/***************************************************************************
 # Copyright (c) 2020, NVIDIA CORPORATION. All rights reserved.
 #
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions
 # are met:
 #  * Redistributions of source code must retain the above copyright
 #    notice, this list of conditions and the following disclaimer.
 #  * Redistributions in binary form must reproduce the above copyright
 #    notice, this list of conditions and the following disclaimer in the
 #    documentation and/or other materials provided with the distribution.
 #  * Neither the name of NVIDIA CORPORATION nor the names of its
 #    contributors may be used to endorse or promote products derived
 #    from this software without specific prior written permission.
 #
 # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
 # EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 # IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 # PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 # CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 # EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 # PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 # PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 **************************************************************************/

//#include "Falcor/stdafx.h"
#include "Scene.h"
#include "HitInfo.h"
#include "Importer.h"

#include "Raytracing/RtProgram/RtProgram.h"
#include "Raytracing/RtProgramVars.h"

#include "Falcor/Utils/Debug/debug.h"

#include <sstream>
#include <numeric>

namespace Falcor {

static_assert(sizeof(MeshDesc) % 16 == 0, "MeshDesc size should be a multiple of 16");
static_assert(sizeof(PackedStaticVertexData) % 16 == 0, "PackedStaticVertexData size should be a multiple of 16");
static_assert(sizeof(PackedMeshInstanceData) % 16 == 0, "PackedMeshInstanceData size should be a multiple of 16");
static_assert(sizeof(ProceduralPrimitiveData) % 16 == 0, "ProceduralPrimitiveData size should be a multiple of 16");
static_assert(PackedMeshInstanceData::kMatrixBits + PackedMeshInstanceData::kMeshBits + PackedMeshInstanceData::kFlagsBits + PackedMeshInstanceData::kMaterialBits <= 64);

namespace {
    // Large scenes are split into multiple BLAS groups in order to reduce build memory usage.
    // The target is max 0.5GB intermediate memory per BLAS group. Note that this is not a strict limit.
    const size_t kMaxBLASBuildMemory = 1ull << 29;

    const std::string kParameterBlockName = "gScene";
    const std::string kMeshBufferName = "meshes";
    const std::string kMeshInstanceBufferName = "meshInstances";
    const std::string kIndexBufferName = "indexData";
    const std::string kVertexBufferName = "vertices";
    const std::string kPrevVertexBufferName = "prevVertices";
    const std::string kProceduralPrimBufferName = "proceduralPrimitives";
    const std::string kProceduralPrimAABBBufferName = "proceduralPrimitiveAABBs";
    const std::string kCurveBufferName = "curves";
    const std::string kCurveInstanceBufferName = "curveInstances";
    const std::string kCurveIndexBufferName = "curveIndices";
    const std::string kCurveVertexBufferName = "curveVertices";
    const std::string kCurvePrevVertexBufferName = "curvePrevVertices";
    const std::string kMaterialsBufferName = "materials";
    const std::string kLightsBufferName = "lights";
    const std::string kVolumesBufferName = "volumes";

    const std::string kStats = "stats";
    const std::string kBounds = "bounds";
    const std::string kAnimations = "animations";
    const std::string kLoopAnimations = "loopAnimations";
    const std::string kCamera = "camera";
    const std::string kCameras = "cameras";
    const std::string kCameraSpeed = "cameraSpeed";
    const std::string kLights = "lights";
    const std::string kAnimated = "animated";
    const std::string kRenderSettings = "renderSettings";
    const std::string kEnvMap = "envMap";
    const std::string kMaterials = "materials";
    const std::string kVolumes = "volumes";
    const std::string kGetLight = "getLight";
    const std::string kGetMaterial = "getMaterial";
    const std::string kGetVolume = "getVolume";
    const std::string kSetEnvMap = "setEnvMap";
    const std::string kAddViewpoint = "addViewpoint";
    const std::string kRemoveViewpoint = "kRemoveViewpoint";
    const std::string kSelectViewpoint = "selectViewpoint";

    // Checks if the transform flips the coordinate system handedness (its determinant is negative).
    bool doesTransformFlip(const glm::mat4& m) {
        return glm::determinant((glm::mat3)m) < 0.f;
    }
}


#ifdef FALCOR_VK
typedef struct D3D12_DRAW_INDEXED_ARGUMENTS {
    unsigned int IndexCountPerInstance;
    unsigned int InstanceCount;
    unsigned int StartIndexLocation;
    int BaseVertexLocation;
    unsigned int StartInstanceLocation;
} D3D12_DRAW_INDEXED_ARGUMENTS;


typedef struct D3D12_DRAW_ARGUMENTS {
    unsigned int VertexCountPerInstance;
    unsigned int InstanceCount;
    unsigned int StartVertexLocation;
    unsigned int StartInstanceLocation;
} D3D12_DRAW_ARGUMENTS;

#define D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BYTE_ALIGNMENT 256

#endif


const FileDialogFilterVec& Scene::getFileExtensionFilters() {
    return Importer::getFileExtensionFilters();
}

Scene::Scene(std::shared_ptr<Device> pDevice): mpDevice(pDevice) {
    mpFrontClockwiseRS = RasterizerState::create(RasterizerState::Desc().setFrontCounterCW(false));
}

Scene::SharedPtr Scene::create(std::shared_ptr<Device> pDevice, const std::string& filename) {
    assert(pDevice);
    auto pBuilder = SceneBuilder::create(pDevice, filename);
    return pBuilder ? pBuilder->getScene() : nullptr;
}

Scene::SharedPtr Scene::create(std::shared_ptr<Device> pDevice) {
    assert(pDevice);
    return Scene::SharedPtr(new Scene(pDevice));
}

Shader::DefineList Scene::getSceneDefines() const {
    Shader::DefineList defines;
    defines.add("SCENE_MATERIAL_COUNT", std::to_string(mMaterials.size()));
    defines.add("SCENE_GRID_COUNT", std::to_string(mGrids.size()));
    defines.add("SCENE_HAS_INDEXED_VERTICES", hasIndexBuffer() ? "1" : "0");
    defines.add("SCENE_HAS_16BIT_INDICES", mHas16BitIndices ? "1" : "0");
    defines.add("SCENE_HAS_32BIT_INDICES", mHas32BitIndices ? "1" : "0");
    defines.add(mHitInfo.getDefines());
    return defines;
}

const LightCollection::SharedPtr& Scene::getLightCollection(RenderContext* pContext) {
    if (!mpLightCollection) {
        mpLightCollection = LightCollection::create(pContext, shared_from_this());
        mpLightCollection->setShaderData(mpSceneBlock["lightCollection"]);

        mSceneStats.emissiveMemoryInBytes = mpLightCollection->getMemoryUsageInBytes();
    }
    return mpLightCollection;
}

void Scene::rasterize(RenderContext* pContext, GraphicsState* pState, GraphicsVars* pVars, RenderFlags flags) {
    PROFILE("rasterizeScene");

    pVars->setParameterBlock("gScene", mpSceneBlock);

    bool overrideRS = !is_set(flags, RenderFlags::UserRasterizerState);
    auto pCurrentRS = pState->getRasterizerState();
    bool isIndexed = hasIndexBuffer();

    for (const auto& draw : mDrawArgs) {
        assert(draw.count > 0);

        // Set state.
        pState->setVao(draw.ibFormat == ResourceFormat::R16Uint ? mpVao16Bit : mpVao);

        if (overrideRS) {
            if (draw.ccw) pState->setRasterizerState(nullptr);
            else pState->setRasterizerState(mpFrontClockwiseRS);
        }

        // Draw the primitives.
        if (isIndexed) {
            pContext->drawIndexedIndirect(pState, pVars, draw.count, draw.pBuffer.get(), 0, nullptr, 0);
        } else {
            pContext->drawIndirect(pState, pVars, draw.count, draw.pBuffer.get(), 0, nullptr, 0);
        }
    }

    if (overrideRS) pState->setRasterizerState(pCurrentRS);
}

void Scene::raytrace(RenderContext* pContext, RtProgram* pProgram, const std::shared_ptr<RtProgramVars>& pVars, uint3 dispatchDims) {
    PROFILE(mpDevice, "raytraceScene");

    auto rayTypeCount = pProgram->getHitProgramCount();
    setRaytracingShaderData(pContext, pVars->getRootVar(), rayTypeCount);

    // If not set yet, set geometry indices for this RtProgramVars.
    if (pVars->getSceneForGeometryIndices().get() != this) {
        setGeometryIndexIntoRtVars(pVars);
        pVars->setSceneForGeometryIndices(shared_from_this());
    }

    // Set ray type constant.
    pVars->getRootVar()["DxrPerFrame"]["hitProgramCount"] = rayTypeCount;

    pContext->raytrace(pProgram, pVars.get(), dispatchDims.x, dispatchDims.y, dispatchDims.z);
}
    
void Scene::initResources() {
   GraphicsProgram::SharedPtr pProgram = GraphicsProgram::createFromFile("Scene/SceneBlock.slang", "", "main", getSceneDefines());
    ParameterBlockReflection::SharedConstPtr pReflection = pProgram->getReflector()->getParameterBlock(kParameterBlockName);
    assert(pReflection);

    mpSceneBlock = ParameterBlock::create(pReflection);
    mpMeshesBuffer = Buffer::createStructured(mpSceneBlock[kMeshBufferName], (uint32_t)mMeshDesc.size(), Resource::BindFlags::ShaderResource, Buffer::CpuAccess::None, nullptr, false);
    mpMeshesBuffer->setName("Scene::mpMeshesBuffer");
    mpMeshInstancesBuffer = Buffer::createStructured(mpSceneBlock[kMeshInstanceBufferName], (uint32_t)mMeshInstanceData.size(), Resource::BindFlags::ShaderResource, Buffer::CpuAccess::None, nullptr, false);
    mpMeshInstancesBuffer->setName("Scene::mpMeshInstancesBuffer");

    if (!mProceduralPrimData.empty()) {
        // Create buffer to be used in BLAS creation. This is also bound to the scene for lookup in shaders
        // Requires unordered access and will be in Non-Pixel Shader Resource state.
        mpRtAABBBuffer = Buffer::createStructured(sizeof(D3D12_RAYTRACING_AABB), (uint32_t)mRtAABBRaw.size());
        mpRtAABBBuffer->setName("Scene::mpRtAABBBuffer");

        mpProceduralPrimitivesBuffer = Buffer::createStructured(mpSceneBlock[kProceduralPrimBufferName], (uint32_t)mProceduralPrimData.size(), Resource::BindFlags::ShaderResource, Buffer::CpuAccess::None, nullptr, false);
        mpProceduralPrimitivesBuffer->setName("Scene::mpProceduralPrimBuffer");
    }

    if (!mCurveDesc.empty()) {
        mpCurvesBuffer = Buffer::createStructured(mpSceneBlock[kCurveBufferName], (uint32_t)mCurveDesc.size(), Resource::BindFlags::ShaderResource, Buffer::CpuAccess::None, nullptr, false);
        mpCurvesBuffer->setName("Scene::mpCurvesBuffer");
        mpCurveInstancesBuffer = Buffer::createStructured(mpSceneBlock[kCurveInstanceBufferName], (uint32_t)mCurveInstanceData.size(), Resource::BindFlags::ShaderResource, Buffer::CpuAccess::None, nullptr, false);
        mpCurveInstancesBuffer->setName("Scene::mpCurveInstancesBuffer");
    }

    mpMaterialsBuffer = Buffer::createStructured(mpSceneBlock[kMaterialsBufferName], (uint32_t)mMaterials.size(), Resource::BindFlags::ShaderResource, Buffer::CpuAccess::None, nullptr, false);
    mpMaterialsBuffer->setName("Scene::mpMaterialsBuffer");

    if (!mLights.empty()) {
        mpLightsBuffer = Buffer::createStructured(mpSceneBlock[kLightsBufferName], (uint32_t)mLights.size(), Resource::BindFlags::ShaderResource, Buffer::CpuAccess::None, nullptr, false);
        mpLightsBuffer->setName("Scene::mpLightsBuffer");
    }

    if (!mVolumes.empty()) {
        mpVolumesBuffer = Buffer::createStructured(mpSceneBlock[kVolumesBufferName], (uint32_t)mVolumes.size(), Resource::BindFlags::ShaderResource, Buffer::CpuAccess::None, nullptr, false);
        mpVolumesBuffer->setName("Scene::mpVolumesBuffer");
    }
}

void Scene::uploadResources() {
    assert(mpAnimationController);

    // Upload geometry
    mpMeshesBuffer->setBlob(mMeshDesc.data(), 0, sizeof(MeshDesc) * mMeshDesc.size());
    if (!mCurveDesc.empty()) mpCurvesBuffer->setBlob(mCurveDesc.data(), 0, sizeof(CurveDesc) * mCurveDesc.size());

    mpSceneBlock->setBuffer(kMeshInstanceBufferName, mpMeshInstancesBuffer);
    mpSceneBlock->setBuffer(kMeshBufferName, mpMeshesBuffer);
    mpSceneBlock->setBuffer(kProceduralPrimBufferName, mpProceduralPrimitivesBuffer);
    mpSceneBlock->setBuffer(kProceduralPrimAABBBufferName, mpRtAABBBuffer);
    mpSceneBlock->setBuffer(kCurveInstanceBufferName, mpCurveInstancesBuffer);
    mpSceneBlock->setBuffer(kCurveBufferName, mpCurvesBuffer);
    mpSceneBlock->setBuffer(kLightsBufferName, mpLightsBuffer);
    mpSceneBlock->setBuffer(kVolumesBufferName, mpVolumesBuffer);
    mpSceneBlock->setBuffer(kMaterialsBufferName, mpMaterialsBuffer);
    if (hasIndexBuffer()) mpSceneBlock->setBuffer(kIndexBufferName, mpVao->getIndexBuffer());
    mpSceneBlock->setBuffer(kVertexBufferName, mpVao->getVertexBuffer(Scene::kStaticDataBufferIndex));
    mpSceneBlock->setBuffer(kPrevVertexBufferName, mpAnimationController->getPrevVertexData()); // Can be nullptr

    if (mpCurveVao != nullptr) {
        mpSceneBlock->setBuffer(kCurveIndexBufferName, mpCurveVao->getIndexBuffer());
        mpSceneBlock->setBuffer(kCurveVertexBufferName, mpCurveVao->getVertexBuffer(Scene::kStaticDataBufferIndex));
    }
}

// TODO: On initial upload of materials, we could improve this by not having separate calls to setElement()
// but instead prepare a buffer containing all data.
void Scene::uploadMaterial(uint32_t materialID)
{
    assert(materialID < mMaterials.size());

    const auto& material = mMaterials[materialID];

    mpMaterialsBuffer->setElement(materialID, material->getData());

    const auto& resources = material->getResources();

    auto var = mpSceneBlock["materialResources"][materialID];

#define set_texture(texName) var[#texName] = resources.texName;
    set_texture(baseColor);
    set_texture(specular);
    set_texture(roughness);
    set_texture(emissive);
    set_texture(normalMap);
    set_texture(occlusionMap);
#undef set_texture

    var["samplerState"] = resources.samplerState;
}

void Scene::uploadSelectedCamera() {
    getCamera()->setShaderData(mpSceneBlock[kCamera]);
}

void Scene::updateBounds() {
    const auto& globalMatrices = mpAnimationController->getGlobalMatrices();

    mSceneBB = AABB();
    for (const auto& inst : mMeshInstanceData) {
        const AABB& meshBB = mMeshBBs[inst.meshID];
        const glm::mat4& transform = globalMatrices[inst.globalMatrixID];
        mSceneBB |= meshBB.transform(transform);
    }

    for (const auto& aabb : mCustomPrimitiveAABBs) {
        mSceneBB |= aabb;
    }

    for (const auto& inst : mCurveInstanceData) {
        const AABB& curveBB = mCurveBBs[inst.curveID];
        const glm::mat4& transform = globalMatrices[inst.globalMatrixID];
        mSceneBB |= curveBB.transform(transform);
    }

    for (const auto& volume : mVolumes) {
        mSceneBB |= volume->getBounds();
    }
}

void Scene::updateMeshInstances(bool forceUpdate) {
    bool dataChanged = false;
    const auto& globalMatrices = mpAnimationController->getGlobalMatrices();

    for (auto& inst : mMeshInstanceData) {
        uint32_t prevFlags = inst.flags;

        const glm::mat4& transform = globalMatrices[inst.globalMatrixID];
        bool isTransformFlipped = doesTransformFlip(transform);
        bool isObjectFrontFaceCW = getMesh(inst.meshID).isFrontFaceCW();
        bool isWorldFrontFaceCW = isObjectFrontFaceCW ^ isTransformFlipped;

        if (isTransformFlipped) inst.flags |= (uint32_t)MeshInstanceFlags::TransformFlipped;
        else inst.flags &= ~(uint32_t)MeshInstanceFlags::TransformFlipped;

        if (isObjectFrontFaceCW) inst.flags |= (uint32_t)MeshInstanceFlags::IsObjectFrontFaceCW;
        else inst.flags &= ~(uint32_t)MeshInstanceFlags::IsObjectFrontFaceCW;

        if (isWorldFrontFaceCW) inst.flags |= (uint32_t)MeshInstanceFlags::IsWorldFrontFaceCW;
        else inst.flags &= ~(uint32_t)MeshInstanceFlags::IsWorldFrontFaceCW;

        dataChanged |= (inst.flags != prevFlags);
    }

    if (forceUpdate || dataChanged) {
        // Make sure the scene data fits in the packed format.
        size_t maxMatrices = 1 << PackedMeshInstanceData::kMatrixBits;
        if (globalMatrices.size() > maxMatrices) {
            throw std::exception(("Number of transform matrices (" + std::to_string(globalMatrices.size()) + ") exceeds the maximum (" + std::to_string(maxMatrices) + ").").c_str());
        }

        size_t maxMeshes = 1 << PackedMeshInstanceData::kMeshBits;
        if (getMeshCount() > maxMeshes) {
            throw std::exception(("Number of meshes (" + std::to_string(getMeshCount()) + ") exceeds the maximum (" + std::to_string(maxMeshes) + ").").c_str());
        }

        size_t maxMaterials = 1 << PackedMeshInstanceData::kMaterialBits;
        if (mMaterials.size() > maxMaterials) {
            throw std::exception(("Number of materials (" + std::to_string(mMaterials.size()) + ") exceeds the maximum (" + std::to_string(maxMaterials) + ").").c_str());
        }

        // Prepare packed mesh instance data.
        assert(mMeshInstanceData.size() > 0);
        mPackedMeshInstanceData.resize(mMeshInstanceData.size());

        for (size_t i = 0; i < mMeshInstanceData.size(); i++) {
            mPackedMeshInstanceData[i].pack(mMeshInstanceData[i]);
        }

        size_t byteSize = sizeof(PackedMeshInstanceData) * mPackedMeshInstanceData.size();
        assert(mpMeshInstancesBuffer && mpMeshInstancesBuffer->getSize() == byteSize);
        mpMeshInstancesBuffer->setBlob(mPackedMeshInstanceData.data(), 0, byteSize);
    }
}

void Scene::updateProceduralPrimitives(bool forceUpdate) {
    if (mProceduralPrimData.empty()) return;

    if (forceUpdate) {
        size_t bytes = sizeof(ProceduralPrimitiveData) * mProceduralPrimData.size();
        assert(mpProceduralPrimitivesBuffer && mpProceduralPrimitivesBuffer->getSize() == bytes);
        mpProceduralPrimitivesBuffer->setBlob(mProceduralPrimData.data(), 0, bytes);
        mpRtAABBBuffer->setBlob(mRtAABBRaw.data(), 0, sizeof(D3D12_RAYTRACING_AABB) * mRtAABBRaw.size());
    }
}

void Scene::updateCurveInstances(bool forceUpdate) {
    if (mCurveInstanceData.empty()) return;

    if (forceUpdate) {
        mpCurveInstancesBuffer->setBlob(mCurveInstanceData.data(), 0, sizeof(CurveInstanceData) * mCurveInstanceData.size());
    }
}


void Scene::finalize() {
    assert(mHas16BitIndices || mHas32BitIndices);
    mHitInfo.init(*this);
    initResources();
    mpAnimationController->animate(gpDevice->getRenderContext(), 0); // Requires Scene block to exist
    updateMeshInstances(true);

    updateCurveInstances(true);
    updateProceduralPrimitives(true);

    updateBounds();
    createDrawList();
    if (mCameras.size() == 0) {
        // Create a new camera to use in the event of a scene with no cameras
        mCameras.push_back(Camera::create());
        resetCamera();
    }
    setCameraController(mCamCtrlType);
    initializeCameras();
    uploadSelectedCamera();
    addViewpoint();
    updateLights(true);
    updateVolumes(true);
    updateEnvMap(true);
    updateMaterials(true);
    uploadResources(); // Upload data after initialization is complete
    updateGeometryStats();
    updateMaterialStats();
    updateLightStats();
    updateVolumeStats();
    //prepareUI();
}

void Scene::initializeCameras() {
    for (auto& camera : mCameras) {
        updateAnimatable(*camera, *mpAnimationController, true);
        camera->beginFrame();
    }
}

void Scene::updateGeometryStats() {
    auto& s = mSceneStats;

    s.uniqueVertexCount = 0;
    s.uniqueTriangleCount = 0;
    s.instancedVertexCount = 0;
    s.instancedTriangleCount = 0;

    for (uint32_t meshID = 0; meshID < getMeshCount(); meshID++) {
        const auto& mesh = getMesh(meshID);
        s.uniqueVertexCount += mesh.vertexCount;
        s.uniqueTriangleCount += mesh.getTriangleCount();
    }

    for (uint32_t instanceID = 0; instanceID < getMeshInstanceCount(); instanceID++) {
        const auto& instance = getMeshInstance(instanceID);
        const auto& mesh = getMesh(instance.meshID);
        s.instancedVertexCount += mesh.vertexCount;
        s.instancedTriangleCount += mesh.getTriangleCount();
    }

    s.uniqueCurvePointCount = 0;
    s.uniqueCurveSegmentCount = 0;
    s.instancedCurvePointCount = 0;
    s.instancedCurveSegmentCount = 0;

    for (uint32_t curveID = 0; curveID < getCurveCount(); curveID++) {
        const auto& curve = getCurve(curveID);
        s.uniqueCurvePointCount += curve.vertexCount;
        s.uniqueCurveSegmentCount += curve.getSegmentCount();
    }

    for (uint32_t instanceID = 0; instanceID < getCurveInstanceCount(); instanceID++) {
        const auto& instance = getCurveInstance(instanceID);
        const auto& curve = getCurve(instance.curveID);
        s.instancedCurvePointCount += curve.vertexCount;
        s.instancedCurveSegmentCount += curve.getSegmentCount();
    }

    // Calculate memory usage.
    const auto& pIB = mpVao->getIndexBuffer();
    const auto& pVB = mpVao->getVertexBuffer(kStaticDataBufferIndex);
    const auto& pDrawID = mpVao->getVertexBuffer(kDrawIdBufferIndex);

    s.indexMemoryInBytes = 0;
    s.vertexMemoryInBytes = 0;
    s.geometryMemoryInBytes = 0;
    s.animationMemoryInBytes = 0;

    s.indexMemoryInBytes += pIB ? pIB->getSize() : 0;
    s.vertexMemoryInBytes += pVB ? pVB->getSize() : 0;

    s.curveIndexMemoryInBytes = 0;
    s.curveVertexMemoryInBytes = 0;

    if (mpCurveVao != nullptr) {
        const auto& pCurveIB = mpCurveVao->getIndexBuffer();
        const auto& pCurveVB = mpCurveVao->getVertexBuffer(kStaticDataBufferIndex);

        s.curveIndexMemoryInBytes += pCurveIB ? pCurveIB->getSize() : 0;
        s.curveVertexMemoryInBytes += pCurveVB ? pCurveVB->getSize() : 0;
    }

    s.geometryMemoryInBytes += mpMeshesBuffer ? mpMeshesBuffer->getSize() : 0;
    s.geometryMemoryInBytes += mpMeshInstancesBuffer ? mpMeshInstancesBuffer->getSize() : 0;
    s.geometryMemoryInBytes += mpRtAABBBuffer ? mpRtAABBBuffer->getSize() : 0;
    s.geometryMemoryInBytes += mpProceduralPrimitivesBuffer ? mpProceduralPrimitivesBuffer->getSize() : 0;
    s.geometryMemoryInBytes += pDrawID ? pDrawID->getSize() : 0;
    
    for (const auto& draw : mDrawArgs) {
        assert(draw.pBuffer);
        s.geometryMemoryInBytes += draw.pBuffer->getSize();
    }
    s.geometryMemoryInBytes += mpCurvesBuffer ? mpCurvesBuffer->getSize() : 0;
    s.geometryMemoryInBytes += mpCurveInstancesBuffer ? mpCurveInstancesBuffer->getSize() : 0;

    s.animationMemoryInBytes += getAnimationController()->getMemoryUsageInBytes();
}

void Scene::updateMaterialStats() {
    auto& s = mSceneStats;

    std::set<Texture::SharedPtr> textures;
    for (const auto& m : mMaterials) {
        for (uint32_t i = 0; i < (uint32_t)Material::TextureSlot::Count; i++) {
            const auto& t = m->getTexture((Material::TextureSlot)i);
            if (t) textures.insert(t);
        }
    }

    s.materialCount = mMaterials.size();
    s.materialMemoryInBytes = mpMaterialsBuffer ? mpMaterialsBuffer->getSize() : 0;
    s.textureCount = textures.size();
    s.textureCompressedCount = 0;
    s.textureTexelCount = 0;
    s.textureMemoryInBytes = 0;

    for (const auto& t : textures) {
        s.textureTexelCount += t->getTexelCount();
        s.textureMemoryInBytes += t->getTextureSizeInBytes();
        if (isCompressedFormat(t->getFormat())) s.textureCompressedCount++;
    }
}

void Scene::updateRaytracingBLASStats() {
    auto& s = mSceneStats;

    s.blasGroupCount = mBlasGroups.size();
    s.blasCount = mBlasData.size();
    s.blasCompactedCount = 0;
    s.blasMemoryInBytes = 0;
    s.blasScratchMemoryInBytes = 0;

    for (const auto& blas : mBlasData) {
        if (blas.useCompaction) s.blasCompactedCount++;
        s.blasMemoryInBytes += blas.blasByteSize;
    }
    if (mpBlasScratch) s.blasScratchMemoryInBytes += mpBlasScratch->getSize();
    if (mpBlasStaticWorldMatrices) s.blasScratchMemoryInBytes += mpBlasStaticWorldMatrices->getSize();
}

void Scene::updateRaytracingTLASStats() {
    auto& s = mSceneStats;

    s.tlasCount = 0;
    s.tlasMemoryInBytes = 0;
    s.tlasScratchMemoryInBytes = 0;

    for (const auto& [i, tlas] : mTlasCache) {
        if (tlas.pTlas) {
            s.tlasMemoryInBytes += tlas.pTlas->getSize();
            s.tlasCount++;
        }
        if (tlas.pInstanceDescs) s.tlasScratchMemoryInBytes += tlas.pInstanceDescs->getSize();
    }
    if (mpTlasScratch) s.tlasScratchMemoryInBytes += mpTlasScratch->getSize();
}

void Scene::updateLightStats() {
    auto& s = mSceneStats;

    s.activeLightCount = 0;
    s.totalLightCount = 0;
    s.pointLightCount = 0;
    s.directionalLightCount = 0;
    s.rectLightCount = 0;
    s.sphereLightCount = 0;
    s.distantLightCount = 0;

    for (const auto& light : mLights) {
        if (light->isActive()) s.activeLightCount++;
        s.totalLightCount++;

        switch (light->getType()) {
            case LightType::Point:
                s.pointLightCount++;
                break;
            case LightType::Directional:
                s.directionalLightCount++;
                break;
            case LightType::Rect:
                s.rectLightCount++;
                break;
            case LightType::Sphere:
                s.sphereLightCount++;
                break;
            case LightType::Distant:
                s.distantLightCount++;
                break;
        }
    }

    s.lightsMemoryInBytes = mpLightsBuffer ? mpLightsBuffer->getSize() : 0;
}

void Scene::updateVolumeStats() {
    auto& s = mSceneStats;

    s.volumeCount = mVolumes.size();
    s.volumeMemoryInBytes = mpVolumesBuffer ? mpVolumesBuffer->getSize() : 0;

    s.gridCount = mGrids.size();
    s.gridVoxelCount = 0;
    s.gridMemoryInBytes = 0;

    for (const auto& g : mGrids) {
        s.gridVoxelCount += g->getVoxelCount();
        s.gridMemoryInBytes += g->getGridSizeInBytes();
    }
}

bool Scene::updateAnimatable(Animatable& animatable, const AnimationController& controller, bool force) {
    uint32_t nodeID = animatable.getNodeID();

    // It is possible for this to be called on an object with no associated node in the scene graph (kInvalidNode),
    // e.g. non-animated lights. This check ensures that we return immediately instead of trying to check
    // matrices for a non-existent node.
    if (nodeID == kInvalidNode) return false;

    if (force || (animatable.hasAnimation() && animatable.isAnimated())) {
        if (!controller.isMatrixChanged(nodeID) && !force) return false;

        glm::mat4 transform = controller.getGlobalMatrices()[nodeID];
        animatable.updateFromAnimation(transform);
        return true;
    }
    return false;
}

Scene::UpdateFlags Scene::updateSelectedCamera(bool forceUpdate) {
    auto camera = mCameras[mSelectedCamera];

    if (forceUpdate || (camera->hasAnimation() && camera->isAnimated())) {
        updateAnimatable(*camera, *mpAnimationController, forceUpdate);
    } else {
        mpCamCtrl->update();
    }

    UpdateFlags flags = UpdateFlags::None;
    auto cameraChanges = camera->beginFrame();

    if (mCameraSwitched || cameraChanges != Camera::Changes::None) {
        uploadSelectedCamera();
        if (is_set(cameraChanges, Camera::Changes::Movement)) flags |= UpdateFlags::CameraMoved;
        if ((cameraChanges & (~Camera::Changes::Movement)) != Camera::Changes::None) flags |= UpdateFlags::CameraPropertiesChanged;
        if (mCameraSwitched) flags |= UpdateFlags::CameraSwitched;
    }
    mCameraSwitched = false;
    return flags;
}

Scene::UpdateFlags Scene::updateLights(bool forceUpdate) {
    Light::Changes combinedChanges = Light::Changes::None;

    // Animate lights and get list of changes.
    for (const auto& light : mLights) {
        updateAnimatable(*light, *mpAnimationController, forceUpdate);
        auto changes = light->beginFrame();
        combinedChanges |= changes;
    }

    // Update changed lights.
    uint32_t lightCount = 0;

    for (const auto& light : mLights) {
        if (!light->isActive()) continue;
        auto changes = light->getChanges();

        if (changes != Light::Changes::None || is_set(combinedChanges, Light::Changes::Active) || forceUpdate) {
            // TODO: This is slow since the buffer is not CPU writable. Copy into CPU buffer and upload once instead.
            mpLightsBuffer->setElement(lightCount, light->getData());
        }

        lightCount++;
    }

    if (combinedChanges != Light::Changes::None || forceUpdate) {
        mpSceneBlock["lightCount"] = lightCount;
        updateLightStats();
    }

    // Compute update flags.
    UpdateFlags flags = UpdateFlags::None;
    if (is_set(combinedChanges, Light::Changes::Intensity)) flags |= UpdateFlags::LightIntensityChanged;
    if (is_set(combinedChanges, Light::Changes::Position)) flags |= UpdateFlags::LightsMoved;
    if (is_set(combinedChanges, Light::Changes::Direction)) flags |= UpdateFlags::LightsMoved;
    if (is_set(combinedChanges, Light::Changes::Active)) flags |= UpdateFlags::LightCountChanged;
    const Light::Changes otherChanges = ~(Light::Changes::Intensity | Light::Changes::Position | Light::Changes::Direction | Light::Changes::Active);
    if ((combinedChanges & otherChanges) != Light::Changes::None) flags |= UpdateFlags::LightPropertiesChanged;

    return flags;
}

Scene::UpdateFlags Scene::updateVolumes(bool forceUpdate) {
    Volume::UpdateFlags combinedUpdates = Volume::UpdateFlags::None;

    // Update animations and get combined updates.
    for (const auto& volume : mVolumes) {
        updateAnimatable(*volume, *mpAnimationController, forceUpdate);
        combinedUpdates |= volume->getUpdates();
    }

    // Early out if no volumes have changed.
    if (!forceUpdate && combinedUpdates == Volume::UpdateFlags::None) return UpdateFlags::None;

    // Upload grids.
    if (forceUpdate) {
        auto var = mpSceneBlock["grids"];
        for (size_t i = 0; i < mGrids.size(); ++i) {
            mGrids[i]->setShaderData(var[i]);
        }
    }

    // Upload volumes and clear updates.
    uint32_t volumeIndex = 0;
    for (const auto& volume : mVolumes) {
        if (forceUpdate || volume->getUpdates() != Volume::UpdateFlags::None) {
            auto data = volume->getData();
            data.densityGrid = volume->getDensityGrid() ? mGridIDs.at(volume->getDensityGrid()) : kInvalidGrid;
            data.emissionGrid = volume->getEmissionGrid() ? mGridIDs.at(volume->getEmissionGrid()) : kInvalidGrid;
            mpVolumesBuffer->setElement(volumeIndex, data);
        }
        volume->clearUpdates();
        volumeIndex++;
    }

    mpSceneBlock["volumeCount"] = (uint32_t)mVolumes.size();

    UpdateFlags flags = UpdateFlags::None;
    if (is_set(combinedUpdates, Volume::UpdateFlags::TransformChanged)) flags |= UpdateFlags::VolumesMoved;
    if (is_set(combinedUpdates, Volume::UpdateFlags::PropertiesChanged)) flags |= UpdateFlags::VolumePropertiesChanged;
    if (is_set(combinedUpdates, Volume::UpdateFlags::GridsChanged)) flags |= UpdateFlags::VolumeGridsChanged;
    if (is_set(combinedUpdates, Volume::UpdateFlags::BoundsChanged)) flags |= UpdateFlags::VolumeBoundsChanged;

    return flags;
}

Scene::UpdateFlags Scene::updateEnvMap(bool forceUpdate) {
    UpdateFlags flags = UpdateFlags::None;

    if (mpEnvMap) {
        auto envMapChanges = mpEnvMap->beginFrame();
        if (envMapChanges != EnvMap::Changes::None || mEnvMapChanged || forceUpdate) {
            if (envMapChanges != EnvMap::Changes::None) flags |= UpdateFlags::EnvMapPropertiesChanged;
            mpEnvMap->setShaderData(mpSceneBlock[kEnvMap]);
        }
    }
    mSceneStats.envMapMemoryInBytes = mpEnvMap ? mpEnvMap->getMemoryUsageInBytes() : 0;

    if (mEnvMapChanged) {
        flags |= UpdateFlags::EnvMapChanged;
        mEnvMapChanged = false;
    }

    return flags;
}

Scene::UpdateFlags Scene::updateMaterials(bool forceUpdate) {
    UpdateFlags flags = UpdateFlags::None;

    // Early out if no materials have changed
    if (!forceUpdate && Material::getGlobalUpdates() == Material::UpdateFlags::None) return flags;

    for (uint32_t materialId = 0; materialId < (uint32_t)mMaterials.size(); ++materialId)
    {
        auto& material = mMaterials[materialId];
        auto materialUpdates = material->getUpdates();
        if (forceUpdate || materialUpdates != Material::UpdateFlags::None)
        {
            material->clearUpdates();
            uploadMaterial(materialId);
            flags |= UpdateFlags::MaterialsChanged;
        }
    }

    updateMaterialStats();
    Material::clearGlobalUpdates();

    return flags;
}

Scene::UpdateFlags Scene::update(RenderContext* pContext, double currentTime) {
    mUpdates = UpdateFlags::None;
    if (mpAnimationController->animate(pContext, currentTime)) {
        mUpdates |= UpdateFlags::SceneGraphChanged;
        for (const auto& inst : mMeshInstanceData) {
            if (mpAnimationController->isMatrixChanged(inst.globalMatrixID)) {
                mUpdates |= UpdateFlags::MeshesMoved;
            }
        }
    }

    mUpdates |= updateSelectedCamera(false);
    mUpdates |= updateLights(false);
    mUpdates |= updateVolumes(false);
    mUpdates |= updateEnvMap(false);
    mUpdates |= updateMaterials(false);
    pContext->flush();

    if (is_set(mUpdates, UpdateFlags::MeshesMoved)) {
        mTlasCache.clear();
        updateMeshInstances(false);
    }

    // If a transform in the scene changed, update BLASes with skinned meshes
    if (mBlasData.size() && mHasSkinnedMesh && is_set(mUpdates, UpdateFlags::SceneGraphChanged)) {
        mTlasCache.clear();
        buildBlas(pContext);
    }

    // Update light collection
    if (mpLightCollection && mpLightCollection->update(pContext)) {
        mUpdates |= UpdateFlags::LightCollectionChanged;
        mSceneStats.emissiveMemoryInBytes = mpLightCollection->getMemoryUsageInBytes();
    } else if (!mpLightCollection) {
        mSceneStats.emissiveMemoryInBytes = 0;
    }

    if (mRenderSettings != mPrevRenderSettings) {
        mUpdates |= UpdateFlags::RenderSettingsChanged;
        mPrevRenderSettings = mRenderSettings;
    }

    return mUpdates;
}

bool Scene::useEnvBackground() const {
    return mpEnvMap != nullptr;
}

bool Scene::useEnvLight() const {
    return mRenderSettings.useEnvLight && mpEnvMap != nullptr;
}

bool Scene::useAnalyticLights() const {
    return mRenderSettings.useAnalyticLights && mLights.empty() == false;
}

bool Scene::useEmissiveLights() const {
    return mRenderSettings.useEmissiveLights && mpLightCollection != nullptr && mpLightCollection->getActiveLightCount() > 0;
}

bool Scene::useVolumes() const {
    return mRenderSettings.useVolumes && mVolumes.empty() == false;
}

void Scene::setCamera(const Camera::SharedPtr& pCamera) {
    auto it = std::find(mCameras.begin(), mCameras.end(), pCamera);
    if (it != mCameras.end()) {
        selectCamera((uint32_t)std::distance(mCameras.begin(), it));
    } else if (pCamera) {
        logWarning("Selected camera " + pCamera->getName() + " does not exist.");
    }
}

void Scene::selectCamera(uint32_t index) {
    if (index == mSelectedCamera) return;
    if (index >= mCameras.size()) {
        logWarning("Selected camera index " + std::to_string(index) + " is invalid.");
        return;
    }

    mSelectedCamera = index;
    mCameraSwitched = true;
    setCameraController(mCamCtrlType);
}

void Scene::resetCamera(bool resetDepthRange) {
    auto camera = getCamera();
    float radius = mSceneBB.radius();
    camera->setPosition(mSceneBB.center());
    camera->setTarget(mSceneBB.center() + float3(0, 0, -1));
    camera->setUpVector(float3(0, 1, 0));

    if (resetDepthRange) {
        float nearZ = std::max(0.1f, radius / 750.0f);
        float farZ = radius * 50;
        camera->setDepthRange(nearZ, farZ);
    }
}

void Scene::setCameraSpeed(float speed) {
    mCameraSpeed = clamp(speed, 0.f, std::numeric_limits<float>::max());
    mpCamCtrl->setCameraSpeed(speed);
}

void Scene::addViewpoint() {
    auto camera = getCamera();
    addViewpoint(camera->getPosition(), camera->getTarget(), camera->getUpVector(), mSelectedCamera);
}

void Scene::addViewpoint(const float3& position, const float3& target, const float3& up, uint32_t cameraIndex) {
    Viewpoint viewpoint = { cameraIndex, position, target, up };
    mViewpoints.push_back(viewpoint);
    mCurrentViewpoint = (uint32_t)mViewpoints.size() - 1;
}

void Scene::removeViewpoint() {
    if (mCurrentViewpoint == 0) {
        logWarning("Cannot remove default viewpoint");
        return;
    }
    mViewpoints.erase(mViewpoints.begin() + mCurrentViewpoint);
    mCurrentViewpoint = std::min(mCurrentViewpoint, (uint32_t)mViewpoints.size() - 1);
}

void Scene::selectViewpoint(uint32_t index) {
    if (index >= mViewpoints.size()) {
        logWarning("Viewpoint does not exist");
        return;
    }

    auto& viewpoint = mViewpoints[index];
    selectCamera(viewpoint.index);
    auto camera = getCamera();
    camera->setPosition(viewpoint.position);
    camera->setTarget(viewpoint.target);
    camera->setUpVector(viewpoint.up);
    mCurrentViewpoint = index;
}

Material::SharedPtr Scene::getMaterialByName(const std::string& name) const {
    for (const auto& m : mMaterials) {
        if (m->getName() == name) return m;
    }

    return nullptr;
}

Volume::SharedPtr Scene::getVolumeByName(const std::string& name) const {
    for (const auto& v : mVolumes) {
        if (v->getName() == name) return v;
    }

    return nullptr;
}

Light::SharedPtr Scene::getLightByName(const std::string& name) const {
    for (const auto& l : mLights) {
        if (l->getName() == name) return l;
    }

    return nullptr;
}

void Scene::toggleAnimations(bool animate) {
    for (auto& light : mLights) light->setIsAnimated(animate);
    for (auto& camera : mCameras) camera->setIsAnimated(animate);
    mpAnimationController->setEnabled(animate);
}

void Scene::setBlasUpdateMode(UpdateMode mode) {
    if (mode != mBlasUpdateMode) mRebuildBlas = true;
    mBlasUpdateMode = mode;
}
    
void Scene::createDrawList() {
    assert(mDrawArgs.empty());
    auto pMatricesBuffer = mpSceneBlock->getBuffer("worldMatrices");
    const glm::mat4* matrices = (glm::mat4*)pMatricesBuffer->map(Buffer::MapType::Read); // #SCENEV2 This will cause the pipeline to flush and sync, but it's probably not too bad as this only happens once

    // Helper to create the draw-indirect buffer.
    auto createDrawBuffer = [this](const auto& drawMeshes, bool ccw, ResourceFormat ibFormat = ResourceFormat::Unknown) {
        if (drawMeshes.size() > 0) {
            DrawArgs draw;
            draw.pBuffer = Buffer::create(sizeof(drawMeshes[0]) * drawMeshes.size(), Resource::BindFlags::IndirectArg, Buffer::CpuAccess::None, drawMeshes.data());
            draw.pBuffer->setName("Scene draw buffer");
            assert(drawMeshes.size() <= std::numeric_limits<uint32_t>::max());
            draw.count = (uint32_t)drawMeshes.size();
            draw.ccw = ccw;
            draw.ibFormat = ibFormat;
            mDrawArgs.push_back(draw);
        }
    };

    if (hasIndexBuffer()) {
        std::vector<D3D12_DRAW_INDEXED_ARGUMENTS> drawClockwiseMeshes[2], drawCounterClockwiseMeshes[2];

        uint32_t instanceID = 0;
        for (const auto& instance : mMeshInstanceData) {
            const auto& mesh = mMeshDesc[instance.meshID];
            const auto& transform = matrices[instance.globalMatrixID];
            bool use16Bit = mesh.use16BitIndices();

            D3D12_DRAW_INDEXED_ARGUMENTS draw;
            draw.IndexCountPerInstance = mesh.indexCount;
            draw.InstanceCount = 1;
            draw.StartIndexLocation = mesh.ibOffset * (use16Bit ? 2 : 1);
            draw.BaseVertexLocation = mesh.vbOffset;
            draw.StartInstanceLocation = instanceID++;

            int i = use16Bit ? 0 : 1;
            (doesTransformFlip(transform)) ? drawClockwiseMeshes[i].push_back(draw) : drawCounterClockwiseMeshes[i].push_back(draw);
        }

        createDrawBuffer(drawClockwiseMeshes[0], false, ResourceFormat::R16Uint);
        createDrawBuffer(drawClockwiseMeshes[1], false, ResourceFormat::R32Uint);
        createDrawBuffer(drawCounterClockwiseMeshes[0], true, ResourceFormat::R16Uint);
        createDrawBuffer(drawCounterClockwiseMeshes[1], true, ResourceFormat::R32Uint);
    } else {
        std::vector<D3D12_DRAW_ARGUMENTS> drawClockwiseMeshes, drawCounterClockwiseMeshes;

        uint32_t instanceID = 0;
        for (const auto& instance : mMeshInstanceData) {
            const auto& mesh = mMeshDesc[instance.meshID];
            const auto& transform = matrices[instance.globalMatrixID];
            assert(mesh.indexCount == 0);

            D3D12_DRAW_ARGUMENTS draw;
            draw.VertexCountPerInstance = mesh.vertexCount;
            draw.InstanceCount = 1;
            draw.StartVertexLocation = mesh.vbOffset;
            draw.StartInstanceLocation = instanceID++;

            (doesTransformFlip(transform)) ? drawClockwiseMeshes.push_back(draw) : drawCounterClockwiseMeshes.push_back(draw);
        }

        createDrawBuffer(drawClockwiseMeshes, false);
        createDrawBuffer(drawCounterClockwiseMeshes, true);
    }
}


    void Scene::initGeomDesc() {
        assert(mBlasData.empty());

        const VertexBufferLayout::SharedConstPtr& pVbLayout = mpVao->getVertexLayout()->getBufferLayout(kStaticDataBufferIndex);
        const Buffer::SharedPtr& pVb = mpVao->getVertexBuffer(kStaticDataBufferIndex);
        const Buffer::SharedPtr& pIb = mpVao->getIndexBuffer();

        assert(mMeshGroups.size() > 0);
        mBlasData.resize(mMeshGroups.size());
        mRebuildBlas = true;
        mHasSkinnedMesh = false;

        for (size_t i = 0; i < mBlasData.size(); i++) {

            const auto& meshList = mMeshGroups[i].meshList;
            auto& blas = mBlasData[i];
            auto& geomDescs = blas.geomDescs;
            geomDescs.resize(meshList.size());

            for (size_t j = 0; j < meshList.size(); j++) {
                const MeshDesc& mesh = mMeshDesc[meshList[j]];
                blas.hasSkinnedMesh |= mMeshHasDynamicData[meshList[j]];

                VkAccelerationStructureGeometryKHR& desc = geomDescs[j];
                desc.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR;
                desc.geometryType = VK_GEOMETRY_TYPE_TRIANGLES_KHR;

                desc.geometry.triangles.transformData.deviceAddress = 0;
                desc.geometry.triangles.transformData.hostAddress = nullptr;

                // If this is an opaque mesh, set the opaque flag
                const auto& material = mMaterials[mesh.materialID];
                bool opaque = material->getAlphaMode() == AlphaModeOpaque;
                desc.flags = opaque ? VK_GEOMETRY_OPAQUE_BIT_KHR : VK_GEOMETRY_OPAQUE_BIT_KHR;

                // Set the position data
                desc.geometry.triangles.vertexData.deviceAddress = pVb->getGpuAddress() + (mesh.vbOffset * pVbLayout->getStride());
                desc.geometry.triangles.vertexData.hostAddress = nullptr;
                desc.geometry.triangles.vertexStride = pVbLayout->getStride();
                desc.geometry.triangles.maxVertex = mesh.vertexCount;
                desc.geometry.triangles.vertexFormat = getVkFormat(pVbLayout->getElementFormat(0));

                // Set index data
                if (pIb) {
                    desc.geometry.triangles.indexData.deviceAddress = pIb->getGpuAddress() + (mesh.ibOffset * getFormatBytesPerBlock(mpVao->getIndexBufferFormat()));
                    desc.geometry.triangles.indexData.hostAddress = nullptr;
                    //desc.geometry.triangles.IndexCount = mesh.indexCount;
                    desc.geometry.triangles.indexType = getVkIndexType(mpVao->getIndexBufferFormat());
                } else {
                    assert(mesh.indexCount == 0);
                    desc.geometry.triangles.indexData.deviceAddress = 0;
                    desc.geometry.triangles.indexData.hostAddress = nullptr;
                    //desc.geometry.triangles.IndexCount = 0;
                    desc.geometry.triangles.indexType = VK_INDEX_TYPE_NONE_KHR;
                }
            }

            mHasSkinnedMesh |= blas.hasSkinnedMesh;
        }
    }

    
    void Scene::buildBlas(RenderContext* pContext) {
        PROFILE(mpDevice, "buildBlas");

        // Add barriers for the VB and IB which will be accessed by the build.
        const Buffer::SharedPtr& pVb = mpVao->getVertexBuffer(kStaticDataBufferIndex);
        const Buffer::SharedPtr& pIb = mpVao->getIndexBuffer();
        pContext->resourceBarrier(pVb.get(), Resource::State::NonPixelShader);
        if (pIb) pContext->resourceBarrier(pIb.get(), Resource::State::NonPixelShader);

        // On the first time, or if a full rebuild is necessary we will:
        // - Update all build inputs and prebuild info
        // - Calculate total intermediate buffer sizes
        // - Build all BLASes into an intermediate buffer
        // - Calculate total compacted buffer size
        // - Compact/clone all BLASes to their final location
        if (mRebuildBlas) {
            uint64_t totalMaxBlasSize = 0;
            uint64_t totalScratchSize = 0;

            for (auto& blas : mBlasData) {
                // Determine how BLAS build/update should be done.
                // The default choice is to compact all static BLASes and those that don't need to be rebuilt every frame. For those compaction just adds overhead.
                // TODO: Add compaction on/off switch for profiling.
                // TODO: Disable compaction for skinned meshes if update performance becomes a problem.
                blas.updateMode = mBlasUpdateMode;
                blas.useCompaction = !blas.hasSkinnedMesh || blas.updateMode != UpdateMode::Rebuild;

                // Setup build parameters.
                VkAccelerationStructureBuildGeometryInfoKHR& inputs = blas.buildInputs;
                inputs.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR;
                inputs.type = VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR;
                inputs.geometryCount = (uint32_t)blas.geomDescs.size();
                inputs.pGeometries = blas.geomDescs.data();
                inputs.flags = VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR;

                // Add necessary flags depending on settings.
                if (blas.useCompaction) {
                    inputs.flags |= VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR;
                }

                if (blas.hasSkinnedMesh && blas.updateMode == UpdateMode::Refit) {
                    inputs.flags |= VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR;
                }

                // Set optional performance hints.
                // TODO: Set FAST_BUILD for skinned meshes if update/rebuild performance becomes a problem.
                // TODO: Add FAST_TRACE on/off switch for profiling. It is disabled by default as it is scene-dependent.
                if (!blas.hasSkinnedMesh) {
                    inputs.flags |= VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR;
                }

                // Get prebuild info.
                //GET_COM_INTERFACE(gpDevice->getApiHandle(), ID3D12Device5, pDevice5);
                //pDevice5->GetRaytracingAccelerationStructurePrebuildInfo(&inputs, &blas.prebuildInfo);
                VkAccelerationStructureBuildSizesInfoKHR accelerationStructureBuildSizesInfo {};
                accelerationStructureBuildSizesInfo.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR;

                vkGetAccelerationStructureBuildSizesKHR(mpDevice->getApiHandle(), VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR, &blas.prebuildInfo,
            &numTriangles,
            &accelerationStructureBuildSizesInfo);


                // Figure out the padded allocation sizes to have proper alignement.
                uint64_t paddedMaxBlasSize = align_to(D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BYTE_ALIGNMENT, blas.prebuildInfo.accelerationStructureSize);
                blas.blasByteOffset = totalMaxBlasSize;
                totalMaxBlasSize += paddedMaxBlasSize;

                uint64_t scratchSize = std::max(blas.prebuildInfo.buildScratchSize, blas.prebuildInfo.updateScratchSize);
                uint64_t paddedScratchSize = align_to(D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BYTE_ALIGNMENT, scratchSize);
                blas.scratchByteOffset = totalScratchSize;
                totalScratchSize += paddedScratchSize;
            }

            // Allocate intermediate buffers and scratch buffer.
            // The scratch buffer we'll retain because it's needed for subsequent rebuilds and updates.
            // TODO: Save memory by reducing the scratch buffer to the minimum required for the dynamic objects.
            if (mpBlasScratch == nullptr || mpBlasScratch->getSize() < totalScratchSize) {
                mpBlasScratch = Buffer::create(mpDevice, totalScratchSize, Buffer::BindFlags::UnorderedAccess, Buffer::CpuAccess::None);
                mpBlasScratch->setName("Scene::mpBlasScratch");
            } else {
                // If we didn't need to reallocate, just insert a barrier so it's safe to use.
                pContext->uavBarrier(mpBlasScratch.get());
            }

            Buffer::SharedPtr pDestBuffer = Buffer::create(mpDevice, totalMaxBlasSize, Buffer::BindFlags::AccelerationStructure, Buffer::CpuAccess::None);

            const size_t postBuildInfoSize = sizeof(D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_COMPACTED_SIZE_DESC);
            static_assert(postBuildInfoSize == sizeof(D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_CURRENT_SIZE_DESC));
            Buffer::SharedPtr pPostbuildInfoBuffer = Buffer::create(mpDevice, mBlasData.size() * postBuildInfoSize, Buffer::BindFlags::None, Buffer::CpuAccess::Read);

            // Build the BLASes into the intermediate destination buffer.
            // We output postbuild info to a separate buffer to find out the final size requirements.
            assert(pDestBuffer && pPostbuildInfoBuffer && mpBlasScratch);
            uint64_t postBuildInfoOffset = 0;

            for (const auto& blas : mBlasData) {
                D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC asDesc = {};
                asDesc.Inputs = blas.buildInputs;
                asDesc.ScratchAccelerationStructureData = mpBlasScratch->getGpuAddress() + blas.scratchByteOffset;
                asDesc.DestAccelerationStructureData = pDestBuffer->getGpuAddress() + blas.blasByteOffset;

                // Need to find out the the postbuild compacted BLAS size to know the final allocation size.
                D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC postbuildInfoDesc = {};
                postbuildInfoDesc.InfoType = blas.useCompaction ? D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_COMPACTED_SIZE : D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_CURRENT_SIZE;
                postbuildInfoDesc.DestBuffer = pPostbuildInfoBuffer->getGpuAddress() + postBuildInfoOffset;
                postBuildInfoOffset += postBuildInfoSize;

                GET_COM_INTERFACE(pContext->getLowLevelData()->getCommandList(), ID3D12GraphicsCommandList4, pList4);
                pList4->BuildRaytracingAccelerationStructure(&asDesc, 1, &postbuildInfoDesc);
            }

            // Release scratch buffer if there is no animated content. We will not need it.
            if (!mHasSkinnedMesh) mpBlasScratch.reset();

            // Read back the calculated final size requirements for each BLAS.
            // For this purpose we have to flush and map the postbuild info buffer for readback.
            // TODO: We could copy to a staging buffer first and wait on a GPU fence for when it's ready.
            // But there is no other work to do inbetween so it probably wouldn't help. This is only done once at startup anyway.
            pContext->flush(true);
            const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_COMPACTED_SIZE_DESC* postBuildInfo =
                (const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_COMPACTED_SIZE_DESC*) pPostbuildInfoBuffer->map(Buffer::MapType::Read);

            uint64_t totalBlasSize = 0;
            for (size_t i = 0; i < mBlasData.size(); i++) {
                auto& blas = mBlasData[i];
                blas.blasByteSize = postBuildInfo[i].CompactedSizeInBytes;
                assert(blas.blasByteSize <= blas.prebuildInfo.ResultDataMaxSizeInBytes);
                uint64_t paddedBlasSize = align_to(D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BYTE_ALIGNMENT, blas.blasByteSize);
                totalBlasSize += paddedBlasSize;
            }
            pPostbuildInfoBuffer->unmap();

            // Allocate final BLAS buffer.
            if (mpBlas == nullptr || mpBlas->getSize() < totalBlasSize) {
                mpBlas = Buffer::create(totalBlasSize, Buffer::BindFlags::AccelerationStructure, Buffer::CpuAccess::None);
                mpBlas->setName("Scene::mpBlas");
            } else {
                // If we didn't need to reallocate, just insert a barrier so it's safe to use.
                pContext->uavBarrier(mpBlas.get());
            }

            // Insert barriers for the intermediate buffer. This is probably not necessary since we flushed above, but it's not going to hurt.
            pContext->uavBarrier(pDestBuffer.get());

            // Compact/clone all BLASes to their final location.
            uint64_t blasOffset = 0;
            for (auto& blas : mBlasData) {
                GET_COM_INTERFACE(pContext->getLowLevelData()->getCommandList(), ID3D12GraphicsCommandList4, pList4);
                pList4->CopyRaytracingAccelerationStructure(
                    mpBlas->getGpuAddress() + blasOffset,
                    pDestBuffer->getGpuAddress() + blas.blasByteOffset,
                    blas.useCompaction ? D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE_COMPACT : D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE_CLONE);

                uint64_t paddedBlasSize = align_to(D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BYTE_ALIGNMENT, blas.blasByteSize);
                blas.blasByteOffset = blasOffset;
                blasOffset += paddedBlasSize;
            }
            assert(blasOffset == totalBlasSize);

            // Insert barrier. The BLAS buffer is now ready for use.
            pContext->uavBarrier(mpBlas.get());

            updateRaytracingStats();
            mRebuildBlas = false;

            return;
        }

        // If we get here, all BLASes have previously been built and compacted. We will:
        // - Early out if there are no animated meshes.
        // - Update or rebuild in-place the ones that are animated.
        assert(!mRebuildBlas);
        if (mHasSkinnedMesh == false) return;

        // Insert barriers. The buffers are now ready to be written to.
        assert(mpBlas && mpBlasScratch);
        pContext->uavBarrier(mpBlas.get());
        pContext->uavBarrier(mpBlasScratch.get());

        for (const auto& blas : mBlasData) {
            // Skip updating BLASes not containing skinned meshes.
            if (!blas.hasSkinnedMesh) continue;

            // Build/update BLAS.
            D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC asDesc = {};
            asDesc.Inputs = blas.buildInputs;
            asDesc.ScratchAccelerationStructureData = mpBlasScratch->getGpuAddress() + blas.scratchByteOffset;
            asDesc.DestAccelerationStructureData = mpBlas->getGpuAddress() + blas.blasByteOffset;

            if (blas.updateMode == UpdateMode::Refit) {
                // Set source address to destination address to update in place.
                asDesc.SourceAccelerationStructureData = asDesc.DestAccelerationStructureData;
                asDesc.Inputs.Flags |= D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_PERFORM_UPDATE;
            } else {
                // We'll rebuild in place. The BLAS should not be compacted, check that size matches prebuild info.
                assert(blas.blasByteSize == blas.prebuildInfo.ResultDataMaxSizeInBytes);
            }

            GET_COM_INTERFACE(pContext->getLowLevelData()->getCommandList(), ID3D12GraphicsCommandList4, pList4);
            pList4->BuildRaytracingAccelerationStructure(&asDesc, 0, nullptr);
        }

        // Insert barrier. The BLAS buffer is now ready for use.
        pContext->uavBarrier(mpBlas.get());
    }

    void Scene::fillInstanceDesc(std::vector<VkAccelerationStructureInstanceKHR>& instanceDescs, uint32_t rayCount, bool perMeshHitEntry) const {
        instanceDescs.clear();
        uint32_t instanceContributionToHitGroupIndex = 0;
        uint32_t instanceId = 0;

        for (size_t i = 0; i < mMeshGroups.size(); i++) {
            const auto& meshList = mMeshGroups[i].meshList;
            const bool isStatic = mMeshGroups[i].isStatic;

            assert(mBlasData[i].blasGroupIndex < mBlasGroups.size());
            const auto& pBlas = mBlasGroups[mBlasData[i].blasGroupIndex].pBlas;
            assert(pBlas);

            D3D12_RAYTRACING_INSTANCE_DESC desc = {};
            desc.AccelerationStructure = pBlas->getGpuAddress() + mBlasData[i].blasByteOffset;
            desc.InstanceMask = 0xFF;
            desc.InstanceContributionToHitGroupIndex = perMeshHitEntry ? instanceContributionToHitGroupIndex : 0;

            instanceContributionToHitGroupIndex += rayCount * (uint32_t)meshList.size();

            // From the scene builder we can expect the following:
            //
            // If BLAS is marked as static:
            // - The meshes are pre-transformed to world-space.
            // - The meshes are guaranteed to be non-instanced, so only one INSTANCE_DESC with an identity transform is needed.
            //
            // If there are multiple meshes in a BLAS not marked as static:
            // - Their global matrix is the same,
            // - The meshes are guaranteed to be non-instanced, so only one INSTANCE_DESC is needed.
            //
            if (isStatic || meshList.size() > 1) {
                for (size_t j = 0; j < meshList.size(); j++) {
                    assert(mMeshIdToInstanceIds[meshList[j]].size() == 1);
                    assert(mMeshIdToInstanceIds[meshList[j]][0] == instanceId + (uint32_t)j); // Mesh instances are sorted by instanceId
                }
                desc.InstanceID = instanceId;
                instanceId += (uint32_t)meshList.size();

                glm::mat4 transform4x4 = glm::identity<glm::mat4>();
                if (!isStatic) {
                    // Dynamic meshes.
                    // Any instances of the mesh will get you the correct matrix, so just pick the first mesh then the first instance.
                    uint32_t matrixId = mMeshInstanceData[desc.InstanceID].globalMatrixID;
                    transform4x4 = transpose(mpAnimationController->getGlobalMatrices()[matrixId]);
                }
                std::memcpy(desc.Transform, &transform4x4, sizeof(desc.Transform));
                instanceDescs.push_back(desc);
            }
            // If only one mesh is in the BLAS, there CAN be multiple instances of it. It is either:
            // - A non-instanced mesh that was unable to be merged with others, or
            // - A mesh with multiple instances.
            else
            {
                assert(meshList.size() == 1);
                const auto& instanceList = mMeshIdToInstanceIds[meshList[0]];

                // For every instance of the mesh, create an INSTANCE_DESC
                for (uint32_t instId : instanceList) {
                    assert(instId == instanceId); // Mesh instances are sorted by instanceId
                    desc.InstanceID = instanceId++;
                    uint32_t matrixId = mMeshInstanceData[desc.InstanceID].globalMatrixID;
                    glm::mat4 transform4x4 = transpose(mpAnimationController->getGlobalMatrices()[matrixId]);
                    std::memcpy(desc.Transform, &transform4x4, sizeof(desc.Transform));
                    instanceDescs.push_back(desc);
                }
            }
        }

        // One instance with identity transform for AABBs.
        if (mpRtAABBBuffer) {
            // Last BLAS should be all AABBs.
            assert(mBlasData.size() == mMeshGroups.size() + 1);

            assert(mBlasData.back().blasGroupIndex < mBlasGroups.size());
            const auto& pBlas = mBlasGroups[mBlasData.back().blasGroupIndex].pBlas;
            assert(pBlas);

            D3D12_RAYTRACING_INSTANCE_DESC desc = {};
            desc.AccelerationStructure = pBlas->getGpuAddress() + mBlasData.back().blasByteOffset;
            desc.InstanceMask = 0xFF;
            desc.InstanceID = 0;

            // Start AABB hitgroup lookup after the triangle hitgroups
            desc.InstanceContributionToHitGroupIndex = perMeshHitEntry ? instanceContributionToHitGroupIndex : rayCount;

            glm::mat4 identityMat = glm::identity<glm::mat4>();
            std::memcpy(desc.Transform, &identityMat, sizeof(desc.Transform));
            instanceDescs.push_back(desc);
        }
    }

    void Scene::buildTlas(RenderContext* pContext, uint32_t rayCount, bool perMeshHitEntry) {
        PROFILE(mpDevice, "buildTlas");

        TlasData tlas;
        auto it = mTlasCache.find(rayCount);
        if (it != mTlasCache.end()) tlas = it->second;

        fillInstanceDesc(mInstanceDescs, rayCount, perMeshHitEntry);

        D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS inputs = {};
        inputs.Type = D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL;
        inputs.DescsLayout = D3D12_ELEMENTS_LAYOUT_ARRAY;
        inputs.NumDescs = (uint32_t)mInstanceDescs.size();
        inputs.Flags = D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_NONE;

        // Add build flags for dynamic scenes if TLAS should be updating instead of rebuilt
        if (mpAnimationController->hasAnimations() && mTlasUpdateMode == UpdateMode::Refit) {
            inputs.Flags |= D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_ALLOW_UPDATE;

            // If TLAS has been built already and it was built with ALLOW_UPDATE
            if (tlas.pTlas != nullptr && tlas.updateMode == UpdateMode::Refit) inputs.Flags |= D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_PERFORM_UPDATE;
        }

        tlas.updateMode = mTlasUpdateMode;

        // On first build for the scene, create scratch buffer and cache prebuild info. As long as INSTANCE_DESC count doesn't change, we can reuse these
        if (mpTlasScratch == nullptr) {
            // Prebuild
            GET_COM_INTERFACE(gpDevice->getApiHandle(), ID3D12Device5, pDevice5);
            pDevice5->GetRaytracingAccelerationStructurePrebuildInfo(&inputs, &mTlasPrebuildInfo);
            mpTlasScratch = Buffer::create(mTlasPrebuildInfo.ScratchDataSizeInBytes, Buffer::BindFlags::UnorderedAccess, Buffer::CpuAccess::None);
            mpTlasScratch->setName("Scene::mpTlasScratch");

            // #SCENE This isn't guaranteed according to the spec, and the scratch buffer being stored should be sized differently depending on update mode
            assert(mTlasPrebuildInfo.UpdateScratchDataSizeInBytes <= mTlasPrebuildInfo.ScratchDataSizeInBytes);
        }

        // Setup GPU buffers
        D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC asDesc = {};
        asDesc.Inputs = inputs;

        // If first time building this TLAS
        if (tlas.pTlas == nullptr) {
            assert(tlas.pInstanceDescs == nullptr); // Instance desc should also be null if no TLAS
            tlas.pTlas = Buffer::create(mTlasPrebuildInfo.ResultDataMaxSizeInBytes, Buffer::BindFlags::AccelerationStructure, Buffer::CpuAccess::None);
            tlas.pTlas->setName("Scene TLAS buffer");
            tlas.pInstanceDescs = Buffer::create((uint32_t)mInstanceDescs.size() * sizeof(D3D12_RAYTRACING_INSTANCE_DESC), Buffer::BindFlags::None, Buffer::CpuAccess::Write, mInstanceDescs.data());
            tlas.pInstanceDescs->setName("Scene instance descs buffer");
        }
        // Else update instance descs and barrier TLAS buffers
        else {
            assert(mpAnimationController->hasAnimations());
            pContext->uavBarrier(tlas.pTlas.get());
            pContext->uavBarrier(mpTlasScratch.get());
            tlas.pInstanceDescs->setBlob(mInstanceDescs.data(), 0, inputs.NumDescs * sizeof(D3D12_RAYTRACING_INSTANCE_DESC));
            asDesc.SourceAccelerationStructureData = tlas.pTlas->getGpuAddress(); // Perform the update in-place
        }

        assert((inputs.NumDescs != 0) && tlas.pInstanceDescs->getApiHandle() && tlas.pTlas->getApiHandle() && mpTlasScratch->getApiHandle());

        asDesc.Inputs.InstanceDescs = tlas.pInstanceDescs->getGpuAddress();
        asDesc.ScratchAccelerationStructureData = mpTlasScratch->getGpuAddress();
        asDesc.DestAccelerationStructureData = tlas.pTlas->getGpuAddress();

        // Set the source buffer to update in place if this is an update
        if ((inputs.Flags & D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_PERFORM_UPDATE) > 0) asDesc.SourceAccelerationStructureData = asDesc.DestAccelerationStructureData;

        // Create TLAS
        GET_COM_INTERFACE(pContext->getLowLevelData()->getCommandList(), ID3D12GraphicsCommandList4, pList4);
        pContext->resourceBarrier(tlas.pInstanceDescs.get(), Resource::State::NonPixelShader);
        pList4->BuildRaytracingAccelerationStructure(&asDesc, 0, nullptr);
        pContext->uavBarrier(tlas.pTlas.get());

        // Create TLAS SRV
        if (tlas.pSrv == nullptr) {
            tlas.pSrv = ShaderResourceView::createViewForAccelerationStructure(tlas.pTlas);
        }

        mTlasCache[rayCount] = tlas;
        updateRaytracingTLASStats();
    }

    void Scene::setGeometryIndexIntoRtVars(const std::shared_ptr<RtProgramVars>& pVars) {
        // Sets the 'geometryIndex' hit shader variable for each mesh.
        // This is the local index of which mesh in the BLAS was hit.
        // In DXR 1.0 we have to pass it via a constant buffer to the shader,
        // in DXR 1.1 it is available through the GeometryIndex() system value.
        //
        assert(!mBlasData.empty());
        uint32_t meshCount = getMeshCount();
        uint32_t descHitCount = pVars->getDescHitGroupCount();

        uint32_t blasIndex = 0;
        uint32_t geometryIndex = 0;
        for (uint32_t meshId = 0; meshId < meshCount; meshId++) {
            for (uint32_t hit = 0; hit < descHitCount; hit++) {
                auto pHitVars = pVars->getHitVars(hit, meshId);
                auto var = pHitVars->findMember(0).findMember("geometryIndex");
                if (var.isValid()) {
                    var = geometryIndex;
                }
            }

            geometryIndex++;

            // If at the end of this BLAS, reset counters and start checking next BLAS
            uint32_t geomCount = (uint32_t)mMeshGroups[blasIndex].meshList.size();
            if (geometryIndex == geomCount) {
                geometryIndex = 0;
                blasIndex++;
            }
        }
    }
    
    void Scene::setRaytracingShaderData(RenderContext* pContext, const ShaderVar& var, uint32_t rayTypeCount) {
        // On first execution, create BLAS for each mesh.
        if (mBlasData.empty()) {
            initGeomDesc();
            buildBlas(pContext);
        }

        // On first execution, when meshes have moved, when there's a new ray count, or when a BLAS has changed, create/update the TLAS
        //
        // TODO: The notion of "ray count" is being treated as fundamental here, and intrinsically
        // linked to the number of hit groups in the program, without checking if this matches
        // other things like the number of miss shaders. If/when we support meshes with custom
        // intersection shaders, then the assumption that number of ray types and number of
        // hit groups match will be incorrect.
        //
        // It really seems like a first-class notion of ray types (and the number thereof) is required.
        //
        auto tlasIt = mTlasCache.find(rayTypeCount);
        if (tlasIt == mTlasCache.end()) {
            // We need a hit entry per mesh right now to pass GeometryIndex()
            buildTlas(pContext, rayTypeCount, true);

            // If new TLAS was just created, get it so the iterator is valid
            if (tlasIt == mTlasCache.end()) tlasIt = mTlasCache.find(rayTypeCount);
        }

        assert(mpSceneBlock);
        assert(tlasIt->second.pSrv);

        // Bind Scene parameter block.
        getCamera()->setShaderData(mpSceneBlock[kCamera]);
        var["gScene"] = mpSceneBlock;

        // Bind TLAS.
        var["gRtScene"].setSrv(tlasIt->second.pSrv);
    }
    
    void Scene::setEnvMap(EnvMap::SharedPtr pEnvMap) {
        if (mpEnvMap == pEnvMap) return;
        mpEnvMap = pEnvMap;
        if (mpEnvMap) mpEnvMap->setShaderData(mpSceneBlock[kEnvMap]);
    }

    void Scene::loadEnvMap(const std::string& filename) {
        EnvMap::SharedPtr pEnvMap = EnvMap::create(mpDevice, filename);
        setEnvMap(pEnvMap);
    }

    void Scene::setCameraAspectRatio(float ratio) {
        getCamera()->setAspectRatio(ratio);
    }

    void Scene::bindSamplerToMaterials(const Sampler::SharedPtr& pSampler) {
        for (auto& pMaterial : mMaterials) {
            pMaterial->setSampler(pSampler);
        }
    }

    void Scene::setCameraController(CameraControllerType type) {
        if (!mCameraSwitched && mCamCtrlType == type && mpCamCtrl) return;

        auto camera = getCamera();
        switch (type) {
            case CameraControllerType::FirstPerson:
                mpCamCtrl = FirstPersonCameraController::create(camera);
                break;
            case CameraControllerType::Orbiter:
                mpCamCtrl = OrbiterCameraController::create(camera);
                ((OrbiterCameraController*)mpCamCtrl.get())->setModelParams(mSceneBB.center, length(mSceneBB.extent), 3.5f);
                break;
            case CameraControllerType::SixDOF:
                mpCamCtrl = SixDoFCameraController::create(camera);
                break;
            default:
                should_not_get_here();
        }
        mpCamCtrl->setCameraSpeed(mCameraSpeed);
    }

    std::string Scene::getScript(const std::string& sceneVar) {
        std::string c;

        // Render settings.
        c += Scripting::makeSetProperty(sceneVar, kRenderSettings, mRenderSettings);

        // Animations.
        if (hasAnimation() && !isAnimated()) {
            c += Scripting::makeSetProperty(sceneVar, kAnimated, false);
        }

        for (size_t i = 0; i < mLights.size(); ++i) {
            const auto& light = mLights[i];
            if (light->hasAnimation() && !light->isAnimated()) {
                c += Scripting::makeSetProperty(sceneVar + "." + kGetLight + "(" + std::to_string(i) + ").", kAnimated, false);
            }
        }

        // Camera.
        if (mSelectedCamera != 0) {
            c += sceneVar + "." + kCamera + " = " + sceneVar + "." + kCameras + "[" + std::to_string(mSelectedCamera) + "]\n";
        }
        c += getCamera()->getScript(sceneVar + "." + kCamera);

        // Camera speed.
        c += Scripting::makeSetProperty(sceneVar, kCameraSpeed, mCameraSpeed);

        // Viewpoints.
        if (hasSavedViewpoints()) {
            for (size_t i = 1; i < mViewpoints.size(); i++) {
                auto v = mViewpoints[i];
                c += Scripting::makeMemberFunc(sceneVar, kAddViewpoint, v.position, v.target, v.up, v.index);
            }
        }

        return c;
    }

#ifdef SCRIPTING
    SCRIPT_BINDING(Scene) {
        pybind11::class_<Scene, Scene::SharedPtr> scene(m, "Scene");
        scene.def_property(kCamera.c_str(), &Scene::getCamera, &Scene::setCamera);
        scene.def_property_readonly(kCameras.c_str(), &Scene::getCameras);
        scene.def_property_readonly(kEnvMap.c_str(), &Scene::getEnvMap);
        scene.def_property_readonly(kMaterials.c_str(), &Scene::getMaterials);
        scene.def_property(kCameraSpeed.c_str(), &Scene::getCameraSpeed, &Scene::setCameraSpeed);
        scene.def_property(kAnimated.c_str(), &Scene::isAnimated, &Scene::setIsAnimated);
        scene.def_property(kRenderSettings.c_str(), pybind11::overload_cast<>(&Scene::getRenderSettings, pybind11::const_), &Scene::setRenderSettings);

        scene.def("animate", &Scene::toggleAnimations, "animate"_a); // PYTHONDEPRECATED
        auto animateCamera = [](Scene* pScene, bool animate) { pScene->getCamera()->setIsAnimated(animate); };
        scene.def("animateCamera", animateCamera, "animate"_a); // PYTHONDEPRECATED
        auto animateLight = [](Scene* pScene, uint32_t index, bool animate) { pScene->getLight(index)->setIsAnimated(animate); };
        scene.def("animateLight", animateLight, "index"_a, "animate"_a); // PYTHONDEPRECATED

        scene.def(kSetEnvMap.c_str(), &Scene::loadEnvMap, "filename"_a);
        scene.def(kGetLight.c_str(), &Scene::getLight, "index"_a);
        scene.def(kGetLight.c_str(), &Scene::getLightByName, "name"_a);
        scene.def("light", &Scene::getLight); // PYTHONDEPRECATED
        scene.def("light", &Scene::getLightByName); // PYTHONDEPRECATED
        scene.def(kGetMaterial.c_str(), &Scene::getMaterial, "index"_a);
        scene.def(kGetMaterial.c_str(), &Scene::getMaterialByName, "name"_a);
        scene.def("material", &Scene::getMaterial); // PYTHONDEPRECATED
        scene.def("material", &Scene::getMaterialByName); // PYTHONDEPRECATED

        // Viewpoints
        scene.def(kAddViewpoint.c_str(), pybind11::overload_cast<>(&Scene::addViewpoint)); // add current camera as viewpoint
        scene.def(kAddViewpoint.c_str(), pybind11::overload_cast<const float3&, const float3&, const float3&, uint32_t>(&Scene::addViewpoint), "position"_a, "target"_a, "up"_a, "cameraIndex"_a=0); // add specified viewpoint
        scene.def(kRemoveViewpoint.c_str(), &Scene::removeViewpoint); // remove the selected viewpoint
        scene.def(kSelectViewpoint.c_str(), &Scene::selectViewpoint, "index"_a); // select a viewpoint by index

        scene.def("viewpoint", pybind11::overload_cast<>(&Scene::addViewpoint)); // PYTHONDEPRECATED save the current camera position etc.
        scene.def("viewpoint", pybind11::overload_cast<uint32_t>(&Scene::selectViewpoint)); // PYTHONDEPRECATED select a previously saved camera viewpoint

        // RenderSettings
        ScriptBindings::SerializableStruct<Scene::RenderSettings> renderSettings(m, "SceneRenderSettings");
#define field(f_) field(#f_, &Scene::RenderSettings::f_)
        renderSettings.field(useEnvLight);
        renderSettings.field(useAnalyticLights);
        renderSettings.field(useEmissiveLights);
#undef field
    }
#endif // SCRIPTING

}  // namespace Falcor
