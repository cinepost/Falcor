import hou

from enum import Enum

from code_template import CodeTemplate
from functions import getVopNodeAdapter
from vop_node_adapter_base import VopNodeAdapterBase
from vop_node_adapter_socket import VopNodeSocket

def appendSocketsAsFuncArgs(args_str, sockets):
	if not isinstance(sockets, (list, tuple)):
		raise ValueError('Wrong sockets argument of type "%s" passed, should be either list or tuple !!!' % type(sockets))

	# Filter out non slang types (line strings and shading contexts e.g 'surface', 'dispalce')
	sockets = [socket for socket in sockets if VopNodeSocket.DataType.isSlandDataType(socket.dataType)]

	if len(sockets) == 0:
		return args_str

	result = args_str

	if result:
		result += ", "

	for i in range(0, len(sockets)):
		socket = sockets[i]

		if socket.direction != VopNodeSocket.Direction.INPUT:
			result += "%s " % socket.slangTypeAccessString
		
		result += "%s %s" % (socket.slangDataTypeString, socket.codeVarName)

		if i != (len(sockets) - 1): result += ", "

	return result

class VopNodeAdapterProcessor(object):
	class ProcessorType(Enum):
		NODE    = 0
		SUBNET  = 1

	_root_node = None
	
	def __init__(self, vop_node, slang_context=None):
		super(VopNodeAdapterProcessor, self).__init__()

		if not issubclass(type(vop_node), hou.VopNode):
			raise ValueError('Wrong object of type "%s" passed as a vop node !!!' % type(vop_node))

		#if adapter.context.vopNode.isSubNetwork():
		#	self._processing_mode = VopNodeAdapterProcessor.ProcessorType.SUBNET
		#else:
		#	self._processing_mode = VopNodeAdapterProcessor.ProcessorType.NODE

		self._multi_slang_code_contexts = False
		try:
			if vop_node.supportsMultiCookCodeContexts():
				self._multi_slang_code_contexts = True
		except:
			pass

		self._root_node = vop_node
		self._slang_context = slang_context

	def processChildren(self, children_vop_nodes, slang_context=None):
		#if self._processing_mode != VopNodeAdapterProcessor.ProcessorType.SUBNET:
		#	raise Exception("Children processing allowed only in sub-networks !!!")

		result = {
			'inputs' : [],
			'outputs' : [],
			'code': "",
		}

		for child_vop_node in children_vop_nodes:
			if not child_vop_node.outputNames():
				# this is a output collection node
				continue

			res = self._process(child_vop_node, slang_context)

			result['code'] += res['code']
			result['outputs'] += res['outputs']

		return result

	def process(self):
		
		resultCode = {}

		if not self._slang_context:
			if self._multi_slang_code_contexts:
				for slang_context in ['surface', 'displacement']:
					resultCode[slang_context] = self._process(self._root_node, slang_context)['code']

			return resultCode

		return {'surface': self._process(self._root_node)['code']}

	def _process(self, vop_node, slang_context = 'surface'):
		from functions import getVopNodeAdapter

		if not issubclass(type(vop_node), hou.VopNode):
			raise ValueError('Wrong object of type "%s" passed as a vop node !!!' % type(vop_node))

		subnet_mode = False
		if vop_node.isSubNetwork():
			subnet_mode = True

		vop_adapter = getVopNodeAdapter(vop_node)

		if not vop_adapter:
			raise Exception('No vop adapter found for node type "%s"' % vop_node.type().name())

		inputs = [] #vop_adapter.context.inputs
		outputs = [] #vop_adapter.context.outputs

		childrenCode = ""

		if subnet_mode:
			children_vop_nodes = [self._vop_node.subnetTerminalChild(output_name)[0] for output_name in self._vop_node.outputNames()]
			res = self.processChildren(children_vop_nodes, slang_context)
			childrenCode = res['code']
			inputs = res['inputs']
			outputs = res['outputs']
		else:
			outputs = vop_adapter.getOutputs(slang_context)


		slang_code_template = vop_adapter.getSlangTemplate(slang_context)
		if not isinstance(slang_code_template, CodeTemplate):
			raise ValueError('"%s" adapter getSlangTemplate returned "%s", CodeTemplate expected !!!' % (vop_adapter.vopTypeName(), type(slang_code_template)))

		#print "processing\n"
		#print self._adapter.getSlangTemplate()
		#print "\n"

		d = {
			'FUNC_NAME': vop_adapter.context.codeFuncName,
			'OP_PATH': vop_adapter.context.vopNodePath,
			'PARAMS': "",
			'RETURN_TYPE': "void",
			'SUPER_BLOCK': childrenCode
		}

		args_str = ""
		if len(inputs) > 0:
			args_str = appendSocketsAsFuncArgs(args_str, inputs)

		if len(outputs) > 1:
			# output variables as a function args
			args_str = appendSocketsAsFuncArgs(args_str, outputs)
		else:
			d['RETURN_TYPE'] = "void" #outputs[0].slangDataTypeString

		d['ARGS'] = args_str

		return {
			'inputs' : inputs,
			'outputs' : outputs,
			'code': slang_code_template.getTemplateString().substitute(d),
		}
