{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"pa",
				"parseStream"
			],
			[
				"Render",
				"RendererIface"
			],
			[
				"RendererI",
				"RendererIfaceBase"
			],
			[
				"Re",
				"ReaderLSD"
			],
			[
				"m",
				"mInitialized"
			],
			[
				"LLO",
				"LLOG_DBG"
			],
			[
				"pI",
				"pIface"
			],
			[
				"ini",
				"initRenderer"
			],
			[
				"R",
				"RendererIfaceLSD"
			],
			[
				"re",
				"render_graph"
			],
			[
				"add",
				"addGraph"
			],
			[
				"Script",
				"ScriptBindings"
			],
			[
				"LLOG",
				"LLOG_WRN"
			],
			[
				"Sc",
				"ScriptBindings"
			],
			[
				"LL",
				"LLOG_DBG"
			],
			[
				"ou",
				"output"
			],
			[
				"mpD",
				"mpDevice"
			],
			[
				"Ren",
				"RenderGraph"
			],
			[
				"set",
				"setScene"
			],
			[
				"RE",
				"RendererIfaceLSD"
			],
			[
				"render",
				"renderFrame"
			],
			[
				"he",
				"height"
			],
			[
				"de",
				"device"
			],
			[
				"p",
				"pTexture"
			],
			[
				"up",
				"updateOffscreenFBO"
			],
			[
				"rele",
				"releaseFboData"
			],
			[
				"onR",
				"onResizeSwapChain"
			],
			[
				"getO",
				"getOffscreenFbo"
			],
			[
				"mp",
				"mpClock"
			],
			[
				"fi",
				"file_name"
			],
			[
				"D",
				"DisplayType"
			],
			[
				"d",
				"display_type"
			],
			[
				"an",
				"any_filename_"
			],
			[
				"any",
				"any_filename"
			],
			[
				"O",
				"OPENEXR"
			],
			[
				"Op",
				"OpenEXR"
			],
			[
				"Rendere",
				"RendererIfaceLSD"
			],
			[
				"mI",
				"mImageHeight"
			],
			[
				"h",
				"height"
			],
			[
				"ima",
				"image_name"
			],
			[
				"cmd_de",
				"cmd_declare"
			],
			[
				"cmd_d",
				"cmd_defaults"
			],
			[
				"cm",
				"cmd_version"
			],
			[
				"cmd_op",
				"cmd_deviceoption"
			],
			[
				"cmd",
				"cmd_defaults"
			],
			[
				"c",
				"cmd_quit"
			],
			[
				"cme",
				"cmd_property"
			],
			[
				"V",
				"Vector4"
			],
			[
				"Ve",
				"Vector2"
			],
			[
				"I",
				"Int4"
			],
			[
				"in",
				"Int3"
			],
			[
				"e",
				"expr"
			],
			[
				"if",
				"ifthen"
			],
			[
				"end",
				"endif"
			],
			[
				"en",
				"endif"
			],
			[
				"C",
				"Command"
			],
			[
				"oper",
				"operator"
			],
			[
				"ope",
				"operator"
			],
			[
				"op_",
				"op_type"
			],
			[
				"opea",
				"operand"
			],
			[
				"op",
				"operand"
			],
			[
				"str",
				"struct\tstruct"
			],
			[
				"ski",
				"skipper"
			],
			[
				"prop",
				"prop_value"
			],
			[
				"LSD",
				"LSDEchoVisitor"
			],
			[
				"ass",
				"assign_bgeo"
			],
			[
				"bge",
				"bgeo_inline"
			],
			[
				"LLOG_",
				"LLOG_DBG"
			],
			[
				"Read",
				"ReaderLSD"
			],
			[
				"is",
				"isInitialized"
			],
			[
				"LOG_",
				"LOG_DBG"
			],
			[
				"LS",
				"LSDEchoVisitor"
			],
			[
				"ech",
				"echo_input"
			],
			[
				"em",
				"empty_array"
			],
			[
				"null_",
				"null_value"
			],
			[
				"array",
				"array_t"
			],
			[
				"value",
				"value_t"
			],
			[
				"valu",
				"value_t"
			],
			[
				"num",
				"number_t"
			],
			[
				"std",
				"stdin"
			],
			[
				"as",
				"assign_array_value"
			],
			[
				"arr",
				"array"
			],
			[
				"va",
				"variant"
			],
			[
				"pars",
				"parser_ok"
			],
			[
				"parse",
				"parser_fail"
			],
			[
				"vec",
				"vector2"
			],
			[
				"vectr",
				"vector4"
			],
			[
				"assign",
				"assign_prop_value"
			],
			[
				"pro",
				"prop_name"
			],
			[
				"q",
				"quoted_string"
			],
			[
				"vect",
				"vector\tstd::vector"
			],
			[
				"vector",
				"vector2"
			],
			[
				"Vec",
				"Vector4"
			],
			[
				"ve",
				"vector\tstd::vector"
			],
			[
				"tep",
				"typedef"
			],
			[
				"o",
				"object"
			],
			[
				"stat",
				"static_vector"
			],
			[
				"ge",
				"geometry_object"
			],
			[
				"min",
				"minor"
			],
			[
				"assi",
				"assign_time"
			],
			[
				"T",
				"T"
			],
			[
				"file",
				"filename"
			],
			[
				"ma",
				"matrix"
			],
			[
				"cmd_",
				"cmd_transform"
			],
			[
				"GE",
				"GEOMERTY"
			],
			[
				"G",
				"GEO"
			],
			[
				"Com",
				"commands"
			],
			[
				"BOO",
				"BOOST_FUSION_ADAPT_STRUCT"
			],
			[
				"comm",
				"comment"
			],
			[
				"s",
				"struct\tstruct"
			],
			[
				"cmd_r",
				"cmd_raytrace"
			],
			[
				"li",
				"lineCommentRule1"
			],
			[
				"get",
				"getBufferStartIndex"
			],
			[
				"siz",
				"size"
			],
			[
				"size",
				"size_t"
			],
			[
				"last",
				"_lastChar"
			],
			[
				"U",
				"UnbufferedCharStream"
			],
			[
				"fa",
				"false"
			],
			[
				"Reade",
				"ReaderBase"
			],
			[
				"lava",
				"lava_lib"
			],
			[
				"beg",
				"begin"
			],
			[
				"pri",
				"private"
			],
			[
				"P",
				"ParserLSD"
			],
			[
				"dri",
				"driver_name"
			],
			[
				"dr",
				"driver_name"
			],
			[
				"Ds",
				"DspyImageClose"
			],
			[
				"l",
				"lib_handle"
			],
			[
				"read",
				"read_stdin"
			]
		]
	},
	"buffers":
	[
		{
			"file": "src/Falcor/Core/Program/GraphicsProgram.cpp",
			"settings":
			{
				"buffer_size": 2616,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "Searching 1245 files for \"RenderGraph::create\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Device.cpp:\n  372  SCRIPT_BINDING(RenderGraph) {\n  373      auto graphClass = m.regClass(RenderGraph);\n  374:     graphClass.ctor(&RenderGraph::create);\n  375      graphClass.property(\"name\", &RenderGraph::getName, &RenderGraph::setName);\n  376      graphClass.func_(RenderGraphIR::kAddPass, &RenderGraph::addPass, \"pass\"_a, \"name\"_a);\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraph.cpp:\n   38  const FileDialogFilterVec RenderGraph::kFileExtensionFilters = { { \"py\", \"Render Graph Files\"} };\n   39  \n   40: RenderGraph::SharedPtr RenderGraph::create(const std::string& name) {\n   41      return SharedPtr(new RenderGraph(_gpDeviceHeadless, name));\n   42  }\n   43  \n   44: RenderGraph::SharedPtr RenderGraph::create(std::shared_ptr<Device> device, const std::string& name) {\n   45      return SharedPtr(new RenderGraph(device, name));\n   46  }\n   ..\n  655  \n  656  SCRIPT_BINDING(RenderGraph) {\n  657:     RenderGraph::SharedPtr (&create_default)(const std::string&) = RenderGraph::create;\n  658:     RenderGraph::SharedPtr (&create_on_device)(std::shared_ptr<Device>, const std::string&) = RenderGraph::create;\n  659  \n  660      auto graphClass = m.regClass(RenderGraph);\n  661:     //graphClass.ctor(&RenderGraph::create(const std::string&));\n  662:     //graphClass.ctor(&RenderGraph::create(std::shared_ptr<Device>, const std::string&));\n  663  \n  664      graphClass.ctor(&create_default);\n\n/home/max/dev/Falcor/src/RenderPasses/CSM/CSM.cpp:\n  291  \n  292  void CSM::compile(RenderContext* pContext, const CompileData& compileData) {\n  293:     mpBlurGraph = RenderGraph::create(mpDevice, \"Gaussian Blur\");\n  294      GaussianBlur::SharedPtr pBlurPass = GaussianBlur::create(pContext, mBlurDict);\n  295      mpBlurGraph->addPass(pBlurPass, kBlurPass);\n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/GBuffer/GBufferRaster.cpp:\n  110      assert(pContext->device());\n  111  \n  112:     mpDepthPrePassGraph = RenderGraph::create(pContext->device(), \"Depth Pre-Pass\");\n  113      DepthPass::SharedPtr pDepthPass = DepthPass::create(pContext);\n  114      pDepthPass->setDepthBufferFormat(ResourceFormat::D32Float);\n\n/home/max/dev/Falcor/src/RenderPasses/SSAO/SSAO.cpp:\n  145      setNoiseTexture(mNoiseSize.x, mNoiseSize.y);\n  146  \n  147:     mpBlurGraph = RenderGraph::create(pDevice, \"Gaussian Blur\");\n  148      GaussianBlur::SharedPtr pBlurPass = GaussianBlur::create(pRenderContext, mBlurDict);\n  149      mpBlurGraph->addPass(pBlurPass, \"GaussianBlur\");\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/DebugPasses/InvalidPixelDetectionTests.cpp:\n   42          RenderContext* pRenderContext = ctx.getRenderContext();\n   43          Texture::SharedPtr pInput = Texture::create2D(2, 4, ResourceFormat::R32Float, 1, Resource::kMaxPossible, pInitData);\n   44:         RenderGraph::SharedPtr pGraph = RenderGraph::create(\"Invalid Pixel Detection\");\n   45          RenderPass::SharedPtr pPass = RenderPassLibrary::instance().createPass(pRenderContext, \"InvalidPixelDetectionPass\");\n   46          if (!pPass) {\n\n/home/max/dev/Falcor/src/Tools/RenderGraphEditor/RenderGraphEditor.cpp:\n  453      std::string graphName = renderGraphName;\n  454      auto nameToIndexIt = mGraphNamesToIndex.find(graphName);\n  455:     RenderGraph::SharedPtr newGraph = RenderGraph::create();\n  456  \n  457      std::string tempGraphName = graphName;\n\n12 matches across 7 files\n\n\nSearching 1245 files for \"Failed to link program\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/Program.cpp:\n  840  \n  841          if (pVersion == nullptr) {\n  842:             std::string error = \"Failed to link program:\\n\" + getProgramDescString() + \"\\n\\n\" + log;\n  843              logError(error, Logger::MsgBox::RetryAbort);\n  844:             throw std::runtime_error(\"Failed to link program\");\n  845  \n  846              // Continue loop to keep trying...\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramVersion.cpp:\n  206                  // Failure\n  207  \n  208:                 std::string error = \"Failed to link program:\\n\" + getName() + \"\\n\\n\" + log;\n  209                  logError(error, Logger::MsgBox::RetryAbort);\n  210:                 throw std::runtime_error(\"Failed to link program\");\n  211  \n  212                  // Continue loop to keep trying...\n\n4 matches across 2 files\n\n\nSearching 1245 files for \"build\" (case sensitive)\n\n/home/max/dev/Falcor/src/Externals/GLM/cmake/CMakePackageConfigHelpers.cmake:\n   25  # under Windows and OSX, where users are used to choose the install location\n   26  # of a binary package at install time, independent from how CMAKE_INSTALL_PREFIX\n   27: # was set at build/cmake time.\n   28  #\n   29  # Using CONFIGURE_PACKAGE_CONFIG_FILE() helps. If used correctly, it makes the\n   ..\n   79  # Writes a file for use as <package>ConfigVersion.cmake file to <filename>.\n   80  # See the documentation of FIND_PACKAGE() for details on this.\n   81: #    filename is the output filename, it should be in the build tree.\n   82  #    major.minor.patch is the version number of the project to be installed\n   83  # The COMPATIBILITY mode AnyNewerVersion means that the installed package version\n\n/home/max/dev/Falcor/src/Externals/GLM/CMakeLists.txt:\n  232  write_basic_package_version_file(\"${CMAKE_CURRENT_BINARY_DIR}/glmConfigVersion.cmake\" VERSION ${GLM_VERSION} COMPATIBILITY AnyNewerVersion)\n  233  \n  234: # build tree package config\n  235  configure_file(cmake/glmBuildConfig.cmake.in glmConfig.cmake @ONLY)\n  236  \n  ...\n  258  install(EXPORT glmTargets FILE glmTargets.cmake DESTINATION ${GLM_INSTALL_CONFIGDIR})\n  259  \n  260: # build pkg-config file\n  261  configure_file(\"./cmake/glm.pc.in\" \"glm.pc\" @ONLY)\n  262  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/setup.hpp:\n  897  #\tendif\n  898  \n  899: \t// Report build target\n  900  #\tif (GLM_ARCH & GLM_ARCH_AVX2_BIT) && (GLM_MODEL == GLM_MODEL_64)\n  901: #\t\tpragma message(\"GLM: x86 64 bits with AVX2 instruction set build target\")\n  902  #\telif (GLM_ARCH & GLM_ARCH_AVX2_BIT) && (GLM_MODEL == GLM_MODEL_32)\n  903: #\t\tpragma message(\"GLM: x86 32 bits with AVX2 instruction set build target\")\n  904  \n  905  #\telif (GLM_ARCH & GLM_ARCH_AVX_BIT) && (GLM_MODEL == GLM_MODEL_64)\n  906: #\t\tpragma message(\"GLM: x86 64 bits with AVX instruction set build target\")\n  907  #\telif (GLM_ARCH & GLM_ARCH_AVX_BIT) && (GLM_MODEL == GLM_MODEL_32)\n  908: #\t\tpragma message(\"GLM: x86 32 bits with AVX instruction set build target\")\n  909  \n  910  #\telif (GLM_ARCH & GLM_ARCH_SSE42_BIT) && (GLM_MODEL == GLM_MODEL_64)\n  911: #\t\tpragma message(\"GLM: x86 64 bits with SSE4.2 instruction set build target\")\n  912  #\telif (GLM_ARCH & GLM_ARCH_SSE42_BIT) && (GLM_MODEL == GLM_MODEL_32)\n  913: #\t\tpragma message(\"GLM: x86 32 bits with SSE4.2 instruction set build target\")\n  914  \n  915  #\telif (GLM_ARCH & GLM_ARCH_SSE41_BIT) && (GLM_MODEL == GLM_MODEL_64)\n  916: #\t\tpragma message(\"GLM: x86 64 bits with SSE4.1 instruction set build target\")\n  917  #\telif (GLM_ARCH & GLM_ARCH_SSE41_BIT) && (GLM_MODEL == GLM_MODEL_32)\n  918: #\t\tpragma message(\"GLM: x86 32 bits with SSE4.1 instruction set build target\")\n  919  \n  920  #\telif (GLM_ARCH & GLM_ARCH_SSSE3_BIT) && (GLM_MODEL == GLM_MODEL_64)\n  921: #\t\tpragma message(\"GLM: x86 64 bits with SSSE3 instruction set build target\")\n  922  #\telif (GLM_ARCH & GLM_ARCH_SSSE3_BIT) && (GLM_MODEL == GLM_MODEL_32)\n  923: #\t\tpragma message(\"GLM: x86 32 bits with SSSE3 instruction set build target\")\n  924  \n  925  #\telif (GLM_ARCH & GLM_ARCH_SSE3_BIT) && (GLM_MODEL == GLM_MODEL_64)\n  926: #\t\tpragma message(\"GLM: x86 64 bits with SSE3 instruction set build target\")\n  927  #\telif (GLM_ARCH & GLM_ARCH_SSE3_BIT) && (GLM_MODEL == GLM_MODEL_32)\n  928: #\t\tpragma message(\"GLM: x86 32 bits with SSE3 instruction set build target\")\n  929  \n  930  #\telif (GLM_ARCH & GLM_ARCH_SSE2_BIT) && (GLM_MODEL == GLM_MODEL_64)\n  931: #\t\tpragma message(\"GLM: x86 64 bits with SSE2 instruction set build target\")\n  932  #\telif (GLM_ARCH & GLM_ARCH_SSE2_BIT) && (GLM_MODEL == GLM_MODEL_32)\n  933: #\t\tpragma message(\"GLM: x86 32 bits with SSE2 instruction set build target\")\n  934  \n  935  #\telif (GLM_ARCH & GLM_ARCH_X86_BIT) && (GLM_MODEL == GLM_MODEL_64)\n  936: #\t\tpragma message(\"GLM: x86 64 bits build target\")\n  937  #\telif (GLM_ARCH & GLM_ARCH_X86_BIT) && (GLM_MODEL == GLM_MODEL_32)\n  938: #\t\tpragma message(\"GLM: x86 32 bits build target\")\n  939  \n  940  #\telif (GLM_ARCH & GLM_ARCH_NEON_BIT) && (GLM_MODEL == GLM_MODEL_64)\n  941: #\t\tpragma message(\"GLM: ARM 64 bits with Neon instruction set build target\")\n  942  #\telif (GLM_ARCH & GLM_ARCH_NEON_BIT) && (GLM_MODEL == GLM_MODEL_32)\n  943: #\t\tpragma message(\"GLM: ARM 32 bits with Neon instruction set build target\")\n  944  \n  945  #\telif (GLM_ARCH & GLM_ARCH_ARM_BIT) && (GLM_MODEL == GLM_MODEL_64)\n  946: #\t\tpragma message(\"GLM: ARM 64 bits build target\")\n  947  #\telif (GLM_ARCH & GLM_ARCH_ARM_BIT) && (GLM_MODEL == GLM_MODEL_32)\n  948: #\t\tpragma message(\"GLM: ARM 32 bits build target\")\n  949  \n  950  #\telif (GLM_ARCH & GLM_ARCH_MIPS_BIT) && (GLM_MODEL == GLM_MODEL_64)\n  951: #\t\tpragma message(\"GLM: MIPS 64 bits build target\")\n  952  #\telif (GLM_ARCH & GLM_ARCH_MIPS_BIT) && (GLM_MODEL == GLM_MODEL_32)\n  953: #\t\tpragma message(\"GLM: MIPS 32 bits build target\")\n  954  \n  955  #\telif (GLM_ARCH & GLM_ARCH_PPC_BIT) && (GLM_MODEL == GLM_MODEL_64)\n  956: #\t\tpragma message(\"GLM: PowerPC 64 bits build target\")\n  957  #\telif (GLM_ARCH & GLM_ARCH_PPC_BIT) && (GLM_MODEL == GLM_MODEL_32)\n  958: #\t\tpragma message(\"GLM: PowerPC 32 bits build target\")\n  959  #\telse\n  960: #\t\tpragma message(\"GLM: Unknown build target\")\n  961  #\tendif//GLM_ARCH\n  962  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/type_quat.inl:\n  165  \t\telse\n  166  \t\t{\n  167: \t\t\t// Otherwise, build quaternion the standard way.\n  168  \t\t\tt = cross(u, v);\n  169  \t\t}\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/rotate_normalized_axis.hpp:\n   38  \t/// @param angle Rotation angle expressed in radians.\n   39  \t/// @param axis Rotation axis, must be normalized.\n   40: \t/// @tparam T Value type used to build the matrix. Currently supported: half (not recommended), float or double.\n   41  \t///\n   42  \t/// @see gtx_rotate_normalized_axis\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/simd/platform.h:\n  129  // Clang\n  130  #elif defined(__clang__)\n  131: #\tif defined(__apple_build_version__)\n  132  #\t\tif (__clang_major__ < 6)\n  133  #\t\t\terror \"GLM requires Clang 3.4 / Apple Clang 6.0 or higher\"\n\n/home/max/dev/Falcor/src/Externals/GLM/readme.md:\n   66  - Added C++17 detection\n   67  - Added Visual C++ language standard version detection\n   68: - Added PDF manual build from markdown\n   69  \n   70  #### Improvements:\n   ..\n   81  #### Fixes:\n   82  - Fixed SIMD detection on Clang and GCC\n   83: - Fixed build problems due to printf and std::clock_t #778\n   84  - Fixed int mod\n   85  - Anonymous unions require C++ language extensions\n   86  - Fixed ortho #790\n   87  - Fixed Visual C++ 2013 warnings in vector relational code #782\n   88: - Fixed ICC build errors with constexpr #704\n   89  - Fixed defaulted operator= and constructors #791\n   90  - Fixed invalid conversion from int scalar with vec4 constructor when using SSE instruction\n   ..\n  121  - Optimised GTX_color_space_YCoCg YCoCgR conversions\n  122  - Optimized GTX_matrix_interpolation axisAngle function\n  123: - Added FAQ 12: Windows headers cause build errors... #557\n  124  - Removed GCC shadow warnings #595\n  125  - Added error for including of different versions of GLM #619\n  ...\n  143  - Fixed axisAngle NaN #638\n  144  - Fixed integer pow from GTX_integer with null exponent #658\n  145: - Fixed quat normalize build error #656\n  146  - Fixed Visual C++ 2017.2 warning regarding __has_feature definision #655\n  147  - Fixed documentation warnings\n  ...\n  173  - Fixed Clang version detection from source #608\n  174  - Fixed packF3x9_E1x5 exponent packing #614\n  175: - Fixed build error min and max specializations with integer #616\n  176: - Fixed simd_mat4 build error #652\n  177  \n  178  ---\n  ...\n  180  #### Fixes:\n  181  - Fixed GTC_packing test failing on GCC x86 due to denorms #212 #577\n  182: - Fixed POPCNT optimization build in Clang #512\n  183  - Fixed intersectRayPlane returns true in parallel case #578\n  184  - Fixed GCC 6.2 compiler warnings #580\n  185  - Fixed GTX_matrix_decompose decompose #582 #448\n  186: - Fixed GCC 4.5 and older build #566\n  187  - Fixed Visual C++ internal error when declaring a global vec type with siwzzle expression enabled #594\n  188  - Fixed GLM_FORCE_CXX11 with Clang and libstlc++ which wasn't using C++11 STL features. #604\n  ...\n  194  \n  195  #### Fixes:\n  196: - Fixed Android build error with C++11 compiler but C++98 STL #284 #564\n  197  - Fixed GTX_transform2 shear* functions #403\n  198  - Fixed interaction between GLM_FORCE_UNRESTRICTED_GENTYPE and ortho function #568\n  199: - Fixed bitCount with AVX on 32 bit builds #567\n  200  - Fixed CMake find_package with version specification #572 #573\n  201  \n  ...\n  211  \n  212  #### Fixes:\n  213: - Fixed Visual C++ constexpr build error #555, #556\n  214  \n  215  ---\n  ...\n  259  - Factorized GLM_COMPILER_LLVM and GLM_COMPILER_APPLE_CLANG into GLM_COMPILER_CLANG\n  260  - No more warnings for use of long long\n  261: - Added more information to build messages\n  262  \n  263  #### Fixes:\n  ...\n  326  - Fixed CMake policy warning\n  327  - Fixed GCC 6.0 detection #477\n  328: - Fixed Clang build on Windows #479\n  329  - Fixed 64 bits constants warnings on GCC #463\n  330  \n  ...\n  335  - Fixed GTC_packing unpackUnorm3x10_1x2 #414\n  336  - Fixed GTC_matrix_inverse affineInverse #192\n  337: - Fixed ICC on Linux build errors #449\n  338  - Fixed ldexp and frexp compilation errors\n  339  - Fixed \"Declaration shadows a field\" warning #468\n  ...\n  341  - Fixed various 'X is not defined' warnings #468\n  342  - Fixed missing unary + operator #435\n  343: - Fixed Cygwin build errors when using C++11 #405\n  344  \n  345  ---\n  ...\n  387  - Fixed specifier removal by 'std::make_pair<>' #333\n  388  - Fixed perspective fovy argument documentation #327\n  389: - Removed -m64 causing build issues on Linux 32 #331\n  390  - Fixed isfinite with C++98 compilers #343\n  391: - Fixed Intel compiler build error on Linux #354\n  392  - Fixed use of libstdc++ with Clang #351\n  393  - Fixed quaternion pow #346\n  ...\n  416  \n  417  #### Fixes:\n  418: - Fixed faceforward build #289\n  419  - Fixed conflict with Xlib #define True 1 #293\n  420  - Fixed decompose function VS2010 templating issues #294\n  ...\n  422  - Fixed warnings in F2x11_1x10 packing function in GTC_packing #295\n  423  - Fixed Visual Studio natvis support for vec4 #288\n  424: - Fixed GTC_packing *pack*norm*x* build and added tests #292\n  425: - Disabled GTX_scalar_multiplication for GCC, failing to build tests #242\n  426  - Fixed Visual C++ 2015 constexpr errors: Disabled only partial support\n  427  - Fixed functions not inlined with Clang #302\n  ...\n  438  \n  439  #### Fixes:\n  440: - Fixed scalar uaddCarry build error with Cuda #276\n  441  - Fixed C++11 explicit conversion operators detection #282\n  442  - Fixed missing explicit conversion when using integer log2 with *vec1 types\n  443  - Fixed 64 bits integer GTX_string_cast to_string on VC 32 bit compiler\n  444: - Fixed Android build issue, STL C++11 is not supported by the NDK #284\n  445  - Fixed unsupported _BitScanForward64 and _BitScanReverse64 in VC10\n  446: - Fixed Visual C++ 32 bit build #283\n  447  - Fixed GLM_FORCE_SIZE_FUNC pragma message\n  448: - Fixed C++98 only build\n  449  - Fixed conflict between GTX_compatibility and GTC_quaternion #286\n  450  - Fixed C++ language restriction using GLM_FORCE_CXX**\n  ...\n  558  - Fixed SSE code included in GLM tests on \"pure\" platforms\n  559  - Fixed undefined reference to fastInverseSqrt (#161)\n  560: - Fixed GLM_FORCE_RADIANS with <glm/ext.hpp> build error (#165)\n  561  - Fix dot product clamp range for vector angle functions. (#163)\n  562  - Tentative fix for strict aliasing warning in GCC 4.8.1 / Android NDK 9c (#152)\n  ...\n  618  - Fixed detection to select the last known compiler if newer version #106\n  619  - Fixed is_int and is_uint code duplication with GCC and C++11 #107 \n  620: - Fixed test suite build while using Clang in C++11 mode\n  621  - Added c++1y mode support in CMake test suite\n  622  - Removed ms extension mode to CMake when no using Visual C++\n  ...\n  683  - Fixed Intel Composer Compiler support on Linux\n  684  - Fixed interaction between quaternion and euler angles\n  685: - Fixed GTC_constants build\n  686  - Fixed GTX_multiple\n  687  - Fixed quat slerp using mix function when cosTheta close to 1\n  ...\n  715  - Fixed isinf and isnan\n  716  - Improved compatibility with Intel compiler\n  717: - Added CMake test build options: SIMD, C++11, fast math and MS land ext\n  718  - Fixed SIMD mat4 test on GCC\n  719  - Fixed perspectiveFov implementation\n  ...\n  776  ---\n  777  ### [GLM 0.9.2.6](https://github.com/g-truc/glm/releases/tag/0.9.2.6) - 2011-10-01\n  778: - Fixed half based type build on old GCC\n  779  - Fixed /W4 warnings on Visual C++\n  780  - Fixed some missing l-value swizzle operators\n  ...\n  792  ---\n  793  ### GLM 0.9.2.3 - 2011-06-08\n  794: - Fixed build issues\n  795  \n  796  ---\n  ...\n  837  - Updated API documentation\n  838  - Improved SIMD implementation\n  839: - Fixed Linux build\n  840  \n  841  ---\n  ...\n  929  ### GLM 0.8.4.1 final - 2009-10-05\n  930  - Updated documentation\n  931: - Fixed MacOS X build\n  932  \n  933  ---\n  ...\n 1008  ---\n 1009  ### GLM 0.7.5 final - 2008-07-05\n 1010: - Added build message system with Visual Studio\n 1011: - Pedantic build with GCC\n 1012  \n 1013  ---\n\n/home/max/dev/Falcor/src/Externals/mikktspace/mikktspace.c:\n 1493  static void BuildNeighborsFast(STriInfo pTriInfos[], SEdge * pEdges, const int piTriListIn[], const int iNrTrianglesIn)\n 1494  {\n 1495:     // build array of edges\n 1496      unsigned int uSeed = INTERNAL_RND_SORT_SEED;                // could replace with a random seed?\n 1497      int iEntries=0, iCurStartIndex=-1, f=0, i=0;\n\n/home/max/dev/Falcor/src/Falcor/CMakeLists.txt:\n   59  \n   60  # add assimp source dir as a subdirectory, effectively making \n   61: # assimp's CMakeLists.txt part of your build\n   62  add_subdirectory( ${PROJECT_SOURCE_DIR}/third_party/assimp ${CMAKE_BINARY_DIR}/assimp)\n   63  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/FalcorD3D12.h:\n  156  #undef rt_flags\n  157  \n  158:     inline D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS getDxrBuildFlags(RtBuildFlags buildFlags)\n  159      {\n  160          D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS dxr = D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_NONE;\n  161  \n  162:         if (is_set(buildFlags, RtBuildFlags::AllowUpdate)) dxr |= D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_ALLOW_UPDATE;\n  163:         if (is_set(buildFlags, RtBuildFlags::AllowCompaction)) dxr |= D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_ALLOW_COMPACTION;\n  164:         if (is_set(buildFlags, RtBuildFlags::FastTrace)) dxr |= D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_PREFER_FAST_TRACE;\n  165:         if (is_set(buildFlags, RtBuildFlags::FastBuild)) dxr |= D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_PREFER_FAST_BUILD;\n  166:         if (is_set(buildFlags, RtBuildFlags::MinimizeMemory)) dxr |= D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_MINIMIZE_MEMORY;\n  167:         if (is_set(buildFlags, RtBuildFlags::PerformUpdate)) dxr |= D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_PERFORM_UPDATE;\n  168  \n  169          return dxr;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Device.h:\n   75          uint32_t apiMinorVersion = 0;                                   ///< Requested API minor version. If specified, device creation will fail if not supported. Otherwise, the highest supported version will be automatically selected.\n   76          bool enableVsync = false;                                       ///< Controls vertical-sync\n   77:         bool enableDebugLayer = DEFAULT_ENABLE_DEBUG_LAYER;             ///< Enable the debug layer. The default for release build is false, for debug build it's true.\n   78  \n   79          static_assert((uint32_t)LowLevelContextData::CommandQueueType::Direct == 2, \"Default initialization of cmdQueues assumes that Direct queue index is 2\");\n\n/home/max/dev/Falcor/src/Falcor/Core/API/RootSignature.cpp:\n  189      d.setLocal(true);\n  190  #else\n  191:     logWarning(\"Local root-signatures are only supported in D3D12 for use with DXR. Make sure you are using the correct build configuration.\");\n  192:     throw std::runtime_error(\"Local root-signatures are only supported in D3D12 for use with DXR. Make sure you are using the correct build configuration.\");\n  193  #endif\n  194  \n\n/home/max/dev/Falcor/src/Falcor/Core/Program/Program.h:\n   55      class dlldecl Desc {\n   56       public:\n   57:         /** Begin building a description, that initially has no source files or entry points.\n   58          */\n   59          Desc();\n   60  \n   61:         /** Begin building a description, based on a single path for source code.\n   62              This is equivalent to: `Desc().sourceFile(path)`\n   63          */\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramReflection.cpp:\n  715              pSlangType);\n  716  \n  717:         ReflectionStructType::BuildState buildState;\n  718  \n  719          for (uint32_t i = 0; i < pSlangType->getFieldCount(); i++) {\n  ...\n  727                  &fieldPath,\n  728                  pProgramVersion);\n  729:             if(pVar) pType->addMember(pVar, buildState);\n  730          }\n  731          return pType;\n  ...\n 1190          pDefaultBlock->setElementType(pGlobalStruct);\n 1191  \n 1192:         ReflectionStructType::BuildState buildState;\n 1193          for (uint32_t i = 0; i < pSlangReflector->getParameterCount(); i++)\n 1194          {\n ....\n 1200                  pDefaultBlock.get(),\n 1201                  pProgramVersion);\n 1202:             if(pVar) pGlobalStruct->addMember(pVar, buildState);\n 1203          }\n 1204  \n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/BuildTriangleList.cs.slang:\n   46  \n   47  \n   48: /** Kernel building the emissive triangles list for all mesh lights.\n   49      One dispatch per mesh light with one thread per triangle.\n   50  */\n   51  [numthreads(256, 1, 1)]\n   52: void buildTriangleList(uint3 DTid : SV_DispatchThreadID)\n   53  {\n   54      if (DTid.x >= gTriangleCount) return;\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/EmissiveUniformSampler.h:\n   48          {\n   49              // TODO\n   50:             //bool        usePreintegration = true;           ///< Use pre-integrated flux per triangle to guide BVH build/sampling. Only relevant if mUseBVHTree == true.\n   51          };\n   52  \n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/EnvProbe.slang:\n   30  \n   31      Use the class EnvProbe on the host to load and prepare the env map.\n   32:     The class builds an hierarchical importance map, which is used here\n   33      for importance sampling.\n   34  */\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/EnvProbeSetup.cs.slang:\n   27   **************************************************************************/\n   28  \n   29: /** Compute shader for building a hierarchical importance map from an\n   30      environment map. The result is used by EnvProbe.slang for sampling.\n   31  */\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVH.cpp:\n  325  \n  326          // Update our GPU side buffers.\n  327:         // TODO: This is slow. We will build the buffer on the GPU in the future.\n  328          assert(mpBVHNodesBuffer->getSize() >= bvhByteSize);\n  329          mpBVHNodesBuffer->setBlob(mAlignedAllocator.getStartPointer(), 0, bvhByteSize);\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVH.h:\n   52          \"Importance Sampling of Many Lights on the GPU\", Ray Tracing Gems, Ch. 18, 2019.\n   53  \n   54:         Before being used, the BVH needs to have been built using |LightBVHBuilder::build()|.\n   55          The data can be both used on the CPU (using |traverseBVH()| or the getters like |getInternalNode()|)\n   56          or on the GPU (1. declare a variable of type |LightBVH| in your shader, 2. call |setShaderData()|\n   ..\n  128          using TraversalEvalFunction = std::function<bool(const NodeLocation& location, const InternalNode* pInternalNode, const LeafNode* pLeafNode)>;\n  129  \n  130:         /** Creates an empty LightBVH object. Use a LightBVHBuilder to build the BVH.\n  131              \\param[in] pLightCollection The light collection around which the BVH will be built.\n  132          */\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVHBuilder.cpp:\n  195      }\n  196  \n  197:     void LightBVHBuilder::build(LightBVH& bvh) {\n  198:         PROFILE(bvh.device(), \"LightBVHBuilder::build()\");\n  199  \n  200          bvh.clear();\n  ...\n  207  \n  208          // Compute list of triangles that should be included in BVH.\n  209:         // For each triangle, precompute data we need for the build.\n  210          BuildingData data(bvh.mAlignedAllocator);\n  211          data.trianglesData.reserve(triangles.size());\n  ...\n  230          if (data.trianglesData.empty()) return;\n  231  \n  232:         // Allocate temporary memory for the BVH build.\n  233          bvh.reserve(data.trianglesData.size());\n  234          const uint64_t invalidBitmask = std::numeric_limits<uint64_t>::max();\n  ...\n  237          // Build the tree.\n  238          SplitHeuristicFunction splitFunc = getSplitFunction(mOptions.splitHeuristicSelection);\n  239:         buildInternal(mOptions, splitFunc, 0ull, 0u, Range(0u, static_cast<uint32_t>(data.trianglesData.size())), data);\n  240  \n  241          const uint32_t bvhByteSize = static_cast<uint32_t>(bvh.mAlignedAllocator.getSize());\n  ...\n  262  \n  263      bool LightBVHBuilder::renderUI(Gui::Widgets& widget) {\n  264:         // Render the build options.\n  265          return renderOptions(widget, mOptions);\n  266      }\n  ...\n  301      LightBVHBuilder::LightBVHBuilder(const Options& options) : mOptions(options) {}\n  302  \n  303:     void* LightBVHBuilder::buildInternal(const Options& options, const SplitHeuristicFunction& splitHeuristic, uint64_t bitmask, uint32_t depth, const Range& triangleRange, BuildingData& data) {\n  304          assert(triangleRange.begin < triangleRange.end);\n  305  \n  ...\n  338  \n  339              uint32_t currentByteOffset = static_cast<uint32_t>(data.alignedAllocator.offsetOf(pNode));\n  340:             void* pLeft = buildInternal(options, splitHeuristic, bitmask | (0ull << depth), depth + 1u, Range(triangleRange.begin, splitResult.triangleIndex), data);\n  341:             void* pRight = buildInternal(options, splitHeuristic, bitmask | (1ull << depth), depth + 1u, Range(splitResult.triangleIndex, triangleRange.end), data);\n  342  \n  343              if (data.alignedAllocator.offsetOf(pLeft) > std::numeric_limits<uint32_t>::max() ||\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVHBuilder.h:\n   38  \n   39  namespace Falcor {\n   40:     /** Utility class for building 2-way light BVH on the CPU.\n   41  \n   42:         The building process can be customized via the |Options|,\n   43          which are also available in the GUI via the |renderUI()| function.\n   44  \n   ..\n   56          };\n   57  \n   58:         /** Light BVH builder configuration options.\n   59              Note if you change options, please update SCRIPT_BINDING in LightBVHBuilder.cpp\n   60          */\n   61          struct Options : Falcor::ScriptBindings::enable_to_string {\n   62:             SplitHeuristic splitHeuristicSelection = SplitHeuristic::BinnedSAOH; ///< Which splitting heuristic to use when building.\n   63              uint32_t       maxTriangleCountPerLeaf = 10u;                        ///< How many triangles to store at most per leaf node.\n   64:             uint32_t       binCount = 16u;                                       ///< How many bins to use when building the BVH.\n   65              float          volumeEpsilon = 1e-3f;                                ///< If a node has an AABB which is 0 along one (or more) of its dimensions, use this epsilon instead for that dimension. Only used when 'useVolumeOverSA' is enabled.\n   66              bool           splitAlongLargest = false;                            ///< Rather than computing a split along each of the 3 dimensions and selecting the best one, only compute the split along the largest dimension.\n   ..\n   68              bool           useLeafCreationCost = true;                           ///< Set to true to avoid splitting when the cost is higher than the cost of creating a leaf node. Only used when 'createLeavesASAP' is disabled.\n   69              bool           createLeavesASAP = true;                              ///< Rather than creating a leaf only once splitting stops, create it as soon as we can.\n   70:             bool           allowRefitting = true;                                ///< Rather than always rebuilding the BVH from scratch, keep the hierarchy but update the bounds and lighting cones.\n   71              bool           usePreintegration = true;                             ///< Use pre-integration for culling out emissive triangles and use their flux when computing the splits. Only valid when using the BinnedSAOH split heuristic.\n   72              bool           useLightingCones = true;                              ///< Use lighting cones when computing the splits. Only valid when using the BinnedSAOH split heuristic.\n   ..\n   74  \n   75          /** Creates a new object.\n   76:             \\param[in] options The options to use for building the BVH.\n   77          */\n   78          static SharedPtr create(const Options& options);\n   79  \n   80          /** Build the BVH.\n   81:             \\param[in,out] bvh The light BVH to build.\n   82          */\n   83:         void build(LightBVH& bvh);\n   84  \n   85          virtual bool renderUI(Gui::Widgets& widget);\n   ..\n  118          struct BuildingData {\n  119              AlignedAllocator& alignedAllocator;                                 ///< Allocator used for allocating the BVH nodes.\n  120:             std::vector<TriangleSortData> trianglesData;                        ///< Compact list of triangles to include in build.\n  121:             std::vector<uint64_t> triangleBitmasks;                             ///< Array containing the per triangle bit pattern retracing the tree traversal to reach the triangle: 0=left child, 1=right child; this array gets filled in during the build process. Indexed by global triangle index.\n  122              float currentNodeFlux = 0.f;                                        ///< Used by computeSAOHSplit() as the leaf creation cost.\n  123  \n  ...\n  129              \\param[in] triangleRange Range of triangles to process.\n  130              \\param[in] nodeBounds Bounds for the node to be splitted.\n  131:             \\param[in] parameters Various parameters defining how the building should occur.\n  132          */\n  133          using SplitHeuristicFunction = std::function<SplitResult(const BuildingData& data, const Range& triangleRange, const BBox& nodeBounds, const Options& parameters)>;\n  ...\n  135          LightBVHBuilder(const Options& options);\n  136  \n  137:         /** Renders the UI with builder options.\n  138          */\n  139          bool renderOptions(Gui::Widgets& widget, Options& options) const;\n  140  \n  141:         /** Recursive BVH build.\n  142              \\param[in] splitHeuristic The splitting heuristic to be used.\n  143              \\param[in] bitmask Bit pattern retracing the tree traversal to reach the node to be built: 0=left child, 1=right child.\n  ...\n  147              \\return pointer to the allocated node.\n  148          */\n  149:         static void* buildInternal(const Options& options, const SplitHeuristicFunction& splitHeuristic, uint64_t bitmask, uint32_t depth, const Range& triangleRange, BuildingData& data);\n  150  \n  151          /** Recursive computation of lighting cones for all internal nodes.\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVHSampler.cpp:\n   57          // Check if light collection has changed.\n   58          if (is_set(mpScene->getUpdates(), Scene::UpdateFlags::LightCollectionChanged)) {\n   59:             if (mOptions.buildOptions.allowRefitting && !mNeedsRebuild) needsRefit = true;\n   60:             else mNeedsRebuild = true;\n   61          }\n   62  \n   63:         // Rebuild BVH if it's marked as dirty.\n   64:         if (mNeedsRebuild) {\n   65:             mpBVHBuilder->build(*mpBVH);\n   66:             mNeedsRebuild = false;\n   67              samplerChanged = true;\n   68          }\n   ..\n   85          pProgram->addDefine(\"_DISABLE_NODE_FLUX\", mOptions.disableNodeFlux ? \"1\" : \"0\");\n   86          pProgram->addDefine(\"_USE_UNIFORM_TRIANGLE_SAMPLING\", mOptions.useUniformTriangleSampling ? \"1\" : \"0\");\n   87:         pProgram->addDefine(\"_ACTUAL_MAX_TRIANGLES_PER_NODE\", std::to_string(mOptions.buildOptions.maxTriangleCountPerLeaf));\n   88          pProgram->addDefine(\"_SOLID_ANGLE_BOUND_METHOD\", std::to_string((uint32_t)mOptions.solidAngleBoundMethod));\n   89  \n   ..\n  109          bool optionsChanged = false;\n  110  \n  111:         auto buildGroup = Gui::Group(widgets, \"BVH building options\");\n  112:         if (buildGroup.open()) {\n  113:             if (mpBVHBuilder->renderUI(buildGroup)) {\n  114:                 mOptions.buildOptions = mpBVHBuilder->getOptions();\n  115:                 mNeedsRebuild = optionsChanged = true;\n  116              }\n  117  \n  118:             buildGroup.release();\n  119          }\n  120  \n  ...\n  123              optionsChanged |= traversalGroup.checkbox(\"Use bounding cone (NdotL)\", mOptions.useBoundingCone);\n  124              if (traversalGroup.checkbox(\"Use lighting cone\", mOptions.useLightingCone)) {\n  125:                 mNeedsRebuild = optionsChanged = true;\n  126              }\n  127              optionsChanged |= traversalGroup.checkbox(\"Disable node flux\", mOptions.disableNodeFlux);\n  ...\n  129  \n  130              if (traversalGroup.dropdown(\"Solid Angle Bound\", kSolidAngleBoundList, (uint32_t&)mOptions.solidAngleBoundMethod)) {\n  131:                 mNeedsRebuild = optionsChanged = true;\n  132              }\n  133  \n  ...\n  151          : EmissiveLightSampler(EmissiveLightSamplerType::LightBVH, pScene)\n  152          , mOptions(options) {\n  153:         // Create the BVH and builder.\n  154:         mpBVHBuilder = LightBVHBuilder::create(mOptions.buildOptions);\n  155          if (!mpBVHBuilder) {\n  156:             throw std::runtime_error(\"Failed to create BVH builder\");\n  157          }\n  158          mpBVH = LightBVH::create(pRenderContext->device(), pScene->getLightCollection(pRenderContext));\n  ...\n  171          auto options = m.class_<LightBVHSampler::Options>(\"LightBVHSamplerOptions\");\n  172  #define field(f_) rwField(#f_, &LightBVHSampler::Options::f_)\n  173:         options.field(buildOptions);\n  174          options.field(useBoundingCone);\n  175          options.field(useLightingCone);\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVHSampler.h:\n   45  \n   46          This class wraps a LightCollection object, which holds the set of lights to sample.\n   47:         Internally, the class build a BVH over the light sources.\n   48      */\n   49      class dlldecl LightBVHSampler : public EmissiveLightSampler, public inherit_shared_from_this<EmissiveLightSampler, LightBVHSampler>\n   ..\n   60              Options() noexcept {};\n   61              // Build options\n   62:             LightBVHBuilder::Options buildOptions;\n   63  \n   64              // Traversal options\n   ..\n  121  \n  122          // Internal state\n  123:         LightBVHBuilder::SharedPtr      mpBVHBuilder;           ///< The light BVH builder.\n  124          LightBVH::SharedPtr             mpBVH;                  ///< The light BVH.\n  125:         bool                            mNeedsRebuild = true;   ///< Trigger rebuild on the next call to update(). We should always build on the first call, so the initial value is true.\n  126      };\n  127  }\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightCollection.cpp:\n  125          if (!initIntegrator(pRenderContext)) return false;\n  126  \n  127:         // Create programs for building/updating the mesh lights.\n  128          Shader::DefineList defines = mpScene->getSceneDefines();\n  129:         mpTriangleListBuilder = ComputePass::create(mpDevice, kBuildTriangleListFile, \"buildTriangleList\", defines);\n  130          mpTrianglePositionUpdater = ComputePass::create(mpDevice, kUpdateTriangleVerticesFile, \"updateTriangleVertices\", defines);\n  131          mpFinalizeIntegration = ComputePass::create(mpDevice, kFinalizeIntegrationFile, \"finalizeIntegration\", defines);\n  ...\n  133          mpStagingFence = GpuFence::create(mpDevice);\n  134  \n  135:         // Now build the mesh light data.\n  136:         build(pRenderContext);\n  137  \n  138          return true;\n  ...\n  229      }\n  230  \n  231:     void LightCollection::build(RenderContext* pRenderContext) {\n  232          if (mTriangleCount == 0) {\n  233              // If there are no emissive triangle, clear everything and mark the CPU data/stats as valid.\n  ...\n  269  \n  270          // Compute triangle data (vertices, uv-coordinates, materialID) for all mesh lights.\n  271:         buildTriangleList(pRenderContext);\n  272      }\n  273  \n  ...\n  403      }\n  404  \n  405:     void LightCollection::buildTriangleList(RenderContext* pRenderContext) {\n  406          assert(mMeshLights.size() > 0);\n  407  \n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightCollection.h:\n  184      bool initIntegrator(RenderContext* pRenderContext);\n  185      bool setupMeshLights();\n  186:     void build(RenderContext* pRenderContext);\n  187      void prepareTriangleData(RenderContext* pRenderContext);\n  188      void prepareMeshData(RenderContext* pRenderContext);\n  189      void integrateEmissive(RenderContext* pRenderContext);\n  190      void computeStats() const;\n  191:     void buildTriangleList(RenderContext* pRenderContext);\n  192      void updateTrianglePositions(RenderContext* pRenderContext, const std::vector<uint32_t>& updatedLights);\n  193  \n\n/home/max/dev/Falcor/src/Falcor/Falcor.props:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ImportGroup Label=\"PropertySheets\" />\n    4    <PropertyGroup Label=\"UserMacros\">\n\n/home/max/dev/Falcor/src/Falcor/Falcor.vcxproj:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup Label=\"ProjectConfigurations\">\n    4      <ProjectConfiguration Include=\"DebugD3D12|x64\">\n    .\n  793      </Link>\n  794      <PreBuildEvent>\n  795:       <Command>call $(ProjectDir)\\..\\..\\Build\\prebuild.bat $(ProjectDir)\\..\\ $(SolutionDir) $(ProjectDir) $(PlatformName) $(PlatformShortName) $(Configuration) $(OutDir)</Command>\n  796      </PreBuildEvent>\n  797      <CustomBuildStep>\n  ...\n  831      </Link>\n  832      <PreBuildEvent>\n  833:       <Command>call $(ProjectDir)\\..\\..\\Build\\prebuild.bat $(ProjectDir)\\..\\ $(SolutionDir) $(ProjectDir) $(PlatformName) $(PlatformShortName) $(Configuration) $(OutDir)</Command>\n  834      </PreBuildEvent>\n  835      <CustomBuildStep>\n  ...\n  874      </Link>\n  875      <PreBuildEvent>\n  876:       <Command>call $(ProjectDir)\\..\\..\\Build\\prebuild.bat $(ProjectDir)\\..\\ $(SolutionDir) $(ProjectDir) $(PlatformName) $(PlatformShortName) $(Configuration) $(OutDir)</Command>\n  877      </PreBuildEvent>\n  878      <CustomBuildStep>\n  ...\n  916      </Link>\n  917      <PreBuildEvent>\n  918:       <Command>call $(ProjectDir)\\..\\..\\Build\\prebuild.bat $(ProjectDir)\\..\\ $(SolutionDir) $(ProjectDir) $(PlatformName) $(PlatformShortName) $(Configuration) $(OutDir)</Command>\n  919      </PreBuildEvent>\n  920      <CustomBuildStep>\n\n/home/max/dev/Falcor/src/Falcor/Falcor.vcxproj.filters:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup>\n    4      <ClInclude Include=\"Core\\API\\D3D12\\D3D12DescriptorData.h\">\n\n/home/max/dev/Falcor/src/Falcor/Raytracing/RtProgramVars.cpp:\n   89          // TODO: We could easily support multiple \"instances\" of ray generation\n   90          // programs without requiring the SBT for miss or hit shaders to be\n   91:         // rebuild on parameter changes. It might make sense for ray-gen programs\n   92          // to be more flexibly allocated.\n   93          //\n\n/home/max/dev/Falcor/src/Falcor/Raytracing/RtProgramVarsHelper.h:\n  127          void InitializeMetaCommand(ID3D12MetaCommand *pMetaCommand, const void *pInitializationParametersData, SIZE_T InitializationParametersDataSizeInBytes) { should_not_get_here(); }\n  128          void ExecuteMetaCommand(ID3D12MetaCommand *pMetaCommand, const void *pExecutionParametersData, SIZE_T ExecutionParametersDataSizeInBytes) { should_not_get_here(); }\n  129:         void BuildRaytracingAccelerationStructure(const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC *pDesc, UINT NumPostbuildInfoDescs, const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC *pPostbuildInfoDescs) { should_not_get_here(); }\n  130:         void EmitRaytracingAccelerationStructurePostbuildInfo(const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC *pDesc, UINT NumSourceAccelerationStructures, const D3D12_GPU_VIRTUAL_ADDRESS *pSourceAccelerationStructureData) { should_not_get_here(); }\n  131          void CopyRaytracingAccelerationStructure(D3D12_GPU_VIRTUAL_ADDRESS DestAccelerationStructureData, D3D12_GPU_VIRTUAL_ADDRESS SourceAccelerationStructureData, D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE Mode) { should_not_get_here(); }\n  132          void SetPipelineState1(ID3D12StateObject *pStateObject) { should_not_get_here(); }\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraphUI.cpp:\n  438          passUI.mOutputPins[outputIt->second].mIsGraphOutput = true;\n  439          mpIr->markOutput(outputParam);\n  440:         mRebuildDisplayData = true;\n  441          mShouldUpdate = true;\n  442      }\n  ...\n  520                  if (dstField[0] == '#')\n  521                  {\n  522:                     // rebuilds data to avoid repeated code\n  523:                     mRebuildDisplayData = true;\n  524                      color = kExecutionEdgeColor;\n  525                      mpIr->addEdge(srcPass, dstPass);\n  ...\n  555      void RenderGraphUI::removeRenderPass(const std::string& name)\n  556      {\n  557:         mRebuildDisplayData = true;\n  558          mpIr->removePass(name);\n  559          mShouldUpdate = true;\n  ...\n  578          if (mpRenderGraph->compile(pContext) == false) mLogString += \"Graph is currently invalid\\n\";\n  579          mShouldUpdate = false;\n  580:         mRebuildDisplayData = true;\n  581      }\n  582  \n  ...\n  882  \n  883          // update the deleted links from the GUI since the library doesn't call its own callback\n  884:         if (mRebuildDisplayData)\n  885          {\n  886:             mRebuildDisplayData = false;\n  887              mpNodeGraphEditor->setNodeCallback(nullptr);\n  888              mpNodeGraphEditor->reset();\n  ...\n 1090          mpNodeGraphEditor->reset();\n 1091          mpNodeGraphEditor->clear();\n 1092:         mRebuildDisplayData = true;\n 1093      }\n 1094  \n ....\n 1299          mInputPinStringToLinkID.clear();\n 1300  \n 1301:         // build information for displaying graph\n 1302          for (const auto& nameToIndex : mpRenderGraph->mNameToIndex)\n 1303          {\n ....\n 1326              }\n 1327  \n 1328:             // clear and rebuild reflection for each pass.\n 1329              renderPassUI.mReflection = mpRenderGraph->mNodeData[nameToIndex.second].pPass->reflect({});\n 1330  \n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraphUI.h:\n   86          void renderUI(RenderContext* pContext, Gui *pGui);\n   87  \n   88:         /** Clear graph ui for rebuilding node graph\n   89          */\n   90          void reset();\n   91  \n   92:         /** Set ui to rebuild all display data before next render ui\n   93          */\n   94:         void setToRebuild() { mRebuildDisplayData = true; }\n   95  \n   96          /** Writes out all the changes made to the graph\n   ..\n  134          std::string getCurrentLog() const { return mLogString; }\n  135  \n  136:         /** Toggle building up delta changes for live preview\n  137          */\n  138          void setRecordUpdates(bool recordUpdates);\n  ...\n  197          std::unordered_map <std::string, std::vector< std::pair<uint32_t, uint32_t > > > mOutputToInputPins;\n  198  \n  199:         // if in external editing mode, building list of commands for changes to send to the other process\n  200          std::string mUpdateCommands;\n  201          std::string mLastCommand;\n  ...\n  213          std::shared_ptr<NodeGraphEditorGui> mpNodeGraphEditor;\n  214  \n  215:         // Flag to re-traverse the graph and build on of the intermediate data again.\n  216:         bool mRebuildDisplayData = true;\n  217          bool mShouldUpdate = false;\n  218      };\n\n/home/max/dev/Falcor/src/Falcor/Scene/Importers/AssimpImporter.cpp:\n  169          class ImporterData {\n  170           public:\n  171:             ImporterData(const aiScene* pAiScene, SceneBuilder& sceneBuilder, const SceneBuilder::InstanceMatrices& modelInstances_) : pScene(pAiScene), modelInstances(modelInstances_), builder(sceneBuilder) {}\n  172              const aiScene* pScene;\n  173  \n  174:             SceneBuilder& builder;\n  175              std::map<uint32_t, Material::SharedPtr> materialMap;\n  176              std::map<uint32_t, uint32_t> meshMap; // Assimp mesh index to Falcor mesh ID\n  ...\n  293              }\n  294  \n  295:             if (data.builder.hasCamera()) {\n  296                  logWarning(\"Found cameras in model file, but the scene already contains a camera. Ignoring the new camera\");\n  297                  return true;\n  ...\n  321                  // GLTF2 has the view direction reversed.\n  322                  if (importMode == ImportMode::GLTF2) n.transform[2] = -n.transform[2];\n  323:                 nodeID = data.builder.addNode(n);\n  324              }\n  325  \n  326              // Find if the camera is affected by a node\n  327:             data.builder.setCamera(pCamera, nodeID);\n  328              return true;\n  329          }\n  ...\n  341                  n.parent = nodeID;\n  342                  n.transform = baseMatrix;\n  343:                 nodeID = data.builder.addNode(n);\n  344              }\n  345:             data.builder.addLight(pLight, nodeID);\n  346  \n  347              return true;\n  ...\n  400              for (uint32_t i = 0; i < data.pScene->mNumAnimations; i++) {\n  401                  Animation::SharedPtr pAnimation = createAnimation(data, data.pScene->mAnimations[i]);\n  402:                 data.builder.addAnimation(0, pAnimation);\n  403              }\n  404              return true;\n  ...\n  517                  mesh.pMaterial = data.materialMap.at(pAiMesh->mMaterialIndex);\n  518                  assert(mesh.pMaterial);\n  519:                 uint32_t meshID = data.builder.addMesh(mesh);\n  520                  if (meshID == SceneBuilder::kInvalidNode) return false;\n  521                  data.meshMap[i] = meshID;\n  ...\n  581              n.localToBindPose = getLocalToBindPoseMatrix(data, n.name);\n  582  \n  583:             data.addAiNode(pCurrent, data.builder.addNode(n));\n  584  \n  585              bool b = true;\n  ...\n  627                              n.parent = nodeID;\n  628                              n.transform = data.modelInstances[instance];\n  629:                             instanceNodeID = data.builder.addNode(n);\n  630                          }\n  631:                         data.builder.addMeshInstance(instanceNodeID, meshID);\n  632                      }\n  633                  }\n  634:                 else data.builder.addMeshInstance(nodeID, meshID);\n  635              }\n  636  \n  ...\n  696              // Determine shading model.\n  697              // MetalRough is the default for everything except OBJ. Check that both flags aren't set simultaneously.\n  698:             SceneBuilder::Flags builderFlags = data.builder.getFlags();\n  699:             assert(!(is_set(builderFlags, SceneBuilder::Flags::UseSpecGlossMaterials) && is_set(builderFlags, SceneBuilder::Flags::UseMetalRoughMaterials)));\n  700:             if (is_set(builderFlags, SceneBuilder::Flags::UseSpecGlossMaterials) || (importMode == ImportMode::OBJ && !is_set(builderFlags, SceneBuilder::Flags::UseMetalRoughMaterials))) {\n  701                  pMaterial->setShadingModel(ShadingModelSpecGloss);\n  702              }\n  ...\n  806  \n  807          bool createAllMaterials(std::shared_ptr<Device> pDevice, ImporterData& data, const std::string& modelFolder, ImportMode importMode) {\n  808:             bool useSrgb = !is_set(data.builder.getFlags(), SceneBuilder::Flags::AssumeLinearSpaceTextures);\n  809  \n  810              for (uint32_t i = 0; i < data.pScene->mNumMaterials; i++) {\n  ...\n  895      }\n  896  \n  897:     bool AssimpImporter::import(std::shared_ptr<Device> pDevice, const std::string& filename, SceneBuilder& builder, const InstanceMatrices& meshInstances) {\n  898          std::string fullpath;\n  899          if (findFileInDataDirectories(filename, fullpath) == false) {\n  ...\n  902          }\n  903  \n  904:         SceneBuilder::Flags builderFlags = builder.getFlags();\n  905          uint32_t assimpFlags = aiProcessPreset_TargetRealtime_MaxQuality |\n  906              aiProcess_FlipUVs |\n  ...\n  911          assimpFlags &= ~(aiProcess_OptimizeGraph); // Never use as it doesn't handle transforms with negative determinants\n  912          assimpFlags &= ~(aiProcess_RemoveRedundantMaterials); // Avoid merging materials\n  913:         if (is_set(builderFlags, SceneBuilder::Flags::DontMergeMeshes)) assimpFlags &= ~aiProcess_OptimizeMeshes; // Avoid merging original meshes\n  914  \n  915          Assimp::Importer importer;\n  ...\n  929          std::string modelFolder = fullpath.substr(0, last);\n  930  \n  931:         ImporterData data(pScene, builder, meshInstances);\n  932  \n  933          // Enable special treatment for obj and gltf files\n  ...\n  973      }\n  974  \n  975:     bool AssimpImporter::import(std::shared_ptr<Device> pDevice, const std::string& filename, SceneBuilder& builder) {\n  976          InstanceMatrices meshInstances(1);\n  977:         return import(pDevice, filename, builder, meshInstances);\n  978      }\n  979  \n\n/home/max/dev/Falcor/src/Falcor/Scene/Importers/AssimpImporter.h:\n   40      using InstanceMatrices = SceneBuilder::InstanceMatrices;\n   41  \n   42:     static bool import(std::shared_ptr<Device> pDevice, const std::string& filename, SceneBuilder& builder);\n   43:     static bool import(std::shared_ptr<Device> pDevice, const std::string& filename, SceneBuilder& builder, const InstanceMatrices& meshInstances);\n   44   private:\n   45      AssimpImporter() = default;\n\n/home/max/dev/Falcor/src/Falcor/Scene/Importers/PythonImporter.cpp:\n   41  class PythonImporterImpl {\n   42   public:\n   43:     PythonImporterImpl(std::shared_ptr<Device> pDevice, SceneBuilder& builder) : mpDevice(pDevice), mBuilder(builder) {}\n   44      bool load(const std::string& filename);\n   45  \n   ..\n   92  }\n   93  \n   94: bool PythonImporter::import(std::shared_ptr<Device> pDevice, const std::string& filename, SceneBuilder& builder) {\n   95:     PythonImporterImpl importer(pDevice, builder);\n   96      return importer.load(filename);\n   97  }\n\n/home/max/dev/Falcor/src/Falcor/Scene/Importers/PythonImporter.h:\n   38  class PythonImporter {\n   39   public:\n   40:     static bool import(std::shared_ptr<Device> pDevice, const std::string& filename, SceneBuilder& builder);\n   41   private:\n   42      PythonImporter() = default;\n\n/home/max/dev/Falcor/src/Falcor/Scene/Importers/SceneImporter.cpp:\n  116  class SceneImporterImpl {\n  117   public:\n  118:     SceneImporterImpl(std::shared_ptr<Device> pDevice, SceneBuilder& builder) : mpDevice(pDevice), mBuilder(builder) {}\n  119      bool load(const std::string& filename);\n  120  \n  ...\n  275  \n  276      // Parse additional properties that affect loading\n  277:     SceneBuilder::Flags buildFlags = mBuilder.getFlags();\n  278      if (jsonModel.HasMember(SceneKeys::kMaterial)) {\n  279          const auto& materialSettings = jsonModel[SceneKeys::kMaterial];\n  ...\n  285              if (m->name == SceneKeys::kShadingModel) {\n  286                  if (m->value == SceneKeys::kShadingSpecGloss) {\n  287:                     buildFlags |= SceneBuilder::Flags::UseSpecGlossMaterials;\n  288                  } else if (m->value == SceneKeys::kShadingMetalRough) {\n  289:                     buildFlags |= SceneBuilder::Flags::UseMetalRoughMaterials;\n  290                  } else {\n  291                      return error(\"Invalid value found in \" + std::string(SceneKeys::kShadingModel) + \". Value == \" + std::string(m->value.GetString()) + \".\");\n  ...\n  918  \n  919  \n  920: bool SceneImporter::import(std::shared_ptr<Device> pDevice, const std::string& filename, SceneBuilder& builder) {\n  921      logWarning(\"fscene files are no longer supported in Falcor 4.0. Some properties may not be loaded.\");\n  922:     SceneImporterImpl importer(pDevice, builder);\n  923      return importer.load(filename);\n  924  }\n\n/home/max/dev/Falcor/src/Falcor/Scene/Importers/SceneImporter.h:\n   38  class SceneImporter {\n   39   public:\n   40:     static bool import(std::shared_ptr<Device> pDevice, const std::string& filename, SceneBuilder& builder);\n   41   private:\n   42      SceneImporter() = default;\n\n/home/max/dev/Falcor/src/Falcor/Scene/Scene.cpp:\n  441      if (mBlasData.size() && mHasSkinnedMesh && is_set(mUpdates, UpdateFlags::SceneGraphChanged)) {\n  442          mTlasCache.clear();\n  443:         buildBlas(pContext);\n  444      }\n  445      #endif\n  ...\n  765  }\n  766  \n  767: void Scene::buildBlas(RenderContext* pContext) {\n  768:     PROFILE(\"buildBlas\");\n  769  \n  770      // Get the VB and IB\n  ...\n  779          if (blas.pBlas != nullptr && !blas.hasSkinnedMesh) continue; // Skip updating BLASes not containing skinned meshes\n  780  \n  781:         // Setup build parameters and get prebuild info\n  782          D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS inputs = {};\n  783          inputs.Type = D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL;\n  ...\n  795          }\n  796  \n  797:         // Allocate scratch and BLAS buffers on the first build\n  798          if (blas.pBlas == nullptr) {\n  799              GET_COM_INTERFACE(gpDevice->getApiHandle(), ID3D12Device5, pDevice5);\n  800:             pDevice5->GetRaytracingAccelerationStructurePrebuildInfo(&inputs, &blas.prebuildInfo);\n  801  \n  802              // #SCENE This isn't guaranteed according to the spec, and the scratch buffer being stored should be sized differently depending on update mode\n  803:             assert(blas.prebuildInfo.UpdateScratchDataSizeInBytes <= blas.prebuildInfo.ScratchDataSizeInBytes);\n  804  \n  805:             blas.pScratchBuffer = Buffer::create(blas.prebuildInfo.ScratchDataSizeInBytes, Buffer::BindFlags::UnorderedAccess, Buffer::CpuAccess::None);\n  806:             blas.pBlas = Buffer::create(blas.prebuildInfo.ResultDataMaxSizeInBytes, Buffer::BindFlags::AccelerationStructure, Buffer::CpuAccess::None);\n  807          } else {\n  808:             // For any rebuild and refits, just add a barrier\n  809              assert(blas.pScratchBuffer != nullptr);\n  810  \n  ...\n  891  }\n  892  \n  893: void Scene::buildTlas(RenderContext* pContext, uint32_t rayCount, bool perMeshHitEntry) {\n  894:     PROFILE(\"buildTlas\");\n  895  \n  896      TlasData tlas;\n  ...\n  906      inputs.Flags = D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_NONE;\n  907  \n  908:     // Add build flags for dynamic scenes if TLAS should be updating instead of rebuilt\n  909      if (mpAnimationController->hasAnimations() && mTlasUpdateMode == UpdateMode::Refit) {\n  910          inputs.Flags |= D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_ALLOW_UPDATE;\n  ...\n  916      tlas.updateMode = mTlasUpdateMode;\n  917  \n  918:     // On first build for the scene, create scratch buffer and cache prebuild info. As long as INSTANCE_DESC count doesn't change, we can reuse these\n  919      if (mpTlasScratch == nullptr) {\n  920:         // Prebuild\n  921          GET_COM_INTERFACE(gpDevice->getApiHandle(), ID3D12Device5, pDevice5);\n  922:         pDevice5->GetRaytracingAccelerationStructurePrebuildInfo(&inputs, &mTlasPrebuildInfo);\n  923:         mpTlasScratch = Buffer::create(mTlasPrebuildInfo.ScratchDataSizeInBytes, Buffer::BindFlags::UnorderedAccess, Buffer::CpuAccess::None);\n  924  \n  925          // #SCENE This isn't guaranteed according to the spec, and the scratch buffer being stored should be sized differently depending on update mode\n  926:         assert(mTlasPrebuildInfo.UpdateScratchDataSizeInBytes <= mTlasPrebuildInfo.ScratchDataSizeInBytes);\n  927      }\n  928  \n  ...\n  931      asDesc.Inputs = inputs;\n  932  \n  933:     // If first time building this TLAS\n  934      if (tlas.pTlas == nullptr) {\n  935          assert(tlas.pInstanceDescs == nullptr); // Instance desc should also be null if no TLAS\n  936:         tlas.pTlas = Buffer::create(mTlasPrebuildInfo.ResultDataMaxSizeInBytes, Buffer::BindFlags::AccelerationStructure, Buffer::CpuAccess::None);\n  937          tlas.pInstanceDescs = Buffer::create((uint32_t)mInstanceDescs.size() * sizeof(D3D12_RAYTRACING_INSTANCE_DESC), Buffer::BindFlags::None, Buffer::CpuAccess::Write, mInstanceDescs.data());\n  938      } else {\n  ...\n 1021      if (mBlasData.empty()) {\n 1022          initGeomDesc();\n 1023:         buildBlas(pContext);\n 1024      }\n 1025  \n ....\n 1037      if (tlasIt == mTlasCache.end()) {\n 1038          // We need a hit entry per mesh right now to pass GeometryIndex()\n 1039:         buildTlas(pContext, rayTypeCount, true);\n 1040  \n 1041          // If new TLAS was just created, get it so the iterator is valid\n\n/home/max/dev/Falcor/src/Falcor/Scene/Scene.h:\n  116          */\n  117          enum class UpdateMode {\n  118:             Rebuild,    ///< Recreate acceleration structure when updates are needed\n  119              Refit       ///< Update acceleration structure when updates are needed\n  120          };\n  ...\n  405          /** Generate bottom level acceleration structures for all meshes\n  406          */\n  407:         void buildBlas(RenderContext* pContext);\n  408  \n  409          /** Generate data for creating a TLAS.\n  410:             #SCENE TODO: Add argument to build descs based off a draw list\n  411          */\n  412          void fillInstanceDesc(std::vector<D3D12_RAYTRACING_INSTANCE_DESC>& instanceDescs, uint32_t rayCount, bool perMeshHitEntry);\n  413  \n  414:         /** Generate top level acceleration structure for the scene. Automatically determines whether to build or refit.\n  415              \\param[in] rayCount Number of ray types in the shader. Required to setup how instances index into the Shader Table\n  416          */\n  417:         void buildTlas(RenderContext* pContext, uint32_t rayCount, bool perMeshHitEntry);\n  418  #endif\n  419  \n  ...\n  513  \n  514          // Raytracing Data\n  515:         UpdateMode mTlasUpdateMode = UpdateMode::Rebuild;   ///< How the TLAS should be updated when there are changes in the scene\n  516          UpdateMode mBlasUpdateMode = UpdateMode::Refit;     ///< How the BLAS should be updated when there are changes to meshes\n  517  \n  518  #ifdef FALCOR_D3D12\n  519:         std::vector<D3D12_RAYTRACING_INSTANCE_DESC> mInstanceDescs; ///< Shared between TLAS builds to avoid reallocating CPU memory\n  520  \n  521          struct TlasData {\n  ...\n  523              ShaderResourceView::SharedPtr pSrv;         ///< Shader Resource View for binding the TLAS\n  524              Buffer::SharedPtr pInstanceDescs;           ///< Buffer holding instance descs for the TLAS\n  525:             UpdateMode updateMode = UpdateMode::Rebuild; ///< Update mode this TLAS was created with.\n  526          };\n  527  \n  528          std::unordered_map<uint32_t, TlasData> mTlasCache;  ///< Top Level Acceleration Structure for scene data cached per shader ray count\n  529                                                              ///< Number of ray types in program affects Shader Table indexing\n  530:         Buffer::SharedPtr mpTlasScratch;                    ///< Scratch buffer used for TLAS builds. Can be shared as long as instance desc count is the same, which for now it is.\n  531:         D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO mTlasPrebuildInfo; ///< This can be reused as long as the number of instance descs doesn't change.\n  532  \n  533          struct BlasData {\n  ...\n  535              Buffer::SharedPtr pScratchBuffer;\n  536  \n  537:             D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO prebuildInfo;\n  538              std::vector<D3D12_RAYTRACING_GEOMETRY_DESC> geomDescs;\n  539              bool hasSkinnedMesh = false;                ///< Whether the BLAS contains a skinned mesh, which means the BLAS may need to be updated\n\n/home/max/dev/Falcor/src/Falcor/Scene/SceneBuilder.cpp:\n  124      }\n  125  \n  126:     SceneBuilder::SharedPtr SceneBuilder::create(std::shared_ptr<Device> pDevice, const std::string& filename, Flags buildFlags, const InstanceMatrices& instances) {\n  127:         auto pBuilder = create(pDevice, buildFlags);\n  128          return pBuilder->import(filename, instances) ? pBuilder : nullptr;\n  129      }\n  ...\n  382  \n  383          if (mMeshes.size() == 0) {\n  384:             logError(\"Can't build scene. No meshes were loaded !!!\");\n  385              return nullptr;\n  386          }\n  ...\n  445  \n  446      SCRIPT_BINDING(SceneBuilder) {\n  447:         auto buildFlags = m.enum_<SceneBuilder::Flags>(\"SceneBuilderFlags\");\n  448:         buildFlags.regEnumVal(SceneBuilder::Flags::None);\n  449:         buildFlags.regEnumVal(SceneBuilder::Flags::RemoveDuplicateMaterials);\n  450:         buildFlags.regEnumVal(SceneBuilder::Flags::UseOriginalTangentSpace);\n  451:         buildFlags.regEnumVal(SceneBuilder::Flags::AssumeLinearSpaceTextures);\n  452:         buildFlags.regEnumVal(SceneBuilder::Flags::DontMergeMeshes);\n  453:         buildFlags.regEnumVal(SceneBuilder::Flags::BuffersAsShaderResource);\n  454:         buildFlags.regEnumVal(SceneBuilder::Flags::UseSpecGlossMaterials);\n  455:         buildFlags.regEnumVal(SceneBuilder::Flags::UseMetalRoughMaterials);\n  456:         buildFlags.addBinaryOperators();\n  457      }\n  458  \n\n/home/max/dev/Falcor/src/Falcor/Scene/SceneBuilder.h:\n   87      /** Construct a new object\n   88      */\n   89:     SceneBuilder(std::shared_ptr<Device> pDevice, Flags buildFlags = Flags::Default);\n   90  \n   91      /** Create a new object\n   ..\n   93      static SharedPtr create(std::shared_ptr<Device> pDevice, Flags mFlags = Flags::Default);\n   94  \n   95:     /** Create a new builder and import a scene/model file\n   96          \\param filename The filename to load\n   97:         \\param flags The build flags\n   98          \\param instances A list of instance matrices to load. This is optional, by default a single instance will be load\n   99          \\return A new object with the imported file already initialized. If an import error occurred, a nullptr will be returned\n  100      */\n  101:     static SharedPtr create(std::shared_ptr<Device> pDevice, const std::string& filename, Flags buildFlags = Flags::Default, const InstanceMatrices& instances = InstanceMatrices());\n  102  \n  103      /** Import a scene/model file\n  ...\n  125      /** Add a mesh. This function will throw an exception if something went wrong\n  126          \\param mesh The mesh's desc\n  127:         \\param flags The build flags\n  128          \\return The ID of the mesh in the scene. Note that all of the instances share the same mesh ID.\n  129      */\n  ...\n  155      void setCamera(const Camera::SharedPtr& pCamera, uint32_t nodeID = kInvalidNode);\n  156  \n  157:     /** Get the build flags\n  158      */\n  159      Flags getFlags() const { return mFlags; }\n\n/home/max/dev/Falcor/src/Falcor/ShaderSource.targets:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3  \n    4    <Target Name=\"ShaderSourceCopy\"\n\n/home/max/dev/Falcor/src/Falcor/ShaderSource.xml:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <ProjectSchemaDefinitions xmlns=\"http://schemas.microsoft.com/build/2009/properties\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:sys=\"clr-namespace:System;assembly=mscorlib\">\n    3  \n    4    <ItemType Name=\"ShaderSource\" DisplayName=\"Shader Source\" />\n    .\n   14          Order=\"500\"\n   15          Description=\"Shader Source propery sheet\"\n   16:         xmlns=\"http://schemas.microsoft.com/build/2009/properties\">\n   17  \n   18      <Rule.Categories>\n\n/home/max/dev/Falcor/src/Falcor/Utils/UI/DebugDrawer.cpp:\n   69  }\n   70  \n   71: DebugDrawer::Quad buildQuad(const float3& center, const float3& up, const float3& right) {\n   72      // Length of each quad side\n   73      static const float size = 0.08f;\n   ..\n   93  //         float3 up = glm::cross(right, forward);\n   94  //\n   95: //         return buildQuad(currFrame.position, up, right);\n   96  //     }\n   97  \n   ..\n  118  //         float3 midRight = (lastToCurrRight + currToNextRight) / 2.0f;\n  119  //\n  120: //         return buildQuad(currFrame.position, midUp, midRight);\n  121  //     }\n  122  \n\n/home/max/dev/Falcor/src/houdini/soho/LSDframe.py:\n   70          # transform based on that position.\n   71          P = hou.Vector3((0,0,0)) * hou.Matrix4(xform)\n   72:         hxform = hou.hmath.buildTranslate(P[0], P[1], P[2])\n   73          # Transform to orient for the face we're rendering\n   74          hxform *= cubemap.Transform\n\n/home/max/dev/Falcor/src/houdini/soho/LSDsettings.py:\n  561              for p in plist:\n  562                  map = soho.decodeParmId(p.ParmId)\n  563:                 # When building the parameter map, we're most interested in the\n  564                  # parameter that actually defines the value (i.e. typically a\n  565                  # material level parameter), not the actual node parameter.\n\n/home/max/dev/Falcor/src/lava_cmd/CMakeLists.txt:\n   17  \n   18  # RPATH \n   19: SET(CMAKE_SKIP_BUILD_RPATH  FALSE) # use, i.e. don't skip the full RPATH for the build tree\n   20: SET(CMAKE_BUILD_WITH_INSTALL_RPATH FALSE) # when building, don't use the install RPATH already (but later on when installing)\n   21  SET(CMAKE_INSTALL_RPATH \"${CMAKE_INSTALL_PREFIX}/lib\")\n   22: SET(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE) # add the automatically determined parts of the RPATH which point to directories outside the build tree to the install RPATH\n   23  \n   24  # Executable \n\n/home/max/dev/Falcor/src/Mogwai/CMakeLists.txt:\n   41  \n   42  # RPATH \n   43: SET(CMAKE_SKIP_BUILD_RPATH  FALSE) # use, i.e. don't skip the full RPATH for the build tree\n   44: SET(CMAKE_BUILD_WITH_INSTALL_RPATH FALSE) # when building, don't use the install RPATH already (but later on when installing)\n   45  SET(CMAKE_INSTALL_RPATH \"${CMAKE_INSTALL_PREFIX}/lib\")\n   46: SET(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE) # add the automatically determined parts of the RPATH which point to directories outside the build tree to the install RPATH\n   47  \n   48  # Executable \n\n/home/max/dev/Falcor/src/Mogwai/Mogwai.cpp:\n  401  }\n  402  \n  403: void Renderer::loadScene(std::string filename, SceneBuilder::Flags buildFlags) {\n  404      LOG_DBG(\"Loading scene on device uid: %u\", mpDevice->uid());\n  405:     setScene(SceneBuilder::create(mpDevice, filename, buildFlags)->getScene());\n  406  }\n  407  \n\n/home/max/dev/Falcor/src/Mogwai/Mogwai.h:\n  157      void removeActiveGraph();\n  158      void loadSceneDialog();\n  159:     void loadScene(std::string filename, SceneBuilder::Flags buildFlags = SceneBuilder::Flags::Default);\n  160      void setScene(Scene::ConstSharedPtrRef pScene);\n  161      Scene::SharedPtr getScene() const;\n\n/home/max/dev/Falcor/src/Mogwai/Mogwai.vcxproj:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup Label=\"ProjectConfigurations\">\n    4      <ProjectConfiguration Include=\"Debug|x64\">\n\n/home/max/dev/Falcor/src/Mogwai/Mogwai.vcxproj.filters:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup>\n    4      <ClCompile Include=\"Mogwai.cpp\" />\n\n/home/max/dev/Falcor/src/Mogwai/MogwaiScripting.cpp:\n  119  \n  120      c.func_(kRunScript.c_str(), &Renderer::loadScript, \"filename\"_a = std::string());\n  121:     c.func_(kLoadScene.c_str(), &Renderer::loadScene, \"filename\"_a = std::string(), \"buildFlags\"_a = SceneBuilder::Flags::Default);\n  122      c.func_(kSaveConfig.c_str(), &Renderer::dumpConfig, \"filename\"_a = std::string());\n  123      c.func_(kAddGraph.c_str(), &Renderer::addGraph, \"graph\"_a);\n\n/home/max/dev/Falcor/src/RenderPasses/AccumulatePass/AccumulatePass.vcxproj:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup Label=\"ProjectConfigurations\">\n    4      <ProjectConfiguration Include=\"Debug|x64\">\n\n/home/max/dev/Falcor/src/RenderPasses/AccumulatePass/AccumulatePass.vcxproj.filters:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup>\n    4      <ClCompile Include=\"AccumulatePass.cpp\" />\n\n/home/max/dev/Falcor/src/RenderPasses/Antialiasing/Antialiasing.vcxproj:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup Label=\"ProjectConfigurations\">\n    4      <ProjectConfiguration Include=\"Debug|x64\">\n\n/home/max/dev/Falcor/src/RenderPasses/Antialiasing/Antialiasing.vcxproj.filters:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup>\n    4      <ClCompile Include=\"Antialiasing.cpp\" />\n\n/home/max/dev/Falcor/src/RenderPasses/BlitPass/BlitPass.vcxproj:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup Label=\"ProjectConfigurations\">\n    4      <ProjectConfiguration Include=\"Debug|x64\">\n\n/home/max/dev/Falcor/src/RenderPasses/BlitPass/BlitPass.vcxproj.filters:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup>\n    4      <ClCompile Include=\"BlitPass.cpp\" />\n\n/home/max/dev/Falcor/src/RenderPasses/BSDFViewer/BSDFViewer.vcxproj:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup Label=\"ProjectConfigurations\">\n    4      <ProjectConfiguration Include=\"Debug|x64\">\n\n/home/max/dev/Falcor/src/RenderPasses/BSDFViewer/BSDFViewer.vcxproj.filters:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup>\n    4      <ClCompile Include=\"BSDFViewer.cpp\" />\n\n/home/max/dev/Falcor/src/RenderPasses/CMakeLists.txt:\n    1  set( PASS_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_LIBRARY_OUTPUT_DIRECTORY}/passes )\n    2  \n    3: message(\"Rende passes build dir: ${PASS_LIBRARY_OUTPUT_DIRECTORY}\")\n    4  \n    5  add_definitions(-DPROJECT_DIR=\"${CMAKE_SOURCE_DIR}\")\n    .\n   13  include_directories(${PYTHON_INCLUDE_DIRS})\n   14  \n   15: # This function builds render pass library\n   16  function (makeRenderPassLib)\n   17      cmake_parse_arguments(\n\n/home/max/dev/Falcor/src/RenderPasses/CSM/CSM.vcxproj:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup Label=\"ProjectConfigurations\">\n    4      <ProjectConfiguration Include=\"Debug|x64\">\n\n/home/max/dev/Falcor/src/RenderPasses/CSM/CSM.vcxproj.filters:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup>\n    4      <ClCompile Include=\"CSM.cpp\" />\n\n/home/max/dev/Falcor/src/RenderPasses/DebugPasses/DebugPasses.vcxproj:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup Label=\"ProjectConfigurations\">\n    4      <ProjectConfiguration Include=\"Debug|x64\">\n\n/home/max/dev/Falcor/src/RenderPasses/DebugPasses/DebugPasses.vcxproj.filters:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup>\n    4      <ClCompile Include=\"DebugPasses.cpp\" />\n\n/home/max/dev/Falcor/src/RenderPasses/DepthPass/DepthPass.vcxproj:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup Label=\"ProjectConfigurations\">\n    4      <ProjectConfiguration Include=\"Debug|x64\">\n\n/home/max/dev/Falcor/src/RenderPasses/DepthPass/DepthPass.vcxproj.filters:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup>\n    4      <ClCompile Include=\"DepthPass.cpp\" />\n\n/home/max/dev/Falcor/src/RenderPasses/ErrorMeasurePass/ErrorMeasurePass.vcxproj:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup Label=\"ProjectConfigurations\">\n    4      <ProjectConfiguration Include=\"Debug|x64\">\n\n/home/max/dev/Falcor/src/RenderPasses/ForwardLightingPass/ForwardLightingPass.vcxproj:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup Label=\"ProjectConfigurations\">\n    4      <ProjectConfiguration Include=\"Debug|x64\">\n\n/home/max/dev/Falcor/src/RenderPasses/ForwardLightingPass/ForwardLightingPass.vcxproj.filters:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup>\n    4      <ClCompile Include=\"ForwardLightingPass.cpp\" />\n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/GBuffer.vcxproj:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup Label=\"ProjectConfigurations\">\n    4      <ProjectConfiguration Include=\"Debug|x64\">\n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/GBuffer.vcxproj.filters:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup>\n    4      <ClCompile Include=\"GBuffer\\GBufferRaster.cpp\">\n\n/home/max/dev/Falcor/src/RenderPasses/ImageLoader/ImageLoader.vcxproj:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup Label=\"ProjectConfigurations\">\n    4      <ProjectConfiguration Include=\"Debug|x64\">\n\n/home/max/dev/Falcor/src/RenderPasses/ImageLoader/ImageLoader.vcxproj.filters:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup>\n    4      <ClCompile Include=\"ImageLoader.cpp\" />\n\n/home/max/dev/Falcor/src/RenderPasses/MegakernelPathTracer/MegakernelPathTracer.vcxproj:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup Label=\"ProjectConfigurations\">\n    4      <ProjectConfiguration Include=\"Debug|x64\">\n\n/home/max/dev/Falcor/src/RenderPasses/MegakernelPathTracer/MegakernelPathTracer.vcxproj.filters:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup>\n    4      <ClCompile Include=\"MegakernelPathTracer.cpp\" />\n\n/home/max/dev/Falcor/src/RenderPasses/MinimalPathTracer/MinimalPathTracer.vcxproj:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup Label=\"ProjectConfigurations\">\n    4      <ProjectConfiguration Include=\"Debug|x64\">\n\n/home/max/dev/Falcor/src/RenderPasses/MinimalPathTracer/MinimalPathTracer.vcxproj.filters:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup>\n    4      <ClCompile Include=\"MinimalPathTracer.cpp\" />\n\n/home/max/dev/Falcor/src/RenderPasses/PassLibraryTemplate/PassLibraryTemplate.vcxproj:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup Label=\"ProjectConfigurations\">\n    4      <ProjectConfiguration Include=\"Debug|x64\">\n\n/home/max/dev/Falcor/src/RenderPasses/PassLibraryTemplate/PassLibraryTemplate.vcxproj.filters:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup>\n    4      <ClCompile Include=\"PassLibraryTemplate.cpp\" />\n\n/home/max/dev/Falcor/src/RenderPasses/PixelInspectorPass/PixelInspectorPass.vcxproj:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup Label=\"ProjectConfigurations\">\n    4      <ProjectConfiguration Include=\"Debug|x64\">\n\n/home/max/dev/Falcor/src/RenderPasses/PixelInspectorPass/PixelInspectorPass.vcxproj.filters:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup>\n    4      <ShaderSource Include=\"PixelInspector.cs.slang\" />\n\n/home/max/dev/Falcor/src/RenderPasses/SkyBox/SkyBox.vcxproj:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup Label=\"ProjectConfigurations\">\n    4      <ProjectConfiguration Include=\"Debug|x64\">\n\n/home/max/dev/Falcor/src/RenderPasses/SkyBox/SkyBox.vcxproj.filters:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup>\n    4      <ClCompile Include=\"SkyBox.cpp\" />\n\n/home/max/dev/Falcor/src/RenderPasses/SSAO/SSAO.vcxproj:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup Label=\"ProjectConfigurations\">\n    4      <ProjectConfiguration Include=\"Debug|x64\">\n\n/home/max/dev/Falcor/src/RenderPasses/SSAO/SSAO.vcxproj.filters:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup>\n    4      <ClCompile Include=\"SSAO.cpp\" />\n\n/home/max/dev/Falcor/src/RenderPasses/SVGFPass/SVGFPass.vcxproj:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup Label=\"ProjectConfigurations\">\n    4      <ProjectConfiguration Include=\"Debug|x64\">\n\n/home/max/dev/Falcor/src/RenderPasses/SVGFPass/SVGFPass.vcxproj.filters:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup>\n    4      <ClCompile Include=\"SVGFPass.cpp\" />\n\n/home/max/dev/Falcor/src/RenderPasses/TemporalDelayPass/TemporalDelayPass.vcxproj:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup Label=\"ProjectConfigurations\">\n    4      <ProjectConfiguration Include=\"Debug|x64\">\n\n/home/max/dev/Falcor/src/RenderPasses/TemporalDelayPass/TemporalDelayPass.vcxproj.filters:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup>\n    4      <ClCompile Include=\"TemporalDelayPass.cpp\" />\n\n/home/max/dev/Falcor/src/RenderPasses/ToneMapper/ToneMapper.vcxproj:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup Label=\"ProjectConfigurations\">\n    4      <ProjectConfiguration Include=\"Debug|x64\">\n\n/home/max/dev/Falcor/src/RenderPasses/ToneMapper/ToneMapper.vcxproj.filters:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup>\n    4      <ClCompile Include=\"ToneMapper.cpp\" />\n\n/home/max/dev/Falcor/src/RenderPasses/Utils/Utils.vcxproj:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup Label=\"ProjectConfigurations\">\n    4      <ProjectConfiguration Include=\"Debug|x64\">\n\n/home/max/dev/Falcor/src/RenderPasses/Utils/Utils.vcxproj.filters:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup>\n    4      <ClCompile Include=\"Utils.cpp\" />\n\n/home/max/dev/Falcor/src/RenderPasses/WhittedRayTracer/WhittedRayTracer.vcxproj:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup Label=\"ProjectConfigurations\">\n    4      <ProjectConfiguration Include=\"Debug|x64\">\n\n/home/max/dev/Falcor/src/RenderPasses/WhittedRayTracer/WhittedRayTracer.vcxproj.filters:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup>\n    4      <ClCompile Include=\"WhittedRayTracer.cpp\" />\n\n/home/max/dev/Falcor/src/Samples/CMakeLists.txt:\n    5  include_directories(${PYTHON_INCLUDE_DIRS})\n    6  \n    7: # This function builds render pass library\n    8  function (makeFalcorSample sample_dir)\n    9  \tfile( GLOB_RECURSE SOURCES\n\n/home/max/dev/Falcor/src/Samples/CudaInterop/CudaInterop.vcxproj:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup Label=\"ProjectConfigurations\">\n    4      <ProjectConfiguration Include=\"Debug|x64\">\n\n/home/max/dev/Falcor/src/Samples/CudaInterop/FalcorCUDA.props:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ImportGroup Label=\"PropertySheets\" />\n    4    <PropertyGroup Label=\"UserMacros\" />\n\n/home/max/dev/Falcor/src/Samples/HelloDXR/HelloDXR.vcxproj:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup Label=\"ProjectConfigurations\">\n    4      <ProjectConfiguration Include=\"Debug|x64\">\n\n/home/max/dev/Falcor/src/Samples/HelloDXR/HelloDXR.vcxproj.filters:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup>\n    4      <ClCompile Include=\"HelloDXR.cpp\" />\n\n/home/max/dev/Falcor/src/Samples/ModelViewer/ModelViewer.cpp:\n   63  \n   64      if(!mpScene) {\n   65:         msgBox(\"Failed to build scene !\");\n   66      }\n   67  \n\n/home/max/dev/Falcor/src/Samples/ModelViewer/ModelViewer.vcxproj:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup Label=\"ProjectConfigurations\">\n    4      <ProjectConfiguration Include=\"Debug|x64\">\n\n/home/max/dev/Falcor/src/Samples/ModelViewer/ModelViewer.vcxproj.filters:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup>\n    4      <ClCompile Include=\"ModelViewer.cpp\" />\n\n/home/max/dev/Falcor/src/Samples/ProjectTemplate/ProjectTemplate.vcxproj:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup Label=\"ProjectConfigurations\">\n    4      <ProjectConfiguration Include=\"Debug|x64\">\n\n/home/max/dev/Falcor/src/Samples/ProjectTemplate/ProjectTemplate.vcxproj.filters:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup>\n    4      <ClCompile Include=\"ProjectTemplate.cpp\" />\n\n/home/max/dev/Falcor/src/Samples/ShaderToy/ShaderToy.vcxproj:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup Label=\"ProjectConfigurations\">\n    4      <ProjectConfiguration Include=\"Debug|x64\">\n\n/home/max/dev/Falcor/src/Samples/ShaderToy/ShaderToy.vcxproj.filters:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup>\n    4      <ClCompile Include=\"ShaderToy.cpp\" />\n\n/home/max/dev/Falcor/src/Tools/CMakeLists.txt:\n    5  include_directories(${PYTHON_INCLUDE_DIRS})\n    6  \n    7: # This function builds render pass library\n    8  function (makeFalcorTool tool_dir)\n    9  \tfile( GLOB_RECURSE SOURCES\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/FalcorTest.vcxproj:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup Label=\"ProjectConfigurations\">\n    4      <ProjectConfiguration Include=\"Debug|x64\">\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/FalcorTest.vcxproj.filters:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup>\n    4      <ClCompile Include=\"FalcorTest.cpp\" />\n\n/home/max/dev/Falcor/src/Tools/ImageCompare/args.h:\n  876              }\n  877  \n  878:             /// Sets a kick-out value for building subparsers\n  879              void KickOut(bool kickout_) noexcept\n  880              {\n  ...\n  889              }\n  890  \n  891:             /// Gets the kick-out value for building subparsers\n  892              bool KickOut() const noexcept\n  893              {\n  ...\n 1609      };\n 1610  \n 1611:     /** Utility class for building subparsers with coroutines/callbacks.\n 1612       *\n 1613       * Brief example:\n ....\n 1677      };\n 1678  \n 1679:     /** Main class for building subparsers.\n 1680       *\n 1681       * /sa Subparser\n\n/home/max/dev/Falcor/src/Tools/ImageCompare/ImageCompare.filters:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup>\n    4      <ClCompile Include=\"ImageCompare.cpp\" />\n\n/home/max/dev/Falcor/src/Tools/ImageCompare/ImageCompare.vcxproj:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup Label=\"ProjectConfigurations\">\n    4      <ProjectConfiguration Include=\"Debug|x64\">\n\n/home/max/dev/Falcor/src/Tools/RenderGraphEditor/RenderGraphEditor.cpp:\n  290          std::vector<uint32_t> executionOrder = mRenderGraphUIs[mCurrentGraphIndex].getPassOrder();\n  291          mpGraphs[mCurrentGraphIndex]->autoGenEdges(executionOrder);\n  292:         mRenderGraphUIs[mCurrentGraphIndex].setToRebuild();\n  293      }\n  294  \n  ...\n  409      mpGraphs[mCurrentGraphIndex] = RenderGraphImporter::import(fileName);\n  410      if (mRenderGraphUIs.size() < mCurrentGraphIndex) {\n  411:         mRenderGraphUIs[mCurrentGraphIndex].setToRebuild();\n  412      }\n  413  }\n\n/home/max/dev/Falcor/src/Tools/RenderGraphEditor/RenderGraphEditor.vcxproj:\n    1  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    2: <Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup Label=\"ProjectConfigurations\">\n    4      <ProjectConfiguration Include=\"Debug|x64\">\n\n373 matches across 119 files\n\n\nSearching 1245 files for \"Shaders\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/CMakeLists.txt:\n  150  \n  151  # Copy/install all needed shaders\n  152: set( SHADERS_OUTPUT_DIRECTORY ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/Shaders)\n  153  file(MAKE_DIRECTORY ${SHADERS_OUTPUT_DIRECTORY})\n  154  file(\n\n/home/max/dev/Falcor/src/Falcor/Core/Platform/OS.cpp:\n   64          std::string(PROJECT_DIR) + \"../Tools/FalcorTest/\",\n   65          // Then we search in deployment folder (necessary to pickup NVAPI and other third-party shaders).\n   66:         getExecutableDirectory() + \"/Shaders\",\n   67      };\n   68  \n   69      std::vector<std::string> deploymentDirectories = {\n   70:         getExecutableDirectory() + \"/Shaders\"\n   71      };\n   72  \n\n/home/max/dev/Falcor/src/Falcor/Core/Platform/OS.h:\n  146  \n  147  /** Finds a shader file. If in development mode (see isDevelopmentMode()), shaders are searched\n  148:     within the source directories. Otherwise, shaders are searched in the Shaders directory\n  149      located besides the executable.\n  150      \\param[in] filename The file to look for\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramVersion.cpp:\n   39      EntryPointGroupKernels::SharedPtr EntryPointGroupKernels::create(\n   40          EntryPointGroupKernels::Type type,\n   41:         const EntryPointGroupKernels::Shaders& shaders)\n   42      {\n   43          return SharedPtr(new EntryPointGroupKernels(type, shaders));\n   44      }\n   45  \n   46:     EntryPointGroupKernels::EntryPointGroupKernels(Type type, const Shaders& shaders)\n   47          : mType(type)\n   48:         , mShaders(shaders)\n   49      {}\n   50  \n   51      const Shader* EntryPointGroupKernels::getShader(ShaderType type) const\n   52      {\n   53:         for( auto& pShader : mShaders )\n   54          {\n   55              if(pShader->getType() == type)\n   ..\n   61      RtEntryPointGroupKernels::SharedPtr RtEntryPointGroupKernels::create(\n   62              Type type,\n   63:             const Shaders& shaders,\n   64              std::string const& exportName,\n   65              RootSignature::SharedPtr const& localRootSignature,\n   ..\n   72      RtEntryPointGroupKernels::RtEntryPointGroupKernels(\n   73          Type type,\n   74:         const Shaders& shaders,\n   75          std::string const& exportName,\n   76          RootSignature::SharedPtr const& localRootSignature,\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramVersion.h:\n   81          };\n   82  \n   83:         using Shaders = std::vector<Shader::SharedPtr>;\n   84  \n   85:         static SharedPtr create(Type type, const Shaders& shaders);\n   86  \n   87          virtual ~EntryPointGroupKernels() = default;\n   ..\n   89          Type getType() const { return mType; }\n   90          const Shader* getShader(ShaderType type) const;\n   91:         const Shader* getShaderByIndex(int32_t index) const { return mShaders[index].get(); }\n   92  \n   93      protected:\n   94:         EntryPointGroupKernels(Type type, const Shaders& shaders);\n   95          EntryPointGroupKernels() = default;\n   96          EntryPointGroupKernels(const EntryPointGroupKernels&) = delete;\n   ..\n   98  \n   99          Type mType;\n  100:         Shaders mShaders;\n  101      };\n  102  \n  ...\n  106          static SharedPtr create(\n  107              Type type,\n  108:             const Shaders& shaders,\n  109              std::string const& exportName,\n  110              RootSignature::SharedPtr const& localRootSignature,\n  ...\n  122          RtEntryPointGroupKernels(\n  123              Type type,\n  124:             const Shaders& shaders,\n  125              std::string const& exportName,\n  126              RootSignature::SharedPtr const& localRootSignature,\n\n/home/max/dev/Falcor/src/Falcor/Falcor.props:\n   37    </ImportGroup>\n   38    <PropertyGroup>\n   39:     <ShaderSourceSubDir>Shaders</ShaderSourceSubDir>\n   40      <ShaderSourcePreservePaths>true</ShaderSourcePreservePaths>\n   41    </PropertyGroup>\n\n/home/max/dev/Falcor/src/Falcor/Falcor.vcxproj:\n  949    </ImportGroup>\n  950    <PropertyGroup>\n  951:     <ShaderSourceSubDir>Shaders</ShaderSourceSubDir>\n  952      <ShaderSourcePreservePaths>true</ShaderSourcePreservePaths>\n  953    </PropertyGroup>\n\n/home/max/dev/Falcor/src/Falcor/ShaderSource.xml:\n   27          DisplayName=\"Destination Subfolder\"\n   28          Description=\"Subfolder of $(OutDir) in which to install shader source files\"\n   29:         Default=\"Shaders\"\n   30          Category=\"General\">\n   31      </StringProperty>\n\n/home/max/dev/Falcor/src/houdini/soho/LSDgeo.py:\n   34  theSavedProperties = {}\n   35  theSavedOPropMaps = {}\n   36: theSavedShaders = {}\n   37  theShopRefs = {}\n   38  theShopRefsInv = {}\n   ..\n   53  def reset(full = True):\n   54      global theDetailRefs, theDetailRefsInv, theSavedDetails, theSavedProperties\n   55:     global theSavedShaders, theSopTBound, theShopRefs\n   56      global theShopRefsInv, theMaterialOverrideRefs, theMaterialOverrideRefsInv\n   57      global theSavedOPropMaps\n   ..\n   60          theDetailRefsInv = {}\n   61          theSavedDetails = {}\n   62:         theSavedShaders = {}\n   63          theSopTBound = {}\n   64          theShopRefs = {}\n   ..\n  409              # the shop node for a specific context\n  410              pathkey = fullpath + str(shadertype)\n  411:             if not theSavedShaders.has_key(pathkey):\n  412:                 theSavedShaders[pathkey] = True\n  413                  shop = soho.getObject(fullpath)\n  414                  # The 'shop:string' token will cause the shop to\n  ...\n  594      wrangler = LSDsettings.getWrangler(obj, now, 'object_wrangler')\n  595  \n  596:     # Call the object wranglers 'retainShaders'. Note. It's the responsibility\n  597      # of object wrangler to emit LSD correctly.\n  598:     obj.wrangleInt(wrangler,'retainShaders', now, [0])[0]\n  599  \n  600      # Call the object wranglers 'retainGeometry', skip inbuilt soho code if\n\n/home/max/dev/Falcor/src/RenderPasses/AccumulatePass/AccumulatePass.vcxproj:\n   44      <PlatformToolset>v142</PlatformToolset>\n   45      <CharacterSet>Unicode</CharacterSet>\n   46:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   47    </PropertyGroup>\n   48    <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n   ..\n   52      <WholeProgramOptimization>true</WholeProgramOptimization>\n   53      <CharacterSet>Unicode</CharacterSet>\n   54:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   55    </PropertyGroup>\n   56    <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n\n/home/max/dev/Falcor/src/RenderPasses/Antialiasing/Antialiasing.vcxproj:\n   48      <PlatformToolset>v142</PlatformToolset>\n   49      <CharacterSet>Unicode</CharacterSet>\n   50:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   51    </PropertyGroup>\n   52    <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n   ..\n   56      <WholeProgramOptimization>true</WholeProgramOptimization>\n   57      <CharacterSet>Unicode</CharacterSet>\n   58:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   59    </PropertyGroup>\n   60    <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n\n/home/max/dev/Falcor/src/RenderPasses/BlitPass/BlitPass.vcxproj:\n   41      <PlatformToolset>v142</PlatformToolset>\n   42      <CharacterSet>Unicode</CharacterSet>\n   43:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   44    </PropertyGroup>\n   45    <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n   ..\n   49      <WholeProgramOptimization>true</WholeProgramOptimization>\n   50      <CharacterSet>Unicode</CharacterSet>\n   51:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   52    </PropertyGroup>\n   53    <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n\n/home/max/dev/Falcor/src/RenderPasses/BSDFViewer/BSDFViewer.vcxproj:\n   43      <PlatformToolset>v142</PlatformToolset>\n   44      <CharacterSet>Unicode</CharacterSet>\n   45:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   46    </PropertyGroup>\n   47    <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n   ..\n   51      <WholeProgramOptimization>true</WholeProgramOptimization>\n   52      <CharacterSet>Unicode</CharacterSet>\n   53:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   54    </PropertyGroup>\n   55    <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n\n/home/max/dev/Falcor/src/RenderPasses/CMakeLists.txt:\n   56  \n   57      # Copy/install all needed shaders\n   58:     set( SHADERS_OUTPUT_DIRECTORY ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/Shaders/RenderPasses)\n   59      file(MAKE_DIRECTORY ${SHADERS_OUTPUT_DIRECTORY})\n   60      if (WIN32)\n\n/home/max/dev/Falcor/src/RenderPasses/CSM/CSM.vcxproj:\n   51      <PlatformToolset>v142</PlatformToolset>\n   52      <CharacterSet>Unicode</CharacterSet>\n   53:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   54    </PropertyGroup>\n   55    <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n   ..\n   59      <WholeProgramOptimization>true</WholeProgramOptimization>\n   60      <CharacterSet>Unicode</CharacterSet>\n   61:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   62    </PropertyGroup>\n   63    <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n\n/home/max/dev/Falcor/src/RenderPasses/DebugPasses/DebugPasses.vcxproj:\n   54      <PlatformToolset>v142</PlatformToolset>\n   55      <CharacterSet>Unicode</CharacterSet>\n   56:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   57    </PropertyGroup>\n   58    <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n   ..\n   62      <WholeProgramOptimization>true</WholeProgramOptimization>\n   63      <CharacterSet>Unicode</CharacterSet>\n   64:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   65    </PropertyGroup>\n   66    <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n\n/home/max/dev/Falcor/src/RenderPasses/DepthPass/DepthPass.vcxproj:\n   44      <PlatformToolset>v142</PlatformToolset>\n   45      <CharacterSet>Unicode</CharacterSet>\n   46:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   47    </PropertyGroup>\n   48    <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n   ..\n   52      <WholeProgramOptimization>true</WholeProgramOptimization>\n   53      <CharacterSet>Unicode</CharacterSet>\n   54:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   55    </PropertyGroup>\n   56    <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n\n/home/max/dev/Falcor/src/RenderPasses/ErrorMeasurePass/ErrorMeasurePass.vcxproj:\n   44      <PlatformToolset>v142</PlatformToolset>\n   45      <CharacterSet>Unicode</CharacterSet>\n   46:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   47    </PropertyGroup>\n   48    <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n   ..\n   52      <WholeProgramOptimization>true</WholeProgramOptimization>\n   53      <CharacterSet>Unicode</CharacterSet>\n   54:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   55    </PropertyGroup>\n   56    <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n\n/home/max/dev/Falcor/src/RenderPasses/ForwardLightingPass/ForwardLightingPass.vcxproj:\n   44      <PlatformToolset>v142</PlatformToolset>\n   45      <CharacterSet>Unicode</CharacterSet>\n   46:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   47    </PropertyGroup>\n   48    <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n   ..\n   52      <WholeProgramOptimization>true</WholeProgramOptimization>\n   53      <CharacterSet>Unicode</CharacterSet>\n   54:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   55    </PropertyGroup>\n   56    <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/GBuffer.vcxproj:\n   62      <PlatformToolset>v142</PlatformToolset>\n   63      <CharacterSet>Unicode</CharacterSet>\n   64:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   65    </PropertyGroup>\n   66    <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n   ..\n   70      <WholeProgramOptimization>true</WholeProgramOptimization>\n   71      <CharacterSet>Unicode</CharacterSet>\n   72:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   73    </PropertyGroup>\n   74    <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n\n/home/max/dev/Falcor/src/RenderPasses/ImageLoader/ImageLoader.vcxproj:\n   41      <PlatformToolset>v142</PlatformToolset>\n   42      <CharacterSet>Unicode</CharacterSet>\n   43:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   44    </PropertyGroup>\n   45    <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n   ..\n   49      <WholeProgramOptimization>true</WholeProgramOptimization>\n   50      <CharacterSet>Unicode</CharacterSet>\n   51:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   52    </PropertyGroup>\n   53    <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n\n/home/max/dev/Falcor/src/RenderPasses/MegakernelPathTracer/MegakernelPathTracer.vcxproj:\n   45      <PlatformToolset>v142</PlatformToolset>\n   46      <CharacterSet>Unicode</CharacterSet>\n   47:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   48    </PropertyGroup>\n   49    <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n   ..\n   53      <WholeProgramOptimization>true</WholeProgramOptimization>\n   54      <CharacterSet>Unicode</CharacterSet>\n   55:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   56    </PropertyGroup>\n   57    <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n\n/home/max/dev/Falcor/src/RenderPasses/MinimalPathTracer/MinimalPathTracer.vcxproj:\n   44      <PlatformToolset>v142</PlatformToolset>\n   45      <CharacterSet>Unicode</CharacterSet>\n   46:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   47    </PropertyGroup>\n   48    <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n   ..\n   52      <WholeProgramOptimization>true</WholeProgramOptimization>\n   53      <CharacterSet>Unicode</CharacterSet>\n   54:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   55    </PropertyGroup>\n   56    <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n\n/home/max/dev/Falcor/src/RenderPasses/PassLibraryTemplate/PassLibraryTemplate.vcxproj:\n   41      <PlatformToolset>v142</PlatformToolset>\n   42      <CharacterSet>Unicode</CharacterSet>\n   43:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   44    </PropertyGroup>\n   45    <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n   ..\n   49      <WholeProgramOptimization>true</WholeProgramOptimization>\n   50      <CharacterSet>Unicode</CharacterSet>\n   51:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   52    </PropertyGroup>\n   53    <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n\n/home/max/dev/Falcor/src/RenderPasses/PixelInspectorPass/PixelInspectorPass.vcxproj:\n   45      <PlatformToolset>v142</PlatformToolset>\n   46      <CharacterSet>Unicode</CharacterSet>\n   47:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   48    </PropertyGroup>\n   49    <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n   ..\n   53      <WholeProgramOptimization>true</WholeProgramOptimization>\n   54      <CharacterSet>Unicode</CharacterSet>\n   55:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   56    </PropertyGroup>\n   57    <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n\n/home/max/dev/Falcor/src/RenderPasses/SkyBox/SkyBox.vcxproj:\n   44      <PlatformToolset>v142</PlatformToolset>\n   45      <CharacterSet>Unicode</CharacterSet>\n   46:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   47    </PropertyGroup>\n   48    <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n   ..\n   52      <WholeProgramOptimization>true</WholeProgramOptimization>\n   53      <CharacterSet>Unicode</CharacterSet>\n   54:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   55    </PropertyGroup>\n   56    <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n\n/home/max/dev/Falcor/src/RenderPasses/SSAO/SSAO.vcxproj:\n   49      <PlatformToolset>v142</PlatformToolset>\n   50      <CharacterSet>Unicode</CharacterSet>\n   51:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   52    </PropertyGroup>\n   53    <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n   ..\n   57      <WholeProgramOptimization>true</WholeProgramOptimization>\n   58      <CharacterSet>Unicode</CharacterSet>\n   59:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   60    </PropertyGroup>\n   61    <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n\n/home/max/dev/Falcor/src/RenderPasses/SVGFPass/SVGFPass.vcxproj:\n   49      <PlatformToolset>v142</PlatformToolset>\n   50      <CharacterSet>Unicode</CharacterSet>\n   51:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   52    </PropertyGroup>\n   53    <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n   ..\n   57      <WholeProgramOptimization>true</WholeProgramOptimization>\n   58      <CharacterSet>Unicode</CharacterSet>\n   59:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   60    </PropertyGroup>\n   61    <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n\n/home/max/dev/Falcor/src/RenderPasses/ToneMapper/ToneMapper.vcxproj:\n   46      <PlatformToolset>v142</PlatformToolset>\n   47      <CharacterSet>Unicode</CharacterSet>\n   48:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   49    </PropertyGroup>\n   50    <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n   ..\n   54      <WholeProgramOptimization>true</WholeProgramOptimization>\n   55      <CharacterSet>Unicode</CharacterSet>\n   56:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   57    </PropertyGroup>\n   58    <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n\n/home/max/dev/Falcor/src/RenderPasses/Utils/Utils.vcxproj:\n   48      <PlatformToolset>v142</PlatformToolset>\n   49      <CharacterSet>Unicode</CharacterSet>\n   50:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   51    </PropertyGroup>\n   52    <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n   ..\n   56      <WholeProgramOptimization>true</WholeProgramOptimization>\n   57      <CharacterSet>Unicode</CharacterSet>\n   58:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   59    </PropertyGroup>\n   60    <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n\n/home/max/dev/Falcor/src/RenderPasses/WhittedRayTracer/WhittedRayTracer.vcxproj:\n   44      <PlatformToolset>v142</PlatformToolset>\n   45      <CharacterSet>Unicode</CharacterSet>\n   46:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   47    </PropertyGroup>\n   48    <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n   ..\n   52      <WholeProgramOptimization>true</WholeProgramOptimization>\n   53      <CharacterSet>Unicode</CharacterSet>\n   54:     <ShaderSourceSubDir>Shaders\\RenderPasses\\$(ProjectName)</ShaderSourceSubDir>\n   55    </PropertyGroup>\n   56    <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n\n/home/max/dev/Falcor/src/Samples/CMakeLists.txt:\n   36  \n   37  \t# Copy/install all needed shaders\n   38: \tset( SHADERS_OUTPUT_DIRECTORY ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/Shaders/Samples)\n   39  \tfile(MAKE_DIRECTORY ${SHADERS_OUTPUT_DIRECTORY})\n   40  \tfile(\n\n/home/max/dev/Falcor/src/Samples/HelloDXR/HelloDXR.vcxproj:\n   45      <PlatformToolset>v142</PlatformToolset>\n   46      <CharacterSet>Unicode</CharacterSet>\n   47:     <ShaderSourceSubDir>Shaders\\Samples\\$(ProjectName)</ShaderSourceSubDir>\n   48    </PropertyGroup>\n   49    <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n   ..\n   53      <WholeProgramOptimization>true</WholeProgramOptimization>\n   54      <CharacterSet>Unicode</CharacterSet>\n   55:     <ShaderSourceSubDir>Shaders\\Samples\\$(ProjectName)</ShaderSourceSubDir>\n   56    </PropertyGroup>\n   57    <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n\n/home/max/dev/Falcor/src/Samples/ModelViewer/ModelViewer.vcxproj:\n   43      <PlatformToolset>v142</PlatformToolset>\n   44      <CharacterSet>Unicode</CharacterSet>\n   45:     <ShaderSourceSubDir>Shaders\\Samples\\$(ProjectName)</ShaderSourceSubDir>\n   46    </PropertyGroup>\n   47    <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n   ..\n   51      <WholeProgramOptimization>true</WholeProgramOptimization>\n   52      <CharacterSet>Unicode</CharacterSet>\n   53:     <ShaderSourceSubDir>Shaders\\Samples\\$(ProjectName)</ShaderSourceSubDir>\n   54    </PropertyGroup>\n   55    <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n\n/home/max/dev/Falcor/src/Samples/ProjectTemplate/ProjectTemplate.vcxproj:\n   40      <PlatformToolset>v142</PlatformToolset>\n   41      <CharacterSet>Unicode</CharacterSet>\n   42:     <ShaderSourceSubDir>Shaders\\Samples\\$(ProjectName)</ShaderSourceSubDir>\n   43    </PropertyGroup>\n   44    <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n   ..\n   48      <WholeProgramOptimization>true</WholeProgramOptimization>\n   49      <CharacterSet>Unicode</CharacterSet>\n   50:     <ShaderSourceSubDir>Shaders\\Samples\\$(ProjectName)</ShaderSourceSubDir>\n   51    </PropertyGroup>\n   52    <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n\n/home/max/dev/Falcor/src/Samples/ShaderToy/ShaderToy.vcxproj:\n   46      <PlatformToolset>v142</PlatformToolset>\n   47      <CharacterSet>Unicode</CharacterSet>\n   48:     <ShaderSourceSubDir>Shaders\\Samples\\$(ProjectName)</ShaderSourceSubDir>\n   49    </PropertyGroup>\n   50    <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n   ..\n   54      <WholeProgramOptimization>true</WholeProgramOptimization>\n   55      <CharacterSet>Unicode</CharacterSet>\n   56:     <ShaderSourceSubDir>Shaders\\Samples\\$(ProjectName)</ShaderSourceSubDir>\n   57    </PropertyGroup>\n   58    <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n\n/home/max/dev/Falcor/src/Tools/CMakeLists.txt:\n   38    if( ${tool_dir} STREQUAL \"FalcorTest\" )\n   39      message (\"Copy FalcorTest shaders...\")\n   40:     set( SHADERS_OUTPUT_DIRECTORY \"${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/Shaders\" )\n   41      file( MAKE_DIRECTORY ${SHADERS_OUTPUT_DIRECTORY} )\n   42      set( TEST_SHADERS_DIRECTORY \"${tool_dir}/Tests\" )\n\n81 matches across 37 files\n\n\nSearching 1245 files for \"findFileInShaderDirectories\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/Platform/OS.cpp:\n  170  }\n  171  \n  172: bool findFileInShaderDirectories(const std::string& filename, std::string& fullPath) {\n  173      for (const auto& dir : gShaderDirectories) {\n  174          fullPath = canonicalizeFilename(dir + '/' + filename);\n\n/home/max/dev/Falcor/src/Falcor/Core/Platform/OS.h:\n  152      \\return true if the file was found, otherwise false\n  153  */\n  154: dlldecl bool findFileInShaderDirectories(const std::string& filename, std::string& fullPath);\n  155  \n  156  /** Get a list of all shader directories.\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/Program.cpp:\n  494              }\n  495              std::string fullpath;\n  496:             if (!findFileInShaderDirectories(src.pLibrary->getFilename(), fullpath)) {\n  497                  logError(\"Can't find file \" + src.pLibrary->getFilename());\n  498                  spDestroyCompileRequest(pSlangRequest);\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightCollection.cpp:\n  146  \n  147          std::string s;\n  148:         if (findFileInShaderDirectories(\"NVAPI/nvHLSLExtns.h\", s) == false) {\n  149              logError(\"LightCollection relies on NVAPI, which appears to be missing. Please make sure you have NVAPI installed (instructions are in the readme file)\");\n  150              return false;\n\n4 matches across 4 files\n\n\nSearching 1245 files for \"Failed to link program\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/Program.cpp:\n  840  \n  841          if (pVersion == nullptr) {\n  842:             std::string error = \"Failed to link program:\\n\" + getProgramDescString() + \"\\n\\n\" + log;\n  843              logError(error, Logger::MsgBox::RetryAbort);\n  844:             throw std::runtime_error(\"Failed to link program\");\n  845  \n  846              // Continue loop to keep trying...\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramVersion.cpp:\n  206                  // Failure\n  207  \n  208:                 std::string error = \"Failed to link program:\\n\" + getName() + \"\\n\\n\" + log;\n  209                  logError(error, Logger::MsgBox::RetryAbort);\n  210:                 throw std::runtime_error(\"Failed to link program\");\n  211  \n  212                  // Continue loop to keep trying...\n\n4 matches across 2 files\n\n\nSearching 1245 files for \"GuiImpl\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Utils/UI/Gui.cpp:\n   39  namespace Falcor {\n   40  \n   41:     class GuiImpl {\n   42       public:\n   43:         GuiImpl(std::shared_ptr<Device> pDevice) { mpDevice = pDevice; }\n   44  \n   45       private:\n   ..\n  146      };\n  147  \n  148:     void GuiImpl::init(Gui* pGui, float scaleFactor) {\n  149          mScaleFactor = scaleFactor;\n  150          ImGui::CreateContext();\n  ...\n  220      }\n  221  \n  222:     void GuiImpl::createVao(uint32_t vertexCount, uint32_t indexCount) {\n  223          static_assert(sizeof(ImDrawIdx) == sizeof(uint16_t), \"ImDrawIdx expected size is a word\");\n  224          uint32_t requiredVbSize = vertexCount * sizeof(ImDrawVert);\n  ...\n  243      }\n  244  \n  245:     void GuiImpl::compileFonts() {\n  246          uint8_t* pFontData;\n  247          int32_t width, height;\n  ...\n  253      }\n  254  \n  255:     bool GuiImpl::addCheckboxes(const char label[], bool* pData, uint32_t numCheckboxes, bool sameLine) {\n  256          bool modified = false;\n  257          std::string labelString(std::string(\"##\") + label + '0');\n  ...\n  268      }\n  269  \n  270:     void GuiImpl::setIoMouseEvents() {\n  271          ImGuiIO& io = ImGui::GetIO();\n  272          memcpy(io.MouseDown, mMouseEvents.buttonPressed, sizeof(mMouseEvents.buttonPressed));\n  273      }\n  274  \n  275:     void GuiImpl::resetMouseEvents() {\n  276          for (uint32_t i = 0; i < arraysize(mMouseEvents.buttonPressed); i++) {\n  277              if (mMouseEvents.buttonReleased[i]) {\n  ...\n  281      }\n  282  \n  283:     bool GuiImpl::beginMenu(const char* name) {\n  284          return ImGui::BeginMenu(name);\n  285      }\n  286  \n  287:     void GuiImpl::endMenu() {\n  288          return ImGui::EndMenu();\n  289      }\n  290  \n  291:     bool GuiImpl::beginMainMenuBar() {\n  292          bool isOpen = ImGui::BeginMainMenuBar();\n  293          return isOpen;\n  294      }\n  295  \n  296:     void GuiImpl::endMainMenuBar() {\n  297          ImGui::EndMainMenuBar();\n  298      }\n  299  \n  300:     bool GuiImpl::beginDropDownMenu(const char label[]) {\n  301          return ImGui::BeginMenu(label);\n  302      }\n  303  \n  304:     void GuiImpl::endDropDownMenu() {\n  305          ImGui::EndMenu();\n  306      }\n  307  \n  308:     bool GuiImpl::addMenuItem(const char label[], const char shortcut[]) {\n  309          return ImGui::MenuItem(label, shortcut);\n  310      }\n  311  \n  312:     bool GuiImpl::addMenuItem(const char label[], bool& var, const char shortcut[]) {\n  313          return ImGui::MenuItem(label, shortcut, &var);\n  314      }\n  315  \n  316:     bool GuiImpl::pushWindow(const char label[], bool& open, uint2 size, uint2 pos, Gui::WindowFlags flags) {\n  317          bool allowClose = is_set(flags, Gui::WindowFlags::CloseButton);\n  318          if (allowClose) {\n  ...\n  343      }\n  344  \n  345:     void GuiImpl::popWindow() {\n  346          ImGui::PopFont();\n  347          ImGui::End();\n  348      }\n  349  \n  350:     void GuiImpl::setCurrentWindowPos(uint32_t x, uint32_t y) {\n  351          ImGui::SetWindowPos({ static_cast<float>(x), static_cast<float>(y) });\n  352      }\n  353  \n  354:     void GuiImpl::setCurrentWindowSize(uint32_t width, uint32_t height) {\n  355          ImGui::SetWindowSize({ static_cast<float>(width), static_cast<float>(height) });\n  356      }\n  357  \n  358:     void GuiImpl::beginColumns(uint32_t numColumns) {\n  359          ImGui::Columns(numColumns);\n  360      }\n  361  \n  362:     void GuiImpl::nextColumn() {\n  363          ImGui::NextColumn();\n  364      }\n  365  \n  366:     bool GuiImpl::beginGroup(const char name[], bool beginExpanded) {\n  367          std::string nameString(name);\n  368          ImGuiTreeNodeFlags flags = beginExpanded ? ImGuiTreeNodeFlags_DefaultOpen : 0;\n  ...\n  382      }\n  383  \n  384:     void GuiImpl::endGroup() {\n  385          assert(mGroupStackSize >= 1);\n  386          mGroupStackSize--;\n  ...\n  388      }\n  389  \n  390:     void GuiImpl::indent(float i) {\n  391          ImGui::Indent(i);\n  392      }\n  393  \n  394:     void GuiImpl::addSeparator(uint32_t count) {\n  395          for (uint32_t i = 0; i < count; i++) ImGui::Separator();\n  396      }\n  397  \n  398:     void GuiImpl::addDummyItem(const char label[], const float2& size, bool sameLine) {\n  399          if (sameLine) ImGui::SameLine();\n  400          ImGui::PushID(label);\n  ...\n  403      }\n  404  \n  405:     void GuiImpl::addRect(const float2& size, const float4& color, bool filled, bool sameLine) {\n  406          if (sameLine) ImGui::SameLine();\n  407  \n  ...\n  417      }\n  418  \n  419:     bool GuiImpl::addDropdown(const char label[], const Gui::DropdownList& values, uint32_t& var, bool sameLine) {\n  420          if (sameLine) ImGui::SameLine();\n  421          // Check if we need to update the currentItem\n  ...\n  450      }\n  451  \n  452:     bool GuiImpl::addButton(const char label[], bool sameLine) {\n  453          if (sameLine) ImGui::SameLine();\n  454          return ImGui::Button(label);\n  455      }\n  456  \n  457:     bool GuiImpl::addRadioButtons(const Gui::RadioButtonGroup& buttons, uint32_t& activeID) {\n  458          int32_t oldValue = activeID;\n  459  \n  ...\n  466      }\n  467  \n  468:     bool GuiImpl::addDirectionWidget(const char label[], float3& direction) {\n  469          float3 dir = direction;\n  470          bool b = addVecVar(label, dir, -1.f, 1.f, 0.001f, false, \"%.3f\");\n  ...\n  473      }\n  474  \n  475:     bool GuiImpl::addCheckbox(const char label[], bool& var, bool sameLine) {\n  476          if (sameLine) ImGui::SameLine();\n  477          return ImGui::Checkbox(label, &var);\n  478      }\n  479  \n  480:     bool GuiImpl::addCheckbox(const char label[], int& var, bool sameLine) {\n  481          bool value = (var != 0);\n  482          bool modified = addCheckbox(label, value, sameLine);\n  ...\n  486  \n  487      template<typename T>\n  488:     bool GuiImpl::addBoolVecVar(const char label[], T& var, bool sameLine) {\n  489          return addCheckboxes(label, glm::value_ptr(var), var.length(), sameLine);\n  490      }\n  491  \n  492:     bool GuiImpl::addDragDropSource(const char label[], const char dataLabel[], const std::string& payloadString) {\n  493          if (ImGui::IsItemHovered() && (ImGui::IsMouseClicked(0) || ImGui::IsMouseClicked(1))) ImGui::SetWindowFocus();\n  494          if (!(ImGui::IsWindowFocused())) return false;\n  ...\n  501      }\n  502  \n  503:     bool GuiImpl::addDragDropDest(const char dataLabel[], std::string& payloadString) {\n  504          bool b = false;\n  505          if (ImGui::BeginDragDropTarget()) {\n  ...\n  517      }\n  518  \n  519:     void GuiImpl::addText(const char text[], bool sameLine) {\n  520          if (sameLine) ImGui::SameLine();\n  521          ImGui::TextUnformatted(text);\n  522      }\n  523  \n  524:     bool GuiImpl::addTextbox(const char label[], char buf[], size_t bufSize, uint32_t lineCount, Gui::TextFlags flags) {\n  525          bool fitWindow = is_set(flags, Gui::TextFlags::FitWindow);\n  526          if (fitWindow) ImGui::PushItemWidth(ImGui::GetWindowWidth());\n  ...\n  536      }\n  537  \n  538:     bool GuiImpl::addTextbox(const char label[], std::string& text, uint32_t lineCount, Gui::TextFlags flags) {\n  539          static const int maxSize = 2048;\n  540          char buf[maxSize];\n  ...\n  546      }\n  547  \n  548:     bool GuiImpl::addMultiTextbox(const char label[], const std::vector<std::string>& textLabels, std::vector<std::string>& textEntries) {\n  549          static uint32_t sIdOffset = 0;\n  550          bool result = false;\n  ...\n  557      }\n  558  \n  559:     void GuiImpl::addTooltip(const char tip[], bool sameLine) {\n  560          if (sameLine) ImGui::SameLine();\n  561          ImGui::TextDisabled(\"(?)\");\n  ...\n  569      }\n  570  \n  571:     bool GuiImpl::addRgbColor(const char label[], float3& var, bool sameLine) {\n  572          if (sameLine) ImGui::SameLine();\n  573          return ImGui::ColorEdit3(label, glm::value_ptr(var));\n  574      }\n  575  \n  576:     bool GuiImpl::addRgbaColor(const char label[], float4& var, bool sameLine) {\n  577          if (sameLine) ImGui::SameLine();\n  578          return ImGui::ColorEdit4(label, glm::value_ptr(var));\n  579      }\n  580  \n  581:     void GuiImpl::addImage(const char label[], const Texture::SharedPtr& pTex, float2 size, bool maintainRatio, bool sameLine) {\n  582          assert(pTex);\n  583          if (size == float2(0)) {\n  ...\n  594      }\n  595  \n  596:     bool GuiImpl::addImageButton(const char label[], const Texture::SharedPtr& pTex, float2 size, bool maintainRatio, bool sameLine) {\n  597          assert(pTex);\n  598          mpImages.push_back(pTex);\n  ...\n  613  \n  614      template<typename T>\n  615:     bool GuiImpl::addScalarVar(const char label[], T& var, T minVal, T maxVal, float step, bool sameLine, const char* displayFormat) {\n  616          if (std::is_same<T, int32_t>::value) {\n  617              return addScalarVarHelper(label, var, ImGuiDataType_S32, minVal, maxVal, step, sameLine, displayFormat);\n  ...\n  638  \n  639      template<typename T>\n  640:     bool GuiImpl::addScalarSlider(const char label[], T& var, T minVal, T maxVal, bool sameLine, const char* displayFormat) {\n  641          if (std::is_same<T, int32_t>::value) {\n  642              return addScalarSliderHelper(label, var, ImGuiDataType_S32, minVal, maxVal, sameLine, displayFormat);\n  ...\n  663  \n  664      template<typename T>\n  665:     bool GuiImpl::addVecVar(const char label[], T& var, typename T::value_type minVal, typename T::value_type maxVal, float step, bool sameLine, const char* displayFormat) {\n  666          if (std::is_same<typename T::value_type, int32_t>::value) {\n  667              return addVecVarHelper(label, var, ImGuiDataType_S32, minVal, maxVal, step, sameLine, displayFormat);\n  ...\n  688  \n  689      template<typename T>\n  690:     bool GuiImpl::addVecSlider(const char label[], T& var, typename T::value_type minVal, typename T::value_type maxVal, bool sameLine, const char* displayFormat) {\n  691          if (std::is_same<typename T::value_type, int32_t>::value) {\n  692              return addVecSliderHelper(label, var, ImGuiDataType_S32, minVal, maxVal, sameLine, displayFormat);\n  ...\n  702  \n  703      template<typename MatrixType>\n  704:     bool GuiImpl::addMatrixVar(const char label[], MatrixType& var, float minVal, float maxVal, bool sameLine) {\n  705          std::string labelString(label);\n  706          std::string hiddenLabelString(\"##\");\n  ...\n  746      }\n  747  \n  748:     void GuiImpl::addGraph(const char label[], Gui::GraphCallback func, void* pUserData, uint32_t sampleCount, int32_t sampleOffset, float yMin, float yMax, uint32_t width, uint32_t height) {\n  749          ImVec2 imSize{ (float)width, (float)height };\n  750          ImGui::PlotLines(label, func, pUserData, (int32_t)sampleCount, sampleOffset, nullptr, yMin, yMax, imSize);\n  ...\n  759      Gui::UniquePtr Gui::create(std::shared_ptr<Device> pDevice, uint32_t width, uint32_t height, float scaleFactor) {\n  760          UniquePtr pGui = UniquePtr(new Gui(pDevice));\n  761:         pGui->mpWrapper = new GuiImpl(pDevice);\n  762          pGui->mpWrapper->init(pGui.get(), scaleFactor);\n  763          pGui->onWindowResize(width, height);\n\n/home/max/dev/Falcor/src/Falcor/Utils/UI/Gui.h:\n   44      struct KeyboardEvent;\n   45  \n   46:     class GuiImpl;\n   47  \n   48      // Helper to check if a class is a vector\n   ..\n  524       private:\n  525          Gui(std::shared_ptr<Device> pDevice);\n  526:         GuiImpl* mpWrapper = nullptr;\n  527  \n  528          std::shared_ptr<Device> mpDevice;\n\n55 matches across 2 files\n\n\nSearching 1245 files for \"GuiImpl::create\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Utils/UI/Gui.cpp:\n  224      }\n  225  \n  226:     void GuiImpl::createVao(uint32_t vertexCount, uint32_t indexCount) {\n  227          static_assert(sizeof(ImDrawIdx) == sizeof(uint16_t), \"ImDrawIdx expected size is a word\");\n  228          uint32_t requiredVbSize = vertexCount * sizeof(ImDrawVert);\n\n1 match in 1 file\n\n\nSearching 1245 files for \"GraphicsProgram::createFromFile\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/GraphicsProgram.cpp:\n   39      }\n   40  \n   41:     GraphicsProgram::SharedPtr GraphicsProgram::createFromFile(std::shared_ptr<Device> device, const std::string& filename, const std::string& vsEntry, const std::string& psEntry, const DefineList& programDefines) {\n   42          Desc d(filename);\n   43          d.vsEntry(vsEntry).psEntry(psEntry).addDefaultVertexShaderIfNeeded();\n\n/home/max/dev/Falcor/src/Falcor/Scene/Scene.cpp:\n  190      assert(mpDevice);\n  191      \n  192:     GraphicsProgram::SharedPtr pProgram = GraphicsProgram::createFromFile(mpDevice, \"Scene/SceneBlock.slang\", \"\", \"main\");\n  193      pProgram->addDefines(getSceneDefines());\n  194      ParameterBlockReflection::SharedConstPtr pReflection = pProgram->getReflector()->getParameterBlock(kParameterBlockName);\n\n/home/max/dev/Falcor/src/Falcor/Utils/UI/Gui.cpp:\n  191          // Create the program\n  192          LOG_DBG(\"mpDevice uid: %u\", mpDevice->uid());\n  193:         mpProgram = GraphicsProgram::createFromFile(mpDevice, \"Utils/UI/Gui.slang\", \"vs\", \"ps\");\n  194          mpProgramVars = GraphicsVars::create(mpDevice, mpProgram->getReflector());\n  195          mpPipelineState->setProgram(mpProgram);\n\n/home/max/dev/Falcor/src/RenderPasses/ForwardLightingPass/ForwardLightingPass.cpp:\n   75  \n   76  ForwardLightingPass::ForwardLightingPass(Device::SharedPtr pDevice): RenderPass(pDevice) {\n   77:     GraphicsProgram::SharedPtr pProgram = GraphicsProgram::createFromFile(pDevice, \"RenderPasses/ForwardLightingPass/ForwardLightingPass.slang\", \"\", \"ps\");\n   78      mpState = GraphicsState::create(pDevice);\n   79      mpState->setProgram(pProgram);\n\n/home/max/dev/Falcor/src/RenderPasses/SkyBox/SkyBox.cpp:\n   67      if (mpCubeScene == nullptr) throw std::runtime_error(\"SkyBox::SkyBox - Failed to load cube model\");\n   68  \n   69:     mpProgram = GraphicsProgram::createFromFile(pDevice, \"RenderPasses/SkyBox/SkyBox.slang\", \"vs\", \"ps\");\n   70      mpProgram->addDefines(mpCubeScene->getSceneDefines());\n   71      mpVars = GraphicsVars::create(pDevice, mpProgram->getReflector());\n\n/home/max/dev/Falcor/src/Samples/ModelViewer/ModelViewer.cpp:\n  124  \n  125  void ModelViewer::onLoad(RenderContext* pRenderContext) {\n  126:     mpProgram = GraphicsProgram::createFromFile(\"Samples/ModelViewer/ModelViewer.ps.slang\", \"\", \"main\");\n  127      mpGraphicsState = GraphicsState::create();\n  128      mpGraphicsState->setProgram(mpProgram);\n\n6 matches across 6 files\n\n\nSearching 1245 files for \"vkCreateImage\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKDevice.cpp:\n  114      VkImage image;\n  115  \n  116:     vkCreateImage(mApiHandle, pCreateInfo, pAllocator,&image);\n  117      \n  118      apiHandle = ResourceHandle::create(shared_from_this(), image, nullptr);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKResourceViews.cpp:\n  156              LOG_DBG(\"2.2\");\n  157              assert(pResource->device());\n  158:             vk_call(vkCreateImageView(pResource->device()->getApiHandle(), &info, nullptr, &imageView));\n  159              LOG_DBG(\"2.3\");\n  160              return VkResource<VkImageView, VkBufferView>::SharedPtr::create(pResource->device(), imageView, nullptr);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKTexture.cpp:\n  144  \n  145          VkImage image;\n  146:         auto result = vkCreateImage(mpDevice->getApiHandle(), &imageInfo, nullptr, &image);\n  147          if (VK_FAILED(result)) {\n  148              throw std::runtime_error(\"Failed to create texture.\");\n\n3 matches across 3 files\n\n\nSearching 1245 files for \"kRenderPassRefreshFlags\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderPassStandardFlags.h:\n   42      field with this name in the dictionary.\n   43  */\n   44: static const char kRenderPassRefreshFlags[] = \"_refreshFlags\";\n   45  \n   46  /** First available preudorandom number generator dimension.\n\n/home/max/dev/Falcor/src/Falcor/RenderPasses/Shared/PathTracer/PathTracer.cpp:\n  498          if (mOptionsChanged || lightingChanged)\n  499          {\n  500:             auto flags = (Falcor::RenderPassRefreshFlags)(dict.keyExists(kRenderPassRefreshFlags) ? dict[Falcor::kRenderPassRefreshFlags] : 0u);\n  501              if (mOptionsChanged) flags |= Falcor::RenderPassRefreshFlags::RenderOptionsChanged;\n  502              if (lightingChanged) flags |= Falcor::RenderPassRefreshFlags::LightingChanged;\n  503:             dict[Falcor::kRenderPassRefreshFlags] = (uint32_t)flags;\n  504              mOptionsChanged = false;\n  505          }\n\n/home/max/dev/Falcor/src/lava_lib/renderer.cpp:\n  109  \n  110      // Execute graph.\n  111:     (*pGraph->getPassesDictionary())[kRenderPassRefreshFlags] = (uint32_t)RenderPassRefreshFlags::None;\n  112      pGraph->execute(pRenderContext);\n  113  }\n\n/home/max/dev/Falcor/src/Mogwai/Mogwai.cpp:\n  467  \n  468      // Execute graph.\n  469:     (*pGraph->getPassesDictionary())[kRenderPassRefreshFlags] = (uint32_t)RenderPassRefreshFlags::None;\n  470      pGraph->execute(pRenderContext);\n  471  }\n\n/home/max/dev/Falcor/src/RenderPasses/AccumulatePass/AccumulatePass.cpp:\n  113      // Query refresh flags passed down from the application and other passes.\n  114      auto& dict = renderData.getDictionary();\n  115:     RenderPassRefreshFlags refreshFlags = (RenderPassRefreshFlags)(dict.keyExists(kRenderPassRefreshFlags) ? dict[kRenderPassRefreshFlags] : 0u);\n  116  \n  117      // If any refresh flag is set, we reset frame accumulation.\n\n/home/max/dev/Falcor/src/RenderPasses/BSDFViewer/BSDFViewer.cpp:\n  136      if (mOptionsChanged) {\n  137          Dictionary& dict = renderData.getDictionary();\n  138:         auto prevFlags = (Falcor::RenderPassRefreshFlags)(dict.keyExists(kRenderPassRefreshFlags) ? dict[Falcor::kRenderPassRefreshFlags] : 0u);\n  139:         dict[Falcor::kRenderPassRefreshFlags] = (uint32_t)(prevFlags | Falcor::RenderPassRefreshFlags::RenderOptionsChanged);\n  140          mOptionsChanged = false;\n  141      }\n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/GBuffer/GBufferRaster.cpp:\n  150      if (mOptionsChanged) {\n  151          Dictionary& dict = renderData.getDictionary();\n  152:         auto prevFlags = (Falcor::RenderPassRefreshFlags)(dict.keyExists(kRenderPassRefreshFlags) ? dict[Falcor::kRenderPassRefreshFlags] : 0u);\n  153:         dict[Falcor::kRenderPassRefreshFlags] = (uint32_t)(prevFlags | Falcor::RenderPassRefreshFlags::RenderOptionsChanged);\n  154          mOptionsChanged = false;\n  155      }\n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/GBuffer/GBufferRT.cpp:\n  144      if (mOptionsChanged)\n  145      {\n  146:         auto prevFlags = (Falcor::RenderPassRefreshFlags)(dict.keyExists(kRenderPassRefreshFlags) ? dict[Falcor::kRenderPassRefreshFlags] : 0u);\n  147:         dict[Falcor::kRenderPassRefreshFlags] = (uint32_t)(prevFlags | Falcor::RenderPassRefreshFlags::RenderOptionsChanged);\n  148          mOptionsChanged = false;\n  149      }\n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/VBuffer/VBufferRaster.cpp:\n   94      if (mOptionsChanged) {\n   95          Dictionary& dict = renderData.getDictionary();\n   96:         auto prevFlags = (Falcor::RenderPassRefreshFlags)(dict.keyExists(kRenderPassRefreshFlags) ? dict[Falcor::kRenderPassRefreshFlags] : 0u);\n   97:         dict[Falcor::kRenderPassRefreshFlags] = (uint32_t)(prevFlags | Falcor::RenderPassRefreshFlags::RenderOptionsChanged);\n   98          mOptionsChanged = false;\n   99      }\n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/VBuffer/VBufferRT.cpp:\n   96      if (mOptionsChanged)\n   97      {\n   98:         auto prevFlags = (Falcor::RenderPassRefreshFlags)(dict.keyExists(kRenderPassRefreshFlags) ? dict[Falcor::kRenderPassRefreshFlags] : 0u);\n   99:         dict[Falcor::kRenderPassRefreshFlags] = (uint32_t)(prevFlags | Falcor::RenderPassRefreshFlags::RenderOptionsChanged);\n  100          mOptionsChanged = false;\n  101      }\n\n/home/max/dev/Falcor/src/RenderPasses/MinimalPathTracer/MinimalPathTracer.cpp:\n  119      if (mOptionsChanged)\n  120      {\n  121:         auto prevFlags = (Falcor::RenderPassRefreshFlags)(dict.keyExists(kRenderPassRefreshFlags) ? dict[Falcor::kRenderPassRefreshFlags] : 0u);\n  122:         dict[Falcor::kRenderPassRefreshFlags] = (uint32_t)(prevFlags | Falcor::RenderPassRefreshFlags::RenderOptionsChanged);\n  123          mOptionsChanged = false;\n  124      }\n\n/home/max/dev/Falcor/src/RenderPasses/WhittedRayTracer/WhittedRayTracer.cpp:\n  170      if (mOptionsChanged)\n  171      {\n  172:         auto prevFlags = (Falcor::RenderPassRefreshFlags)(dict.keyExists(kRenderPassRefreshFlags) ? dict[Falcor::kRenderPassRefreshFlags] : 0u);\n  173:         dict[Falcor::kRenderPassRefreshFlags] = (uint32_t)(prevFlags | Falcor::RenderPassRefreshFlags::RenderOptionsChanged);\n  174          mOptionsChanged = false;\n  175      }\n\n29 matches across 12 files\n\n\nSearching 1245 files for \"kRenderPassRefreshFlags\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderPassStandardFlags.h:\n   42      field with this name in the dictionary.\n   43  */\n   44: static const char kRenderPassRefreshFlags[] = \"_refreshFlags\";\n   45  \n   46  /** First available preudorandom number generator dimension.\n\n/home/max/dev/Falcor/src/Falcor/RenderPasses/Shared/PathTracer/PathTracer.cpp:\n  498          if (mOptionsChanged || lightingChanged)\n  499          {\n  500:             auto flags = (Falcor::RenderPassRefreshFlags)(dict.keyExists(kRenderPassRefreshFlags) ? dict[Falcor::kRenderPassRefreshFlags] : 0u);\n  501              if (mOptionsChanged) flags |= Falcor::RenderPassRefreshFlags::RenderOptionsChanged;\n  502              if (lightingChanged) flags |= Falcor::RenderPassRefreshFlags::LightingChanged;\n  503:             dict[Falcor::kRenderPassRefreshFlags] = (uint32_t)flags;\n  504              mOptionsChanged = false;\n  505          }\n\n/home/max/dev/Falcor/src/lava_lib/renderer.cpp:\n  109  \n  110      // Execute graph.\n  111:     (*pGraph->getPassesDictionary())[kRenderPassRefreshFlags] = (uint32_t)Falcor::RenderPassRefreshFlags::None;\n  112      pGraph->execute(pRenderContext);\n  113  }\n\n/home/max/dev/Falcor/src/Mogwai/Mogwai.cpp:\n  467  \n  468      // Execute graph.\n  469:     (*pGraph->getPassesDictionary())[kRenderPassRefreshFlags] = (uint32_t)RenderPassRefreshFlags::None;\n  470      pGraph->execute(pRenderContext);\n  471  }\n\n/home/max/dev/Falcor/src/RenderPasses/AccumulatePass/AccumulatePass.cpp:\n  113      // Query refresh flags passed down from the application and other passes.\n  114      auto& dict = renderData.getDictionary();\n  115:     RenderPassRefreshFlags refreshFlags = (RenderPassRefreshFlags)(dict.keyExists(kRenderPassRefreshFlags) ? dict[kRenderPassRefreshFlags] : 0u);\n  116  \n  117      // If any refresh flag is set, we reset frame accumulation.\n\n/home/max/dev/Falcor/src/RenderPasses/BSDFViewer/BSDFViewer.cpp:\n  136      if (mOptionsChanged) {\n  137          Dictionary& dict = renderData.getDictionary();\n  138:         auto prevFlags = (Falcor::RenderPassRefreshFlags)(dict.keyExists(kRenderPassRefreshFlags) ? dict[Falcor::kRenderPassRefreshFlags] : 0u);\n  139:         dict[Falcor::kRenderPassRefreshFlags] = (uint32_t)(prevFlags | Falcor::RenderPassRefreshFlags::RenderOptionsChanged);\n  140          mOptionsChanged = false;\n  141      }\n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/GBuffer/GBufferRaster.cpp:\n  150      if (mOptionsChanged) {\n  151          Dictionary& dict = renderData.getDictionary();\n  152:         auto prevFlags = (Falcor::RenderPassRefreshFlags)(dict.keyExists(kRenderPassRefreshFlags) ? dict[Falcor::kRenderPassRefreshFlags] : 0u);\n  153:         dict[Falcor::kRenderPassRefreshFlags] = (uint32_t)(prevFlags | Falcor::RenderPassRefreshFlags::RenderOptionsChanged);\n  154          mOptionsChanged = false;\n  155      }\n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/GBuffer/GBufferRT.cpp:\n  144      if (mOptionsChanged)\n  145      {\n  146:         auto prevFlags = (Falcor::RenderPassRefreshFlags)(dict.keyExists(kRenderPassRefreshFlags) ? dict[Falcor::kRenderPassRefreshFlags] : 0u);\n  147:         dict[Falcor::kRenderPassRefreshFlags] = (uint32_t)(prevFlags | Falcor::RenderPassRefreshFlags::RenderOptionsChanged);\n  148          mOptionsChanged = false;\n  149      }\n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/VBuffer/VBufferRaster.cpp:\n   94      if (mOptionsChanged) {\n   95          Dictionary& dict = renderData.getDictionary();\n   96:         auto prevFlags = (Falcor::RenderPassRefreshFlags)(dict.keyExists(kRenderPassRefreshFlags) ? dict[Falcor::kRenderPassRefreshFlags] : 0u);\n   97:         dict[Falcor::kRenderPassRefreshFlags] = (uint32_t)(prevFlags | Falcor::RenderPassRefreshFlags::RenderOptionsChanged);\n   98          mOptionsChanged = false;\n   99      }\n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/VBuffer/VBufferRT.cpp:\n   96      if (mOptionsChanged)\n   97      {\n   98:         auto prevFlags = (Falcor::RenderPassRefreshFlags)(dict.keyExists(kRenderPassRefreshFlags) ? dict[Falcor::kRenderPassRefreshFlags] : 0u);\n   99:         dict[Falcor::kRenderPassRefreshFlags] = (uint32_t)(prevFlags | Falcor::RenderPassRefreshFlags::RenderOptionsChanged);\n  100          mOptionsChanged = false;\n  101      }\n\n/home/max/dev/Falcor/src/RenderPasses/MinimalPathTracer/MinimalPathTracer.cpp:\n  119      if (mOptionsChanged)\n  120      {\n  121:         auto prevFlags = (Falcor::RenderPassRefreshFlags)(dict.keyExists(kRenderPassRefreshFlags) ? dict[Falcor::kRenderPassRefreshFlags] : 0u);\n  122:         dict[Falcor::kRenderPassRefreshFlags] = (uint32_t)(prevFlags | Falcor::RenderPassRefreshFlags::RenderOptionsChanged);\n  123          mOptionsChanged = false;\n  124      }\n\n/home/max/dev/Falcor/src/RenderPasses/WhittedRayTracer/WhittedRayTracer.cpp:\n  170      if (mOptionsChanged)\n  171      {\n  172:         auto prevFlags = (Falcor::RenderPassRefreshFlags)(dict.keyExists(kRenderPassRefreshFlags) ? dict[Falcor::kRenderPassRefreshFlags] : 0u);\n  173:         dict[Falcor::kRenderPassRefreshFlags] = (uint32_t)(prevFlags | Falcor::RenderPassRefreshFlags::RenderOptionsChanged);\n  174          mOptionsChanged = false;\n  175      }\n\n29 matches across 12 files\n\n\nSearching 1246 files for \"ctor\" (case sensitive)\n\n/home/max/dev/Falcor/src/CMakeLists.txt:\n    1: add_subdirectory( Falcor ) # renderer core library\n    2: add_subdirectory( RenderPasses ) # render passes plugins\n    3: add_subdirectory( lava_utils_lib ) # lava utility library\n    4: add_subdirectory( lava_lib ) # rendering library\n    5: add_subdirectory( lava_cmd ) # command line renderer\n    6: add_subdirectory( houdini ) # SOHO\n    7  \n    8: #add_subdirectory( pxr ) # usd hydra renderer plugin\n    9: #add_subdirectory( Tools ) # falcor tools\n   10: #add_subdirectory( Samples ) # falcor samples\n   11: add_subdirectory( Mogwai ) # gui application\n   12  \n   13  \n\n/home/max/dev/Falcor/src/Externals/dear_imgui_addons/imguinodegrapheditor/imguinodegrapheditor.cpp:\n  524                  ImGui::Separator();\n  525                  typedef struct _MyDummyStuff {\n  526:                     const ImVector<AvailableNodeInfo>& availableNodesInfo;\n  527:                     _MyDummyStuff(const ImVector<AvailableNodeInfo>& _availableNodesInfo) : availableNodesInfo(_availableNodesInfo) {}\n  528                      static bool item_getter(void* pmds, int idx, const char** pOut) {\n  529                          const _MyDummyStuff& mds = *((const _MyDummyStuff*)pmds);\n  ...\n  807                      }\n  808                      oldFontWindowScale = currentFontWindowScale;\n  809:                     maxConnectorNameWidth = 0.f;\n  810                  }\n  811  \n  ...\n  861                      if (enableLinkCulling) linkClipRect = ImRect(windowClipRect0 + offset - link_cp - ImVec2(0, link_line_width), windowClipRect1 + offset + link_cp + ImVec2(0, link_line_width));   // used to clip links\n  862                      if (enableNodeCulling) {\n  863:                         const float windowClipHalfExtraWidth = NODE_SLOT_RADIUS + (show_connection_names ? maxConnectorNameWidth : 0.f);  // Otherwise node names are culled too early\n  864                          windowClipRect0.x -= windowClipHalfExtraWidth;\n  865                          windowClipRect1.x += windowClipHalfExtraWidth;\n  ...\n 1177                          //#           define SKIP_VERTICAL_GRADIENT\n 1178  #                   ifndef SKIP_VERTICAL_GRADIENT\n 1179:                         float fillGradientFactor = node->overrideTitleBgColorGradient >= 0.f ? node->overrideTitleBgColorGradient : titleBgGradient >= 0.f ? titleBgGradient : style.color_node_title_background_gradient;//0.15f;\n 1180:                         if (node->isSelected) fillGradientFactor = -fillGradientFactor; // or if (node==activeNode)\n 1181:                         if (fillGradientFactor != 0.f) {\n 1182:                             if (node->isOpen) ImGui::NGE_Draw::ImDrawListAddRectWithVerticalGradient(draw_list, node_rect_min, ImVec2(node_rect_max.x, node_rect_min.y + nodeTitleBarBgHeight), nodeTitleBgColor, fillGradientFactor, IM_COL32_BLACK_TRANS, style.node_rounding, 1 | 2);\n 1183:                             else ImGui::NGE_Draw::ImDrawListAddRectWithVerticalGradient(draw_list, node_rect_min, node_rect_max, nodeTitleBgColor, fillGradientFactor, IM_COL32_BLACK_TRANS, style.node_rounding);\n 1184                          }\n 1185                          else {\n ....\n 1212  \n 1213  \n 1214:                     // Display connectors\n 1215                      const ImVec2 oldCursorScreenPos = ImGui::GetCursorScreenPos();\n 1216                      const ImVec2 mouseScreenPos = io.MousePos;;\n 1217:                     ImVec2 connectorScreenPos, deltaPos; const bool canDeleteLinks = true;\n 1218                      const bool mustDeleteLinkIfSlotIsHovered = canDeleteLinks && io.MouseDoubleClicked[0];\n 1219                      const bool mustDetectIfSlotIsHoveredForDragNDrop = !cantDragAnything && !isSomeNodeMoving && (!isDragNodeValid || isLMBDraggingForMakingLinks);\n 1220                      ImGui::PushStyleColor(ImGuiCol_Text, style.color_node_input_slots_names);\n 1221:                     const float connectorBorderThickness = NODE_SLOT_RADIUS * 0.25f; // lineThickness = ((activeNode == node) ? 3.0f : (node->isSelected ? 2.0f : 1.f))*currentFontWindowScale;\n 1222:                     ImVec2 connectorNameSize(0, 0);\n 1223                      for (int slot_idx = 0; slot_idx < node->InputsCount; slot_idx++) {\n 1224:                         connectorScreenPos = offset + node->GetInputSlotPos(slot_idx, currentFontWindowScale);\n 1225:                         //draw_list->AddCircleFilled(connectorScreenPos, NODE_SLOT_RADIUS, style.color_node_input_slots,connectorNumSegments);\n 1226:                         ImGui::NGE_Draw::ImDrawListAddCircle(draw_list, connectorScreenPos, NODE_SLOT_RADIUS, node->inputColors[slot_idx], style.color_node_input_slots_border, style.node_slots_num_segments, connectorBorderThickness);\n 1227                          /*if ((style.color_node_input_slots & IM_COL32_A_MASK) != 0)  {\n 1228                      const float a_max = IM_PI * 0.5f * 11.f/12.f;\n 1229:                     draw_list->PathArcTo(connectorScreenPos, NODE_SLOT_RADIUS, IM_PI-a_max, IM_PI+a_max, 12);\n 1230                      draw_list->PathFill(style.color_node_input_slots);\n 1231                  }*/\n ....\n 1233                              const char* name = node->InputNames[slot_idx];\n 1234                              if (name) {\n 1235:                                 connectorNameSize = ImGui::CalcTextSize(name);\n 1236:                                 if (maxConnectorNameWidth < connectorNameSize.x) maxConnectorNameWidth = connectorNameSize.x;\n 1237:                                 ImGui::SetCursorScreenPos(offset + node->GetInputSlotPos(slot_idx, currentFontWindowScale) - ImVec2(NODE_SLOT_RADIUS, 0) - connectorNameSize);\n 1238                                  ImGui::Text(\"%s\", name);\n 1239                              }\n 1240                          }\n 1241                          if (mustDetectIfSlotIsHoveredForDragNDrop || mustDeleteLinkIfSlotIsHovered) {\n 1242:                             deltaPos.x = mouseScreenPos.x - connectorScreenPos.x;\n 1243:                             deltaPos.y = mouseScreenPos.y - connectorScreenPos.y;\n 1244                              if ((deltaPos.x*deltaPos.x) + (deltaPos.y*deltaPos.y) < NODE_SLOT_RADIUS_SQUARED) {\n 1245                                  if (mustDeleteLinkIfSlotIsHovered) {\n ....\n 1299                      ImGui::PushStyleColor(ImGuiCol_Text, style.color_node_output_slots_names);\n 1300                      for (int slot_idx = 0; slot_idx < node->OutputsCount; slot_idx++) {\n 1301:                         connectorScreenPos = offset + node->GetOutputSlotPos(slot_idx, currentFontWindowScale);\n 1302:                         //draw_list->AddCircleFilled(connectorScreenPos, NODE_SLOT_RADIUS, style.color_node_output_slots,connectorNumSegments);\n 1303:                         ImGui::NGE_Draw::ImDrawListAddCircle(draw_list, connectorScreenPos, NODE_SLOT_RADIUS, node->outputColors[slot_idx], style.color_node_output_slots_border, style.node_slots_num_segments, connectorBorderThickness);\n 1304                          /*if ((style.color_node_output_slots & IM_COL32_A_MASK) != 0)  {\n 1305                      const float a_max = IM_PI * 0.5f * 11.f/12.f;\n 1306:                     draw_list->PathArcTo(connectorScreenPos, NODE_SLOT_RADIUS, -a_max, a_max, 12);\n 1307                      draw_list->PathFill(style.color_node_output_slots);\n 1308                  }*/\n ....\n 1310                              const char* name = node->OutputNames[slot_idx];\n 1311                              if (name) {\n 1312:                                 connectorNameSize = ImGui::CalcTextSize(name);\n 1313:                                 if (maxConnectorNameWidth < connectorNameSize.x) maxConnectorNameWidth = connectorNameSize.x;\n 1314:                                 ImGui::SetCursorScreenPos(offset + node->GetOutputSlotPos(slot_idx, currentFontWindowScale) + ImVec2(NODE_SLOT_RADIUS, 0) - ImVec2(0, connectorNameSize.y));\n 1315                                  ImGui::Text(\"%s\", name);\n 1316                              }\n 1317                          }\n 1318                          if (mustDetectIfSlotIsHoveredForDragNDrop || mustDeleteLinkIfSlotIsHovered) {\n 1319:                             deltaPos.x = mouseScreenPos.x - connectorScreenPos.x;\n 1320:                             deltaPos.y = mouseScreenPos.y - connectorScreenPos.y;\n 1321                              if ((deltaPos.x*deltaPos.x) + (deltaPos.y*deltaPos.y) < NODE_SLOT_RADIUS_SQUARED) {\n 1322                                  if (mustDeleteLinkIfSlotIsHovered) {\n ....\n 1491                      open_delete_only_context_menu = false;\t// just in case...\n 1492                  }\n 1493:                 else if (/*!isAContextMenuOpen &&*/ !ImGui::IsAnyItemHovered() && ImGui::IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem) && getNumAvailableNodeTypes() > 0 && nodeFactoryFunctionPtr) {\n 1494                      // if (ImGui::IsMouseClicked(1)) {   // Open context menu for adding nodes\n 1495                      //     menuNode = node_hovered_in_scene ? node_hovered_in_scene : node_hovered_in_list ? node_hovered_in_list : NULL;\n ....\n 1599                          ImGui::Text(\"%s\", \"Add Node Menu\");\n 1600                          ImGui::Separator();\n 1601:                         if (nodeFactoryFunctionPtr) {\n 1602                              if (sourceCopyNode && sourceCopyNode->canBeCopied()) {\n 1603                                  AvailableNodeInfo* ni = fetchAvailableNodeInfo(sourceCopyNode->getType());\n 1604                                  if ((!ni || ni->maxNumInstances < 0 || ni->curNumInstances < ni->maxNumInstances) && ImGui::MenuItem(\"Paste##cloneCopySource\")) {\n 1605:                                     Node* clonedNode = addNode(nodeFactoryFunctionPtr(sourceCopyNode->typeID, scene_pos, *this));\n 1606                                      clonedNode->fields.copyPDataValuesFrom(sourceCopyNode->fields);\n 1607                                      clonedNode->onCopied();\n ....\n 1672  \n 1673  \n 1674:     void NodeGraphEditor::registerNodeTypes(const char *nodeTypeNames[], int numNodeTypeNames, NodeFactoryDelegate _nodeFactoryFunctionPtr, const int *pOptionalNodeTypesToUse, int numNodeTypesToUse, const int* pOptionalMaxNumAllowedInstancesToUse, int numMaxNumAllowedInstancesToUse, bool sortEntriesAlphabetically)\n 1675      {\n 1676          this->numNodeTypeNames = numNodeTypeNames;\n 1677          this->pNodeTypeNames = numNodeTypeNames > 0 ? &nodeTypeNames[0] : NULL;\n 1678:         this->nodeFactoryFunctionPtr = _nodeFactoryFunctionPtr;\n 1679          this->availableNodesInfo.clear(); this->availableNodesInfoInverseMap.clear();\n 1680          if (numNodeTypesToUse > numNodeTypeNames) numNodeTypesToUse = numNodeTypeNames;\n ....\n 1751          return false;\n 1752      }\n 1753:     int NodeGraphEditor::getAllNodesOfType(int typeID, ImVector<Node *> *pNodesOut, bool clearNodesOutBeforeUsage) {\n 1754          if (pNodesOut && clearNodesOutBeforeUsage) pNodesOut->clear();\n 1755          int cnt = 0;\n ....\n 1763          return cnt;\n 1764      }\n 1765:     int NodeGraphEditor::getAllNodesOfType(int typeID, ImVector<const Node *> *pNodesOut, bool clearNodesOutBeforeUsage) const {\n 1766          if (pNodesOut && clearNodesOutBeforeUsage) pNodesOut->clear();\n 1767          int cnt = 0;\n ....\n 1779          const bool mustDeleteSourceCopyNode = sourceCopyNode && (!n || n->typeID != sourceCopyNode->typeID);\n 1780          if (mustDeleteSourceCopyNode) {\n 1781:             sourceCopyNode->~Node();              // ImVector does not call it\n 1782              ImGui::MemFree(sourceCopyNode);       // items MUST be allocated by the user using ImGui::MemAlloc(...)\n 1783              sourceCopyNode = NULL;\n ....\n 1785          if (!n) return;\n 1786          if (!sourceCopyNode) {\n 1787:             if (!nodeFactoryFunctionPtr) return;\n 1788:             sourceCopyNode = nodeFactoryFunctionPtr(n->typeID, ImVec2(0, 0), *this);\n 1789          }\n 1790          sourceCopyNode->fields.copyPDataValuesFrom(n->fields);\n ....\n 1792      }\n 1793  \n 1794:     void NodeGraphEditor::getInputNodesForNodeAndSlot(const Node* node, int input_slot, ImVector<Node *> &returnValueOut, ImVector<int> *pOptionalReturnValueOutputSlotOut) const {\n 1795          returnValueOut.clear(); if (pOptionalReturnValueOutputSlotOut) pOptionalReturnValueOutputSlotOut->clear();\n 1796          for (int link_idx = 0, link_idx_size = links.size(); link_idx < link_idx_size; link_idx++) {\n ....\n 1813          return NULL;\n 1814      }\n 1815:     void NodeGraphEditor::getOutputNodesForNodeAndSlot(const Node* node, int output_slot, ImVector<Node *> &returnValueOut, ImVector<int> *pOptionalReturnValueInputSlotOut) const {\n 1816          returnValueOut.clear(); if (pOptionalReturnValueInputSlotOut) pOptionalReturnValueInputSlotOut->clear();\n 1817          for (int link_idx = 0, link_idx_size = links.size(); link_idx < link_idx_size; link_idx++) {\n ....\n 1859      }\n 1860  \n 1861:     int NodeGraphEditor::getSelectedNodes(ImVector<Node *> &rv) {\n 1862          rv.resize(0);\n 1863          for (int i = 0, isz = nodes.size(); i < isz; i++) {\n ....\n 1868      }\n 1869  \n 1870:     int NodeGraphEditor::getSelectedNodes(ImVector<const Node *> &rv) const {\n 1871          rv.resize(0);\n 1872          for (int i = 0, isz = nodes.size(); i < isz; i++) {\n ....\n 2114  #endif //NO_IMGUIHELPER_SERIALIZATION_LOAD\n 2115  #endif //NO_IMGUIHELPER_SERIALIZATION\n 2116:     FieldInfo &FieldInfoVector::addField(int *pdata, int numArrayElements, const char *label, const char *tooltip, int precision, int lowerLimit, int upperLimit, void *userData) {\n 2117          IM_ASSERT(pdata && numArrayElements <= 4);\n 2118          push_back(FieldInfo());\n ....\n 2122          return f;\n 2123      }\n 2124:     FieldInfo &FieldInfoVector::addField(unsigned *pdata, int numArrayElements, const char *label, const char *tooltip, int precision, unsigned lowerLimit, unsigned upperLimit, void *userData) {\n 2125          IM_ASSERT(pdata && numArrayElements <= 4);\n 2126          push_back(FieldInfo());\n ....\n 2130          return f;\n 2131      }\n 2132:     FieldInfo &FieldInfoVector::addField(float *pdata, int numArrayElements, const char *label, const char *tooltip, int precision, float lowerLimit, float upperLimit, void *userData, bool needsRadiansToDegs) {\n 2133          IM_ASSERT(pdata && numArrayElements <= 4);\n 2134          push_back(FieldInfo());\n ....\n 2138          return f;\n 2139      }\n 2140:     FieldInfo &FieldInfoVector::addField(double *pdata, int numArrayElements, const char *label, const char *tooltip, int precision, double lowerLimit, double upperLimit, void *userData, bool needsRadiansToDegs) {\n 2141          IM_ASSERT(pdata && numArrayElements <= 4);\n 2142          push_back(FieldInfo());\n ....\n 2146          return f;\n 2147      }\n 2148:     FieldInfo &FieldInfoVector::addField(char *pdata, int textLength, const char *label, const char *tooltip, int flags, bool multiline, float optionalHeight, void *userData, bool isSingleEditWithBrowseButton) {\n 2149          IM_ASSERT(pdata);\n 2150          push_back(FieldInfo());\n ....\n 2154          return f;\n 2155      }\n 2156:     FieldInfo &FieldInfoVector::addFieldEnum(int *pdata, int numEnumElements, FieldInfo::TextFromEnumDelegate textFromEnumFunctionPtr, const char *label, const char *tooltip, void *userData) {\n 2157          IM_ASSERT(pdata && numEnumElements > 0 && textFromEnumFunctionPtr);\n 2158          push_back(FieldInfo());\n ....\n 2161          return f;\n 2162      }\n 2163:     FieldInfo &FieldInfoVector::addFieldEnum(int *pdata, FieldInfo::GetNumEnumElementsDelegate getNumEnumElementsFunctionPtr, FieldInfo::TextFromEnumDelegate textFromEnumFunctionPtr, const char *label, const char *tooltip, void *userData) {\n 2164          IM_ASSERT(pdata && getNumEnumElementsFunctionPtr && textFromEnumFunctionPtr);\n 2165          push_back(FieldInfo());\n ....\n 2174          return true;\n 2175      }\n 2176:     FieldInfo &FieldInfoVector::addFieldEnum(int *pdata, int numEnumElements, const char* const* items, const char *label, const char *tooltip) {\n 2177          IM_ASSERT(pdata && numEnumElements > 0);\n 2178          push_back(FieldInfo());\n ....\n 2195          return true;\n 2196      }\n 2197:     FieldInfo &FieldInfoVector::addFieldEnum(int *pdata, const char* items_separated_by_zeros, const char *label, const char *tooltip) {\n 2198          IM_ASSERT(pdata);\n 2199          int items_count = 0;\n ....\n 2206          return f;\n 2207      }\n 2208:     FieldInfo &FieldInfoVector::addField(bool *pdata, const char *label, const char *tooltip, void *userData) {\n 2209          IM_ASSERT(pdata);\n 2210          push_back(FieldInfo());\n ....\n 2214          return f;\n 2215      }\n 2216:     FieldInfo &FieldInfoVector::addFieldColor(float *pdata, bool useAlpha, const char *label, const char *tooltip, int precision, void *userData) {\n 2217          IM_ASSERT(pdata);\n 2218          push_back(FieldInfo());\n ....\n 2222          return f;\n 2223      }\n 2224:     FieldInfo &FieldInfoVector::addFieldCustom(FieldInfo::RenderFieldDelegate renderFieldDelegate, FieldInfo::CopyFieldDelegate copyFieldDelegate, void *userData\n 2225          //-------------------------------------------------------------------------------\n 2226  #       if (defined(IMGUIHELPER_H_) && !defined(NO_IMGUIHELPER_SERIALIZATION))\n ....\n 2256      bool NodeGraphEditor::UseSlidersInsteadOfDragControls = false;\n 2257      template<typename T> inline static T GetRadiansToDegs() {\n 2258:         static T factor = T(180) / T(3.1415926535897932384626433832795029);\n 2259:         return factor;\n 2260      }\n 2261      template<typename T> inline static T GetDegsToRadians() {\n 2262:         static T factor = T(3.1415926535897932384626433832795029) / T(180);\n 2263:         return factor;\n 2264      }\n 2265      bool FieldInfo::render(int nodeWidth) {\n ....\n 2603      }\n 2604      bool NodeGraphEditor::load(ImGuiHelper::Deserializer& d, const char ** pOptionalBufferStart) {\n 2605:         if (!d.isValid() || !nodeFactoryFunctionPtr) return false;\n 2606          clear();\n 2607          setModified(false);\n ....\n 2615              amount = d.parse(NodeGraphEditorParseCallback2, (void*)&cbn, amount);\n 2616              // TODO: do some checks on cbn\n 2617:             Node* n = nodeFactoryFunctionPtr(cbn.typeID, cbn.Pos, *this);\n 2618              n->userID = cbn.userID;\n 2619              n->isOpen = cbn.isOpen;\n ....\n 2644              nodes[i]->onLoaded();\n 2645          }\n 2646:         maxConnectorNameWidth = 0;\n 2647          oldFontWindowScale = 0;\n 2648          //--------------------------------------------\n ....\n 2725              // 1) allocation\n 2726              // MANDATORY (NodeGraphEditor::~NodeGraphEditor() will delete these with ImGui::MemFree(...))\n 2727:         // MANDATORY even with blank ctrs. Reason: ImVector does not call ctrs/dctrs on items.\n 2728              ThisClass* node = (ThisClass*)ImGui::MemAlloc(sizeof(ThisClass)); IM_PLACEMENT_NEW(node) ThisClass();\n 2729  \n ....\n 2767              // 1) allocation\n 2768              // MANDATORY (NodeGraphEditor::~NodeGraphEditor() will delete these with ImGui::MemFree(...))\n 2769:         // MANDATORY even with blank ctrs. Reason: ImVector does not call ctrs/dctrs on items.\n 2770              ThisClass* node = (ThisClass*)ImGui::MemAlloc(sizeof(ThisClass)); IM_PLACEMENT_NEW(node) ThisClass();\n 2771  \n ....\n 2815              // 1) allocation\n 2816              // MANDATORY (NodeGraphEditor::~NodeGraphEditor() will delete these with ImGui::MemFree(...))\n 2817:             // MANDATORY even with blank ctrs. Reason: ImVector does not call ctrs/dctrs on items.\n 2818              ThisClass* node = (ThisClass*)ImGui::MemAlloc(sizeof(ThisClass)); IM_PLACEMENT_NEW(node) ThisClass();\n 2819  \n ....\n 2880              // 1) allocation\n 2881              // MANDATORY (NodeGraphEditor::~NodeGraphEditor() will delete these with ImGui::MemFree(...))\n 2882:             // MANDATORY even with blank ctrs.  Reason: ImVector does not call ctrs/dctrs on items.\n 2883              ThisClass* node = (ThisClass*)ImGui::MemAlloc(sizeof(ThisClass)); IM_PLACEMENT_NEW(node) ThisClass();\n 2884  \n ....\n 2947              // 1) allocation\n 2948              // MANDATORY (NodeGraphEditor::~NodeGraphEditor() will delete these with ImGui::MemFree(...))\n 2949:             // MANDATORY even with blank ctrs.  Reason: ImVector does not call ctrs/dctrs on items.\n 2950              ThisClass* node = (ThisClass*)ImGui::MemAlloc(sizeof(ThisClass));\n 2951              IM_PLACEMENT_NEW(node) ThisClass();\n ....\n 2980              const bool changed = Base::render(nodeWidth);\n 2981  #\tifndef NO_IMGUIFILESYSTEM\n 2982:             const char* filePath = dlg.chooseFileDialog(startBrowseDialogNextFrame, dlg.getLastDirectory(), \".jpg;.jpeg;.png;.gif;.tga;.bmp\");\n 2983              if (strlen(filePath) > 0) {\n 2984                  //fprintf(stderr,\"Browsed..: %s\\n\",filePath);\n ....\n 3057              // 1) allocation\n 3058              // MANDATORY (NodeGraphEditor::~NodeGraphEditor() will delete these with ImGui::MemFree(...))\n 3059:         // MANDATORY even with blank ctrs. Reason: ImVector does not call ctrs/dctrs on items.\n 3060              ThisClass* node = (ThisClass*)ImGui::MemAlloc(sizeof(ThisClass)); IM_PLACEMENT_NEW(node) ThisClass();\n 3061  \n ....\n 3081      };\n 3082  \n 3083:     static Node* MyNodeFactory(int nt, const ImVec2& pos, const NodeGraphEditor& /*nge*/) {\n 3084          switch (nt) {\n 3085          case MNT_COLOR_NODE: return ColorNode::Create(pos);\n ....\n 3100          if (nge.isInited()) {\n 3101              // This adds entries to the \"add node\" context menu\n 3102:             nge.registerNodeTypes(MyNodeTypeNames, MNT_COUNT, MyNodeFactory, NULL, -1); // last 2 args can be used to add only a subset of nodes (or to sort their order inside the context menu)\n 3103              // The line above can be replaced by the following two lines, if we want to use only an active subset of the available node types:\n 3104              //const int optionalNodeTypesToUse[] = {MNT_COMPLEX_NODE,MNT_COMMENT_NODE,MNT_OUTPUT_NODE};\n 3105:             //nge.registerNodeTypes(MyNodeTypeNames,MNT_COUNT,MyNodeFactory,optionalNodeTypesToUse,sizeof(optionalNodeTypesToUse)/sizeof(optionalNodeTypesToUse[0]));\n 3106              nge.registerNodeTypeMaxAllowedInstances(MNT_OUTPUT_NODE, 1); // Here we set the max number of allowed instances of the output node (1)\n 3107  \n\n/home/max/dev/Falcor/src/Externals/dear_imgui_addons/imguinodegrapheditor/imguinodegrapheditor.h:\n    1: /* \tRefactoring from https://github.com/ocornut/imgui/issues/306\n    2      It's basically the same exact code with a few modifications (and tons of additions)\n    3  */\n    .\n   54  */\n   55  \n   56: // Enforce cdecl calling convention for functions called by the standard library, in case compilation settings changed the default to e.g. __vectorcall\n   57  #ifdef _MSC_VER\n   58  #define IMGUINGE_CDECL __cdecl\n   ..\n  175          //--------------------------------------------------------------------------------\n  176  \n  177:         friend class FieldInfoVector;\n  178          friend class Node;\n  179      };\n  180:     class FieldInfoVector : public ImVector < FieldInfo > {\n  181      public:\n  182          // Warning: returned reference might not stay valid for long in these methods\n  ...\n  218          );\n  219  \n  220:         void copyPDataValuesFrom(const FieldInfoVector& o) {\n  221              for (int i = 0, isz = o.size() < size() ? o.size() : size(); i < isz; i++) {\n  222                  const FieldInfo& of = o[i];\n  ...\n  271  \n  272      protected:\n  273:         FieldInfoVector fields; // I guess you can just skip these at all and implement virtual methods... but it was supposed to be useful...\n  274          // virtual methods\n  275          virtual bool render(float nodeWidth) // should return \"true\" if the node has been edited and its values modified (to fire \"edited callbacks\")\n  ...\n  373      {\n  374          public:\n  375:         typedef Node* (*NodeFactoryDelegate)(int nodeType,const ImVec2& pos,const NodeGraphEditor& nge);\n  376          enum NodeState { NS_ADDED,NS_DELETED,NS_EDITED };\n  377          enum LinkState { LS_ADDED,LS_DELETED };\n  ...\n  380  \n  381          protected:\n  382:         ImVector<Node*> nodes;          // used as a garbage collector too\n  383:         ImVector<NodeLink> links;\n  384          ImVec2 scrolling;\n  385          Node *activeNode;               // It's one of the selected nodes (ATM always the first, but the concept of 'active node' is never used by this code: i.e. we could have not included any 'active node' selection at all)\n  ...\n  391          //bool isAContextMenuOpen;            // to fix a bug\n  392          float oldFontWindowScale;           // to fix zooming (CTRL+mouseWheel)    \n  393:         float maxConnectorNameWidth;        //used to enlarge node culling space to include connector names\n  394          int nodeListFilterComboIndex;\n  395  \n  ...\n  397          const char** pNodeTypeNames; // NOT OWNED! -> Must point to a static reference. Must contain ALL node names.\n  398          int numNodeTypeNames;\n  399:         NodeFactoryDelegate nodeFactoryFunctionPtr;\n  400  \n  401          struct AvailableNodeInfo {\n  ...\n  404              AvailableNodeInfo(int _type = 0,int _maxNumInstances = -1,int _curNumInstances = 0,const char* _name = NULL) : type(_type),maxNumInstances(_maxNumInstances),curNumInstances(_curNumInstances),name(_name) {}\n  405          };\n  406:         ImVector<AvailableNodeInfo> availableNodesInfo;     // These will appear in the \"add node menu\"\n  407:         ImVector<int> availableNodesInfoInverseMap;         // map: absolute node type -> availableNodesInfo index. Must be size() = totalNumberOfNodeTypes.\n  408  \n  409          typedef void(*NodeCallback)(Node*& node,NodeState state,NodeGraphEditor& editor);\n  ...\n  545              pNodeTypeNames = NULL;\n  546              numNodeTypeNames = 0;\n  547:             nodeFactoryFunctionPtr = NULL;\n  548              inited = init_in_ctr;\n  549              //colorEditMode = ImGuiColorEditMode_RGB;\n  ...\n  551              oldFontWindowScale = 0.f;\n  552              nodesBaseWidth = 120.f;\n  553:             maxConnectorNameWidth = 0;\n  554              nodeListFilterComboIndex = 0;\n  555              setModified(false);\n  ...\n  570                  if (node) {\n  571                      if (nodeCallback) nodeCallback(node,NS_DELETED,*this);\n  572:                     node->~Node();              // ImVector does not call it\n  573                      ImGui::MemFree(node);       // items MUST be allocated by the user using ImGui::MemAlloc(...)\n  574                      node = NULL;\n  ...\n  578              scrolling = ImVec2(0,0);\n  579              if (sourceCopyNode) {\n  580:                     sourceCopyNode->~Node();              // ImVector does not call it\n  581                      ImGui::MemFree(sourceCopyNode);       // items MUST be allocated by the user using ImGui::MemAlloc(...)\n  582                      sourceCopyNode = NULL;\n  ...\n  610  \n  611          // nodeTypeNames must point to a block of static memory: it's not owned, nor copied. pOptionalNodeTypesToUse is copied.\n  612:         IMGUI_API void registerNodeTypes(const char* nodeTypeNames[], int numNodeTypeNames, NodeFactoryDelegate _nodeFactoryFunctionPtr, const int* pOptionalNodeTypesToUse = NULL, int numNodeTypesToUse = -1, const int* pOptionalMaxNumAllowedInstancesToUse = NULL, int numMaxNumAllowedInstancesToUse = 0, bool sortEntriesAlphabetically = true);\n  613          inline int getNumAvailableNodeTypes() const { return availableNodesInfo.size(); }\n  614          bool registerNodeTypeMaxAllowedInstances(int nodeType,int maxAllowedNodeTypeInstances = -1) {\n  ...\n  630                      removeAnyLinkFromNode(n);\n  631                      if (nodeCallback) nodeCallback(n,NS_DELETED,*this);\n  632:                     n->~Node();              // ImVector does not call it\n  633                      ImGui::MemFree(n);       // items MUST be allocated by the user using ImGui::MemAlloc(...)\n  634                      if (i + 1 < nodes.size()) n = nodes[nodes.size() - 1];    // swap with the last node\n  ...\n  671          Node* getHoveredNode() { return menuNode; }  // This is actually not strictly the hovered node, but the node called 'menuNode'\n  672          const Node* getHoveredNode() const { return menuNode; }\n  673:         IMGUI_API int getSelectedNodes(ImVector<Node*>& rv);  // returns rv.size(). The active node should be contained inside rv (the first AFAIK).\n  674:         IMGUI_API int getSelectedNodes(ImVector<const Node*>& rv) const;\n  675          Node* getActiveNode() { return activeNode; }  // The 'active' node is the first of the selected nodes\n  676          const Node* getActiveNode() const { return activeNode; }\n  ...\n  683          bool isNodeSelected(const Node* node) const { return (node && node->isSelected); }\n  684  \n  685:         IMGUI_API void getOutputNodesForNodeAndSlot(const Node* node,int output_slot,ImVector<Node*>& returnValueOut,ImVector<int>* pOptionalReturnValueInputSlotOut = NULL) const;\n  686:         IMGUI_API void getInputNodesForNodeAndSlot(const Node* node,int input_slot,ImVector<Node*>& returnValueOut,ImVector<int>* pOptionalReturnValueOutputSlotOut = NULL) const;\n  687          // if allowOnlyOneLinkPerInputSlot == true:\n  688          IMGUI_API Node* getInputNodeForNodeAndSlot(const Node* node,int input_slot,int* pOptionalReturnValueOutputSlotOut = NULL) const;\n  ...\n  690          IMGUI_API bool isNodeReachableFrom(const Node *node1, bool goBackward,const Node* nodeToFind,int* pOptionalNode1SlotOut = NULL,int* pOptionalNodeToFindSlotOut = NULL) const;\n  691          IMGUI_API bool hasLinks(Node* node) const;\n  692:         IMGUI_API int getAllNodesOfType(int typeID,ImVector<Node*>* pNodesOut = NULL,bool clearNodesOutBeforeUsage = true);\n  693:         IMGUI_API int getAllNodesOfType(int typeID,ImVector<const Node*>* pNodesOut = NULL,bool clearNodesOutBeforeUsage = true) const;\n  694          int getNumNodes() const { return nodes.size(); }\n  695          Node* getNode(int index) { return (index >= 0 && index < nodes.size()) ? nodes[index] : NULL; }\n  ...\n  751  \n  752                      Node* addNode(int nodeType,const ImVec2& Pos,AvailableNodeInfo* pOptionalNi) {\n  753:                         if (!nodeFactoryFunctionPtr) return NULL;\n  754                          if (!pOptionalNi) pOptionalNi = fetchAvailableNodeInfo(nodeType);\n  755                          if (!pOptionalNi || (pOptionalNi->maxNumInstances >= 0 && pOptionalNi->curNumInstances >= pOptionalNi->maxNumInstances)) return NULL;\n  756:                         Node* rv = nodeFactoryFunctionPtr(pOptionalNi->type,Pos,*this);\n  757                          if (rv) ++(pOptionalNi->curNumInstances);\n  758                          return addNode(rv);\n  ...\n  790  \n  791                      private:\n  792:                         // Refactored for cleaner exposure (without the misleading 'flag' argument)\n  793                          void selectNodePrivate(const Node* node, bool flag = true,bool findANewActiveNodeWhenNeeded = true);\n  794                          void selectAllNodesPrivate(bool flag = true,bool findANewActiveNodeWhenNeeded = true);\n\n/home/max/dev/Falcor/src/Externals/GLM/cmake/CMakePackageConfigHelpers.cmake:\n   19  #   set(FOO_CONFIG_DIR  \"${installedPrefix}/@CONFIG_INSTALL_DIR@\" )\n   20  # All 4 options shown above are not sufficient, since the first 3 hardcode\n   21: # the absolute directory locations, and the 4th case works only if the logic\n   22  # to determine the installedPrefix is correct, and if CONFIG_INSTALL_DIR contains\n   23  # a relative path, which in general cannot be guaranteed.\n   ..\n   48  # by CONFIGURE_PACKAGE_CONFIG_FILE() so that they are always relative to the\n   49  # installed location of the package. This works both for relative and also for absolute locations.\n   50: # For absolute locations it works only if the absolute location is a subdirectory\n   51  # of CMAKE_INSTALL_PREFIX.\n   52  #\n   ..\n   55  #\n   56  # set_and_check() should be used instead of the normal set()\n   57: # command for setting directories and file locations. Additionally to setting the\n   58: # variable it also checks that the referenced file or directory actually exists\n   59  # and fails with a FATAL_ERROR otherwise. This makes sure that the created\n   60  # FooConfig.cmake file does not contain wrong references.\n   ..\n  199    set(\\${_var} \\\"\\${_file}\\\")\n  200    if(NOT EXISTS \\\"\\${_file}\\\")\n  201:     message(FATAL_ERROR \\\"File or directory \\${_file} referenced by variable \\${_var} does not exist !\\\")\n  202    endif()\n  203  endmacro()\n\n/home/max/dev/Falcor/src/Externals/GLM/cmake/GNUInstallDirs.cmake:\n    1: # - Define GNU standard installation directories\n    2: # Provides install directory variables as defined for GNU software:\n    3: #  http://www.gnu.org/prep/standards/html_node/Directory-Variables.html\n    4  # Inclusion of this module defines the following variables:\n    5  #  CMAKE_INSTALL_<dir>      - destination for files of a given type\n    .\n   43  #  License text for the above reference.)\n   44  \n   45: # Installation directories\n   46  #\n   47  if(NOT DEFINED CMAKE_INSTALL_BINDIR)\n   ..\n   88        if(NOT DEFINED CMAKE_SIZEOF_VOID_P)\n   89          message(AUTHOR_WARNING\n   90:           \"Unable to determine default CMAKE_INSTALL_LIBDIR directory because no target architecture is known. \"\n   91            \"Please enable at least one language before including GNUInstallDirs.\")\n   92        else()\n   ..\n  162    )\n  163  \n  164: # Result directories\n  165  #\n  166  foreach(dir\n\n/home/max/dev/Falcor/src/Externals/GLM/CMakeLists.txt:\n  197  \tadd_compile_options(-Werror -Weverything)\n  198  \tadd_compile_options(-Wno-c++98-compat -Wno-c++98-compat-pedantic -Wno-c++11-long-long -Wno-padded -Wno-gnu-anonymous-struct -Wno-nested-anon-types)\n  199: \tadd_compile_options(-Wno-undefined-reinterpret-cast -Wno-sign-conversion -Wno-unused-variable -Wno-missing-prototypes -Wno-unreachable-code -Wno-missing-variable-declarations -Wno-sign-compare -Wno-global-constructors -Wno-unused-macros -Wno-format-nonliteral)\n  200  \n  201  elseif(CMAKE_CXX_COMPILER_ID MATCHES \"GNU\")\n  ...\n  222  endif()\n  223  \n  224: include_directories(\"${PROJECT_SOURCE_DIR}\")\n  225  \n  226: add_subdirectory(glm)\n  227: add_subdirectory(test)\n  228  \n  229  set(GLM_INSTALL_CONFIGDIR \"${CMAKE_INSTALL_LIBDIR}/cmake/glm\")\n  ...\n  249  \n  250  add_library(glm INTERFACE)\n  251: target_include_directories(glm INTERFACE\n  252  \t$<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>\n  253  \t$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>)\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/common.hpp:\n   25  \t/// Returns x if x >= 0; otherwise, it returns -x.\n   26  \t///\n   27: \t/// @tparam genType floating-point or signed integer; scalar or vector types.\n   28  \t///\n   29  \t/// @see <a href=\"http://www.opengl.org/sdk/docs/manglsl/xhtml/abs.xml\">GLSL abs man page</a>\n   ..\n   34  \t/// Returns x if x >= 0; otherwise, it returns -x.\n   35  \t///\n   36: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n   37  \t/// @tparam T Floating-point or signed integer scalar types\n   38  \t/// @tparam Q Value from qualifier enum\n   ..\n   45  \t/// Returns 1.0 if x > 0, 0.0 if x == 0, or -1.0 if x < 0.\n   46  \t///\n   47: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n   48  \t/// @tparam T Floating-point scalar types\n   49  \t/// @tparam Q Value from qualifier enum\n   ..\n   56  \t/// Returns a value equal to the nearest integer that is less then or equal to x.\n   57  \t///\n   58: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n   59  \t/// @tparam T Floating-point scalar types\n   60  \t/// @tparam Q Value from qualifier enum\n   ..\n   68  \t/// whose absolute value is not larger than the absolute value of x.\n   69  \t///\n   70: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n   71  \t/// @tparam T Floating-point scalar types\n   72  \t/// @tparam Q Value from qualifier enum\n   ..\n   83  \t/// same value as roundEven(x) for all values of x.\n   84  \t///\n   85: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n   86  \t/// @tparam T Floating-point scalar types\n   87  \t/// @tparam Q Value from qualifier enum\n   ..\n   96  \t/// integer. (Both 3.5 and 4.5 for x will return 4.0.)\n   97  \t///\n   98: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n   99  \t/// @tparam T Floating-point scalar types\n  100  \t/// @tparam Q Value from qualifier enum\n  ...\n  109  \t/// that is greater than or equal to x.\n  110  \t///\n  111: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  112  \t/// @tparam T Floating-point scalar types\n  113  \t/// @tparam Q Value from qualifier enum\n  ...\n  120  \t/// Return x - floor(x).\n  121  \t///\n  122: \t/// @tparam genType Floating-point scalar or vector types.\n  123  \t///\n  124  \t/// @see <a href=\"http://www.opengl.org/sdk/docs/manglsl/xhtml/fract.xml\">GLSL fract man page</a>\n  ...\n  129  \t/// Return x - floor(x).\n  130  \t///\n  131: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  132  \t/// @tparam T Floating-point scalar types\n  133  \t/// @tparam Q Value from qualifier enum\n  ...\n  147  \t/// for each component in x using the floating point value y.\n  148  \t///\n  149: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  150  \t/// @tparam T Floating-point scalar types, include glm/gtc/integer for integer scalar types support\n  151  \t/// @tparam Q Value from qualifier enum\n  ...\n  161  \t/// sign as x.\n  162  \t///\n  163: \t/// @tparam genType Floating-point scalar or vector types.\n  164  \t///\n  165  \t/// @see <a href=\"http://www.opengl.org/sdk/docs/manglsl/xhtml/modf.xml\">GLSL modf man page</a>\n  ...\n  170  \t/// Returns y if y < x; otherwise, it returns x.\n  171  \t///\n  172: \t/// @tparam genType Floating-point or integer; scalar or vector types.\n  173  \t///\n  174  \t/// @see <a href=\"http://www.opengl.org/sdk/docs/manglsl/xhtml/min.xml\">GLSL min man page</a>\n  ...\n  179  \t/// Returns y if y < x; otherwise, it returns x.\n  180  \t///\n  181: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  182  \t/// @tparam T Floating-point or integer scalar types\n  183  \t/// @tparam Q Value from qualifier enum\n  ...\n  190  \t/// Returns y if y < x; otherwise, it returns x.\n  191  \t///\n  192: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  193  \t/// @tparam T Floating-point or integer scalar types\n  194  \t/// @tparam Q Value from qualifier enum\n  ...\n  201  \t/// Returns y if x < y; otherwise, it returns x.\n  202  \t///\n  203: \t/// @tparam genType Floating-point or integer; scalar or vector types.\n  204  \t///\n  205  \t/// @see <a href=\"http://www.opengl.org/sdk/docs/manglsl/xhtml/max.xml\">GLSL max man page</a>\n  ...\n  210  \t/// Returns y if x < y; otherwise, it returns x.\n  211  \t///\n  212: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  213  \t/// @tparam T Floating-point or integer scalar types\n  214  \t/// @tparam Q Value from qualifier enum\n  ...\n  221  \t/// Returns y if x < y; otherwise, it returns x.\n  222  \t///\n  223: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  224  \t/// @tparam T Floating-point or integer scalar types\n  225  \t/// @tparam Q Value from qualifier enum\n  ...\n  233  \t/// using the floating-point values minVal and maxVal.\n  234  \t///\n  235: \t/// @tparam genType Floating-point or integer; scalar or vector types.\n  236  \t///\n  237  \t/// @see <a href=\"http://www.opengl.org/sdk/docs/manglsl/xhtml/clamp.xml\">GLSL clamp man page</a>\n  ...\n  243  \t/// using the floating-point values minVal and maxVal.\n  244  \t///\n  245: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  246  \t/// @tparam T Floating-point or integer scalar types\n  247  \t/// @tparam Q Value from qualifier enum\n  ...\n  255  \t/// using the floating-point values minVal and maxVal.\n  256  \t///\n  257: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  258  \t/// @tparam T Floating-point or integer scalar types\n  259  \t/// @tparam Q Value from qualifier enum\n  ...\n  264  \tGLM_FUNC_DECL GLM_CONSTEXPR vec<L, T, Q> clamp(vec<L, T, Q> const& x, vec<L, T, Q> const& minVal, vec<L, T, Q> const& maxVal);\n  265  \n  266: \t/// If genTypeU is a floating scalar or vector:\n  267  \t/// Returns x * (1.0 - a) + y * a, i.e., the linear blend of\n  268  \t/// x and y using the floating-point value a.\n  269  \t/// The value for a is not restricted to the range [0, 1].\n  270  \t///\n  271: \t/// If genTypeU is a boolean scalar or vector:\n  272: \t/// Selects which vector each returned component comes\n  273  \t/// from. For a component of 'a' that is false, the\n  274  \t/// corresponding component of 'x' is returned. For a\n  ...\n  279  \t/// provides different functionality than\n  280  \t/// genType mix(genType x, genType y, genType(a))\n  281: \t/// where a is a Boolean vector.\n  282  \t///\n  283  \t/// @see <a href=\"http://www.opengl.org/sdk/docs/manglsl/xhtml/mix.xml\">GLSL mix man page</a>\n  ...\n  288  \t/// @param[in]  a Interpolant.\n  289  \t///\n  290: \t/// @tparam\tgenTypeT Floating point scalar or vector.\n  291: \t/// @tparam genTypeU Floating point or boolean scalar or vector. It can't be a vector if it is the length of genTypeT.\n  292  \t///\n  293  \t/// @code\n  ...\n  301  \t/// glm::vec4 h;\n  302  \t/// ...\n  303: \t/// glm::vec4 r = glm::mix(g, h, a); // Interpolate with a floating-point scalar two vectors.\n  304  \t/// glm::vec4 s = glm::mix(g, h, b); // Returns g or h;\n  305  \t/// glm::dvec3 t = glm::mix(e, f, a); // Types of the third parameter is not required to match with the first and the second.\n  306: \t/// glm::vec4 u = glm::mix(g, h, r); // Interpolations can be perform per component with a vector for the last parameter.\n  307  \t/// @endcode\n  308  \ttemplate<typename genTypeT, typename genTypeU>\n  ...\n  324  \t/// Returns 0.0 if x < edge, otherwise it returns 1.0.\n  325  \t///\n  326: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  327  \t/// @tparam T Floating-point scalar types\n  328  \t/// @tparam Q Value from qualifier enum\n  ...\n  335  \t/// Returns 0.0 if x < edge, otherwise it returns 1.0.\n  336  \t///\n  337: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  338  \t/// @tparam T Floating-point scalar types\n  339  \t/// @tparam Q Value from qualifier enum\n  ...\n  354  \t/// Results are undefined if edge0 >= edge1.\n  355  \t///\n  356: \t/// @tparam genType Floating-point scalar or vector types.\n  357  \t///\n  358  \t/// @see <a href=\"http://www.opengl.org/sdk/docs/manglsl/xhtml/smoothstep.xml\">GLSL smoothstep man page</a>\n  ...\n  375  \t/// /!\\ When using compiler fast math, this function may fail.\n  376  \t///\n  377: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  378  \t/// @tparam T Floating-point scalar types\n  379  \t/// @tparam Q Value from qualifier enum\n  ...\n  390  \t/// representations.\n  391  \t///\n  392: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  393  \t/// @tparam T Floating-point scalar types\n  394  \t/// @tparam Q Value from qualifier enum\n  ...\n  411  \t/// value's bit-level representation is preserved.\n  412  \t///\n  413: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  414  \t/// @tparam Q Value from qualifier enum\n  415  \t///\n  ...\n  431  \t/// value's bit-level representation is preserved.\n  432  \t///\n  433: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  434  \t/// @tparam Q Value from qualifier enum\n  435  \t///\n  ...\n  455  \t/// the bit-level representation is preserved.\n  456  \t///\n  457: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  458  \t/// @tparam Q Value from qualifier enum\n  459  \t///\n  ...\n  479  \t/// the bit-level representation is preserved.\n  480  \t///\n  481: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  482  \t/// @tparam Q Value from qualifier enum\n  483  \t///\n  ...\n  489  \t/// Computes and returns a * b + c.\n  490  \t///\n  491: \t/// @tparam genType Floating-point scalar or vector types.\n  492  \t///\n  493  \t/// @see <a href=\"http://www.opengl.org/sdk/docs/manglsl/xhtml/fma.xml\">GLSL fma man page</a>\n  ...\n  506  \t/// infinity or is not a number, the results are undefined.\n  507  \t///\n  508: \t/// @tparam genType Floating-point scalar or vector types.\n  509  \t///\n  510  \t/// @see <a href=\"http://www.opengl.org/sdk/docs/manglsl/xhtml/frexp.xml\">GLSL frexp man page</a>\n  ...\n  520  \t/// floating-point type, the result is undefined.\n  521  \t///\n  522: \t/// @tparam genType Floating-point scalar or vector types.\n  523  \t///\n  524  \t/// @see <a href=\"http://www.opengl.org/sdk/docs/manglsl/xhtml/ldexp.xml\">GLSL ldexp man page</a>;\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/_features.hpp:\n  105  \n  106  // #define GLM_CXX11_DELEGATING_CONSTRUCTORS\n  107: // Delegating constructors\tN1986\tGCC 4.7\n  108  // http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1986.pdf\n  109  \n  110  //\n  111: // Inheriting constructors\tN2540\tGCC 4.8\n  112  // http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2540.htm\n  113  \n  ...\n  180  \n  181  // #define GLM_CXX11_NOEXCEPT\n  182: // Allowing move constructors to throw [noexcept]\tN3050\tGCC 4.6 (core language only)\n  183  // http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3050.html\n  184  \n  ...\n  292  #\tendif\n  293  \n  294: #\tif(__has_feature(cxx_delegating_constructors))\n  295  #\t\tdefine GLM_CXX11_DELEGATING_CONSTRUCTORS\n  296  #\tendif\n  ...\n  312  #\tendif\n  313  \n  314: #\tif(__has_feature(cxx_inheriting_constructors))\n  315  #\t\tdefine GLM_CXX11_INHERITING_CONSTRUCTORS\n  316  #\tendif\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/_swizzle.hpp:\n   12  \t\tGLM_FUNC_QUALIFIER T const& elem(size_t i) const{ return (reinterpret_cast<const T*>(_buffer))[i]; }\n   13  \n   14: \t\t// Use an opaque buffer to *ensure* the compiler doesn't call a constructor.\n   15  \t\t// The size 1 buffer is assumed to aligned to the actual members so that the\n   16  \t\t// elem()\n   ..\n   46  \n   47  \t\tT\t\t\t= type of scalar values (e.g. float, double)\n   48: \t\tN\t\t\t= number of components in the vector (e.g. 3)\n   49  \t\tE0...3\t\t= what index the n-th element of this swizzle refers to in the unswizzled vec\n   50  \n   ..\n  219  \n  220  //\n  221: // Macro for wrapping a function taking two vector arguments (e.g. dot()).\n  222  //\n  223  #define GLM_SWIZZLE_FUNCTION_2_ARGS(RETURN_TYPE,FUNCTION)                                                       \\\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/_vectorize.hpp:\n    5  {\n    6  \ttemplate<template<length_t L, typename T, qualifier Q> class vec, length_t L, typename R, typename T, qualifier Q>\n    7: \tstruct functor1{};\n    8  \n    9  \ttemplate<template<length_t L, typename T, qualifier Q> class vec, typename R, typename T, qualifier Q>\n   10: \tstruct functor1<vec, 1, R, T, Q>\n   11  \t{\n   12  \t\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR static vec<1, R, Q> call(R (*Func) (T x), vec<1, T, Q> const& v)\n   ..\n   17  \n   18  \ttemplate<template<length_t L, typename T, qualifier Q> class vec, typename R, typename T, qualifier Q>\n   19: \tstruct functor1<vec, 2, R, T, Q>\n   20  \t{\n   21  \t\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR static vec<2, R, Q> call(R (*Func) (T x), vec<2, T, Q> const& v)\n   ..\n   26  \n   27  \ttemplate<template<length_t L, typename T, qualifier Q> class vec, typename R, typename T, qualifier Q>\n   28: \tstruct functor1<vec, 3, R, T, Q>\n   29  \t{\n   30  \t\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR static vec<3, R, Q> call(R (*Func) (T x), vec<3, T, Q> const& v)\n   ..\n   35  \n   36  \ttemplate<template<length_t L, typename T, qualifier Q> class vec, typename R, typename T, qualifier Q>\n   37: \tstruct functor1<vec, 4, R, T, Q>\n   38  \t{\n   39  \t\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR static vec<4, R, Q> call(R (*Func) (T x), vec<4, T, Q> const& v)\n   ..\n   44  \n   45  \ttemplate<template<length_t L, typename T, qualifier Q> class vec, length_t L, typename T, qualifier Q>\n   46: \tstruct functor2{};\n   47  \n   48  \ttemplate<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>\n   49: \tstruct functor2<vec, 1, T, Q>\n   50  \t{\n   51  \t\tGLM_FUNC_QUALIFIER static vec<1, T, Q> call(T (*Func) (T x, T y), vec<1, T, Q> const& a, vec<1, T, Q> const& b)\n   ..\n   56  \n   57  \ttemplate<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>\n   58: \tstruct functor2<vec, 2, T, Q>\n   59  \t{\n   60  \t\tGLM_FUNC_QUALIFIER static vec<2, T, Q> call(T (*Func) (T x, T y), vec<2, T, Q> const& a, vec<2, T, Q> const& b)\n   ..\n   65  \n   66  \ttemplate<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>\n   67: \tstruct functor2<vec, 3, T, Q>\n   68  \t{\n   69  \t\tGLM_FUNC_QUALIFIER static vec<3, T, Q> call(T (*Func) (T x, T y), vec<3, T, Q> const& a, vec<3, T, Q> const& b)\n   ..\n   74  \n   75  \ttemplate<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>\n   76: \tstruct functor2<vec, 4, T, Q>\n   77  \t{\n   78  \t\tGLM_FUNC_QUALIFIER static vec<4, T, Q> call(T (*Func) (T x, T y), vec<4, T, Q> const& a, vec<4, T, Q> const& b)\n   ..\n   83  \n   84  \ttemplate<template<length_t L, typename T, qualifier Q> class vec, length_t L, typename T, qualifier Q>\n   85: \tstruct functor2_vec_sca{};\n   86  \n   87  \ttemplate<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>\n   88: \tstruct functor2_vec_sca<vec, 1, T, Q>\n   89  \t{\n   90  \t\tGLM_FUNC_QUALIFIER static vec<1, T, Q> call(T (*Func) (T x, T y), vec<1, T, Q> const& a, T b)\n   ..\n   95  \n   96  \ttemplate<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>\n   97: \tstruct functor2_vec_sca<vec, 2, T, Q>\n   98  \t{\n   99  \t\tGLM_FUNC_QUALIFIER static vec<2, T, Q> call(T (*Func) (T x, T y), vec<2, T, Q> const& a, T b)\n  ...\n  104  \n  105  \ttemplate<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>\n  106: \tstruct functor2_vec_sca<vec, 3, T, Q>\n  107  \t{\n  108  \t\tGLM_FUNC_QUALIFIER static vec<3, T, Q> call(T (*Func) (T x, T y), vec<3, T, Q> const& a, T b)\n  ...\n  113  \n  114  \ttemplate<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>\n  115: \tstruct functor2_vec_sca<vec, 4, T, Q>\n  116  \t{\n  117  \t\tGLM_FUNC_QUALIFIER static vec<4, T, Q> call(T (*Func) (T x, T y), vec<4, T, Q> const& a, T b)\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/compute_common.hpp:\n   18  \t\t\tGLM_STATIC_ASSERT(\n   19  \t\t\t\tstd::numeric_limits<genFIType>::is_iec559 || std::numeric_limits<genFIType>::is_signed,\n   20: \t\t\t\t\"'abs' only accept floating-point and integer scalar or vector inputs\");\n   21  \n   22  \t\t\treturn x >= genFIType(0) ? x : -x;\n   ..\n   43  \t\t\tGLM_STATIC_ASSERT(\n   44  \t\t\t\t(!std::numeric_limits<genFIType>::is_signed && std::numeric_limits<genFIType>::is_integer),\n   45: \t\t\t\t\"'abs' only accept floating-point and integer scalar or vector inputs\");\n   46  \t\t\treturn x;\n   47  \t\t}\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/func_common.inl:\n    2  /// @file glm/detail/func_common.inl\n    3  \n    4: #include \"../vector_relational.hpp\"\n    5  #include \"compute_common.hpp\"\n    6  #include \"type_vec2.hpp\"\n    7  #include \"type_vec3.hpp\"\n    8  #include \"type_vec4.hpp\"\n    9: #include \"_vectorize.hpp\"\n   10  #include <limits>\n   11  \n   ..\n   69  {\n   70  \ttemplate<length_t L, typename T, qualifier Q, bool Aligned>\n   71: \tstruct compute_abs_vector\n   72  \t{\n   73  \t\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR static vec<L, T, Q> call(vec<L, T, Q> const& x)\n   74  \t\t{\n   75: \t\t\treturn detail::functor1<vec, L, T, T, Q>::call(abs, x);\n   76  \t\t}\n   77  \t};\n   78  \n   79  \ttemplate<length_t L, typename T, typename U, qualifier Q, bool Aligned>\n   80: \tstruct compute_mix_vector\n   81  \t{\n   82  \t\tGLM_FUNC_QUALIFIER static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, U, Q> const& a)\n   ..\n   89  \n   90  \ttemplate<length_t L, typename T, qualifier Q, bool Aligned>\n   91: \tstruct compute_mix_vector<L, T, bool, Q, Aligned>\n   92  \t{\n   93  \t\tGLM_FUNC_QUALIFIER static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, bool, Q> const& a)\n   ..\n  168  \t\tGLM_FUNC_QUALIFIER static vec<L, T, Q> call(vec<L, T, Q> const& x)\n  169  \t\t{\n  170: \t\t\treturn detail::functor1<vec, L, T, T, Q>::call(std::floor, x);\n  171  \t\t}\n  172  \t};\n  ...\n  177  \t\tGLM_FUNC_QUALIFIER static vec<L, T, Q> call(vec<L, T, Q> const& x)\n  178  \t\t{\n  179: \t\t\treturn detail::functor1<vec, L, T, T, Q>::call(std::ceil, x);\n  180  \t\t}\n  181  \t};\n  ...\n  195  \t\tGLM_FUNC_QUALIFIER static vec<L, T, Q> call(vec<L, T, Q> const& x)\n  196  \t\t{\n  197: \t\t\treturn detail::functor1<vec, L, T, T, Q>::call(trunc, x);\n  198  \t\t}\n  199  \t};\n  ...\n  204  \t\tGLM_FUNC_QUALIFIER static vec<L, T, Q> call(vec<L, T, Q> const& x)\n  205  \t\t{\n  206: \t\t\treturn detail::functor1<vec, L, T, T, Q>::call(round, x);\n  207  \t\t}\n  208  \t};\n  ...\n  219  \n  220  \ttemplate<length_t L, typename T, qualifier Q, bool Aligned>\n  221: \tstruct compute_min_vector\n  222  \t{\n  223  \t\tGLM_FUNC_QUALIFIER static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y)\n  224  \t\t{\n  225: \t\t\treturn detail::functor2<vec, L, T, Q>::call(min, x, y);\n  226  \t\t}\n  227  \t};\n  228  \n  229  \ttemplate<length_t L, typename T, qualifier Q, bool Aligned>\n  230: \tstruct compute_max_vector\n  231  \t{\n  232  \t\tGLM_FUNC_QUALIFIER static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y)\n  233  \t\t{\n  234: \t\t\treturn detail::functor2<vec, L, T, Q>::call(max, x, y);\n  235  \t\t}\n  236  \t};\n  237  \n  238  \ttemplate<length_t L, typename T, qualifier Q, bool Aligned>\n  239: \tstruct compute_clamp_vector\n  240  \t{\n  241  \t\tGLM_FUNC_QUALIFIER static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& minVal, vec<L, T, Q> const& maxVal)\n  ...\n  246  \n  247  \ttemplate<length_t L, typename T, qualifier Q, bool Aligned>\n  248: \tstruct compute_step_vector\n  249  \t{\n  250  \t\tGLM_FUNC_QUALIFIER static vec<L, T, Q> call(vec<L, T, Q> const& edge, vec<L, T, Q> const& x)\n  ...\n  255  \n  256  \ttemplate<length_t L, typename T, qualifier Q, bool Aligned>\n  257: \tstruct compute_smoothstep_vector\n  258  \t{\n  259  \t\tGLM_FUNC_QUALIFIER static vec<L, T, Q> call(vec<L, T, Q> const& edge0, vec<L, T, Q> const& edge1, vec<L, T, Q> const& x)\n  ...\n  275  \tGLM_FUNC_QUALIFIER GLM_CONSTEXPR vec<L, T, Q> abs(vec<L, T, Q> const& x)\n  276  \t{\n  277: \t\treturn detail::compute_abs_vector<L, T, Q, detail::is_aligned<Q>::value>::call(x);\n  278  \t}\n  279  \n  ...\n  370  \t{\n  371  \t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'roundEven' only accept floating-point inputs\");\n  372: \t\treturn detail::functor1<vec, L, T, T, Q>::call(roundEven, x);\n  373  \t}\n  374  \n  ...\n  476  \t{\n  477  \t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer, \"'min' only accept floating-point or integer inputs\");\n  478: \t\treturn detail::compute_min_vector<L, T, Q, detail::is_aligned<Q>::value>::call(a, vec<L, T, Q>(b));\n  479  \t}\n  480  \n  ...\n  482  \tGLM_FUNC_QUALIFIER GLM_CONSTEXPR vec<L, T, Q> min(vec<L, T, Q> const& a, vec<L, T, Q> const& b)\n  483  \t{\n  484: \t\treturn detail::compute_min_vector<L, T, Q, detail::is_aligned<Q>::value>::call(a, b);\n  485  \t}\n  486  \n  ...\n  490  \t{\n  491  \t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer, \"'max' only accept floating-point or integer inputs\");\n  492: \t\treturn detail::compute_max_vector<L, T, Q, detail::is_aligned<Q>::value>::call(a, vec<L, T, Q>(b));\n  493  \t}\n  494  \n  ...\n  496  \tGLM_FUNC_QUALIFIER GLM_CONSTEXPR vec<L, T, Q> max(vec<L, T, Q> const& a, vec<L, T, Q> const& b)\n  497  \t{\n  498: \t\treturn detail::compute_max_vector<L, T, Q, detail::is_aligned<Q>::value>::call(a, b);\n  499  \t}\n  500  \n  ...\n  511  \t{\n  512  \t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer, \"'clamp' only accept floating-point or integer inputs\");\n  513: \t\treturn detail::compute_clamp_vector<L, T, Q, detail::is_aligned<Q>::value>::call(x, vec<L, T, Q>(minVal), vec<L, T, Q>(maxVal));\n  514  \t}\n  515  \n  ...\n  518  \t{\n  519  \t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer, \"'clamp' only accept floating-point or integer inputs\");\n  520: \t\treturn detail::compute_clamp_vector<L, T, Q, detail::is_aligned<Q>::value>::call(x, minVal, maxVal);\n  521  \t}\n  522  \n  ...\n  536  \tGLM_FUNC_QUALIFIER vec<L, T, Q> mix(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, U, Q> const& a)\n  537  \t{\n  538: \t\treturn detail::compute_mix_vector<L, T, U, Q, detail::is_aligned<Q>::value>::call(x, y, a);\n  539  \t}\n  540  \n  ...\n  549  \tGLM_FUNC_QUALIFIER vec<L, T, Q> step(T edge, vec<L, T, Q> const& x)\n  550  \t{\n  551: \t\treturn detail::compute_step_vector<L, T, Q, detail::is_aligned<Q>::value>::call(vec<L, T, Q>(edge), x);\n  552  \t}\n  553  \n  ...\n  555  \tGLM_FUNC_QUALIFIER vec<L, T, Q> step(vec<L, T, Q> const& edge, vec<L, T, Q> const& x)\n  556  \t{\n  557: \t\treturn detail::compute_step_vector<L, T, Q, detail::is_aligned<Q>::value>::call(edge, x);\n  558  \t}\n  559  \n  ...\n  571  \tGLM_FUNC_QUALIFIER vec<L, T, Q> smoothstep(T edge0, T edge1, vec<L, T, Q> const& x)\n  572  \t{\n  573: \t\treturn detail::compute_smoothstep_vector<L, T, Q, detail::is_aligned<Q>::value>::call(vec<L, T, Q>(edge0), vec<L, T, Q>(edge1), x);\n  574  \t}\n  575  \n  ...\n  577  \tGLM_FUNC_QUALIFIER vec<L, T, Q> smoothstep(vec<L, T, Q> const& edge0, vec<L, T, Q> const& edge1, vec<L, T, Q> const& x)\n  578  \t{\n  579: \t\treturn detail::compute_smoothstep_vector<L, T, Q, detail::is_aligned<Q>::value>::call(edge0, edge1, x);\n  580  \t}\n  581  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/func_common_simd.inl:\n   12  {\n   13  \ttemplate<qualifier Q>\n   14: \tstruct compute_abs_vector<4, float, Q, true>\n   15  \t{\n   16  \t\tGLM_FUNC_QUALIFIER static vec<4, float, Q> call(vec<4, float, Q> const& v)\n   ..\n   23  \n   24  \ttemplate<qualifier Q>\n   25: \tstruct compute_abs_vector<4, int, Q, true>\n   26  \t{\n   27  \t\tGLM_FUNC_QUALIFIER static vec<4, int, Q> call(vec<4, int, Q> const& v)\n   ..\n   89  \n   90  \ttemplate<qualifier Q>\n   91: \tstruct compute_min_vector<4, float, Q, true>\n   92  \t{\n   93  \t\tGLM_FUNC_QUALIFIER static vec<4, float, Q> call(vec<4, float, Q> const& v1, vec<4, float, Q> const& v2)\n   ..\n  100  \n  101  \ttemplate<qualifier Q>\n  102: \tstruct compute_min_vector<4, int, Q, true>\n  103  \t{\n  104  \t\tGLM_FUNC_QUALIFIER static vec<4, int, Q> call(vec<4, int, Q> const& v1, vec<4, int, Q> const& v2)\n  ...\n  111  \n  112  \ttemplate<qualifier Q>\n  113: \tstruct compute_min_vector<4, uint, Q, true>\n  114  \t{\n  115  \t\tGLM_FUNC_QUALIFIER static vec<4, uint, Q> call(vec<4, uint, Q> const& v1, vec<4, uint, Q> const& v2)\n  ...\n  122  \n  123  \ttemplate<qualifier Q>\n  124: \tstruct compute_max_vector<4, float, Q, true>\n  125  \t{\n  126  \t\tGLM_FUNC_QUALIFIER static vec<4, float, Q> call(vec<4, float, Q> const& v1, vec<4, float, Q> const& v2)\n  ...\n  133  \n  134  \ttemplate<qualifier Q>\n  135: \tstruct compute_max_vector<4, int, Q, true>\n  136  \t{\n  137  \t\tGLM_FUNC_QUALIFIER static vec<4, int, Q> call(vec<4, int, Q> const& v1, vec<4, int, Q> const& v2)\n  ...\n  144  \n  145  \ttemplate<qualifier Q>\n  146: \tstruct compute_max_vector<4, uint, Q, true>\n  147  \t{\n  148  \t\tGLM_FUNC_QUALIFIER static vec<4, uint, Q> call(vec<4, uint, Q> const& v1, vec<4, uint, Q> const& v2)\n  ...\n  155  \n  156  \ttemplate<qualifier Q>\n  157: \tstruct compute_clamp_vector<4, float, Q, true>\n  158  \t{\n  159  \t\tGLM_FUNC_QUALIFIER static vec<4, float, Q> call(vec<4, float, Q> const& x, vec<4, float, Q> const& minVal, vec<4, float, Q> const& maxVal)\n  ...\n  166  \n  167  \ttemplate<qualifier Q>\n  168: \tstruct compute_clamp_vector<4, int, Q, true>\n  169  \t{\n  170  \t\tGLM_FUNC_QUALIFIER static vec<4, int, Q> call(vec<4, int, Q> const& x, vec<4, int, Q> const& minVal, vec<4, int, Q> const& maxVal)\n  ...\n  177  \n  178  \ttemplate<qualifier Q>\n  179: \tstruct compute_clamp_vector<4, uint, Q, true>\n  180  \t{\n  181  \t\tGLM_FUNC_QUALIFIER static vec<4, uint, Q> call(vec<4, uint, Q> const& x, vec<4, uint, Q> const& minVal, vec<4, uint, Q> const& maxVal)\n  ...\n  188  \n  189  \ttemplate<qualifier Q>\n  190: \tstruct compute_mix_vector<4, float, bool, Q, true>\n  191  \t{\n  192  \t\tGLM_FUNC_QUALIFIER static vec<4, float, Q> call(vec<4, float, Q> const& x, vec<4, float, Q> const& y, vec<4, bool, Q> const& a)\n  ...\n  206  /* FIXME\n  207  \ttemplate<qualifier Q>\n  208: \tstruct compute_step_vector<float, Q, tvec4>\n  209  \t{\n  210  \t\tGLM_FUNC_QUALIFIER static vec<4, float, Q> call(vec<4, float, Q> const& edge, vec<4, float, Q> const& x)\n  ...\n  217  */\n  218  \ttemplate<qualifier Q>\n  219: \tstruct compute_smoothstep_vector<4, float, Q, true>\n  220  \t{\n  221  \t\tGLM_FUNC_QUALIFIER static vec<4, float, Q> call(vec<4, float, Q> const& edge0, vec<4, float, Q> const& edge1, vec<4, float, Q> const& x)\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/func_exponential.inl:\n    2  /// @file glm/detail/func_exponential.inl\n    3  \n    4: #include \"../vector_relational.hpp\"\n    5: #include \"_vectorize.hpp\"\n    6  #include <limits>\n    7  #include <cmath>\n    .\n   28  \t\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'log2' only accept floating-point inputs. Include <glm/gtc/integer.hpp> for integer inputs.\");\n   29  \n   30: \t\t\treturn detail::functor1<vec, L, T, T, Q>::call(log2, v);\n   31  \t\t}\n   32  \t};\n   ..\n   37  \t\tGLM_FUNC_QUALIFIER static vec<L, T, Q> call(vec<L, T, Q> const& x)\n   38  \t\t{\n   39: \t\t\treturn detail::functor1<vec, L, T, T, Q>::call(std::sqrt, x);\n   40  \t\t}\n   41  \t};\n   ..\n   72  \tGLM_FUNC_QUALIFIER vec<L, T, Q> pow(vec<L, T, Q> const& base, vec<L, T, Q> const& exponent)\n   73  \t{\n   74: \t\treturn detail::functor2<vec, L, T, Q>::call(pow, base, exponent);\n   75  \t}\n   76  \n   ..\n   80  \tGLM_FUNC_QUALIFIER vec<L, T, Q> exp(vec<L, T, Q> const& x)\n   81  \t{\n   82: \t\treturn detail::functor1<vec, L, T, T, Q>::call(exp, x);\n   83  \t}\n   84  \n   ..\n   88  \tGLM_FUNC_QUALIFIER vec<L, T, Q> log(vec<L, T, Q> const& x)\n   89  \t{\n   90: \t\treturn detail::functor1<vec, L, T, T, Q>::call(log, x);\n   91  \t}\n   92  \n   ..\n  107  \tGLM_FUNC_QUALIFIER vec<L, T, Q> exp2(vec<L, T, Q> const& x)\n  108  \t{\n  109: \t\treturn detail::functor1<vec, L, T, T, Q>::call(exp2, x);\n  110  \t}\n  111  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/func_integer.inl:\n    1  /// @ref core\n    2  \n    3: #include \"_vectorize.hpp\"\n    4  #if(GLM_ARCH & GLM_ARCH_X86 && GLM_COMPILER & GLM_COMPILER_VC)\n    5  #\tinclude <intrin.h>\n    .\n  148  \t\t\tGLM_FUNC_QUALIFIER static vec<L, int, Q> call(vec<L, T, Q> const& x)\n  149  \t\t\t{\n  150: \t\t\t\treturn detail::functor1<vec, L, int, T, Q>::call(compute_findMSB_32, x);\n  151  \t\t\t}\n  152  \t\t};\n  ...\n  166  \t\t\tGLM_FUNC_QUALIFIER static vec<L, int, Q> call(vec<L, T, Q> const& x)\n  167  \t\t\t{\n  168: \t\t\t\treturn detail::functor1<vec, L, int, T, Q>::call(compute_findMSB_64, x);\n  169  \t\t\t}\n  170  \t\t};\n  ...\n  336  \t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_integer, \"'findLSB' only accept integer values\");\n  337  \n  338: \t\treturn detail::functor1<vec, L, int, T, Q>::call(findLSB, x);\n  339  \t}\n  340  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/func_matrix.inl:\n  225  \t\tGLM_FUNC_QUALIFIER static T call(mat<4, 4, T, Q> const& m)\n  226  \t\t{\n  227: \t\t\tT SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];\n  228: \t\t\tT SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];\n  229: \t\t\tT SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];\n  230: \t\t\tT SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];\n  231: \t\t\tT SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];\n  232: \t\t\tT SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];\n  233  \n  234  \t\t\tvec<4, T, Q> DetCof(\n  235: \t\t\t\t+ (m[1][1] * SubFactor00 - m[1][2] * SubFactor01 + m[1][3] * SubFactor02),\n  236: \t\t\t\t- (m[1][0] * SubFactor00 - m[1][2] * SubFactor03 + m[1][3] * SubFactor04),\n  237: \t\t\t\t+ (m[1][0] * SubFactor01 - m[1][1] * SubFactor03 + m[1][3] * SubFactor05),\n  238: \t\t\t\t- (m[1][0] * SubFactor02 - m[1][1] * SubFactor04 + m[1][2] * SubFactor05));\n  239  \n  240  \t\t\treturn\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/func_trigonometric.inl:\n    1: #include \"_vectorize.hpp\"\n    2  #include <cmath>\n    3  #include <limits>\n    .\n   17  \tGLM_FUNC_QUALIFIER GLM_CONSTEXPR vec<L, T, Q> radians(vec<L, T, Q> const& v)\n   18  \t{\n   19: \t\treturn detail::functor1<vec, L, T, T, Q>::call(radians, v);\n   20  \t}\n   21  \n   ..\n   32  \tGLM_FUNC_QUALIFIER GLM_CONSTEXPR vec<L, T, Q> degrees(vec<L, T, Q> const& v)\n   33  \t{\n   34: \t\treturn detail::functor1<vec, L, T, T, Q>::call(degrees, v);\n   35  \t}\n   36  \n   ..\n   41  \tGLM_FUNC_QUALIFIER vec<L, T, Q> sin(vec<L, T, Q> const& v)\n   42  \t{\n   43: \t\treturn detail::functor1<vec, L, T, T, Q>::call(sin, v);\n   44  \t}\n   45  \n   ..\n   50  \tGLM_FUNC_QUALIFIER vec<L, T, Q> cos(vec<L, T, Q> const& v)\n   51  \t{\n   52: \t\treturn detail::functor1<vec, L, T, T, Q>::call(cos, v);\n   53  \t}\n   54  \n   ..\n   59  \tGLM_FUNC_QUALIFIER vec<L, T, Q> tan(vec<L, T, Q> const& v)\n   60  \t{\n   61: \t\treturn detail::functor1<vec, L, T, T, Q>::call(tan, v);\n   62  \t}\n   63  \n   ..\n   68  \tGLM_FUNC_QUALIFIER vec<L, T, Q> asin(vec<L, T, Q> const& v)\n   69  \t{\n   70: \t\treturn detail::functor1<vec, L, T, T, Q>::call(asin, v);\n   71  \t}\n   72  \n   ..\n   77  \tGLM_FUNC_QUALIFIER vec<L, T, Q> acos(vec<L, T, Q> const& v)\n   78  \t{\n   79: \t\treturn detail::functor1<vec, L, T, T, Q>::call(acos, v);\n   80  \t}\n   81  \n   ..\n   92  \tGLM_FUNC_QUALIFIER vec<L, T, Q> atan(vec<L, T, Q> const& a, vec<L, T, Q> const& b)\n   93  \t{\n   94: \t\treturn detail::functor2<vec, L, T, Q>::call(::std::atan2, a, b);\n   95  \t}\n   96  \n   ..\n  100  \tGLM_FUNC_QUALIFIER vec<L, T, Q> atan(vec<L, T, Q> const& v)\n  101  \t{\n  102: \t\treturn detail::functor1<vec, L, T, T, Q>::call(atan, v);\n  103  \t}\n  104  \n  ...\n  109  \tGLM_FUNC_QUALIFIER vec<L, T, Q> sinh(vec<L, T, Q> const& v)\n  110  \t{\n  111: \t\treturn detail::functor1<vec, L, T, T, Q>::call(sinh, v);\n  112  \t}\n  113  \n  ...\n  118  \tGLM_FUNC_QUALIFIER vec<L, T, Q> cosh(vec<L, T, Q> const& v)\n  119  \t{\n  120: \t\treturn detail::functor1<vec, L, T, T, Q>::call(cosh, v);\n  121  \t}\n  122  \n  ...\n  127  \tGLM_FUNC_QUALIFIER vec<L, T, Q> tanh(vec<L, T, Q> const& v)\n  128  \t{\n  129: \t\treturn detail::functor1<vec, L, T, T, Q>::call(tanh, v);\n  130  \t}\n  131  \n  ...\n  146  \tGLM_FUNC_QUALIFIER vec<L, T, Q> asinh(vec<L, T, Q> const& v)\n  147  \t{\n  148: \t\treturn detail::functor1<vec, L, T, T, Q>::call(asinh, v);\n  149  \t}\n  150  \n  ...\n  167  \tGLM_FUNC_QUALIFIER vec<L, T, Q> acosh(vec<L, T, Q> const& v)\n  168  \t{\n  169: \t\treturn detail::functor1<vec, L, T, T, Q>::call(acosh, v);\n  170  \t}\n  171  \n  ...\n  188  \tGLM_FUNC_QUALIFIER vec<L, T, Q> atanh(vec<L, T, Q> const& v)\n  189  \t{\n  190: \t\treturn detail::functor1<vec, L, T, T, Q>::call(atanh, v);\n  191  \t}\n  192  }//namespace glm\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/func_vector_relational.inl:\n   84  \n   85  #if GLM_CONFIG_SIMD == GLM_ENABLE\n   86: #\tinclude \"func_vector_relational_simd.inl\"\n   87  #endif\n   88  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/setup.hpp:\n  709  \n  710  ///////////////////////////////////////////////////////////////////////////////////\n  711: // Only use x, y, z, w as vector type components\n  712  \n  713  #ifdef GLM_FORCE_XYZW_ONLY\n  ...\n  988  \t// Report whether only xyzw component are used\n  989  #\tif defined GLM_FORCE_XYZW_ONLY\n  990: #\t\tpragma message(\"GLM: GLM_FORCE_XYZW_ONLY is defined. Only x, y, z and w component are available in vector type. This define disables swizzle operators and SIMD instruction sets\")\n  991  #\tendif\n  992  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/type_mat2x2.hpp:\n   31  \t\tGLM_FUNC_DECL GLM_CONSTEXPR col_type const& operator[](length_type i) const;\n   32  \n   33: \t\t// -- Constructors --\n   34  \n   35  \t\tGLM_FUNC_DECL GLM_CONSTEXPR mat() GLM_DEFAULT;\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/type_mat2x2.inl:\n    3  namespace glm\n    4  {\n    5: \t// -- Constructors --\n    6  \n    7  #\tif GLM_CONFIG_DEFAULTED_FUNCTIONS == GLM_DISABLE\n    .\n   72  \t}\n   73  \n   74: \t// -- Conversion constructors --\n   75  \n   76  \ttemplate<typename T, qualifier Q>\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/type_mat2x3.hpp:\n   32  \t\tGLM_FUNC_DECL GLM_CONSTEXPR col_type const& operator[](length_type i) const;\n   33  \n   34: \t\t// -- Constructors --\n   35  \n   36  \t\tGLM_FUNC_DECL GLM_CONSTEXPR mat() GLM_DEFAULT;\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/type_mat2x3.inl:\n    1  namespace glm\n    2  {\n    3: \t// -- Constructors --\n    4  \n    5  #\tif GLM_CONFIG_DEFAULTED_FUNCTIONS == GLM_DISABLE\n    .\n   70  \t}\n   71  \n   72: \t// -- Conversion constructors --\n   73  \n   74  \ttemplate<typename T, qualifier Q>\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/type_mat2x4.hpp:\n   32  \t\tGLM_FUNC_DECL GLM_CONSTEXPR col_type const& operator[](length_type i) const;\n   33  \n   34: \t\t// -- Constructors --\n   35  \n   36  \t\tGLM_FUNC_DECL GLM_CONSTEXPR mat() GLM_DEFAULT;\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/type_mat2x4.inl:\n    1  namespace glm\n    2  {\n    3: \t// -- Constructors --\n    4  \n    5  #\tif GLM_CONFIG_DEFAULTED_FUNCTIONS == GLM_DISABLE\n    .\n   70  \t}\n   71  \n   72: \t// -- Conversion constructors --\n   73  \n   74  \ttemplate<typename T, qualifier Q>\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/type_mat3x2.hpp:\n   32  \t\tGLM_FUNC_DECL GLM_CONSTEXPR col_type const& operator[](length_type i) const;\n   33  \n   34: \t\t// -- Constructors --\n   35  \n   36  \t\tGLM_FUNC_DECL GLM_CONSTEXPR mat() GLM_DEFAULT;\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/type_mat3x2.inl:\n    1  namespace glm\n    2  {\n    3: \t// -- Constructors --\n    4  \n    5  #\tif GLM_CONFIG_DEFAULTED_FUNCTIONS == GLM_DISABLE\n    .\n   76  \t}\n   77  \n   78: \t// -- Conversion constructors --\n   79  \n   80  \ttemplate<typename T, qualifier Q>\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/type_mat3x3.hpp:\n   31  \t\tGLM_FUNC_DECL GLM_CONSTEXPR col_type const& operator[](length_type i) const;\n   32  \n   33: \t\t// -- Constructors --\n   34  \n   35  \t\tGLM_FUNC_DECL GLM_CONSTEXPR mat() GLM_DEFAULT;\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/type_mat3x3.inl:\n    3  namespace glm\n    4  {\n    5: \t// -- Constructors --\n    6  \n    7  #\tif GLM_CONFIG_DEFAULTED_FUNCTIONS == GLM_DISABLE\n    .\n   78  \t}\n   79  \n   80: \t// -- Conversion constructors --\n   81  \n   82  \ttemplate<typename T, qualifier Q>\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/type_mat3x4.hpp:\n   32  \t\tGLM_FUNC_DECL GLM_CONSTEXPR col_type const& operator[](length_type i) const;\n   33  \n   34: \t\t// -- Constructors --\n   35  \n   36  \t\tGLM_FUNC_DECL GLM_CONSTEXPR mat() GLM_DEFAULT;\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/type_mat3x4.inl:\n    1  namespace glm\n    2  {\n    3: \t// -- Constructors --\n    4  \n    5  #\tif GLM_CONFIG_DEFAULTED_FUNCTIONS == GLM_DISABLE\n    .\n   79  \t}\n   80  \n   81: \t// -- Conversion constructors --\n   82  \n   83  \ttemplate<typename T, qualifier Q>\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/type_mat4x2.hpp:\n   32  \t\tGLM_FUNC_DECL GLM_CONSTEXPR col_type const& operator[](length_type i) const;\n   33  \n   34: \t\t// -- Constructors --\n   35  \n   36  \t\tGLM_FUNC_DECL GLM_CONSTEXPR mat() GLM_DEFAULT;\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/type_mat4x2.inl:\n    1  namespace glm\n    2  {\n    3: \t// -- Constructors --\n    4  \n    5  #\tif GLM_CONFIG_DEFAULTED_FUNCTIONS == GLM_DISABLE\n    .\n   82  \t}\n   83  \n   84: \t// -- Conversion constructors --\n   85  \n   86  \ttemplate<typename T, qualifier Q>\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/type_mat4x3.hpp:\n   32  \t\tGLM_FUNC_DECL GLM_CONSTEXPR col_type const& operator[](length_type i) const;\n   33  \n   34: \t\t// -- Constructors --\n   35  \n   36  \t\tGLM_FUNC_DECL GLM_CONSTEXPR mat() GLM_DEFAULT;\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/type_mat4x3.inl:\n    1  namespace glm\n    2  {\n    3: \t// -- Constructors --\n    4  \n    5  #\tif GLM_CONFIG_DEFAULTED_FUNCTIONS == GLM_DISABLE\n    .\n   82  \t}\n   83  \n   84: \t// -- Conversion constructors --\n   85  \n   86  \ttemplate<typename T, qualifier Q>\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/type_mat4x4.hpp:\n   31  \t\tGLM_FUNC_DECL GLM_CONSTEXPR col_type const& operator[](length_type i) const;\n   32  \n   33: \t\t// -- Constructors --\n   34  \n   35  \t\tGLM_FUNC_DECL GLM_CONSTEXPR mat() GLM_DEFAULT;\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/type_mat4x4.inl:\n    3  namespace glm\n    4  {\n    5: \t// -- Constructors --\n    6  \n    7  #\tif GLM_CONFIG_DEFAULTED_FUNCTIONS == GLM_DISABLE\n    .\n  122  #\t\tendif\n  123  \t{\n  124: \t\tGLM_STATIC_ASSERT(std::numeric_limits<X1>::is_iec559 || std::numeric_limits<X1>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 1st parameter type invalid.\");\n  125: \t\tGLM_STATIC_ASSERT(std::numeric_limits<Y1>::is_iec559 || std::numeric_limits<Y1>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 2nd parameter type invalid.\");\n  126: \t\tGLM_STATIC_ASSERT(std::numeric_limits<Z1>::is_iec559 || std::numeric_limits<Z1>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 3rd parameter type invalid.\");\n  127: \t\tGLM_STATIC_ASSERT(std::numeric_limits<W1>::is_iec559 || std::numeric_limits<W1>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 4th parameter type invalid.\");\n  128  \n  129: \t\tGLM_STATIC_ASSERT(std::numeric_limits<X2>::is_iec559 || std::numeric_limits<X2>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 5th parameter type invalid.\");\n  130: \t\tGLM_STATIC_ASSERT(std::numeric_limits<Y2>::is_iec559 || std::numeric_limits<Y2>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 6th parameter type invalid.\");\n  131: \t\tGLM_STATIC_ASSERT(std::numeric_limits<Z2>::is_iec559 || std::numeric_limits<Z2>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 7th parameter type invalid.\");\n  132: \t\tGLM_STATIC_ASSERT(std::numeric_limits<W2>::is_iec559 || std::numeric_limits<W2>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 8th parameter type invalid.\");\n  133  \n  134: \t\tGLM_STATIC_ASSERT(std::numeric_limits<X3>::is_iec559 || std::numeric_limits<X3>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 9th parameter type invalid.\");\n  135: \t\tGLM_STATIC_ASSERT(std::numeric_limits<Y3>::is_iec559 || std::numeric_limits<Y3>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 10th parameter type invalid.\");\n  136: \t\tGLM_STATIC_ASSERT(std::numeric_limits<Z3>::is_iec559 || std::numeric_limits<Z3>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 11th parameter type invalid.\");\n  137: \t\tGLM_STATIC_ASSERT(std::numeric_limits<W3>::is_iec559 || std::numeric_limits<W3>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 12th parameter type invalid.\");\n  138  \n  139: \t\tGLM_STATIC_ASSERT(std::numeric_limits<X4>::is_iec559 || std::numeric_limits<X4>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 13th parameter type invalid.\");\n  140: \t\tGLM_STATIC_ASSERT(std::numeric_limits<Y4>::is_iec559 || std::numeric_limits<Y4>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 14th parameter type invalid.\");\n  141: \t\tGLM_STATIC_ASSERT(std::numeric_limits<Z4>::is_iec559 || std::numeric_limits<Z4>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 15th parameter type invalid.\");\n  142: \t\tGLM_STATIC_ASSERT(std::numeric_limits<W4>::is_iec559 || std::numeric_limits<W4>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 16th parameter type invalid.\");\n  143  \n  144  #\t\tif !GLM_HAS_INITIALIZER_LISTS\n  ...\n  157  #\t\tendif\n  158  \t{\n  159: \t\tGLM_STATIC_ASSERT(std::numeric_limits<V1>::is_iec559 || std::numeric_limits<V1>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 1st parameter type invalid.\");\n  160: \t\tGLM_STATIC_ASSERT(std::numeric_limits<V2>::is_iec559 || std::numeric_limits<V2>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 2nd parameter type invalid.\");\n  161: \t\tGLM_STATIC_ASSERT(std::numeric_limits<V3>::is_iec559 || std::numeric_limits<V3>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 3rd parameter type invalid.\");\n  162: \t\tGLM_STATIC_ASSERT(std::numeric_limits<V4>::is_iec559 || std::numeric_limits<V4>::is_integer || GLM_CONFIG_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 4th parameter type invalid.\");\n  163  \n  164  #\t\tif !GLM_HAS_INITIALIZER_LISTS\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/type_quat.hpp:\n   19  #include \"../detail/type_vec3.hpp\"\n   20  #include \"../detail/type_vec4.hpp\"\n   21: #include \"../ext/vector_relational.hpp\"\n   22  #include \"../ext/quaternion_relational.hpp\"\n   23  #include \"../gtc/constants.hpp\"\n   ..\n   59  \t\tGLM_FUNC_DECL GLM_CONSTEXPR T const& operator[](length_type i) const;\n   60  \n   61: \t\t// -- Implicit basic constructors --\n   62  \n   63  \t\tGLM_FUNC_DECL GLM_CONSTEXPR qua() GLM_DEFAULT;\n   ..\n   66  \t\tGLM_FUNC_DECL GLM_CONSTEXPR qua(qua<T, P> const& q);\n   67  \n   68: \t\t// -- Explicit basic constructors --\n   69  \n   70  \t\tGLM_FUNC_DECL GLM_CONSTEXPR qua(T s, vec<3, T, Q> const& v);\n   71  \t\tGLM_FUNC_DECL GLM_CONSTEXPR qua(T w, T x, T y, T z);\n   72  \n   73: \t\t// -- Conversion constructors --\n   74  \n   75  \t\ttemplate<typename U, qualifier P>\n   ..\n   87  \t\t/// @param v A second normalized axis\n   88  \t\t/// @see gtc_quaternion\n   89: \t\t/// @see http://lolengine.net/blog/2013/09/18/beautiful-maths-quaternion-from-vectors\n   90  \t\tGLM_FUNC_DECL qua(vec<3, T, Q> const& u, vec<3, T, Q> const& v);\n   91  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/type_quat.inl:\n   85  \t}\n   86  \n   87: \t// -- Implicit basic constructors --\n   88  \n   89  #\tif GLM_CONFIG_DEFAULTED_FUNCTIONS == GLM_DISABLE\n   ..\n  107  \t{}\n  108  \n  109: \t// -- Explicit basic constructors --\n  110  \n  111  \ttemplate<typename T, qualifier Q>\n  ...\n  119  \t{}\n  120  \n  121: \t// -- Conversion constructors --\n  122  \n  123  \ttemplate<typename T, qualifier Q>\n  ...\n  314  \tGLM_FUNC_QUALIFIER vec<3, T, Q> operator*(qua<T, Q> const& q, vec<3, T, Q> const& v)\n  315  \t{\n  316: \t\tvec<3, T, Q> const QuatVector(q.x, q.y, q.z);\n  317: \t\tvec<3, T, Q> const uv(glm::cross(QuatVector, v));\n  318: \t\tvec<3, T, Q> const uuv(glm::cross(QuatVector, uv));\n  319  \n  320  \t\treturn v + ((uv * q.w) + uuv) * static_cast<T>(2);\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/type_vec1.hpp:\n   60  \t\t// -- Component accesses --\n   61  \n   62: \t\t/// Return the count of components of the vector\n   63  \t\ttypedef length_t length_type;\n   64  \t\tGLM_FUNC_DECL static GLM_CONSTEXPR length_type length(){return 1;}\n   ..\n   67  \t\tGLM_FUNC_DECL GLM_CONSTEXPR T const& operator[](length_type i) const;\n   68  \n   69: \t\t// -- Implicit basic constructors --\n   70  \n   71  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec() GLM_DEFAULT;\n   ..\n   74  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec(vec<1, T, P> const& v);\n   75  \n   76: \t\t// -- Explicit basic constructors --\n   77  \n   78  \t\tGLM_FUNC_DECL GLM_CONSTEXPR explicit vec(T scalar);\n   79  \n   80: \t\t// -- Conversion vector constructors --\n   81  \n   82: \t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n   83  \t\ttemplate<typename U, qualifier P>\n   84  \t\tGLM_FUNC_DECL GLM_CONSTEXPR GLM_EXPLICIT vec(vec<2, U, P> const& v);\n   85: \t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n   86  \t\ttemplate<typename U, qualifier P>\n   87  \t\tGLM_FUNC_DECL GLM_CONSTEXPR GLM_EXPLICIT vec(vec<3, U, P> const& v);\n   88: \t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n   89  \t\ttemplate<typename U, qualifier P>\n   90  \t\tGLM_FUNC_DECL GLM_CONSTEXPR GLM_EXPLICIT vec(vec<4, U, P> const& v);\n   91  \n   92: \t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n   93  \t\ttemplate<typename U, qualifier P>\n   94  \t\tGLM_FUNC_DECL GLM_CONSTEXPR GLM_EXPLICIT vec(vec<1, U, P> const& v);\n   95  \n   96: \t\t// -- Swizzle constructors --\n   97  /*\n   98  #\t\tif GLM_CONFIG_SWIZZLE == GLM_SWIZZLE_OPERATOR\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/type_vec1.inl:\n    1  /// @ref core\n    2  \n    3: #include \"./compute_vector_relational.hpp\"\n    4  \n    5  namespace glm\n    6  {\n    7: \t// -- Implicit basic constructors --\n    8  \n    9  #\tif GLM_CONFIG_DEFAULTED_FUNCTIONS == GLM_DISABLE\n   ..\n   27  \t{}\n   28  \n   29: \t// -- Explicit basic constructors --\n   30  \n   31  \ttemplate<typename T, qualifier Q>\n   ..\n   34  \t{}\n   35  \n   36: \t// -- Conversion vector constructors --\n   37  \n   38  \ttemplate<typename T, qualifier Q>\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/type_vec2.hpp:\n   59  \t\t// -- Component accesses --\n   60  \n   61: \t\t/// Return the count of components of the vector\n   62  \t\ttypedef length_t length_type;\n   63  \t\tGLM_FUNC_DECL static GLM_CONSTEXPR length_type length(){return 2;}\n   ..\n   66  \t\tGLM_FUNC_DECL GLM_CONSTEXPR T const& operator[](length_type i) const;\n   67  \n   68: \t\t// -- Implicit basic constructors --\n   69  \n   70  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec() GLM_DEFAULT;\n   ..\n   73  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec(vec<2, T, P> const& v);\n   74  \n   75: \t\t// -- Explicit basic constructors --\n   76  \n   77  \t\tGLM_FUNC_DECL GLM_CONSTEXPR explicit vec(T scalar);\n   78  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec(T x, T y);\n   79  \n   80: \t\t// -- Conversion constructors --\n   81  \n   82  \t\ttemplate<typename U, qualifier P>\n   83  \t\tGLM_FUNC_DECL GLM_CONSTEXPR explicit vec(vec<1, U, P> const& v);\n   84  \n   85: \t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n   86  \t\ttemplate<typename A, typename B>\n   87  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec(A x, B y);\n   ..\n   93  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec(vec<1, A, Q> const& x, vec<1, B, Q> const& y);\n   94  \n   95: \t\t// -- Conversion vector constructors --\n   96  \n   97: \t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n   98  \t\ttemplate<typename U, qualifier P>\n   99  \t\tGLM_FUNC_DECL GLM_CONSTEXPR GLM_EXPLICIT vec(vec<3, U, P> const& v);\n  100: \t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n  101  \t\ttemplate<typename U, qualifier P>\n  102  \t\tGLM_FUNC_DECL GLM_CONSTEXPR GLM_EXPLICIT vec(vec<4, U, P> const& v);\n  103  \n  104: \t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n  105  \t\ttemplate<typename U, qualifier P>\n  106  \t\tGLM_FUNC_DECL GLM_CONSTEXPR GLM_EXPLICIT vec(vec<2, U, P> const& v);\n  107  \n  108: \t\t// -- Swizzle constructors --\n  109  #\t\tif GLM_CONFIG_SWIZZLE == GLM_SWIZZLE_OPERATOR\n  110  \t\t\ttemplate<int E0, int E1>\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/type_vec2.inl:\n    1  /// @ref core\n    2  \n    3: #include \"./compute_vector_relational.hpp\"\n    4  \n    5  namespace glm\n    6  {\n    7: \t// -- Implicit basic constructors --\n    8  \n    9  #\tif GLM_CONFIG_DEFAULTED_FUNCTIONS == GLM_DISABLE\n   ..\n   27  \t{}\n   28  \n   29: \t// -- Explicit basic constructors --\n   30  \n   31  \ttemplate<typename T, qualifier Q>\n   ..\n   39  \t{}\n   40  \n   41: \t// -- Conversion scalar constructors --\n   42  \n   43  \ttemplate<typename T, qualifier Q>\n   ..\n   76  \t{}\n   77  \n   78: \t// -- Conversion vector constructors --\n   79  \n   80  \ttemplate<typename T, qualifier Q>\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/type_vec3.hpp:\n   60  \t\t// -- Component accesses --\n   61  \n   62: \t\t/// Return the count of components of the vector\n   63  \t\ttypedef length_t length_type;\n   64  \t\tGLM_FUNC_DECL static GLM_CONSTEXPR length_type length(){return 3;}\n   ..\n   67  \t\tGLM_FUNC_DECL GLM_CONSTEXPR T const& operator[](length_type i) const;\n   68  \n   69: \t\t// -- Implicit basic constructors --\n   70  \n   71  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec() GLM_DEFAULT;\n   ..\n   74  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec(vec<3, T, P> const& v);\n   75  \n   76: \t\t// -- Explicit basic constructors --\n   77  \n   78  \t\tGLM_FUNC_DECL GLM_CONSTEXPR explicit vec(T scalar);\n   79  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec(T a, T b, T c);\n   80  \n   81: \t\t// -- Conversion scalar constructors --\n   82  \n   83  \t\ttemplate<typename U, qualifier P>\n   84  \t\tGLM_FUNC_DECL GLM_CONSTEXPR explicit vec(vec<1, U, P> const& v);\n   85  \n   86: \t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n   87  \t\ttemplate<typename X, typename Y, typename Z>\n   88  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec(X x, Y y, Z z);\n   ..\n  102  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z);\n  103  \n  104: \t\t// -- Conversion vector constructors --\n  105  \n  106: \t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n  107  \t\ttemplate<typename A, typename B, qualifier P>\n  108  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec(vec<2, A, P> const& _xy, B _z);\n  109: \t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n  110  \t\ttemplate<typename A, typename B, qualifier P>\n  111  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z);\n  112: \t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n  113  \t\ttemplate<typename A, typename B, qualifier P>\n  114  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec(A _x, vec<2, B, P> const& _yz);\n  115: \t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n  116  \t\ttemplate<typename A, typename B, qualifier P>\n  117  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz);\n  118: \t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n  119  \t\ttemplate<typename U, qualifier P>\n  120  \t\tGLM_FUNC_DECL GLM_CONSTEXPR GLM_EXPLICIT vec(vec<4, U, P> const& v);\n  121  \n  122: \t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n  123  \t\ttemplate<typename U, qualifier P>\n  124  \t\tGLM_FUNC_DECL GLM_CONSTEXPR GLM_EXPLICIT vec(vec<3, U, P> const& v);\n  125  \n  126: \t\t// -- Swizzle constructors --\n  127  #\t\tif GLM_CONFIG_SWIZZLE == GLM_SWIZZLE_OPERATOR\n  128  \t\t\ttemplate<int E0, int E1, int E2>\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/type_vec3.inl:\n    1  /// @ref core\n    2  \n    3: #include \"compute_vector_relational.hpp\"\n    4  \n    5  namespace glm\n    6  {\n    7: \t// -- Implicit basic constructors --\n    8  \n    9  #\tif GLM_CONFIG_DEFAULTED_FUNCTIONS == GLM_DISABLE\n   ..\n   27  \t{}\n   28  \n   29: \t// -- Explicit basic constructors --\n   30  \n   31  \ttemplate<typename T, qualifier Q>\n   ..\n   39  \t{}\n   40  \n   41: \t// -- Conversion scalar constructors --\n   42  \n   43  \ttemplate<typename T, qualifier Q>\n   ..\n  113  \t{}\n  114  \n  115: \t// -- Conversion vector constructors --\n  116  \n  117  \ttemplate<typename T, qualifier Q>\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/type_vec4.hpp:\n   61  \t\t// -- Component accesses --\n   62  \n   63: \t\t/// Return the count of components of the vector\n   64  \t\ttypedef length_t length_type;\n   65  \t\tGLM_FUNC_DECL static GLM_CONSTEXPR length_type length(){return 4;}\n   ..\n   68  \t\tGLM_FUNC_DECL GLM_CONSTEXPR T const& operator[](length_type i) const;\n   69  \n   70: \t\t// -- Implicit basic constructors --\n   71  \n   72  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec() GLM_DEFAULT;\n   ..\n   75  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec(vec<4, T, P> const& v);\n   76  \n   77: \t\t// -- Explicit basic constructors --\n   78  \n   79  \t\tGLM_FUNC_DECL GLM_CONSTEXPR explicit vec(T scalar);\n   80  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec(T x, T y, T z, T w);\n   81  \n   82: \t\t// -- Conversion scalar constructors --\n   83  \n   84  \t\ttemplate<typename U, qualifier P>\n   85  \t\tGLM_FUNC_DECL GLM_CONSTEXPR explicit vec(vec<1, U, P> const& v);\n   86  \n   87: \t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n   88  \t\ttemplate<typename X, typename Y, typename Z, typename W>\n   89  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec(X _x, Y _y, Z _z, W _w);\n   ..\n  117  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _Y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w);\n  118  \n  119: \t\t// -- Conversion vector constructors --\n  120  \n  121: \t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n  122  \t\ttemplate<typename A, typename B, typename C, qualifier P>\n  123  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec(vec<2, A, P> const& _xy, B _z, C _w);\n  124: \t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n  125  \t\ttemplate<typename A, typename B, typename C, qualifier P>\n  126  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z, C _w);\n  127: \t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n  128  \t\ttemplate<typename A, typename B, typename C, qualifier P>\n  129  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec(vec<2, A, P> const& _xy, B _z, vec<1, C, P> const& _w);\n  130: \t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n  131  \t\ttemplate<typename A, typename B, typename C, qualifier P>\n  132  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z, vec<1, C, P> const& _w);\n  133: \t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n  134  \t\ttemplate<typename A, typename B, typename C, qualifier P>\n  135  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec(A _x, vec<2, B, P> const& _yz, C _w);\n  136: \t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n  137  \t\ttemplate<typename A, typename B, typename C, qualifier P>\n  138  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz, C _w);\n  139: \t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n  140  \t\ttemplate<typename A, typename B, typename C, qualifier P>\n  141  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec(A _x, vec<2, B, P> const& _yz, vec<1, C, P> const& _w);\n  142: \t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n  143  \t\ttemplate<typename A, typename B, typename C, qualifier P>\n  144  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz, vec<1, C, P> const& _w);\n  145: \t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n  146  \t\ttemplate<typename A, typename B, typename C, qualifier P>\n  147  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec(A _x, B _y, vec<2, C, P> const& _zw);\n  148: \t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n  149  \t\ttemplate<typename A, typename B, typename C, qualifier P>\n  150  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec(vec<1, A, P> const& _x, B _y, vec<2, C, P> const& _zw);\n  151: \t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n  152  \t\ttemplate<typename A, typename B, typename C, qualifier P>\n  153  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec(A _x, vec<1, B, P> const& _y, vec<2, C, P> const& _zw);\n  154: \t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n  155  \t\ttemplate<typename A, typename B, typename C, qualifier P>\n  156  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec(vec<1, A, P> const& _x, vec<1, B, P> const& _y, vec<2, C, P> const& _zw);\n  157: \t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n  158  \t\ttemplate<typename A, typename B, qualifier P>\n  159  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec(vec<3, A, P> const& _xyz, B _w);\n  160: \t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n  161  \t\ttemplate<typename A, typename B, qualifier P>\n  162  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec(vec<3, A, P> const& _xyz, vec<1, B, P> const& _w);\n  163: \t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n  164  \t\ttemplate<typename A, typename B, qualifier P>\n  165  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec(A _x, vec<3, B, P> const& _yzw);\n  166: \t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n  167  \t\ttemplate<typename A, typename B, qualifier P>\n  168  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec(vec<1, A, P> const& _x, vec<3, B, P> const& _yzw);\n  169: \t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n  170  \t\ttemplate<typename A, typename B, qualifier P>\n  171  \t\tGLM_FUNC_DECL GLM_CONSTEXPR vec(vec<2, A, P> const& _xy, vec<2, B, P> const& _zw);\n  172  \n  173: \t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n  174  \t\ttemplate<typename U, qualifier P>\n  175  \t\tGLM_FUNC_DECL GLM_CONSTEXPR GLM_EXPLICIT vec(vec<4, U, P> const& v);\n  176  \n  177: \t\t// -- Swizzle constructors --\n  178  #\t\tif GLM_CONFIG_SWIZZLE == GLM_SWIZZLE_OPERATOR\n  179  \t\t\ttemplate<int E0, int E1, int E2, int E3>\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/type_vec4.inl:\n    1  /// @ref core\n    2  \n    3: #include \"compute_vector_relational.hpp\"\n    4  \n    5  namespace glm{\n    .\n  128  }//namespace detail\n  129  \n  130: \t// -- Implicit basic constructors --\n  131  \n  132  #\tif GLM_CONFIG_DEFAULTED_FUNCTIONS == GLM_DISABLE\n  ...\n  150  \t{}\n  151  \n  152: \t// -- Explicit basic constructors --\n  153  \n  154  \ttemplate<typename T, qualifier Q>\n  ...\n  162  \t{}\n  163  \n  164: \t// -- Conversion scalar constructors --\n  165  \n  166  \ttemplate<typename T, qualifier Q>\n  ...\n  308  \t{}\n  309  \n  310: \t// -- Conversion vector constructors --\n  311  \n  312  \ttemplate<typename T, qualifier Q>\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/exponential.hpp:\n   39  \t///\n   40  \t/// @param v exp function is defined for input values of v defined in the range (inf-, inf+) in the limit of the type qualifier.\n   41: \t/// @tparam L An integer between 1 and 4 included that qualify the dimension of the vector.\n   42  \t/// @tparam T Floating-point scalar types.\n   43  \t///\n   ..\n   52  \t///\n   53  \t/// @param v log function is defined for input values of v defined in the range (0, inf+) in the limit of the type qualifier.\n   54: \t/// @tparam L An integer between 1 and 4 included that qualify the dimension of the vector.\n   55  \t/// @tparam T Floating-point scalar types.\n   56  \t///\n   ..\n   63  \t///\n   64  \t/// @param v exp2 function is defined for input values of v defined in the range (inf-, inf+) in the limit of the type qualifier.\n   65: \t/// @tparam L An integer between 1 and 4 included that qualify the dimension of the vector.\n   66  \t/// @tparam T Floating-point scalar types.\n   67  \t///\n   ..\n   75  \t///\n   76  \t/// @param v log2 function is defined for input values of v defined in the range (0, inf+) in the limit of the type qualifier.\n   77: \t/// @tparam L An integer between 1 and 4 included that qualify the dimension of the vector.\n   78  \t/// @tparam T Floating-point scalar types.\n   79  \t///\n   ..\n   86  \t///\n   87  \t/// @param v sqrt function is defined for input values of v defined in the range [0, inf+) in the limit of the type qualifier.\n   88: \t/// @tparam L An integer between 1 and 4 included that qualify the dimension of the vector.\n   89  \t/// @tparam T Floating-point scalar types.\n   90  \t///\n   ..\n   97  \t///\n   98  \t/// @param v inversesqrt function is defined for input values of v defined in the range [0, inf+) in the limit of the type qualifier.\n   99: \t/// @tparam L An integer between 1 and 4 included that qualify the dimension of the vector.\n  100  \t/// @tparam T Floating-point scalar types.\n  101  \t///\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext.hpp:\n   66  #include \"./ext/scalar_relational.hpp\"\n   67  \n   68: #include \"./ext/vector_bool1.hpp\"\n   69: #include \"./ext/vector_bool1_precision.hpp\"\n   70: #include \"./ext/vector_bool2.hpp\"\n   71: #include \"./ext/vector_bool2_precision.hpp\"\n   72: #include \"./ext/vector_bool3.hpp\"\n   73: #include \"./ext/vector_bool3_precision.hpp\"\n   74: #include \"./ext/vector_bool4.hpp\"\n   75: #include \"./ext/vector_bool4_precision.hpp\"\n   76  \n   77: #include \"./ext/vector_double1.hpp\"\n   78: #include \"./ext/vector_double1_precision.hpp\"\n   79: #include \"./ext/vector_double2.hpp\"\n   80: #include \"./ext/vector_double2_precision.hpp\"\n   81: #include \"./ext/vector_double3.hpp\"\n   82: #include \"./ext/vector_double3_precision.hpp\"\n   83: #include \"./ext/vector_double4.hpp\"\n   84: #include \"./ext/vector_double4_precision.hpp\"\n   85  \n   86: #include \"./ext/vector_float1.hpp\"\n   87: #include \"./ext/vector_float1_precision.hpp\"\n   88: #include \"./ext/vector_float2.hpp\"\n   89: #include \"./ext/vector_float2_precision.hpp\"\n   90: #include \"./ext/vector_float3.hpp\"\n   91: #include \"./ext/vector_float3_precision.hpp\"\n   92: #include \"./ext/vector_float4.hpp\"\n   93: #include \"./ext/vector_float4_precision.hpp\"\n   94  \n   95: #include \"./ext/vector_int1.hpp\"\n   96: #include \"./ext/vector_int1_precision.hpp\"\n   97: #include \"./ext/vector_int2.hpp\"\n   98: #include \"./ext/vector_int2_precision.hpp\"\n   99: #include \"./ext/vector_int3.hpp\"\n  100: #include \"./ext/vector_int3_precision.hpp\"\n  101: #include \"./ext/vector_int4.hpp\"\n  102: #include \"./ext/vector_int4_precision.hpp\"\n  103  \n  104: #include \"./ext/vector_relational.hpp\"\n  105  \n  106: #include \"./ext/vector_uint1.hpp\"\n  107: #include \"./ext/vector_uint1_precision.hpp\"\n  108: #include \"./ext/vector_uint2.hpp\"\n  109: #include \"./ext/vector_uint2_precision.hpp\"\n  110: #include \"./ext/vector_uint3.hpp\"\n  111: #include \"./ext/vector_uint3_precision.hpp\"\n  112: #include \"./ext/vector_uint4.hpp\"\n  113: #include \"./ext/vector_uint4_precision.hpp\"\n  114  \n  115  #include \"./gtc/bitfield.hpp\"\n  ...\n  175  #include \"./gtx/quaternion.hpp\"\n  176  #include \"./gtx/raw_data.hpp\"\n  177: #include \"./gtx/rotate_vector.hpp\"\n  178  #include \"./gtx/spline.hpp\"\n  179  #include \"./gtx/std_based_type.hpp\"\n  ...\n  184  #include \"./gtx/transform2.hpp\"\n  185  #include \"./gtx/vec_swizzle.hpp\"\n  186: #include \"./gtx/vector_angle.hpp\"\n  187: #include \"./gtx/vector_query.hpp\"\n  188  #include \"./gtx/wrap.hpp\"\n  189  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/matrix_relational.hpp:\n    9  /// Include <glm/ext/matrix_relational.hpp> to use the features of this extension.\n   10  ///\n   11: /// @see ext_vector_relational\n   12  /// @see ext_scalar_relational\n   13  /// @see ext_quaternion_relational\n   ..\n   28  \n   29  \t/// Perform a component-wise equal-to comparison of two matrices.\n   30: \t/// Return a boolean vector which components value is True if this expression is satisfied per column of the matrices.\n   31  \t///\n   32  \t/// @tparam C Integer between 1 and 4 included that qualify the number of columns of the matrix\n   ..\n   58  \n   59  \t/// Perform a component-wise not-equal-to comparison of two matrices.\n   60: \t/// Return a boolean vector which components value is True if this expression is satisfied per column of the matrices.\n   61  \t///\n   62  \t/// @tparam C Integer between 1 and 4 included that qualify the number of columns of the matrix\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/matrix_relational.inl:\n    1: /// @ref ext_vector_relational\n    2: /// @file glm/ext/vector_relational.inl\n    3  \n    4  // Dependency:\n    5: #include \"../ext/vector_relational.hpp\"\n    6  #include \"../common.hpp\"\n    7  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/matrix_transform.hpp:\n   39  \tGLM_FUNC_DECL GLM_CONSTEXPR genType identity();\n   40  \n   41: \t/// Builds a translation 4 * 4 matrix created from a vector of 3 components.\n   42  \t///\n   43  \t/// @param m Input matrix multiplied by this translation matrix.\n   44: \t/// @param v Coordinates of a translation vector.\n   45  \t///\n   46  \t/// @tparam T A floating-point scalar type\n   ..\n   65  \t\tmat<4, 4, T, Q> const& m, vec<3, T, Q> const& v);\n   66  \n   67: \t/// Builds a rotation 4 * 4 matrix created from an axis vector and an angle.\n   68  \t///\n   69  \t/// @param m Input matrix multiplied by this rotation matrix.\n   ..\n  100  \t/// @param eye Position of the camera\n  101  \t/// @param center Position where the camera is looking at\n  102: \t/// @param up Normalized up vector, how the camera is oriented. Typically (0, 0, 1)\n  103  \t///\n  104  \t/// @tparam T A floating-point scalar type\n  ...\n  114  \t/// @param eye Position of the camera\n  115  \t/// @param center Position where the camera is looking at\n  116: \t/// @param up Normalized up vector, how the camera is oriented. Typically (0, 0, 1)\n  117  \t///\n  118  \t/// @tparam T A floating-point scalar type\n  ...\n  128  \t/// @param eye Position of the camera\n  129  \t/// @param center Position where the camera is looking at\n  130: \t/// @param up Normalized up vector, how the camera is oriented. Typically (0, 0, 1)\n  131  \t///\n  132  \t/// @tparam T A floating-point scalar type\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/quaternion_common.hpp:\n   10  ///\n   11  /// @see ext_scalar_common\n   12: /// @see ext_vector_common\n   13  /// @see ext_quaternion_float\n   14  /// @see ext_quaternion_double\n   ..\n   44  \t/// @param x A quaternion\n   45  \t/// @param y A quaternion\n   46: \t/// @param a Interpolation factor. The interpolation is defined beyond the range [0, 1].\n   47  \t///\n   48  \t/// @tparam T A floating-point scalar type\n   ..\n   58  \t/// @param x A quaternion\n   59  \t/// @param y A quaternion\n   60: \t/// @param a Interpolation factor. The interpolation is defined in the range [0, 1].\n   61  \t///\n   62  \t/// @tparam T A floating-point scalar type\n   ..\n   70  \t/// @param x A quaternion\n   71  \t/// @param y A quaternion\n   72: \t/// @param a Interpolation factor. The interpolation is defined beyond the range [0, 1].\n   73  \t///\n   74  \t/// @tparam T A floating-point scalar type\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/quaternion_geometric.hpp:\n   18  #include \"../geometric.hpp\"\n   19  #include \"../exponential.hpp\"\n   20: #include \"../ext/vector_relational.hpp\"\n   21  \n   22  #if GLM_MESSAGES == GLM_ENABLE && !defined(GLM_EXT_INCLUDED)\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/quaternion_relational.hpp:\n    9  /// Include <glm/ext/quaternion_relational.hpp> to use the features of this extension.\n   10  ///\n   11: /// @see core_vector_relational\n   12: /// @see ext_vector_relational\n   13  /// @see ext_matrix_relational\n   14  /// @see ext_quaternion_float\n   ..\n   18  \n   19  // Dependency:\n   20: #include \"../vector_relational.hpp\"\n   21  \n   22  #if GLM_MESSAGES == GLM_ENABLE && !defined(GLM_EXT_INCLUDED)\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/quaternion_transform.hpp:\n   32  \t/// @{\n   33  \n   34: \t/// Rotates a quaternion from a vector of 3 components axis and an angle.\n   35  \t///\n   36  \t/// @param q Source orientation\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/quaternion_trigonometric.hpp:\n   22  #include \"../exponential.hpp\"\n   23  #include \"scalar_constants.hpp\"\n   24: #include \"vector_relational.hpp\"\n   25  #include <limits>\n   26  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/scalar_common.hpp:\n   10  ///\n   11  /// @see core_func_common\n   12: /// @see ext_vector_common\n   13  \n   14  #pragma once\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/scalar_relational.hpp:\n    9  /// Include <glm/ext/scalar_relational.hpp> to use the features of this extension.\n   10  ///\n   11: /// @see core_vector_relational\n   12: /// @see ext_vector_relational\n   13  /// @see ext_matrix_relational\n   14  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_bool1.hpp:\n    1: /// @ref ext_vector_bool1\n    2: /// @file glm/ext/vector_bool1.hpp\n    3  ///\n    4: /// @defgroup ext_vector_bool1 GLM_EXT_vector_bool1\n    5  /// @ingroup ext\n    6  ///\n    7: /// Exposes bvec1 vector type.\n    8  ///\n    9: /// Include <glm/ext/vector_bool1.hpp> to use the features of this extension.\n   10  ///\n   11: /// @see ext_vector_bool1_precision extension.\n   12  \n   13  #pragma once\n   ..\n   16  \n   17  #if GLM_MESSAGES == GLM_ENABLE && !defined(GLM_EXT_INCLUDED)\n   18: #\tpragma message(\"GLM: GLM_EXT_vector_bool1 extension included\")\n   19  #endif\n   20  \n   21  namespace glm\n   22  {\n   23: \t/// @addtogroup ext_vector_bool1\n   24  \t/// @{\n   25  \n   26: \t/// 1 components vector of boolean.\n   27  \ttypedef vec<1, bool, defaultp>\t\tbvec1;\n   28  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_bool1_precision.hpp:\n    1: /// @ref ext_vector_bool1_precision\n    2: /// @file glm/ext/vector_bool1_precision.hpp\n    3  ///\n    4: /// @defgroup ext_vector_bool1_precision GLM_EXT_vector_bool1_precision\n    5  /// @ingroup ext\n    6  ///\n    7  /// Exposes highp_bvec1, mediump_bvec1 and lowp_bvec1 types.\n    8  ///\n    9: /// Include <glm/ext/vector_bool1_precision.hpp> to use the features of this extension.\n   10  \n   11  #pragma once\n   ..\n   14  \n   15  #if GLM_MESSAGES == GLM_ENABLE && !defined(GLM_EXT_INCLUDED)\n   16: #\tpragma message(\"GLM: GLM_EXT_vector_bool1_precision extension included\")\n   17  #endif\n   18  \n   19  namespace glm\n   20  {\n   21: \t/// @addtogroup ext_vector_bool1_precision\n   22  \t/// @{\n   23  \n   24: \t/// 1 component vector of bool values.\n   25  \ttypedef vec<1, bool, highp>\t\t\thighp_bvec1;\n   26  \n   27: \t/// 1 component vector of bool values.\n   28  \ttypedef vec<1, bool, mediump>\t\tmediump_bvec1;\n   29  \n   30: \t/// 1 component vector of bool values.\n   31  \ttypedef vec<1, bool, lowp>\t\t\tlowp_bvec1;\n   32  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_bool2.hpp:\n    1  /// @ref core\n    2: /// @file glm/ext/vector_bool2.hpp\n    3  \n    4  #pragma once\n    .\n    7  namespace glm\n    8  {\n    9: \t/// @addtogroup core_vector\n   10  \t/// @{\n   11  \n   12: \t/// 2 components vector of boolean.\n   13  \t///\n   14: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   15  \ttypedef vec<2, bool, defaultp>\t\tbvec2;\n   16  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_bool2_precision.hpp:\n    1  /// @ref core\n    2: /// @file glm/ext/vector_bool2_precision.hpp\n    3  \n    4  #pragma once\n    .\n    7  namespace glm\n    8  {\n    9: \t/// @addtogroup core_vector_precision\n   10  \t/// @{\n   11  \n   12: \t/// 2 components vector of high qualifier bool numbers.\n   13  \t///\n   14: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   15  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   16  \ttypedef vec<2, bool, highp>\t\thighp_bvec2;\n   17  \n   18: \t/// 2 components vector of medium qualifier bool numbers.\n   19  \t///\n   20: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   21  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   22  \ttypedef vec<2, bool, mediump>\tmediump_bvec2;\n   23  \n   24: \t/// 2 components vector of low qualifier bool numbers.\n   25  \t///\n   26: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   27  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   28  \ttypedef vec<2, bool, lowp>\t\tlowp_bvec2;\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_bool3.hpp:\n    1  /// @ref core\n    2: /// @file glm/ext/vector_bool3.hpp\n    3  \n    4  #pragma once\n    .\n    7  namespace glm\n    8  {\n    9: \t/// @addtogroup core_vector\n   10  \t/// @{\n   11  \n   12: \t/// 3 components vector of boolean.\n   13  \t///\n   14: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   15  \ttypedef vec<3, bool, defaultp>\t\tbvec3;\n   16  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_bool3_precision.hpp:\n    1  /// @ref core\n    2: /// @file glm/ext/vector_bool3_precision.hpp\n    3  \n    4  #pragma once\n    .\n    7  namespace glm\n    8  {\n    9: \t/// @addtogroup core_vector_precision\n   10  \t/// @{\n   11  \n   12: \t/// 3 components vector of high qualifier bool numbers.\n   13  \t///\n   14: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   15  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   16  \ttypedef vec<3, bool, highp>\t\thighp_bvec3;\n   17  \n   18: \t/// 3 components vector of medium qualifier bool numbers.\n   19  \t///\n   20: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   21  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   22  \ttypedef vec<3, bool, mediump>\tmediump_bvec3;\n   23  \n   24: \t/// 3 components vector of low qualifier bool numbers.\n   25  \t///\n   26: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   27  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   28  \ttypedef vec<3, bool, lowp>\t\tlowp_bvec3;\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_bool4.hpp:\n    1  /// @ref core\n    2: /// @file glm/ext/vector_bool4.hpp\n    3  \n    4  #pragma once\n    .\n    7  namespace glm\n    8  {\n    9: \t/// @addtogroup core_vector\n   10  \t/// @{\n   11  \n   12: \t/// 4 components vector of boolean.\n   13  \t///\n   14: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   15  \ttypedef vec<4, bool, defaultp>\t\tbvec4;\n   16  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_bool4_precision.hpp:\n    1  /// @ref core\n    2: /// @file glm/ext/vector_bool4_precision.hpp\n    3  \n    4  #pragma once\n    .\n    7  namespace glm\n    8  {\n    9: \t/// @addtogroup core_vector_precision\n   10  \t/// @{\n   11  \n   12: \t/// 4 components vector of high qualifier bool numbers.\n   13  \t///\n   14: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   15  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   16  \ttypedef vec<4, bool, highp>\t\thighp_bvec4;\n   17  \n   18: \t/// 4 components vector of medium qualifier bool numbers.\n   19  \t///\n   20: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   21  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   22  \ttypedef vec<4, bool, mediump>\tmediump_bvec4;\n   23  \n   24: \t/// 4 components vector of low qualifier bool numbers.\n   25  \t///\n   26: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   27  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   28  \ttypedef vec<4, bool, lowp>\t\tlowp_bvec4;\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_common.hpp:\n    1: /// @ref ext_vector_common\n    2: /// @file glm/ext/vector_common.hpp\n    3  ///\n    4: /// @defgroup ext_vector_common GLM_EXT_vector_common\n    5  /// @ingroup ext\n    6  ///\n    7: /// Exposes min and max functions for 3 to 4 vector parameters.\n    8  ///\n    9: /// Include <glm/ext/vector_common.hpp> to use the features of this extension.\n   10  ///\n   11  /// @see core_common\n   ..\n   19  \n   20  #if GLM_MESSAGES == GLM_ENABLE && !defined(GLM_EXT_INCLUDED)\n   21: #\tpragma message(\"GLM: GLM_EXT_vector_common extension included\")\n   22  #endif\n   23  \n   24  namespace glm\n   25  {\n   26: \t/// @addtogroup ext_vector_common\n   27  \t/// @{\n   28  \n   29  \t/// Return the minimum component-wise values of 3 inputs\n   30  \t///\n   31: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n   32  \t/// @tparam T Floating-point or integer scalar types\n   33  \t/// @tparam Q Value from qualifier enum\n   ..\n   37  \t/// Return the minimum component-wise values of 4 inputs\n   38  \t///\n   39: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n   40  \t/// @tparam T Floating-point or integer scalar types\n   41  \t/// @tparam Q Value from qualifier enum\n   ..\n   45  \t/// Return the maximum component-wise values of 3 inputs\n   46  \t///\n   47: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n   48  \t/// @tparam T Floating-point or integer scalar types\n   49  \t/// @tparam Q Value from qualifier enum\n   ..\n   53  \t/// Return the maximum component-wise values of 4 inputs\n   54  \t///\n   55: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n   56  \t/// @tparam T Floating-point or integer scalar types\n   57  \t/// @tparam Q Value from qualifier enum\n   ..\n   61  \t/// Returns y if y < x; otherwise, it returns x. If one of the two arguments is NaN, the value of the other argument is returned.\n   62  \t///\n   63: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n   64  \t/// @tparam T Floating-point scalar types\n   65  \t/// @tparam Q Value from qualifier enum\n   ..\n   71  \t/// Returns y if y < x; otherwise, it returns x. If one of the two arguments is NaN, the value of the other argument is returned.\n   72  \t///\n   73: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n   74  \t/// @tparam T Floating-point scalar types\n   75  \t/// @tparam Q Value from qualifier enum\n   ..\n   81  \t/// Returns y if y < x; otherwise, it returns x. If one of the two arguments is NaN, the value of the other argument is returned.\n   82  \t///\n   83: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n   84  \t/// @tparam T Floating-point scalar types\n   85  \t/// @tparam Q Value from qualifier enum\n   ..\n   91  \t/// Returns y if y < x; otherwise, it returns x. If one of the two arguments is NaN, the value of the other argument is returned.\n   92  \t///\n   93: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n   94  \t/// @tparam T Floating-point scalar types\n   95  \t/// @tparam Q Value from qualifier enum\n   ..\n  101  \t/// Returns y if x < y; otherwise, it returns x. If one of the two arguments is NaN, the value of the other argument is returned.\n  102  \t///\n  103: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  104  \t/// @tparam T Floating-point scalar types\n  105  \t/// @tparam Q Value from qualifier enum\n  ...\n  111  \t/// Returns y if x < y; otherwise, it returns x. If one of the two arguments is NaN, the value of the other argument is returned.\n  112  \t///\n  113: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  114  \t/// @tparam T Floating-point scalar types\n  115  \t/// @tparam Q Value from qualifier enum\n  ...\n  121  \t/// Returns y if x < y; otherwise, it returns x. If one of the two arguments is NaN, the value of the other argument is returned.\n  122  \t///\n  123: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  124  \t/// @tparam T Floating-point scalar types\n  125  \t/// @tparam Q Value from qualifier enum\n  ...\n  131  \t/// Returns y if x < y; otherwise, it returns x. If one of the two arguments is NaN, the value of the other argument is returned.\n  132  \t///\n  133: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  134  \t/// @tparam T Floating-point scalar types\n  135  \t/// @tparam Q Value from qualifier enum\n  ...\n  142  }//namespace glm\n  143  \n  144: #include \"vector_common.inl\"\n  145  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_common.inl:\n    1: #include \"../detail/_vectorize.hpp\"\n    2  \n    3  namespace glm\n    .\n   35  \t{\n   36  \t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'fmin' only accept floating-point inputs\");\n   37: \t\treturn detail::functor2<vec, L, T, Q>::call(fmin, a, vec<L, T, Q>(b));\n   38  \t}\n   39  \n   ..\n   42  \t{\n   43  \t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'fmin' only accept floating-point inputs\");\n   44: \t\treturn detail::functor2<vec, L, T, Q>::call(fmin, a, b);\n   45  \t}\n   46  \n   ..\n   63  \t{\n   64  \t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'fmax' only accept floating-point inputs\");\n   65: \t\treturn detail::functor2<vec, L, T, Q>::call(fmax, a, vec<L, T, Q>(b));\n   66  \t}\n   67  \n   ..\n   70  \t{\n   71  \t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'fmax' only accept floating-point inputs\");\n   72: \t\treturn detail::functor2<vec, L, T, Q>::call(fmax, a, b);\n   73  \t}\n   74  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_double1.hpp:\n    1: /// @ref ext_vector_double1\n    2: /// @file glm/ext/vector_double1.hpp\n    3  ///\n    4: /// @defgroup ext_vector_double1 GLM_EXT_vector_double1\n    5  /// @ingroup ext\n    6  ///\n    7: /// Exposes double-precision floating point vector type with one component.\n    8  ///\n    9: /// Include <glm/ext/vector_double1.hpp> to use the features of this extension.\n   10  ///\n   11: /// @see ext_vector_double1_precision extension.\n   12: /// @see ext_vector_float1 extension.\n   13  \n   14  #pragma once\n   ..\n   17  \n   18  #if GLM_MESSAGES == GLM_ENABLE && !defined(GLM_EXT_INCLUDED)\n   19: #\tpragma message(\"GLM: GLM_EXT_vector_dvec1 extension included\")\n   20  #endif\n   21  \n   22  namespace glm\n   23  {\n   24: \t/// @addtogroup ext_vector_double1\n   25  \t/// @{\n   26  \n   27: \t/// 1 components vector of double-precision floating-point numbers.\n   28  \ttypedef vec<1, double, defaultp>\t\tdvec1;\n   29  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_double1_precision.hpp:\n    1: /// @ref ext_vector_double1_precision\n    2: /// @file glm/ext/vector_double1_precision.hpp\n    3  ///\n    4: /// @defgroup ext_vector_double1_precision GLM_EXT_vector_double1_precision\n    5  /// @ingroup ext\n    6  ///\n    7  /// Exposes highp_dvec1, mediump_dvec1 and lowp_dvec1 types.\n    8  ///\n    9: /// Include <glm/ext/vector_double1_precision.hpp> to use the features of this extension.\n   10  ///\n   11: /// @see ext_vector_double1\n   12  \n   13  #pragma once\n   ..\n   16  \n   17  #if GLM_MESSAGES == GLM_ENABLE && !defined(GLM_EXT_INCLUDED)\n   18: #\tpragma message(\"GLM: GLM_EXT_vector_double1_precision extension included\")\n   19  #endif\n   20  \n   21  namespace glm\n   22  {\n   23: \t/// @addtogroup ext_vector_double1_precision\n   24  \t/// @{\n   25  \n   26: \t/// 1 component vector of double-precision floating-point numbers using high precision arithmetic in term of ULPs.\n   27  \ttypedef vec<1, double, highp>\t\thighp_dvec1;\n   28  \n   29: \t/// 1 component vector of double-precision floating-point numbers using medium precision arithmetic in term of ULPs.\n   30  \ttypedef vec<1, double, mediump>\t\tmediump_dvec1;\n   31  \n   32: \t/// 1 component vector of double-precision floating-point numbers using low precision arithmetic in term of ULPs.\n   33  \ttypedef vec<1, double, lowp>\t\tlowp_dvec1;\n   34  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_double2.hpp:\n    1  /// @ref core\n    2: /// @file glm/ext/vector_double2.hpp\n    3  \n    4  #pragma once\n    .\n    7  namespace glm\n    8  {\n    9: \t/// @addtogroup core_vector\n   10  \t/// @{\n   11  \n   12: \t/// 2 components vector of double-precision floating-point numbers.\n   13  \t///\n   14: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   15  \ttypedef vec<2, double, defaultp>\t\tdvec2;\n   16  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_double2_precision.hpp:\n    1  /// @ref core\n    2: /// @file glm/ext/vector_double2_precision.hpp\n    3  \n    4  #pragma once\n    .\n    7  namespace glm\n    8  {\n    9: \t/// @addtogroup core_vector_precision\n   10  \t/// @{\n   11  \n   12: \t/// 2 components vector of high double-qualifier floating-point numbers.\n   13  \t///\n   14: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   15  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   16  \ttypedef vec<2, double, highp>\t\thighp_dvec2;\n   17  \n   18: \t/// 2 components vector of medium double-qualifier floating-point numbers.\n   19  \t///\n   20: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   21  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   22  \ttypedef vec<2, double, mediump>\t\tmediump_dvec2;\n   23  \n   24: \t/// 2 components vector of low double-qualifier floating-point numbers.\n   25  \t///\n   26: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   27  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   28  \ttypedef vec<2, double, lowp>\t\tlowp_dvec2;\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_double3.hpp:\n    1  /// @ref core\n    2: /// @file glm/ext/vector_double3.hpp\n    3  \n    4  #pragma once\n    .\n    7  namespace glm\n    8  {\n    9: \t/// @addtogroup core_vector\n   10  \t/// @{\n   11  \n   12: \t/// 3 components vector of double-precision floating-point numbers.\n   13  \t///\n   14: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   15  \ttypedef vec<3, double, defaultp>\t\tdvec3;\n   16  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_double3_precision.hpp:\n    1  /// @ref core\n    2: /// @file glm/ext/vector_double3_precision.hpp\n    3  \n    4  #pragma once\n    .\n    7  namespace glm\n    8  {\n    9: \t/// @addtogroup core_vector_precision\n   10  \t/// @{\n   11  \n   12: \t/// 3 components vector of high double-qualifier floating-point numbers.\n   13  \t/// There is no guarantee on the actual qualifier.\n   14  \t///\n   15: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   16  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   17  \ttypedef vec<3, double, highp>\t\thighp_dvec3;\n   18  \n   19: \t/// 3 components vector of medium double-qualifier floating-point numbers.\n   20  \t/// There is no guarantee on the actual qualifier.\n   21  \t///\n   22: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   23  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   24  \ttypedef vec<3, double, mediump>\t\tmediump_dvec3;\n   25  \n   26: \t/// 3 components vector of low double-qualifier floating-point numbers.\n   27  \t/// There is no guarantee on the actual qualifier.\n   28  \t///\n   29: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   30  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   31  \ttypedef vec<3, double, lowp>\t\tlowp_dvec3;\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_double4.hpp:\n    1  /// @ref core\n    2: /// @file glm/ext/vector_double4.hpp\n    3  \n    4  #pragma once\n    .\n    7  namespace glm\n    8  {\n    9: \t/// @addtogroup core_vector\n   10  \t/// @{\n   11  \n   12: \t/// 4 components vector of double-precision floating-point numbers.\n   13  \t///\n   14: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   15  \ttypedef vec<4, double, defaultp>\t\tdvec4;\n   16  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_double4_precision.hpp:\n    1  /// @ref core\n    2: /// @file glm/ext/vector_double4_precision.hpp\n    3  \n    4  #pragma once\n    .\n    8  namespace glm\n    9  {\n   10: \t/// @addtogroup core_vector_precision\n   11  \t/// @{\n   12  \n   13: \t/// 4 components vector of high double-qualifier floating-point numbers.\n   14  \t/// There is no guarantee on the actual qualifier.\n   15  \t///\n   16: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   17  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   18  \ttypedef vec<4, double, highp>\t\thighp_dvec4;\n   19  \n   20: \t/// 4 components vector of medium double-qualifier floating-point numbers.\n   21  \t/// There is no guarantee on the actual qualifier.\n   22  \t///\n   23: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   24  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   25  \ttypedef vec<4, double, mediump>\t\tmediump_dvec4;\n   26  \n   27: \t/// 4 components vector of low double-qualifier floating-point numbers.\n   28  \t/// There is no guarantee on the actual qualifier.\n   29  \t///\n   30: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   31  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   32  \ttypedef vec<4, double, lowp>\t\tlowp_dvec4;\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_float1.hpp:\n    1: /// @ref ext_vector_float1\n    2: /// @file glm/ext/vector_float1.hpp\n    3  ///\n    4: /// @defgroup ext_vector_float1 GLM_EXT_vector_float1\n    5  /// @ingroup ext\n    6  ///\n    7: /// Exposes single-precision floating point vector type with one component.\n    8  ///\n    9: /// Include <glm/ext/vector_float1.hpp> to use the features of this extension.\n   10  ///\n   11: /// @see ext_vector_float1_precision extension.\n   12: /// @see ext_vector_double1 extension.\n   13  \n   14  #pragma once\n   ..\n   17  \n   18  #if GLM_MESSAGES == GLM_ENABLE && !defined(GLM_EXT_INCLUDED)\n   19: #\tpragma message(\"GLM: GLM_EXT_vector_float1 extension included\")\n   20  #endif\n   21  \n   22  namespace glm\n   23  {\n   24: \t/// @addtogroup ext_vector_float1\n   25  \t/// @{\n   26  \n   27: \t/// 1 components vector of single-precision floating-point numbers.\n   28  \ttypedef vec<1, float, defaultp>\t\tvec1;\n   29  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_float1_precision.hpp:\n    1: /// @ref ext_vector_float1_precision\n    2: /// @file glm/ext/vector_float1_precision.hpp\n    3  ///\n    4: /// @defgroup ext_vector_float1_precision GLM_EXT_vector_float1_precision\n    5  /// @ingroup ext\n    6  ///\n    7  /// Exposes highp_vec1, mediump_vec1 and lowp_vec1 types.\n    8  ///\n    9: /// Include <glm/ext/vector_float1_precision.hpp> to use the features of this extension.\n   10  ///\n   11: /// @see ext_vector_float1 extension.\n   12  \n   13  #pragma once\n   ..\n   16  \n   17  #if GLM_MESSAGES == GLM_ENABLE && !defined(GLM_EXT_INCLUDED)\n   18: #\tpragma message(\"GLM: GLM_EXT_vector_float1_precision extension included\")\n   19  #endif\n   20  \n   21  namespace glm\n   22  {\n   23: \t/// @addtogroup ext_vector_float1_precision\n   24  \t/// @{\n   25  \n   26: \t/// 1 component vector of single-precision floating-point numbers using high precision arithmetic in term of ULPs.\n   27  \ttypedef vec<1, float, highp>\t\thighp_vec1;\n   28  \n   29: \t/// 1 component vector of single-precision floating-point numbers using medium precision arithmetic in term of ULPs.\n   30  \ttypedef vec<1, float, mediump>\t\tmediump_vec1;\n   31  \n   32: \t/// 1 component vector of single-precision floating-point numbers using low precision arithmetic in term of ULPs.\n   33  \ttypedef vec<1, float, lowp>\t\t\tlowp_vec1;\n   34  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_float2.hpp:\n    1  /// @ref core\n    2: /// @file glm/ext/vector_float2.hpp\n    3  \n    4  #pragma once\n    .\n    7  namespace glm\n    8  {\n    9: \t/// @addtogroup core_vector\n   10  \t/// @{\n   11  \n   12: \t/// 2 components vector of single-precision floating-point numbers.\n   13  \t///\n   14: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   15  \ttypedef vec<2, float, defaultp>\tvec2;\n   16  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_float2_precision.hpp:\n    1  /// @ref core\n    2: /// @file glm/ext/vector_float2_precision.hpp\n    3  \n    4  #pragma once\n    .\n    7  namespace glm\n    8  {\n    9: \t/// @addtogroup core_vector_precision\n   10  \t/// @{\n   11  \n   12: \t/// 2 components vector of high single-qualifier floating-point numbers.\n   13  \t///\n   14: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   15  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   16  \ttypedef vec<2, float, highp>\t\thighp_vec2;\n   17  \n   18: \t/// 2 components vector of medium single-qualifier floating-point numbers.\n   19  \t///\n   20: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   21  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   22  \ttypedef vec<2, float, mediump>\t\tmediump_vec2;\n   23  \n   24: \t/// 2 components vector of low single-qualifier floating-point numbers.\n   25  \t///\n   26: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   27  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   28  \ttypedef vec<2, float, lowp>\t\t\tlowp_vec2;\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_float3.hpp:\n    1  /// @ref core\n    2: /// @file glm/ext/vector_float3.hpp\n    3  \n    4  #pragma once\n    .\n    7  namespace glm\n    8  {\n    9: \t/// @addtogroup core_vector\n   10  \t/// @{\n   11  \n   12: \t/// 3 components vector of single-precision floating-point numbers.\n   13  \t///\n   14: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   15  \ttypedef vec<3, float, defaultp>\t\tvec3;\n   16  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_float3_precision.hpp:\n    1  /// @ref core\n    2: /// @file glm/ext/vector_float3_precision.hpp\n    3  \n    4  #pragma once\n    .\n    7  namespace glm\n    8  {\n    9: \t/// @addtogroup core_vector_precision\n   10  \t/// @{\n   11  \n   12: \t/// 3 components vector of high single-qualifier floating-point numbers.\n   13  \t///\n   14: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   15  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   16  \ttypedef vec<3, float, highp>\t\thighp_vec3;\n   17  \n   18: \t/// 3 components vector of medium single-qualifier floating-point numbers.\n   19  \t///\n   20: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   21  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   22  \ttypedef vec<3, float, mediump>\t\tmediump_vec3;\n   23  \n   24: \t/// 3 components vector of low single-qualifier floating-point numbers.\n   25  \t///\n   26: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   27  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   28  \ttypedef vec<3, float, lowp>\t\t\tlowp_vec3;\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_float4.hpp:\n    1  /// @ref core\n    2: /// @file glm/ext/vector_float4.hpp\n    3  \n    4  #pragma once\n    .\n    7  namespace glm\n    8  {\n    9: \t/// @addtogroup core_vector\n   10  \t/// @{\n   11  \n   12: \t/// 4 components vector of single-precision floating-point numbers.\n   13  \t///\n   14: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   15  \ttypedef vec<4, float, defaultp>\t\tvec4;\n   16  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_float4_precision.hpp:\n    1  /// @ref core\n    2: /// @file glm/ext/vector_float4_precision.hpp\n    3  \n    4  #pragma once\n    .\n    7  namespace glm\n    8  {\n    9: \t/// @addtogroup core_vector_precision\n   10  \t/// @{\n   11  \n   12: \t/// 4 components vector of high single-qualifier floating-point numbers.\n   13  \t///\n   14: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   15  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   16  \ttypedef vec<4, float, highp>\t\thighp_vec4;\n   17  \n   18: \t/// 4 components vector of medium single-qualifier floating-point numbers.\n   19  \t///\n   20: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   21  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   22  \ttypedef vec<4, float, mediump>\t\tmediump_vec4;\n   23  \n   24: \t/// 4 components vector of low single-qualifier floating-point numbers.\n   25  \t///\n   26: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   27  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   28  \ttypedef vec<4, float, lowp>\t\t\tlowp_vec4;\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_int1.hpp:\n    1: /// @ref ext_vector_int1\n    2: /// @file glm/ext/vector_int1.hpp\n    3  ///\n    4: /// @defgroup ext_vector_int1 GLM_EXT_vector_int1\n    5  /// @ingroup ext\n    6  ///\n    7: /// Exposes ivec1 vector type.\n    8  ///\n    9: /// Include <glm/ext/vector_int1.hpp> to use the features of this extension.\n   10  ///\n   11: /// @see ext_vector_uint1 extension.\n   12: /// @see ext_vector_int1_precision extension.\n   13  \n   14  #pragma once\n   ..\n   17  \n   18  #if GLM_MESSAGES == GLM_ENABLE && !defined(GLM_EXT_INCLUDED)\n   19: #\tpragma message(\"GLM: GLM_EXT_vector_int1 extension included\")\n   20  #endif\n   21  \n   22  namespace glm\n   23  {\n   24: \t/// @addtogroup ext_vector_int1\n   25  \t/// @{\n   26  \n   27: \t/// 1 component vector of signed integer numbers.\n   28  \ttypedef vec<1, int, defaultp>\t\t\tivec1;\n   29  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_int1_precision.hpp:\n    1: /// @ref ext_vector_int1_precision\n    2: /// @file glm/ext/vector_int1_precision.hpp\n    3  ///\n    4: /// @defgroup ext_vector_int1_precision GLM_EXT_vector_int1_precision\n    5  /// @ingroup ext\n    6  ///\n    7  /// Exposes highp_ivec1, mediump_ivec1 and lowp_ivec1 types.\n    8  ///\n    9: /// Include <glm/ext/vector_int1_precision.hpp> to use the features of this extension.\n   10  \n   11  #pragma once\n   ..\n   14  \n   15  #if GLM_MESSAGES == GLM_ENABLE && !defined(GLM_EXT_INCLUDED)\n   16: #\tpragma message(\"GLM: GLM_EXT_vector_int1_precision extension included\")\n   17  #endif\n   18  \n   19  namespace glm\n   20  {\n   21: \t/// @addtogroup ext_vector_int1_precision\n   22  \t/// @{\n   23  \n   24: \t/// 1 component vector of signed integer values.\n   25  \ttypedef vec<1, int, highp>\t\t\thighp_ivec1;\n   26  \n   27: \t/// 1 component vector of signed integer values.\n   28  \ttypedef vec<1, int, mediump>\t\tmediump_ivec1;\n   29  \n   30: \t/// 1 component vector of signed integer values.\n   31  \ttypedef vec<1, int, lowp>\t\t\tlowp_ivec1;\n   32  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_int2.hpp:\n    1  /// @ref core\n    2: /// @file glm/ext/vector_int2.hpp\n    3  \n    4  #pragma once\n    .\n    7  namespace glm\n    8  {\n    9: \t/// @addtogroup core_vector\n   10  \t/// @{\n   11  \n   12: \t/// 2 components vector of signed integer numbers.\n   13  \t///\n   14: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   15  \ttypedef vec<2, int, defaultp>\t\tivec2;\n   16  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_int2_precision.hpp:\n    1  /// @ref core\n    2: /// @file glm/ext/vector_int2_precision.hpp\n    3  \n    4  #pragma once\n    .\n    7  namespace glm\n    8  {\n    9: \t/// @addtogroup core_vector_precision\n   10  \t/// @{\n   11  \n   12: \t/// 2 components vector of high qualifier signed integer numbers.\n   13  \t///\n   14: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   15  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   16  \ttypedef vec<2, int, highp>\t\thighp_ivec2;\n   17  \n   18: \t/// 2 components vector of medium qualifier signed integer numbers.\n   19  \t///\n   20: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   21  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   22  \ttypedef vec<2, int, mediump>\tmediump_ivec2;\n   23  \n   24: \t/// 2 components vector of low qualifier signed integer numbers.\n   25  \t///\n   26: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   27  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   28  \ttypedef vec<2, int, lowp>\t\tlowp_ivec2;\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_int3.hpp:\n    1  /// @ref core\n    2: /// @file glm/ext/vector_int3.hpp\n    3  \n    4  #pragma once\n    .\n    7  namespace glm\n    8  {\n    9: \t/// @addtogroup core_vector\n   10  \t/// @{\n   11  \n   12: \t/// 3 components vector of signed integer numbers.\n   13  \t///\n   14: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   15  \ttypedef vec<3, int, defaultp>\t\tivec3;\n   16  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_int3_precision.hpp:\n    1  /// @ref core\n    2: /// @file glm/ext/vector_int3_precision.hpp\n    3  \n    4  #pragma once\n    .\n    7  namespace glm\n    8  {\n    9: \t/// @addtogroup core_vector_precision\n   10  \t/// @{\n   11  \n   12: \t/// 3 components vector of high qualifier signed integer numbers.\n   13  \t///\n   14: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   15  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   16  \ttypedef vec<3, int, highp>\t\thighp_ivec3;\n   17  \n   18: \t/// 3 components vector of medium qualifier signed integer numbers.\n   19  \t///\n   20: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   21  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   22  \ttypedef vec<3, int, mediump>\tmediump_ivec3;\n   23  \n   24: \t/// 3 components vector of low qualifier signed integer numbers.\n   25  \t///\n   26: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   27  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   28  \ttypedef vec<3, int, lowp>\t\tlowp_ivec3;\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_int4.hpp:\n    1  /// @ref core\n    2: /// @file glm/ext/vector_int4.hpp\n    3  \n    4  #pragma once\n    .\n    7  namespace glm\n    8  {\n    9: \t/// @addtogroup core_vector\n   10  \t/// @{\n   11  \n   12: \t/// 4 components vector of signed integer numbers.\n   13  \t///\n   14: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   15  \ttypedef vec<4, int, defaultp>\t\tivec4;\n   16  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_int4_precision.hpp:\n    1  /// @ref core\n    2: /// @file glm/ext/vector_int4_precision.hpp\n    3  \n    4  #pragma once\n    .\n    7  namespace glm\n    8  {\n    9: \t/// @addtogroup core_vector_precision\n   10  \t/// @{\n   11  \n   12: \t/// 4 components vector of high qualifier signed integer numbers.\n   13  \t///\n   14: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   15  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   16  \ttypedef vec<4, int, highp>\t\thighp_ivec4;\n   17  \n   18: \t/// 4 components vector of medium qualifier signed integer numbers.\n   19  \t///\n   20: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   21  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   22  \ttypedef vec<4, int, mediump>\tmediump_ivec4;\n   23  \n   24: \t/// 4 components vector of low qualifier signed integer numbers.\n   25  \t///\n   26: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   27  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   28  \ttypedef vec<4, int, lowp>\t\tlowp_ivec4;\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_relational.hpp:\n    1: /// @ref ext_vector_relational\n    2: /// @file glm/ext/vector_relational.hpp\n    3  ///\n    4: /// @defgroup ext_vector_relational GLM_EXT_vector_relational\n    5  /// @ingroup ext\n    6  ///\n    7: /// Exposes comparison functions for vector types that take a user defined epsilon values.\n    8  ///\n    9: /// Include <glm/ext/vector_relational.hpp> to use the features of this extension.\n   10  ///\n   11: /// @see core_vector_relational\n   12  /// @see ext_scalar_relational\n   13  /// @see ext_matrix_relational\n   ..\n   19  \n   20  #if GLM_MESSAGES == GLM_ENABLE && !defined(GLM_EXT_INCLUDED)\n   21: #\tpragma message(\"GLM: GLM_EXT_vector_relational extension included\")\n   22  #endif\n   23  \n   24  namespace glm\n   25  {\n   26: \t/// @addtogroup ext_vector_relational\n   27  \t/// @{\n   28  \n   ..\n   30  \t/// True if this expression is satisfied.\n   31  \t///\n   32: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n   33  \t/// @tparam T Floating-point or integer scalar types\n   34  \t/// @tparam Q Value from qualifier enum\n   ..\n   39  \t/// True if this expression is satisfied.\n   40  \t///\n   41: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n   42  \t/// @tparam T Floating-point or integer scalar types\n   43  \t/// @tparam Q Value from qualifier enum\n   ..\n   48  \t/// True if this expression is not satisfied.\n   49  \t///\n   50: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n   51  \t/// @tparam T Floating-point or integer scalar types\n   52  \t/// @tparam Q Value from qualifier enum\n   ..\n   57  \t/// True if this expression is not satisfied.\n   58  \t///\n   59: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n   60  \t/// @tparam T Floating-point or integer scalar types\n   61  \t/// @tparam Q Value from qualifier enum\n   ..\n   66  }//namespace glm\n   67  \n   68: #include \"vector_relational.inl\"\n   69  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_relational.inl:\n    1: #include \"../vector_relational.hpp\"\n    2  #include \"../common.hpp\"\n    3  #include \"../detail/qualifier.hpp\"\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_uint1.hpp:\n    1: /// @ref ext_vector_uint1\n    2: /// @file glm/ext/vector_uint1.hpp\n    3  ///\n    4: /// @defgroup ext_vector_uint1 GLM_EXT_vector_uint1\n    5  /// @ingroup ext\n    6  ///\n    7: /// Exposes uvec1 vector type.\n    8  ///\n    9: /// Include <glm/ext/vector_uvec1.hpp> to use the features of this extension.\n   10  ///\n   11: /// @see ext_vector_int1 extension.\n   12: /// @see ext_vector_uint1_precision extension.\n   13  \n   14  #pragma once\n   ..\n   17  \n   18  #if GLM_MESSAGES == GLM_ENABLE && !defined(GLM_EXT_INCLUDED)\n   19: #\tpragma message(\"GLM: GLM_EXT_vector_uint1 extension included\")\n   20  #endif\n   21  \n   22  namespace glm\n   23  {\n   24: \t/// @addtogroup ext_vector_uint1\n   25  \t/// @{\n   26  \n   27: \t/// 1 component vector of unsigned integer numbers.\n   28  \ttypedef vec<1, unsigned int, defaultp>\t\t\tuvec1;\n   29  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_uint1_precision.hpp:\n    1: /// @ref ext_vector_uint1_precision\n    2: /// @file glm/ext/vector_uint1_precision.hpp\n    3  ///\n    4: /// @defgroup ext_vector_uint1_precision GLM_EXT_vector_uint1_precision\n    5  /// @ingroup ext\n    6  ///\n    7  /// Exposes highp_uvec1, mediump_uvec1 and lowp_uvec1 types.\n    8  ///\n    9: /// Include <glm/ext/vector_uint1_precision.hpp> to use the features of this extension.\n   10  \n   11  #pragma once\n   ..\n   14  \n   15  #if GLM_MESSAGES == GLM_ENABLE && !defined(GLM_EXT_INCLUDED)\n   16: #\tpragma message(\"GLM: GLM_EXT_vector_uint1_precision extension included\")\n   17  #endif\n   18  \n   19  namespace glm\n   20  {\n   21: \t/// @addtogroup ext_vector_uint1_precision\n   22  \t/// @{\n   23  \n   24: \t/// 1 component vector of unsigned integer values.\n   25  \t///\n   26: \t/// @see ext_vector_uint1_precision\n   27  \ttypedef vec<1, unsigned int, highp>\t\t\thighp_uvec1;\n   28  \n   29: \t/// 1 component vector of unsigned integer values.\n   30  \t///\n   31: \t/// @see ext_vector_uint1_precision\n   32  \ttypedef vec<1, unsigned int, mediump>\t\tmediump_uvec1;\n   33  \n   34: \t/// 1 component vector of unsigned integer values.\n   35  \t///\n   36: \t/// @see ext_vector_uint1_precision\n   37  \ttypedef vec<1, unsigned int, lowp>\t\t\tlowp_uvec1;\n   38  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_uint2.hpp:\n    1  /// @ref core\n    2: /// @file glm/ext/vector_uint2.hpp\n    3  \n    4  #pragma once\n    .\n    7  namespace glm\n    8  {\n    9: \t/// @addtogroup core_vector\n   10  \t/// @{\n   11  \n   12: \t/// 2 components vector of unsigned integer numbers.\n   13  \t///\n   14: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   15  \ttypedef vec<2, unsigned int, defaultp>\t\tuvec2;\n   16  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_uint2_precision.hpp:\n    1  /// @ref core\n    2: /// @file glm/ext/vector_uint2_precision.hpp\n    3  \n    4  #pragma once\n    .\n    7  namespace glm\n    8  {\n    9: \t/// @addtogroup core_vector_precision\n   10  \t/// @{\n   11  \n   12: \t/// 2 components vector of high qualifier unsigned integer numbers.\n   13  \t///\n   14: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   15  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   16  \ttypedef vec<2, unsigned int, highp>\t\thighp_uvec2;\n   17  \n   18: \t/// 2 components vector of medium qualifier unsigned integer numbers.\n   19  \t///\n   20: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   21  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   22  \ttypedef vec<2, unsigned int, mediump>\tmediump_uvec2;\n   23  \n   24: \t/// 2 components vector of low qualifier unsigned integer numbers.\n   25  \t///\n   26: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   27  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   28  \ttypedef vec<2, unsigned int, lowp>\t\tlowp_uvec2;\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_uint3.hpp:\n    1  /// @ref core\n    2: /// @file glm/ext/vector_uint3.hpp\n    3  \n    4  #pragma once\n    .\n    7  namespace glm\n    8  {\n    9: \t/// @addtogroup core_vector\n   10  \t/// @{\n   11  \n   12: \t/// 3 components vector of unsigned integer numbers.\n   13  \t///\n   14: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   15  \ttypedef vec<3, unsigned int, defaultp>\t\tuvec3;\n   16  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_uint3_precision.hpp:\n    1  /// @ref core\n    2: /// @file glm/ext/vector_uint3_precision.hpp\n    3  \n    4  #pragma once\n    .\n    7  namespace glm\n    8  {\n    9: \t/// @addtogroup core_vector_precision\n   10  \t/// @{\n   11  \n   12: \t/// 3 components vector of high qualifier unsigned integer numbers.\n   13  \t///\n   14: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   15  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   16  \ttypedef vec<3, unsigned int, highp>\t\thighp_uvec3;\n   17  \n   18: \t/// 3 components vector of medium qualifier unsigned integer numbers.\n   19  \t///\n   20: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   21  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   22  \ttypedef vec<3, unsigned int, mediump>\tmediump_uvec3;\n   23  \n   24: \t/// 3 components vector of low qualifier unsigned integer numbers.\n   25  \t///\n   26: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   27  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   28  \ttypedef vec<3, unsigned int, lowp>\t\tlowp_uvec3;\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_uint4.hpp:\n    1  /// @ref core\n    2: /// @file glm/ext/vector_uint4.hpp\n    3  \n    4  #pragma once\n    .\n    7  namespace glm\n    8  {\n    9: \t/// @addtogroup core_vector\n   10  \t/// @{\n   11  \n   12: \t/// 4 components vector of unsigned integer numbers.\n   13  \t///\n   14: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   15  \ttypedef vec<4, unsigned int, defaultp>\t\tuvec4;\n   16  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/vector_uint4_precision.hpp:\n    1  /// @ref core\n    2: /// @file glm/ext/vector_uint4_precision.hpp\n    3  \n    4  #pragma once\n    .\n    7  namespace glm\n    8  {\n    9: \t/// @addtogroup core_vector_precision\n   10  \t/// @{\n   11  \n   12: \t/// 4 components vector of high qualifier unsigned integer numbers.\n   13  \t///\n   14: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   15  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   16  \ttypedef vec<4, unsigned int, highp>\t\thighp_uvec4;\n   17  \n   18: \t/// 4 components vector of medium qualifier unsigned integer numbers.\n   19  \t///\n   20: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   21  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   22  \ttypedef vec<4, unsigned int, mediump>\tmediump_uvec4;\n   23  \n   24: \t/// 4 components vector of low qualifier unsigned integer numbers.\n   25  \t///\n   26: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>\n   27  \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>\n   28  \ttypedef vec<4, unsigned int, lowp>\t\tlowp_uvec4;\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/fwd.hpp:\n  176  \ttypedef double\t\t\t\t\tfloat64_t;\n  177  \n  178: \t// Vector bool\n  179  \n  180  \ttypedef vec<1, bool, lowp>\t\tlowp_bvec1;\n  ...\n  198  \ttypedef vec<4, bool, defaultp>\tbvec4;\n  199  \n  200: \t// Vector int\n  201  \n  202  \ttypedef vec<1, i32, lowp>\t\tlowp_ivec1;\n  ...\n  300  \ttypedef vec<4, i64, defaultp>\ti64vec4;\n  301  \n  302: \t// Vector uint\n  303  \n  304  \ttypedef vec<1, u32, lowp>\t\tlowp_uvec1;\n  ...\n  402  \ttypedef vec<4, u64, defaultp>\tu64vec4;\n  403  \n  404: \t// Vector float\n  405  \n  406  \ttypedef vec<1, float, lowp>\t\t\tlowp_vec1;\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/geometric.hpp:\n    7  /// @ingroup core\n    8  ///\n    9: /// These operate on vectors as vectors, not component-wise.\n   10  ///\n   11  /// Include <glm/geometric.hpp> to use these core features.\n   ..\n   22  \t/// Returns the length of x, i.e., sqrt(x * x).\n   23  \t///\n   24: \t/// @tparam L An integer between 1 and 4 included that qualify the dimension of the vector.\n   25  \t/// @tparam T Floating-point scalar types.\n   26  \t///\n   ..\n   32  \t/// Returns the distance betwwen p0 and p1, i.e., length(p0 - p1).\n   33  \t///\n   34: \t/// @tparam L An integer between 1 and 4 included that qualify the dimension of the vector.\n   35  \t/// @tparam T Floating-point scalar types.\n   36  \t///\n   ..\n   42  \t/// Returns the dot product of x and y, i.e., result = x * y.\n   43  \t///\n   44: \t/// @tparam L An integer between 1 and 4 included that qualify the dimension of the vector.\n   45  \t/// @tparam T Floating-point scalar types.\n   46  \t///\n   ..\n   59  \tGLM_FUNC_DECL vec<3, T, Q> cross(vec<3, T, Q> const& x, vec<3, T, Q> const& y);\n   60  \n   61: \t/// Returns a vector in the same direction as x but with length of 1.\n   62  \t/// According to issue 10 GLSL 1.10 specification, if length(x) == 0 then result is undefined and generate an error.\n   63  \t///\n   64: \t/// @tparam L An integer between 1 and 4 included that qualify the dimension of the vector.\n   65  \t/// @tparam T Floating-point scalar types.\n   66  \t///\n   ..\n   72  \t/// If dot(Nref, I) < 0.0, return N, otherwise, return -N.\n   73  \t///\n   74: \t/// @tparam L An integer between 1 and 4 included that qualify the dimension of the vector.\n   75  \t/// @tparam T Floating-point scalar types.\n   76  \t///\n   ..\n   83  \t\tvec<L, T, Q> const& Nref);\n   84  \n   85: \t/// For the incident vector I and surface orientation N,\n   86  \t/// returns the reflection direction : result = I - 2.0 * dot(N, I) * N.\n   87  \t///\n   88: \t/// @tparam L An integer between 1 and 4 included that qualify the dimension of the vector.\n   89  \t/// @tparam T Floating-point scalar types.\n   90  \t///\n   ..\n   96  \t\tvec<L, T, Q> const& N);\n   97  \n   98: \t/// For the incident vector I and surface normal N,\n   99  \t/// and the ratio of indices of refraction eta,\n  100: \t/// return the refraction vector.\n  101  \t///\n  102: \t/// @tparam L An integer between 1 and 4 included that qualify the dimension of the vector.\n  103  \t/// @tparam T Floating-point scalar types.\n  104  \t///\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/glm.hpp:\n   16  ///\n   17  ///\n   18: /// @defgroup core_vector Vector types\n   19  ///\n   20: /// Vector types of two to four components with an exhaustive set of operators.\n   21  ///\n   22  /// @ingroup core\n   23  ///\n   24  ///\n   25: /// @defgroup core_vector_precision Vector types with precision qualifiers\n   26  ///\n   27: /// @brief Vector types with precision qualifiers which may result in various precision in term of ULPs\n   28  ///\n   29  /// GLSL allows defining qualifiers for particular variables.\n   ..\n  133  #include \"geometric.hpp\"\n  134  #include \"matrix.hpp\"\n  135: #include \"vector_relational.hpp\"\n  136  #include \"integer.hpp\"\n  137  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtc/bitfield.hpp:\n   20  #include \"../ext/scalar_uint_sized.hpp\"\n   21  #include \"../detail/qualifier.hpp\"\n   22: #include \"../detail/_vectorize.hpp\"\n   23  #include \"type_precision.hpp\"\n   24  #include <limits>\n   ..\n   41  \t/// Build a mask of 'count' bits\n   42  \t///\n   43: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n   44  \t/// @tparam T Signed and unsigned integer scalar types\n   45  \t/// @tparam Q Value from qualifier enum\n   ..\n   57  \t/// Rotate all bits to the right. All the bits dropped in the right side are inserted back on the left side.\n   58  \t///\n   59: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n   60  \t/// @tparam T Signed and unsigned integer scalar types\n   61  \t/// @tparam Q Value from qualifier enum\n   ..\n   73  \t/// Rotate all bits to the left. All the bits dropped in the left side are inserted back on the right side.\n   74  \t///\n   75: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n   76  \t/// @tparam T Signed and unsigned integer scalar types\n   77  \t/// @tparam Q Value from qualifier enum\n   ..\n   89  \t/// Set to 1 a range of bits.\n   90  \t///\n   91: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n   92  \t/// @tparam T Signed and unsigned integer scalar types\n   93  \t/// @tparam Q Value from qualifier enum\n   ..\n  105  \t/// Set to 0 a range of bits.\n  106  \t///\n  107: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  108  \t/// @tparam T Signed and unsigned integer scalar types\n  109  \t/// @tparam Q Value from qualifier enum\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtc/bitfield.inl:\n  235  \t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_integer, \"'mask' accepts only integer values\");\n  236  \n  237: \t\treturn detail::functor1<vec, L, T, T, Q>::call(mask, v);\n  238  \t}\n  239  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtc/epsilon.inl:\n    2  \n    3  // Dependency:\n    4: #include \"../vector_relational.hpp\"\n    5  #include \"../common.hpp\"\n    6  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtc/matrix_inverse.inl:\n   66  \tGLM_FUNC_QUALIFIER mat<4, 4, T, Q> inverseTranspose(mat<4, 4, T, Q> const& m)\n   67  \t{\n   68: \t\tT SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];\n   69: \t\tT SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];\n   70: \t\tT SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];\n   71: \t\tT SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];\n   72: \t\tT SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];\n   73: \t\tT SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];\n   74: \t\tT SubFactor06 = m[1][2] * m[3][3] - m[3][2] * m[1][3];\n   75: \t\tT SubFactor07 = m[1][1] * m[3][3] - m[3][1] * m[1][3];\n   76: \t\tT SubFactor08 = m[1][1] * m[3][2] - m[3][1] * m[1][2];\n   77: \t\tT SubFactor09 = m[1][0] * m[3][3] - m[3][0] * m[1][3];\n   78: \t\tT SubFactor10 = m[1][0] * m[3][2] - m[3][0] * m[1][2];\n   79: \t\tT SubFactor11 = m[1][1] * m[3][3] - m[3][1] * m[1][3];\n   80: \t\tT SubFactor12 = m[1][0] * m[3][1] - m[3][0] * m[1][1];\n   81: \t\tT SubFactor13 = m[1][2] * m[2][3] - m[2][2] * m[1][3];\n   82: \t\tT SubFactor14 = m[1][1] * m[2][3] - m[2][1] * m[1][3];\n   83: \t\tT SubFactor15 = m[1][1] * m[2][2] - m[2][1] * m[1][2];\n   84: \t\tT SubFactor16 = m[1][0] * m[2][3] - m[2][0] * m[1][3];\n   85: \t\tT SubFactor17 = m[1][0] * m[2][2] - m[2][0] * m[1][2];\n   86: \t\tT SubFactor18 = m[1][0] * m[2][1] - m[2][0] * m[1][1];\n   87  \n   88  \t\tmat<4, 4, T, Q> Inverse;\n   89: \t\tInverse[0][0] = + (m[1][1] * SubFactor00 - m[1][2] * SubFactor01 + m[1][3] * SubFactor02);\n   90: \t\tInverse[0][1] = - (m[1][0] * SubFactor00 - m[1][2] * SubFactor03 + m[1][3] * SubFactor04);\n   91: \t\tInverse[0][2] = + (m[1][0] * SubFactor01 - m[1][1] * SubFactor03 + m[1][3] * SubFactor05);\n   92: \t\tInverse[0][3] = - (m[1][0] * SubFactor02 - m[1][1] * SubFactor04 + m[1][2] * SubFactor05);\n   93  \n   94: \t\tInverse[1][0] = - (m[0][1] * SubFactor00 - m[0][2] * SubFactor01 + m[0][3] * SubFactor02);\n   95: \t\tInverse[1][1] = + (m[0][0] * SubFactor00 - m[0][2] * SubFactor03 + m[0][3] * SubFactor04);\n   96: \t\tInverse[1][2] = - (m[0][0] * SubFactor01 - m[0][1] * SubFactor03 + m[0][3] * SubFactor05);\n   97: \t\tInverse[1][3] = + (m[0][0] * SubFactor02 - m[0][1] * SubFactor04 + m[0][2] * SubFactor05);\n   98  \n   99: \t\tInverse[2][0] = + (m[0][1] * SubFactor06 - m[0][2] * SubFactor07 + m[0][3] * SubFactor08);\n  100: \t\tInverse[2][1] = - (m[0][0] * SubFactor06 - m[0][2] * SubFactor09 + m[0][3] * SubFactor10);\n  101: \t\tInverse[2][2] = + (m[0][0] * SubFactor11 - m[0][1] * SubFactor09 + m[0][3] * SubFactor12);\n  102: \t\tInverse[2][3] = - (m[0][0] * SubFactor08 - m[0][1] * SubFactor10 + m[0][2] * SubFactor12);\n  103  \n  104: \t\tInverse[3][0] = - (m[0][1] * SubFactor13 - m[0][2] * SubFactor14 + m[0][3] * SubFactor15);\n  105: \t\tInverse[3][1] = + (m[0][0] * SubFactor13 - m[0][2] * SubFactor16 + m[0][3] * SubFactor17);\n  106: \t\tInverse[3][2] = - (m[0][0] * SubFactor14 - m[0][1] * SubFactor16 + m[0][3] * SubFactor18);\n  107: \t\tInverse[3][3] = + (m[0][0] * SubFactor15 - m[0][1] * SubFactor17 + m[0][2] * SubFactor18);\n  108  \n  109  \t\tT Determinant =\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtc/noise.hpp:\n   23  #include \"../geometric.hpp\"\n   24  #include \"../common.hpp\"\n   25: #include \"../vector_relational.hpp\"\n   26  #include \"../vec2.hpp\"\n   27  #include \"../vec3.hpp\"\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtc/packing.hpp:\n   57  \t/// packUnorm2x8:\tround(clamp(c, 0, +1) * 255.0)\n   58  \t///\n   59: \t/// The first component of the vector will be written to the least significant bits of the output;\n   60  \t/// the last component will be written to the most significant bits.\n   61  \t///\n   ..\n   68  \n   69  \t/// First, unpacks a single 16-bit unsigned integer p into a pair of 8-bit unsigned integers.\n   70: \t/// Then, each component is converted to a normalized floating-point value to generate the returned two-component vector.\n   71  \t///\n   72  \t/// The conversion for unpacked fixed-point value f to floating point is done as follows:\n   73  \t/// unpackUnorm4x8: f / 255.0\n   74  \t///\n   75: \t/// The first component of the returned vector will be extracted from the least significant bits of the input;\n   76  \t/// the last component will be extracted from the most significant bits.\n   77  \t///\n   ..\n  115  \t/// packSnorm2x8:\tround(clamp(c, -1, +1) * 127.0)\n  116  \t///\n  117: \t/// The first component of the vector will be written to the least significant bits of the output;\n  118  \t/// the last component will be written to the most significant bits.\n  119  \t///\n  ...\n  126  \n  127  \t/// First, unpacks a single 16-bit unsigned integer p into a pair of 8-bit signed integers.\n  128: \t/// Then, each component is converted to a normalized floating-point value to generate the returned two-component vector.\n  129  \t///\n  130  \t/// The conversion for unpacked fixed-point value f to floating point is done as follows:\n  131  \t/// unpackSnorm2x8: clamp(f / 127.0, -1, +1)\n  132  \t///\n  133: \t/// The first component of the returned vector will be extracted from the least significant bits of the input;\n  134  \t/// the last component will be extracted from the most significant bits.\n  135  \t///\n  ...\n  173  \t/// packUnorm4x16:\tround(clamp(c, 0, +1) * 65535.0)\n  174  \t///\n  175: \t/// The first component of the vector will be written to the least significant bits of the output;\n  176  \t/// the last component will be written to the most significant bits.\n  177  \t///\n  ...\n  184  \n  185  \t/// First, unpacks a single 64-bit unsigned integer p into four 16-bit unsigned integers.\n  186: \t/// Then, each component is converted to a normalized floating-point value to generate the returned four-component vector.\n  187  \t///\n  188  \t/// The conversion for unpacked fixed-point value f to floating point is done as follows:\n  189  \t/// unpackUnormx4x16: f / 65535.0\n  190  \t///\n  191: \t/// The first component of the returned vector will be extracted from the least significant bits of the input;\n  192  \t/// the last component will be extracted from the most significant bits.\n  193  \t///\n  ...\n  231  \t/// packSnorm2x8:\tround(clamp(c, -1, +1) * 32767.0)\n  232  \t///\n  233: \t/// The first component of the vector will be written to the least significant bits of the output;\n  234  \t/// the last component will be written to the most significant bits.\n  235  \t///\n  ...\n  242  \n  243  \t/// First, unpacks a single 64-bit unsigned integer p into four 16-bit signed integers.\n  244: \t/// Then, each component is converted to a normalized floating-point value to generate the returned four-component vector.\n  245  \t///\n  246  \t/// The conversion for unpacked fixed-point value f to floating point is done as follows:\n  247  \t/// unpackSnorm4x16: clamp(f / 32767.0, -1, +1)\n  248  \t///\n  249: \t/// The first component of the returned vector will be extracted from the least significant bits of the input;\n  250  \t/// the last component will be extracted from the most significant bits.\n  251  \t///\n  ...\n  279  \tGLM_FUNC_DECL float unpackHalf1x16(uint16 v);\n  280  \n  281: \t/// Returns an unsigned integer obtained by converting the components of a four-component floating-point vector\n  282  \t/// to the 16-bit floating-point representation found in the OpenGL Specification,\n  283  \t/// and then packing these four 16-bit values into a 64-bit unsigned integer.\n  284: \t/// The first vector component specifies the 16 least-significant bits of the result;\n  285  \t/// the forth component specifies the 16 most-significant bits.\n  286  \t///\n  ...\n  292  \tGLM_FUNC_DECL uint64 packHalf4x16(vec4 const& v);\n  293  \n  294: \t/// Returns a four-component floating-point vector with components obtained by unpacking a 64-bit unsigned integer into four 16-bit values,\n  295  \t/// interpreting those values as 16-bit floating-point numbers according to the OpenGL Specification,\n  296  \t/// and converting them to 32-bit floating-point values.\n  297: \t/// The first component of the vector is obtained from the 16 least-significant bits of v;\n  298  \t/// the forth component is obtained from the 16 most-significant bits of v.\n  299  \t///\n  ...\n  305  \tGLM_FUNC_DECL vec4 unpackHalf4x16(uint64 p);\n  306  \n  307: \t/// Returns an unsigned integer obtained by converting the components of a four-component signed integer vector\n  308  \t/// to the 10-10-10-2-bit signed integer representation found in the OpenGL Specification,\n  309  \t/// and then packing these four values into a 32-bit unsigned integer.\n  310: \t/// The first vector component specifies the 10 least-significant bits of the result;\n  311  \t/// the forth component specifies the 2 most-significant bits.\n  312  \t///\n  ...\n  320  \t/// Unpacks a single 32-bit unsigned integer p into three 10-bit and one 2-bit signed integers.\n  321  \t///\n  322: \t/// The first component of the returned vector will be extracted from the least significant bits of the input;\n  323  \t/// the last component will be extracted from the most significant bits.\n  324  \t///\n  ...\n  329  \tGLM_FUNC_DECL ivec4 unpackI3x10_1x2(uint32 p);\n  330  \n  331: \t/// Returns an unsigned integer obtained by converting the components of a four-component unsigned integer vector\n  332  \t/// to the 10-10-10-2-bit unsigned integer representation found in the OpenGL Specification,\n  333  \t/// and then packing these four values into a 32-bit unsigned integer.\n  334: \t/// The first vector component specifies the 10 least-significant bits of the result;\n  335  \t/// the forth component specifies the 2 most-significant bits.\n  336  \t///\n  ...\n  344  \t/// Unpacks a single 32-bit unsigned integer p into three 10-bit and one 2-bit unsigned integers.\n  345  \t///\n  346: \t/// The first component of the returned vector will be extracted from the least significant bits of the input;\n  347  \t/// the last component will be extracted from the most significant bits.\n  348  \t///\n  ...\n  361  \t/// packSnorm3x10_1x2(w):\tround(clamp(c, -1, +1) * 1.0)\n  362  \t///\n  363: \t/// The first vector component specifies the 10 least-significant bits of the result;\n  364  \t/// the forth component specifies the 2 most-significant bits.\n  365  \t///\n  ...\n  372  \n  373  \t/// First, unpacks a single 32-bit unsigned integer p into four 16-bit signed integers.\n  374: \t/// Then, each component is converted to a normalized floating-point value to generate the returned four-component vector.\n  375  \t///\n  376  \t/// The conversion for unpacked fixed-point value f to floating point is done as follows:\n  ...\n  378  \t/// unpackSnorm3x10_1x2(w): clamp(f / 511.0, -1, +1)\n  379  \t///\n  380: \t/// The first component of the returned vector will be extracted from the least significant bits of the input;\n  381  \t/// the last component will be extracted from the most significant bits.\n  382  \t///\n  ...\n  396  \t/// packUnorm3x10_1x2(w):\tround(clamp(c, 0, +1) * 3.0)\n  397  \t///\n  398: \t/// The first vector component specifies the 10 least-significant bits of the result;\n  399  \t/// the forth component specifies the 2 most-significant bits.\n  400  \t///\n  ...\n  407  \n  408  \t/// First, unpacks a single 32-bit unsigned integer p into four 16-bit signed integers.\n  409: \t/// Then, each component is converted to a normalized floating-point value to generate the returned four-component vector.\n  410  \t///\n  411  \t/// The conversion for unpacked fixed-point value f to floating point is done as follows:\n  ...\n  413  \t/// unpackSnorm3x10_1x2(w): clamp(f / 3.0, 0, +1)\n  414  \t///\n  415: \t/// The first component of the returned vector will be extracted from the least significant bits of the input;\n  416  \t/// the last component will be extracted from the most significant bits.\n  417  \t///\n  ...\n  427  \t/// Then, the results are packed into the returned 32-bit unsigned integer.\n  428  \t///\n  429: \t/// The first vector component specifies the 11 least-significant bits of the result;\n  430  \t/// the last component specifies the 10 most-significant bits.\n  431  \t///\n  ...\n  435  \n  436  \t/// First, unpacks a single 32-bit unsigned integer p into two 11-bit signless floating-point values and one 10-bit signless floating-point value .\n  437: \t/// Then, each component is converted to a normalized floating-point value to generate the returned three-component vector.\n  438  \t///\n  439: \t/// The first component of the returned vector will be extracted from the least significant bits of the input;\n  440  \t/// the last component will be extracted from the most significant bits.\n  441  \t///\n  ...\n  449  \t/// Then, the results are packed into the returned 32-bit unsigned integer.\n  450  \t///\n  451: \t/// The first vector component specifies the 11 least-significant bits of the result;\n  452  \t/// the last component specifies the 10 most-significant bits.\n  453  \t///\n  ...\n  459  \n  460  \t/// First, unpacks a single 32-bit unsigned integer p into two 11-bit signless floating-point values and one 10-bit signless floating-point value .\n  461: \t/// Then, each component is converted to a normalized floating-point value to generate the returned three-component vector.\n  462  \t///\n  463: \t/// The first component of the returned vector will be extracted from the least significant bits of the input;\n  464  \t/// the last component will be extracted from the most significant bits.\n  465  \t///\n  ...\n  470  \tGLM_FUNC_DECL vec3 unpackF3x9_E1x5(uint32 p);\n  471  \n  472: \t/// Returns an unsigned integer vector obtained by converting the components of a floating-point vector\n  473  \t/// to the 16-bit floating-point representation found in the OpenGL Specification.\n  474: \t/// The first vector component specifies the 16 least-significant bits of the result;\n  475  \t/// the forth component specifies the 16 most-significant bits.\n  476  \t///\n  ...\n  481  \tGLM_FUNC_DECL vec<4, T, Q> packRGBM(vec<3, T, Q> const& rgb);\n  482  \n  483: \t/// Returns a floating-point vector with components obtained by reinterpreting an integer vector as 16-bit floating-point numbers and converting them to 32-bit floating-point values.\n  484: \t/// The first component of the vector is obtained from the 16 least-significant bits of v;\n  485  \t/// the forth component is obtained from the 16 most-significant bits of v.\n  486  \t///\n  ...\n  491  \tGLM_FUNC_DECL vec<3, T, Q> unpackRGBM(vec<4, T, Q> const& rgbm);\n  492  \n  493: \t/// Returns an unsigned integer vector obtained by converting the components of a floating-point vector\n  494  \t/// to the 16-bit floating-point representation found in the OpenGL Specification.\n  495: \t/// The first vector component specifies the 16 least-significant bits of the result;\n  496  \t/// the forth component specifies the 16 most-significant bits.\n  497  \t///\n  ...\n  502  \tGLM_FUNC_DECL vec<L, uint16, Q> packHalf(vec<L, float, Q> const& v);\n  503  \n  504: \t/// Returns a floating-point vector with components obtained by reinterpreting an integer vector as 16-bit floating-point numbers and converting them to 32-bit floating-point values.\n  505: \t/// The first component of the vector is obtained from the 16 least-significant bits of v;\n  506  \t/// the forth component is obtained from the 16 most-significant bits of v.\n  507  \t///\n  ...\n  512  \tGLM_FUNC_DECL vec<L, float, Q> unpackHalf(vec<L, uint16, Q> const& p);\n  513  \n  514: \t/// Convert each component of the normalized floating-point vector into unsigned integer values.\n  515  \t///\n  516  \t/// @see gtc_packing\n  ...\n  519  \tGLM_FUNC_DECL vec<L, uintType, Q> packUnorm(vec<L, floatType, Q> const& v);\n  520  \n  521: \t/// Convert a packed integer to a normalized floating-point vector.\n  522  \t///\n  523  \t/// @see gtc_packing\n  ...\n  526  \tGLM_FUNC_DECL vec<L, floatType, Q> unpackUnorm(vec<L, uintType, Q> const& v);\n  527  \n  528: \t/// Convert each component of the normalized floating-point vector into signed integer values.\n  529  \t///\n  530  \t/// @see gtc_packing\n  ...\n  533  \tGLM_FUNC_DECL vec<L, intType, Q> packSnorm(vec<L, floatType, Q> const& v);\n  534  \n  535: \t/// Convert a packed integer to a normalized floating-point vector.\n  536  \t///\n  537  \t/// @see gtc_packing\n  ...\n  540  \tGLM_FUNC_DECL vec<L, floatType, Q> unpackSnorm(vec<L, intType, Q> const& v);\n  541  \n  542: \t/// Convert each component of the normalized floating-point vector into unsigned integer values.\n  543  \t///\n  544  \t/// @see gtc_packing\n  ...\n  546  \tGLM_FUNC_DECL uint8 packUnorm2x4(vec2 const& v);\n  547  \n  548: \t/// Convert a packed integer to a normalized floating-point vector.\n  549  \t///\n  550  \t/// @see gtc_packing\n  ...\n  552  \tGLM_FUNC_DECL vec2 unpackUnorm2x4(uint8 p);\n  553  \n  554: \t/// Convert each component of the normalized floating-point vector into unsigned integer values.\n  555  \t///\n  556  \t/// @see gtc_packing\n  ...\n  558  \tGLM_FUNC_DECL uint16 packUnorm4x4(vec4 const& v);\n  559  \n  560: \t/// Convert a packed integer to a normalized floating-point vector.\n  561  \t///\n  562  \t/// @see gtc_packing\n  ...\n  564  \tGLM_FUNC_DECL vec4 unpackUnorm4x4(uint16 p);\n  565  \n  566: \t/// Convert each component of the normalized floating-point vector into unsigned integer values.\n  567  \t///\n  568  \t/// @see gtc_packing\n  ...\n  570  \tGLM_FUNC_DECL uint16 packUnorm1x5_1x6_1x5(vec3 const& v);\n  571  \n  572: \t/// Convert a packed integer to a normalized floating-point vector.\n  573  \t///\n  574  \t/// @see gtc_packing\n  ...\n  576  \tGLM_FUNC_DECL vec3 unpackUnorm1x5_1x6_1x5(uint16 p);\n  577  \n  578: \t/// Convert each component of the normalized floating-point vector into unsigned integer values.\n  579  \t///\n  580  \t/// @see gtc_packing\n  ...\n  582  \tGLM_FUNC_DECL uint16 packUnorm3x5_1x1(vec4 const& v);\n  583  \n  584: \t/// Convert a packed integer to a normalized floating-point vector.\n  585  \t///\n  586  \t/// @see gtc_packing\n  ...\n  588  \tGLM_FUNC_DECL vec4 unpackUnorm3x5_1x1(uint16 p);\n  589  \n  590: \t/// Convert each component of the normalized floating-point vector into unsigned integer values.\n  591  \t///\n  592  \t/// @see gtc_packing\n  ...\n  594  \tGLM_FUNC_DECL uint8 packUnorm2x3_1x2(vec3 const& v);\n  595  \n  596: \t/// Convert a packed integer to a normalized floating-point vector.\n  597  \t///\n  598  \t/// @see gtc_packing\n  ...\n  602  \n  603  \n  604: \t/// Convert each component from an integer vector into a packed unsigned integer.\n  605  \t///\n  606  \t/// @see gtc_packing\n  ...\n  608  \tGLM_FUNC_DECL int16 packInt2x8(i8vec2 const& v);\n  609  \n  610: \t/// Convert a packed integer into an integer vector.\n  611  \t///\n  612  \t/// @see gtc_packing\n  ...\n  614  \tGLM_FUNC_DECL i8vec2 unpackInt2x8(int16 p);\n  615  \n  616: \t/// Convert each component from an integer vector into a packed unsigned integer.\n  617  \t///\n  618  \t/// @see gtc_packing\n  ...\n  620  \tGLM_FUNC_DECL uint16 packUint2x8(u8vec2 const& v);\n  621  \n  622: \t/// Convert a packed integer into an integer vector.\n  623  \t///\n  624  \t/// @see gtc_packing\n  ...\n  626  \tGLM_FUNC_DECL u8vec2 unpackUint2x8(uint16 p);\n  627  \n  628: \t/// Convert each component from an integer vector into a packed unsigned integer.\n  629  \t///\n  630  \t/// @see gtc_packing\n  ...\n  632  \tGLM_FUNC_DECL int32 packInt4x8(i8vec4 const& v);\n  633  \n  634: \t/// Convert a packed integer into an integer vector.\n  635  \t///\n  636  \t/// @see gtc_packing\n  ...\n  638  \tGLM_FUNC_DECL i8vec4 unpackInt4x8(int32 p);\n  639  \n  640: \t/// Convert each component from an integer vector into a packed unsigned integer.\n  641  \t///\n  642  \t/// @see gtc_packing\n  ...\n  644  \tGLM_FUNC_DECL uint32 packUint4x8(u8vec4 const& v);\n  645  \n  646: \t/// Convert a packed integer into an integer vector.\n  647  \t///\n  648  \t/// @see gtc_packing\n  ...\n  650  \tGLM_FUNC_DECL u8vec4 unpackUint4x8(uint32 p);\n  651  \n  652: \t/// Convert each component from an integer vector into a packed unsigned integer.\n  653  \t///\n  654  \t/// @see gtc_packing\n  ...\n  656  \tGLM_FUNC_DECL int packInt2x16(i16vec2 const& v);\n  657  \n  658: \t/// Convert a packed integer into an integer vector.\n  659  \t///\n  660  \t/// @see gtc_packing\n  ...\n  662  \tGLM_FUNC_DECL i16vec2 unpackInt2x16(int p);\n  663  \n  664: \t/// Convert each component from an integer vector into a packed unsigned integer.\n  665  \t///\n  666  \t/// @see gtc_packing\n  ...\n  668  \tGLM_FUNC_DECL int64 packInt4x16(i16vec4 const& v);\n  669  \n  670: \t/// Convert a packed integer into an integer vector.\n  671  \t///\n  672  \t/// @see gtc_packing\n  ...\n  674  \tGLM_FUNC_DECL i16vec4 unpackInt4x16(int64 p);\n  675  \n  676: \t/// Convert each component from an integer vector into a packed unsigned integer.\n  677  \t///\n  678  \t/// @see gtc_packing\n  ...\n  680  \tGLM_FUNC_DECL uint packUint2x16(u16vec2 const& v);\n  681  \n  682: \t/// Convert a packed integer into an integer vector.\n  683  \t///\n  684  \t/// @see gtc_packing\n  ...\n  686  \tGLM_FUNC_DECL u16vec2 unpackUint2x16(uint p);\n  687  \n  688: \t/// Convert each component from an integer vector into a packed unsigned integer.\n  689  \t///\n  690  \t/// @see gtc_packing\n  ...\n  692  \tGLM_FUNC_DECL uint64 packUint4x16(u16vec4 const& v);\n  693  \n  694: \t/// Convert a packed integer into an integer vector.\n  695  \t///\n  696  \t/// @see gtc_packing\n  ...\n  698  \tGLM_FUNC_DECL u16vec4 unpackUint4x16(uint64 p);\n  699  \n  700: \t/// Convert each component from an integer vector into a packed unsigned integer.\n  701  \t///\n  702  \t/// @see gtc_packing\n  ...\n  704  \tGLM_FUNC_DECL int64 packInt2x32(i32vec2 const& v);\n  705  \n  706: \t/// Convert a packed integer into an integer vector.\n  707  \t///\n  708  \t/// @see gtc_packing\n  ...\n  710  \tGLM_FUNC_DECL i32vec2 unpackInt2x32(int64 p);\n  711  \n  712: \t/// Convert each component from an integer vector into a packed unsigned integer.\n  713  \t///\n  714  \t/// @see gtc_packing\n  ...\n  716  \tGLM_FUNC_DECL uint64 packUint2x32(u32vec2 const& v);\n  717  \n  718: \t/// Convert a packed integer into an integer vector.\n  719  \t///\n  720  \t/// @see gtc_packing\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtc/packing.inl:\n    2  \n    3  #include \"../ext/scalar_relational.hpp\"\n    4: #include \"../ext/vector_relational.hpp\"\n    5  #include \"../common.hpp\"\n    6  #include \"../vec2.hpp\"\n    .\n  590  \tGLM_FUNC_QUALIFIER vec4 unpackUnorm3x10_1x2(uint32 v)\n  591  \t{\n  592: \t\tvec4 const ScaleFactors(1.0f / 1023.f, 1.0f / 1023.f, 1.0f / 1023.f, 1.0f / 3.f);\n  593  \n  594  \t\tdetail::u10u10u10u2 Unpack;\n  595  \t\tUnpack.pack = v;\n  596: \t\treturn vec4(Unpack.data.x, Unpack.data.y, Unpack.data.z, Unpack.data.w) * ScaleFactors;\n  597  \t}\n  598  \n  ...\n  716  \tGLM_FUNC_QUALIFIER vec2 unpackUnorm2x4(uint8 v)\n  717  \t{\n  718: \t\tfloat const ScaleFactor(1.f / 15.f);\n  719  \t\tdetail::u4u4 Unpack;\n  720  \t\tUnpack.pack = v;\n  721: \t\treturn vec2(Unpack.data.x, Unpack.data.y) * ScaleFactor;\n  722  \t}\n  723  \n  ...\n  735  \tGLM_FUNC_QUALIFIER vec4 unpackUnorm4x4(uint16 v)\n  736  \t{\n  737: \t\tfloat const ScaleFactor(1.f / 15.f);\n  738  \t\tdetail::u4u4u4u4 Unpack;\n  739  \t\tUnpack.pack = v;\n  740: \t\treturn vec4(Unpack.data.x, Unpack.data.y, Unpack.data.z, Unpack.data.w) * ScaleFactor;\n  741  \t}\n  742  \n  ...\n  753  \tGLM_FUNC_QUALIFIER vec3 unpackUnorm1x5_1x6_1x5(uint16 v)\n  754  \t{\n  755: \t\tvec3 const ScaleFactor(1.f / 31.f, 1.f / 63.f, 1.f / 31.f);\n  756  \t\tdetail::u5u6u5 Unpack;\n  757  \t\tUnpack.pack = v;\n  758: \t\treturn vec3(Unpack.data.x, Unpack.data.y, Unpack.data.z) * ScaleFactor;\n  759  \t}\n  760  \n  ...\n  772  \tGLM_FUNC_QUALIFIER vec4 unpackUnorm3x5_1x1(uint16 v)\n  773  \t{\n  774: \t\tvec4 const ScaleFactor(1.f / 31.f, 1.f / 31.f, 1.f / 31.f, 1.f);\n  775  \t\tdetail::u5u5u5u1 Unpack;\n  776  \t\tUnpack.pack = v;\n  777: \t\treturn vec4(Unpack.data.x, Unpack.data.y, Unpack.data.z, Unpack.data.w) * ScaleFactor;\n  778  \t}\n  779  \n  ...\n  790  \tGLM_FUNC_QUALIFIER vec3 unpackUnorm2x3_1x2(uint8 v)\n  791  \t{\n  792: \t\tvec3 const ScaleFactor(1.f / 7.f, 1.f / 7.f, 1.f / 3.f);\n  793  \t\tdetail::u3u3u2 Unpack;\n  794  \t\tUnpack.pack = v;\n  795: \t\treturn vec3(Unpack.data.x, Unpack.data.y, Unpack.data.z) * ScaleFactor;\n  796  \t}\n  797  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtc/quaternion.hpp:\n   17  #include \"../gtc/constants.hpp\"\n   18  #include \"../gtc/matrix_transform.hpp\"\n   19: #include \"../ext/vector_relational.hpp\"\n   20  #include \"../ext/quaternion_common.hpp\"\n   21  #include \"../ext/quaternion_float.hpp\"\n   ..\n  145  \t///\n  146  \t/// @param direction Desired forward direction. Needs to be normalized.\n  147: \t/// @param up Up vector, how the camera is oriented. Typically (0, 1, 0).\n  148  \ttemplate<typename T, qualifier Q>\n  149  \tGLM_FUNC_DECL qua<T, Q> quatLookAt(\n  ...\n  154  \t///\n  155  \t/// @param direction Desired forward direction onto which the -z-axis gets mapped. Needs to be normalized.\n  156: \t/// @param up Up vector, how the camera is oriented. Typically (0, 1, 0).\n  157  \ttemplate<typename T, qualifier Q>\n  158  \tGLM_FUNC_DECL qua<T, Q> quatLookAtRH(\n  ...\n  163  \t///\n  164  \t/// @param direction Desired forward direction onto which the +z-axis gets mapped. Needs to be normalized.\n  165: \t/// @param up Up vector, how the camera is oriented. Typically (0, 1, 0).\n  166  \ttemplate<typename T, qualifier Q>\n  167  \tGLM_FUNC_DECL qua<T, Q> quatLookAtLH(\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtc/random.hpp:\n   53  \tGLM_FUNC_DECL genType gaussRand(genType Mean, genType Deviation);\n   54  \n   55: \t/// Generate a random 2D vector which coordinates are regulary distributed on a circle of a given radius\n   56  \t///\n   57  \t/// @see gtc_random\n   ..\n   59  \tGLM_FUNC_DECL vec<2, T, defaultp> circularRand(T Radius);\n   60  \n   61: \t/// Generate a random 3D vector which coordinates are regulary distributed on a sphere of a given radius\n   62  \t///\n   63  \t/// @see gtc_random\n   ..\n   65  \tGLM_FUNC_DECL vec<3, T, defaultp> sphericalRand(T Radius);\n   66  \n   67: \t/// Generate a random 2D vector which coordinates are regulary distributed within the area of a disk of a given radius\n   68  \t///\n   69  \t/// @see gtc_random\n   ..\n   71  \tGLM_FUNC_DECL vec<2, T, defaultp> diskRand(T Radius);\n   72  \n   73: \t/// Generate a random 3D vector which coordinates are regulary distributed within the volume of a ball of a given radius\n   74  \t///\n   75  \t/// @see gtc_random\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtc/random.inl:\n  235  \tGLM_FUNC_QUALIFIER vec<L, T, Q> gaussRand(vec<L, T, Q> const& Mean, vec<L, T, Q> const& Deviation)\n  236  \t{\n  237: \t\treturn detail::functor2<vec, L, T, Q>::call(gaussRand, Mean, Deviation);\n  238  \t}\n  239  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtc/reciprocal.hpp:\n   28  \t/// hypotenuse / adjacent or 1 / cos(x)\n   29  \t///\n   30: \t/// @tparam genType Floating-point scalar or vector types.\n   31  \t///\n   32  \t/// @see gtc_reciprocal\n   ..\n   37  \t/// hypotenuse / opposite or 1 / sin(x)\n   38  \t///\n   39: \t/// @tparam genType Floating-point scalar or vector types.\n   40  \t///\n   41  \t/// @see gtc_reciprocal\n   ..\n   46  \t/// adjacent / opposite or 1 / tan(x)\n   47  \t///\n   48: \t/// @tparam genType Floating-point scalar or vector types.\n   49  \t///\n   50  \t/// @see gtc_reciprocal\n   ..\n   55  \t///\n   56  \t/// @return Return an angle expressed in radians.\n   57: \t/// @tparam genType Floating-point scalar or vector types.\n   58  \t///\n   59  \t/// @see gtc_reciprocal\n   ..\n   64  \t///\n   65  \t/// @return Return an angle expressed in radians.\n   66: \t/// @tparam genType Floating-point scalar or vector types.\n   67  \t///\n   68  \t/// @see gtc_reciprocal\n   ..\n   73  \t///\n   74  \t/// @return Return an angle expressed in radians.\n   75: \t/// @tparam genType Floating-point scalar or vector types.\n   76  \t///\n   77  \t/// @see gtc_reciprocal\n   ..\n   81  \t/// Secant hyperbolic function.\n   82  \t///\n   83: \t/// @tparam genType Floating-point scalar or vector types.\n   84  \t///\n   85  \t/// @see gtc_reciprocal\n   ..\n   89  \t/// Cosecant hyperbolic function.\n   90  \t///\n   91: \t/// @tparam genType Floating-point scalar or vector types.\n   92  \t///\n   93  \t/// @see gtc_reciprocal\n   ..\n   97  \t/// Cotangent hyperbolic function.\n   98  \t///\n   99: \t/// @tparam genType Floating-point scalar or vector types.\n  100  \t///\n  101  \t/// @see gtc_reciprocal\n  ...\n  106  \t///\n  107  \t/// @return Return an angle expressed in radians.\n  108: \t/// @tparam genType Floating-point scalar or vector types.\n  109  \t///\n  110  \t/// @see gtc_reciprocal\n  ...\n  115  \t///\n  116  \t/// @return Return an angle expressed in radians.\n  117: \t/// @tparam genType Floating-point scalar or vector types.\n  118  \t///\n  119  \t/// @see gtc_reciprocal\n  ...\n  124  \t///\n  125  \t/// @return Return an angle expressed in radians.\n  126: \t/// @tparam genType Floating-point scalar or vector types.\n  127  \t///\n  128  \t/// @see gtc_reciprocal\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtc/reciprocal.inl:\n   18  \t{\n   19  \t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'sec' only accept floating-point inputs\");\n   20: \t\treturn detail::functor1<vec, L, T, T, Q>::call(sec, x);\n   21  \t}\n   22  \n   ..\n   33  \t{\n   34  \t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'csc' only accept floating-point inputs\");\n   35: \t\treturn detail::functor1<vec, L, T, T, Q>::call(csc, x);\n   36  \t}\n   37  \n   ..\n   50  \t{\n   51  \t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'cot' only accept floating-point inputs\");\n   52: \t\treturn detail::functor1<vec, L, T, T, Q>::call(cot, x);\n   53  \t}\n   54  \n   ..\n   65  \t{\n   66  \t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'asec' only accept floating-point inputs\");\n   67: \t\treturn detail::functor1<vec, L, T, T, Q>::call(asec, x);\n   68  \t}\n   69  \n   ..\n   80  \t{\n   81  \t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'acsc' only accept floating-point inputs\");\n   82: \t\treturn detail::functor1<vec, L, T, T, Q>::call(acsc, x);\n   83  \t}\n   84  \n   ..\n   97  \t{\n   98  \t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'acot' only accept floating-point inputs\");\n   99: \t\treturn detail::functor1<vec, L, T, T, Q>::call(acot, x);\n  100  \t}\n  101  \n  ...\n  112  \t{\n  113  \t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'sech' only accept floating-point inputs\");\n  114: \t\treturn detail::functor1<vec, L, T, T, Q>::call(sech, x);\n  115  \t}\n  116  \n  ...\n  127  \t{\n  128  \t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'csch' only accept floating-point inputs\");\n  129: \t\treturn detail::functor1<vec, L, T, T, Q>::call(csch, x);\n  130  \t}\n  131  \n  ...\n  142  \t{\n  143  \t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'coth' only accept floating-point inputs\");\n  144: \t\treturn detail::functor1<vec, L, T, T, Q>::call(coth, x);\n  145  \t}\n  146  \n  ...\n  157  \t{\n  158  \t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'asech' only accept floating-point inputs\");\n  159: \t\treturn detail::functor1<vec, L, T, T, Q>::call(asech, x);\n  160  \t}\n  161  \n  ...\n  172  \t{\n  173  \t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'acsch' only accept floating-point inputs\");\n  174: \t\treturn detail::functor1<vec, L, T, T, Q>::call(acsch, x);\n  175  \t}\n  176  \n  ...\n  187  \t{\n  188  \t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'acoth' only accept floating-point inputs\");\n  189: \t\treturn detail::functor1<vec, L, T, T, Q>::call(acoth, x);\n  190  \t}\n  191  }//namespace glm\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtc/round.hpp:\n   17  #include \"../detail/setup.hpp\"\n   18  #include \"../detail/qualifier.hpp\"\n   19: #include \"../detail/_vectorize.hpp\"\n   20: #include \"../vector_relational.hpp\"\n   21  #include \"../common.hpp\"\n   22  #include <limits>\n   ..\n   39  \t/// Return true if the value is a power of two number.\n   40  \t///\n   41: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n   42  \t/// @tparam T Floating-point or integer scalar types\n   43  \t/// @tparam Q Value from qualifier enum\n   ..\n   57  \t/// round up to a power of two.\n   58  \t///\n   59: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n   60  \t/// @tparam T Floating-point or integer scalar types\n   61  \t/// @tparam Q Value from qualifier enum\n   ..\n   75  \t/// round down to a power of two.\n   76  \t///\n   77: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n   78  \t/// @tparam T Floating-point or integer scalar types\n   79  \t/// @tparam Q Value from qualifier enum\n   ..\n   91  \t/// Return the power of two number which value is the closet to the input value.\n   92  \t///\n   93: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n   94  \t/// @tparam T Floating-point or integer scalar types\n   95  \t/// @tparam Q Value from qualifier enum\n   ..\n  107  \t/// Return true if the 'Value' is a multiple of 'Multiple'.\n  108  \t///\n  109: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  110  \t/// @tparam T Floating-point or integer scalar types\n  111  \t/// @tparam Q Value from qualifier enum\n  ...\n  117  \t/// Return true if the 'Value' is a multiple of 'Multiple'.\n  118  \t///\n  119: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  120  \t/// @tparam T Floating-point or integer scalar types\n  121  \t/// @tparam Q Value from qualifier enum\n  ...\n  127  \t/// Higher multiple number of Source.\n  128  \t///\n  129: \t/// @tparam genType Floating-point or integer scalar or vector types.\n  130  \t///\n  131  \t/// @param v Source value to which is applied the function\n  ...\n  138  \t/// Higher multiple number of Source.\n  139  \t///\n  140: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  141  \t/// @tparam T Floating-point or integer scalar types\n  142  \t/// @tparam Q Value from qualifier enum\n  ...\n  151  \t/// Lower multiple number of Source.\n  152  \t///\n  153: \t/// @tparam genType Floating-point or integer scalar or vector types.\n  154  \t///\n  155  \t/// @param v Source value to which is applied the function\n  ...\n  162  \t/// Lower multiple number of Source.\n  163  \t///\n  164: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  165  \t/// @tparam T Floating-point or integer scalar types\n  166  \t/// @tparam Q Value from qualifier enum\n  ...\n  175  \t/// Lower multiple number of Source.\n  176  \t///\n  177: \t/// @tparam genType Floating-point or integer scalar or vector types.\n  178  \t///\n  179  \t/// @param v Source value to which is applied the function\n  ...\n  186  \t/// Lower multiple number of Source.\n  187  \t///\n  188: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  189  \t/// @tparam T Floating-point or integer scalar types\n  190  \t/// @tparam Q Value from qualifier enum\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtc/round.inl:\n   29  \t\tGLM_FUNC_QUALIFIER static vec<L, T, Q> call(vec<L, T, Q> const& x)\n   30  \t\t{\n   31: \t\t\tGLM_STATIC_ASSERT(!std::numeric_limits<T>::is_iec559, \"'ceilPowerOfTwo' only accept integer scalar or vector inputs\");\n   32  \n   33  \t\t\tvec<L, T, Q> const Sign(sign(x));\n   ..\n   51  \t\tGLM_FUNC_QUALIFIER static vec<L, T, Q> call(vec<L, T, Q> const& x)\n   52  \t\t{\n   53: \t\t\tGLM_STATIC_ASSERT(!std::numeric_limits<T>::is_iec559, \"'ceilPowerOfTwo' only accept integer scalar or vector inputs\");\n   54  \n   55  \t\t\tvec<L, T, Q> v(x);\n   ..\n  253  \tGLM_FUNC_QUALIFIER vec<L, T, Q> floorPowerOfTwo(vec<L, T, Q> const& v)\n  254  \t{\n  255: \t\treturn detail::functor1<vec, L, T, T, Q>::call(floorPowerOfTwo, v);\n  256  \t}\n  257  \n  ...\n  273  \tGLM_FUNC_QUALIFIER vec<L, T, Q> roundPowerOfTwo(vec<L, T, Q> const& v)\n  274  \t{\n  275: \t\treturn detail::functor1<vec, L, T, T, Q>::call(roundPowerOfTwo, v);\n  276  \t}\n  277  \n  ...\n  309  \tGLM_FUNC_QUALIFIER vec<L, T, Q> ceilMultiple(vec<L, T, Q> const& Source, vec<L, T, Q> const& Multiple)\n  310  \t{\n  311: \t\treturn detail::functor2<vec, L, T, Q>::call(ceilMultiple, Source, Multiple);\n  312  \t}\n  313  \n  ...\n  324  \tGLM_FUNC_QUALIFIER vec<L, T, Q> floorMultiple(vec<L, T, Q> const& Source, vec<L, T, Q> const& Multiple)\n  325  \t{\n  326: \t\treturn detail::functor2<vec, L, T, Q>::call(floorMultiple, Source, Multiple);\n  327  \t}\n  328  \n  ...\n  339  \tGLM_FUNC_QUALIFIER vec<L, T, Q> roundMultiple(vec<L, T, Q> const& Source, vec<L, T, Q> const& Multiple)\n  340  \t{\n  341: \t\treturn detail::functor2<vec, L, T, Q>::call(roundMultiple, Source, Multiple);\n  342  \t}\n  343  }//namespace glm\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtc/type_aligned.hpp:\n    9  /// Include <glm/gtc/type_aligned.hpp> to use the features of this extension.\n   10  ///\n   11: /// Aligned types allowing SIMD optimizations of vectors and matrices types\n   12  \n   13  #pragma once\n   ..\n   42  \t// -- *vec1 --\n   43  \n   44: \t/// 1 component vector aligned in memory of single-precision floating-point numbers using high precision arithmetic in term of ULPs.\n   45  \ttypedef vec<1, float, aligned_highp>\taligned_highp_vec1;\n   46  \n   47: \t/// 1 component vector aligned in memory of single-precision floating-point numbers using medium precision arithmetic in term of ULPs.\n   48  \ttypedef vec<1, float, aligned_mediump>\taligned_mediump_vec1;\n   49  \n   50: \t/// 1 component vector aligned in memory of single-precision floating-point numbers using low precision arithmetic in term of ULPs.\n   51  \ttypedef vec<1, float, aligned_lowp>\t\taligned_lowp_vec1;\n   52  \n   53: \t/// 1 component vector aligned in memory of double-precision floating-point numbers using high precision arithmetic in term of ULPs.\n   54  \ttypedef vec<1, double, aligned_highp>\taligned_highp_dvec1;\n   55  \n   56: \t/// 1 component vector aligned in memory of double-precision floating-point numbers using medium precision arithmetic in term of ULPs.\n   57  \ttypedef vec<1, double, aligned_mediump>\taligned_mediump_dvec1;\n   58  \n   59: \t/// 1 component vector aligned in memory of double-precision floating-point numbers using low precision arithmetic in term of ULPs.\n   60  \ttypedef vec<1, double, aligned_lowp>\taligned_lowp_dvec1;\n   61  \n   62: \t/// 1 component vector aligned in memory of signed integer numbers.\n   63  \ttypedef vec<1, int, aligned_highp>\t\taligned_highp_ivec1;\n   64  \n   65: \t/// 1 component vector aligned in memory of signed integer numbers.\n   66  \ttypedef vec<1, int, aligned_mediump>\taligned_mediump_ivec1;\n   67  \n   68: \t/// 1 component vector aligned in memory of signed integer numbers.\n   69  \ttypedef vec<1, int, aligned_lowp>\t\taligned_lowp_ivec1;\n   70  \n   71: \t/// 1 component vector aligned in memory of unsigned integer numbers.\n   72  \ttypedef vec<1, uint, aligned_highp>\t\taligned_highp_uvec1;\n   73  \n   74: \t/// 1 component vector aligned in memory of unsigned integer numbers.\n   75  \ttypedef vec<1, uint, aligned_mediump>\taligned_mediump_uvec1;\n   76  \n   77: \t/// 1 component vector aligned in memory of unsigned integer numbers.\n   78  \ttypedef vec<1, uint, aligned_lowp>\t\taligned_lowp_uvec1;\n   79  \n   80: \t/// 1 component vector aligned in memory of bool values.\n   81  \ttypedef vec<1, bool, aligned_highp>\t\taligned_highp_bvec1;\n   82  \n   83: \t/// 1 component vector aligned in memory of bool values.\n   84  \ttypedef vec<1, bool, aligned_mediump>\taligned_mediump_bvec1;\n   85  \n   86: \t/// 1 component vector aligned in memory of bool values.\n   87  \ttypedef vec<1, bool, aligned_lowp>\t\taligned_lowp_bvec1;\n   88  \n   89: \t/// 1 component vector tightly packed in memory of single-precision floating-point numbers using high precision arithmetic in term of ULPs.\n   90  \ttypedef vec<1, float, packed_highp>\t\tpacked_highp_vec1;\n   91  \n   92: \t/// 1 component vector tightly packed in memory of single-precision floating-point numbers using medium precision arithmetic in term of ULPs.\n   93  \ttypedef vec<1, float, packed_mediump>\tpacked_mediump_vec1;\n   94  \n   95: \t/// 1 component vector tightly packed in memory of single-precision floating-point numbers using low precision arithmetic in term of ULPs.\n   96  \ttypedef vec<1, float, packed_lowp>\t\tpacked_lowp_vec1;\n   97  \n   98: \t/// 1 component vector tightly packed in memory of double-precision floating-point numbers using high precision arithmetic in term of ULPs.\n   99  \ttypedef vec<1, double, packed_highp>\tpacked_highp_dvec1;\n  100  \n  101: \t/// 1 component vector tightly packed in memory of double-precision floating-point numbers using medium precision arithmetic in term of ULPs.\n  102  \ttypedef vec<1, double, packed_mediump>\tpacked_mediump_dvec1;\n  103  \n  104: \t/// 1 component vector tightly packed in memory of double-precision floating-point numbers using low precision arithmetic in term of ULPs.\n  105  \ttypedef vec<1, double, packed_lowp>\t\tpacked_lowp_dvec1;\n  106  \n  107: \t/// 1 component vector tightly packed in memory of signed integer numbers.\n  108  \ttypedef vec<1, int, packed_highp>\t\tpacked_highp_ivec1;\n  109  \n  110: \t/// 1 component vector tightly packed in memory of signed integer numbers.\n  111  \ttypedef vec<1, int, packed_mediump>\t\tpacked_mediump_ivec1;\n  112  \n  113: \t/// 1 component vector tightly packed in memory of signed integer numbers.\n  114  \ttypedef vec<1, int, packed_lowp>\t\tpacked_lowp_ivec1;\n  115  \n  116: \t/// 1 component vector tightly packed in memory of unsigned integer numbers.\n  117  \ttypedef vec<1, uint, packed_highp>\t\tpacked_highp_uvec1;\n  118  \n  119: \t/// 1 component vector tightly packed in memory of unsigned integer numbers.\n  120  \ttypedef vec<1, uint, packed_mediump>\tpacked_mediump_uvec1;\n  121  \n  122: \t/// 1 component vector tightly packed in memory of unsigned integer numbers.\n  123  \ttypedef vec<1, uint, packed_lowp>\t\tpacked_lowp_uvec1;\n  124  \n  125: \t/// 1 component vector tightly packed in memory of bool values.\n  126  \ttypedef vec<1, bool, packed_highp>\t\tpacked_highp_bvec1;\n  127  \n  128: \t/// 1 component vector tightly packed in memory of bool values.\n  129  \ttypedef vec<1, bool, packed_mediump>\tpacked_mediump_bvec1;\n  130  \n  131: \t/// 1 component vector tightly packed in memory of bool values.\n  132  \ttypedef vec<1, bool, packed_lowp>\t\tpacked_lowp_bvec1;\n  133  \n  134  \t// -- *vec2 --\n  135  \n  136: \t/// 2 components vector aligned in memory of single-precision floating-point numbers using high precision arithmetic in term of ULPs.\n  137  \ttypedef vec<2, float, aligned_highp>\taligned_highp_vec2;\n  138  \n  139: \t/// 2 components vector aligned in memory of single-precision floating-point numbers using medium precision arithmetic in term of ULPs.\n  140  \ttypedef vec<2, float, aligned_mediump>\taligned_mediump_vec2;\n  141  \n  142: \t/// 2 components vector aligned in memory of single-precision floating-point numbers using low precision arithmetic in term of ULPs.\n  143  \ttypedef vec<2, float, aligned_lowp>\t\taligned_lowp_vec2;\n  144  \n  145: \t/// 2 components vector aligned in memory of double-precision floating-point numbers using high precision arithmetic in term of ULPs.\n  146  \ttypedef vec<2, double, aligned_highp>\taligned_highp_dvec2;\n  147  \n  148: \t/// 2 components vector aligned in memory of double-precision floating-point numbers using medium precision arithmetic in term of ULPs.\n  149  \ttypedef vec<2, double, aligned_mediump>\taligned_mediump_dvec2;\n  150  \n  151: \t/// 2 components vector aligned in memory of double-precision floating-point numbers using low precision arithmetic in term of ULPs.\n  152  \ttypedef vec<2, double, aligned_lowp>\taligned_lowp_dvec2;\n  153  \n  154: \t/// 2 components vector aligned in memory of signed integer numbers.\n  155  \ttypedef vec<2, int, aligned_highp>\t\taligned_highp_ivec2;\n  156  \n  157: \t/// 2 components vector aligned in memory of signed integer numbers.\n  158  \ttypedef vec<2, int, aligned_mediump>\taligned_mediump_ivec2;\n  159  \n  160: \t/// 2 components vector aligned in memory of signed integer numbers.\n  161  \ttypedef vec<2, int, aligned_lowp>\t\taligned_lowp_ivec2;\n  162  \n  163: \t/// 2 components vector aligned in memory of unsigned integer numbers.\n  164  \ttypedef vec<2, uint, aligned_highp>\t\taligned_highp_uvec2;\n  165  \n  166: \t/// 2 components vector aligned in memory of unsigned integer numbers.\n  167  \ttypedef vec<2, uint, aligned_mediump>\taligned_mediump_uvec2;\n  168  \n  169: \t/// 2 components vector aligned in memory of unsigned integer numbers.\n  170  \ttypedef vec<2, uint, aligned_lowp>\t\taligned_lowp_uvec2;\n  171  \n  172: \t/// 2 components vector aligned in memory of bool values.\n  173  \ttypedef vec<2, bool, aligned_highp>\t\taligned_highp_bvec2;\n  174  \n  175: \t/// 2 components vector aligned in memory of bool values.\n  176  \ttypedef vec<2, bool, aligned_mediump>\taligned_mediump_bvec2;\n  177  \n  178: \t/// 2 components vector aligned in memory of bool values.\n  179  \ttypedef vec<2, bool, aligned_lowp>\t\taligned_lowp_bvec2;\n  180  \n  181: \t/// 2 components vector tightly packed in memory of single-precision floating-point numbers using high precision arithmetic in term of ULPs.\n  182  \ttypedef vec<2, float, packed_highp>\t\tpacked_highp_vec2;\n  183  \n  184: \t/// 2 components vector tightly packed in memory of single-precision floating-point numbers using medium precision arithmetic in term of ULPs.\n  185  \ttypedef vec<2, float, packed_mediump>\tpacked_mediump_vec2;\n  186  \n  187: \t/// 2 components vector tightly packed in memory of single-precision floating-point numbers using low precision arithmetic in term of ULPs.\n  188  \ttypedef vec<2, float, packed_lowp>\t\tpacked_lowp_vec2;\n  189  \n  190: \t/// 2 components vector tightly packed in memory of double-precision floating-point numbers using high precision arithmetic in term of ULPs.\n  191  \ttypedef vec<2, double, packed_highp>\tpacked_highp_dvec2;\n  192  \n  193: \t/// 2 components vector tightly packed in memory of double-precision floating-point numbers using medium precision arithmetic in term of ULPs.\n  194  \ttypedef vec<2, double, packed_mediump>\tpacked_mediump_dvec2;\n  195  \n  196: \t/// 2 components vector tightly packed in memory of double-precision floating-point numbers using low precision arithmetic in term of ULPs.\n  197  \ttypedef vec<2, double, packed_lowp>\t\tpacked_lowp_dvec2;\n  198  \n  199: \t/// 2 components vector tightly packed in memory of signed integer numbers.\n  200  \ttypedef vec<2, int, packed_highp>\t\tpacked_highp_ivec2;\n  201  \n  202: \t/// 2 components vector tightly packed in memory of signed integer numbers.\n  203  \ttypedef vec<2, int, packed_mediump>\t\tpacked_mediump_ivec2;\n  204  \n  205: \t/// 2 components vector tightly packed in memory of signed integer numbers.\n  206  \ttypedef vec<2, int, packed_lowp>\t\tpacked_lowp_ivec2;\n  207  \n  208: \t/// 2 components vector tightly packed in memory of unsigned integer numbers.\n  209  \ttypedef vec<2, uint, packed_highp>\t\tpacked_highp_uvec2;\n  210  \n  211: \t/// 2 components vector tightly packed in memory of unsigned integer numbers.\n  212  \ttypedef vec<2, uint, packed_mediump>\tpacked_mediump_uvec2;\n  213  \n  214: \t/// 2 components vector tightly packed in memory of unsigned integer numbers.\n  215  \ttypedef vec<2, uint, packed_lowp>\t\tpacked_lowp_uvec2;\n  216  \n  217: \t/// 2 components vector tightly packed in memory of bool values.\n  218  \ttypedef vec<2, bool, packed_highp>\t\tpacked_highp_bvec2;\n  219  \n  220: \t/// 2 components vector tightly packed in memory of bool values.\n  221  \ttypedef vec<2, bool, packed_mediump>\tpacked_mediump_bvec2;\n  222  \n  223: \t/// 2 components vector tightly packed in memory of bool values.\n  224  \ttypedef vec<2, bool, packed_lowp>\t\tpacked_lowp_bvec2;\n  225  \n  226  \t// -- *vec3 --\n  227  \n  228: \t/// 3 components vector aligned in memory of single-precision floating-point numbers using high precision arithmetic in term of ULPs.\n  229  \ttypedef vec<3, float, aligned_highp>\taligned_highp_vec3;\n  230  \n  231: \t/// 3 components vector aligned in memory of single-precision floating-point numbers using medium precision arithmetic in term of ULPs.\n  232  \ttypedef vec<3, float, aligned_mediump>\taligned_mediump_vec3;\n  233  \n  234: \t/// 3 components vector aligned in memory of single-precision floating-point numbers using low precision arithmetic in term of ULPs.\n  235  \ttypedef vec<3, float, aligned_lowp>\t\taligned_lowp_vec3;\n  236  \n  237: \t/// 3 components vector aligned in memory of double-precision floating-point numbers using high precision arithmetic in term of ULPs.\n  238  \ttypedef vec<3, double, aligned_highp>\taligned_highp_dvec3;\n  239  \n  240: \t/// 3 components vector aligned in memory of double-precision floating-point numbers using medium precision arithmetic in term of ULPs.\n  241  \ttypedef vec<3, double, aligned_mediump>\taligned_mediump_dvec3;\n  242  \n  243: \t/// 3 components vector aligned in memory of double-precision floating-point numbers using low precision arithmetic in term of ULPs.\n  244  \ttypedef vec<3, double, aligned_lowp>\taligned_lowp_dvec3;\n  245  \n  246: \t/// 3 components vector aligned in memory of signed integer numbers.\n  247  \ttypedef vec<3, int, aligned_highp>\t\taligned_highp_ivec3;\n  248  \n  249: \t/// 3 components vector aligned in memory of signed integer numbers.\n  250  \ttypedef vec<3, int, aligned_mediump>\taligned_mediump_ivec3;\n  251  \n  252: \t/// 3 components vector aligned in memory of signed integer numbers.\n  253  \ttypedef vec<3, int, aligned_lowp>\t\taligned_lowp_ivec3;\n  254  \n  255: \t/// 3 components vector aligned in memory of unsigned integer numbers.\n  256  \ttypedef vec<3, uint, aligned_highp>\t\taligned_highp_uvec3;\n  257  \n  258: \t/// 3 components vector aligned in memory of unsigned integer numbers.\n  259  \ttypedef vec<3, uint, aligned_mediump>\taligned_mediump_uvec3;\n  260  \n  261: \t/// 3 components vector aligned in memory of unsigned integer numbers.\n  262  \ttypedef vec<3, uint, aligned_lowp>\t\taligned_lowp_uvec3;\n  263  \n  264: \t/// 3 components vector aligned in memory of bool values.\n  265  \ttypedef vec<3, bool, aligned_highp>\t\taligned_highp_bvec3;\n  266  \n  267: \t/// 3 components vector aligned in memory of bool values.\n  268  \ttypedef vec<3, bool, aligned_mediump>\taligned_mediump_bvec3;\n  269  \n  270: \t/// 3 components vector aligned in memory of bool values.\n  271  \ttypedef vec<3, bool, aligned_lowp>\t\taligned_lowp_bvec3;\n  272  \n  273: \t/// 3 components vector tightly packed in memory of single-precision floating-point numbers using high precision arithmetic in term of ULPs.\n  274  \ttypedef vec<3, float, packed_highp>\t\tpacked_highp_vec3;\n  275  \n  276: \t/// 3 components vector tightly packed in memory of single-precision floating-point numbers using medium precision arithmetic in term of ULPs.\n  277  \ttypedef vec<3, float, packed_mediump>\tpacked_mediump_vec3;\n  278  \n  279: \t/// 3 components vector tightly packed in memory of single-precision floating-point numbers using low precision arithmetic in term of ULPs.\n  280  \ttypedef vec<3, float, packed_lowp>\t\tpacked_lowp_vec3;\n  281  \n  282: \t/// 3 components vector tightly packed in memory of double-precision floating-point numbers using high precision arithmetic in term of ULPs.\n  283  \ttypedef vec<3, double, packed_highp>\tpacked_highp_dvec3;\n  284  \n  285: \t/// 3 components vector tightly packed in memory of double-precision floating-point numbers using medium precision arithmetic in term of ULPs.\n  286  \ttypedef vec<3, double, packed_mediump>\tpacked_mediump_dvec3;\n  287  \n  288: \t/// 3 components vector tightly packed in memory of double-precision floating-point numbers using low precision arithmetic in term of ULPs.\n  289  \ttypedef vec<3, double, packed_lowp>\t\tpacked_lowp_dvec3;\n  290  \n  291: \t/// 3 components vector tightly packed in memory of signed integer numbers.\n  292  \ttypedef vec<3, int, packed_highp>\t\tpacked_highp_ivec3;\n  293  \n  294: \t/// 3 components vector tightly packed in memory of signed integer numbers.\n  295  \ttypedef vec<3, int, packed_mediump>\t\tpacked_mediump_ivec3;\n  296  \n  297: \t/// 3 components vector tightly packed in memory of signed integer numbers.\n  298  \ttypedef vec<3, int, packed_lowp>\t\tpacked_lowp_ivec3;\n  299  \n  300: \t/// 3 components vector tightly packed in memory of unsigned integer numbers.\n  301  \ttypedef vec<3, uint, packed_highp>\t\tpacked_highp_uvec3;\n  302  \n  303: \t/// 3 components vector tightly packed in memory of unsigned integer numbers.\n  304  \ttypedef vec<3, uint, packed_mediump>\tpacked_mediump_uvec3;\n  305  \n  306: \t/// 3 components vector tightly packed in memory of unsigned integer numbers.\n  307  \ttypedef vec<3, uint, packed_lowp>\t\tpacked_lowp_uvec3;\n  308  \n  309: \t/// 3 components vector tightly packed in memory of bool values.\n  310  \ttypedef vec<3, bool, packed_highp>\t\tpacked_highp_bvec3;\n  311  \n  312: \t/// 3 components vector tightly packed in memory of bool values.\n  313  \ttypedef vec<3, bool, packed_mediump>\tpacked_mediump_bvec3;\n  314  \n  315: \t/// 3 components vector tightly packed in memory of bool values.\n  316  \ttypedef vec<3, bool, packed_lowp>\t\tpacked_lowp_bvec3;\n  317  \n  318  \t// -- *vec4 --\n  319  \n  320: \t/// 4 components vector aligned in memory of single-precision floating-point numbers using high precision arithmetic in term of ULPs.\n  321  \ttypedef vec<4, float, aligned_highp>\taligned_highp_vec4;\n  322  \n  323: \t/// 4 components vector aligned in memory of single-precision floating-point numbers using medium precision arithmetic in term of ULPs.\n  324  \ttypedef vec<4, float, aligned_mediump>\taligned_mediump_vec4;\n  325  \n  326: \t/// 4 components vector aligned in memory of single-precision floating-point numbers using low precision arithmetic in term of ULPs.\n  327  \ttypedef vec<4, float, aligned_lowp>\t\taligned_lowp_vec4;\n  328  \n  329: \t/// 4 components vector aligned in memory of double-precision floating-point numbers using high precision arithmetic in term of ULPs.\n  330  \ttypedef vec<4, double, aligned_highp>\taligned_highp_dvec4;\n  331  \n  332: \t/// 4 components vector aligned in memory of double-precision floating-point numbers using medium precision arithmetic in term of ULPs.\n  333  \ttypedef vec<4, double, aligned_mediump>\taligned_mediump_dvec4;\n  334  \n  335: \t/// 4 components vector aligned in memory of double-precision floating-point numbers using low precision arithmetic in term of ULPs.\n  336  \ttypedef vec<4, double, aligned_lowp>\taligned_lowp_dvec4;\n  337  \n  338: \t/// 4 components vector aligned in memory of signed integer numbers.\n  339  \ttypedef vec<4, int, aligned_highp>\t\taligned_highp_ivec4;\n  340  \n  341: \t/// 4 components vector aligned in memory of signed integer numbers.\n  342  \ttypedef vec<4, int, aligned_mediump>\taligned_mediump_ivec4;\n  343  \n  344: \t/// 4 components vector aligned in memory of signed integer numbers.\n  345  \ttypedef vec<4, int, aligned_lowp>\t\taligned_lowp_ivec4;\n  346  \n  347: \t/// 4 components vector aligned in memory of unsigned integer numbers.\n  348  \ttypedef vec<4, uint, aligned_highp>\t\taligned_highp_uvec4;\n  349  \n  350: \t/// 4 components vector aligned in memory of unsigned integer numbers.\n  351  \ttypedef vec<4, uint, aligned_mediump>\taligned_mediump_uvec4;\n  352  \n  353: \t/// 4 components vector aligned in memory of unsigned integer numbers.\n  354  \ttypedef vec<4, uint, aligned_lowp>\t\taligned_lowp_uvec4;\n  355  \n  356: \t/// 4 components vector aligned in memory of bool values.\n  357  \ttypedef vec<4, bool, aligned_highp>\t\taligned_highp_bvec4;\n  358  \n  359: \t/// 4 components vector aligned in memory of bool values.\n  360  \ttypedef vec<4, bool, aligned_mediump>\taligned_mediump_bvec4;\n  361  \n  362: \t/// 4 components vector aligned in memory of bool values.\n  363  \ttypedef vec<4, bool, aligned_lowp>\t\taligned_lowp_bvec4;\n  364  \n  365: \t/// 4 components vector tightly packed in memory of single-precision floating-point numbers using high precision arithmetic in term of ULPs.\n  366  \ttypedef vec<4, float, packed_highp>\t\tpacked_highp_vec4;\n  367  \n  368: \t/// 4 components vector tightly packed in memory of single-precision floating-point numbers using medium precision arithmetic in term of ULPs.\n  369  \ttypedef vec<4, float, packed_mediump>\tpacked_mediump_vec4;\n  370  \n  371: \t/// 4 components vector tightly packed in memory of single-precision floating-point numbers using low precision arithmetic in term of ULPs.\n  372  \ttypedef vec<4, float, packed_lowp>\t\tpacked_lowp_vec4;\n  373  \n  374: \t/// 4 components vector tightly packed in memory of double-precision floating-point numbers using high precision arithmetic in term of ULPs.\n  375  \ttypedef vec<4, double, packed_highp>\tpacked_highp_dvec4;\n  376  \n  377: \t/// 4 components vector tightly packed in memory of double-precision floating-point numbers using medium precision arithmetic in term of ULPs.\n  378  \ttypedef vec<4, double, packed_mediump>\tpacked_mediump_dvec4;\n  379  \n  380: \t/// 4 components vector tightly packed in memory of double-precision floating-point numbers using low precision arithmetic in term of ULPs.\n  381  \ttypedef vec<4, double, packed_lowp>\t\tpacked_lowp_dvec4;\n  382  \n  383: \t/// 4 components vector tightly packed in memory of signed integer numbers.\n  384  \ttypedef vec<4, int, packed_highp>\t\tpacked_highp_ivec4;\n  385  \n  386: \t/// 4 components vector tightly packed in memory of signed integer numbers.\n  387  \ttypedef vec<4, int, packed_mediump>\t\tpacked_mediump_ivec4;\n  388  \n  389: \t/// 4 components vector tightly packed in memory of signed integer numbers.\n  390  \ttypedef vec<4, int, packed_lowp>\t\tpacked_lowp_ivec4;\n  391  \n  392: \t/// 4 components vector tightly packed in memory of unsigned integer numbers.\n  393  \ttypedef vec<4, uint, packed_highp>\t\tpacked_highp_uvec4;\n  394  \n  395: \t/// 4 components vector tightly packed in memory of unsigned integer numbers.\n  396  \ttypedef vec<4, uint, packed_mediump>\tpacked_mediump_uvec4;\n  397  \n  398: \t/// 4 components vector tightly packed in memory of unsigned integer numbers.\n  399  \ttypedef vec<4, uint, packed_lowp>\t\tpacked_lowp_uvec4;\n  400  \n  401: \t/// 4 components vector tightly packed in memory of bool values.\n  402  \ttypedef vec<4, bool, packed_highp>\t\tpacked_highp_bvec4;\n  403  \n  404: \t/// 4 components vector tightly packed in memory of bool values.\n  405  \ttypedef vec<4, bool, packed_mediump>\tpacked_mediump_bvec4;\n  406  \n  407: \t/// 4 components vector tightly packed in memory of bool values.\n  408  \ttypedef vec<4, bool, packed_lowp>\t\tpacked_lowp_bvec4;\n  409  \n  ...\n  937  \ttypedef packed_mediump_mat4x4\t\tpacked_mat4x4;\n  938  #else //defined(GLM_PRECISION_HIGHP_FLOAT)\n  939: \t/// 1 component vector aligned in memory of single-precision floating-point numbers.\n  940  \ttypedef aligned_highp_vec1\t\t\taligned_vec1;\n  941  \n  942: \t/// 2 components vector aligned in memory of single-precision floating-point numbers.\n  943  \ttypedef aligned_highp_vec2\t\t\taligned_vec2;\n  944  \n  945: \t/// 3 components vector aligned in memory of single-precision floating-point numbers.\n  946  \ttypedef aligned_highp_vec3\t\t\taligned_vec3;\n  947  \n  948: \t/// 4 components vector aligned in memory of single-precision floating-point numbers.\n  949  \ttypedef aligned_highp_vec4 \t\t\taligned_vec4;\n  950  \n  951: \t/// 1 component vector tightly packed in memory of single-precision floating-point numbers.\n  952  \ttypedef packed_highp_vec1\t\t\tpacked_vec1;\n  953  \n  954: \t/// 2 components vector tightly packed in memory of single-precision floating-point numbers.\n  955  \ttypedef packed_highp_vec2\t\t\tpacked_vec2;\n  956  \n  957: \t/// 3 components vector tightly packed in memory of single-precision floating-point numbers.\n  958  \ttypedef packed_highp_vec3\t\t\tpacked_vec3;\n  959  \n  960: \t/// 4 components vector tightly packed in memory of single-precision floating-point numbers.\n  961  \ttypedef packed_highp_vec4\t\t\tpacked_vec4;\n  962  \n  ...\n 1105  \ttypedef packed_mediump_dmat4x4\t\tpacked_dmat4x4;\n 1106  #else //defined(GLM_PRECISION_HIGHP_DOUBLE)\n 1107: \t/// 1 component vector aligned in memory of double-precision floating-point numbers.\n 1108  \ttypedef aligned_highp_dvec1\t\t\taligned_dvec1;\n 1109  \n 1110: \t/// 2 components vector aligned in memory of double-precision floating-point numbers.\n 1111  \ttypedef aligned_highp_dvec2\t\t\taligned_dvec2;\n 1112  \n 1113: \t/// 3 components vector aligned in memory of double-precision floating-point numbers.\n 1114  \ttypedef aligned_highp_dvec3\t\t\taligned_dvec3;\n 1115  \n 1116: \t/// 4 components vector aligned in memory of double-precision floating-point numbers.\n 1117  \ttypedef aligned_highp_dvec4\t\t\taligned_dvec4;\n 1118  \n 1119: \t/// 1 component vector tightly packed in memory of double-precision floating-point numbers.\n 1120  \ttypedef packed_highp_dvec1\t\t\tpacked_dvec1;\n 1121  \n 1122: \t/// 2 components vector tightly packed in memory of double-precision floating-point numbers.\n 1123  \ttypedef packed_highp_dvec2\t\t\tpacked_dvec2;\n 1124  \n 1125: \t/// 3 components vector tightly packed in memory of double-precision floating-point numbers.\n 1126  \ttypedef packed_highp_dvec3\t\t\tpacked_dvec3;\n 1127  \n 1128: \t/// 4 components vector tightly packed in memory of double-precision floating-point numbers.\n 1129  \ttypedef packed_highp_dvec4\t\t\tpacked_dvec4;\n 1130  \n ....\n 1213  \ttypedef aligned_mediump_ivec4\t\taligned_ivec4;\n 1214  #else //defined(GLM_PRECISION_HIGHP_INT)\n 1215: \t/// 1 component vector aligned in memory of signed integer numbers.\n 1216  \ttypedef aligned_highp_ivec1\t\t\taligned_ivec1;\n 1217  \n 1218: \t/// 2 components vector aligned in memory of signed integer numbers.\n 1219  \ttypedef aligned_highp_ivec2\t\t\taligned_ivec2;\n 1220  \n 1221: \t/// 3 components vector aligned in memory of signed integer numbers.\n 1222  \ttypedef aligned_highp_ivec3\t\t\taligned_ivec3;\n 1223  \n 1224: \t/// 4 components vector aligned in memory of signed integer numbers.\n 1225  \ttypedef aligned_highp_ivec4\t\t\taligned_ivec4;\n 1226  \n 1227: \t/// 1 component vector tightly packed in memory of signed integer numbers.\n 1228  \ttypedef packed_highp_ivec1\t\t\tpacked_ivec1;\n 1229  \n 1230: \t/// 2 components vector tightly packed in memory of signed integer numbers.\n 1231  \ttypedef packed_highp_ivec2\t\t\tpacked_ivec2;\n 1232  \n 1233: \t/// 3 components vector tightly packed in memory of signed integer numbers.\n 1234  \ttypedef packed_highp_ivec3\t\t\tpacked_ivec3;\n 1235  \n 1236: \t/// 4 components vector tightly packed in memory of signed integer numbers.\n 1237  \ttypedef packed_highp_ivec4\t\t\tpacked_ivec4;\n 1238  #endif//GLM_PRECISION\n ....\n 1251  \ttypedef aligned_mediump_uvec4\t\taligned_uvec4;\n 1252  #else //defined(GLM_PRECISION_HIGHP_UINT)\n 1253: \t/// 1 component vector aligned in memory of unsigned integer numbers.\n 1254  \ttypedef aligned_highp_uvec1\t\t\taligned_uvec1;\n 1255  \n 1256: \t/// 2 components vector aligned in memory of unsigned integer numbers.\n 1257  \ttypedef aligned_highp_uvec2\t\t\taligned_uvec2;\n 1258  \n 1259: \t/// 3 components vector aligned in memory of unsigned integer numbers.\n 1260  \ttypedef aligned_highp_uvec3\t\t\taligned_uvec3;\n 1261  \n 1262: \t/// 4 components vector aligned in memory of unsigned integer numbers.\n 1263  \ttypedef aligned_highp_uvec4\t\t\taligned_uvec4;\n 1264  \n 1265: \t/// 1 component vector tightly packed in memory of unsigned integer numbers.\n 1266  \ttypedef packed_highp_uvec1\t\t\tpacked_uvec1;\n 1267  \n 1268: \t/// 2 components vector tightly packed in memory of unsigned integer numbers.\n 1269  \ttypedef packed_highp_uvec2\t\t\tpacked_uvec2;\n 1270  \n 1271: \t/// 3 components vector tightly packed in memory of unsigned integer numbers.\n 1272  \ttypedef packed_highp_uvec3\t\t\tpacked_uvec3;\n 1273  \n 1274: \t/// 4 components vector tightly packed in memory of unsigned integer numbers.\n 1275  \ttypedef packed_highp_uvec4\t\t\tpacked_uvec4;\n 1276  #endif//GLM_PRECISION\n ....\n 1287  \ttypedef aligned_mediump_bvec4\t\taligned_bvec4;\n 1288  #else //defined(GLM_PRECISION_HIGHP_BOOL)\n 1289: \t/// 1 component vector aligned in memory of bool values.\n 1290  \ttypedef aligned_highp_bvec1\t\t\taligned_bvec1;\n 1291  \n 1292: \t/// 2 components vector aligned in memory of bool values.\n 1293  \ttypedef aligned_highp_bvec2\t\t\taligned_bvec2;\n 1294  \n 1295: \t/// 3 components vector aligned in memory of bool values.\n 1296  \ttypedef aligned_highp_bvec3\t\t\taligned_bvec3;\n 1297  \n 1298: \t/// 4 components vector aligned in memory of bool values.\n 1299  \ttypedef aligned_highp_bvec4\t\t\taligned_bvec4;\n 1300  \n 1301: \t/// 1 components vector tightly packed in memory of bool values.\n 1302  \ttypedef packed_highp_bvec1\t\t\tpacked_bvec1;\n 1303  \n 1304: \t/// 2 components vector tightly packed in memory of bool values.\n 1305  \ttypedef packed_highp_bvec2\t\t\tpacked_bvec2;\n 1306  \n 1307: \t/// 3 components vector tightly packed in memory of bool values.\n 1308  \ttypedef packed_highp_bvec3\t\t\tpacked_bvec3;\n 1309  \n 1310: \t/// 4 components vector tightly packed in memory of bool values.\n 1311  \ttypedef packed_highp_bvec4\t\t\tpacked_bvec4;\n 1312  #endif//GLM_PRECISION\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtc/type_precision.hpp:\n   40  {\n   41  \t///////////////////////////\n   42: \t// Signed int vector types\n   43  \n   44  \t/// @addtogroup gtc_type_precision\n   ..\n  235  \ttypedef vec<1, i8, lowp> lowp_i8vec1;\n  236  \n  237: \t/// Low qualifier 8 bit signed integer vector of 2 components type.\n  238  \t/// @see gtc_type_precision\n  239  \ttypedef vec<2, i8, lowp> lowp_i8vec2;\n  240  \n  241: \t/// Low qualifier 8 bit signed integer vector of 3 components type.\n  242  \t/// @see gtc_type_precision\n  243  \ttypedef vec<3, i8, lowp> lowp_i8vec3;\n  244  \n  245: \t/// Low qualifier 8 bit signed integer vector of 4 components type.\n  246  \t/// @see gtc_type_precision\n  247  \ttypedef vec<4, i8, lowp> lowp_i8vec4;\n  ...\n  252  \ttypedef vec<1, i8, mediump> mediump_i8vec1;\n  253  \n  254: \t/// Medium qualifier 8 bit signed integer vector of 2 components type.\n  255  \t/// @see gtc_type_precision\n  256  \ttypedef vec<2, i8, mediump> mediump_i8vec2;\n  257  \n  258: \t/// Medium qualifier 8 bit signed integer vector of 3 components type.\n  259  \t/// @see gtc_type_precision\n  260  \ttypedef vec<3, i8, mediump> mediump_i8vec3;\n  261  \n  262: \t/// Medium qualifier 8 bit signed integer vector of 4 components type.\n  263  \t/// @see gtc_type_precision\n  264  \ttypedef vec<4, i8, mediump> mediump_i8vec4;\n  ...\n  269  \ttypedef vec<1, i8, highp> highp_i8vec1;\n  270  \n  271: \t/// High qualifier 8 bit signed integer vector of 2 components type.\n  272  \t/// @see gtc_type_precision\n  273  \ttypedef vec<2, i8, highp> highp_i8vec2;\n  274  \n  275: \t/// High qualifier 8 bit signed integer vector of 3 components type.\n  276  \t/// @see gtc_type_precision\n  277  \ttypedef vec<3, i8, highp> highp_i8vec3;\n  278  \n  279: \t/// High qualifier 8 bit signed integer vector of 4 components type.\n  280  \t/// @see gtc_type_precision\n  281  \ttypedef vec<4, i8, highp> highp_i8vec4;\n  ...\n  287  \ttypedef vec<1, i8, defaultp> i8vec1;\n  288  \n  289: \t/// 8 bit signed integer vector of 2 components type.\n  290  \t/// @see gtc_type_precision\n  291  \ttypedef vec<2, i8, defaultp> i8vec2;\n  292  \n  293: \t/// 8 bit signed integer vector of 3 components type.\n  294  \t/// @see gtc_type_precision\n  295  \ttypedef vec<3, i8, defaultp> i8vec3;\n  296  \n  297: \t/// 8 bit signed integer vector of 4 components type.\n  298  \t/// @see gtc_type_precision\n  299  \ttypedef vec<4, i8, defaultp> i8vec4;\n  ...\n  307  \ttypedef vec<1, i16, lowp>\t\tlowp_i16vec1;\n  308  \n  309: \t/// Low qualifier 16 bit signed integer vector of 2 components type.\n  310  \t/// @see gtc_type_precision\n  311  \ttypedef vec<2, i16, lowp>\t\tlowp_i16vec2;\n  312  \n  313: \t/// Low qualifier 16 bit signed integer vector of 3 components type.\n  314  \t/// @see gtc_type_precision\n  315  \ttypedef vec<3, i16, lowp>\t\tlowp_i16vec3;\n  316  \n  317: \t/// Low qualifier 16 bit signed integer vector of 4 components type.\n  318  \t/// @see gtc_type_precision\n  319  \ttypedef vec<4, i16, lowp>\t\tlowp_i16vec4;\n  ...\n  324  \ttypedef vec<1, i16, mediump>\t\tmediump_i16vec1;\n  325  \n  326: \t/// Medium qualifier 16 bit signed integer vector of 2 components type.\n  327  \t/// @see gtc_type_precision\n  328  \ttypedef vec<2, i16, mediump>\t\tmediump_i16vec2;\n  329  \n  330: \t/// Medium qualifier 16 bit signed integer vector of 3 components type.\n  331  \t/// @see gtc_type_precision\n  332  \ttypedef vec<3, i16, mediump>\t\tmediump_i16vec3;\n  333  \n  334: \t/// Medium qualifier 16 bit signed integer vector of 4 components type.\n  335  \t/// @see gtc_type_precision\n  336  \ttypedef vec<4, i16, mediump>\t\tmediump_i16vec4;\n  ...\n  341  \ttypedef vec<1, i16, highp>\t\thighp_i16vec1;\n  342  \n  343: \t/// High qualifier 16 bit signed integer vector of 2 components type.\n  344  \t/// @see gtc_type_precision\n  345  \ttypedef vec<2, i16, highp>\t\thighp_i16vec2;\n  346  \n  347: \t/// High qualifier 16 bit signed integer vector of 3 components type.\n  348  \t/// @see gtc_type_precision\n  349  \ttypedef vec<3, i16, highp>\t\thighp_i16vec3;\n  350  \n  351: \t/// High qualifier 16 bit signed integer vector of 4 components type.\n  352  \t/// @see gtc_type_precision\n  353  \ttypedef vec<4, i16, highp>\t\thighp_i16vec4;\n  ...\n  360  \ttypedef vec<1, i16, defaultp> i16vec1;\n  361  \n  362: \t/// 16 bit signed integer vector of 2 components type.\n  363  \t/// @see gtc_type_precision\n  364  \ttypedef vec<2, i16, defaultp> i16vec2;\n  365  \n  366: \t/// 16 bit signed integer vector of 3 components type.\n  367  \t/// @see gtc_type_precision\n  368  \ttypedef vec<3, i16, defaultp> i16vec3;\n  369  \n  370: \t/// 16 bit signed integer vector of 4 components type.\n  371  \t/// @see gtc_type_precision\n  372  \ttypedef vec<4, i16, defaultp> i16vec4;\n  ...\n  378  \ttypedef vec<1, i32, lowp>\t\tlowp_i32vec1;\n  379  \n  380: \t/// Low qualifier 32 bit signed integer vector of 2 components type.\n  381  \t/// @see gtc_type_precision\n  382  \ttypedef vec<2, i32, lowp>\t\tlowp_i32vec2;\n  383  \n  384: \t/// Low qualifier 32 bit signed integer vector of 3 components type.\n  385  \t/// @see gtc_type_precision\n  386  \ttypedef vec<3, i32, lowp>\t\tlowp_i32vec3;\n  387  \n  388: \t/// Low qualifier 32 bit signed integer vector of 4 components type.\n  389  \t/// @see gtc_type_precision\n  390  \ttypedef vec<4, i32, lowp>\t\tlowp_i32vec4;\n  ...\n  395  \ttypedef vec<1, i32, mediump>\t\tmediump_i32vec1;\n  396  \n  397: \t/// Medium qualifier 32 bit signed integer vector of 2 components type.\n  398  \t/// @see gtc_type_precision\n  399  \ttypedef vec<2, i32, mediump>\t\tmediump_i32vec2;\n  400  \n  401: \t/// Medium qualifier 32 bit signed integer vector of 3 components type.\n  402  \t/// @see gtc_type_precision\n  403  \ttypedef vec<3, i32, mediump>\t\tmediump_i32vec3;\n  404  \n  405: \t/// Medium qualifier 32 bit signed integer vector of 4 components type.\n  406  \t/// @see gtc_type_precision\n  407  \ttypedef vec<4, i32, mediump>\t\tmediump_i32vec4;\n  ...\n  412  \ttypedef vec<1, i32, highp>\t\thighp_i32vec1;\n  413  \n  414: \t/// High qualifier 32 bit signed integer vector of 2 components type.\n  415  \t/// @see gtc_type_precision\n  416  \ttypedef vec<2, i32, highp>\t\thighp_i32vec2;\n  417  \n  418: \t/// High qualifier 32 bit signed integer vector of 3 components type.\n  419  \t/// @see gtc_type_precision\n  420  \ttypedef vec<3, i32, highp>\t\thighp_i32vec3;\n  421  \n  422: \t/// High qualifier 32 bit signed integer vector of 4 components type.\n  423  \t/// @see gtc_type_precision\n  424  \ttypedef vec<4, i32, highp>\t\thighp_i32vec4;\n  ...\n  429  \ttypedef vec<1, i32, defaultp> i32vec1;\n  430  \n  431: \t/// 32 bit signed integer vector of 2 components type.\n  432  \t/// @see gtc_type_precision\n  433  \ttypedef vec<2, i32, defaultp> i32vec2;\n  434  \n  435: \t/// 32 bit signed integer vector of 3 components type.\n  436  \t/// @see gtc_type_precision\n  437  \ttypedef vec<3, i32, defaultp> i32vec3;\n  438  \n  439: \t/// 32 bit signed integer vector of 4 components type.\n  440  \t/// @see gtc_type_precision\n  441  \ttypedef vec<4, i32, defaultp> i32vec4;\n  ...\n  448  \ttypedef vec<1, i64, lowp>\t\tlowp_i64vec1;\n  449  \n  450: \t/// Low qualifier 64 bit signed integer vector of 2 components type.\n  451  \t/// @see gtc_type_precision\n  452  \ttypedef vec<2, i64, lowp>\t\tlowp_i64vec2;\n  453  \n  454: \t/// Low qualifier 64 bit signed integer vector of 3 components type.\n  455  \t/// @see gtc_type_precision\n  456  \ttypedef vec<3, i64, lowp>\t\tlowp_i64vec3;\n  457  \n  458: \t/// Low qualifier 64 bit signed integer vector of 4 components type.\n  459  \t/// @see gtc_type_precision\n  460  \ttypedef vec<4, i64, lowp>\t\tlowp_i64vec4;\n  ...\n  465  \ttypedef vec<1, i64, mediump>\t\tmediump_i64vec1;\n  466  \n  467: \t/// Medium qualifier 64 bit signed integer vector of 2 components type.\n  468  \t/// @see gtc_type_precision\n  469  \ttypedef vec<2, i64, mediump>\t\tmediump_i64vec2;\n  470  \n  471: \t/// Medium qualifier 64 bit signed integer vector of 3 components type.\n  472  \t/// @see gtc_type_precision\n  473  \ttypedef vec<3, i64, mediump>\t\tmediump_i64vec3;\n  474  \n  475: \t/// Medium qualifier 64 bit signed integer vector of 4 components type.\n  476  \t/// @see gtc_type_precision\n  477  \ttypedef vec<4, i64, mediump>\t\tmediump_i64vec4;\n  ...\n  482  \ttypedef vec<1, i64, highp>\t\thighp_i64vec1;\n  483  \n  484: \t/// High qualifier 64 bit signed integer vector of 2 components type.\n  485  \t/// @see gtc_type_precision\n  486  \ttypedef vec<2, i64, highp>\t\thighp_i64vec2;\n  487  \n  488: \t/// High qualifier 64 bit signed integer vector of 3 components type.\n  489  \t/// @see gtc_type_precision\n  490  \ttypedef vec<3, i64, highp>\t\thighp_i64vec3;\n  491  \n  492: \t/// High qualifier 64 bit signed integer vector of 4 components type.\n  493  \t/// @see gtc_type_precision\n  494  \ttypedef vec<4, i64, highp>\t\thighp_i64vec4;\n  ...\n  499  \ttypedef vec<1, i64, defaultp> i64vec1;\n  500  \n  501: \t/// 64 bit signed integer vector of 2 components type.\n  502  \t/// @see gtc_type_precision\n  503  \ttypedef vec<2, i64, defaultp> i64vec2;\n  504  \n  505: \t/// 64 bit signed integer vector of 3 components type.\n  506  \t/// @see gtc_type_precision\n  507  \ttypedef vec<3, i64, defaultp> i64vec3;\n  508  \n  509: \t/// 64 bit signed integer vector of 4 components type.\n  510  \t/// @see gtc_type_precision\n  511  \ttypedef vec<4, i64, defaultp> i64vec4;\n  ...\n  513  \n  514  \t/////////////////////////////\n  515: \t// Unsigned int vector types\n  516  \n  517  \t/// Low qualifier 8 bit unsigned integer type.\n  ...\n  703  \n  704  \t//////////////////////\n  705: \t// Float vector types\n  706  \n  707  \t/// Low 32 bit single-qualifier floating-point scalar.\n  ...\n  883  \n  884  \n  885: \t/// Low single-qualifier floating-point vector of 1 component.\n  886  \t/// @see gtc_type_precision\n  887  \ttypedef vec<1, float, lowp> lowp_fvec1;\n  888  \n  889: \t/// Low single-qualifier floating-point vector of 2 components.\n  890  \t/// @see gtc_type_precision\n  891  \ttypedef vec<2, float, lowp> lowp_fvec2;\n  892  \n  893: \t/// Low single-qualifier floating-point vector of 3 components.\n  894  \t/// @see gtc_type_precision\n  895  \ttypedef vec<3, float, lowp> lowp_fvec3;\n  896  \n  897: \t/// Low single-qualifier floating-point vector of 4 components.\n  898  \t/// @see gtc_type_precision\n  899  \ttypedef vec<4, float, lowp> lowp_fvec4;\n  900  \n  901  \n  902: \t/// Medium single-qualifier floating-point vector of 1 component.\n  903  \t/// @see gtc_type_precision\n  904  \ttypedef vec<1, float, mediump> mediump_fvec1;\n  905  \n  906: \t/// Medium Single-qualifier floating-point vector of 2 components.\n  907  \t/// @see gtc_type_precision\n  908  \ttypedef vec<2, float, mediump> mediump_fvec2;\n  909  \n  910: \t/// Medium Single-qualifier floating-point vector of 3 components.\n  911  \t/// @see gtc_type_precision\n  912  \ttypedef vec<3, float, mediump> mediump_fvec3;\n  913  \n  914: \t/// Medium Single-qualifier floating-point vector of 4 components.\n  915  \t/// @see gtc_type_precision\n  916  \ttypedef vec<4, float, mediump> mediump_fvec4;\n  917  \n  918  \n  919: \t/// High single-qualifier floating-point vector of 1 component.\n  920  \t/// @see gtc_type_precision\n  921  \ttypedef vec<1, float, highp> highp_fvec1;\n  922  \n  923: \t/// High Single-qualifier floating-point vector of 2 components.\n  924  \t/// @see core_precision\n  925  \ttypedef vec<2, float, highp> highp_fvec2;\n  926  \n  927: \t/// High Single-qualifier floating-point vector of 3 components.\n  928  \t/// @see core_precision\n  929  \ttypedef vec<3, float, highp> highp_fvec3;\n  930  \n  931: \t/// High Single-qualifier floating-point vector of 4 components.\n  932  \t/// @see core_precision\n  933  \ttypedef vec<4, float, highp> highp_fvec4;\n  934  \n  935  \n  936: \t/// Low single-qualifier floating-point vector of 1 component.\n  937  \t/// @see gtc_type_precision\n  938  \ttypedef vec<1, f32, lowp> lowp_f32vec1;\n  939  \n  940: \t/// Low single-qualifier floating-point vector of 2 components.\n  941  \t/// @see core_precision\n  942  \ttypedef vec<2, f32, lowp> lowp_f32vec2;\n  943  \n  944: \t/// Low single-qualifier floating-point vector of 3 components.\n  945  \t/// @see core_precision\n  946  \ttypedef vec<3, f32, lowp> lowp_f32vec3;\n  947  \n  948: \t/// Low single-qualifier floating-point vector of 4 components.\n  949  \t/// @see core_precision\n  950  \ttypedef vec<4, f32, lowp> lowp_f32vec4;\n  951  \n  952: \t/// Medium single-qualifier floating-point vector of 1 component.\n  953  \t/// @see gtc_type_precision\n  954  \ttypedef vec<1, f32, mediump> mediump_f32vec1;\n  955  \n  956: \t/// Medium single-qualifier floating-point vector of 2 components.\n  957  \t/// @see core_precision\n  958  \ttypedef vec<2, f32, mediump> mediump_f32vec2;\n  959  \n  960: \t/// Medium single-qualifier floating-point vector of 3 components.\n  961  \t/// @see core_precision\n  962  \ttypedef vec<3, f32, mediump> mediump_f32vec3;\n  963  \n  964: \t/// Medium single-qualifier floating-point vector of 4 components.\n  965  \t/// @see core_precision\n  966  \ttypedef vec<4, f32, mediump> mediump_f32vec4;\n  967  \n  968: \t/// High single-qualifier floating-point vector of 1 component.\n  969  \t/// @see gtc_type_precision\n  970  \ttypedef vec<1, f32, highp> highp_f32vec1;\n  971  \n  972: \t/// High single-qualifier floating-point vector of 2 components.\n  973  \t/// @see gtc_type_precision\n  974  \ttypedef vec<2, f32, highp> highp_f32vec2;\n  975  \n  976: \t/// High single-qualifier floating-point vector of 3 components.\n  977  \t/// @see gtc_type_precision\n  978  \ttypedef vec<3, f32, highp> highp_f32vec3;\n  979  \n  980: \t/// High single-qualifier floating-point vector of 4 components.\n  981  \t/// @see gtc_type_precision\n  982  \ttypedef vec<4, f32, highp> highp_f32vec4;\n  983  \n  984  \n  985: \t/// Low double-qualifier floating-point vector of 1 component.\n  986  \t/// @see gtc_type_precision\n  987  \ttypedef vec<1, f64, lowp> lowp_f64vec1;\n  988  \n  989: \t/// Low double-qualifier floating-point vector of 2 components.\n  990  \t/// @see gtc_type_precision\n  991  \ttypedef vec<2, f64, lowp> lowp_f64vec2;\n  992  \n  993: \t/// Low double-qualifier floating-point vector of 3 components.\n  994  \t/// @see gtc_type_precision\n  995  \ttypedef vec<3, f64, lowp> lowp_f64vec3;\n  996  \n  997: \t/// Low double-qualifier floating-point vector of 4 components.\n  998  \t/// @see gtc_type_precision\n  999  \ttypedef vec<4, f64, lowp> lowp_f64vec4;\n 1000  \n 1001: \t/// Medium double-qualifier floating-point vector of 1 component.\n 1002  \t/// @see gtc_type_precision\n 1003  \ttypedef vec<1, f64, mediump> mediump_f64vec1;\n 1004  \n 1005: \t/// Medium double-qualifier floating-point vector of 2 components.\n 1006  \t/// @see gtc_type_precision\n 1007  \ttypedef vec<2, f64, mediump> mediump_f64vec2;\n 1008  \n 1009: \t/// Medium double-qualifier floating-point vector of 3 components.\n 1010  \t/// @see gtc_type_precision\n 1011  \ttypedef vec<3, f64, mediump> mediump_f64vec3;\n 1012  \n 1013: \t/// Medium double-qualifier floating-point vector of 4 components.\n 1014  \t/// @see gtc_type_precision\n 1015  \ttypedef vec<4, f64, mediump> mediump_f64vec4;\n 1016  \n 1017: \t/// High double-qualifier floating-point vector of 1 component.\n 1018  \t/// @see gtc_type_precision\n 1019  \ttypedef vec<1, f64, highp> highp_f64vec1;\n 1020  \n 1021: \t/// High double-qualifier floating-point vector of 2 components.\n 1022  \t/// @see gtc_type_precision\n 1023  \ttypedef vec<2, f64, highp> highp_f64vec2;\n 1024  \n 1025: \t/// High double-qualifier floating-point vector of 3 components.\n 1026  \t/// @see gtc_type_precision\n 1027  \ttypedef vec<3, f64, highp> highp_f64vec3;\n 1028  \n 1029: \t/// High double-qualifier floating-point vector of 4 components.\n 1030  \t/// @see gtc_type_precision\n 1031  \ttypedef vec<4, f64, highp> highp_f64vec4;\n ....\n 1554  \ttypedef vec<1, u8, lowp> lowp_u8vec1;\n 1555  \n 1556: \t/// Low qualifier 8 bit unsigned integer vector of 2 components type.\n 1557  \t/// @see gtc_type_precision\n 1558  \ttypedef vec<2, u8, lowp> lowp_u8vec2;\n 1559  \n 1560: \t/// Low qualifier 8 bit unsigned integer vector of 3 components type.\n 1561  \t/// @see gtc_type_precision\n 1562  \ttypedef vec<3, u8, lowp> lowp_u8vec3;\n 1563  \n 1564: \t/// Low qualifier 8 bit unsigned integer vector of 4 components type.\n 1565  \t/// @see gtc_type_precision\n 1566  \ttypedef vec<4, u8, lowp> lowp_u8vec4;\n ....\n 1571  \ttypedef vec<1, u8, mediump> mediump_u8vec1;\n 1572  \n 1573: \t/// Medium qualifier 8 bit unsigned integer vector of 2 components type.\n 1574  \t/// @see gtc_type_precision\n 1575  \ttypedef vec<2, u8, mediump> mediump_u8vec2;\n 1576  \n 1577: \t/// Medium qualifier 8 bit unsigned integer vector of 3 components type.\n 1578  \t/// @see gtc_type_precision\n 1579  \ttypedef vec<3, u8, mediump> mediump_u8vec3;\n 1580  \n 1581: \t/// Medium qualifier 8 bit unsigned integer vector of 4 components type.\n 1582  \t/// @see gtc_type_precision\n 1583  \ttypedef vec<4, u8, mediump> mediump_u8vec4;\n ....\n 1588  \ttypedef vec<1, u8, highp> highp_u8vec1;\n 1589  \n 1590: \t/// High qualifier 8 bit unsigned integer vector of 2 components type.\n 1591  \t/// @see gtc_type_precision\n 1592  \ttypedef vec<2, u8, highp> highp_u8vec2;\n 1593  \n 1594: \t/// High qualifier 8 bit unsigned integer vector of 3 components type.\n 1595  \t/// @see gtc_type_precision\n 1596  \ttypedef vec<3, u8, highp> highp_u8vec3;\n 1597  \n 1598: \t/// High qualifier 8 bit unsigned integer vector of 4 components type.\n 1599  \t/// @see gtc_type_precision\n 1600  \ttypedef vec<4, u8, highp> highp_u8vec4;\n ....\n 1606  \ttypedef vec<1, u8, defaultp> u8vec1;\n 1607  \n 1608: \t/// Default qualifier 8 bit unsigned integer vector of 2 components type.\n 1609  \t/// @see gtc_type_precision\n 1610  \ttypedef vec<2, u8, defaultp> u8vec2;\n 1611  \n 1612: \t/// Default qualifier 8 bit unsigned integer vector of 3 components type.\n 1613  \t/// @see gtc_type_precision\n 1614  \ttypedef vec<3, u8, defaultp> u8vec3;\n 1615  \n 1616: \t/// Default qualifier 8 bit unsigned integer vector of 4 components type.\n 1617  \t/// @see gtc_type_precision\n 1618  \ttypedef vec<4, u8, defaultp> u8vec4;\n ....\n 1625  \ttypedef vec<1, u16, lowp>\t\tlowp_u16vec1;\n 1626  \n 1627: \t/// Low qualifier 16 bit unsigned integer vector of 2 components type.\n 1628  \t/// @see gtc_type_precision\n 1629  \ttypedef vec<2, u16, lowp>\t\tlowp_u16vec2;\n 1630  \n 1631: \t/// Low qualifier 16 bit unsigned integer vector of 3 components type.\n 1632  \t/// @see gtc_type_precision\n 1633  \ttypedef vec<3, u16, lowp>\t\tlowp_u16vec3;\n 1634  \n 1635: \t/// Low qualifier 16 bit unsigned integer vector of 4 components type.\n 1636  \t/// @see gtc_type_precision\n 1637  \ttypedef vec<4, u16, lowp>\t\tlowp_u16vec4;\n ....\n 1642  \ttypedef vec<1, u16, mediump>\t\tmediump_u16vec1;\n 1643  \n 1644: \t/// Medium qualifier 16 bit unsigned integer vector of 2 components type.\n 1645  \t/// @see gtc_type_precision\n 1646  \ttypedef vec<2, u16, mediump>\t\tmediump_u16vec2;\n 1647  \n 1648: \t/// Medium qualifier 16 bit unsigned integer vector of 3 components type.\n 1649  \t/// @see gtc_type_precision\n 1650  \ttypedef vec<3, u16, mediump>\t\tmediump_u16vec3;\n 1651  \n 1652: \t/// Medium qualifier 16 bit unsigned integer vector of 4 components type.\n 1653  \t/// @see gtc_type_precision\n 1654  \ttypedef vec<4, u16, mediump>\t\tmediump_u16vec4;\n ....\n 1659  \ttypedef vec<1, u16, highp>\t\thighp_u16vec1;\n 1660  \n 1661: \t/// High qualifier 16 bit unsigned integer vector of 2 components type.\n 1662  \t/// @see gtc_type_precision\n 1663  \ttypedef vec<2, u16, highp>\t\thighp_u16vec2;\n 1664  \n 1665: \t/// High qualifier 16 bit unsigned integer vector of 3 components type.\n 1666  \t/// @see gtc_type_precision\n 1667  \ttypedef vec<3, u16, highp>\t\thighp_u16vec3;\n 1668  \n 1669: \t/// High qualifier 16 bit unsigned integer vector of 4 components type.\n 1670  \t/// @see gtc_type_precision\n 1671  \ttypedef vec<4, u16, highp>\t\thighp_u16vec4;\n ....\n 1678  \ttypedef vec<1, u16, defaultp> u16vec1;\n 1679  \n 1680: \t/// Default qualifier 16 bit unsigned integer vector of 2 components type.\n 1681  \t/// @see gtc_type_precision\n 1682  \ttypedef vec<2, u16, defaultp> u16vec2;\n 1683  \n 1684: \t/// Default qualifier 16 bit unsigned integer vector of 3 components type.\n 1685  \t/// @see gtc_type_precision\n 1686  \ttypedef vec<3, u16, defaultp> u16vec3;\n 1687  \n 1688: \t/// Default qualifier 16 bit unsigned integer vector of 4 components type.\n 1689  \t/// @see gtc_type_precision\n 1690  \ttypedef vec<4, u16, defaultp> u16vec4;\n ....\n 1696  \ttypedef vec<1, u32, lowp>\t\tlowp_u32vec1;\n 1697  \n 1698: \t/// Low qualifier 32 bit unsigned integer vector of 2 components type.\n 1699  \t/// @see gtc_type_precision\n 1700  \ttypedef vec<2, u32, lowp>\t\tlowp_u32vec2;\n 1701  \n 1702: \t/// Low qualifier 32 bit unsigned integer vector of 3 components type.\n 1703  \t/// @see gtc_type_precision\n 1704  \ttypedef vec<3, u32, lowp>\t\tlowp_u32vec3;\n 1705  \n 1706: \t/// Low qualifier 32 bit unsigned integer vector of 4 components type.\n 1707  \t/// @see gtc_type_precision\n 1708  \ttypedef vec<4, u32, lowp>\t\tlowp_u32vec4;\n ....\n 1713  \ttypedef vec<1, u32, mediump>\t\tmediump_u32vec1;\n 1714  \n 1715: \t/// Medium qualifier 32 bit unsigned integer vector of 2 components type.\n 1716  \t/// @see gtc_type_precision\n 1717  \ttypedef vec<2, u32, mediump>\t\tmediump_u32vec2;\n 1718  \n 1719: \t/// Medium qualifier 32 bit unsigned integer vector of 3 components type.\n 1720  \t/// @see gtc_type_precision\n 1721  \ttypedef vec<3, u32, mediump>\t\tmediump_u32vec3;\n 1722  \n 1723: \t/// Medium qualifier 32 bit unsigned integer vector of 4 components type.\n 1724  \t/// @see gtc_type_precision\n 1725  \ttypedef vec<4, u32, mediump>\t\tmediump_u32vec4;\n ....\n 1730  \ttypedef vec<1, u32, highp>\t\thighp_u32vec1;\n 1731  \n 1732: \t/// High qualifier 32 bit unsigned integer vector of 2 components type.\n 1733  \t/// @see gtc_type_precision\n 1734  \ttypedef vec<2, u32, highp>\t\thighp_u32vec2;\n 1735  \n 1736: \t/// High qualifier 32 bit unsigned integer vector of 3 components type.\n 1737  \t/// @see gtc_type_precision\n 1738  \ttypedef vec<3, u32, highp>\t\thighp_u32vec3;\n 1739  \n 1740: \t/// High qualifier 32 bit unsigned integer vector of 4 components type.\n 1741  \t/// @see gtc_type_precision\n 1742  \ttypedef vec<4, u32, highp>\t\thighp_u32vec4;\n ....\n 1748  \ttypedef vec<1, u32, defaultp> u32vec1;\n 1749  \n 1750: \t/// Default qualifier 32 bit unsigned integer vector of 2 components type.\n 1751  \t/// @see gtc_type_precision\n 1752  \ttypedef vec<2, u32, defaultp> u32vec2;\n 1753  \n 1754: \t/// Default qualifier 32 bit unsigned integer vector of 3 components type.\n 1755  \t/// @see gtc_type_precision\n 1756  \ttypedef vec<3, u32, defaultp> u32vec3;\n 1757  \n 1758: \t/// Default qualifier 32 bit unsigned integer vector of 4 components type.\n 1759  \t/// @see gtc_type_precision\n 1760  \ttypedef vec<4, u32, defaultp> u32vec4;\n ....\n 1767  \ttypedef vec<1, u64, lowp>\t\tlowp_u64vec1;\n 1768  \n 1769: \t/// Low qualifier 64 bit unsigned integer vector of 2 components type.\n 1770  \t/// @see gtc_type_precision\n 1771  \ttypedef vec<2, u64, lowp>\t\tlowp_u64vec2;\n 1772  \n 1773: \t/// Low qualifier 64 bit unsigned integer vector of 3 components type.\n 1774  \t/// @see gtc_type_precision\n 1775  \ttypedef vec<3, u64, lowp>\t\tlowp_u64vec3;\n 1776  \n 1777: \t/// Low qualifier 64 bit unsigned integer vector of 4 components type.\n 1778  \t/// @see gtc_type_precision\n 1779  \ttypedef vec<4, u64, lowp>\t\tlowp_u64vec4;\n ....\n 1784  \ttypedef vec<1, u64, mediump>\t\tmediump_u64vec1;\n 1785  \n 1786: \t/// Medium qualifier 64 bit unsigned integer vector of 2 components type.\n 1787  \t/// @see gtc_type_precision\n 1788  \ttypedef vec<2, u64, mediump>\t\tmediump_u64vec2;\n 1789  \n 1790: \t/// Medium qualifier 64 bit unsigned integer vector of 3 components type.\n 1791  \t/// @see gtc_type_precision\n 1792  \ttypedef vec<3, u64, mediump>\t\tmediump_u64vec3;\n 1793  \n 1794: \t/// Medium qualifier 64 bit unsigned integer vector of 4 components type.\n 1795  \t/// @see gtc_type_precision\n 1796  \ttypedef vec<4, u64, mediump>\t\tmediump_u64vec4;\n ....\n 1801  \ttypedef vec<1, u64, highp>\t\thighp_u64vec1;\n 1802  \n 1803: \t/// High qualifier 64 bit unsigned integer vector of 2 components type.\n 1804  \t/// @see gtc_type_precision\n 1805  \ttypedef vec<2, u64, highp>\t\thighp_u64vec2;\n 1806  \n 1807: \t/// High qualifier 64 bit unsigned integer vector of 3 components type.\n 1808  \t/// @see gtc_type_precision\n 1809  \ttypedef vec<3, u64, highp>\t\thighp_u64vec3;\n 1810  \n 1811: \t/// High qualifier 64 bit unsigned integer vector of 4 components type.\n 1812  \t/// @see gtc_type_precision\n 1813  \ttypedef vec<4, u64, highp>\t\thighp_u64vec4;\n ....\n 1820  \ttypedef vec<1, u64, defaultp> u64vec1;\n 1821  \n 1822: \t/// Default qualifier 64 bit unsigned integer vector of 2 components type.\n 1823  \t/// @see gtc_type_precision\n 1824  \ttypedef vec<2, u64, defaultp> u64vec2;\n 1825  \n 1826: \t/// Default qualifier 64 bit unsigned integer vector of 3 components type.\n 1827  \t/// @see gtc_type_precision\n 1828  \ttypedef vec<3, u64, defaultp> u64vec3;\n 1829  \n 1830: \t/// Default qualifier 64 bit unsigned integer vector of 4 components type.\n 1831  \t/// @see gtc_type_precision\n 1832  \ttypedef vec<4, u64, defaultp> u64vec4;\n ....\n 1834  \n 1835  \t//////////////////////\n 1836: \t// Float vector types\n 1837  \n 1838  \t/// 32 bit single-qualifier floating-point scalar.\n ....\n 1855  #\tendif//GLM_FORCE_SINGLE_ONLY\n 1856  \n 1857: \t/// Single-qualifier floating-point vector of 1 component.\n 1858  \t/// @see gtc_type_precision\n 1859  \ttypedef vec<1, float, defaultp> fvec1;\n 1860  \n 1861: \t/// Single-qualifier floating-point vector of 2 components.\n 1862  \t/// @see gtc_type_precision\n 1863  \ttypedef vec<2, float, defaultp> fvec2;\n 1864  \n 1865: \t/// Single-qualifier floating-point vector of 3 components.\n 1866  \t/// @see gtc_type_precision\n 1867  \ttypedef vec<3, float, defaultp> fvec3;\n 1868  \n 1869: \t/// Single-qualifier floating-point vector of 4 components.\n 1870  \t/// @see gtc_type_precision\n 1871  \ttypedef vec<4, float, defaultp> fvec4;\n 1872  \n 1873  \n 1874: \t/// Single-qualifier floating-point vector of 1 component.\n 1875  \t/// @see gtc_type_precision\n 1876  \ttypedef vec<1, f32, defaultp> f32vec1;\n 1877  \n 1878: \t/// Single-qualifier floating-point vector of 2 components.\n 1879  \t/// @see gtc_type_precision\n 1880  \ttypedef vec<2, f32, defaultp> f32vec2;\n 1881  \n 1882: \t/// Single-qualifier floating-point vector of 3 components.\n 1883  \t/// @see gtc_type_precision\n 1884  \ttypedef vec<3, f32, defaultp> f32vec3;\n 1885  \n 1886: \t/// Single-qualifier floating-point vector of 4 components.\n 1887  \t/// @see gtc_type_precision\n 1888  \ttypedef vec<4, f32, defaultp> f32vec4;\n 1889  \n 1890  #\tifndef GLM_FORCE_SINGLE_ONLY\n 1891: \t\t/// Double-qualifier floating-point vector of 1 component.\n 1892  \t\t/// @see gtc_type_precision\n 1893  \t\ttypedef vec<1, f64, defaultp> f64vec1;\n 1894  \n 1895: \t\t/// Double-qualifier floating-point vector of 2 components.\n 1896  \t\t/// @see gtc_type_precision\n 1897  \t\ttypedef vec<2, f64, defaultp> f64vec2;\n 1898  \n 1899: \t\t/// Double-qualifier floating-point vector of 3 components.\n 1900  \t\t/// @see gtc_type_precision\n 1901  \t\ttypedef vec<3, f64, defaultp> f64vec3;\n 1902  \n 1903: \t\t/// Double-qualifier floating-point vector of 4 components.\n 1904  \t\t/// @see gtc_type_precision\n 1905  \t\ttypedef vec<4, f64, defaultp> f64vec4;\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtc/type_ptr.hpp:\n   10  /// Include <glm/gtc/type_ptr.hpp> to use the features of this extension.\n   11  ///\n   12: /// Handles the interaction between pointers and vector, matrix types.\n   13  ///\n   14  /// This extension defines an overloaded function, glm::value_ptr. It returns\n   ..\n   23  /// #include <glm/gtc/type_ptr.hpp>\n   24  ///\n   25: /// glm::vec3 aVector(3);\n   26  /// glm::mat4 someMatrix(1.0);\n   27  ///\n   28: /// glUniform3fv(uniformLoc, 1, glm::value_ptr(aVector));\n   29  /// glUniformMatrix4fv(uniformMatrixLoc, 1, GL_FALSE, glm::value_ptr(someMatrix));\n   30  /// @endcode\n   ..\n   65  \tGLM_FUNC_DECL typename genType::value_type const * value_ptr(genType const& v);\n   66  \n   67: \t/// Build a vector from a pointer.\n   68  \t/// @see gtc_type_ptr\n   69  \ttemplate <typename T, qualifier Q>\n   70  \tGLM_FUNC_DECL vec<1, T, Q> make_vec1(vec<1, T, Q> const& v);\n   71  \n   72: \t/// Build a vector from a pointer.\n   73  \t/// @see gtc_type_ptr\n   74  \ttemplate <typename T, qualifier Q>\n   75  \tGLM_FUNC_DECL vec<1, T, Q> make_vec1(vec<2, T, Q> const& v);\n   76  \n   77: \t/// Build a vector from a pointer.\n   78  \t/// @see gtc_type_ptr\n   79  \ttemplate <typename T, qualifier Q>\n   80  \tGLM_FUNC_DECL vec<1, T, Q> make_vec1(vec<3, T, Q> const& v);\n   81  \n   82: \t/// Build a vector from a pointer.\n   83  \t/// @see gtc_type_ptr\n   84  \ttemplate <typename T, qualifier Q>\n   85  \tGLM_FUNC_DECL vec<1, T, Q> make_vec1(vec<4, T, Q> const& v);\n   86  \n   87: \t/// Build a vector from a pointer.\n   88  \t/// @see gtc_type_ptr\n   89  \ttemplate <typename T, qualifier Q>\n   90  \tGLM_FUNC_DECL vec<2, T, Q> make_vec2(vec<1, T, Q> const& v);\n   91  \n   92: \t/// Build a vector from a pointer.\n   93  \t/// @see gtc_type_ptr\n   94  \ttemplate <typename T, qualifier Q>\n   95  \tGLM_FUNC_DECL vec<2, T, Q> make_vec2(vec<2, T, Q> const& v);\n   96  \n   97: \t/// Build a vector from a pointer.\n   98  \t/// @see gtc_type_ptr\n   99  \ttemplate <typename T, qualifier Q>\n  100  \tGLM_FUNC_DECL vec<2, T, Q> make_vec2(vec<3, T, Q> const& v);\n  101  \n  102: \t/// Build a vector from a pointer.\n  103  \t/// @see gtc_type_ptr\n  104  \ttemplate <typename T, qualifier Q>\n  105  \tGLM_FUNC_DECL vec<2, T, Q> make_vec2(vec<4, T, Q> const& v);\n  106  \n  107: \t/// Build a vector from a pointer.\n  108  \t/// @see gtc_type_ptr\n  109  \ttemplate <typename T, qualifier Q>\n  110  \tGLM_FUNC_DECL vec<3, T, Q> make_vec3(vec<1, T, Q> const& v);\n  111  \n  112: \t/// Build a vector from a pointer.\n  113  \t/// @see gtc_type_ptr\n  114  \ttemplate <typename T, qualifier Q>\n  115  \tGLM_FUNC_DECL vec<3, T, Q> make_vec3(vec<2, T, Q> const& v);\n  116  \n  117: \t/// Build a vector from a pointer.\n  118  \t/// @see gtc_type_ptr\n  119  \ttemplate <typename T, qualifier Q>\n  120  \tGLM_FUNC_DECL vec<3, T, Q> make_vec3(vec<3, T, Q> const& v);\n  121  \n  122: \t/// Build a vector from a pointer.\n  123  \t/// @see gtc_type_ptr\n  124  \ttemplate <typename T, qualifier Q>\n  125  \tGLM_FUNC_DECL vec<3, T, Q> make_vec3(vec<4, T, Q> const& v);\n  126  \n  127: \t/// Build a vector from a pointer.\n  128  \t/// @see gtc_type_ptr\n  129  \ttemplate <typename T, qualifier Q>\n  130  \tGLM_FUNC_DECL vec<4, T, Q> make_vec4(vec<1, T, Q> const& v);\n  131  \n  132: \t/// Build a vector from a pointer.\n  133  \t/// @see gtc_type_ptr\n  134  \ttemplate <typename T, qualifier Q>\n  135  \tGLM_FUNC_DECL vec<4, T, Q> make_vec4(vec<2, T, Q> const& v);\n  136  \n  137: \t/// Build a vector from a pointer.\n  138  \t/// @see gtc_type_ptr\n  139  \ttemplate <typename T, qualifier Q>\n  140  \tGLM_FUNC_DECL vec<4, T, Q> make_vec4(vec<3, T, Q> const& v);\n  141  \n  142: \t/// Build a vector from a pointer.\n  143  \t/// @see gtc_type_ptr\n  144  \ttemplate <typename T, qualifier Q>\n  145  \tGLM_FUNC_DECL vec<4, T, Q> make_vec4(vec<4, T, Q> const& v);\n  146  \n  147: \t/// Build a vector from a pointer.\n  148  \t/// @see gtc_type_ptr\n  149  \ttemplate<typename T>\n  150  \tGLM_FUNC_DECL vec<2, T, defaultp> make_vec2(T const * const ptr);\n  151  \n  152: \t/// Build a vector from a pointer.\n  153  \t/// @see gtc_type_ptr\n  154  \ttemplate<typename T>\n  155  \tGLM_FUNC_DECL vec<3, T, defaultp> make_vec3(T const * const ptr);\n  156  \n  157: \t/// Build a vector from a pointer.\n  158  \t/// @see gtc_type_ptr\n  159  \ttemplate<typename T>\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtc/ulp.hpp:\n   17  // Dependencies\n   18  #include \"../gtc/constants.hpp\"\n   19: #include \"../ext/vector_relational.hpp\"\n   20  \n   21  #if GLM_MESSAGES == GLM_ENABLE && !defined(GLM_EXT_INCLUDED)\n   ..\n   53  \tGLM_FUNC_DECL uint float_distance(T const& x, T const& y);\n   54  \n   55: \t/// Return the distance in the number of ULP between 2 vectors.\n   56  \t/// @see gtc_ulp\n   57  \ttemplate<typename T, qualifier Q>\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtc/vec1.hpp:\n   14  \n   15  // Dependency:\n   16: #include \"../ext/vector_bool1.hpp\"\n   17: #include \"../ext/vector_bool1_precision.hpp\"\n   18: #include \"../ext/vector_float1.hpp\"\n   19: #include \"../ext/vector_float1_precision.hpp\"\n   20: #include \"../ext/vector_double1.hpp\"\n   21: #include \"../ext/vector_double1_precision.hpp\"\n   22: #include \"../ext/vector_int1.hpp\"\n   23: #include \"../ext/vector_int1_precision.hpp\"\n   24: #include \"../ext/vector_uint1.hpp\"\n   25: #include \"../ext/vector_uint1_precision.hpp\"\n   26  \n   27  #if GLM_MESSAGES == GLM_ENABLE && !defined(GLM_EXT_INCLUDED)\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/bit.inl:\n   22  \tGLM_FUNC_QUALIFIER vec<L, T, Q> highestBitValue(vec<L, T, Q> const& v)\n   23  \t{\n   24: \t\treturn detail::functor1<vec, L, T, T, Q>::call(highestBitValue, v);\n   25  \t}\n   26  \n   ..\n   37  \tGLM_FUNC_QUALIFIER vec<L, T, Q> lowestBitValue(vec<L, T, Q> const& v)\n   38  \t{\n   39: \t\treturn detail::functor1<vec, L, T, T, Q>::call(lowestBitValue, v);\n   40  \t}\n   41  \n   ..\n   52  \tGLM_FUNC_QUALIFIER vec<L, T, Q> powerOfTwoAbove(vec<L, T, Q> const& v)\n   53  \t{\n   54: \t\treturn detail::functor1<vec, L, T, T, Q>::call(powerOfTwoAbove, v);\n   55  \t}\n   56  \n   ..\n   67  \tGLM_FUNC_QUALIFIER vec<L, T, Q> powerOfTwoBelow(vec<L, T, Q> const& v)\n   68  \t{\n   69: \t\treturn detail::functor1<vec, L, T, T, Q>::call(powerOfTwoBelow, v);\n   70  \t}\n   71  \n   ..\n   87  \tGLM_FUNC_QUALIFIER vec<L, T, Q> powerOfTwoNearest(vec<L, T, Q> const& v)\n   88  \t{\n   89: \t\treturn detail::functor1<vec, L, T, T, Q>::call(powerOfTwoNearest, v);\n   90  \t}\n   91  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/closest_point.inl:\n   12  \t{\n   13  \t\tT LineLength = distance(a, b);\n   14: \t\tvec<3, T, Q> Vector = point - a;\n   15  \t\tvec<3, T, Q> LineDirection = (b - a) / LineLength;\n   16  \n   17: \t\t// Project Vector to LineDirection to get the distance of point from a\n   18: \t\tT Distance = dot(Vector, LineDirection);\n   19  \n   20  \t\tif(Distance <= T(0)) return a;\n   ..\n   32  \t{\n   33  \t\tT LineLength = distance(a, b);\n   34: \t\tvec<2, T, Q> Vector = point - a;\n   35  \t\tvec<2, T, Q> LineDirection = (b - a) / LineLength;\n   36  \n   37: \t\t// Project Vector to LineDirection to get the distance of point from a\n   38: \t\tT Distance = dot(Vector, LineDirection);\n   39  \n   40  \t\tif(Distance <= T(0)) return a;\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/color_space.inl:\n   14  \t\telse\n   15  \t\t{\n   16: \t\t\tT sector = floor(hsv.x * (T(1) / T(60)));\n   17: \t\t\tT frac = (hsv.x * (T(1) / T(60))) - sector;\n   18: \t\t\t// factorial part of h\n   19  \t\t\tT o = hsv.z * (T(1) - hsv.y);\n   20  \t\t\tT p = hsv.z * (T(1) - hsv.y * frac);\n   21  \t\t\tT q = hsv.z * (T(1) - hsv.y * (T(1) - frac));\n   22  \n   23: \t\t\tswitch(int(sector))\n   24  \t\t\t{\n   25  \t\t\tdefault:\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/common.hpp:\n   36  \t/// This format is less precise but can represent values closer to zero.\n   37  \t///\n   38: \t/// @tparam genType Floating-point scalar or vector types.\n   39  \t///\n   40  \t/// @see <a href=\"http://www.opengl.org/sdk/docs/manglsl/xhtml/isnan.xml\">GLSL isnan man page</a>\n   ..\n   51  \tGLM_FUNC_DECL vec<L, T, Q> fmod(vec<L, T, Q> const& v);\n   52  \n   53: \t/// Returns whether vector components values are within an interval. A open interval excludes its endpoints, and is denoted with square brackets.\n   54  \t///\n   55: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n   56  \t/// @tparam T Floating-point or integer scalar types\n   57  \t/// @tparam Q Value from qualifier enum\n   58  \t///\n   59: \t/// @see ext_vector_relational\n   60  \ttemplate <length_t L, typename T, qualifier Q>\n   61  \tGLM_FUNC_DECL vec<L, bool, Q> openBounded(vec<L, T, Q> const& Value, vec<L, T, Q> const& Min, vec<L, T, Q> const& Max);\n   62  \n   63: \t/// Returns whether vector components values are within an interval. A closed interval includes its endpoints, and is denoted with square brackets.\n   64  \t///\n   65: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n   66  \t/// @tparam T Floating-point or integer scalar types\n   67  \t/// @tparam Q Value from qualifier enum\n   68  \t///\n   69: \t/// @see ext_vector_relational\n   70  \ttemplate <length_t L, typename T, qualifier Q>\n   71  \tGLM_FUNC_DECL vec<L, bool, Q> closeBounded(vec<L, T, Q> const& Value, vec<L, T, Q> const& Min, vec<L, T, Q> const& Max);\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/common.inl:\n   13  \t\tGLM_FUNC_QUALIFIER static vec<L, T, Q> call(vec<L, T, Q> const& a, vec<L, T, Q> const& b)\n   14  \t\t{\n   15: \t\t\treturn detail::functor2<vec, L, T, Q>::call(std::fmod, a, b);\n   16  \t\t}\n   17  \t};\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/compatibility.hpp:\n   44  \ttemplate<typename T, qualifier Q> GLM_FUNC_QUALIFIER vec<3, T, Q> lerp(const vec<3, T, Q>& x, const vec<3, T, Q>& y, T a){return mix(x, y, a);}\t\t\t\t\t\t\t//!< \\brief Returns x * (1.0 - a) + y * a, i.e., the linear blend of x and y using the floating-point value a. The value for a is not restricted to the range [0, 1]. (From GLM_GTX_compatibility)\n   45  \ttemplate<typename T, qualifier Q> GLM_FUNC_QUALIFIER vec<4, T, Q> lerp(const vec<4, T, Q>& x, const vec<4, T, Q>& y, T a){return mix(x, y, a);}\t\t\t\t\t\t\t//!< \\brief Returns x * (1.0 - a) + y * a, i.e., the linear blend of x and y using the floating-point value a. The value for a is not restricted to the range [0, 1]. (From GLM_GTX_compatibility)\n   46: \ttemplate<typename T, qualifier Q> GLM_FUNC_QUALIFIER vec<2, T, Q> lerp(const vec<2, T, Q>& x, const vec<2, T, Q>& y, const vec<2, T, Q>& a){return mix(x, y, a);}\t//!< \\brief Returns the component-wise result of x * (1.0 - a) + y * a, i.e., the linear blend of x and y using vector a. The value for a is not restricted to the range [0, 1]. (From GLM_GTX_compatibility)\n   47: \ttemplate<typename T, qualifier Q> GLM_FUNC_QUALIFIER vec<3, T, Q> lerp(const vec<3, T, Q>& x, const vec<3, T, Q>& y, const vec<3, T, Q>& a){return mix(x, y, a);}\t//!< \\brief Returns the component-wise result of x * (1.0 - a) + y * a, i.e., the linear blend of x and y using vector a. The value for a is not restricted to the range [0, 1]. (From GLM_GTX_compatibility)\n   48: \ttemplate<typename T, qualifier Q> GLM_FUNC_QUALIFIER vec<4, T, Q> lerp(const vec<4, T, Q>& x, const vec<4, T, Q>& y, const vec<4, T, Q>& a){return mix(x, y, a);}\t//!< \\brief Returns the component-wise result of x * (1.0 - a) + y * a, i.e., the linear blend of x and y using vector a. The value for a is not restricted to the range [0, 1]. (From GLM_GTX_compatibility)\n   49  \n   50  \ttemplate<typename T, qualifier Q> GLM_FUNC_QUALIFIER T saturate(T x){return clamp(x, T(0), T(1));}\t\t\t\t\t\t\t\t\t\t\t\t\t\t//!< \\brief Returns clamp(x, 0, 1) for each component in x. (From GLM_GTX_compatibility)\n   ..\n   58  \ttemplate<typename T, qualifier Q> GLM_FUNC_QUALIFIER vec<4, T, Q> atan2(const vec<4, T, Q>& x, const vec<4, T, Q>& y){return atan(x, y);}\t//!< \\brief Arc tangent. Returns an angle whose tangent is y/x. The signs of x and y are used to determine what quadrant the angle is in. The range of values returned by this function is [-PI, PI]. Results are undefined if x and y are both 0. (From GLM_GTX_compatibility)\n   59  \n   60: \ttemplate<typename genType> GLM_FUNC_DECL bool isfinite(genType const& x);\t\t\t\t\t\t\t\t\t\t\t//!< \\brief Test whether or not a scalar or each vector component is a finite value. (From GLM_GTX_compatibility)\n   61: \ttemplate<typename T, qualifier Q> GLM_FUNC_DECL vec<1, bool, Q> isfinite(const vec<1, T, Q>& x);\t\t\t\t//!< \\brief Test whether or not a scalar or each vector component is a finite value. (From GLM_GTX_compatibility)\n   62: \ttemplate<typename T, qualifier Q> GLM_FUNC_DECL vec<2, bool, Q> isfinite(const vec<2, T, Q>& x);\t\t\t\t//!< \\brief Test whether or not a scalar or each vector component is a finite value. (From GLM_GTX_compatibility)\n   63: \ttemplate<typename T, qualifier Q> GLM_FUNC_DECL vec<3, bool, Q> isfinite(const vec<3, T, Q>& x);\t\t\t\t//!< \\brief Test whether or not a scalar or each vector component is a finite value. (From GLM_GTX_compatibility)\n   64: \ttemplate<typename T, qualifier Q> GLM_FUNC_DECL vec<4, bool, Q> isfinite(const vec<4, T, Q>& x);\t\t\t\t//!< \\brief Test whether or not a scalar or each vector component is a finite value. (From GLM_GTX_compatibility)\n   65  \n   66  \ttypedef bool\t\t\t\t\t\tbool1;\t\t\t//!< \\brief boolean type with 1 component. (From GLM_GTX_compatibility extension)\n   ..\n   80  \ttypedef mat<4, 4, bool, highp>\t\tbool4x4;\t\t//!< \\brief boolean matrix with 4 x 4 components. (From GLM_GTX_compatibility extension)\n   81  \n   82: \ttypedef int\t\t\t\t\t\t\tint1;\t\t\t//!< \\brief integer vector with 1 component. (From GLM_GTX_compatibility extension)\n   83: \ttypedef vec<2, int, highp>\t\t\tint2;\t\t\t//!< \\brief integer vector with 2 components. (From GLM_GTX_compatibility extension)\n   84: \ttypedef vec<3, int, highp>\t\t\tint3;\t\t\t//!< \\brief integer vector with 3 components. (From GLM_GTX_compatibility extension)\n   85: \ttypedef vec<4, int, highp>\t\t\tint4;\t\t\t//!< \\brief integer vector with 4 components. (From GLM_GTX_compatibility extension)\n   86  \n   87  \ttypedef int\t\t\t\t\t\t\tint1x1;\t\t\t//!< \\brief integer matrix with 1 component. (From GLM_GTX_compatibility extension)\n   ..\n   96  \ttypedef mat<4, 4, int, highp>\t\tint4x4;\t\t\t//!< \\brief integer matrix with 4 x 4 components. (From GLM_GTX_compatibility extension)\n   97  \n   98: \ttypedef float\t\t\t\t\t\tfloat1;\t\t\t//!< \\brief single-qualifier floating-point vector with 1 component. (From GLM_GTX_compatibility extension)\n   99: \ttypedef vec<2, float, highp>\t\tfloat2;\t\t\t//!< \\brief single-qualifier floating-point vector with 2 components. (From GLM_GTX_compatibility extension)\n  100: \ttypedef vec<3, float, highp>\t\tfloat3;\t\t\t//!< \\brief single-qualifier floating-point vector with 3 components. (From GLM_GTX_compatibility extension)\n  101: \ttypedef vec<4, float, highp>\t\tfloat4;\t\t\t//!< \\brief single-qualifier floating-point vector with 4 components. (From GLM_GTX_compatibility extension)\n  102  \n  103  \ttypedef float\t\t\t\t\t\tfloat1x1;\t\t//!< \\brief single-qualifier floating-point matrix with 1 component. (From GLM_GTX_compatibility extension)\n  ...\n  112  \ttypedef mat<4, 4, float, highp>\t\tfloat4x4;\t\t//!< \\brief single-qualifier floating-point matrix with 4 x 4 components. (From GLM_GTX_compatibility extension)\n  113  \n  114: \ttypedef double\t\t\t\t\t\tdouble1;\t\t//!< \\brief double-qualifier floating-point vector with 1 component. (From GLM_GTX_compatibility extension)\n  115: \ttypedef vec<2, double, highp>\t\tdouble2;\t\t//!< \\brief double-qualifier floating-point vector with 2 components. (From GLM_GTX_compatibility extension)\n  116: \ttypedef vec<3, double, highp>\t\tdouble3;\t\t//!< \\brief double-qualifier floating-point vector with 3 components. (From GLM_GTX_compatibility extension)\n  117: \ttypedef vec<4, double, highp>\t\tdouble4;\t\t//!< \\brief double-qualifier floating-point vector with 4 components. (From GLM_GTX_compatibility extension)\n  118  \n  119  \ttypedef double\t\t\t\t\t\tdouble1x1;\t\t//!< \\brief double-qualifier floating-point matrix with 1 component. (From GLM_GTX_compatibility extension)\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/component_wise.hpp:\n   32  \t/// @{\n   33  \n   34: \t/// Convert an integer vector to a normalized float vector.\n   35  \t/// If the parameter value type is already a floating qualifier type, the value is passed through.\n   36  \t/// @see gtx_component_wise\n   ..\n   38  \tGLM_FUNC_DECL vec<L, floatType, Q> compNormalize(vec<L, T, Q> const& v);\n   39  \n   40: \t/// Convert a normalized float vector to an integer vector.\n   41  \t/// If the parameter value type is already a floating qualifier type, the value is passed through.\n   42  \t/// @see gtx_component_wise\n   ..\n   44  \tGLM_FUNC_DECL vec<L, T, Q> compScale(vec<L, floatType, Q> const& v);\n   45  \n   46: \t/// Add all vector components together.\n   47  \t/// @see gtx_component_wise\n   48  \ttemplate<typename genType>\n   49  \tGLM_FUNC_DECL typename genType::value_type compAdd(genType const& v);\n   50  \n   51: \t/// Multiply all vector components together.\n   52  \t/// @see gtx_component_wise\n   53  \ttemplate<typename genType>\n   54  \tGLM_FUNC_DECL typename genType::value_type compMul(genType const& v);\n   55  \n   56: \t/// Find the minimum value between single vector components.\n   57  \t/// @see gtx_component_wise\n   58  \ttemplate<typename genType>\n   59  \tGLM_FUNC_DECL typename genType::value_type compMin(genType const& v);\n   60  \n   61: \t/// Find the maximum value between single vector components.\n   62  \t/// @see gtx_component_wise\n   63  \ttemplate<typename genType>\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/dual_quaternion.hpp:\n   55  \t\tGLM_FUNC_DECL part_type const& operator[](length_type i) const;\n   56  \n   57: \t\t// -- Implicit basic constructors --\n   58  \n   59  \t\tGLM_FUNC_DECL GLM_CONSTEXPR tdualquat() GLM_DEFAULT;\n   ..\n   62  \t\tGLM_FUNC_DECL GLM_CONSTEXPR tdualquat(tdualquat<T, P> const& d);\n   63  \n   64: \t\t// -- Explicit basic constructors --\n   65  \n   66  \t\tGLM_FUNC_DECL GLM_CONSTEXPR tdualquat(qua<T, Q> const& real);\n   ..\n   68  \t\tGLM_FUNC_DECL GLM_CONSTEXPR tdualquat(qua<T, Q> const& real, qua<T, Q> const& dual);\n   69  \n   70: \t\t// -- Conversion constructors --\n   71  \n   72  \t\ttemplate<typename U, qualifier P>\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/dual_quaternion.inl:\n   22  \t}\n   23  \n   24: \t// -- Implicit basic constructors --\n   25  \n   26  #\tif GLM_CONFIG_DEFAULTED_FUNCTIONS == GLM_DISABLE\n   ..\n   47  \t{}\n   48  \n   49: \t// -- Explicit basic constructors --\n   50  \n   51  \ttemplate<typename T, qualifier Q>\n   ..\n   68  \t{}\n   69  \n   70: \t// -- Conversion constructors --\n   71  \n   72  \ttemplate<typename T, qualifier Q>\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/extended_min_max.hpp:\n  133  \t/// Returns y if y < x; otherwise, it returns x. If one of the two arguments is NaN, the value of the other argument is returned.\n  134  \t///\n  135: \t/// @tparam genType Floating-point or integer; scalar or vector types.\n  136  \t///\n  137  \t/// @see gtx_extented_min_max\n  ...\n  141  \t/// Returns y if x < y; otherwise, it returns x. If one of the two arguments is NaN, the value of the other argument is returned.\n  142  \t///\n  143: \t/// @tparam genType Floating-point; scalar or vector types.\n  144  \t///\n  145  \t/// @see gtx_extented_min_max\n  ...\n  150  \t/// Returns min(max(x, minVal), maxVal) for each component in x. If one of the two arguments is NaN, the value of the other argument is returned.\n  151  \t///\n  152: \t/// @tparam genType Floating-point scalar or vector types.\n  153  \t///\n  154  \t/// @see gtx_extented_min_max\n  ...\n  158  \t/// Returns min(max(x, minVal), maxVal) for each component in x. If one of the two arguments is NaN, the value of the other argument is returned.\n  159  \t///\n  160: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  161  \t/// @tparam T Floating-point scalar types\n  162  \t/// @tparam Q Value from qualifier enum\n  ...\n  168  \t/// Returns min(max(x, minVal), maxVal) for each component in x. If one of the two arguments is NaN, the value of the other argument is returned.\n  169  \t///\n  170: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  171  \t/// @tparam T Floating-point scalar types\n  172  \t/// @tparam Q Value from qualifier enum\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/extended_min_max.inl:\n  158  \tGLM_FUNC_QUALIFIER vec<L, T, Q> fmin(vec<L, T, Q> const& a, T b)\n  159  \t{\n  160: \t\treturn detail::functor2<vec, L, T, Q>::call(fmin, a, vec<L, T, Q>(b));\n  161  \t}\n  162  \n  ...\n  164  \tGLM_FUNC_QUALIFIER vec<L, T, Q> fmin(vec<L, T, Q> const& a, vec<L, T, Q> const& b)\n  165  \t{\n  166: \t\treturn detail::functor2<vec, L, T, Q>::call(fmin, a, b);\n  167  \t}\n  168  \n  ...\n  188  \tGLM_FUNC_QUALIFIER vec<L, T, Q> fmax(vec<L, T, Q> const& a, T b)\n  189  \t{\n  190: \t\treturn detail::functor2<vec, L, T, Q>::call(fmax, a, vec<L, T, Q>(b));\n  191  \t}\n  192  \n  ...\n  194  \tGLM_FUNC_QUALIFIER vec<L, T, Q> fmax(vec<L, T, Q> const& a, vec<L, T, Q> const& b)\n  195  \t{\n  196: \t\treturn detail::functor2<vec, L, T, Q>::call(fmax, a, b);\n  197  \t}\n  198  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/fast_exponential.inl:\n   84  \tGLM_FUNC_QUALIFIER vec<L, T, Q> fastExp(vec<L, T, Q> const& x)\n   85  \t{\n   86: \t\treturn detail::functor1<vec, L, T, T, Q>::call(fastExp, x);\n   87  \t}\n   88  \n   ..\n  106  \tGLM_FUNC_QUALIFIER vec<L, T, Q> fastLog(vec<L, T, Q> const& x)\n  107  \t{\n  108: \t\treturn detail::functor1<vec, L, T, T, Q>::call(fastLog, x);\n  109  \t}\n  110  \n  ...\n  119  \tGLM_FUNC_QUALIFIER vec<L, T, Q> fastExp2(vec<L, T, Q> const& x)\n  120  \t{\n  121: \t\treturn detail::functor1<vec, L, T, T, Q>::call(fastExp2, x);\n  122  \t}\n  123  \n  ...\n  132  \tGLM_FUNC_QUALIFIER vec<L, T, Q> fastLog2(vec<L, T, Q> const& x)\n  133  \t{\n  134: \t\treturn detail::functor1<vec, L, T, T, Q>::call(fastLog2, x);\n  135  \t}\n  136  }//namespace glm\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/fast_square_root.inl:\n   15  \tGLM_FUNC_QUALIFIER vec<L, T, Q> fastSqrt(vec<L, T, Q> const& x)\n   16  \t{\n   17: \t\treturn detail::functor1<vec, L, T, T, Q>::call(fastSqrt, x);\n   18  \t}\n   19  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/fast_trigonometry.inl:\n   24  \tGLM_FUNC_QUALIFIER vec<L, T, Q> cos_52s(vec<L, T, Q> const& x)\n   25  \t{\n   26: \t\treturn detail::functor1<vec, L, T, T, Q>::call(cos_52s, x);\n   27  \t}\n   28  }//namespace detail\n   ..\n   38  \tGLM_FUNC_QUALIFIER vec<L, T, Q> wrapAngle(vec<L, T, Q> const& x)\n   39  \t{\n   40: \t\treturn detail::functor1<vec, L, T, T, Q>::call(wrapAngle, x);\n   41  \t}\n   42  \n   ..\n   60  \tGLM_FUNC_QUALIFIER vec<L, T, Q> fastCos(vec<L, T, Q> const& x)\n   61  \t{\n   62: \t\treturn detail::functor1<vec, L, T, T, Q>::call(fastCos, x);\n   63  \t}\n   64  \n   ..\n   73  \tGLM_FUNC_QUALIFIER vec<L, T, Q> fastSin(vec<L, T, Q> const& x)\n   74  \t{\n   75: \t\treturn detail::functor1<vec, L, T, T, Q>::call(fastSin, x);\n   76  \t}\n   77  \n   ..\n   86  \tGLM_FUNC_QUALIFIER vec<L, T, Q> fastTan(vec<L, T, Q> const& x)\n   87  \t{\n   88: \t\treturn detail::functor1<vec, L, T, T, Q>::call(fastTan, x);\n   89  \t}\n   90  \n   ..\n   99  \tGLM_FUNC_QUALIFIER vec<L, T, Q> fastAsin(vec<L, T, Q> const& x)\n  100  \t{\n  101: \t\treturn detail::functor1<vec, L, T, T, Q>::call(fastAsin, x);\n  102  \t}\n  103  \n  ...\n  112  \tGLM_FUNC_QUALIFIER vec<L, T, Q> fastAcos(vec<L, T, Q> const& x)\n  113  \t{\n  114: \t\treturn detail::functor1<vec, L, T, T, Q>::call(fastAcos, x);\n  115  \t}\n  116  \n  ...\n  126  \tGLM_FUNC_QUALIFIER vec<L, T, Q> fastAtan(vec<L, T, Q> const& y, vec<L, T, Q> const& x)\n  127  \t{\n  128: \t\treturn detail::functor2<vec, L, T, Q>::call(fastAtan, y, x);\n  129  \t}\n  130  \n  ...\n  138  \tGLM_FUNC_QUALIFIER vec<L, T, Q> fastAtan(vec<L, T, Q> const& x)\n  139  \t{\n  140: \t\treturn detail::functor1<vec, L, T, T, Q>::call(fastAtan, x);\n  141  \t}\n  142  }//namespace glm\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/handed_coordinate_space.hpp:\n    9  /// Include <glm/gtx/handed_coordinate_system.hpp> to use the features of this extension.\n   10  ///\n   11: /// To know if a set of three basis vectors defines a right or left-handed coordinate system.\n   12  \n   13  #pragma once\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/integer.hpp:\n   46  \tGLM_FUNC_DECL int mod(int x, int y);\n   47  \n   48: \t//! Return the factorial value of a number (!12 max, integer only)\n   49  \t//! From GLM_GTX_integer extension.\n   50  \ttemplate<typename genType>\n   51: \tGLM_FUNC_DECL genType factorial(genType const& x);\n   52  \n   53  \t//! 32bit signed integer.\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/integer.inl:\n   69  \t}\n   70  \n   71: \t// factorial (!12 max, integer only)\n   72  \ttemplate<typename genType>\n   73: \tGLM_FUNC_QUALIFIER genType factorial(genType const& x)\n   74  \t{\n   75  \t\tgenType Temp = x;\n   ..\n   81  \n   82  \ttemplate<typename T, qualifier Q>\n   83: \tGLM_FUNC_QUALIFIER vec<2, T, Q> factorial(\n   84  \t\tvec<2, T, Q> const& x)\n   85  \t{\n   86  \t\treturn vec<2, T, Q>(\n   87: \t\t\tfactorial(x.x),\n   88: \t\t\tfactorial(x.y));\n   89  \t}\n   90  \n   91  \ttemplate<typename T, qualifier Q>\n   92: \tGLM_FUNC_QUALIFIER vec<3, T, Q> factorial(\n   93  \t\tvec<3, T, Q> const& x)\n   94  \t{\n   95  \t\treturn vec<3, T, Q>(\n   96: \t\t\tfactorial(x.x),\n   97: \t\t\tfactorial(x.y),\n   98: \t\t\tfactorial(x.z));\n   99  \t}\n  100  \n  101  \ttemplate<typename T, qualifier Q>\n  102: \tGLM_FUNC_QUALIFIER vec<4, T, Q> factorial(\n  103  \t\tvec<4, T, Q> const& x)\n  104  \t{\n  105  \t\treturn vec<4, T, Q>(\n  106: \t\t\tfactorial(x.x),\n  107: \t\t\tfactorial(x.y),\n  108: \t\t\tfactorial(x.z),\n  109: \t\t\tfactorial(x.w));\n  110  \t}\n  111  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/intersect.hpp:\n   20  #include \"../geometric.hpp\"\n   21  #include \"../gtx/closest_point.hpp\"\n   22: #include \"../gtx/vector_query.hpp\"\n   23  \n   24  #ifndef GLM_ENABLE_EXPERIMENTAL\n   ..\n   62  \n   63  \t//! Compute the intersection distance of a ray and a sphere.\n   64: \t//! The ray direction vector is unit length.\n   65  \t//! From GLM_GTX_intersect extension.\n   66  \ttemplate<typename genType>\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/intersect.inl:\n   31  \t)\n   32  \t{\n   33: \t\t// find vectors for two edges sharing vert0\n   34  \t\tvec<3, T, Q> const edge1 = vert1 - vert0;\n   35  \t\tvec<3, T, Q> const edge2 = vert2 - vert0;\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/io.inl:\n  154  \ttemplate<typename CTy, typename CTr, typename V>\n  155  \tGLM_FUNC_QUALIFIER std::basic_ostream<CTy, CTr>&\n  156: \tprint_vector_on(std::basic_ostream<CTy, CTr>& os, V const& a)\n  157  \t{\n  158  \t\ttypename std::basic_ostream<CTy, CTr>::sentry const cerberus(os);\n  ...\n  198  \tGLM_FUNC_QUALIFIER std::basic_ostream<CTy,CTr>& operator<<(std::basic_ostream<CTy,CTr>& os, qua<T, Q> const& a)\n  199  \t{\n  200: \t\treturn detail::print_vector_on(os, a);\n  201  \t}\n  202  \n  ...\n  204  \tGLM_FUNC_QUALIFIER std::basic_ostream<CTy,CTr>& operator<<(std::basic_ostream<CTy,CTr>& os, vec<1, T, Q> const& a)\n  205  \t{\n  206: \t\treturn detail::print_vector_on(os, a);\n  207  \t}\n  208  \n  ...\n  210  \tGLM_FUNC_QUALIFIER std::basic_ostream<CTy,CTr>& operator<<(std::basic_ostream<CTy,CTr>& os, vec<2, T, Q> const& a)\n  211  \t{\n  212: \t\treturn detail::print_vector_on(os, a);\n  213  \t}\n  214  \n  ...\n  216  \tGLM_FUNC_QUALIFIER std::basic_ostream<CTy,CTr>& operator<<(std::basic_ostream<CTy,CTr>& os, vec<3, T, Q> const& a)\n  217  \t{\n  218: \t\treturn detail::print_vector_on(os, a);\n  219  \t}\n  220  \n  ...\n  222  \tGLM_FUNC_QUALIFIER std::basic_ostream<CTy,CTr>& operator<<(std::basic_ostream<CTy,CTr>& os, vec<4, T, Q> const& a)\n  223  \t{\n  224: \t\treturn detail::print_vector_on(os, a);\n  225  \t}\n  226  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/log_base.hpp:\n    9  /// Include <glm/gtx/log_base.hpp> to use the features of this extension.\n   10  ///\n   11: /// Logarithm for any base. base can be a vector or a scalar.\n   12  \n   13  #pragma once\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/matrix_decompose.inl:\n    7  namespace detail\n    8  {\n    9: \t/// Make a linear combination of two vectors and return the result.\n   10  \t// result = (a * ascl) + (b * bscl)\n   11  \ttemplate<typename T, qualifier Q>\n   ..\n   97  \t\t\tRow[i][j] = LocalMatrix[i][j];\n   98  \n   99: \t\t// Compute X scale factor and normalize first row.\n  100  \t\tScale.x = length(Row[0]);// v3Length(Row[0]);\n  101  \n  102  \t\tRow[0] = detail::scale(Row[0], static_cast<T>(1));\n  103  \n  104: \t\t// Compute XY shear factor and make 2nd row orthogonal to 1st.\n  105  \t\tSkew.z = dot(Row[0], Row[1]);\n  106  \t\tRow[1] = detail::combine(Row[1], Row[0], static_cast<T>(1), -Skew.z);\n  ...\n  125  \t\t// At this point, the matrix (in rows[]) is orthonormal.\n  126  \t\t// Check for a coordinate system flip.  If the determinant\n  127: \t\t// is -1, then negate the matrix and the scaling factors.\n  128  \t\tPdum3 = cross(Row[1], Row[2]); // v3Cross(row[1], row[2], Pdum3);\n  129  \t\tif(dot(Row[0], Pdum3) < 0)\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/matrix_factorisation.hpp:\n    1: /// @ref gtx_matrix_factorisation\n    2: /// @file glm/gtx/matrix_factorisation.hpp\n    3  ///\n    4  /// @see core (dependence)\n    5  ///\n    6: /// @defgroup gtx_matrix_factorisation GLM_GTX_matrix_factorisation\n    7  /// @ingroup gtx\n    8  ///\n    9: /// Include <glm/gtx/matrix_factorisation.hpp> to use the features of this extension.\n   10  ///\n   11: /// Functions to factor matrices in various forms\n   12  \n   13  #pragma once\n   ..\n   17  \n   18  #ifndef GLM_ENABLE_EXPERIMENTAL\n   19: #\terror \"GLM: GLM_GTX_matrix_factorisation is an experimental extension and may change in the future. Use #define GLM_ENABLE_EXPERIMENTAL before including it, if you really want to use it.\"\n   20  #endif\n   21  \n   22  #if GLM_MESSAGES == GLM_ENABLE && !defined(GLM_EXT_INCLUDED)\n   23: #\tpragma message(\"GLM: GLM_GTX_matrix_factorisation extension included\")\n   24  #endif\n   25  \n   ..\n   27  Suggestions:\n   28   - Move helper functions flipud and fliplr to another file: They may be helpful in more general circumstances.\n   29:  - Implement other types of matrix factorisation, such as: QL and LQ, L(D)U, eigendecompositions, etc...\n   30  */\n   31  \n   32  namespace glm\n   33  {\n   34: \t/// @addtogroup gtx_matrix_factorisation\n   35  \t/// @{\n   36  \n   37  \t/// Flips the matrix rows up and down.\n   38  \t///\n   39: \t/// From GLM_GTX_matrix_factorisation extension.\n   40  \ttemplate <length_t C, length_t R, typename T, qualifier Q>\n   41  \tGLM_FUNC_DECL mat<C, R, T, Q> flipud(mat<C, R, T, Q> const& in);\n   ..\n   43  \t/// Flips the matrix columns right and left.\n   44  \t///\n   45: \t/// From GLM_GTX_matrix_factorisation extension.\n   46  \ttemplate <length_t C, length_t R, typename T, qualifier Q>\n   47  \tGLM_FUNC_DECL mat<C, R, T, Q> fliplr(mat<C, R, T, Q> const& in);\n   48  \n   49: \t/// Performs QR factorisation of a matrix.\n   50  \t/// Returns 2 matrices, q and r, such that the columns of q are orthonormal and span the same subspace than those of the input matrix, r is an upper triangular matrix, and q*r=in.\n   51  \t/// Given an n-by-m input matrix, q has dimensions min(n,m)-by-m, and r has dimensions n-by-min(n,m).\n   52  \t///\n   53: \t/// From GLM_GTX_matrix_factorisation extension.\n   54  \ttemplate <length_t C, length_t R, typename T, qualifier Q>\n   55  \tGLM_FUNC_DECL void qr_decompose(mat<C, R, T, Q> const& in, mat<(C < R ? C : R), R, T, Q>& q, mat<C, (C < R ? C : R), T, Q>& r);\n   56  \n   57: \t/// Performs RQ factorisation of a matrix.\n   58  \t/// Returns 2 matrices, r and q, such that r is an upper triangular matrix, the rows of q are orthonormal and span the same subspace than those of the input matrix, and r*q=in.\n   59: \t/// Note that in the context of RQ factorisation, the diagonal is seen as starting in the lower-right corner of the matrix, instead of the usual upper-left.\n   60  \t/// Given an n-by-m input matrix, r has dimensions min(n,m)-by-m, and q has dimensions n-by-min(n,m).\n   61  \t///\n   62: \t/// From GLM_GTX_matrix_factorisation extension.\n   63  \ttemplate <length_t C, length_t R, typename T, qualifier Q>\n   64  \tGLM_FUNC_DECL void rq_decompose(mat<C, R, T, Q> const& in, mat<(C < R ? C : R), R, T, Q>& r, mat<C, (C < R ? C : R), T, Q>& q);\n   ..\n   67  }\n   68  \n   69: #include \"matrix_factorisation.inl\"\n   70  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/matrix_factorisation.inl:\n    1: /// @ref gtx_matrix_factorisation\n    2  \n    3  namespace glm\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/matrix_major_storage.hpp:\n   30  \t/// @{\n   31  \n   32: \t//! Build a row major matrix from row vectors.\n   33  \t//! From GLM_GTX_matrix_major_storage extension.\n   34  \ttemplate<typename T, qualifier Q>\n   ..\n   43  \t\tmat<2, 2, T, Q> const& m);\n   44  \n   45: \t//! Build a row major matrix from row vectors.\n   46  \t//! From GLM_GTX_matrix_major_storage extension.\n   47  \ttemplate<typename T, qualifier Q>\n   ..\n   57  \t\tmat<3, 3, T, Q> const& m);\n   58  \n   59: \t//! Build a row major matrix from row vectors.\n   60  \t//! From GLM_GTX_matrix_major_storage extension.\n   61  \ttemplate<typename T, qualifier Q>\n   ..\n   72  \t\tmat<4, 4, T, Q> const& m);\n   73  \n   74: \t//! Build a column major matrix from column vectors.\n   75  \t//! From GLM_GTX_matrix_major_storage extension.\n   76  \ttemplate<typename T, qualifier Q>\n   ..\n   85  \t\tmat<2, 2, T, Q> const& m);\n   86  \n   87: \t//! Build a column major matrix from column vectors.\n   88  \t//! From GLM_GTX_matrix_major_storage extension.\n   89  \ttemplate<typename T, qualifier Q>\n   ..\n   99  \t\tmat<3, 3, T, Q> const& m);\n  100  \n  101: \t//! Build a column major matrix from column vectors.\n  102  \t//! From GLM_GTX_matrix_major_storage extension.\n  103  \ttemplate<typename T, qualifier Q>\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/matrix_operation.hpp:\n    9  /// Include <glm/gtx/matrix_operation.hpp> to use the features of this extension.\n   10  ///\n   11: /// Build diagonal matrices from vectors.\n   12  \n   13  #pragma once\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/matrix_query.hpp:\n    3  ///\n    4  /// @see core (dependence)\n    5: /// @see gtx_vector_query (dependence)\n    6  ///\n    7  /// @defgroup gtx_matrix_query GLM_GTX_matrix_query\n    .\n   16  // Dependency:\n   17  #include \"../glm.hpp\"\n   18: #include \"../gtx/vector_query.hpp\"\n   19  #include <limits>\n   20  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/matrix_transform_2d.hpp:\n   31  \t/// @{\n   32  \n   33: \t/// Builds a translation 3 * 3 matrix created from a vector of 2 components.\n   34  \t///\n   35  \t/// @param m Input matrix multiplied by this translation matrix.\n   36: \t/// @param v Coordinates of a translation vector.\n   37  \ttemplate<typename T, qualifier Q>\n   38  \tGLM_FUNC_QUALIFIER mat<3, 3, T, Q> translate(\n   ..\n   49  \t\tT angle);\n   50  \n   51: \t/// Builds a scale 3 * 3 matrix created from a vector of 2 components.\n   52  \t///\n   53  \t/// @param m Input matrix multiplied by this translation matrix.\n   54: \t/// @param v Coordinates of a scale vector.\n   55  \ttemplate<typename T, qualifier Q>\n   56  \tGLM_FUNC_QUALIFIER mat<3, 3, T, Q> scale(\n   ..\n   61  \t///\n   62  \t/// @param m Input matrix multiplied by this translation matrix.\n   63: \t/// @param y Shear factor.\n   64  \ttemplate<typename T, qualifier Q>\n   65  \tGLM_FUNC_QUALIFIER mat<3, 3, T, Q> shearX(\n   ..\n   70  \t///\n   71  \t/// @param m Input matrix multiplied by this translation matrix.\n   72: \t/// @param x Shear factor.\n   73  \ttemplate<typename T, qualifier Q>\n   74  \tGLM_FUNC_QUALIFIER mat<3, 3, T, Q> shearY(\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/mixed_product.hpp:\n    9  /// Include <glm/gtx/mixed_product.hpp> to use the features of this extension.\n   10  ///\n   11: /// Mixed product of 3 vectors.\n   12  \n   13  #pragma once\n   ..\n   29  \t/// @{\n   30  \n   31: \t/// @brief Mixed product of 3 vectors (from GLM_GTX_mixed_product extension)\n   32  \ttemplate<typename T, qualifier Q>\n   33  \tGLM_FUNC_DECL T mixedProduct(\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/norm.hpp:\n   10  /// Include <glm/gtx/norm.hpp> to use the features of this extension.\n   11  ///\n   12: /// Various ways to compute vector norms.\n   13  \n   14  #pragma once\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/normalize_dot.hpp:\n   10  /// Include <glm/gtx/normalized_dot.hpp> to use the features of this extension.\n   11  ///\n   12: /// Dot product of vectors that need to be normalize with a single square root.\n   13  \n   14  #pragma once\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/number_precision.hpp:\n   31  {\n   32  \t/////////////////////////////\n   33: \t// Unsigned int vector types\n   34  \n   35  \t/// @addtogroup gtx_number_precision\n   ..\n   42  \n   43  \t//////////////////////\n   44: \t// Float vector types\n   45  \n   46  \ttypedef f32\t\t\tf32vec1;    //!< \\brief Single-qualifier floating-point scalar. (from GLM_GTX_number_precision extension)\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/perpendicular.hpp:\n   10  /// Include <glm/gtx/perpendicular.hpp> to use the features of this extension.\n   11  ///\n   12: /// Perpendicular of a vector from other one\n   13  \n   14  #pragma once\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/projection.hpp:\n    9  /// Include <glm/gtx/projection.hpp> to use the features of this extension.\n   10  ///\n   11: /// Projection of a vector to other one\n   12  \n   13  #pragma once\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/quaternion.hpp:\n   40  \tGLM_FUNC_DECL qua<T, Q> quat_identity();\n   41  \n   42: \t/// Compute a cross product between a quaternion and a vector.\n   43  \t///\n   44  \t/// @see gtx_quaternion\n   ..\n   48  \t\tvec<3, T, Q> const& v);\n   49  \n   50: \t//! Compute a cross product between a vector and a quaternion.\n   51  \t///\n   52  \t/// @see gtx_quaternion\n   ..\n   84  \t//\tqua<T, Q> const& q);\n   85  \n   86: \t//! Rotates a 3 components vector by a quaternion.\n   87  \t///\n   88  \t/// @see gtx_quaternion\n   ..\n   92  \t\tvec<3, T, Q> const& v);\n   93  \n   94: \t/// Rotates a 4 components vector by a quaternion.\n   95  \t///\n   96  \t/// @see gtx_quaternion\n   ..\n  153  \t\tT const& a);\n  154  \n  155: \t/// Compute the rotation between two vectors.\n  156: \t/// param orig vector, needs to be normalized\n  157: \t/// param dest vector, needs to be normalized\n  158  \t///\n  159  \t/// @see gtx_quaternion\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/quaternion.inl:\n  132  \t\tif(cosTheta < static_cast<T>(-1) + epsilon<T>())\n  133  \t\t{\n  134: \t\t\t// special case when vectors in opposite directions :\n  135  \t\t\t// there is no \"ideal\" rotation axis\n  136  \t\t\t// So guess one; any will do as long as it's perpendicular to start\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/range.hpp:\n    8  /// Include <glm/gtx/range.hpp> to use the features of this extension.\n    9  ///\n   10: /// Defines begin and end for vectors and matrices. Useful for range-based for loop.\n   11  /// The range is defined over the elements, not over columns or rows (e.g. mat4 has 16 elements).\n   12  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/raw_data.hpp:\n    9  /// Include <glm/gtx/raw_data.hpp> to use the features of this extension.\n   10  ///\n   11: /// Projection of a vector to other one\n   12  \n   13  #pragma once\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/rotate_normalized_axis.hpp:\n   50  \t\tvec<3, T, Q> const& axis);\n   51  \n   52: \t/// Rotates a quaternion from a vector of 3 components normalized axis and an angle.\n   53  \t///\n   54  \t/// @param q Source orientation\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/rotate_vector.hpp:\n    1: /// @ref gtx_rotate_vector\n    2: /// @file glm/gtx/rotate_vector.hpp\n    3  ///\n    4  /// @see core (dependence)\n    5  /// @see gtx_transform (dependence)\n    6  ///\n    7: /// @defgroup gtx_rotate_vector GLM_GTX_rotate_vector\n    8  /// @ingroup gtx\n    9  ///\n   10: /// Include <glm/gtx/rotate_vector.hpp> to use the features of this extension.\n   11  ///\n   12: /// Function to directly rotate a vector\n   13  \n   14  #pragma once\n   ..\n   17  #include \"../gtx/transform.hpp\"\n   18  #include \"../gtc/epsilon.hpp\"\n   19: #include \"../ext/vector_relational.hpp\"\n   20  #include \"../glm.hpp\"\n   21  \n   22  #ifndef GLM_ENABLE_EXPERIMENTAL\n   23: #\terror \"GLM: GLM_GTX_rotate_vector is an experimental extension and may change in the future. Use #define GLM_ENABLE_EXPERIMENTAL before including it, if you really want to use it.\"\n   24  #endif\n   25  \n   26  #if GLM_MESSAGES == GLM_ENABLE && !defined(GLM_EXT_INCLUDED)\n   27: #\tpragma message(\"GLM: GLM_GTX_rotate_vector extension included\")\n   28  #endif\n   29  \n   30  namespace glm\n   31  {\n   32: \t/// @addtogroup gtx_rotate_vector\n   33  \t/// @{\n   34  \n   35: \t/// Returns Spherical interpolation between two vectors\n   36  \t///\n   37: \t/// @param x A first vector\n   38: \t/// @param y A second vector\n   39: \t/// @param a Interpolation factor. The interpolation is defined beyond the range [0, 1].\n   40  \t///\n   41: \t/// @see gtx_rotate_vector\n   42  \ttemplate<typename T, qualifier Q>\n   43  \tGLM_FUNC_DECL vec<3, T, Q> slerp(\n   ..\n   46  \t\tT const& a);\n   47  \n   48: \t//! Rotate a two dimensional vector.\n   49: \t//! From GLM_GTX_rotate_vector extension.\n   50  \ttemplate<typename T, qualifier Q>\n   51  \tGLM_FUNC_DECL vec<2, T, Q> rotate(\n   ..\n   53  \t\tT const& angle);\n   54  \n   55: \t//! Rotate a three dimensional vector around an axis.\n   56: \t//! From GLM_GTX_rotate_vector extension.\n   57  \ttemplate<typename T, qualifier Q>\n   58  \tGLM_FUNC_DECL vec<3, T, Q> rotate(\n   ..\n   61  \t\tvec<3, T, Q> const& normal);\n   62  \n   63: \t//! Rotate a four dimensional vector around an axis.\n   64: \t//! From GLM_GTX_rotate_vector extension.\n   65  \ttemplate<typename T, qualifier Q>\n   66  \tGLM_FUNC_DECL vec<4, T, Q> rotate(\n   ..\n   69  \t\tvec<3, T, Q> const& normal);\n   70  \n   71: \t//! Rotate a three dimensional vector around the X axis.\n   72: \t//! From GLM_GTX_rotate_vector extension.\n   73  \ttemplate<typename T, qualifier Q>\n   74  \tGLM_FUNC_DECL vec<3, T, Q> rotateX(\n   ..\n   76  \t\tT const& angle);\n   77  \n   78: \t//! Rotate a three dimensional vector around the Y axis.\n   79: \t//! From GLM_GTX_rotate_vector extension.\n   80  \ttemplate<typename T, qualifier Q>\n   81  \tGLM_FUNC_DECL vec<3, T, Q> rotateY(\n   ..\n   83  \t\tT const& angle);\n   84  \n   85: \t//! Rotate a three dimensional vector around the Z axis.\n   86: \t//! From GLM_GTX_rotate_vector extension.\n   87  \ttemplate<typename T, qualifier Q>\n   88  \tGLM_FUNC_DECL vec<3, T, Q> rotateZ(\n   ..\n   90  \t\tT const& angle);\n   91  \n   92: \t//! Rotate a four dimensional vector around the X axis.\n   93: \t//! From GLM_GTX_rotate_vector extension.\n   94  \ttemplate<typename T, qualifier Q>\n   95  \tGLM_FUNC_DECL vec<4, T, Q> rotateX(\n   ..\n   97  \t\tT const& angle);\n   98  \n   99: \t//! Rotate a four dimensional vector around the Y axis.\n  100: \t//! From GLM_GTX_rotate_vector extension.\n  101  \ttemplate<typename T, qualifier Q>\n  102  \tGLM_FUNC_DECL vec<4, T, Q> rotateY(\n  ...\n  104  \t\tT const& angle);\n  105  \n  106: \t//! Rotate a four dimensional vector around the Z axis.\n  107: \t//! From GLM_GTX_rotate_vector extension.\n  108  \ttemplate<typename T, qualifier Q>\n  109  \tGLM_FUNC_DECL vec<4, T, Q> rotateZ(\n  ...\n  111  \t\tT const& angle);\n  112  \n  113: \t//! Build a rotation matrix from a normal and a up vector.\n  114: \t//! From GLM_GTX_rotate_vector extension.\n  115  \ttemplate<typename T, qualifier Q>\n  116  \tGLM_FUNC_DECL mat<4, 4, T, Q> orientation(\n  ...\n  121  }//namespace glm\n  122  \n  123: #include \"rotate_vector.inl\"\n  124  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/rotate_vector.inl:\n    1: /// @ref gtx_rotate_vector\n    2  \n    3  namespace glm\n    .\n   11  \t)\n   12  \t{\n   13: \t\t// get cosine of angle between vectors (-1 -> 1)\n   14  \t\tT CosAlpha = dot(x, y);\n   15  \t\t// get angle (0 -> pi)\n   16  \t\tT Alpha = acos(CosAlpha);\n   17: \t\t// get sine of angle between vectors (0 -> 1)\n   18  \t\tT SinAlpha = sin(Alpha);\n   19  \t\t// this breaks down when SinAlpha = 0, i.e. Alpha = 0 or pi\n   ..\n   21  \t\tT t2 = sin(a * Alpha) / SinAlpha;\n   22  \n   23: \t\t// interpolate src vectors\n   24  \t\treturn x * t1 + y * t2;\n   25  \t}\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/std_based_type.hpp:\n   10  /// Include <glm/gtx/std_based_type.hpp> to use the features of this extension.\n   11  ///\n   12: /// Adds vector types based on STL value types.\n   13  \n   14  #pragma once\n   ..\n   31  \t/// @{\n   32  \n   33: \t/// Vector type based of one std::size_t component.\n   34  \t/// @see GLM_GTX_std_based_type\n   35  \ttypedef vec<1, std::size_t, defaultp>\t\tsize1;\n   36  \n   37: \t/// Vector type based of two std::size_t components.\n   38  \t/// @see GLM_GTX_std_based_type\n   39  \ttypedef vec<2, std::size_t, defaultp>\t\tsize2;\n   40  \n   41: \t/// Vector type based of three std::size_t components.\n   42  \t/// @see GLM_GTX_std_based_type\n   43  \ttypedef vec<3, std::size_t, defaultp>\t\tsize3;\n   44  \n   45: \t/// Vector type based of four std::size_t components.\n   46  \t/// @see GLM_GTX_std_based_type\n   47  \ttypedef vec<4, std::size_t, defaultp>\t\tsize4;\n   48  \n   49: \t/// Vector type based of one std::size_t component.\n   50  \t/// @see GLM_GTX_std_based_type\n   51  \ttypedef vec<1, std::size_t, defaultp>\t\tsize1_t;\n   52  \n   53: \t/// Vector type based of two std::size_t components.\n   54  \t/// @see GLM_GTX_std_based_type\n   55  \ttypedef vec<2, std::size_t, defaultp>\t\tsize2_t;\n   56  \n   57: \t/// Vector type based of three std::size_t components.\n   58  \t/// @see GLM_GTX_std_based_type\n   59  \ttypedef vec<3, std::size_t, defaultp>\t\tsize3_t;\n   60  \n   61: \t/// Vector type based of four std::size_t components.\n   62  \t/// @see GLM_GTX_std_based_type\n   63  \ttypedef vec<4, std::size_t, defaultp>\t\tsize4_t;\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/string_cast.hpp:\n   42  \t/// @{\n   43  \n   44: \t/// Create a string from a GLM vector or matrix typed variable.\n   45  \t/// @see gtx_string_cast extension.\n   46  \ttemplate<typename genType>\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/texture.hpp:\n   34  \t///\n   35  \t/// @param Extent Extent of the texture base level mipmap\n   36: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n   37  \t/// @tparam T Floating-point or signed integer scalar types\n   38  \t/// @tparam Q Value from qualifier enum\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/transform.hpp:\n   48  \t\tvec<3, T, Q> const& v);\n   49  \n   50: \t/// Transforms a matrix with a scale 4 * 4 matrix created from a vector of 3 components.\n   51  \t/// @see gtc_matrix_transform\n   52  \t/// @see gtx_transform\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/transform2.hpp:\n   57  \n   58  \t//template<typename T> GLM_FUNC_QUALIFIER mat<4, 4, T, Q> shear(const mat<4, 4, T, Q> & m, shearPlane, planePoint, angle)\n   59: \t// Identity + tan(angle) * cross(Normal, OnPlaneVector)     0\n   60: \t// - dot(PointOnPlane, normal) * OnPlaneVector              1\n   61  \n   62  \t// Reflect functions seem to don't work\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/type_aligned.hpp:\n   29  {\n   30  \t///////////////////////////\n   31: \t// Signed int vector types\n   32  \n   33  \t/// @addtogroup gtx_type_aligned\n   ..\n  242  \tGLM_ALIGNED_TYPEDEF(ivec1, aligned_ivec1, 4);\n  243  \n  244: \t/// Default qualifier 32 bit signed integer aligned vector of 2 components type.\n  245  \t/// @see gtx_type_aligned\n  246  \tGLM_ALIGNED_TYPEDEF(ivec2, aligned_ivec2, 8);\n  247  \n  248: \t/// Default qualifier 32 bit signed integer aligned vector of 3 components type.\n  249  \t/// @see gtx_type_aligned\n  250  \tGLM_ALIGNED_TYPEDEF(ivec3, aligned_ivec3, 16);\n  251  \n  252: \t/// Default qualifier 32 bit signed integer aligned vector of 4 components type.\n  253  \t/// @see gtx_type_aligned\n  254  \tGLM_ALIGNED_TYPEDEF(ivec4, aligned_ivec4, 16);\n  ...\n  259  \tGLM_ALIGNED_TYPEDEF(i8vec1, aligned_i8vec1, 1);\n  260  \n  261: \t/// Default qualifier 8 bit signed integer aligned vector of 2 components type.\n  262  \t/// @see gtx_type_aligned\n  263  \tGLM_ALIGNED_TYPEDEF(i8vec2, aligned_i8vec2, 2);\n  264  \n  265: \t/// Default qualifier 8 bit signed integer aligned vector of 3 components type.\n  266  \t/// @see gtx_type_aligned\n  267  \tGLM_ALIGNED_TYPEDEF(i8vec3, aligned_i8vec3, 4);\n  268  \n  269: \t/// Default qualifier 8 bit signed integer aligned vector of 4 components type.\n  270  \t/// @see gtx_type_aligned\n  271  \tGLM_ALIGNED_TYPEDEF(i8vec4, aligned_i8vec4, 4);\n  ...\n  276  \tGLM_ALIGNED_TYPEDEF(i16vec1, aligned_i16vec1, 2);\n  277  \n  278: \t/// Default qualifier 16 bit signed integer aligned vector of 2 components type.\n  279  \t/// @see gtx_type_aligned\n  280  \tGLM_ALIGNED_TYPEDEF(i16vec2, aligned_i16vec2, 4);\n  281  \n  282: \t/// Default qualifier 16 bit signed integer aligned vector of 3 components type.\n  283  \t/// @see gtx_type_aligned\n  284  \tGLM_ALIGNED_TYPEDEF(i16vec3, aligned_i16vec3, 8);\n  285  \n  286: \t/// Default qualifier 16 bit signed integer aligned vector of 4 components type.\n  287  \t/// @see gtx_type_aligned\n  288  \tGLM_ALIGNED_TYPEDEF(i16vec4, aligned_i16vec4, 8);\n  ...\n  293  \tGLM_ALIGNED_TYPEDEF(i32vec1, aligned_i32vec1, 4);\n  294  \n  295: \t/// Default qualifier 32 bit signed integer aligned vector of 2 components type.\n  296  \t/// @see gtx_type_aligned\n  297  \tGLM_ALIGNED_TYPEDEF(i32vec2, aligned_i32vec2, 8);\n  298  \n  299: \t/// Default qualifier 32 bit signed integer aligned vector of 3 components type.\n  300  \t/// @see gtx_type_aligned\n  301  \tGLM_ALIGNED_TYPEDEF(i32vec3, aligned_i32vec3, 16);\n  302  \n  303: \t/// Default qualifier 32 bit signed integer aligned vector of 4 components type.\n  304  \t/// @see gtx_type_aligned\n  305  \tGLM_ALIGNED_TYPEDEF(i32vec4, aligned_i32vec4, 16);\n  ...\n  310  \tGLM_ALIGNED_TYPEDEF(i64vec1, aligned_i64vec1, 8);\n  311  \n  312: \t/// Default qualifier 64 bit signed integer aligned vector of 2 components type.\n  313  \t/// @see gtx_type_aligned\n  314  \tGLM_ALIGNED_TYPEDEF(i64vec2, aligned_i64vec2, 16);\n  315  \n  316: \t/// Default qualifier 64 bit signed integer aligned vector of 3 components type.\n  317  \t/// @see gtx_type_aligned\n  318  \tGLM_ALIGNED_TYPEDEF(i64vec3, aligned_i64vec3, 32);\n  319  \n  320: \t/// Default qualifier 64 bit signed integer aligned vector of 4 components type.\n  321  \t/// @see gtx_type_aligned\n  322  \tGLM_ALIGNED_TYPEDEF(i64vec4, aligned_i64vec4, 32);\n  ...\n  324  \n  325  \t/////////////////////////////\n  326: \t// Unsigned int vector types\n  327  \n  328  \t/// Low qualifier 8 bit unsigned integer aligned scalar type.\n  ...\n  534  \tGLM_ALIGNED_TYPEDEF(uvec1, aligned_uvec1, 4);\n  535  \n  536: \t/// Default qualifier 32 bit unsigned integer aligned vector of 2 components type.\n  537  \t/// @see gtx_type_aligned\n  538  \tGLM_ALIGNED_TYPEDEF(uvec2, aligned_uvec2, 8);\n  539  \n  540: \t/// Default qualifier 32 bit unsigned integer aligned vector of 3 components type.\n  541  \t/// @see gtx_type_aligned\n  542  \tGLM_ALIGNED_TYPEDEF(uvec3, aligned_uvec3, 16);\n  543  \n  544: \t/// Default qualifier 32 bit unsigned integer aligned vector of 4 components type.\n  545  \t/// @see gtx_type_aligned\n  546  \tGLM_ALIGNED_TYPEDEF(uvec4, aligned_uvec4, 16);\n  ...\n  551  \tGLM_ALIGNED_TYPEDEF(u8vec1, aligned_u8vec1, 1);\n  552  \n  553: \t/// Default qualifier 8 bit unsigned integer aligned vector of 2 components type.\n  554  \t/// @see gtx_type_aligned\n  555  \tGLM_ALIGNED_TYPEDEF(u8vec2, aligned_u8vec2, 2);\n  556  \n  557: \t/// Default qualifier 8 bit unsigned integer aligned vector of 3 components type.\n  558  \t/// @see gtx_type_aligned\n  559  \tGLM_ALIGNED_TYPEDEF(u8vec3, aligned_u8vec3, 4);\n  560  \n  561: \t/// Default qualifier 8 bit unsigned integer aligned vector of 4 components type.\n  562  \t/// @see gtx_type_aligned\n  563  \tGLM_ALIGNED_TYPEDEF(u8vec4, aligned_u8vec4, 4);\n  ...\n  568  \tGLM_ALIGNED_TYPEDEF(u16vec1, aligned_u16vec1, 2);\n  569  \n  570: \t/// Default qualifier 16 bit unsigned integer aligned vector of 2 components type.\n  571  \t/// @see gtx_type_aligned\n  572  \tGLM_ALIGNED_TYPEDEF(u16vec2, aligned_u16vec2, 4);\n  573  \n  574: \t/// Default qualifier 16 bit unsigned integer aligned vector of 3 components type.\n  575  \t/// @see gtx_type_aligned\n  576  \tGLM_ALIGNED_TYPEDEF(u16vec3, aligned_u16vec3, 8);\n  577  \n  578: \t/// Default qualifier 16 bit unsigned integer aligned vector of 4 components type.\n  579  \t/// @see gtx_type_aligned\n  580  \tGLM_ALIGNED_TYPEDEF(u16vec4, aligned_u16vec4, 8);\n  ...\n  585  \tGLM_ALIGNED_TYPEDEF(u32vec1, aligned_u32vec1, 4);\n  586  \n  587: \t/// Default qualifier 32 bit unsigned integer aligned vector of 2 components type.\n  588  \t/// @see gtx_type_aligned\n  589  \tGLM_ALIGNED_TYPEDEF(u32vec2, aligned_u32vec2, 8);\n  590  \n  591: \t/// Default qualifier 32 bit unsigned integer aligned vector of 3 components type.\n  592  \t/// @see gtx_type_aligned\n  593  \tGLM_ALIGNED_TYPEDEF(u32vec3, aligned_u32vec3, 16);\n  594  \n  595: \t/// Default qualifier 32 bit unsigned integer aligned vector of 4 components type.\n  596  \t/// @see gtx_type_aligned\n  597  \tGLM_ALIGNED_TYPEDEF(u32vec4, aligned_u32vec4, 16);\n  ...\n  602  \tGLM_ALIGNED_TYPEDEF(u64vec1, aligned_u64vec1, 8);\n  603  \n  604: \t/// Default qualifier 64 bit unsigned integer aligned vector of 2 components type.\n  605  \t/// @see gtx_type_aligned\n  606  \tGLM_ALIGNED_TYPEDEF(u64vec2, aligned_u64vec2, 16);\n  607  \n  608: \t/// Default qualifier 64 bit unsigned integer aligned vector of 3 components type.\n  609  \t/// @see gtx_type_aligned\n  610  \tGLM_ALIGNED_TYPEDEF(u64vec3, aligned_u64vec3, 32);\n  611  \n  612: \t/// Default qualifier 64 bit unsigned integer aligned vector of 4 components type.\n  613  \t/// @see gtx_type_aligned\n  614  \tGLM_ALIGNED_TYPEDEF(u64vec4, aligned_u64vec4, 32);\n  ...\n  616  \n  617  \t//////////////////////\n  618: \t// Float vector types\n  619  \n  620  \t/// 32 bit single-qualifier floating-point aligned scalar.\n  ...\n  647  \n  648  \n  649: \t/// Single-qualifier floating-point aligned vector of 1 component.\n  650  \t/// @see gtx_type_aligned\n  651  \tGLM_ALIGNED_TYPEDEF(vec1, aligned_vec1, 4);\n  652  \n  653: \t/// Single-qualifier floating-point aligned vector of 2 components.\n  654  \t/// @see gtx_type_aligned\n  655  \tGLM_ALIGNED_TYPEDEF(vec2, aligned_vec2, 8);\n  656  \n  657: \t/// Single-qualifier floating-point aligned vector of 3 components.\n  658  \t/// @see gtx_type_aligned\n  659  \tGLM_ALIGNED_TYPEDEF(vec3, aligned_vec3, 16);\n  660  \n  661: \t/// Single-qualifier floating-point aligned vector of 4 components.\n  662  \t/// @see gtx_type_aligned\n  663  \tGLM_ALIGNED_TYPEDEF(vec4, aligned_vec4, 16);\n  664  \n  665  \n  666: \t/// Single-qualifier floating-point aligned vector of 1 component.\n  667  \t/// @see gtx_type_aligned\n  668  \tGLM_ALIGNED_TYPEDEF(fvec1, aligned_fvec1, 4);\n  669  \n  670: \t/// Single-qualifier floating-point aligned vector of 2 components.\n  671  \t/// @see gtx_type_aligned\n  672  \tGLM_ALIGNED_TYPEDEF(fvec2, aligned_fvec2, 8);\n  673  \n  674: \t/// Single-qualifier floating-point aligned vector of 3 components.\n  675  \t/// @see gtx_type_aligned\n  676  \tGLM_ALIGNED_TYPEDEF(fvec3, aligned_fvec3, 16);\n  677  \n  678: \t/// Single-qualifier floating-point aligned vector of 4 components.\n  679  \t/// @see gtx_type_aligned\n  680  \tGLM_ALIGNED_TYPEDEF(fvec4, aligned_fvec4, 16);\n  681  \n  682  \n  683: \t/// Single-qualifier floating-point aligned vector of 1 component.\n  684  \t/// @see gtx_type_aligned\n  685  \tGLM_ALIGNED_TYPEDEF(f32vec1, aligned_f32vec1, 4);\n  686  \n  687: \t/// Single-qualifier floating-point aligned vector of 2 components.\n  688  \t/// @see gtx_type_aligned\n  689  \tGLM_ALIGNED_TYPEDEF(f32vec2, aligned_f32vec2, 8);\n  690  \n  691: \t/// Single-qualifier floating-point aligned vector of 3 components.\n  692  \t/// @see gtx_type_aligned\n  693  \tGLM_ALIGNED_TYPEDEF(f32vec3, aligned_f32vec3, 16);\n  694  \n  695: \t/// Single-qualifier floating-point aligned vector of 4 components.\n  696  \t/// @see gtx_type_aligned\n  697  \tGLM_ALIGNED_TYPEDEF(f32vec4, aligned_f32vec4, 16);\n  698  \n  699  \n  700: \t/// Double-qualifier floating-point aligned vector of 1 component.\n  701  \t/// @see gtx_type_aligned\n  702  \tGLM_ALIGNED_TYPEDEF(dvec1, aligned_dvec1, 8);\n  703  \n  704: \t/// Double-qualifier floating-point aligned vector of 2 components.\n  705  \t/// @see gtx_type_aligned\n  706  \tGLM_ALIGNED_TYPEDEF(dvec2, aligned_dvec2, 16);\n  707  \n  708: \t/// Double-qualifier floating-point aligned vector of 3 components.\n  709  \t/// @see gtx_type_aligned\n  710  \tGLM_ALIGNED_TYPEDEF(dvec3, aligned_dvec3, 32);\n  711  \n  712: \t/// Double-qualifier floating-point aligned vector of 4 components.\n  713  \t/// @see gtx_type_aligned\n  714  \tGLM_ALIGNED_TYPEDEF(dvec4, aligned_dvec4, 32);\n  ...\n  717  #\tifndef GLM_FORCE_SINGLE_ONLY\n  718  \n  719: \t/// Double-qualifier floating-point aligned vector of 1 component.\n  720  \t/// @see gtx_type_aligned\n  721  \tGLM_ALIGNED_TYPEDEF(f64vec1, aligned_f64vec1, 8);\n  722  \n  723: \t/// Double-qualifier floating-point aligned vector of 2 components.\n  724  \t/// @see gtx_type_aligned\n  725  \tGLM_ALIGNED_TYPEDEF(f64vec2, aligned_f64vec2, 16);\n  726  \n  727: \t/// Double-qualifier floating-point aligned vector of 3 components.\n  728  \t/// @see gtx_type_aligned\n  729  \tGLM_ALIGNED_TYPEDEF(f64vec3, aligned_f64vec3, 32);\n  730  \n  731: \t/// Double-qualifier floating-point aligned vector of 4 components.\n  732  \t/// @see gtx_type_aligned\n  733  \tGLM_ALIGNED_TYPEDEF(f64vec4, aligned_f64vec4, 32);\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/vector_angle.hpp:\n    1: /// @ref gtx_vector_angle\n    2: /// @file glm/gtx/vector_angle.hpp\n    3  ///\n    4  /// @see core (dependence)\n    .\n    6  /// @see gtx_epsilon (dependence)\n    7  ///\n    8: /// @defgroup gtx_vector_angle GLM_GTX_vector_angle\n    9  /// @ingroup gtx\n   10  ///\n   11: /// Include <glm/gtx/vector_angle.hpp> to use the features of this extension.\n   12  ///\n   13: /// Compute angle between vectors\n   14  \n   15  #pragma once\n   ..\n   19  #include \"../gtc/epsilon.hpp\"\n   20  #include \"../gtx/quaternion.hpp\"\n   21: #include \"../gtx/rotate_vector.hpp\"\n   22  \n   23  #ifndef GLM_ENABLE_EXPERIMENTAL\n   24: #\terror \"GLM: GLM_GTX_vector_angle is an experimental extension and may change in the future. Use #define GLM_ENABLE_EXPERIMENTAL before including it, if you really want to use it.\"\n   25  #endif\n   26  \n   27  #if GLM_MESSAGES == GLM_ENABLE && !defined(GLM_EXT_INCLUDED)\n   28: #\tpragma message(\"GLM: GLM_GTX_vector_angle extension included\")\n   29  #endif\n   30  \n   31  namespace glm\n   32  {\n   33: \t/// @addtogroup gtx_vector_angle\n   34  \t/// @{\n   35  \n   36: \t//! Returns the absolute angle between two vectors.\n   37  \t//! Parameters need to be normalized.\n   38: \t/// @see gtx_vector_angle extension.\n   39  \ttemplate<length_t L, typename T, qualifier Q>\n   40  \tGLM_FUNC_DECL T angle(vec<L, T, Q> const& x, vec<L, T, Q> const& y);\n   41  \n   42: \t//! Returns the oriented angle between two 2d vectors.\n   43  \t//! Parameters need to be normalized.\n   44: \t/// @see gtx_vector_angle extension.\n   45  \ttemplate<typename T, qualifier Q>\n   46  \tGLM_FUNC_DECL T orientedAngle(vec<2, T, Q> const& x, vec<2, T, Q> const& y);\n   47  \n   48: \t//! Returns the oriented angle between two 3d vectors based from a reference axis.\n   49  \t//! Parameters need to be normalized.\n   50: \t/// @see gtx_vector_angle extension.\n   51  \ttemplate<typename T, qualifier Q>\n   52  \tGLM_FUNC_DECL T orientedAngle(vec<3, T, Q> const& x, vec<3, T, Q> const& y, vec<3, T, Q> const& ref);\n   ..\n   55  }// namespace glm\n   56  \n   57: #include \"vector_angle.inl\"\n   58  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/vector_angle.inl:\n    1: /// @ref gtx_vector_angle\n    2  \n    3  namespace glm\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/vector_query.hpp:\n    1: /// @ref gtx_vector_query\n    2: /// @file glm/gtx/vector_query.hpp\n    3  ///\n    4  /// @see core (dependence)\n    5  ///\n    6: /// @defgroup gtx_vector_query GLM_GTX_vector_query\n    7  /// @ingroup gtx\n    8  ///\n    9: /// Include <glm/gtx/vector_query.hpp> to use the features of this extension.\n   10  ///\n   11: /// Query informations of vector types\n   12  \n   13  #pragma once\n   ..\n   19  \n   20  #ifndef GLM_ENABLE_EXPERIMENTAL\n   21: #\terror \"GLM: GLM_GTX_vector_query is an experimental extension and may change in the future. Use #define GLM_ENABLE_EXPERIMENTAL before including it, if you really want to use it.\"\n   22  #endif\n   23  \n   24  #if GLM_MESSAGES == GLM_ENABLE && !defined(GLM_EXT_INCLUDED)\n   25: #\tpragma message(\"GLM: GLM_GTX_vector_query extension included\")\n   26  #endif\n   27  \n   28  namespace glm\n   29  {\n   30: \t/// @addtogroup gtx_vector_query\n   31  \t/// @{\n   32  \n   33: \t//! Check whether two vectors are collinears.\n   34: \t/// @see gtx_vector_query extensions.\n   35  \ttemplate<length_t L, typename T, qualifier Q>\n   36  \tGLM_FUNC_DECL bool areCollinear(vec<L, T, Q> const& v0, vec<L, T, Q> const& v1, T const& epsilon);\n   37  \n   38: \t//! Check whether two vectors are orthogonals.\n   39: \t/// @see gtx_vector_query extensions.\n   40  \ttemplate<length_t L, typename T, qualifier Q>\n   41  \tGLM_FUNC_DECL bool areOrthogonal(vec<L, T, Q> const& v0, vec<L, T, Q> const& v1, T const& epsilon);\n   42  \n   43: \t//! Check whether a vector is normalized.\n   44: \t/// @see gtx_vector_query extensions.\n   45  \ttemplate<length_t L, typename T, qualifier Q>\n   46  \tGLM_FUNC_DECL bool isNormalized(vec<L, T, Q> const& v, T const& epsilon);\n   47  \n   48: \t//! Check whether a vector is null.\n   49: \t/// @see gtx_vector_query extensions.\n   50  \ttemplate<length_t L, typename T, qualifier Q>\n   51  \tGLM_FUNC_DECL bool isNull(vec<L, T, Q> const& v, T const& epsilon);\n   52  \n   53: \t//! Check whether a each component of a vector is null.\n   54: \t/// @see gtx_vector_query extensions.\n   55  \ttemplate<length_t L, typename T, qualifier Q>\n   56  \tGLM_FUNC_DECL vec<L, bool, Q> isCompNull(vec<L, T, Q> const& v, T const& epsilon);\n   57  \n   58: \t//! Check whether two vectors are orthonormal.\n   59: \t/// @see gtx_vector_query extensions.\n   60  \ttemplate<length_t L, typename T, qualifier Q>\n   61  \tGLM_FUNC_DECL bool areOrthonormal(vec<L, T, Q> const& v0, vec<L, T, Q> const& v1, T const& epsilon);\n   ..\n   64  }// namespace glm\n   65  \n   66: #include \"vector_query.inl\"\n   67  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/vector_query.inl:\n    1: /// @ref gtx_vector_query\n    2  \n    3  #include <cassert>\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/integer.hpp:\n   19  #include \"detail/qualifier.hpp\"\n   20  #include \"common.hpp\"\n   21: #include \"vector_relational.hpp\"\n   22  \n   23  namespace glm\n   ..\n   30  \t/// less than pow(2, 32), or to 1 otherwise.\n   31  \t///\n   32: \t/// @tparam L An integer between 1 and 4 included that qualify the dimension of the vector.\n   33  \t///\n   34  \t/// @see <a href=\"http://www.opengl.org/sdk/docs/manglsl/xhtml/uaddCarry.xml\">GLSL uaddCarry man page</a>\n   ..\n   44  \t/// otherwise. The value borrow is set to 0 if x >= y, or to 1 otherwise.\n   45  \t///\n   46: \t/// @tparam L An integer between 1 and 4 included that qualify the dimension of the vector.\n   47  \t///\n   48  \t/// @see <a href=\"http://www.opengl.org/sdk/docs/manglsl/xhtml/usubBorrow.xml\">GLSL usubBorrow man page</a>\n   ..\n   58  \t/// The 32 most-significant bits are returned in msb.\n   59  \t///\n   60: \t/// @tparam L An integer between 1 and 4 included that qualify the dimension of the vector.\n   61  \t///\n   62  \t/// @see <a href=\"http://www.opengl.org/sdk/docs/manglsl/xhtml/umulExtended.xml\">GLSL umulExtended man page</a>\n   ..\n   73  \t/// The 32 most-significant bits are returned in msb.\n   74  \t///\n   75: \t/// @tparam L An integer between 1 and 4 included that qualify the dimension of the vector.\n   76  \t///\n   77  \t/// @see <a href=\"http://www.opengl.org/sdk/docs/manglsl/xhtml/imulExtended.xml\">GLSL imulExtended man page</a>\n   ..\n   95  \t/// to store the operand.\n   96  \t///\n   97: \t/// @tparam L An integer between 1 and 4 included that qualify the dimension of the vector.\n   98  \t/// @tparam T Signed or unsigned integer scalar types.\n   99  \t///\n  ...\n  116  \t/// store the operand.\n  117  \t///\n  118: \t/// @tparam L An integer between 1 and 4 included that qualify the dimension of the vector.\n  119: \t/// @tparam T Signed or unsigned integer scalar or vector types.\n  120  \t///\n  121  \t/// @see <a href=\"http://www.opengl.org/sdk/docs/manglsl/xhtml/bitfieldInsert.xml\">GLSL bitfieldInsert man page</a>\n  ...\n  132  \t/// where bits is the total number of bits used to represent value.\n  133  \t///\n  134: \t/// @tparam L An integer between 1 and 4 included that qualify the dimension of the vector.\n  135: \t/// @tparam T Signed or unsigned integer scalar or vector types.\n  136  \t///\n  137  \t/// @see <a href=\"http://www.opengl.org/sdk/docs/manglsl/xhtml/bitfieldReverse.xml\">GLSL bitfieldReverse man page</a>\n  ...\n  142  \t/// Returns the number of bits set to 1 in the binary representation of value.\n  143  \t///\n  144: \t/// @tparam genType Signed or unsigned integer scalar or vector types.\n  145  \t///\n  146  \t/// @see <a href=\"http://www.opengl.org/sdk/docs/manglsl/xhtml/bitCount.xml\">GLSL bitCount man page</a>\n  ...\n  151  \t/// Returns the number of bits set to 1 in the binary representation of value.\n  152  \t///\n  153: \t/// @tparam L An integer between 1 and 4 included that qualify the dimension of the vector.\n  154: \t/// @tparam T Signed or unsigned integer scalar or vector types.\n  155  \t///\n  156  \t/// @see <a href=\"http://www.opengl.org/sdk/docs/manglsl/xhtml/bitCount.xml\">GLSL bitCount man page</a>\n  ...\n  174  \t/// If value is zero, -1 will be returned.\n  175  \t///\n  176: \t/// @tparam L An integer between 1 and 4 included that qualify the dimension of the vector.\n  177  \t/// @tparam T Signed or unsigned integer scalar types.\n  178  \t///\n  ...\n  199  \t/// bit set to 0. For a value of zero or negative one, -1 will be returned.\n  200  \t///\n  201: \t/// @tparam L An integer between 1 and 4 included that qualify the dimension of the vector.\n  202  \t/// @tparam T Signed or unsigned integer scalar types.\n  203  \t///\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/matrix.hpp:\n  106  \tGLM_FUNC_DECL mat<C, R, T, Q> matrixCompMult(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y);\n  107  \n  108: \t/// Treats the first parameter c as a column vector\n  109: \t/// and the second parameter r as a row vector\n  110  \t/// and does a linear algebraic matrix multiply c * r.\n  111  \t///\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/packing.hpp:\n   16  #pragma once\n   17  \n   18: #include \"./ext/vector_uint2.hpp\"\n   19: #include \"./ext/vector_float2.hpp\"\n   20: #include \"./ext/vector_float4.hpp\"\n   21  \n   22  namespace glm\n   ..\n   31  \t/// packUnorm2x16: round(clamp(c, 0, +1) * 65535.0)\n   32  \t///\n   33: \t/// The first component of the vector will be written to the least significant bits of the output;\n   34  \t/// the last component will be written to the most significant bits.\n   35  \t///\n   ..\n   44  \t/// packSnorm2x16: round(clamp(v, -1, +1) * 32767.0)\n   45  \t///\n   46: \t/// The first component of the vector will be written to the least significant bits of the output;\n   47  \t/// the last component will be written to the most significant bits.\n   48  \t///\n   ..\n   57  \t/// packUnorm4x8:\tround(clamp(c, 0, +1) * 255.0)\n   58  \t///\n   59: \t/// The first component of the vector will be written to the least significant bits of the output;\n   60  \t/// the last component will be written to the most significant bits.\n   61  \t///\n   ..\n   70  \t/// packSnorm4x8:\tround(clamp(c, -1, +1) * 127.0)\n   71  \t///\n   72: \t/// The first component of the vector will be written to the least significant bits of the output;\n   73  \t/// the last component will be written to the most significant bits.\n   74  \t///\n   ..\n   78  \n   79  \t/// First, unpacks a single 32-bit unsigned integer p into a pair of 16-bit unsigned integers, four 8-bit unsigned integers, or four 8-bit signed integers.\n   80: \t/// Then, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector.\n   81  \t///\n   82  \t/// The conversion for unpacked fixed-point value f to floating point is done as follows:\n   83  \t/// unpackUnorm2x16: f / 65535.0\n   84  \t///\n   85: \t/// The first component of the returned vector will be extracted from the least significant bits of the input;\n   86  \t/// the last component will be extracted from the most significant bits.\n   87  \t///\n   ..\n   91  \n   92  \t/// First, unpacks a single 32-bit unsigned integer p into a pair of 16-bit unsigned integers, four 8-bit unsigned integers, or four 8-bit signed integers.\n   93: \t/// Then, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector.\n   94  \t///\n   95  \t/// The conversion for unpacked fixed-point value f to floating point is done as follows:\n   96  \t/// unpackSnorm2x16: clamp(f / 32767.0, -1, +1)\n   97  \t///\n   98: \t/// The first component of the returned vector will be extracted from the least significant bits of the input;\n   99  \t/// the last component will be extracted from the most significant bits.\n  100  \t///\n  ...\n  104  \n  105  \t/// First, unpacks a single 32-bit unsigned integer p into a pair of 16-bit unsigned integers, four 8-bit unsigned integers, or four 8-bit signed integers.\n  106: \t/// Then, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector.\n  107  \t///\n  108  \t/// The conversion for unpacked fixed-point value f to floating point is done as follows:\n  109  \t/// unpackUnorm4x8: f / 255.0\n  110  \t///\n  111: \t/// The first component of the returned vector will be extracted from the least significant bits of the input;\n  112  \t/// the last component will be extracted from the most significant bits.\n  113  \t///\n  ...\n  117  \n  118  \t/// First, unpacks a single 32-bit unsigned integer p into a pair of 16-bit unsigned integers, four 8-bit unsigned integers, or four 8-bit signed integers.\n  119: \t/// Then, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector.\n  120  \t///\n  121  \t/// The conversion for unpacked fixed-point value f to floating point is done as follows:\n  122  \t/// unpackSnorm4x8: clamp(f / 127.0, -1, +1)\n  123  \t///\n  124: \t/// The first component of the returned vector will be extracted from the least significant bits of the input;\n  125  \t/// the last component will be extracted from the most significant bits.\n  126  \t///\n  ...\n  132  \t/// If an IEEE 754 Inf or NaN is created, it will not signal, and the resulting floating point value is unspecified.\n  133  \t/// Otherwise, the bit- level representation of v is preserved.\n  134: \t/// The first vector component specifies the 32 least significant bits;\n  135  \t/// the second component specifies the 32 most significant bits.\n  136  \t///\n  ...\n  139  \tGLM_FUNC_DECL double packDouble2x32(uvec2 const& v);\n  140  \n  141: \t/// Returns a two-component unsigned integer vector representation of v.\n  142  \t/// The bit-level representation of v is preserved.\n  143: \t/// The first component of the vector contains the 32 least significant bits of the double;\n  144  \t/// the second component consists the 32 most significant bits.\n  145  \t///\n  ...\n  148  \tGLM_FUNC_DECL uvec2 unpackDouble2x32(double v);\n  149  \n  150: \t/// Returns an unsigned integer obtained by converting the components of a two-component floating-point vector\n  151  \t/// to the 16-bit floating-point representation found in the OpenGL Specification,\n  152  \t/// and then packing these two 16- bit integers into a 32-bit unsigned integer.\n  153: \t/// The first vector component specifies the 16 least-significant bits of the result;\n  154  \t/// the second component specifies the 16 most-significant bits.\n  155  \t///\n  ...\n  158  \tGLM_FUNC_DECL uint packHalf2x16(vec2 const& v);\n  159  \n  160: \t/// Returns a two-component floating-point vector with components obtained by unpacking a 32-bit unsigned integer into a pair of 16-bit values,\n  161  \t/// interpreting those values as 16-bit floating-point numbers according to the OpenGL Specification,\n  162  \t/// and converting them to 32-bit floating-point values.\n  163: \t/// The first component of the vector is obtained from the 16 least-significant bits of v;\n  164  \t/// the second component is obtained from the 16 most-significant bits of v.\n  165  \t///\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/simd/matrix.h:\n  171  \t__m128 Fac0;\n  172  \t{\n  173: \t\t//\tvalType SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];\n  174: \t\t//\tvalType SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];\n  175: \t\t//\tvalType SubFactor06 = m[1][2] * m[3][3] - m[3][2] * m[1][3];\n  176: \t\t//\tvalType SubFactor13 = m[1][2] * m[2][3] - m[2][2] * m[1][3];\n  177  \n  178  \t\t__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], _MM_SHUFFLE(3, 3, 3, 3));\n  ...\n  191  \t__m128 Fac1;\n  192  \t{\n  193: \t\t//\tvalType SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];\n  194: \t\t//\tvalType SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];\n  195: \t\t//\tvalType SubFactor07 = m[1][1] * m[3][3] - m[3][1] * m[1][3];\n  196: \t\t//\tvalType SubFactor14 = m[1][1] * m[2][3] - m[2][1] * m[1][3];\n  197  \n  198  \t\t__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], _MM_SHUFFLE(3, 3, 3, 3));\n  ...\n  212  \t__m128 Fac2;\n  213  \t{\n  214: \t\t//\tvalType SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];\n  215: \t\t//\tvalType SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];\n  216: \t\t//\tvalType SubFactor08 = m[1][1] * m[3][2] - m[3][1] * m[1][2];\n  217: \t\t//\tvalType SubFactor15 = m[1][1] * m[2][2] - m[2][1] * m[1][2];\n  218  \n  219  \t\t__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], _MM_SHUFFLE(2, 2, 2, 2));\n  ...\n  232  \t__m128 Fac3;\n  233  \t{\n  234: \t\t//\tvalType SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];\n  235: \t\t//\tvalType SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];\n  236: \t\t//\tvalType SubFactor09 = m[1][0] * m[3][3] - m[3][0] * m[1][3];\n  237: \t\t//\tvalType SubFactor16 = m[1][0] * m[2][3] - m[2][0] * m[1][3];\n  238  \n  239  \t\t__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], _MM_SHUFFLE(3, 3, 3, 3));\n  ...\n  252  \t__m128 Fac4;\n  253  \t{\n  254: \t\t//\tvalType SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];\n  255: \t\t//\tvalType SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];\n  256: \t\t//\tvalType SubFactor10 = m[1][0] * m[3][2] - m[3][0] * m[1][2];\n  257: \t\t//\tvalType SubFactor17 = m[1][0] * m[2][2] - m[2][0] * m[1][2];\n  258  \n  259  \t\t__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], _MM_SHUFFLE(2, 2, 2, 2));\n  ...\n  272  \t__m128 Fac5;\n  273  \t{\n  274: \t\t//\tvalType SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];\n  275: \t\t//\tvalType SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];\n  276: \t\t//\tvalType SubFactor12 = m[1][0] * m[3][1] - m[3][0] * m[1][1];\n  277: \t\t//\tvalType SubFactor18 = m[1][0] * m[2][1] - m[2][0] * m[1][1];\n  278  \n  279  \t\t__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], _MM_SHUFFLE(1, 1, 1, 1));\n  ...\n  385  \t// _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(\n  386  \n  387: \t//T SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];\n  388: \t//T SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];\n  389: \t//T SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];\n  390: \t//T SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];\n  391: \t//T SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];\n  392: \t//T SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];\n  393  \n  394  \t// First 2 columns\n  ...\n  412  \n  413  \t//vec<4, T, Q> DetCof(\n  414: \t//\t+ (m[1][1] * SubFactor00 - m[1][2] * SubFactor01 + m[1][3] * SubFactor02),\n  415: \t//\t- (m[1][0] * SubFactor00 - m[1][2] * SubFactor03 + m[1][3] * SubFactor04),\n  416: \t//\t+ (m[1][0] * SubFactor01 - m[1][1] * SubFactor03 + m[1][3] * SubFactor05),\n  417: \t//\t- (m[1][0] * SubFactor02 - m[1][1] * SubFactor04 + m[1][2] * SubFactor05));\n  418  \n  419  \t__m128 SubFacA = _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(SubE), _MM_SHUFFLE(2, 1, 0, 0)));\n  ...\n  448  \t// _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(add)\n  449  \n  450: \t//T SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];\n  451: \t//T SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];\n  452: \t//T SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];\n  453: \t//T SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];\n  454: \t//T SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];\n  455: \t//T SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];\n  456  \n  457  \t// First 2 columns\n  ...\n  475  \n  476  \t//vec<4, T, Q> DetCof(\n  477: \t//\t+ (m[1][1] * SubFactor00 - m[1][2] * SubFactor01 + m[1][3] * SubFactor02),\n  478: \t//\t- (m[1][0] * SubFactor00 - m[1][2] * SubFactor03 + m[1][3] * SubFactor04),\n  479: \t//\t+ (m[1][0] * SubFactor01 - m[1][1] * SubFactor03 + m[1][3] * SubFactor05),\n  480: \t//\t- (m[1][0] * SubFactor02 - m[1][1] * SubFactor04 + m[1][2] * SubFactor05));\n  481  \n  482  \t__m128 SubFacA = _mm_shuffle_ps(SubE, SubE, _MM_SHUFFLE(2, 1, 0, 0));\n  ...\n  511  \t__m128 Fac0;\n  512  \t{\n  513: \t\t//\tvalType SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];\n  514: \t\t//\tvalType SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];\n  515: \t\t//\tvalType SubFactor06 = m[1][2] * m[3][3] - m[3][2] * m[1][3];\n  516: \t\t//\tvalType SubFactor13 = m[1][2] * m[2][3] - m[2][2] * m[1][3];\n  517  \n  518  \t\t__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], _MM_SHUFFLE(3, 3, 3, 3));\n  ...\n  531  \t__m128 Fac1;\n  532  \t{\n  533: \t\t//\tvalType SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];\n  534: \t\t//\tvalType SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];\n  535: \t\t//\tvalType SubFactor07 = m[1][1] * m[3][3] - m[3][1] * m[1][3];\n  536: \t\t//\tvalType SubFactor14 = m[1][1] * m[2][3] - m[2][1] * m[1][3];\n  537  \n  538  \t\t__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], _MM_SHUFFLE(3, 3, 3, 3));\n  ...\n  552  \t__m128 Fac2;\n  553  \t{\n  554: \t\t//\tvalType SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];\n  555: \t\t//\tvalType SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];\n  556: \t\t//\tvalType SubFactor08 = m[1][1] * m[3][2] - m[3][1] * m[1][2];\n  557: \t\t//\tvalType SubFactor15 = m[1][1] * m[2][2] - m[2][1] * m[1][2];\n  558  \n  559  \t\t__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], _MM_SHUFFLE(2, 2, 2, 2));\n  ...\n  572  \t__m128 Fac3;\n  573  \t{\n  574: \t\t//\tvalType SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];\n  575: \t\t//\tvalType SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];\n  576: \t\t//\tvalType SubFactor09 = m[1][0] * m[3][3] - m[3][0] * m[1][3];\n  577: \t\t//\tvalType SubFactor16 = m[1][0] * m[2][3] - m[2][0] * m[1][3];\n  578  \n  579  \t\t__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], _MM_SHUFFLE(3, 3, 3, 3));\n  ...\n  592  \t__m128 Fac4;\n  593  \t{\n  594: \t\t//\tvalType SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];\n  595: \t\t//\tvalType SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];\n  596: \t\t//\tvalType SubFactor10 = m[1][0] * m[3][2] - m[3][0] * m[1][2];\n  597: \t\t//\tvalType SubFactor17 = m[1][0] * m[2][2] - m[2][0] * m[1][2];\n  598  \n  599  \t\t__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], _MM_SHUFFLE(2, 2, 2, 2));\n  ...\n  612  \t__m128 Fac5;\n  613  \t{\n  614: \t\t//\tvalType SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];\n  615: \t\t//\tvalType SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];\n  616: \t\t//\tvalType SubFactor12 = m[1][0] * m[3][1] - m[3][0] * m[1][1];\n  617: \t\t//\tvalType SubFactor18 = m[1][0] * m[2][1] - m[2][0] * m[1][1];\n  618  \n  619  \t\t__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], _MM_SHUFFLE(1, 1, 1, 1));\n  ...\n  732  \t__m128 Fac0;\n  733  \t{\n  734: \t\t//\tvalType SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];\n  735: \t\t//\tvalType SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];\n  736: \t\t//\tvalType SubFactor06 = m[1][2] * m[3][3] - m[3][2] * m[1][3];\n  737: \t\t//\tvalType SubFactor13 = m[1][2] * m[2][3] - m[2][2] * m[1][3];\n  738  \n  739  \t\t__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], _MM_SHUFFLE(3, 3, 3, 3));\n  ...\n  752  \t__m128 Fac1;\n  753  \t{\n  754: \t\t//\tvalType SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];\n  755: \t\t//\tvalType SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];\n  756: \t\t//\tvalType SubFactor07 = m[1][1] * m[3][3] - m[3][1] * m[1][3];\n  757: \t\t//\tvalType SubFactor14 = m[1][1] * m[2][3] - m[2][1] * m[1][3];\n  758  \n  759  \t\t__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], _MM_SHUFFLE(3, 3, 3, 3));\n  ...\n  773  \t__m128 Fac2;\n  774  \t{\n  775: \t\t//\tvalType SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];\n  776: \t\t//\tvalType SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];\n  777: \t\t//\tvalType SubFactor08 = m[1][1] * m[3][2] - m[3][1] * m[1][2];\n  778: \t\t//\tvalType SubFactor15 = m[1][1] * m[2][2] - m[2][1] * m[1][2];\n  779  \n  780  \t\t__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], _MM_SHUFFLE(2, 2, 2, 2));\n  ...\n  793  \t__m128 Fac3;\n  794  \t{\n  795: \t\t//\tvalType SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];\n  796: \t\t//\tvalType SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];\n  797: \t\t//\tvalType SubFactor09 = m[1][0] * m[3][3] - m[3][0] * m[1][3];\n  798: \t\t//\tvalType SubFactor16 = m[1][0] * m[2][3] - m[2][0] * m[1][3];\n  799  \n  800  \t\t__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], _MM_SHUFFLE(3, 3, 3, 3));\n  ...\n  813  \t__m128 Fac4;\n  814  \t{\n  815: \t\t//\tvalType SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];\n  816: \t\t//\tvalType SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];\n  817: \t\t//\tvalType SubFactor10 = m[1][0] * m[3][2] - m[3][0] * m[1][2];\n  818: \t\t//\tvalType SubFactor17 = m[1][0] * m[2][2] - m[2][0] * m[1][2];\n  819  \n  820  \t\t__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], _MM_SHUFFLE(2, 2, 2, 2));\n  ...\n  833  \t__m128 Fac5;\n  834  \t{\n  835: \t\t//\tvalType SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];\n  836: \t\t//\tvalType SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];\n  837: \t\t//\tvalType SubFactor12 = m[1][0] * m[3][1] - m[3][0] * m[1][1];\n  838: \t\t//\tvalType SubFactor18 = m[1][0] * m[2][1] - m[2][0] * m[1][1];\n  839  \n  840  \t\t__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], _MM_SHUFFLE(1, 1, 1, 1));\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/simd/vector_relational.h:\n    1  /// @ref simd\n    2: /// @file glm/simd/vector_relational.h\n    3  \n    4  #pragma once\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/trigonometric.hpp:\n   15  /// Include <glm/trigonometric.hpp> to use these core features.\n   16  ///\n   17: /// @see ext_vector_trigonometric\n   18  \n   19  #pragma once\n   ..\n   29  \t/// Converts degrees to radians and returns the result.\n   30  \t///\n   31: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n   32  \t/// @tparam T Floating-point scalar types\n   33  \t/// @tparam Q Value from qualifier enum\n   ..\n   40  \t/// Converts radians to degrees and returns the result.\n   41  \t///\n   42: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n   43  \t/// @tparam T Floating-point scalar types\n   44  \t/// @tparam Q Value from qualifier enum\n   ..\n   52  \t/// The values returned by this function will range from [-1, 1].\n   53  \t///\n   54: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n   55  \t/// @tparam T Floating-point scalar types\n   56  \t/// @tparam Q Value from qualifier enum\n   ..\n   64  \t/// The values returned by this function will range from [-1, 1].\n   65  \t///\n   66: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n   67  \t/// @tparam T Floating-point scalar types\n   68  \t/// @tparam Q Value from qualifier enum\n   ..\n   75  \t/// The standard trigonometric tangent function.\n   76  \t///\n   77: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n   78  \t/// @tparam T Floating-point scalar types\n   79  \t/// @tparam Q Value from qualifier enum\n   ..\n   88  \t/// Results are undefined if |x| > 1.\n   89  \t///\n   90: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n   91  \t/// @tparam T Floating-point scalar types\n   92  \t/// @tparam Q Value from qualifier enum\n   ..\n  101  \t/// Results are undefined if |x| > 1.\n  102  \t///\n  103: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  104  \t/// @tparam T Floating-point scalar types\n  105  \t/// @tparam Q Value from qualifier enum\n  ...\n  116  \t/// if x and y are both 0.\n  117  \t///\n  118: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  119  \t/// @tparam T Floating-point scalar types\n  120  \t/// @tparam Q Value from qualifier enum\n  ...\n  128  \t/// The range of values returned by this function is [-PI/2, PI/2].\n  129  \t///\n  130: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  131  \t/// @tparam T Floating-point scalar types\n  132  \t/// @tparam Q Value from qualifier enum\n  ...\n  139  \t/// Returns the hyperbolic sine function, (exp(x) - exp(-x)) / 2\n  140  \t///\n  141: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  142  \t/// @tparam T Floating-point scalar types\n  143  \t/// @tparam Q Value from qualifier enum\n  ...\n  150  \t/// Returns the hyperbolic cosine function, (exp(x) + exp(-x)) / 2\n  151  \t///\n  152: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  153  \t/// @tparam T Floating-point scalar types\n  154  \t/// @tparam Q Value from qualifier enum\n  ...\n  161  \t/// Returns the hyperbolic tangent function, sinh(angle) / cosh(angle)\n  162  \t///\n  163: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  164  \t/// @tparam T Floating-point scalar types\n  165  \t/// @tparam Q Value from qualifier enum\n  ...\n  172  \t/// Arc hyperbolic sine; returns the inverse of sinh.\n  173  \t///\n  174: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  175  \t/// @tparam T Floating-point scalar types\n  176  \t/// @tparam Q Value from qualifier enum\n  ...\n  184  \t/// of cosh. Results are undefined if x < 1.\n  185  \t///\n  186: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  187  \t/// @tparam T Floating-point scalar types\n  188  \t/// @tparam Q Value from qualifier enum\n  ...\n  196  \t/// Results are undefined if abs(x) >= 1.\n  197  \t///\n  198: \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n  199  \t/// @tparam T Floating-point scalar types\n  200  \t/// @tparam Q Value from qualifier enum\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/vec2.hpp:\n    3  \n    4  #pragma once\n    5: #include \"./ext/vector_bool2.hpp\"\n    6: #include \"./ext/vector_bool2_precision.hpp\"\n    7: #include \"./ext/vector_float2.hpp\"\n    8: #include \"./ext/vector_float2_precision.hpp\"\n    9: #include \"./ext/vector_double2.hpp\"\n   10: #include \"./ext/vector_double2_precision.hpp\"\n   11: #include \"./ext/vector_int2.hpp\"\n   12: #include \"./ext/vector_int2_precision.hpp\"\n   13: #include \"./ext/vector_uint2.hpp\"\n   14: #include \"./ext/vector_uint2_precision.hpp\"\n   15  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/vec3.hpp:\n    3  \n    4  #pragma once\n    5: #include \"./ext/vector_bool3.hpp\"\n    6: #include \"./ext/vector_bool3_precision.hpp\"\n    7: #include \"./ext/vector_float3.hpp\"\n    8: #include \"./ext/vector_float3_precision.hpp\"\n    9: #include \"./ext/vector_double3.hpp\"\n   10: #include \"./ext/vector_double3_precision.hpp\"\n   11: #include \"./ext/vector_int3.hpp\"\n   12: #include \"./ext/vector_int3_precision.hpp\"\n   13: #include \"./ext/vector_uint3.hpp\"\n   14: #include \"./ext/vector_uint3_precision.hpp\"\n   15  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/vec4.hpp:\n    3  \n    4  #pragma once\n    5: #include \"./ext/vector_bool4.hpp\"\n    6: #include \"./ext/vector_bool4_precision.hpp\"\n    7: #include \"./ext/vector_float4.hpp\"\n    8: #include \"./ext/vector_float4_precision.hpp\"\n    9: #include \"./ext/vector_double4.hpp\"\n   10: #include \"./ext/vector_double4_precision.hpp\"\n   11: #include \"./ext/vector_int4.hpp\"\n   12: #include \"./ext/vector_int4_precision.hpp\"\n   13: #include \"./ext/vector_uint4.hpp\"\n   14: #include \"./ext/vector_uint4_precision.hpp\"\n   15  \n   16  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/vector_relational.hpp:\n    1  /// @ref core\n    2: /// @file glm/vector_relational.hpp\n    3  ///\n    4: /// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 8.7 Vector Relational Functions</a>\n    5  ///\n    6: /// @defgroup core_func_vector_relational Vector Relational Functions\n    7  /// @ingroup core\n    8  ///\n    9  /// Relational and equality operators (<, <=, >, >=, ==, !=) are defined to\n   10: /// operate on scalars and produce scalar Boolean results. For vector results,\n   11  /// use the following built-in functions.\n   12  ///\n   13: /// In all cases, the sizes of all the input and return vectors for any particular\n   14  /// call must match.\n   15  ///\n   16: /// Include <glm/vector_relational.hpp> to use these core features.\n   17  ///\n   18: /// @see ext_vector_relational\n   19  \n   20  #pragma once\n   ..\n   25  namespace glm\n   26  {\n   27: \t/// @addtogroup core_func_vector_relational\n   28  \t/// @{\n   29  \n   30  \t/// Returns the component-wise comparison result of x < y.\n   31  \t///\n   32: \t/// @tparam L An integer between 1 and 4 included that qualify the dimension of the vector.\n   33  \t/// @tparam T A floating-point or integer scalar type.\n   34  \t///\n   35  \t/// @see <a href=\"http://www.opengl.org/sdk/docs/manglsl/xhtml/lessThan.xml\">GLSL lessThan man page</a>\n   36: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 8.7 Vector Relational Functions</a>\n   37  \ttemplate<length_t L, typename T, qualifier Q>\n   38  \tGLM_FUNC_DECL GLM_CONSTEXPR vec<L, bool, Q> lessThan(vec<L, T, Q> const& x, vec<L, T, Q> const& y);\n   ..\n   40  \t/// Returns the component-wise comparison of result x <= y.\n   41  \t///\n   42: \t/// @tparam L An integer between 1 and 4 included that qualify the dimension of the vector.\n   43  \t/// @tparam T A floating-point or integer scalar type.\n   44  \t///\n   45  \t/// @see <a href=\"http://www.opengl.org/sdk/docs/manglsl/xhtml/lessThanEqual.xml\">GLSL lessThanEqual man page</a>\n   46: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 8.7 Vector Relational Functions</a>\n   47  \ttemplate<length_t L, typename T, qualifier Q>\n   48  \tGLM_FUNC_DECL GLM_CONSTEXPR vec<L, bool, Q> lessThanEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y);\n   ..\n   50  \t/// Returns the component-wise comparison of result x > y.\n   51  \t///\n   52: \t/// @tparam L An integer between 1 and 4 included that qualify the dimension of the vector.\n   53  \t/// @tparam T A floating-point or integer scalar type.\n   54  \t///\n   55  \t/// @see <a href=\"http://www.opengl.org/sdk/docs/manglsl/xhtml/greaterThan.xml\">GLSL greaterThan man page</a>\n   56: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 8.7 Vector Relational Functions</a>\n   57  \ttemplate<length_t L, typename T, qualifier Q>\n   58  \tGLM_FUNC_DECL GLM_CONSTEXPR vec<L, bool, Q> greaterThan(vec<L, T, Q> const& x, vec<L, T, Q> const& y);\n   ..\n   60  \t/// Returns the component-wise comparison of result x >= y.\n   61  \t///\n   62: \t/// @tparam L An integer between 1 and 4 included that qualify the dimension of the vector.\n   63  \t/// @tparam T A floating-point or integer scalar type.\n   64  \t///\n   65  \t/// @see <a href=\"http://www.opengl.org/sdk/docs/manglsl/xhtml/greaterThanEqual.xml\">GLSL greaterThanEqual man page</a>\n   66: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 8.7 Vector Relational Functions</a>\n   67  \ttemplate<length_t L, typename T, qualifier Q>\n   68  \tGLM_FUNC_DECL GLM_CONSTEXPR vec<L, bool, Q> greaterThanEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y);\n   ..\n   70  \t/// Returns the component-wise comparison of result x == y.\n   71  \t///\n   72: \t/// @tparam L An integer between 1 and 4 included that qualify the dimension of the vector.\n   73  \t/// @tparam T A floating-point, integer or bool scalar type.\n   74  \t///\n   75  \t/// @see <a href=\"http://www.opengl.org/sdk/docs/manglsl/xhtml/equal.xml\">GLSL equal man page</a>\n   76: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 8.7 Vector Relational Functions</a>\n   77  \ttemplate<length_t L, typename T, qualifier Q>\n   78  \tGLM_FUNC_DECL GLM_CONSTEXPR vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y);\n   ..\n   80  \t/// Returns the component-wise comparison of result x != y.\n   81  \t///\n   82: \t/// @tparam L An integer between 1 and 4 included that qualify the dimension of the vector.\n   83  \t/// @tparam T A floating-point, integer or bool scalar type.\n   84  \t///\n   85  \t/// @see <a href=\"http://www.opengl.org/sdk/docs/manglsl/xhtml/notEqual.xml\">GLSL notEqual man page</a>\n   86: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 8.7 Vector Relational Functions</a>\n   87  \ttemplate<length_t L, typename T, qualifier Q>\n   88  \tGLM_FUNC_DECL GLM_CONSTEXPR vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y);\n   ..\n   90  \t/// Returns true if any component of x is true.\n   91  \t///\n   92: \t/// @tparam L An integer between 1 and 4 included that qualify the dimension of the vector.\n   93  \t///\n   94  \t/// @see <a href=\"http://www.opengl.org/sdk/docs/manglsl/xhtml/any.xml\">GLSL any man page</a>\n   95: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 8.7 Vector Relational Functions</a>\n   96  \ttemplate<length_t L, qualifier Q>\n   97  \tGLM_FUNC_DECL GLM_CONSTEXPR bool any(vec<L, bool, Q> const& v);\n   ..\n   99  \t/// Returns true if all components of x are true.\n  100  \t///\n  101: \t/// @tparam L An integer between 1 and 4 included that qualify the dimension of the vector.\n  102  \t///\n  103  \t/// @see <a href=\"http://www.opengl.org/sdk/docs/manglsl/xhtml/all.xml\">GLSL all man page</a>\n  104: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 8.7 Vector Relational Functions</a>\n  105  \ttemplate<length_t L, qualifier Q>\n  106  \tGLM_FUNC_DECL GLM_CONSTEXPR bool all(vec<L, bool, Q> const& v);\n  ...\n  109  \t/// /!\\ Because of language incompatibilities between C++ and GLSL, GLM defines the function not but not_ instead.\n  110  \t///\n  111: \t/// @tparam L An integer between 1 and 4 included that qualify the dimension of the vector.\n  112  \t///\n  113  \t/// @see <a href=\"http://www.opengl.org/sdk/docs/manglsl/xhtml/not.xml\">GLSL not man page</a>\n  114: \t/// @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 8.7 Vector Relational Functions</a>\n  115  \ttemplate<length_t L, qualifier Q>\n  116  \tGLM_FUNC_DECL GLM_CONSTEXPR vec<L, bool, Q> not_(vec<L, bool, Q> const& v);\n  ...\n  119  }//namespace glm\n  120  \n  121: #include \"detail/func_vector_relational.inl\"\n  122  \n\n/home/max/dev/Falcor/src/Externals/GLM/readme.md:\n   56  #### Fixes:\n   57  - Fixed GLM_FORCE_CXX** section in the manual\n   58: - Fixed default initialization with vector and quaternion types using GLM_FORCE_CTOR_INIT #812\n   59  \n   60  ### [GLM 0.9.9.1](https://github.com/g-truc/glm/releases/tag/0.9.9.1) - 2018-09-03\n   ..\n   70  #### Improvements:\n   71  - Added a section to the manual for contributing to GLM\n   72: - Refactor manual, lists all configuration defines\n   73: - Added missing vec1 based constructors\n   74  - Redesigned constexpr support which excludes both SIMD and constexpr #783\n   75  - Added detection of Visual C++ 2017 toolsets\n   ..\n   85  - Anonymous unions require C++ language extensions\n   86  - Fixed ortho #790\n   87: - Fixed Visual C++ 2013 warnings in vector relational code #782\n   88  - Fixed ICC build errors with constexpr #704\n   89: - Fixed defaulted operator= and constructors #791\n   90: - Fixed invalid conversion from int scalar with vec4 constructor when using SSE instruction\n   91  - Fixed infinite loop in random functions when using negative radius values using an assert #739\n   92  \n   ..\n   97  - Added GTX_vec_swizzle, faster compile time swizzling then swizzle operator #558\n   98  - Added GTX_exterior_product with a vec2 cross implementation #621\n   99: - Added GTX_matrix_factorisation to factor matrices in various forms #654\n  100  - Added [GLM_ENABLE_EXPERIMENTAL](manual.md#section7_4) to enable experimental features.\n  101: - Added packing functions for integer vectors #639\n  102  - Added conan packaging configuration #643 #641\n  103  - Added quatLookAt to GTX_quaternion #659\n  104  - Added fmin, fmax and fclamp to GTX_extended_min_max #372\n  105: - Added EXT_vector_relational: extend equal and notEqual to take an epsilon argument\n  106: - Added EXT_vector_relational: openBounded and closeBounded\n  107  - Added EXT_vec1: *vec1 types\n  108  - Added GTX_texture: levels function\n  ...\n  112  \n  113  #### Improvements:\n  114: - No more default initialization of vector, matrix and quaternion types\n  115  - Added lowp variant of GTC_color_space convertLinearToSRGB #419\n  116  - Replaced the manual by a markdown version #458\n  ...\n  148  - Fixed GLM_HAS_OPENMP when OpenMP is not enabled\n  149  - Fixed Better follow GLSL min and max specification #372\n  150: - Fixed quaternion constructor from two vectors special cases #469\n  151  - Fixed glm::to_string on quaternions wrong components order #681\n  152  - Fixed acsch #698\n  ...\n  207  - Added warning messages when using GLM_FORCE_CXX** but the compiler\n  208    is known to not fully support the requested C++ version #555\n  209: - Refactored GLM_COMPILER_VC values\n  210  - Made quat, vec, mat type component length() static #565\n  211  \n  ...\n  257  - Added PowerPC CPUs detection\n  258  - Use Cuda built-in function for abs function implementation with Cuda compiler\n  259: - Factorized GLM_COMPILER_LLVM and GLM_COMPILER_APPLE_CLANG into GLM_COMPILER_CLANG\n  260  - No more warnings for use of long long\n  261  - Added more information to build messages\n  ...\n  354  - Fixed link errors on compilers not supported default function #377\n  355  - Fixed compilation warnings in vec4\n  356: - Fixed non-identity quaternions for equal vectors #234\n  357  - Fixed excessive GTX_fast_trigonometry execution time #396\n  358  - Fixed Visual Studio 2015 'hides class member' warnings #394\n  ...\n  369  - Added <glm/gtx/hash.hpp> to perform std::hash on GLM types #320 #367\n  370  - Added <glm/gtx/wrap.hpp> for texcoord wrapping\n  371: - Added static components and precision members to all vector and quat types #350\n  372  - Added .gitignore #349\n  373  - Added support of defaulted functions to GLM types, to use them in unions #366\n  ...\n  453  ### [GLM 0.9.6.0](https://github.com/g-truc/glm/releases/tag/0.9.6.0) - 2014-11-30\n  454  #### Features:\n  455: - Exposed template vector and matrix types in 'glm' namespace #239, #244\n  456  - Added GTX_scalar_multiplication for C++ 11 compiler only #242\n  457  - Added GTX_range for C++ 11 compiler only #240\n  ...\n  470  - Added GTC_round extension, promoted GTX_bit\n  471  - Added GLM_FORCE_EXPLICIT_CTOR to require explicit type conversions #269\n  472: - Added GTX_type_aligned for aligned vector, matrix and quaternion types\n  473  \n  474  #### Improvements:\n  ...\n  482  - Optimized bitfieldReverse and bitCount functions\n  483  - Optimized findLSB and findMSB functions.\n  484: - Optimized matrix-vector multiple performance with Cuda #257, #258\n  485  - Reduced integer type redifinitions #233\n  486  - Rewrited of GTX_fast_trigonometry #264 #265\n  ...\n  499  - Fixed Visual Studio 14 compiler warnings\n  500  - Fixed implicit conversion from another tvec2 type to another tvec2 #241\n  501: - Fixed lack of consistency of quat and dualquat constructors\n  502  - Fixed uaddCarray #253\n  503  - Fixed float comparison warnings #270\n  ...\n  520  - Fixed glm::isinf and glm::isnan for with Android NDK 9d #191\n  521  - Fixed builtin GLM_ARCH_SSE4 #204\n  522: - Optimized Quaternion vector rotation #205\n  523  - Fixed missing doxygen @endcond tag #211\n  524  - Fixed instruction set detection with Clang #158\n  ...\n  529  - Fixed tweakedInfinitePerspective #208 and added user-defined epsilon to\n  530    tweakedInfinitePerspective\n  531: - Fixed std::copy and std::vector with GLM types #214\n  532  - Fixed strict aliasing issues #212, #152\n  533  - Fixed std::nextafter not supported with C++11 on Android #213\n  ...\n  559  - Fixed undefined reference to fastInverseSqrt (#161)\n  560  - Fixed GLM_FORCE_RADIANS with <glm/ext.hpp> build error (#165)\n  561: - Fix dot product clamp range for vector angle functions. (#163)\n  562  - Tentative fix for strict aliasing warning in GCC 4.8.1 / Android NDK 9c (#152)\n  563  - Fixed GLM_GTC_constants description brief (#162)\n  ...\n  606  - Allowed including individual core feature\n  607  - Increased unit tests completness\n  608: - Added creating of a quaternion from two vectors\n  609  - Added C++11 initializer lists\n  610: - Fixed umulExtended and imulExtended implementations for vector types (#76)\n  611  - Fixed CUDA coverage for GTC extensions\n  612  - Added GTX_io extension\n  ...\n  642  ### GLM 0.9.4.4 - 2013-05-29\n  643  - Fixed slerp when costheta is close to 1 #65\n  644: - Fixed mat4x2 value_type constructor #70\n  645  - Fixed glm.natvis for Visual C++ 12 #82\n  646  - Added assert in inversesqrt to detect division by zero #61\n  ...\n  707  - Fixed C++11 compiler option for GCC\n  708  - Removed MS language extension option for GCC (not fonctionnal)\n  709: - Fixed bitfieldExtract for vector types\n  710  - Fixed warnings\n  711  - Fixed SSE includes\n  ...\n  747  - Added support for Chrone Native Client\n  748  - Added epsilon constant\n  749: - Removed value_size function from vector types\n  750  - Fixed roundEven on GCC\n  751  - Improved API documentation\n  ...\n  759  - Added new swizzle operators for C++11 compilers\n  760  - Added new swizzle operators declared as functions\n  761: - Added GLSL 4.20 length for vector and matrix types\n  762  - Promoted GLM_GTC_noise extension: simplex, perlin, periodic noise functions\n  763  - Promoted GLM_GTC_random extension: linear, gaussian and various random number \n  ...\n  766  - Added extension versioning\n  767  - Removed many unused namespaces\n  768: - Fixed half based type contructors\n  769  - Added GLSL core noise functions\n  770  \n  771  ---\n  772  ### [GLM 0.9.2.7](https://github.com/g-truc/glm/releases/tag/0.9.2.7) - 2011-10-24\n  773: - Added more swizzling constructors\n  774  - Added missing none-squared matrix products\n  775  \n  ...\n  796  ---\n  797  ### GLM 0.9.2.2 - 2011-06-02\n  798: - Expend matrix constructors flexibility\n  799  - Improved quaternion implementation\n  800  - Fixed many warnings across platforms and compilers\n  ...\n  805  - Improved compiler detection\n  806  - Fixed errors and warnings in VC with C++ extensions disabled\n  807: - Fixed and tested GLM_GTX_vector_angle\n  808: - Fixed and tested GLM_GTX_rotate_vector\n  809  \n  810  ---\n  ...\n  993  ---\n  994  ### GLM 0.8.0 beta2 - 2008-10-04\n  995: - Improved half scalars and vectors support.\n  996  \n  997  ---\n\n/home/max/dev/Falcor/src/Externals/mikktspace/mikktspace.c:\n 1405  \n 1406              // weight contribution by the angle\n 1407:             // between the two edge vectors\n 1408              fCos = vdot(v1,v2); fCos=fCos>1?1:(fCos<(-1) ? (-1) : fCos);\n 1409              fAngle = (float) acos(fCos);\n\n/home/max/dev/Falcor/src/Externals/mikktspace/mikktspace.h:\n   81  \n   82      // This function is used to return the tangent and fSign to the application.\n   83:     // fvTangent is a unit length vector.\n   84      // For normal maps it is sufficient to use the following simplified version of the bitangent which is generated at pixel/vertex level.\n   85      // bitangent = fSign * cross(vN, tangent);\n   ..\n   90  \n   91      // This function is used to return tangent space results to the application.\n   92:     // fvTangent and fvBiTangent are unit length vectors and fMagS and fMagT are their\n   93      // true magnitudes which can be used for relief mapping effects.\n   94      // fvBiTangent is the \"real\" bitangent and thus may not be perpendicular to fvTangent.\n\n/home/max/dev/Falcor/src/Falcor/CMakeLists.txt:\n   44  \n   45  # ImGui\n   46: include_directories(${PROJECT_SOURCE_DIR}/third_party/imgui)\n   47  \n   48  # Assimp (built within project)\n   49  #set(CMAKE_PREFIX_PATH ${CMAKE_PREFIX_PATH} ${CMAKE_BINARY_DIR}/third_party/assimp)# ASSIMP search path\n   50  #find_package(assimp CONFIG REQUIRED)\n   51: #include_directories(${assimp_INCLUDE_DIRS})\n   52  #if (assimp_FOUND)\n   53  #    message(\"Assimp inc: ${ASSIMP_INCLUDE_DIR}\" )\n   ..\n   58  set(ASSIMP_BUILD_STATIC_LIB ON)\n   59  \n   60: # add assimp source dir as a subdirectory, effectively making \n   61  # assimp's CMakeLists.txt part of your build\n   62: add_subdirectory( ${PROJECT_SOURCE_DIR}/third_party/assimp ${CMAKE_BINARY_DIR}/assimp)\n   63  \n   64  \n   65  # GLFW \n   66  find_package(glfw3 CONFIG REQUIRED)\n   67: include_directories(${GLFW_INCLUDE_DIRS})\n   68  link_libraries(${GLFW_LIBRARIES})\n   69  \n   ..\n   98  # Python\n   99  find_package( PythonLibs 3.7 REQUIRED )\n  100: include_directories( ${PYTHON_INCLUDE_DIRS} )\n  101  \n  102  # FreeImage\n  103  find_package(FreeImage REQUIRED)\n  104: include_directories( ${FREEIMAGE_INCLUDE_DIRS} )\n  105  \n  106  # TIFF (required by FreeImage )\n  107  find_package( TIFF REQUIRED )\n  108: include_directories( ${TIFF_INCLUDE_DIRS} )\n  109  \n  110  # Find Boost libs\n  111  find_package( Boost COMPONENTS system filesystem REQUIRED )\n  112: include_directories( ${Boost_INCLUDE_DIRS} )\n  113  \n  114  # We use Boost static libs\n\n/home/max/dev/Falcor/src/Falcor/Core/API/BlendState.h:\n   66          DstAlpha,               ///< The render-target alpha value\n   67          OneMinusDstAlpha,       ///< One minus the render-target alpha value\n   68:         BlendFactor,            ///< Constant color, set using Desc#SetBlendFactor()\n   69:         OneMinusBlendFactor,    ///< One minus constant color, set using Desc#SetBlendFactor()\n   70          SrcAlphaSaturate,       ///< (f, f, f, 1), where f = min(fragment shader output alpha, 1 - render-target pixel alpha)\n   71          Src1Color,              ///< Fragment-shader output color 1\n   ..\n   82          friend class BlendState;\n   83  \n   84:         /** Set the constant blend factor\n   85:             \\param[in] factor Blend factor\n   86          */\n   87:         Desc& setBlendFactor(const float4& factor) { mBlendFactor = factor; return *this; }\n   88  \n   89          /** Enable/disable independent blend modes for different render target. Only used when multiple render-targets are bound.\n   ..\n  134  \n  135       protected:\n  136:         std::vector<RenderTargetDesc> mRtDesc;\n  137          bool mEnableIndependentBlend = false;\n  138          bool mAlphaToCoverageEnabled = false;\n  139:         float4 mBlendFactor          = float4(0, 0, 0, 0);\n  140      \n  141          std::shared_ptr<Device> mpDevice;\n  ...\n  150      static BlendState::SharedPtr create(const Desc& desc);\n  151  \n  152:     /** Get the constant blend factor color\n  153      */\n  154:     const float4& getBlendFactor() const { return mDesc.mBlendFactor; }\n  155  \n  156      /** Get the RGB blend operation\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Buffer.cpp:\n  124      bool createCounter)\n  125  {\n  126:     const auto& pDefaultBlock = pProgram->getReflector()->getDefaultParameterBlock();\n  127      const ReflectionVar* pVar = pDefaultBlock ? pDefaultBlock->getResource(name).get() : nullptr;\n  128      if (pVar == nullptr) {\n\n/home/max/dev/Falcor/src/Falcor/Core/API/CopyContext.cpp:\n   67  }\n   68  \n   69: std::vector<uint8_t> CopyContext::readTextureSubresource(const Texture* pTexture, uint32_t subresourceIndex) {\n   70      CopyContext::ReadTextureTask::SharedPtr pTask = asyncReadTextureSubresource(pTexture, subresourceIndex);\n   71      return pTask->getData();\n\n/home/max/dev/Falcor/src/Falcor/Core/API/CopyContext.h:\n   50          using SharedPtr = std::shared_ptr<ReadTextureTask>;\n   51          static SharedPtr create(CopyContext* pCtx, const Texture* pTexture, uint32_t subresourceIndex);\n   52:         std::vector<uint8_t> getData();\n   53  \n   54       private:\n   ..\n  133      /** Read texture data synchronously. Calling this command will flush the pipeline and wait for the GPU to finish execution\n  134      */\n  135:     std::vector<uint8_t> readTextureSubresource(const Texture* pTexture, uint32_t subresourceIndex);\n  136  \n  137      /** Read texture data Asynchronously\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12ComputeStateObject.cpp:\n   35  {\n   36  #if _ENABLE_NVAPI\n   37:     bool getNvApiComputePsoDesc(const ComputeStateObject::Desc& desc, std::vector<NvApiPsoExDesc>& nvApiPsoExDescs)\n   38      {\n   39          auto ret = NvAPI_Initialize();\n   ..\n   54      }\n   55  \n   56:     ComputeStateObject::ApiHandle getNvApiComputePsoHandle(const std::vector<NvApiPsoExDesc>& nvDescVec, const D3D12_COMPUTE_PIPELINE_STATE_DESC& desc)\n   57      {\n   58          assert(nvDescVec.size() <= 1);\n   ..\n   85  \n   86  #else\n   87:     bool getNvApiComputePsoDesc(const ComputeStateObject::Desc& desc, std::vector<NvApiPsoExDesc>& nvApiPsoExDescs) { should_not_get_here(); return false; }\n   88:     ComputeStateObject::ApiHandle getNvApiComputePsoHandle(const std::vector<NvApiPsoExDesc>& psoDesc, const D3D12_COMPUTE_PIPELINE_STATE_DESC& desc) { should_not_get_here(); return nullptr; }\n   89      bool getIsNvApiComputePsoRequired(const ComputeStateObject::Desc& desc) { return false; }\n   90  #endif\n   ..\n  102          if (getIsNvApiComputePsoRequired(mDesc))\n  103          {\n  104:             std::vector<NvApiPsoExDesc> nvApiDesc;\n  105              bool ret = getNvApiComputePsoDesc(mDesc, nvApiDesc);\n  106              if (!ret) throw std::exception(\"Failed to create compute PSO desc with NVAPI extensions\");\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12CopyContext.cpp:\n   84          // Get the footprint\n   85          D3D12_RESOURCE_DESC texDesc = pTexture->getApiHandle()->GetDesc();\n   86:         std::vector<D3D12_PLACED_SUBRESOURCE_FOOTPRINT> footprint(subresourceCount);\n   87:         std::vector<uint32_t> rowCount(subresourceCount);\n   88:         std::vector<uint64_t> rowSize(subresourceCount);\n   89          uint64_t bufferSize;\n   90  \n   ..\n  173      }\n  174  \n  175:     std::vector<uint8_t> CopyContext::ReadTextureTask::getData()\n  176      {\n  177          mpFence->syncCpu();\n  ...\n  179  \n  180          //Get buffer data\n  181:         std::vector<uint8_t> result;\n  182          uint32_t actualRowSize = footprint.Footprint.Width * getFormatBytesPerBlock(mTextureFormat);\n  183          result.resize(mRowCount * actualRowSize);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12DescriptorData.h:\n   39      {\n   40          D3D12DescriptorHeap::Allocation::SharedPtr pAllocation; // The heap-allocation. We always allocate a single contiguous block, even if there are multiple ranges.\n   41:         std::vector<uint32_t> rangeBaseOffset;                  // For each range, we store the base offset into the allocation. We need it because many set calls accpet a range index.\n   42      };\n   43  }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12DescriptorHeap.h:\n  135  \n  136          Chunk::SharedPtr mpCurrentChunk;\n  137:         std::vector<Chunk::SharedPtr> mFreeChunks; // Free list for standard sized chunks (1 chunk * kDescPerChunk)\n  138          std::multiset<Chunk::SharedPtr, ChunkComparator> mFreeLargeChunks; // Free list for large chunks with the capacity of multiple chunks (>1 chunk * kDescPerChunk)\n  139      };\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Device.cpp:\n   33      struct DeviceApiData\n   34      {\n   35:         IDXGIFactory4Ptr pDxgiFactory = nullptr;\n   36          IDXGISwapChain3Ptr pSwapChain = nullptr;\n   37          bool isWindowOccluded = false;\n   ..\n   94      }\n   95  \n   96:     IDXGISwapChain3Ptr createDxgiSwapChain(IDXGIFactory4* pFactory, const Window* pWindow, ID3D12CommandQueue* pCommandQueue, ResourceFormat colorFormat, uint32_t bufferCount)\n   97      {\n   98          DXGI_SWAP_CHAIN_DESC1 swapChainDesc = {};\n   ..\n  111          IDXGISwapChain1Ptr pSwapChain;\n  112  \n  113:         HRESULT hr = pFactory->CreateSwapChainForHwnd(pCommandQueue, pWindow->getApiHandle(), &swapChainDesc, nullptr, nullptr, &pSwapChain);\n  114          if (FAILED(hr))\n  115          {\n  ...\n  123      }\n  124  \n  125:     DeviceHandle createDevice(IDXGIFactory4* pFactory, D3D_FEATURE_LEVEL requestedFeatureLevel, const std::vector<UUID>& experimentalFeatures)\n  126      {\n  127          // Feature levels to try creating devices. Listed in descending order so the highest supported level is used.\n  ...\n  174  \n  175          uint32_t gpuDeviceId = 0;\n  176:         for (uint32_t i = 0; DXGI_ERROR_NOT_FOUND != pFactory->EnumAdapters1(i, &pAdapter); i++)\n  177          {\n  178              DXGI_ADAPTER_DESC1 desc;\n  ...\n  294          }\n  295  \n  296:         // Create the DXGI factory\n  297:         d3d_call(CreateDXGIFactory2(dxgiFlags, IID_PPV_ARGS(&mpApiData->pDxgiFactory)));\n  298  \n  299          // Create the device\n  300:         mApiHandle = createDevice(mpApiData->pDxgiFactory, getD3DFeatureLevel(mDesc.apiMajorVersion, mDesc.apiMinorVersion), mDesc.experimentalFeatures);\n  301          if (mApiHandle == nullptr) return false;\n  302  \n  ...\n  351      bool Device::createSwapChain(ResourceFormat colorFormat)\n  352      {\n  353:         mpApiData->pSwapChain = createDxgiSwapChain(mpApiData->pDxgiFactory, mpWindow.get(), getCommandQueueHandle(LowLevelContextData::CommandQueueType::Direct, 0), colorFormat, kSwapChainBuffersCount);\n  354          if (mpApiData->pSwapChain == nullptr) return false;\n  355          return true;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12GraphicsStateObject.cpp:\n   36  {\n   37  #if _ENABLE_NVAPI\n   38:     bool getNvApiGraphicsPsoDesc(const GraphicsStateObject::Desc& desc, std::vector<NvApiPsoExDesc>& nvApiPsoExDescs)\n   39      {\n   40          auto ret = NvAPI_Initialize();\n   ..\n   55      }\n   56  \n   57:     GraphicsStateObject::ApiHandle getNvApiGraphicsPsoHandle(const std::vector<NvApiPsoExDesc>& nvDescVec, const D3D12_GRAPHICS_PIPELINE_STATE_DESC& desc)\n   58      {\n   59          const NVAPI_D3D12_PSO_EXTENSION_DESC* ppPSOExtensionsDesc[5];\n   ..\n   88      }\n   89  #else\n   90:     bool getNvApiGraphicsPsoDesc(const GraphicsStateObject::Desc& desc, std::vector<NvApiPsoExDesc>& nvApiPsoExDescs) { should_not_get_here(); return false; }\n   91:     GraphicsStateObject::ApiHandle getNvApiGraphicsPsoHandle(const std::vector<NvApiPsoExDesc>& psoDesc, const D3D12_GRAPHICS_PIPELINE_STATE_DESC& desc) { should_not_get_here(); return nullptr; }\n   92      bool getIsNvApiGraphicsPsoRequired(const GraphicsStateObject::Desc& desc) { return false; }\n   93  #endif\n   ..\n  101          if (getIsNvApiGraphicsPsoRequired(mDesc))\n  102          {\n  103:             std::vector<NvApiPsoExDesc> nvApiDesc;\n  104              bool ret = getNvApiGraphicsPsoDesc(mDesc, nvApiDesc);\n  105              if (!ret) throw std::exception(\"Failed to create graphics PSO desc with NVAPI extensions\");\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12NvApiExDesc.h:\n   37          NVAPI_D3D12_PSO_GEOMETRY_SHADER_DESC mGsExDesc;\n   38          NVAPI_D3D12_PSO_SET_SHADER_EXTENSION_SLOT_DESC mExtSlotDesc;\n   39:         std::vector<NV_CUSTOM_SEMANTIC> mCustomSemantics;\n   40      };\n   41  \n   ..\n   85      inline std::optional<uint32_t> findNvApiShaderRegister(ProgramKernels::SharedConstPtr const& pKernels)\n   86      {\n   87:         auto pBlock = pKernels->getReflector()->getDefaultParameterBlock();\n   88          auto pVar = pBlock->getResource(\"g_NvidiaExt\");\n   89          if (!pVar) return std::optional<uint32_t>();\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12RenderContext.cpp:\n   95                  blitData.pPointSampler = Sampler::create(desc);\n   96  \n   97:                 const auto& pDefaultBlockReflection = blitData.pPass->getProgram()->getReflector()->getDefaultParameterBlock();\n   98                  blitData.texBindLoc = pDefaultBlockReflection->getResourceBinding(\"gTex\");\n   99  \n  ...\n  194          uint32_t colorTargets = Fbo::getMaxColorTargetCount();\n  195          auto pNullRtv = RenderTargetView::getNullView();\n  196:         std::vector<HeapCpuHandle> pRTV(colorTargets, pNullRtv->getApiHandle()->getCpuHandle(0));\n  197          HeapCpuHandle pDSV = DepthStencilView::getNullView()->getApiHandle()->getCpuHandle(0);\n  198  \n  ...\n  317  \n  318          BlendState::SharedPtr blendState = pState->getBlendState();\n  319:         if (blendState != nullptr)  pList->OMSetBlendFactor(glm::value_ptr(blendState->getBlendFactor()));\n  320  \n  321          const auto pDsState = pState->getDepthStencilState();\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12RootSignature.cpp:\n   35      void RootSignature::apiInit()\n   36      {\n   37:         // Get vector of root parameters\n   38          RootSignatureParams params;\n   39          initD3D12RootParams(mDesc, params);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12State.cpp:\n   57          case BlendState::BlendFunc::OneMinusDstAlpha:\n   58              return D3D12_BLEND_INV_DEST_ALPHA;\n   59:         case BlendState::BlendFunc::BlendFactor:\n   60              return D3D12_BLEND_BLEND_FACTOR;\n   61:         case BlendState::BlendFunc::OneMinusBlendFactor:\n   62              return D3D12_BLEND_INV_BLEND_FACTOR;\n   63          case BlendState::BlendFunc::SrcAlphaSaturate:\n   ..\n  436      }\n  437  \n  438:     void convertRootDescTable(const RootSignature::DescriptorSetLayout& falcorSet, D3D12_ROOT_PARAMETER1& desc, std::vector<D3D12_DESCRIPTOR_RANGE1>& d3dRange)\n  439      {\n  440          desc.ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12State.h:\n   27   **************************************************************************/\n   28  #pragma  once\n   29: #include <vector>\n   30  #include \"Core/API/RootSignature.h\"\n   31  #include \"Core/API/VAO.h\"\n   ..\n   43      struct InputLayoutDesc\n   44      {\n   45:         std::vector<D3D12_INPUT_ELEMENT_DESC> elements;\n   46:         std::vector<std::unique_ptr<char[]>> names; // Can't use strings directly because the vector size is unknown and vector reallocations will change the addresses we used in INPUT_ELEMENT_DESC \n   47      };\n   48  \n   ..\n   56      struct RootSignatureParams\n   57      {\n   58:         using RootParameterVec = std::vector<D3D12_ROOT_PARAMETER1>;\n   59          RootParameterVec rootParams;\n   60:         std::vector<std::vector<D3D12_DESCRIPTOR_RANGE1>> d3dRanges;\n   61          uint32_t signatureSizeInBytes;\n   62:         std::vector<uint32_t> elementByteOffset;\n   63      };\n   64  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/FalcorD3D12.h:\n  119      inline std::string convertBlobToString(BlobType* pBlob)\n  120      {\n  121:         std::vector<char> infoLog(pBlob->GetBufferSize() + 1);\n  122          memcpy(infoLog.data(), pBlob->GetBufferPointer(), pBlob->GetBufferSize());\n  123          infoLog[pBlob->GetBufferSize()] = 0;\n  ...\n  177      MAKE_SMART_COM_PTR(IDXGIDevice);\n  178      MAKE_SMART_COM_PTR(IDXGIAdapter1);\n  179:     MAKE_SMART_COM_PTR(IDXGIFactory4);\n  180      MAKE_SMART_COM_PTR(ID3DBlob);\n  181  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/DescriptorPool.h:\n  123      };\n  124  \n  125:     std::priority_queue<DeferredRelease, std::vector<DeferredRelease>, std::greater<DeferredRelease>> mpDeferredReleases;\n  126  };\n  127  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/DescriptorSet.h:\n   29  #define SRC_FALCOR_CORE_API_DESCRIPTORSET_H_\n   30  \n   31: #include <vector>\n   32  #include <memory>\n   33  \n   ..\n   85          ShaderVisibility getVisibility() const { return mVisibility; }\n   86       private:\n   87:         std::vector<Range> mRanges;\n   88          ShaderVisibility mVisibility;\n   89      };\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Device.cpp:\n   43  Device::SharedPtr _gpDeviceHeadless;\n   44  \n   45: std::vector<Device::SharedPtr> _gDevices;\n   46: std::vector<Device::SharedPtr> _gDevicesHeadless;\n   47  \n   48  std::atomic<std::uint8_t> Device::UID = 0;\n   ..\n  392  \n  393      auto deviceClass = m.regClass(Device);\n  394:     //deviceClass.ctor(&Device::create);\n  395:     deviceClass.ctor(&create_headless);\n  396  }\n  397  \n  ...\n  401  SCRIPT_BINDING(RenderGraph) {\n  402      auto graphClass = m.regClass(RenderGraph);\n  403:     graphClass.ctor(&RenderGraph::create);\n  404      graphClass.property(\"name\", &RenderGraph::getName, &RenderGraph::setName);\n  405      graphClass.func_(RenderGraphIR::kAddPass, &RenderGraph::addPass, \"pass\"_a, \"name\"_a);\n  ...\n  426          return pPass;\n  427      };\n  428:     passClass.ctor(createRenderPass, \"device\"_a, \"name\"_a, \"dict\"_a = pybind11::dict());\n  429  \n  430      const auto& loadPassLibrary = [](const std::string& library) {\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Device.h:\n   33  #include <memory>\n   34  #include <queue>\n   35: #include <vector>\n   36  #include <atomic>\n   37  \n   ..\n   82  #ifdef FALCOR_D3D12\n   83          // GUID list for experimental features\n   84:         std::vector<UUID> experimentalFeatures;\n   85  #endif\n   86  \n   87  #ifdef FALCOR_VK\n   88:         std::vector<std::string> requiredExtensions;\n   89  #endif\n   90  \n   ..\n  119      uint8_t uid() { return _uid; }\n  120  \n  121:     /** Acts as the destructor for Device. Some resources use gpDevice in their cleanup.\n  122:         Cleaning up the SharedPtr directly would clear gpDevice before calling destructors.\n  123      */\n  124      void cleanup();\n  ...\n  251      std::list<QueryHeap::SharedPtr> mTimestampQueryHeaps;\n  252      double mGpuTimestampFrequency;\n  253:     std::vector<CommandQueueHandle> mCmdQueues[kQueueTypeCount];\n  254  \n  255      bool headless = false;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/DeviceManager.cpp:\n   39      \n   40  DeviceManager::DeviceManager() {\n   41:     LOG_DBG(\"DeviceManager constructor called.\");\n   42      mDeviceNames = {};\n   43      initialized = init();\n   ..\n   46  }\n   47  \n   48: std::vector<Device::SharedPtr> DeviceManager::displayDevices() {\n   49:     std::vector<Device::SharedPtr> devices;\n   50      for( auto& device: mDisplayDevices ) {\n   51          devices.push_back(device.second);\n   ..\n   54  }\n   55  \n   56: std::vector<Device::SharedPtr> DeviceManager::renderingDevices() {\n   57:     std::vector<Device::SharedPtr> devices;\n   58      for( auto& device: mRenderingDevices ) {\n   59          devices.push_back(device.second);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/DeviceManager.h:\n   33  #include <memory>\n   34  #include <queue>\n   35: #include <vector>\n   36  #include <atomic>\n   37  #include <unordered_map>\n   ..\n   57  \n   58      const std::unordered_map<DeviceLocalUID, std::string>& listDevices() { return mDeviceNames; }\n   59:     std::vector<Device::SharedPtr> displayDevices();\n   60:     std::vector<Device::SharedPtr> renderingDevices();\n   61  \n   62      Device::SharedPtr displayDevice(DeviceLocalUID luid);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/FBO.cpp:\n  182      }\n  183  \n  184:     Fbo::SharedPtr Fbo::create(std::shared_ptr<Device> pDevice, const std::vector<Texture::SharedPtr>& colors, const Texture::SharedPtr& pDepth) {\n  185          auto pFbo = create(pDevice);\n  186          for (uint32_t i = 0 ; i < colors.size() ; i++) {\n  ...\n  341      void Fbo::setSamplePositions(uint32_t samplesPerPixel, uint32_t pixelCount, const SamplePosition positions[]) {\n  342          if (positions) {\n  343:             mSamplePositions = std::vector<SamplePosition>(positions, positions + (samplesPerPixel * pixelCount));\n  344              mSamplePositionsPixelCount = pixelCount;\n  345          } else {\n\n/home/max/dev/Falcor/src/Falcor/Core/API/FBO.h:\n  107          };\n  108  \n  109:         std::vector<TargetDesc> mColorTargets;\n  110          TargetDesc mDepthStencilTarget;\n  111          uint32_t mSampleCount = 1;\n  ...\n  120      static const uint32_t kAttachEntireMipLevel = uint32_t(-1);\n  121  \n  122:     /** Destructor. Releases the API object\n  123      */\n  124      ~Fbo();\n  ...\n  134  \n  135      /** Create an FBO from a list of textures. It will bind mip 0 and the all of the array slices.\n  136:         \\param[in] colors A vector with color textures. The index in the vector corresponds to the render target index in the shader. You can use nullptr for unused indices.\n  137          \\param[in] depth An optional depth buffer texture.\n  138          \\return A new object. An exception is thrown if creation failed, for example due to texture size mismatch, bind flags issues, illegal formats, etc.\n  139      */\n  140:     static SharedPtr create(std::shared_ptr<Device> pDevice, const std::vector<Texture::SharedPtr>& colors, const Texture::SharedPtr& pDepth = nullptr);\n  141  \n  142      /** Create a color-only 2D framebuffer.\n  ...\n  243      /** Get the sample positions\n  244      */\n  245:     const std::vector<SamplePosition> getSamplePositions() const { return mSamplePositions; }\n  246  \n  247      /** Get the number of pixels the sample positions are configured for\n  ...\n  276  \n  277      Fbo(std::shared_ptr<Device> pDevice);\n  278:     std::vector<Attachment> mColorAttachments;\n  279:     std::vector<SamplePosition> mSamplePositions;\n  280      uint32_t mSamplePositionsPixelCount = 0;\n  281  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/RenderContext.h:\n   30  \n   31  #include <stack>\n   32: #include <vector>\n   33  #include <memory>\n   34  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Resource.h:\n   31  #include <string>\n   32  #include <memory>\n   33: #include <vector>\n   34  #include <unordered_map>\n   35  \n   ..\n  185          bool isGlobal = true;\n  186          State global = State::Undefined;\n  187:         std::vector<State> perSubresource;\n  188      } mutable mState;\n  189  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/ResourceViews.h:\n   29  #define SRC_FALCOR_CORE_API_RESOURCEVIEWS_H_\n   30  \n   31: #include <vector>\n   32  #include <memory>\n   33  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/RootSignature.cpp:\n  138          assert(resourceRange.count == 1);  // TODO: The code here does not handle arrays of sub-objects\n  139  \n  140:         addParamBlockSets(bindingInfo.pSubObjectReflector.get(), ioDesc);\n  141      }\n  142  }\n  ...\n  168          assert(resourceRange.count == 1);  // TODO: The code here does not handle arrays of sub-objects\n  169  \n  170:         addRootDescriptors(bindingInfo.pSubObjectReflector.get(), ioDesc);\n  171      }\n  172  }\n  173  \n  174: RootSignature::SharedPtr RootSignature::create(std::shared_ptr<Device> device, const ProgramReflection* pReflector) {\n  175:     assert(pReflector);\n  176      RootSignature::Desc d;\n  177:     addParamBlockSets(pReflector->getDefaultParameterBlock().get(), d);\n  178:     addRootDescriptors(pReflector->getDefaultParameterBlock().get(), d);\n  179      return RootSignature::create(device, d);\n  180  }\n  181  \n  182: RootSignature::SharedPtr RootSignature::createLocal(std::shared_ptr<Device> device, const EntryPointBaseReflection* pReflector) {\n  183:     assert(pReflector);\n  184      RootSignature::Desc d;\n  185:     addParamBlockSets(pReflector, d);\n  186:     addRootDescriptors(pReflector, d);\n  187  \n  188  #ifdef FALCOR_D3D12\n\n/home/max/dev/Falcor/src/Falcor/Core/API/RootSignature.h:\n   29  #define SRC_FALCOR_CORE_API_ROOTSIGNATURE_H_\n   30  \n   31: #include <vector>\n   32  #include <memory>\n   33  \n   ..\n   80          Desc& addDescriptorSet(const DescriptorSetLayout& setLayout);\n   81          Desc& addRootDescriptor(DescType type, uint32_t regIndex, uint32_t spaceIndex, ShaderVisibility visibility = ShaderVisibility::All);\n   82:         Desc& addRootConstants(uint32_t regIndex, uint32_t spaceIndex, uint32_t count);  // #SHADER_VAR Make sure this works with the reflectors\n   83  \n   84  #ifdef FALCOR_D3D12\n   ..\n   98          friend class RootSignature;\n   99  \n  100:         std::vector<DescriptorSetLayout> mSets;\n  101:         std::vector<RootDescriptorDesc> mRootDescriptors;\n  102:         std::vector<RootConstantsDesc> mRootConstants;\n  103  \n  104  #ifdef FALCOR_D3D12\n  ...\n  130          \\return New object, or throws an exception if creation failed.\n  131      */\n  132:     static SharedPtr createLocal(std::shared_ptr<Device> device, const EntryPointGroupReflection* pReflector);\n  133  \n  134      const ApiHandle& getApiHandle() const { return mApiHandle; }\n  ...\n  163  \n  164      uint32_t mSizeInBytes;\n  165:     std::vector<uint32_t> mElementByteOffset;\n  166  \n  167      std::shared_ptr<Device> mpDevice;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Texture.cpp:\n   26   # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n   27   **************************************************************************/\n   28: #include <vector>\n   29  \n   30  #include \"Falcor/stdafx.h\"\n   ..\n  228      uint32_t channels;\n  229      ResourceFormat resourceFormat;\n  230:     std::vector<uint8_t> textureData;\n  231  \n  232      readTextureData(mipLevel, arraySlice, textureData, resourceFormat, channels);\n  ...\n  239  }\n  240  \n  241: void Texture::readTextureData(uint32_t mipLevel, uint32_t arraySlice, std::vector<uint8_t>& textureData, ResourceFormat& resourceFormat, uint32_t& channels) {\n  242      assert(mType == Type::Texture2D);\n  243      RenderContext* pContext = mpDevice->getRenderContext();\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Texture.h:\n  173  \n  174      /** Create a new texture object from a file.\n  175:         \\param[in] filename Filename of the image. Can also include a full path or relative path from a data directory.\n  176          \\param[in] generateMipLevels Whether the mip-chain should be generated.\n  177          \\param[in] loadAsSrgb Load the texture using sRGB format. Only valid for 3 or 4 component textures.\n  ...\n  234          \\param[out] channels Texture data channels number\n  235      */\n  236:     void readTextureData(uint32_t mipLevel, uint32_t arraySlice, std::vector<uint8_t>& textureData, ResourceFormat& resourceFormat, uint32_t& channels);\n  237  \n  238  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/TextureLoader.cpp:\n  450  void flipData(DdsData& ddsData, ResourceFormat format, uint32_t width, uint32_t height, uint32_t depth, uint32_t mipDepth, bool isCubemap = false) {\n  451      if (!isCompressedFormat(format) && !kTopDown) {\n  452:         std::vector<uint8_t> oldData(ddsData.data.size());\n  453          oldData.swap(ddsData.data);\n  454          const uint8_t* currentTexture = oldData.data();\n  ...\n  609  Texture::SharedPtr Texture::createFromFile(std::shared_ptr<Device> device, const std::string& filename, bool generateMipLevels, bool loadAsSrgb, Texture::BindFlags bindFlags) {\n  610      std::string fullpath;\n  611:     if (findFileInDataDirectories(filename, fullpath) == false) {\n  612          logError(\"Error when loading image file. Can't find image file \" + filename);\n  613          return nullptr;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/VAO.h:\n   29  #define SRC_FALCOR_CORE_API_VAO_H_\n   30  \n   31: #include <vector>\n   32  #include <memory>\n   33  \n   ..\n   64      };\n   65  \n   66:     using BufferVec = std::vector<Buffer::SharedPtr>;\n   67  \n   68      /** Create a new vertex array object.\n\n/home/max/dev/Falcor/src/Falcor/Core/API/VertexLayout.h:\n   29  #define SRC_FALCOR_CORE_API_VERTEXLAYOUT_H_\n   30  \n   31: #include <vector>\n   32  #include <string>\n   33  #include <memory>\n   ..\n  147      };\n  148  \n  149:     std::vector<Element> mElements;\n  150      InputClass mClass = InputClass::PerVertexData;\n  151      uint32_t mInstanceStepRate = 0;\n  ...\n  186   private:\n  187      VertexLayout() { mpBufferLayouts.reserve(16); }\n  188:     std::vector<VertexBufferLayout::SharedConstPtr> mpBufferLayouts;\n  189  };\n  190  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKComputeContext.cpp:\n  131              if ((value.x != value.y) || ((value.x != value.z) && (value.x != value.w)))\n  132              {\n  133:                 logWarning(\"Vulkan buffer clears only support a single element. A vector was supplied which has different elements per channel. only `x` will be used'\");\n  134              }\n  135              const Buffer* pBuffer = dynamic_cast<const Buffer*>(pUav->getResource());\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKComputeStateObject.cpp:\n   26   # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n   27   **************************************************************************/\n   28: #include <vector>\n   29  \n   30  #include \"Falcor/stdafx.h\"\n   ..\n   38  \n   39  void ComputeStateObject::apiInit() {\n   40:     std::vector<VkPipelineShaderStageCreateInfo> shaderStageInfos;\n   41      //initVkShaderStageInfo(mDesc.getProgramVersion().get(), shaderStageInfos);\n   42      initVkShaderStageInfo(mDesc.getProgramKernels(), shaderStageInfos);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKCopyContext.cpp:\n  228      }\n  229  \n  230:     std::vector<uint8_t> CopyContext::ReadTextureTask::getData() {\n  231          mpFence->syncCpu();\n  232          // Map and read the results\n  233:         std::vector<uint8_t> result(mDataSize);\n  234          uint8_t* pData = reinterpret_cast<uint8_t*>(mpBuffer->map(Buffer::MapType::Read));\n  235          std::memcpy(result.data(), pData, mDataSize);\n  ...\n  327  \n  328              uint32_t mipCount = pSrcTex->getMipCount();\n  329:             std::vector<VkImageCopy> regions(mipCount);\n  330              VkImageAspectFlags srcAspect = getAspectFlagsFromFormat(pSrcTex->getFormat());\n  331              VkImageAspectFlags dstAspect = getAspectFlagsFromFormat(pDstTex->getFormat());\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKDevice.cpp:\n  164      assert(imageCount == kSwapChainBuffersCount);\n  165  \n  166:     std::vector<VkImage> swapchainImages(imageCount);\n  167      vkGetSwapchainImagesKHR(mApiHandle, mpApiData->swapchain, &imageCount, swapchainImages.data());\n  168      for (size_t i = 0; i < swapchainImages.size(); i++) {\n  ...\n  188  }\n  189  \n  190: static std::vector<VkLayerProperties> enumarateInstanceLayersProperties() {\n  191      uint32_t layerCount = 0;\n  192      vkEnumerateInstanceLayerProperties(&layerCount, nullptr);\n  193:     std::vector<VkLayerProperties> layerProperties(layerCount);\n  194      vkEnumerateInstanceLayerProperties(&layerCount, layerProperties.data());\n  195  \n  ...\n  201  }\n  202  \n  203: static bool isLayerSupported(const std::string& layer, const std::vector<VkLayerProperties>& supportedLayers) {\n  204      for (const auto& l : supportedLayers) {\n  205          if (l.layerName == layer) return true;\n  ...\n  208  }\n  209  \n  210: void enableLayerIfPresent(const char* layerName, const std::vector<VkLayerProperties>& supportedLayers, std::vector<const char*>& requiredLayers) {\n  211      if (isLayerSupported(layerName, supportedLayers)) {\n  212          requiredLayers.push_back(layerName);\n  ...\n  216  }\n  217  \n  218: static std::vector<VkExtensionProperties> enumarateInstanceExtensions() {\n  219      // Enumerate implicitly available extensions. The debug layers above just have VK_EXT_debug_report\n  220      uint32_t extensionCount = 0;\n  221      vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, nullptr);\n  222:     std::vector<VkExtensionProperties> supportedExtensions(extensionCount);\n  223      vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, supportedExtensions.data());\n  224  \n  ...\n  253  \n  254  \n  255: static bool isExtensionSupported(const std::string& str, const std::vector<VkExtensionProperties>& vec) {\n  256      for (const auto& s : vec) {\n  257          if (str == std::string(s.extensionName)) return true;\n  ...\n  263      // Initialize the layers\n  264      const auto layerProperties = enumarateInstanceLayersProperties();\n  265:     std::vector<const char*> requiredLayers;\n  266  \n  267      if (enableDebugLayer) {\n  ...\n  270  \n  271      // Initialize the extensions\n  272:     std::vector<VkExtensionProperties> supportedExtensions = enumarateInstanceExtensions();\n  273  \n  274      // Extensions to use when creating instance\n  275:     std::vector<const char*> requiredExtensions = {\n  276          \"VK_KHR_surface\",\n  277  #ifdef _WIN32\n  ...\n  309  /** Select best physical device based on memory\n  310  */\n  311: VkPhysicalDevice selectPhysicalDevice(const std::vector<VkPhysicalDevice>& devices) {\n  312      LOG_DBG(\"Selecting physical Vulkan device...\");\n  313      VkPhysicalDevice bestDevice = VK_NULL_HANDLE;\n  ...\n  347      assert(count > 0);\n  348  \n  349:     std::vector<VkPhysicalDevice> devices(count);\n  350      vkEnumeratePhysicalDevices(instance, &count, devices.data());\n  351  \n  ...\n  368      vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, &queueFamilyCount, nullptr);\n  369  \n  370:     std::vector<VkQueueFamilyProperties> queueFamilyProperties(queueFamilyCount);\n  371      vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, &queueFamilyCount, queueFamilyProperties.data());\n  372  \n  ...\n  396  }\n  397  \n  398: static void initDeviceQueuesInfo(const Device::Desc& desc, const DeviceApiData *pData, std::vector<VkDeviceQueueCreateInfo>& queueInfos, std::vector<CommandQueueHandle> cmdQueues[Device::kQueueTypeCount], std::vector<std::vector<float>>& queuePriorities) {\n  399      queuePriorities.resize(arraysize(pData->falcorToVulkanQueueType));\n  400  \n  ...\n  417  }\n  418  \n  419: VkDevice createLogicalDevice(VkPhysicalDevice physicalDevice, DeviceApiData *pData, const Device::Desc& desc, std::vector<CommandQueueHandle> cmdQueues[Device::kQueueTypeCount]) {\n  420      // Features\n  421      VkPhysicalDeviceFeatures requiredFeatures;\n  ...\n  423  \n  424      // Queues\n  425:     std::vector<VkDeviceQueueCreateInfo> queueInfos;\n  426:     std::vector<std::vector<float>> queuePriorities;\n  427      initDeviceQueuesInfo(desc, pData, queueInfos, cmdQueues, queuePriorities);\n  428  \n  ...\n  437      }\n  438  \n  439:     std::vector<const char*> extensionNames = { \"VK_KHR_swapchain\" };\n  440      assert(isExtensionSupported(extensionNames[0], pData->deviceExtensions));\n  441  \n  ...\n  535      uint32_t formatCount = 0;\n  536      vkGetPhysicalDeviceSurfaceFormatsKHR(mApiHandle, mApiHandle, &formatCount, nullptr);\n  537:     std::vector<VkSurfaceFormatKHR> surfaceFormats(formatCount);\n  538      vkGetPhysicalDeviceSurfaceFormatsKHR(mApiHandle, mApiHandle, &formatCount, surfaceFormats.data());\n  539  \n  ...\n  554      uint32_t presentModeCount = 0;\n  555      vkGetPhysicalDeviceSurfacePresentModesKHR(mApiHandle, mApiHandle, &presentModeCount, nullptr);\n  556:     std::vector<VkPresentModeKHR> presentModes(presentModeCount);\n  557      vkGetPhysicalDeviceSurfacePresentModesKHR(mApiHandle, mApiHandle, &presentModeCount, presentModes.data());\n  558  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKDevice.h:\n   52      uint32_t vkMemoryTypeBits[(uint32_t)Device::MemoryType::Count];\n   53      VkPhysicalDeviceLimits deviceLimits;\n   54:     std::vector<VkExtensionProperties> deviceExtensions;\n   55  \n   56      struct {\n   57:         std::vector<VkFence> f;\n   58          uint32_t cur = 0;\n   59      } presentFences;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKDeviceManager.cpp:\n   60      assert(count > 0);\n   61  \n   62:     std::vector<VkPhysicalDevice> devices(count);\n   63      vkEnumeratePhysicalDevices(gVulkanInstance, &count, devices.data());\n   64  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKFbo.cpp:\n   58      // Bind the color buffers\n   59      uint32_t arraySize = -1;\n   60:     std::vector<VkImageView> attachments(Fbo::getMaxColorTargetCount(mpDevice) + 1);  // 1 is for the depth\n   61  \n   62      LOG_DBG(\"1\");\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKGpuFence.cpp:\n  116  \n  117              std::deque<VkType>& getActiveObjects() { return activeObjects; }\n  118:             std::vector<VkType>& getFreeObjects() { return freeObjects; }\n  119           private:\n  120              std::deque<VkType> activeObjects;\n  121:             std::vector<VkType> freeObjects;\n  122              std::shared_ptr<Device> mpDevice;\n  123          };\n  ...\n  125          std::unique_ptr<SmartQueue<VkFence, createFence, destroyFence, resetFence>> fenceQueue;\n  126          std::unique_ptr<SmartQueue<VkSemaphore, createSemaphore, destroySemaphore, nullptr>> semaphoreQueue;\n  127:         std::vector<VkSemaphore> semaphoreWaitList;\n  128          uint64_t gpuValue = 0;\n  129      };\n  ...\n  154          static const uint32_t waitThreshold = 20;\n  155          static const uint32_t waitCount = 10;\n  156:         static const std::vector<VkPipelineStageFlags> waitStages(waitCount, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT);\n  157  \n  158          if (mpApiData->semaphoreWaitList.size() > waitThreshold) {\n  ...\n  183          submit.waitSemaphoreCount = (uint32_t)mpApiData->semaphoreWaitList.size();\n  184          submit.pWaitSemaphores = mpApiData->semaphoreWaitList.data();\n  185:         const std::vector<VkPipelineStageFlags> waitStages(submit.waitSemaphoreCount, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT);\n  186          submit.pWaitDstStageMask = waitStages.data();\n  187  \n  ...\n  208  \n  209          auto& activeFences = mpApiData->fenceQueue->getActiveObjects();\n  210:         std::vector<VkFence> fenceVec(activeFences.begin(), activeFences.end());\n  211          vk_call(vkWaitForFences(mpDevice->getApiHandle(), (uint32_t)fenceVec.size(), fenceVec.data(), true, UINT64_MAX));\n  212          mpApiData->gpuValue += fenceVec.size();\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKGraphicsStateObject.cpp:\n   26   # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n   27   **************************************************************************/\n   28: #include <vector>\n   29  \n   30  #include \"Falcor/stdafx.h\"\n   ..\n   40      void GraphicsStateObject::apiInit() {\n   41          // Shader Stages\n   42:         std::vector<VkPipelineShaderStageCreateInfo> shaderStageInfos;\n   43          //initVkShaderStageInfo(mDesc.getProgramVersion().get(), shaderStageInfos);\n   44          initVkShaderStageInfo(mDesc.getProgramKernels(), shaderStageInfos);\n   ..\n   46          // Vertex Input State\n   47          VertexInputStateCreateInfo vertexInputInfo = {};\n   48:         initVkVertexLayoutInfo(mDesc.getVertexLayout().get(), vertexInputInfo, mDesc.getProgramVersion()->getReflector().get());\n   49  \n   50          // Input Assembly State\n   ..\n   65          // Multisample State\n   66          VkPipelineMultisampleStateCreateInfo multisampleInfo = {};\n   67:         bool enableSampleFrequency = mDesc.getProgramVersion() ? mDesc.getProgramVersion()->getReflector()->isSampleFrequency() : false;\n   68          initVkMultiSampleInfo(mDesc.getBlendState().get(), mDesc.getFboDesc(), mDesc.getSampleMask(), multisampleInfo, enableSampleFrequency);\n   69  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKRenderContext.cpp:\n   73      }\n   74  \n   75:     void setViewports(CommandListHandle cmdList, const std::vector<GraphicsState::Viewport>& viewports) {\n   76          // LOG_DBG(\"set viewports\");\n   77          static_assert(offsetof(GraphicsState::Viewport, originX) == offsetof(VkViewport, x), \"VP originX offset\");\n   ..\n   85      }\n   86  \n   87:     void setScissors(CommandListHandle cmdList, const std::vector<GraphicsState::Scissor>& scissors) {\n   88          // LOG_DBG(\"set scissors\");\n   89:         std::vector<VkRect2D> vkScissors(scissors.size());\n   90          for (size_t i = 0; i < scissors.size(); i++) {\n   91              vkScissors[i].offset.x = scissors[i].left;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKResourceViews.cpp:\n  284  \n  285  RenderTargetView::~RenderTargetView() {\n  286:     static std::vector<RenderTargetView::ApiHandle> hdl;\n  287      hdl.push_back(mApiHandle);\n  288  }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKRootSignature.cpp:\n   68  \n   69      VkDescriptorSetLayout createDescriptorSetLayout(std::shared_ptr<Device> pDevice, const DescriptorSet::Layout& layout) {\n   70:         std::vector<VkDescriptorSetLayoutBinding> bindings(layout.getRangeCount());\n   71  \n   72          uint32_t space;\n   ..\n  121  \n  122          static VkDescriptorSetLayout emptyLayout = createDescriptorSetLayout(mpDevice, {});   // #VKTODO This gets deleted multiple times on exit\n  123:         std::vector<VkDescriptorSetLayout> vkSetLayouts(maxIndex + 1, emptyLayout);\n  124  \n  125          for (const auto& set : mDesc.mSets) {\n  ...\n  129          /*/----------------------------------------------------\n  130          if (mDesc.getRootDescriptorCount() > 0) {\n  131:             std::vector<VkDescriptorSetLayoutBinding> root_bindings(mDesc.getRootDescriptorCount());\n  132              //for (const auto& desc : mDesc.mRootDescriptors) {\n  133              for (uint32_t i =0; i < mDesc.getRootDescriptorCount(); i++) {\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKSmartHandle.h:\n   30  \n   31  #include <memory>\n   32: #include <vector>\n   33  \n   34  #include \"Falcor/Core/Framework.h\"\n   ..\n   67      ~VkHandle() {\n   68  #ifdef _WIN32\n   69:         static_assert(false, \"VkHandle missing destructor specialization\");\n   70  #endif\n   71      }\n   ..\n   82          SharedPtr() = default;\n   83          explicit SharedPtr(VkRootSignature* pHandle) : std::shared_ptr<VkRootSignature>(pHandle) {}\n   84:         static SharedPtr create(std::shared_ptr<Device> device, VkPipelineLayout layout, const std::vector<VkDescriptorSetLayout>& sets) { return SharedPtr(new VkRootSignature(device ,layout, sets)); }\n   85          operator VkPipelineLayout() const { return get()->mApiHandle; }\n   86  \n   ..\n   93   private:\n   94      friend class SharedPtr;\n   95:     VkRootSignature(std::shared_ptr<Device> device, VkPipelineLayout layout, const std::vector<VkDescriptorSetLayout>& sets) : VkBaseApiHandle(device), mApiHandle(layout), mSets(sets) {}\n   96      VkPipelineLayout mApiHandle;\n   97:     std::vector<VkDescriptorSetLayout> mSets;\n   98  };\n   99  \n  ...\n  165      ~VkResource() {\n  166  #ifdef _WIN32\n  167:         static_assert(false, \"VkResource missing destructor specialization\");\n  168  #endif\n  169      }\n  ...\n  207  };\n  208  \n  209: // Destructors\n  210  template<> VkHandle<VkSwapchainKHR>::~VkHandle();\n  211  template<> VkHandle<VkCommandPool>::~VkHandle();\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKState.cpp:\n   59      }\n   60      /*\n   61:     void initVkShaderStageInfo(const ProgramVersion* pProgram, std::vector<VkPipelineShaderStageCreateInfo>& infosOut)\n   62      {\n   63          infosOut.clear();\n   ..\n   81      }\n   82      */\n   83:     void initVkShaderStageInfo(const ProgramKernels::SharedConstPtr& pProgramKernels, std::vector<VkPipelineShaderStageCreateInfo>& infosOut) {\n   84          infosOut.clear();\n   85  \n   ..\n  100      }\n  101  \n  102:     VkBlendFactor getVkBlendFactor(BlendState::BlendFunc func) {\n  103          switch (func) {\n  104              case BlendState::BlendFunc::Zero:\n  ...\n  122              case BlendState::BlendFunc::OneMinusDstAlpha:\n  123                  return VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA;\n  124:             case BlendState::BlendFunc::BlendFactor:\n  125                  return VK_BLEND_FACTOR_CONSTANT_COLOR;\n  126:             case BlendState::BlendFunc::OneMinusBlendFactor:\n  127                  return VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR;\n  128              case BlendState::BlendFunc::SrcAlphaSaturate:\n  ...\n  181              VkPipelineColorBlendAttachmentState& state = infoOut.attachmentStates[i];\n  182              state.blendEnable = vkBool(rtDesc.blendEnabled);\n  183:             state.srcColorBlendFactor = getVkBlendFactor(rtDesc.srcRgbFunc);\n  184:             state.dstColorBlendFactor = getVkBlendFactor(rtDesc.dstRgbFunc);\n  185              state.colorBlendOp = getVkBlendOp(rtDesc.rgbBlendOp);\n  186:             state.srcAlphaBlendFactor = getVkBlendFactor(rtDesc.srcAlphaFunc);\n  187:             state.dstAlphaBlendFactor = getVkBlendFactor(rtDesc.dstAlphaFunc);\n  188              state.alphaBlendOp = getVkBlendOp(rtDesc.alphaBlendOp);\n  189  \n  ...\n  198          infoOut.info.pAttachments = infoOut.attachmentStates.data();\n  199  \n  200:         const float4 blendColor = pState->getBlendFactor();\n  201          infoOut.info.blendConstants[0] = blendColor.r;\n  202          infoOut.info.blendConstants[1] = blendColor.g;\n  ...\n  241          infoOut.frontFace = pState->isFrontCounterCW() ? VK_FRONT_FACE_COUNTER_CLOCKWISE : VK_FRONT_FACE_CLOCKWISE;\n  242          infoOut.depthBiasEnable = vkBool(pState->getDepthBias() > 0);\n  243:         infoOut.depthBiasConstantFactor = (float)pState->getDepthBias();\n  244          infoOut.depthBiasClamp = 0.0f;\n  245:         infoOut.depthBiasSlopeFactor = pState->getSlopeScaledDepthBias();\n  246          infoOut.lineWidth = 1.0f;\n  247      }\n  ...\n  336      }\n  337  \n  338:     void initVkVertexLayoutInfo(const VertexLayout* pLayout, VertexInputStateCreateInfo& infoOut, ProgramReflection const* pReflector) {\n  339          // Build Vertex input and binding info\n  340          infoOut.bindingDescs.clear();\n  ...\n  360                      uint32_t shaderLocation = pVB->getElementShaderLocation(elemID);\n  361  \n  362:                     auto pAttribReflector = pReflector->getVertexAttributeBySemantic(pVB->getElementName(elemID));\n  363:                     if (pAttribReflector) {\n  364:                         shaderLocation = (uint32_t)pAttribReflector->bindLocation;\n  365                      }\n  366  \n  ...\n  499          // Init Color and Depth Attachment Info\n  500          infoOut.attachmentDescs.resize(Fbo::getMaxColorTargetCount(fboDesc.device()) + 1); // Color + Depth\n  501:         std::vector<uint32_t> regToAttachmentIndex(infoOut.attachmentDescs.size(), VK_ATTACHMENT_UNUSED);\n  502          uint32_t rtCount = 0;\n  503  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKState.h:\n   34  \n   35      struct ColorBlendStateCreateInfo {\n   36:         std::vector<VkPipelineColorBlendAttachmentState> attachmentStates;\n   37          uint32_t attachmentCount = 0;\n   38          VkPipelineColorBlendStateCreateInfo info;\n   ..\n   40  \n   41      struct VertexInputStateCreateInfo {\n   42:         std::vector<VkVertexInputBindingDescription> bindingDescs;\n   43:         std::vector<VkVertexInputAttributeDescription> attribDescs;\n   44          VkPipelineVertexInputStateCreateInfo info;\n   45      };\n   46  \n   47      struct RenderPassCreateInfo {\n   48:         std::vector<VkAttachmentDescription> attachmentDescs;\n   49:         std::vector<VkAttachmentReference> attachmentRefs;\n   50:         std::vector<VkSubpassDescription> subpassDescs;\n   51:         std::vector<VkSubpassDependency> subpassDependencies;\n   52          VkRenderPassCreateInfo info;\n   53      };\n   54  \n   55:     //void initVkShaderStageInfo(const ProgramVersion* pProgram, std::vector<VkPipelineShaderStageCreateInfo>& infosOut);\n   56:     void initVkShaderStageInfo(const ProgramKernels::SharedConstPtr& pProgramKernels, std::vector<VkPipelineShaderStageCreateInfo>& infosOut);\n   57      void initVkBlendInfo(const Fbo::Desc& fboDesc, const BlendState* pState, ColorBlendStateCreateInfo& infoOut);\n   58      void initVkRasterizerInfo(const RasterizerState* pState, VkPipelineRasterizationStateCreateInfo& infoOut);\n   59      void initVkDepthStencilInfo(const DepthStencilState* pState, VkPipelineDepthStencilStateCreateInfo& infoOut);\n   60:     void initVkVertexLayoutInfo(const VertexLayout* pLayout, VertexInputStateCreateInfo& infoOut, ProgramReflection const* pReflector);\n   61      void initVkSamplerInfo(const Sampler* pSampler, VkSamplerCreateInfo& infoOut);\n   62      void initVkMultiSampleInfo(const BlendState* pState, const Fbo::Desc& fboDesc, const uint32_t& sampleMask, VkPipelineMultisampleStateCreateInfo& infoOut, bool enableSampleFrequency);\n\n/home/max/dev/Falcor/src/Falcor/Core/BufferTypes/ParameterBlock.cpp:\n  245  ParameterBlock::SharedPtr ParameterBlock::create(std::shared_ptr<Device> pDevice, const std::shared_ptr<const ProgramVersion>& pProgramVersion, const std::string& typeName) {\n  246      assert(pProgramVersion);\n  247:     return ParameterBlock::create(pDevice, pProgramVersion, pProgramVersion->getReflector()->findType(typeName));\n  248  }\n  249  \n  250  ParameterBlock::ParameterBlock(std::shared_ptr<Device> pDevice, const std::shared_ptr<const ProgramVersion>& pProgramVersion, const ParameterBlockReflection::SharedConstPtr& pReflection)\n  251      : mpDevice(pDevice)\n  252:     , mpReflector(pReflection)\n  253      , mpProgramVersion(pProgramVersion)\n  254      , mData(pReflection->getElementType()->getByteSize(), 0)  {\n  ...\n  318                              assert(mpDevice);\n  319  \n  320:                             auto pCB = ParameterBlock::create(mpDevice, pResourceType->getParameterBlockReflector());\n  321                              var.setParameterBlock(pCB);\n  322                          }\n  ...\n  385  #if _LOG_ENABLED\n  386      auto rangeIndex = bindLocation.getResourceRangeIndex();\n  387:     auto& resourceRange = mpReflector->getResourceRange(rangeIndex);\n  388  \n  389      if (!isSetType(resourceRange.descriptorType, allowedTypes)) {\n  ...\n  402      if (!checkResourceIndices(bindLocation, funcName)) return false;\n  403  \n  404:     auto& bindingInfo = mpReflector->getResourceRangeBindingInfo(bindLocation.getResourceRangeIndex());\n  405      bool isUav = std::holds_alternative<UnorderedAccessView::SharedPtr>(pView);\n  406  \n  ...\n  485  \n  486  uint32_t ParameterBlock::getDescriptorSetIndex(const BindLocation& bindLocation) {\n  487:     return mpReflector->getResourceRangeBindingInfo(bindLocation.getResourceRangeIndex()).descriptorSetIndex;\n  488  }\n  489  \n  ...\n  511      // gets bound through (if one exists) should also be invalidated.\n  512      //\n  513:     markDescriptorSetDirty(mpReflector->getDefaultConstantBufferBindingInfo().descriptorSetIndex);\n  514  }\n  515  \n  ...\n  603  \n  604  std::pair<Resource::SharedPtr, bool> ParameterBlock::getRootDescriptor(uint32_t resourceRangeIndex, uint32_t arrayIndex) const {\n  605:     assert(mpReflector->getResourceRangeBindingInfo(resourceRangeIndex).isRootDescriptor());\n  606:     auto& resourceRange = mpReflector->getResourceRange(resourceRangeIndex);\n  607  \n  608      bool isUav = isSetType(resourceRange.descriptorType, kRootUavDescriptorTypes);\n  ...\n  758      updateSpecialization();\n  759  \n  760:     auto pSlangTypeLayout = mpSpecializedReflector->getElementType()->getSlangTypeLayout();\n  761  \n  762      auto requiredSize = pSlangTypeLayout->getSize();\n  ...\n  847  }\n  848  \n  849: void ParameterBlock::checkForIndirectChanges(ParameterBlockReflection const* pReflector) const {\n  850      // First off, we will recursively check any parameter blocks attached to use\n  851      // for `ConstantBuffer<T>`/`cbuffer` or interface-type parameters, since\n  ...\n  853      // sets attached to `this`.\n  854      //\n  855:     auto resourceRangeCount = pReflector->getResourceRangeCount();\n  856      for (uint32_t r = 0; r < resourceRangeCount; ++r) {\n  857:         auto rangeBindingInfo = pReflector->getResourceRangeBindingInfo(r);\n  858          switch (rangeBindingInfo.flavor) {\n  859              default:\n  ...\n  865          }\n  866  \n  867:         auto pSubObjectReflector = rangeBindingInfo.pSubObjectReflector.get();\n  868:         assert(pSubObjectReflector);\n  869  \n  870:         auto rangeInfo = pReflector->getResourceRange(r);\n  871          for (uint32_t i = 0; i < rangeInfo.count; ++i) {\n  872              auto& assigned = getAssignedParameterBlock(r, i);\n  873              auto& pSubObject = assigned.pBlock;\n  874  \n  875:             pSubObject->checkForIndirectChanges(pSubObjectReflector);\n  876          }\n  877      }\n  ...\n  880      // would be invalidated due to a change in a sub-block.\n  881      //\n  882:     auto setCount = pReflector->getDescriptorSetCount();\n  883      for (uint32_t s = 0; s < setCount; ++s) {\n  884:         auto& setInfo = pReflector->getDescriptorSetInfo(s);\n  885          for ( auto subObjectRange : setInfo.subObjects ) {\n  886              auto resourceRangeIndex = subObjectRange.resourceRangeIndexOfSubObject;\n  887              auto setIndexInSubObject = subObjectRange.setIndexInSubObject;\n  888  \n  889:             auto subObjectCount = pReflector->getResourceRange(resourceRangeIndex).count;\n  890:             auto pSubObjectReflector = pReflector->getResourceRangeBindingInfo(resourceRangeIndex).pSubObjectReflector.get();\n  891              for (uint32_t i = 0; i < subObjectCount; ++i) {\n  892                  auto& assigned = getAssignedParameterBlock(resourceRangeIndex, i);\n  ...\n  908      //\n  909      for (uint32_t r = 0; r < resourceRangeCount; ++r) {\n  910:         auto rangeBindingInfo = pReflector->getResourceRangeBindingInfo(r);\n  911          if (rangeBindingInfo.flavor != ParameterBlockReflection::ResourceRangeBindingInfo::Flavor::Interface)\n  912              continue;\n  913  \n  914:         auto pSubObjectReflector = rangeBindingInfo.pSubObjectReflector.get();\n  915:         assert(pSubObjectReflector);\n  916  \n  917:         auto rangeInfo = pReflector->getResourceRange(r);\n  918          for (uint32_t i = 0; i < rangeInfo.count; ++i) {\n  919              auto& assigned = getAssignedParameterBlock(r, i);\n  ...\n  933      //\n  934      for (uint32_t r = 0; r < resourceRangeCount; ++r) {\n  935:         auto rangeBindingInfo = pReflector->getResourceRangeBindingInfo(r);\n  936          switch (rangeBindingInfo.flavor) {\n  937              default:\n  ...\n  943          }\n  944  \n  945:         auto pSubObjectReflector = rangeBindingInfo.pSubObjectReflector.get();\n  946:         assert(pSubObjectReflector);\n  947  \n  948:         auto rangeInfo = pReflector->getResourceRange(r);\n  949          for (uint32_t i = 0; i < rangeInfo.count; ++i) {\n  950              auto& assigned = getAssignedParameterBlock(r, i);\n  ...\n  957  \n  958  ParameterBlock::ChangeEpoch ParameterBlock::computeEpochOfLastChange(ParameterBlock* pBlock) {\n  959:     pBlock->checkForIndirectChanges(pBlock->mpReflector.get());\n  960      return getEpochOfLastChange(pBlock);\n  961  }\n  962  \n  963: void ParameterBlock::validateUnderlyingConstantBuffer(ParameterBlockReflection const* pReflector) {\n  964      // There is no need to allocate and fill in the underlying constant\n  965      // buffer if we will actually be using root constants.\n  966      //\n  967:     if (pReflector->getDefaultConstantBufferBindingInfo().useRootConstants)\n  968          return;\n  969  \n  ...\n  987      auto pBuffer = getUnderlyingConstantBuffer().get();\n  988      char* pData = reinterpret_cast<char*>(pBuffer->map(Buffer::MapType::WriteDiscard));\n  989:     writeIntoBuffer(pReflector, pData, pBuffer->getSize());\n  990      pBuffer->unmap();\n  991  \n  ...\n 1004  }\n 1005  \n 1006: void ParameterBlock::writeIntoBuffer(ParameterBlockReflection const* pReflector, char* pBuffer, size_t bufferSize) {\n 1007      auto dataSize = mData.size();\n 1008      assert(dataSize <= bufferSize);\n 1009      memcpy(pBuffer, mData.data(), dataSize);\n 1010  \n 1011:     auto resourceRangeCount = pReflector->getResourceRangeCount();\n 1012      for (uint32_t rr = 0; rr < resourceRangeCount; ++rr) {\n 1013:         auto rangeBindingInfo = pReflector->getResourceRangeBindingInfo(rr);\n 1014          if (rangeBindingInfo.flavor != ParameterBlockReflection::ResourceRangeBindingInfo::Flavor::Interface)\n 1015              continue;\n 1016  \n 1017:         auto pSubObjectReflector = rangeBindingInfo.pSubObjectReflector.get();\n 1018:         assert(pSubObjectReflector);\n 1019  \n 1020:         auto rangeInfo = pReflector->getResourceRange(rr);\n 1021          for (uint32_t ii = 0; ii < rangeInfo.count; ++ii) {\n 1022              assert(ii == 0);\n ....\n 1026              assert(subObjectOffset <= bufferSize);\n 1027              pSubObject->writeIntoBuffer(\n 1028:                 pSubObjectReflector,\n 1029                  pBuffer + subObjectOffset,\n 1030                  bufferSize - subObjectOffset);\n ....\n 1176  \n 1177  ParameterBlock::SharedPtr const& ParameterBlock::getParameterBlock(uint32_t resourceRangeIndex, uint32_t arrayIndex) const {\n 1178:     auto rangeInfo = mpReflector->getElementType()->getResourceRange(resourceRangeIndex);\n 1179      return mParameterBlocks[rangeInfo.baseIndex + arrayIndex].pBlock;\n 1180  }\n 1181  \n 1182  ParameterBlock::AssignedParameterBlock const& ParameterBlock::getAssignedParameterBlock(uint32_t resourceRangeIndex, uint32_t arrayIndex) const {\n 1183:     auto rangeInfo = mpReflector->getElementType()->getResourceRange(resourceRangeIndex);\n 1184      return mParameterBlocks[rangeInfo.baseIndex + arrayIndex];\n 1185  }\n 1186  \n 1187: bool ParameterBlock::bindIntoDescriptorSet(const ParameterBlockReflection* pReflector, DescriptorSet::SharedPtr pDescSet, uint32_t setIndex, uint32_t& ioDestRangeIndex) {\n 1188:     if ( pReflector->hasDefaultConstantBuffer() ) {\n 1189:         auto defaultConstantBufferInfo = pReflector->getDefaultConstantBufferBindingInfo();\n 1190          if (setIndex == defaultConstantBufferInfo.descriptorSetIndex) {\n 1191              uint32_t destRangeIndex = ioDestRangeIndex++;\n ....\n 1196      }\n 1197  \n 1198:     return bindResourcesIntoDescriptorSet(pReflector, pDescSet, setIndex, ioDestRangeIndex);\n 1199  }\n 1200  \n 1201:     bool ParameterBlock::bindResourcesIntoDescriptorSet(const ParameterBlockReflection* pReflector, DescriptorSet::SharedPtr pDescSet, uint32_t setIndex, uint32_t& ioDestRangeIndex) {\n 1202:         auto& setInfo = pReflector->getDescriptorSetInfo(setIndex);\n 1203  \n 1204          for(auto resourceRangeIndex : setInfo.resourceRangeIndices) {\n ....\n 1305              auto setIndexInSubObject = subObjectRange.setIndexInSubObject;\n 1306  \n 1307:             auto subObjectCount = pReflector->getResourceRange(resourceRangeIndex).count;\n 1308:             auto pSubObjectReflector = pReflector->getResourceRangeBindingInfo(resourceRangeIndex).pSubObjectReflector.get();\n 1309              for(uint32_t i = 0; i < subObjectCount; ++i) {\n 1310                  // TODO: if `subObjectCount` is > 1, then we really need\n ....\n 1313  \n 1314                  auto pSubObject = getParameterBlock(resourceRangeIndex, i);\n 1315:                 if( pReflector->getResourceRangeBindingInfo(resourceRangeIndex).flavor == ParameterBlockReflection::ResourceRangeBindingInfo::Flavor::Interface ) {\n 1316                      pSubObject->bindResourcesIntoDescriptorSet(\n 1317:                         pSubObjectReflector,\n 1318                          pDescSet,\n 1319                          setIndexInSubObject,\n ....\n 1321                  } else {\n 1322                      pSubObject->bindIntoDescriptorSet(\n 1323:                         pSubObjectReflector,\n 1324                          pDescSet,\n 1325                          setIndexInSubObject,\n ....\n 1338          //\n 1339          if( pSlangTypeLayout && pSlangTypeLayout->getSize(slang::ParameterCategory::ExistentialTypeParam) == 0 ) {\n 1340:             mpSpecializedReflector = mpReflector;\n 1341              return false;\n 1342          }\n ....\n 1350  \n 1351      void ParameterBlock::collectSpecializationArgs(ParameterBlock::SpecializationArgs& ioArgs) const {\n 1352:         auto pReflector = getReflection();\n 1353:         uint32_t resourceRangeCount = pReflector->getResourceRangeCount();\n 1354          for( uint32_t r = 0; r < resourceRangeCount; ++r ) {\n 1355:             auto rangeInfo = pReflector->getResourceRange(r);\n 1356:             auto rangeBindingInfo = pReflector->getResourceRangeBindingInfo(r);\n 1357              switch( rangeBindingInfo.flavor ) {\n 1358                  case ParameterBlockReflection::ResourceRangeBindingInfo::Flavor::Interface: {\n ....\n 1437          auto pSpecializedSlangTypeLayout = pSlangSession->getTypeLayout(pSpecializedSlangType);\n 1438  \n 1439:         mpSpecializedReflector = ParameterBlockReflection::create(mpProgramVersion.get(), pSpecializedSlangTypeLayout);\n 1440  \n 1441          return true;\n 1442      }\n 1443  \n 1444:     bool ParameterBlock::prepareDefaultConstantBufferAndResources(CopyContext* pContext, ParameterBlockReflection const* pReflector) {\n 1445:         if ( pReflector->hasDefaultConstantBuffer() ) {\n 1446:             validateUnderlyingConstantBuffer(pReflector);\n 1447          }\n 1448:         return prepareResources(pContext, pReflector);\n 1449      }\n 1450  \n 1451:     bool ParameterBlock::prepareResources(CopyContext* pContext, ParameterBlockReflection const* pReflector) {\n 1452          // Prepare all bound resources by inserting appropriate barriers/transitions as needed.\n 1453          for (auto& srv : mSRVs) {\n ....\n 1460  \n 1461          // Recursively prepare the resources in all sub-blocks bound to this parameter block.\n 1462:         auto resourceRangeCount = pReflector->getResourceRangeCount();\n 1463          for (uint32_t resourceRangeIndex = 0; resourceRangeIndex < resourceRangeCount; ++resourceRangeIndex) {\n 1464:             auto& bindingInfo = pReflector->getResourceRangeBindingInfo(resourceRangeIndex);\n 1465              if (bindingInfo.flavor == ParameterBlockReflection::ResourceRangeBindingInfo::Flavor::Simple ||\n 1466                  bindingInfo.flavor == ParameterBlockReflection::ResourceRangeBindingInfo::Flavor::RootDescriptor) {\n ....\n 1468              }\n 1469  \n 1470:             auto& resourceRange = pReflector->getResourceRange(resourceRangeIndex);\n 1471:             auto pSubObjectReflector = bindingInfo.pSubObjectReflector.get();\n 1472              auto objectCount = resourceRange.count;\n 1473  \n ....\n 1478                  switch (bindingInfo.flavor) {\n 1479                      case ParameterBlockReflection::ResourceRangeBindingInfo::Flavor::ConstantBuffer:\n 1480:                         if (!pSubBlock->prepareDefaultConstantBufferAndResources(pContext, pSubObjectReflector)) {\n 1481                              return false;\n 1482                          }\n ....\n 1484  \n 1485                      case ParameterBlockReflection::ResourceRangeBindingInfo::Flavor::ParameterBlock:\n 1486:                         if (!pSubBlock->prepareDescriptorSets(pContext, pSubObjectReflector)) {\n 1487                              return false;\n 1488                          }\n ....\n 1490  \n 1491                      case ParameterBlockReflection::ResourceRangeBindingInfo::Flavor::Interface:\n 1492:                         if (!pSubBlock->prepareResources(pContext, pSubObjectReflector)) {\n 1493                              return false;\n 1494                          }\n ....\n 1506      bool ParameterBlock::prepareDescriptorSets(CopyContext* pContext) {\n 1507          // Note: allocating and filling in descriptor sets will always\n 1508:         // use the specialized reflector, which is based on how the\n 1509          // object has been laid out based on the known types of\n 1510          // interface-type parameters.\n 1511          //\n 1512          updateSpecialization();\n 1513:         auto pReflector = mpSpecializedReflector.get();\n 1514  \n 1515:         return prepareDescriptorSets(pContext, pReflector);\n 1516      }\n 1517  \n 1518:     bool ParameterBlock::prepareDescriptorSets(CopyContext* pContext, const ParameterBlockReflection* pReflector) {\n 1519          //LOG_DBG(\"prepareDescriptorSets\");\n 1520          \n ....\n 1523          // and re-creation of descriptor sets for this parameter block.\n 1524          //\n 1525:         checkForIndirectChanges(pReflector);\n 1526  \n 1527          // Next we need to recursively \"prepare\" the resources for this\n ....\n 1541          \n 1542          //LOG_DBG(\"test prepareDefaultConstantBufferAndResources\");\n 1543:         if (!prepareDefaultConstantBufferAndResources(pContext, pReflector)) {\n 1544              return false;\n 1545          }\n ....\n 1549          // have been invalidated in one way or another.\n 1550          //\n 1551:         uint32_t setCount = pReflector->getDescriptorSetCount();\n 1552          //LOG_DBG(\"iterate %u descriptor sets\", setCount);\n 1553          for (uint32_t setIndex = 0; setIndex < setCount; ++setIndex) {\n ....\n 1556  \n 1557              //LOG_DBG(\"get descriptor set layout\");\n 1558:             auto pSetLayout = pReflector->getDescriptorSetLayout(setIndex);\n 1559  \n 1560              //LOG_DBG(\"create descriptor set\");\n ....\n 1564              //LOG_DBG(\"bind into descriptor set\");\n 1565              bindIntoDescriptorSet(\n 1566:                 pReflector,\n 1567                  pSet,\n 1568                  setIndex,\n\n/home/max/dev/Falcor/src/Falcor/Core/BufferTypes/ParameterBlock.h:\n  108      static SharedPtr create(std::shared_ptr<Device> pDevice, const std::shared_ptr<const ProgramVersion>& pProgramVersion, const ReflectionType::SharedConstPtr& pType);\n  109  \n  110:     /** Create a new object that holds a value described by the given reflector.\n  111      */\n  112      static SharedPtr create(std::shared_ptr<Device> pDevice, const ParameterBlockReflection::SharedConstPtr& pReflection);\n  ...\n  269      /** Get the parameter block's reflection interface\n  270      */\n  271:     ParameterBlockReflection::SharedConstPtr getReflection() const { return mpReflector; }\n  272  \n  273      /** Get the block reflection type\n  274      */\n  275:     ReflectionType::SharedConstPtr getElementType() const { return mpReflector->getElementType(); }\n  276  \n  277      /** Get the size of the reflection type\n  ...\n  304  \n  305      bool updateSpecialization() const;\n  306:     ParameterBlockReflection::SharedConstPtr getSpecializedReflector() const { return mpSpecializedReflector; }\n  307  \n  308      bool prepareDescriptorSets(CopyContext* pCopyContext);\n  309  \n  310:     uint32_t getDescriptorSetCount() const { return mpReflector->getDescriptorSetCount(); }\n  311      DescriptorSet::SharedPtr const& getDescriptorSet(uint32_t index) const { return mSets[index].pSet; }\n  312  \n  ...\n  320      bool setSampler(uint32_t, const Sampler::SharedPtr&) = delete;\n  321  \n  322:     using SpecializationArgs = std::vector<slang::SpecializationArg>;\n  323      void collectSpecializationArgs(SpecializationArgs& ioArgs) const;\n  324  \n  ...\n  346  \n  347      std::shared_ptr<const ProgramVersion> mpProgramVersion;\n  348:     ParameterBlockReflection::SharedConstPtr mpReflector;\n  349:     mutable ParameterBlockReflection::SharedConstPtr mpSpecializedReflector;\n  350:     std::vector<uint8_t> mData;\n  351  \n  352      virtual bool updateSpecializationImpl() const;\n  ...\n  358  \n  359      void validateUnderlyingConstantBuffer(\n  360:         ParameterBlockReflection const*   pReflector);\n  361  \n  362      void writeIntoBuffer(\n  363:         ParameterBlockReflection const*   pReflector,\n  364          char*                           pBuffer,\n  365          size_t                          bufferSize);\n  ...\n  367      bool prepareDescriptorSets(\n  368          CopyContext*                    pCopyContext,\n  369:         const ParameterBlockReflection* pReflector);\n  370  \n  371      bool prepareDefaultConstantBufferAndResources(\n  372          CopyContext*                        pContext,\n  373:         ParameterBlockReflection const*     pReflector);\n  374      \n  375      bool prepareResources(\n  376          CopyContext*                    pContext,\n  377:         ParameterBlockReflection const* pReflector);\n  378  \n  379      bool bindIntoDescriptorSet(\n  380:         const ParameterBlockReflection*   pReflector,\n  381          DescriptorSet::SharedPtr        pDescSet,\n  382          uint32_t                        setIndex,\n  ...\n  384  \n  385      bool bindResourcesIntoDescriptorSet(\n  386:         const ParameterBlockReflection*   pReflector,\n  387          DescriptorSet::SharedPtr        pDescSet,\n  388          uint32_t                        setIndex,\n  ...\n  404      };\n  405  \n  406:     std::vector<AssignedParameterBlock>     mParameterBlocks;\n  407:     std::vector<AssignedSRV>                mSRVs;              ///< All SRVs bound to descriptor sets or root descriptors.\n  408:     std::vector<AssignedUAV>                mUAVs;              ///< All UAVs bound to descriptor sets or root descriptors.\n  409:     std::vector<Sampler::SharedPtr>         mSamplers;\n  410  \n  411      AssignedParameterBlock const& getAssignedParameterBlock(uint32_t resourceRangeIndex, uint32_t arrayIndex) const;\n  ...\n  431      static ChangeEpoch computeEpochOfLastChange(ParameterBlock* pBlock);\n  432  \n  433:     void checkForIndirectChanges(ParameterBlockReflection const* pReflector) const;\n  434  \n  435      mutable uint32_t mDescriptorSetResourceDataVersion = 0;\n  ...\n  453      };\n  454      \n  455:     mutable std::vector<DescriptorSetInfo> mSets;\n  456  };\n  457  \n\n/home/max/dev/Falcor/src/Falcor/Core/FalcorConfig.h:\n   35  #define _PROFILING_LOG_BATCH_SIZE 1024 * 1  // This can be used to control how many samples are accumulated before they are dumped to file.\n   36  \n   37: #define _ENABLE_NVAPI false // Controls NVIDIA specific DX extensions. If it is set to true, make sure you have the NVAPI package in your 'Externals' directory. View the readme for more information.\n   38  \n   39  #ifdef _WIN32\n\n/home/max/dev/Falcor/src/Falcor/Core/Framework.h:\n   57  #include <string>\n   58  #include <string_view>\n   59: #include <vector>\n   60  #include <algorithm>\n   61  #include <utility>\n   ..\n   65  #include \"Falcor/Core/FalcorConfig.h\"\n   66  #include \"Falcor/Utils/Logger.h\"\n   67: #include \"Falcor/Utils/Math/Vector.h\"\n   68  \n   69  #ifndef arraysize\n\n/home/max/dev/Falcor/src/Falcor/Core/Platform/Linux/Linux.cpp:\n   58  };\n   59  \n   60: uint32_t msgBox(const std::string& msg, std::vector<MsgBoxCustomButton> buttons, MsgBoxIcon icon, uint32_t defaultButtonId) {\n   61      return -1;\n   62  }\n   ..\n  139  \n  140  size_t executeProcess(const std::string& appName, const std::string& commandLineArgs) {\n  141:     std::string linuxAppName = getExecutableDirectory(); linuxAppName += \"/\" + appName;\n  142:     std::vector<const char*> argv;\n  143:     std::vector<std::string> argvStrings;\n  144  \n  145      auto argStrings = splitString(commandLineArgs, \" \");\n  ...\n  181  }\n  182  \n  183: bool isDirectoryExists(const std::string& filename) {\n  184      const char* pathname = filename.c_str();\n  185      struct stat sb;\n  ...\n  198  \n  199  std::string getTempFilename() {\n  200:     std::string filePath = fs::temp_directory_path().string();\n  201      filePath += \"/fileXXXXXX\";\n  202  \n  ...\n  206  }\n  207  \n  208: const std::string& getExecutableDirectory() {\n  209      char result[PATH_MAX] = { 0 };\n  210      ssize_t count = readlink(\"/proc/self/exe\", result, PATH_MAX);\n  ...\n  218  }\n  219  \n  220: const std::string getWorkingDirectory() {\n  221      char cwd[1024];\n  222      if (getcwd(cwd, sizeof(cwd)) != nullptr) {\n  ...\n  227  }\n  228  \n  229: const std::string getAppDataDirectory() {\n  230      //assert(0);\n  231      //return std::string();\n  ...\n  328  }\n  329  \n  330: float getDisplayScaleFactor() {\n  331      return 1;\n  332  }\n  ...\n  359  }\n  360  \n  361: void enumerateFiles(std::string searchString, std::vector<std::string>& filenames) {\n  362      DIR* pDir = opendir(searchString.c_str());\n  363      if (pDir != nullptr) {\n  364          struct dirent* pDirEntry = readdir(pDir);\n  365          while (pDirEntry != nullptr) {\n  366:             // Only add files, no subdirectories, symlinks, or other objects\n  367              if (pDirEntry->d_type == DT_REG) {\n  368                  filenames.push_back(pDirEntry->d_name);\n\n/home/max/dev/Falcor/src/Falcor/Core/Platform/MonitorInfo.cpp:\n  165      }\n  166  \n  167:     std::vector<MonitorInfo::MonitorDesc> internalDescs;\n  168  \n  169      BOOL CALLBACK MonitorEnumProc(HMONITOR hMonitor,\n  ...\n  207      }\n  208  \n  209:     void MonitorInfo::getMonitorDescs(std::vector<MonitorInfo::MonitorDesc>& monitorDescs)\n  210      {\n  211          internalDescs.clear();\n  ...\n  217      void MonitorInfo::displayMonitorInfo()\n  218      {\n  219:         std::vector<MonitorInfo::MonitorDesc> monitorDescs;\n  220          getMonitorDescs(monitorDescs);\n  221  \n\n/home/max/dev/Falcor/src/Falcor/Core/Platform/MonitorInfo.h:\n   50          /** Function to enumerate all monitors.\n   51              This function is _not_ thread-safe\n   52:             \\param monitorDescs An empty vector to receive the output list of monitor configurations.\n   53          */\n   54:         static void getMonitorDescs(std::vector<MonitorDesc>& monitorDescs);\n   55  \n   56          /** Display information on currently connected monitors\n\n/home/max/dev/Falcor/src/Falcor/Core/Platform/OS.cpp:\n   57  }\n   58  \n   59: inline std::vector<std::string> getInitialShaderDirectories() {\n   60:     std::vector<std::string> developmentDirectories = {\n   61          // First we search in source folders.\n   62          std::string(PROJECT_DIR),\n   ..\n   64          std::string(PROJECT_DIR) + \"../Tools/FalcorTest/\",\n   65          // Then we search in deployment folder (necessary to pickup NVAPI and other third-party shaders).\n   66:         getExecutableDirectory() + \"/Shaders\",\n   67      };\n   68  \n   69:     std::vector<std::string> deploymentDirectories = {\n   70:         getExecutableDirectory() + \"/Shaders\"\n   71      };\n   72  \n   73      std::cout << \"dev mode: \" << (isDevelopmentMode() ? \"true\" : \"false\") << \"\\n\";\n   74:     std::cout << \"exec dir: \" << getExecutableDirectory() << \"\\n\";\n   75  \n   76:     return isDevelopmentMode() ? developmentDirectories : deploymentDirectories;\n   77  }\n   78  \n   79: static std::vector<std::string> gShaderDirectories = getInitialShaderDirectories();\n   80  \n   81: inline std::vector<std::string> getInitialDataDirectories() {\n   82:     std::vector<std::string> developmentDirectories = {\n   83          std::string(PROJECT_DIR) + \"/Data\",\n   84:         getExecutableDirectory() + \"/Data\",\n   85      };\n   86  \n   87:     std::vector<std::string> deploymentDirectories = {\n   88:         getExecutableDirectory() + \"/Data\"\n   89      };\n   90  \n   91:     std::vector<std::string> directories = isDevelopmentMode() ? developmentDirectories : deploymentDirectories;\n   92  \n   93      // Add development media folder.\n   94  #ifdef _MSC_VER\n   95:     directories.push_back(getExecutableDirectory() + \"/../../../Media\"); // Relative to Visual Studio output folder\n   96  #else\n   97:     directories.push_back(getExecutableDirectory() + \"/../Media\"); // Relative to Makefile output folder\n   98  #endif\n   99  \n  ...\n  102      if (getEnvironmentVariable(\"FALCOR_MEDIA_FOLDERS\", mediaFolders)) {\n  103          auto folders = splitString(mediaFolders, \";\");\n  104:         directories.insert(directories.end(), folders.begin(), folders.end());\n  105      }\n  106  \n  107:     return directories;\n  108  }\n  109  \n  110: static std::vector<std::string> gDataDirectories = getInitialDataDirectories();\n  111  \n  112: const std::vector<std::string>& getDataDirectoriesList() {\n  113:     return gDataDirectories;\n  114  }\n  115  \n  116: void addDataDirectory(const std::string& dir) {\n  117:     if (std::find(gDataDirectories.begin(), gDataDirectories.end(), dir) == gDataDirectories.end()) {\n  118:         gDataDirectories.push_back(dir);\n  119      }\n  120  }\n  121  \n  122: void removeDataDirectory(const std::string& dir) {\n  123:     auto it = std::find(gDataDirectories.begin(), gDataDirectories.end(), dir);\n  124:     if (it != gDataDirectories.end()) {\n  125:         gDataDirectories.erase(it);\n  126      }\n  127  }\n  ...\n  149  }\n  150  \n  151: bool findFileInDataDirectories(const std::string& filename, std::string& fullPath) {\n  152      // Check if this is an absolute path\n  153      if (fs::path(filename).is_absolute()) {\n  ...\n  156      }\n  157  \n  158:     for (const auto& dir : gDataDirectories) {\n  159          fullPath = canonicalizeFilename(dir + '/' + filename);\n  160          if (doesFileExist(fullPath)) {\n  ...\n  166  }\n  167  \n  168: const std::vector<std::string>& getShaderDirectoriesList() {\n  169:     return gShaderDirectories;\n  170  }\n  171  \n  172: bool findFileInShaderDirectories(const std::string& filename, std::string& fullPath) {\n  173:     for (const auto& dir : gShaderDirectories) {\n  174          fullPath = canonicalizeFilename(dir + '/' + filename);\n  175          if (doesFileExist(fullPath)) {\n  ...\n  180  }\n  181  \n  182: bool findAvailableFilename(const std::string& prefix, const std::string& directory, const std::string& extension, std::string& filename) {\n  183      for (uint32_t i = 0; i < (uint32_t)-1; i++) {\n  184          std::string newPrefix = prefix + '.' + std::to_string(i);\n  185:         filename = directory + '/' + newPrefix + \".\" + extension;\n  186  \n  187          if (doesFileExist(filename) == false) {\n  ...\n  194  }\n  195  \n  196: std::string stripDataDirectories(const std::string& filename) {\n  197      std::string stripped = filename;\n  198      std::string canonFile = canonicalizeFilename(filename);\n  199  \n  200:     for (const auto& dir : gDataDirectories) {\n  201          std::string canonDir = canonicalizeFilename(dir);\n  202  \n  203          if (canonDir.size() && hasPrefix(canonFile, canonDir, false)) {\n  204              // canonicalizeFilename adds trailing \\\\ to drive letters and removes them from paths containing folders\n  205:             // The entire prefix directory including the slash should be removed\n  206              bool trailingSlash = canonDir.back() == '\\\\' || canonDir.back() == '/';\n  207              size_t len = trailingSlash ? canonDir.length() : canonDir.length() + 1;\n  ...\n  226  }\n  227  \n  228: std::string getDirectoryFromFile(const std::string& filename) {\n  229      fs::path path = filename;\n  230      return path.has_filename() ? path.parent_path().string() : filename;\n\n/home/max/dev/Falcor/src/Falcor/Core/Platform/OS.h:\n   71  dlldecl int getDisplayDpi();\n   72  \n   73: /** Get the requested display scale factor\n   74  */\n   75: dlldecl float getDisplayScaleFactor();\n   76  \n   77  /** Message box icons.\n   ..\n  132      \\return The id of the button that was clicked.\n  133  */\n  134: dlldecl uint32_t msgBox(const std::string& msg, std::vector<MsgBoxCustomButton> buttons, MsgBoxIcon icon = MsgBoxIcon::None, uint32_t defaultButtonId = uint32_t(-1));\n  135  \n  136  /** Set the title for message boxes. The default value is \"Falcor\"\n  ...\n  138  dlldecl void msgBoxTitle(const std::string& title);\n  139  \n  140: /** Finds a file in one of the media directories. The arguments must not alias.\n  141      \\param[in] filename The file to look for\n  142      \\param[in] fullPath If the file was found, the full path to the file. If the file wasn't found, this is invalid.\n  143      \\return true if the file was found, otherwise false\n  144  */\n  145: dlldecl bool findFileInDataDirectories(const std::string& filename, std::string& fullPath);\n  146  \n  147  /** Finds a shader file. If in development mode (see isDevelopmentMode()), shaders are searched\n  148:     within the source directories. Otherwise, shaders are searched in the Shaders directory\n  149      located besides the executable.\n  150      \\param[in] filename The file to look for\n  ...\n  152      \\return true if the file was found, otherwise false\n  153  */\n  154: dlldecl bool findFileInShaderDirectories(const std::string& filename, std::string& fullPath);\n  155  \n  156: /** Get a list of all shader directories.\n  157  */\n  158: dlldecl const std::vector<std::string>& getShaderDirectoriesList();\n  159  \n  160: /** Given a filename, returns the shortest possible path to the file relative to the data directories.\n  161:     If the file is not relative to the data directories, return the original filename\n  162  */\n  163: dlldecl std::string stripDataDirectories(const std::string& filename);\n  164  \n  165  /** Structure to help with file dialog file-extension filters\n  ...\n  171  };\n  172  \n  173: using FileDialogFilterVec = std::vector<FileDialogFilter>;\n  174  \n  175  /** Creates a 'open file' dialog box.\n  ...\n  193  dlldecl bool chooseFolderDialog(std::string& folder);\n  194  \n  195: /** Checks if a file exists in the file system. This function doesn't look in the common directories.\n  196      \\param[in] filename The file to look for\n  197      \\return true if the file was found, otherwise false\n  ...\n  199  dlldecl bool doesFileExist(const std::string& filename);\n  200  \n  201: /** Checks if a directory exists in the file system.\n  202:     \\param[in] filename The directory to look for\n  203:     \\return true if the directory was found, otherwise false\n  204  */\n  205: dlldecl bool isDirectoryExists(const std::string& filename);\n  206  \n  207  /** Open watch thread for file changes and call callback when the file is written to.\n  ...\n  216  dlldecl void closeSharedFile(const std::string& filePath);\n  217  \n  218: /** Creates a file in the temperary directory and returns the path.\n  219      \\return pathName Absolute path to unique temp file.\n  220  */\n  221  dlldecl std::string getTempFilename();\n  222  \n  223: /** Create a directory from path.\n  224  */\n  225: dlldecl bool createDirectory(const std::string& path);\n  226  \n  227  /** Given the app name and full command line arguments, begin the process\n  ...\n  237  dlldecl void terminateProcess(size_t processID);\n  238  \n  239: /** Get the current executable directory\n  240:     \\return The full path of the application directory\n  241  */\n  242: dlldecl const std::string& getExecutableDirectory();\n  243  \n  244  /** Get the current executable name\n  ...\n  247  dlldecl const std::string& getExecutableName();\n  248  \n  249: /** Get the working directory. This can be different from the executable directory (for example, by default when you launch an app from Visual Studio, the working the directory is the directory containing the project file).\n  250  */\n  251: dlldecl const std::string getWorkingDirectory();\n  252  \n  253: /** Get the application data directory.\n  254  */\n  255: dlldecl const std::string getAppDataDirectory();\n  256  \n  257  /** Get the content of a system environment variable.\n  ...\n  262  dlldecl bool getEnvironmentVariable(const std::string& varName, std::string& value);\n  263  \n  264: /** Get a list of all recorded data directories.\n  265  */\n  266: dlldecl const std::vector<std::string>& getDataDirectoriesList();\n  267  \n  268: /** Adds a folder into the search directory. Once added, calls to FindFileInCommonDirs() will seach that directory as well\n  269:     \\param[in] dir The new directory to add to the common directories.\n  270  */\n  271: dlldecl void addDataDirectory(const std::string& dir);\n  272  \n  273: /** Removes a folder from the search directories\n  274:     \\param[in] dir The directory name to remove from the common directories.\n  275  */\n  276: dlldecl void removeDataDirectory(const std::string& dir);\n  277  \n  278  /** Find a new filename based on the supplied parameters. This function doesn't actually create the file, just find an available file name.\n  279      \\param[in] prefix Requested file prefix.\n  280:     \\param[in] directory The directory to create the file in.\n  281      \\param[in] extension The requested file extension.\n  282:     \\param[out] filename On success, will hold a valid unused filename in the following format - 'Directory\\\\Prefix.<index>.Extension'.\n  283      \\return true if an available filename was found, otherwise false.\n  284  */\n  285: dlldecl bool findAvailableFilename(const std::string& prefix, const std::string& directory, const std::string& extension, std::string& filename);\n  286  \n  287  /** Check if a debugger session is attached.\n  ...\n  309  dlldecl void printToDebugWindow(const std::string& s);\n  310  \n  311: /** Get directory from filename.\n  312:     \\param[in] filename File path to strip directory from\n  313:     \\return Stripped directory path\n  314  */\n  315: dlldecl std::string getDirectoryFromFile(const std::string& filename);\n  316  \n  317  /** Get  extension tag from filename.\n  ...\n  337  /** Enumerate files using search string\n  338      \\param[in] searchString String to use in file search\n  339:     \\param[out] filenames Vector of found filenames\n  340  */\n  341: dlldecl void enumerateFiles(std::string searchString, std::vector<std::string>& filenames);\n  342  \n  343  /** Return current thread handle\n\n/home/max/dev/Falcor/src/Falcor/Core/Platform/ProgressBar.h:\n   27   **************************************************************************/\n   28  #pragma once\n   29: #include <vector>\n   30  \n   31  namespace Falcor\n   ..\n   39      public:\n   40          using SharedPtr = std::shared_ptr<ProgressBar>;\n   41:         using MessageList = std::vector<std::string>;\n   42          ~ProgressBar();\n   43  \n\n/home/max/dev/Falcor/src/Falcor/Core/Platform/Windows/Windows.cpp:\n   60          const MsgBoxCustomButton buttonNo{uint32_t(MsgBoxButton::No), \"No\"};\n   61  \n   62:         std::vector<MsgBoxCustomButton> buttons;\n   63          switch (type)\n   64          {\n   ..\n   74      }\n   75  \n   76:     uint32_t msgBox(const std::string& msg, std::vector<MsgBoxCustomButton> buttons, MsgBoxIcon icon, uint32_t defaultButtonId)\n   77      {\n   78          assert(buttons.size() > 0);\n   ..\n  128  \n  129          // Set up button configs\n  130:         std::vector<std::wstring> wideButtonTitles(buttons.size());\n  131:         std::vector<TASKDIALOG_BUTTON> buttonConfigs(buttons.size());\n  132          for (size_t i = 0; i < buttons.size(); ++i)\n  133          {\n  ...\n  187      }\n  188  \n  189:     bool isDirectoryExists(const std::string& filename)\n  190      {\n  191          DWORD attr = GetFileAttributesA(filename.c_str());\n  ...\n  193      }\n  194  \n  195:     bool createDirectory(const std::string& path)\n  196      {\n  197:         DWORD res = CreateDirectoryA(path.c_str(), NULL);\n  198  \n  199          return res == TRUE;\n  ...\n  206      }\n  207  \n  208:     const std::string& getExecutableDirectory()\n  209      {\n  210          static std::string folder;\n  ...\n  221      }\n  222  \n  223:     const std::string getWorkingDirectory()\n  224      {\n  225          CHAR curDir[MAX_PATH];\n  226:         GetCurrentDirectoryA(MAX_PATH, curDir);\n  227          return std::string(curDir);\n  228      }\n  229  \n  230:     const std::string getAppDataDirectory()\n  231      {\n  232          PWSTR wpath;\n  ...\n  330          const COMDLG_FILTERSPEC* data() const { return comDlg.data(); }\n  331      private:\n  332:         std::vector<COMDLG_FILTERSPEC> comDlg;\n  333:         std::vector<std::wstring> descs;\n  334:         std::vector<std::wstring> ext;\n  335      };\n  336  \n  ...\n  382      {\n  383          std::string fullpath;\n  384:         if (findFileInDataDirectories(iconFile, fullpath))\n  385          {\n  386              HANDLE hIcon = LoadImageA(GetModuleHandle(NULL), fullpath.c_str(), IMAGE_ICON, 0, 0, LR_DEFAULTSIZE | LR_LOADFROMFILE);\n  ...\n  404      }\n  405  \n  406:     float getDisplayScaleFactor()\n  407      {\n  408          float dpi = (float)getDisplayDpi();\n  ...\n  411  \n  412          ::SetProcessDPIAware();\n  413:         DEVICE_SCALE_FACTOR factor;\n  414:         if (GetScaleFactorForMonitor(nullptr, &factor) == S_OK)\n  415          {\n  416:             switch (factor)\n  417              {\n  418              case SCALE_100_PERCENT: return 1.0f;\n  ...\n  493      {\n  494          std::string fileName = getFilenameFromPath(filePath);\n  495:         std::string dir = getDirectoryFromFile(filePath);\n  496  \n  497          HANDLE hFile = CreateFileA(dir.c_str(), GENERIC_READ | FILE_LIST_DIRECTORY,\n  ...\n  506              size_t offset = 0;\n  507              uint32_t bytesReturned = 0;\n  508:             std::vector<uint32_t> buffer;\n  509              buffer.resize(1024);\n  510  \n  511:             if (!ReadDirectoryChangesW(hFile, buffer.data(), static_cast<uint32_t>(sizeof(uint32_t) * buffer.size()), FALSE,\n  512                  FILE_NOTIFY_CHANGE_LAST_WRITE, 0, &overlapped, nullptr))\n  513              {\n  514:                 logError(\"Failed to read directory changes for shared file.\");\n  515                  CloseHandle(hFile);\n  516                  return;\n  ...\n  519              if (!GetOverlappedResult(hFile, &overlapped, (LPDWORD)&bytesReturned, true))\n  520              {\n  521:                 logError(\"Failed to read directory changes for shared file.\");\n  522                  CloseHandle(hFile);\n  523                  return;\n  ...\n  584      }\n  585  \n  586:     void enumerateFiles(std::string searchString, std::vector<std::string>& filenames)\n  587      {\n  588          WIN32_FIND_DATAA ffd;\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/Program.cpp:\n  150  \n  151  // Program\n  152: std::vector<std::weak_ptr<Program>> Program::sPrograms;\n  153  \n  154  void Program::init(std::shared_ptr<Device> device, Desc const& desc, DefineList const& defineList) {\n  ...\n  350      // Note: Slang allows application to plug in a callback API to\n  351      // implement file I/O, and this could be used instead of specifying\n  352:     // the data directories to Slang.\n  353      //\n  354:     std::vector<const char*> slangSearchPaths;\n  355:     for (auto& path : getShaderDirectoriesList()) {\n  356          slangSearchPaths.push_back(path.c_str());\n  357      }\n  ...\n  403      // own preprocessing any more.\n  404      //\n  405:     std::vector<slang::PreprocessorMacroDesc> slangDefines;\n  406      const auto addSlangDefine = [&slangDefines] (const char* name, const char* value) {\n  407          slangDefines.push_back({ name, value });\n  ...\n  495              }\n  496              std::string fullpath;\n  497:             if (!findFileInShaderDirectories(src.pLibrary->getFilename(), fullpath)) {\n  498                  logError(\"Can't find file \" + src.pLibrary->getFilename());\n  499                  spDestroyCompileRequest(pSlangRequest);\n  ...\n  527      ProgramVersion const*                       pVersion,\n  528      slang::IComponentType*                      pSlangGlobalScope,\n  529:     std::vector<ComPtr<slang::IComponentType>>  pSlangLinkedEntryPoints,\n  530:     ProgramReflection::SharedPtr&               pReflector,\n  531      std::string&                                log) const\n  532  {\n  ...\n  535      // TODO: actually need to reflect the entry point groups!\n  536  \n  537:     std::vector<slang::EntryPointLayout*> pSlangEntryPointReflectors;\n  538  \n  539      for( auto pSlangLinkedEntryPoint : pSlangLinkedEntryPoints ) {\n  540          auto pSlangEntryPointLayout = pSlangLinkedEntryPoint->getLayout()->getEntryPointByIndex(0);\n  541:         pSlangEntryPointReflectors.push_back(pSlangEntryPointLayout);\n  542      }\n  543  \n  544:     pReflector = ProgramReflection::create(\n  545          pVersion,\n  546          pSlangGlobalScopeLayout,\n  547:         pSlangEntryPointReflectors,\n  548          log);\n  549  \n  ...\n  603  \n  604      uint32_t allEntryPointCount = uint32_t(mDesc.mEntryPoints.size());\n  605:     std::vector<ComPtr<slang::IComponentType>> pLinkedEntryPoints;\n  606  \n  607      for( uint32_t ee = 0; ee < allEntryPointCount; ++ee ) {\n  ...\n  631      // be valid to bind to the specialized program.\n  632      //\n  633:     // Still, the specialized reflector may differ from the\n  634:     // unspecialized reflector in a few key ways:\n  635      //\n  636      // * There may be additional registers/bindings allocated for\n  ...\n  664          // the global scope in that case.\n  665          //\n  666:         std::vector<slang::IComponentType*> componentTypesForProgram;\n  667          componentTypesForProgram.push_back(pSpecializedSlangGlobalScope);\n  668          \n  ...\n  681      }\n  682  \n  683:     ProgramReflection::SharedPtr pReflector;\n  684:     doSlangReflection(pVersion, pSpecializedSlangProgram, pLinkedEntryPoints, pReflector, log);\n  685  \n  686      // In order to construct the `ProgramKernels` we need to extract\n  687      // the kernels for each entry-point group.\n  688      //\n  689:     std::vector<EntryPointGroupKernels::SharedPtr> entryPointGroups;\n  690  \n  691      // TODO: Because we aren't actually specializing entry-point groups,\n  ...\n  706          //\n  707          auto groupEntryPointCount = entryPointGroupDesc.entryPointCount;\n  708:         std::vector<Shader::SharedPtr> shaders;\n  709          \n  710          LOG_DBG(\"1.1\");\n  ...\n  749          }\n  750  \n  751:         auto pGroupReflector = pReflector->getEntryPointGroup(gg);\n  752  \n  753:         auto pEntryPointGroupKernels = createEntryPointGroupKernels(shaders, pGroupReflector);\n  754          entryPointGroups.push_back(pEntryPointGroupKernels);\n  755      }\n  ...\n  760              mpDevice,\n  761              pVersion,\n  762:             pReflector,\n  763              entryPointGroups,\n  764              log,\n  ...\n  785      ComPtr<slang::ISession> pSlangSession(pSlangGlobalScope->getSession());\n  786  \n  787:     std::vector<ComPtr<slang::IComponentType>> pSlangEntryPoints;\n  788      uint32_t entryPointCount = (uint32_t) mDesc.mEntryPoints.size();\n  789      \n  ...\n  835          pSlangProgram.writeRef());\n  836  \n  837:     ProgramReflection::SharedPtr pReflector;\n  838      \n  839:     if( !doSlangReflection(pVersion.get(), pSlangGlobalScope, pSlangEntryPoints, pReflector, log) ) {\n  840          return nullptr;\n  841      }\n  ...\n  843      pVersion->init(\n  844          mDefineList,\n  845:         pReflector,\n  846          getProgramDescString(),\n  847          pSlangEntryPoints);\n  ...\n  851  \n  852  EntryPointGroupKernels::SharedPtr Program::createEntryPointGroupKernels(\n  853:     const std::vector<Shader::SharedPtr>& shaders,\n  854:     EntryPointBaseReflection::SharedPtr const& pReflector) const\n  855  {\n  856      return EntryPointGroupKernels::create(EntryPointGroupKernels::Type::Rasterization, shaders);\n  ...\n  939      // Once we are done, we will have written a compacted\n  940      // version of `sPrograms` (skipping the null elements)\n  941:     // to the first N elements of the vector. To make the\n  942:     // vector only contain those first N elements, we\n  943      // then need to erase everything past the last point\n  944      // we wrote to.\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/Program.h:\n  149          };\n  150  \n  151:         std::vector<Source> mSources;\n  152:         std::vector<EntryPointGroup> mGroups;\n  153:         std::vector<EntryPoint> mEntryPoints;\n  154  \n  155          int32_t mActiveSource = -1;\n  ...\n  232          \\return Program reflection object, or an exception is thrown on failure.\n  233      */\n  234:     ProgramReflection::ConstSharedPtrRef getReflector() const { return getActiveVersion()->getReflector(); }\n  235  \n  236      uint32_t getEntryPointGroupCount() const { return uint32_t(mDesc.mGroups.size()); }\n  ...\n  255          ProgramVersion const*                       pVersion,\n  256          slang::IComponentType*                      pSlangGlobalScope,\n  257:         std::vector<ComPtr<slang::IComponentType>>  pSlangEntryPointGroups,\n  258:         ProgramReflection::SharedPtr&               pReflector,\n  259          std::string&                                log) const;\n  260  \n  ...\n  267  \n  268      virtual EntryPointGroupKernels::SharedPtr createEntryPointGroupKernels(\n  269:         const std::vector<Shader::SharedPtr>& shaders,\n  270:         EntryPointGroupReflection::SharedPtr const& pReflector) const;\n  271  \n  272      // The description used to create this program\n  ...\n  282  \n  283      std::string getProgramDescString() const;\n  284:     static std::vector<std::weak_ptr<Program>> sPrograms;\n  285  \n  286      using string_time_map = std::unordered_map<std::string, time_t>;\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramReflection.cpp:\n  195          }\n  196  \n  197:         // These \"storage\" fields are used in the constructor\n  198          // when it needs to allocate aditional links. By pre-allocating\n  199          // them here in the body of the type we avoid having to do\n  ...\n  669  \n  670                      pType->setStructType(pElementType);\n  671:                     pType->setParameterBlockReflector(pSubBlock);\n  672  \n  673                      // TODO: `pSubBlock` should probably get stored on the\n  ...\n  682                          bindingInfo.flavor = ParameterBlockReflection::ResourceRangeBindingInfo::Flavor::ConstantBuffer;\n  683                      }\n  684:                     bindingInfo.pSubObjectReflector = pSubBlock;\n  685                  }\n  686                  break;\n  ...\n  797              pPendingBlock->finalize();\n  798  \n  799:             pType->setParameterBlockReflector(pPendingBlock);\n  800  \n  801:             bindingInfo.pSubObjectReflector = pPendingBlock;\n  802  \n  803              category = slang::ParameterCategory::Uniform;\n  ...\n  865              case TypeReflection::Kind::Scalar:\n  866              case TypeReflection::Kind::Matrix:\n  867:             case TypeReflection::Kind::Vector:\n  868                  return reflectBasicType(pSlangType);\n  869              case TypeReflection::Kind::None:\n  ...\n  963          TypeReflection::Kind kind = pTypeLayout->getKind();\n  964          // If this is a leaf node, store it\n  965:         if ((kind == TypeReflection::Kind::Matrix) || (kind == TypeReflection::Kind::Vector) || (kind == TypeReflection::Kind::Scalar)) {\n  966              storeShaderVariable(path, category, name, varMap, pVarMapBySemantic, 0, 0);\n  967          } else if (kind == TypeReflection::Kind::Array) {\n  968              auto arrayKind = pTypeLayout->getElementTypeLayout()->getKind();\n  969:             assert((arrayKind == TypeReflection::Kind::Matrix) || (arrayKind == TypeReflection::Kind::Vector) || (arrayKind == TypeReflection::Kind::Scalar));\n  970              uint32_t arraySize = (uint32_t)pTypeLayout->getTotalArrayElementCount();\n  971              uint32_t arrayStride = (uint32_t)pTypeLayout->getElementStride(SLANG_PARAMETER_CATEGORY_UNIFORM);\n  ...\n  995      ProgramReflection::SharedPtr ProgramReflection::create(\n  996          ProgramVersion const* pProgramVersion,\n  997:         slang::ShaderReflection* pSlangReflector,\n  998:         std::vector<slang::EntryPointLayout*> const& pSlangEntryPointReflectors,\n  999          std::string& log)\n 1000      {\n 1001:         return SharedPtr(new ProgramReflection(pProgramVersion, pSlangReflector, pSlangEntryPointReflectors, log));\n 1002      }\n 1003  \n ....\n 1064          ProgramVersion const*   pProgramVersion,\n 1065          uint32_t                groupIndex,\n 1066:         std::vector<slang::EntryPointLayout*> const& pSlangEntryPointReflectors)\n 1067      {\n 1068          // We are going to expect/require that all the entry points have the\n ....\n 1077          assert(entryPointCount != 0);\n 1078  \n 1079:         slang::EntryPointLayout* pBestEntryPoint = pSlangEntryPointReflectors[pProgram->getGroupEntryPointIndex(groupIndex, 0)];\n 1080          for (uint32_t ee = 0; ee < entryPointCount; ++ee)\n 1081          {\n 1082:             slang::EntryPointReflection* pSlangEntryPoint = pSlangEntryPointReflectors[pProgram->getGroupEntryPointIndex(groupIndex, ee)];\n 1083  \n 1084              if(getUniformParameterCount(pSlangEntryPoint) > getUniformParameterCount(pBestEntryPoint))\n ....\n 1179      ProgramReflection::ProgramReflection(\n 1180          ProgramVersion const* pProgramVersion,\n 1181:         slang::ShaderReflection* pSlangReflector,\n 1182:         std::vector<slang::EntryPointLayout*> const& pSlangEntryPointReflectors,\n 1183          std::string& log)\n 1184          : mpProgramVersion(pProgramVersion)\n 1185:         , mpSlangReflector(pSlangReflector)\n 1186      {\n 1187          // For the most part the program scope needs to be refelcted like a struct type\n ....\n 1191  \n 1192          ReflectionStructType::BuildState buildState;\n 1193:         for (uint32_t i = 0; i < pSlangReflector->getParameterCount(); i++)\n 1194          {\n 1195:             VariableLayoutReflection* pSlangLayout = pSlangReflector->getParameterByIndex(i);\n 1196  \n 1197              ReflectionVar::SharedPtr pVar = reflectTopLevelVariable(\n ....\n 1215                  pProgramVersion,\n 1216                  gg,\n 1217:                 pSlangEntryPointReflectors);\n 1218              mEntryPointGroups.push_back(pEntryPointGroup);\n 1219          }\n 1220  \n 1221          // Reflect per-stage parameters\n 1222:         for(auto pSlangEntryPoint : pSlangEntryPointReflectors)\n 1223          {\n 1224              switch (pSlangEntryPoint->getStage())\n ....\n 1538  \n 1539          std::map<SetIndex, uint32_t> newSetIndices;\n 1540:         ParameterBlockReflection* pPrimaryReflector;\n 1541  \n 1542          uint32_t computeDescriptorSetIndex(\n ....\n 1549              {\n 1550                  // New set\n 1551:                 setIndex = (uint32_t) pPrimaryReflector->mDescriptorSets.size();\n 1552                  newSetIndices[origIndex] = setIndex;\n 1553:                 pPrimaryReflector->mDescriptorSets.push_back({});\n 1554              }\n 1555              else\n ....\n 1569          void addSubObjectResources(\n 1570              uint32_t subObjectResourceRangeIndex,\n 1571:             ParameterBlockReflection const* pSubObjectReflector,\n 1572              bool shouldSkipDefaultConstantBufferRange)\n 1573          {\n ....\n 1576              // arrays of constant buffers.\n 1577  \n 1578:             assert(pSubObjectReflector);\n 1579:             auto subSetCount = pSubObjectReflector->getDescriptorSetCount();\n 1580              for (uint32_t subSetIndex = 0; subSetIndex < subSetCount; ++subSetIndex)\n 1581              {\n 1582:                 auto& subSet = pSubObjectReflector->getDescriptorSetInfo(subSetIndex);\n 1583  \n 1584                  assert(subSet.layout.getRangeCount() != 0);\n ....\n 1586  \n 1587                  auto setIndex = computeDescriptorSetIndex(subRange.regSpace, subRange.type);\n 1588:                 auto& setInfo = pPrimaryReflector->mDescriptorSets[setIndex];\n 1589  \n 1590                  ParameterBlockReflection::DescriptorSetInfo::SubObjectInfo subObjectInfo;\n ....\n 1614          }\n 1615  \n 1616:         void finalize(ParameterBlockReflection* pReflector)\n 1617          {\n 1618:             pPrimaryReflector = pReflector;\n 1619  \n 1620:             if (pReflector->hasDefaultConstantBuffer())\n 1621              {\n 1622                  auto descriptorType = DescriptorSet::Type::Cbv;\n 1623:                 auto& bindingInfo = pReflector->mDefaultConstantBufferBindingInfo;\n 1624  \n 1625                  if(!bindingInfo.useRootConstants)\n ....\n 1628  \n 1629                      bindingInfo.descriptorSetIndex = setIndex;\n 1630:                     auto& setInfo = pReflector->mDescriptorSets[setIndex];\n 1631  \n 1632                      setInfo.layout.addRange(\n ....\n 1639  \n 1640              // Iterate over descriptors\n 1641:             auto resourceRangeCount = pReflector->mResourceRanges.size();\n 1642              for (uint32_t rangeIndex = 0; rangeIndex < resourceRangeCount; ++rangeIndex)\n 1643              {\n 1644:                 const auto& range = pReflector->getElementType()->getResourceRange(rangeIndex);\n 1645:                 auto& rangeBindingInfo = pReflector->mResourceRanges[rangeIndex];\n 1646  \n 1647                  switch (rangeBindingInfo.flavor) {\n ....\n 1651  \n 1652                          rangeBindingInfo.descriptorSetIndex = setIndex;\n 1653:                         auto& setInfo = pReflector->mDescriptorSets[setIndex];\n 1654  \n 1655                          setInfo.layout.addRange(\n ....\n 1673  \n 1674                          rangeBindingInfo.descriptorSetIndex = setIndex;\n 1675:                         auto& setInfo = pReflector->mDescriptorSets[setIndex];\n 1676  \n 1677                          setInfo.layout.addRange(\n ....\n 1684                      }\n 1685                          // ----------------------------------------\n 1686:                         pReflector->mRootDescriptorRangeIndices.push_back(rangeIndex);\n 1687                          break;\n 1688  \n ....\n 1699              for (uint32_t rangeIndex = 0; rangeIndex < resourceRangeCount; ++rangeIndex)\n 1700              {\n 1701:                 auto& rangeBindingInfo = pReflector->mResourceRanges[rangeIndex];\n 1702  \n 1703                  if (rangeBindingInfo.flavor != ParameterBlockReflection::ResourceRangeBindingInfo::Flavor::ConstantBuffer)\n 1704                      continue;\n 1705  \n 1706:                 addSubObjectResources(rangeIndex, rangeBindingInfo.pSubObjectReflector.get(), false);\n 1707              }\n 1708  \n ....\n 1710              for (uint32_t rangeIndex = 0; rangeIndex < resourceRangeCount; ++rangeIndex)\n 1711              {\n 1712:                 auto& rangeBindingInfo = pReflector->mResourceRanges[rangeIndex];\n 1713                  if (rangeBindingInfo.flavor != ParameterBlockReflection::ResourceRangeBindingInfo::Flavor::ParameterBlock)\n 1714                      continue;\n 1715  \n 1716:                 pReflector->mParameterBlockSubObjectRangeIndices.push_back(rangeIndex);\n 1717              }\n 1718  \n ....\n 1720              for (uint32_t rangeIndex = 0; rangeIndex < resourceRangeCount; ++rangeIndex)\n 1721              {\n 1722:                 auto& rangeBindingInfo = pReflector->mResourceRanges[rangeIndex];\n 1723  \n 1724                  if(rangeBindingInfo.flavor != ParameterBlockReflection::ResourceRangeBindingInfo::Flavor::Interface)\n ....\n 1726  \n 1727                  // TODO(tfoley): need to figure out what exactly is appropriate here.\n 1728:                 if( auto pSubObjectReflector = rangeBindingInfo.pSubObjectReflector )\n 1729                  {\n 1730:                     addSubObjectResources(rangeIndex, pSubObjectReflector.get(), pSubObjectReflector->hasDefaultConstantBuffer());\n 1731                  }\n 1732              }\n ....\n 1769              return mpDefaultBlock;\n 1770  \n 1771:         return mpDefaultBlock->getElementType()->findMember(name)->getType()->asResourceType()->getParameterBlockReflector()->shared_from_this();\n 1772      }\n 1773  \n ....\n 2063              return iter->second;\n 2064  \n 2065:         auto pSlangType = mpSlangReflector->findTypeByName(name.c_str());\n 2066          if (!pSlangType) return nullptr;\n 2067:         auto pSlangTypeLayout = mpSlangReflector->getTypeLayout(pSlangType);\n 2068  \n 2069          auto pFalcorTypeLayout = reflectType(pSlangTypeLayout, nullptr, nullptr, mpProgramVersion);\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramReflection.h:\n   93          UniformShaderVarOffset myOffset = UniformShaderVarOffset::kInvalid;\n   94  \n   95:     Note that the default constructor also creates an invalid offset, so this could instead\n   96      be written more simply as:\n   97  \n   ..\n  100      enum Invalid { kInvalid = -1 };\n  101  \n  102:     /** Default constructor: creates an invalid offset.\n  103      */\n  104      UniformShaderVarOffset(Invalid _ = kInvalid)\n  ...\n  229          ResourceShaderVarOffset myOffset = ResourceShaderVarOffset::kInvalid;\n  230  \n  231:     Note that the default constructor also constructs an invalid offset, so this\n  232      could be written more simply as:\n  233  \n  ...\n  237      enum Invalid { kInvalid = -1 };\n  238  \n  239:     /** Default constructor: constructs an invalid offset.\n  240      */\n  241      ResourceShaderVarOffset(Invalid _ = kInvalid)\n  ...\n  364          ShaderVarOffset myOffset = ShaderVarOffset::kInvalid;\n  365  \n  366:     Note that the default constructor also constructs an invalid offset, so this\n  367      could be written more simply as:\n  368  \n  ...\n  372      enum Invalid { kInvalid = -1 };\n  373  \n  374:     /** Default constructor: constructs an invalid offset.\n  375      */\n  376      ShaderVarOffset(Invalid _ = kInvalid)\n  ...\n  533  {\n  534  public:\n  535:     /** Default constructor: constructs an invalid offset.\n  536      */\n  537      TypedShaderVarOffset(Invalid _ = kInvalid)\n  ...\n  751      Kind mKind;\n  752      ByteSize mByteSize = 0;\n  753:     std::vector<ResourceRange> mResourceRanges;\n  754      slang::TypeLayoutReflection* mpSlangTypeLayout = nullptr;\n  755  };\n  ...\n  879          const std::string& name,\n  880          slang::TypeLayoutReflection*    pSlangTypeLayout);\n  881:     std::vector<std::shared_ptr<const ReflectionVar>> mMembers;   // Struct members\n  882      std::unordered_map<std::string, int32_t> mNameToIndex; // Translates from a name to an index in mMembers\n  883      std::string mName;\n  884  };\n  885  \n  886: /** Reflection object for scalars, vectors and matrices\n  887  */\n  888  class dlldecl ReflectionBasicType : public ReflectionType, public inherit_shared_from_this<ReflectionType, ReflectionBasicType>\n  ...\n 1047      const ReflectionType::SharedConstPtr& getStructType() const { return mpStructType; }\n 1048  \n 1049:     const std::shared_ptr<const ParameterBlockReflection>& getParameterBlockReflector() const { return mpParameterBlockReflector; }\n 1050:     void setParameterBlockReflector(const std::shared_ptr<const ParameterBlockReflection>& pReflector)\n 1051      {\n 1052:         mpParameterBlockReflector = pReflector;\n 1053      }\n 1054  \n ....\n 1089      Type mType;\n 1090      ReflectionType::SharedConstPtr mpStructType;   // For constant- and structured-buffers\n 1091:     std::shared_ptr<const ParameterBlockReflection> mpParameterBlockReflector; // For constant buffers and parameter blocks\n 1092  };\n 1093  \n ....\n 1107      bool operator==(const ReflectionType& other) const override;\n 1108  \n 1109:     const std::shared_ptr<const ParameterBlockReflection>& getParameterBlockReflector() const { return mpParameterBlockReflector; }\n 1110:     void setParameterBlockReflector(const std::shared_ptr<const ParameterBlockReflection>& pReflector)\n 1111      {\n 1112:         mpParameterBlockReflector = pReflector;\n 1113      }\n 1114  \n ....\n 1117          slang::TypeLayoutReflection*    pSlangTypeLayout);\n 1118  \n 1119:     std::shared_ptr<const ParameterBlockReflection> mpParameterBlockReflector; // For interface types that have been specialized\n 1120  };\n 1121  \n ....\n 1178      static const uint32_t kInvalidIndex = 0xffffffff;\n 1179  \n 1180:     /** Create a new parameter block reflector, for the given element type.\n 1181      */\n 1182      static SharedPtr create(\n ....\n 1184          ReflectionType::SharedConstPtr const& pElementType);\n 1185  \n 1186:     /** Create a new shader object reflector, for the given element type.\n 1187      */\n 1188      static SharedPtr create(\n ....\n 1224          /// descriptor ranges in the `layout`.\n 1225          ///\n 1226:         std::vector<uint32_t>   resourceRangeIndices;\n 1227  \n 1228          /// Information about a sub-object that should have some\n ....\n 1245          /// have data written into this descriptor sets.\n 1246          ///\n 1247:         std::vector<SubObjectInfo> subObjects;\n 1248      };\n 1249  \n ....\n 1284  \n 1285          /// The reflection object for a sub-object range.\n 1286:         ParameterBlockReflection::SharedConstPtr pSubObjectReflector;\n 1287  \n 1288          bool isDescriptorSet() const { return flavor == Flavor::Simple; }\n ....\n 1358      /// this will record the corresponding `register` and `space`.\n 1359      ///\n 1360:     std::vector<ResourceRangeBindingInfo> mResourceRanges;\n 1361  \n 1362      /// Layout and binding information for all descriptor sets that\n 1363      /// must be created to represent the state of a parameter block\n 1364:     /// using this reflector.\n 1365      ///\n 1366      /// Note: this array does *not* include information for descriptor\n ....\n 1369      /// descriptor sets that this object can simply re-use.\n 1370      ///\n 1371:     std::vector<DescriptorSetInfo> mDescriptorSets;\n 1372  \n 1373      /// Indices of the resource ranges that represent root descriptors,\n ....\n 1378      /// are required to allocate and maintain their own root descriptor range indices.\n 1379      ///\n 1380:     std::vector<uint32_t> mRootDescriptorRangeIndices;\n 1381  \n 1382      /// Indices of the resource ranges that represent parameter blocks,\n ....\n 1384      /// along with the descriptor sets directly stored on the parameter block\n 1385      ///\n 1386:     std::vector<uint32_t> mParameterBlockSubObjectRangeIndices;\n 1387  \n 1388      ProgramVersion const* mpProgramVersion = nullptr;\n ....\n 1402          ProgramVersion const*   pProgramVersion,\n 1403          uint32_t                groupIndex,\n 1404:         std::vector<slang::EntryPointLayout*> const& pSlangEntryPointReflectors);\n 1405  \n 1406  private:\n ....\n 1430      using BindLocation = ParameterBlockReflection::BindLocation;\n 1431  \n 1432:     /** Create a new object for a Slang reflector object\n 1433      */\n 1434      static SharedPtr create(\n 1435          ProgramVersion const* pProgramVersion,\n 1436:         slang::ShaderReflection* pSlangReflector,\n 1437:         std::vector<slang::EntryPointLayout*> const& pSlangEntryPointReflectors,\n 1438          std::string& log);\n 1439  \n ....\n 1482      ReflectionVar::SharedConstPtr findMember(const std::string& name) const;\n 1483  \n 1484:     std::vector<EntryPointGroupReflection::SharedPtr> const& getEntryPointGroups() const { return mEntryPointGroups; }\n 1485  \n 1486      EntryPointGroupReflection::SharedPtr const& getEntryPointGroup(uint32_t index) const { return mEntryPointGroups[index]; }\n ....\n 1489      ProgramReflection(\n 1490          ProgramVersion const* pProgramVersion,\n 1491:         slang::ShaderReflection* pSlangReflector,\n 1492:         std::vector<slang::EntryPointLayout*> const& pSlangEntryPointReflectors,\n 1493          std::string& log);\n 1494      ProgramReflection(ProgramVersion const* pProgramVersion);\n ....\n 1506      VariableMap mVertAttrBySemantic;\n 1507  \n 1508:     slang::ShaderReflection* mpSlangReflector = nullptr;\n 1509      mutable std::map<std::string, ReflectionType::SharedPtr> mMapNameToType;\n 1510  \n 1511:     std::vector<EntryPointGroupReflection::SharedPtr> mEntryPointGroups;\n 1512  };\n 1513  \n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramVars.cpp:\n   55      }\n   56  \n   57:     ProgramVars::ProgramVars(std::shared_ptr<Device> pDevice, const ProgramReflection::SharedConstPtr& pReflector)\n   58:         : ParameterBlock(pDevice, pReflector->getProgramVersion() , pReflector->getDefaultParameterBlock())\n   59:         , mpReflector(pReflector)\n   60      {\n   61:         assert(pReflector);\n   62      }\n   63  \n   64      void ProgramVars::addSimpleEntryPointGroups() {\n   65:         auto& entryPointGroups = mpReflector->getEntryPointGroups();\n   66          auto groupCount = entryPointGroups.size();\n   67  \n   ..\n   73      }\n   74  \n   75:     GraphicsVars::GraphicsVars(std::shared_ptr<Device> pDevice, const ProgramReflection::SharedConstPtr& pReflector): ProgramVars(pDevice, pReflector) {\n   76          addSimpleEntryPointGroups();\n   77      }\n   78  \n   79:     GraphicsVars::SharedPtr GraphicsVars::create(std::shared_ptr<Device> pDevice, const ProgramReflection::SharedConstPtr& pReflector) {\n   80:         if (pReflector == nullptr) {\n   81:             throw std::runtime_error(\"Can't create a GraphicsVars object without a program reflector\");\n   82          }\n   83:         return SharedPtr(new GraphicsVars(pDevice, pReflector));\n   84      }\n   85  \n   ..\n   88              throw std::runtime_error(\"Can't create a GraphicsVars object without a program\");\n   89          }\n   90:         return create(pDevice, pProg->getReflector());\n   91      }\n   92  \n   93:     ComputeVars::SharedPtr ComputeVars::create(std::shared_ptr<Device> pDevice, const ProgramReflection::SharedConstPtr& pReflector) {\n   94:         if (pReflector == nullptr) {\n   95:             throw std::runtime_error(\"Can't create a ComputeVars object without a program reflector\");\n   96          }\n   97:         return SharedPtr(new ComputeVars(pDevice, pReflector));\n   98      }\n   99  \n  ...\n  102              throw std::runtime_error(\"Can't create a ComputeVars object without a program\");\n  103          }\n  104:         return create(pDevice, pProg->getReflector());\n  105      }\n  106  \n  107:     ComputeVars::ComputeVars(std::shared_ptr<Device> pDevice, const ProgramReflection::SharedConstPtr& pReflector) : ProgramVars(pDevice, pReflector) {\n  108          addSimpleEntryPointGroups();\n  109      }\n  ...\n  140  \n  141      template<bool forGraphics>\n  142:     void bindRootConstants(CopyContext* pContext, uint32_t rootIndex, ParameterBlock* pParameterBlock, const ParameterBlockReflection* pParameterBlockReflector) {\n  143          #ifdef _WIN32\n  144:         uint32_t count = uint32_t(pParameterBlockReflector->getElementType()->getByteSize() / sizeof(uint32_t));\n  145          void const* pSrc = pParameterBlock->getRawData();\n  146          if (forGraphics) {\n  ...\n  163      bool bindParameterBlockSets(\n  164          ParameterBlock*                 pParameterBlock,\n  165:         const ParameterBlockReflection* pParameterBlockReflector,\n  166          CopyContext*                    pContext,\n  167          RootSignature*                  pRootSignature,\n  ...\n  170          uint32_t&                       rootConstIndex)\n  171      {\n  172:         auto defaultConstantBufferInfo = pParameterBlockReflector->getDefaultConstantBufferBindingInfo();\n  173          if( defaultConstantBufferInfo.useRootConstants ) {\n  174              uint32_t rootIndex = rootConstIndex++;\n  175  \n  176:             bindRootConstants<forGraphics>(pContext, rootIndex, pParameterBlock, pParameterBlockReflector);\n  177          }\n  178  \n  179:         auto descriptorSetCount = pParameterBlockReflector->getDescriptorSetCount();\n  180          for(uint32_t s = 0; s < descriptorSetCount; ++s) {\n  181              auto pSet = pParameterBlock->getDescriptorSet(s);\n  ...\n  187  \n  188          // Iterate over parameter blocks to recursively bind their descriptor sets.\n  189:         auto parameterBlockRangeCount = pParameterBlockReflector->getParameterBlockSubObjectRangeCount();\n  190          for(uint32_t i = 0; i < parameterBlockRangeCount; ++i) {\n  191:             auto resourceRangeIndex = pParameterBlockReflector->getParameterBlockSubObjectRangeIndex(i);\n  192:             auto& resourceRange = pParameterBlockReflector->getResourceRange(resourceRangeIndex);\n  193:             auto& bindingInfo = pParameterBlockReflector->getResourceRangeBindingInfo(resourceRangeIndex);\n  194  \n  195:             auto pSubObjectReflector = bindingInfo.pSubObjectReflector;\n  196              auto objectCount = resourceRange.count;\n  197  \n  198              for(uint32_t i = 0; i < objectCount; ++i) {\n  199                  auto pSubBlock = pParameterBlock->getParameterBlock(resourceRangeIndex, i);\n  200:                 if(!bindParameterBlockSets<forGraphics>(pSubBlock.get(), pSubObjectReflector.get(), pContext, pRootSignature, bindRootSig, descSetIndex, rootConstIndex)) {\n  201                      return false;\n  202                  }\n  ...\n  210      bool bindParameterBlockRootDescs(\n  211          ParameterBlock*                 pParameterBlock,\n  212:         const ParameterBlockReflection* pParameterBlockReflector,\n  213          CopyContext*                    pContext,\n  214          RootSignature*                  pRootSignature,\n  ...\n  216          uint32_t&                       rootDescIndex)\n  217      {\n  218:         auto rootDescriptorRangeCount = pParameterBlockReflector->getRootDescriptorRangeCount();\n  219          \n  220          for (uint32_t i = 0; i < rootDescriptorRangeCount; ++i) {\n  221:             auto resourceRangeIndex = pParameterBlockReflector->getRootDescriptorRangeIndex(i);\n  222:             auto& resourceRange = pParameterBlockReflector->getResourceRange(resourceRangeIndex);\n  223  \n  224              assert(resourceRange.count == 1); // Root descriptors cannot be arrays\n  ...\n  229  \n  230          // Iterate over constant buffers and parameter blocks to recursively bind their root descriptors.\n  231:         uint32_t resourceRangeCount = pParameterBlockReflector->getResourceRangeCount();\n  232  \n  233          for (uint32_t resourceRangeIndex = 0; resourceRangeIndex < resourceRangeCount; ++resourceRangeIndex) {\n  234:             auto& resourceRange = pParameterBlockReflector->getResourceRange(resourceRangeIndex);\n  235:             auto& bindingInfo = pParameterBlockReflector->getResourceRangeBindingInfo(resourceRangeIndex);\n  236  \n  237              if (bindingInfo.flavor != ParameterBlockReflection::ResourceRangeBindingInfo::Flavor::ConstantBuffer &&\n  ...\n  239                  continue;\n  240  \n  241:             auto pSubObjectReflector = bindingInfo.pSubObjectReflector;\n  242              auto objectCount = resourceRange.count;\n  243  \n  244              for (uint32_t i = 0; i < objectCount; ++i) {\n  245                  auto pSubBlock = pParameterBlock->getParameterBlock(resourceRangeIndex, i);\n  246:                 if (!bindParameterBlockRootDescs<forGraphics>(pSubBlock.get(), pSubObjectReflector.get(), pContext, pRootSignature, bindRootSig, rootDescIndex)) {\n  247                      return false;\n  248                  }\n  ...\n  265          uint32_t rootConstIndex = pRootSignature->getRootConstantBaseIndex();\n  266  \n  267:         if (!bindParameterBlockSets<forGraphics>(pVars, pVars->getSpecializedReflector().get(), pContext, pRootSignature, bindRootSig, descSetIndex, rootConstIndex)) {\n  268              return false;\n  269          }\n  270  \n  271:         if (!bindParameterBlockRootDescs<forGraphics>(pVars, pVars->getSpecializedReflector().get(), pContext, pRootSignature, bindRootSig, rootDescIndex)) {\n  272              return false;\n  273          }\n  ...\n  293          collectSpecializationArgs(specializationArgs);\n  294          if( specializationArgs.size() == 0 ) {\n  295:             mpSpecializedReflector = ParameterBlock::mpReflector;\n  296              return false;\n  297          }\n  ...\n  300  \n  301          auto pProgramKernels = mpProgramVersion->getKernels(this);\n  302:         mpSpecializedReflector = pProgramKernels->getReflector()->getDefaultParameterBlock();\n  303          return false;\n  304      }\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramVars.h:\n   46  \n   47      /** Create a new entry point group vars object.\n   48:         \\param[in] pReflector The reflection object.\n   49          \\param[in] groupIndexInProgram Group index.\n   50          \\return New object, or throws an exception if creation failed.\n   51      */\n   52:     static SharedPtr create(std::shared_ptr<Device> pDevice, const EntryPointGroupReflection::SharedConstPtr& pReflector, uint32_t groupIndexInProgram) {\n   53:         assert(pReflector);\n   54:         return SharedPtr(new EntryPointGroupVars(pDevice, pReflector, groupIndexInProgram));\n   55      }\n   56  \n   ..\n   58  \n   59   protected:\n   60:     EntryPointGroupVars(std::shared_ptr<Device> pDevice, const EntryPointGroupReflection::SharedConstPtr& pReflector, uint32_t groupIndexInProgram)\n   61:         : ParameterBlock(pDevice, pReflector->getProgramVersion(), pReflector)\n   62          , mGroupIndexInProgram(groupIndexInProgram)\n   63      {\n   64:         assert(pReflector);\n   65      }\n   66  \n   ..\n   80      /** Get the program reflection interface\n   81      */\n   82:     const ProgramReflection::SharedConstPtr& getReflection() const { return mpReflector; }\n   83  \n   84      virtual bool updateSpecializationImpl() const override;\n   ..\n   91  \n   92   protected:\n   93:     ProgramVars(std::shared_ptr<Device> pDevice, const ProgramReflection::SharedConstPtr& pReflector);\n   94  \n   95:     ProgramReflection::SharedConstPtr mpReflector;\n   96  \n   97      void addSimpleEntryPointGroups();\n   98  \n   99:     std::vector<EntryPointGroupVars::SharedPtr> mpEntryPointGroupVars;\n  100  };\n  101  \n  ...\n  107  \n  108      /** Create a new graphics vars object.\n  109:         \\param[in] pReflector A program reflection object containing the requested declarations.\n  110          \\return A new object, or an exception is thrown if creation failed.\n  111      */\n  112:     static SharedPtr create(std::shared_ptr<Device> pDevice, const ProgramReflection::SharedConstPtr& pReflector);\n  113  \n  114      /** Create a new graphics vars object.\n  ...\n  121  \n  122   protected:\n  123:     GraphicsVars(std::shared_ptr<Device> pDevice, const ProgramReflection::SharedConstPtr& pReflector);\n  124  };\n  125  \n  ...\n  134  \n  135      /** Create a new compute vars object.\n  136:         \\param[in] pReflector A program reflection object containing the requested declarations.\n  137          \\return A new object, or an exception is thrown if creation failed.\n  138      */\n  139:     static SharedPtr create(std::shared_ptr<Device> pDevice, const ProgramReflection::SharedConstPtr& pReflector);\n  140  \n  141      /** Create a new compute vars object.\n  ...\n  148  \n  149   protected:\n  150:     ComputeVars(std::shared_ptr<Device> pDevice, const ProgramReflection::SharedConstPtr& pReflector);\n  151  };\n  152  \n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramVersion.cpp:\n   91          std::shared_ptr<Device> device, \n   92          const ProgramVersion* pVersion,\n   93:         const ProgramReflection::SharedPtr& pReflector,\n   94          const ProgramKernels::UniqueEntryPointGroups& uniqueEntryPointGroups,\n   95          const std::string& name)\n   96          : mName(name)\n   97:         , mpReflector(pReflector)\n   98          , mpVersion(pVersion)\n   99          , mUniqueEntryPointGroups(uniqueEntryPointGroups)\n  100          , mpDevice(device)\n  101      {\n  102:         mpRootSignature = RootSignature::create(device, pReflector.get());\n  103      }\n  104  \n  ...\n  106          std::shared_ptr<Device> pDevice, \n  107          const ProgramVersion* pVersion,\n  108:         const ProgramReflection::SharedPtr& pReflector,\n  109          const ProgramKernels::UniqueEntryPointGroups& uniqueEntryPointGroups,\n  110          std::string& log,\n  111          const std::string& name)\n  112      {\n  113:         SharedPtr pProgram = SharedPtr(new ProgramKernels(pDevice, pVersion, pReflector, uniqueEntryPointGroups, name));\n  114          return pProgram;\n  115      }\n  ...\n  140      void ProgramVersion::init(\n  141          const DefineList&                                   defineList,\n  142:         const ProgramReflection::SharedPtr&                 pReflector,\n  143          const std::string&                                  name,\n  144:         std::vector<ComPtr<slang::IComponentType>> const&   pSlangEntryPoints)\n  145      {\n  146:         assert(pReflector);\n  147          mDefines = defineList,\n  148:         mpReflector = pReflector;\n  149          mName = name;\n  150          mpSlangEntryPoints = pSlangEntryPoints;\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramVersion.h:\n   81          };\n   82  \n   83:         using Shaders = std::vector<Shader::SharedPtr>;\n   84  \n   85          static SharedPtr create(Type type, const Shaders& shaders);\n   ..\n  142          using SharedConstPtr = std::shared_ptr<const ProgramKernels>;\n  143  \n  144:         typedef std::vector<EntryPointGroupKernels::SharedPtr> UniqueEntryPointGroups;\n  145  \n  146          /** Create a new program object for graphics.\n  ...\n  158              std::shared_ptr<Device> pDevice, \n  159              const ProgramVersion* pVersion,\n  160:             const ProgramReflection::SharedPtr& pReflector,\n  161              const UniqueEntryPointGroups& uniqueEntryPointGroups,\n  162              std::string& log,\n  ...\n  175          /** Get the reflection object\n  176          */\n  177:         const ProgramReflection::SharedPtr& getReflector() const { return mpReflector; }\n  178  \n  179          RootSignature::SharedPtr const& getRootSignature() const { return mpRootSignature; }\n  ...\n  189              std::shared_ptr<Device> device, \n  190              const ProgramVersion* pVersion,\n  191:             const ProgramReflection::SharedPtr& pReflector,\n  192              const UniqueEntryPointGroups& uniqueEntryPointGroups,\n  193              const std::string& name = \"\");\n  ...\n  199  \n  200          void* mpPrivateData;\n  201:         const ProgramReflection::SharedPtr mpReflector;\n  202  \n  203          ProgramVersion const* mpVersion = nullptr;\n  ...\n  228              \\return A program reflection object.\n  229          */\n  230:         ProgramReflection::ConstSharedPtrRef getReflector() const { assert(mpReflector); return mpReflector; }\n  231  \n  232          /** Get executable kernels based on state in a `ProgramVars`\n  ...\n  248          void init(\n  249              const DefineList&                                   defineList,\n  250:             const ProgramReflection::SharedPtr&                 pReflector,\n  251              const std::string&                                  name,\n  252:             std::vector<ComPtr<slang::IComponentType>> const&   pSlangEntryPoints);\n  253  \n  254          std::shared_ptr<Program>        mpProgram;\n  255          DefineList                      mDefines;\n  256:         ProgramReflection::SharedPtr    mpReflector;\n  257          std::string                     mName;\n  258          ComPtr<slang::IComponentType>   mpSlangGlobalScope;\n  259:         std::vector<ComPtr<slang::IComponentType>> mpSlangEntryPoints;\n  260  \n  261          // Cached version of compiled kernels for this program version\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ShaderVar.h:\n   83      ShaderVar(std::nullptr_t) : ShaderVar() {};\n   84  \n   85:     /** Copy constructor.\n   86      */\n   87      ShaderVar(const ShaderVar& other);\n\n/home/max/dev/Falcor/src/Falcor/Core/Renderer.h:\n   47      bool suppressInput = false;              ///< Suppress all keyboard and mouse input (other than escape to terminate)\n   48      bool showMessageBoxOnError = true;       ///< Show message box on framework/API errors.\n   49:     float timeScale = 1.0f;                  ///< A scaling factor for the time elapsed between frames\n   50      bool pauseTime = false;                  ///< Control whether or not to start the clock when the sample start running\n   51      bool showUI = false;                     ///< Show the UI\n   ..\n   88      /** Takes and outputs a screenshot.\n   89      */\n   90:     virtual std::string captureScreen(const std::string explicitFilename = \"\", const std::string explicitOutputDirectory = \"\") = 0;\n   91  \n   92      /* Shutdown the app\n\n/home/max/dev/Falcor/src/Falcor/Core/Sample.cpp:\n  207              SampleConfig c;\n  208  \n  209:             if (findFileInDataDirectories(filename, fullpath)) {\n  210                  Scripting::Context ctx;\n  211                  Scripting::runScriptFromFile(fullpath, ctx);\n  ...\n  495      }\n  496  \n  497:     std::string Sample::captureScreen(const std::string explicitFilename, const std::string explicitOutputDirectory) {\n  498          mCaptureScreen = false;\n  499  \n  500          std::string filename = explicitFilename != \"\" ? explicitFilename : getExecutableName();\n  501:         std::string outputDirectory = explicitOutputDirectory != \"\" ? explicitOutputDirectory : getExecutableDirectory();\n  502  \n  503          std::string pngFile;\n  504:         if (findAvailableFilename(filename, outputDirectory, \"png\", pngFile)) {\n  505              Texture::SharedPtr pTexture;\n  506              pTexture = mpDevice->getSwapChainFbo()->getColorTexture(0);\n  ...\n  517          std::cout << \"UI\";\n  518          LOG_DBG(\"Sample::initUI\");\n  519:         float scaling = getDisplayScaleFactor();\n  520          const auto& pSwapChainFbo = mpDevice->getSwapChainFbo();\n  521          mpGui = Gui::create(mpDevice, uint32_t(pSwapChainFbo->getWidth()), uint32_t(pSwapChainFbo->getHeight()), scaling);\n\n/home/max/dev/Falcor/src/Falcor/Core/Sample.h:\n   31  #include <set>\n   32  #include <optional>\n   33: #include <vector>\n   34  #include <utility>\n   35  #include <string>\n   ..\n   94      void pauseRenderer(bool pause) override { mRendererPaused = pause; }\n   95      bool isRendererPaused() override { return mRendererPaused; }\n   96:     std::string captureScreen(const std::string explicitFilename = \"\", const std::string explicitOutputDirectory = \"\") override;\n   97      void shutdown() override { if (mpWindow) { mpWindow->shutdown(); } }\n   98      SampleConfig getConfig() override;\n   ..\n  145          VideoEncoderUI::UniquePtr pUI;\n  146          VideoEncoder::UniquePtr pVideoCapture;\n  147:         std::vector<uint8_t> pFrame;\n  148          double fixedTimeDelta = 0;\n  149          double currentTime = 0;\n\n/home/max/dev/Falcor/src/Falcor/Core/State/ComputeState.h:\n   53      static SharedPtr create(std::shared_ptr<Device> device) { return SharedPtr(new ComputeState(device)); }\n   54  \n   55:     /** Copy constructor. Useful if you need to make minor changes to an already existing object\n   56      */\n   57      SharedPtr operator=(const SharedPtr& other);\n\n/home/max/dev/Falcor/src/Falcor/Core/State/GraphicsState.h:\n   86      static SharedPtr create(std::shared_ptr<Device> device) { return SharedPtr(new GraphicsState(device)); }\n   87  \n   88:     /** Copy constructor. Useful if you need to make minor changes to an already existing object\n   89      */\n   90      SharedPtr operator=(const SharedPtr& other);\n   ..\n  142      /** Get the array of all the current viewports.\n  143      */\n  144:     const std::vector<Viewport>& getViewports() const { return mViewports; }\n  145  \n  146      /** Push the current viewport and sets a new one\n  ...\n  170      /** Get the array of all the current scissors.\n  171      */\n  172:     const std::vector<Scissor>& getScissors() const { return mScissors; }\n  173  \n  174      /** Push a current Scissor and sets a new one\n  ...\n  240      GraphicsStateObject::Desc mDesc;\n  241      uint8_t mStencilRef = 0;\n  242:     std::vector<Viewport> mViewports;\n  243:     std::vector<Scissor> mScissors;\n  244  \n  245      std::stack<Fbo::SharedPtr> mFboStack;\n  246:     std::vector<std::stack<Viewport>> mVpStack;\n  247:     std::vector<std::stack<Scissor>> mScStack;\n  248  \n  249      std::shared_ptr<Device> mpDevice;\n\n/home/max/dev/Falcor/src/Falcor/Core/State/StateGraph.h:\n  111      };\n  112  \n  113:     std::vector<Node> mGraph;\n  114      uint32_t mCurrentNode = 0;\n  115  };\n\n/home/max/dev/Falcor/src/Falcor/Core/Window.h:\n   81      static SharedPtr create(const Desc& desc, ICallbacks* pCallbacks);\n   82  \n   83:     /** Destructor\n   84      */\n   85      ~Window();\n\n/home/max/dev/Falcor/src/Falcor/Data/Framework/Textures/NextFrame.jpg:\n    <binary>\n\n/home/max/dev/Falcor/src/Falcor/Data/Framework/Textures/Pause.jpg:\n    <binary>\n\n/home/max/dev/Falcor/src/Falcor/Data/Framework/Textures/Play.jpg:\n    <binary>\n\n/home/max/dev/Falcor/src/Falcor/Data/Framework/Textures/PrevFrame.jpg:\n    <binary>\n\n/home/max/dev/Falcor/src/Falcor/Data/Framework/Textures/Rewind.jpg:\n    <binary>\n\n/home/max/dev/Falcor/src/Falcor/Data/Framework/Textures/Stop.jpg:\n    <binary>\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/EmissiveLightSamplerHelpers.slang:\n   62      ls.posW = gScene.lightCollection.getPosition(triangleIndex, barycentrics);\n   63  \n   64:     // Compute light vector and squared distance.\n   65:     float3 toLight = ls.posW - posW; // Unnormalized light vector\n   66      const float distSqr = max(FLT_MIN, dot(toLight, toLight)); // Clamp to avoid NaNs below\n   67      ls.distance = sqrt(distSqr);\n   ..\n  100  float evalTrianglePdf(const float3 posW, const TriangleHit hit)\n  101  {\n  102:     // Compute light vector and squared distance.\n  103:     float3 toLight = hit.posW - posW; // Unnormalized light vector\n  104      const float distSqr = dot(toLight, toLight);\n  105      if (distSqr <= FLT_MIN) return 0.f; // Avoid NaNs below\n  106      float3 L = toLight / sqrt(distSqr);\n  107  \n  108:     // Cosine of angle between the light's normal and the light vector (flip L since it points towards the light).\n  109      float cosTheta = dot(hit.normalW, -L);\n  110      if (cosTheta <= 0.f) return 0.f;\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/FinalizeIntegration.cs.slang:\n   67          averageEmissiveColor = weight > 0.f ? texelSum.rgb / weight : float3(1.0f);\n   68      }\n   69:     float3 averageRadiance = averageEmissiveColor * materialData.emissiveFactor;\n   70  \n   71      // Pre-compute the luminous flux emitted, which is what we use during sampling to set probabilities.\n   72:     // We assume diffuse emitters and integrate per side (hemisphere) => the scale factor is pi.\n   73      float area = gTriangleData[triIdx].area;                        // Triangle area in m^2 (the scene units are assumed to be in meters).\n   74      float flux = luminance(averageRadiance) * area * (float) M_PI;  // Flux in lumens.\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVH.cpp:\n  263          });\n  264  \n  265:         std::vector<uint32_t> perDepthOffset(mPerDepthRefitEntryInfo.size(), 0u);\n  266          for (std::size_t i = 1; i < mPerDepthRefitEntryInfo.size(); ++i)\n  267          {\n  ...\n  307      }\n  308  \n  309:     void LightBVH::uploadCPUBuffers(const std::vector<uint64_t>& triangleBitmasks) {\n  310          const uint32_t bvhByteSize = static_cast<uint32_t>(mAlignedAllocator.getSize());\n  311  \n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVH.h:\n   34  #include \"Utils/AlignedAllocator.h\"\n   35  #include \"Utils/Math/BBox.h\"\n   36: #include \"Utils/Math/Vector.h\"\n   37  #include \"Utils/UI/Gui.h\"\n   38  \n   ..\n   40  \n   41  #include <limits>\n   42: #include <vector>\n   43  \n   44  namespace Falcor {\n   ..\n  161  \n  162          struct BVHStats {\n  163:             std::vector<uint32_t> nodeCountPerLevel;         ///< For each level in the tree, how many nodes are there.\n  164:             std::vector<uint32_t> leafCountPerTriangleCount; ///< For each amount of triangles, how many leaf nodes contain that many triangles.\n  165  \n  166              uint32_t treeHeight = 0;                         ///< Number of edges on the longest path between the root node and a leaf.\n  ...\n  203          void renderStats(Gui::Widgets& widget, const BVHStats& stats) const;\n  204  \n  205:         void uploadCPUBuffers(const std::vector<uint64_t>& triangleBitmasks);\n  206          void syncDataToCPU() const;\n  207  \n  ...\n  235          // CPU resources\n  236          mutable AlignedAllocator              mAlignedAllocator;        ///< Utility class for the CPU-side node buffer.\n  237:         std::vector<uint32_t>                 mNodeOffsets;\n  238:         std::vector<RefitEntryInfo>           mPerDepthRefitEntryInfo;  ///< Array containing for each level the number of internal nodes as well as the corresponding offset in mpNodeOffsetsBuffer; the very last entry contains the same data, but for all leaf nodes instead.\n  239          uint32_t                              mMaxTriangleCountPerLeaf = 0u; ///< After the BVH is built, this contains the maximum light count per leaf node.\n  240          BVHStats                              mBVHStats;\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVHBuilder.cpp:\n   75      }\n   76  \n   77:     /** Given two cones specified by direction vectors and the cosine of\n   78          their spread angles, returns a cone that bounds both of them. This\n   79          is what was used previously; the cones it returns aren't as tight as\n   ..\n   95      }\n   96  \n   97:     /** Given two cones specified by direction vectors and the cosine of\n   98          their spread angles, returns a cone that bounds both of\n   99          them. Algorithm 1 in the 2018 Sony EGSR light sampling paper.\n  ...\n  135          float3 dir;\n  136          if (glm::dot(rDir, rDir) < 1e-8) {\n  137:             // The two vectors are effectively pointing in opposite directions.\n  138  \n  139:             // Find some vector that's orthogonal to one of them (via\n  140              // \"Building and Orthonormal Basis, Revisited\" in jcgt.)\n  141              const float sign = aDir.z > 0 ? 1.f : -1.f;\n  ...\n  146              // bDir, then aTheta / 2 more on top of that. (Recall that\n  147              // aTheta > bTheta, so we don't need to worry about bTheta).\n  148:             // Note that we could rotate dir around the vector cross(dir,\n  149              // aTheta) and then be able to use the tighter spread angle\n  150              // oTheta computed before, but it probably doesn't matter much\n  ...\n  163          auto checkInside = [&](float3 d, float theta) {\n  164                                 // Make sure that sum of the angle between\n  165:                                // the two cone vectors and the spread angle\n  166                                 // of the given cone is still within the\n  167                                 // extent of the result cone.\n  ...\n  472  \n  473          assert(parameters.binCount > 1);\n  474:         std::vector<Bin> bins(parameters.binCount);\n  475:         std::vector<float> costs(parameters.binCount - 1u);\n  476  \n  477          /** Helper function that computes the best split along the given dimension using the SAH metric.\n  ...\n  500  \n  501              // First, compute A_j(L) * N_j(L) by sweeping over the bins from left to right.\n  502:             // Note that the costs vector has n-1 elements when there are n bins; the i:th elements represents the split between bin i and i+1.\n  503              Bin total = Bin();\n  504              for (std::size_t i = 0u; i < costs.size(); ++i) {\n  ...\n  619  \n  620          assert(parameters.binCount > 1);\n  621:         std::vector<Bin> bins(parameters.binCount);\n  622:         std::vector<float> costs(parameters.binCount - 1u);\n  623  \n  624          /** Helper function that computes the best split along the given dimension using the SAOH metric.\n  ...\n  652              // Compute the lighting cones for each bin.\n  653              // The cone direction is the average direction over all lights in the bin and the cone angle is grown to include all.\n  654:             // If the vector is zero length (no lights or if all directions cancelled out), the cone is marked as invalid.\n  655              // TODO: Switch to a more sophisticated algorithm to get narrower cones.\n  656              for (Bin& bin : bins) {\n  ...\n  665  \n  666              // First, compute A_j(L) * N_j(L) by sweeping over the bins from left to right.\n  667:             // Note that the costs vector has n-1 elements when there are n bins; the i:th elements represents the split between bin i and i+1.\n  668              Bin total = Bin();\n  669              for (std::size_t i = 0u; i < costs.size(); ++i) {\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVHBuilder.h:\n   31  #include \"Utils/AlignedAllocator.h\"\n   32  #include \"Utils/Math/BBox.h\"\n   33: #include \"Utils/Math/Vector.h\"\n   34  #include \"Utils/UI/Gui.h\"\n   35  \n   36  #include <limits>\n   37: #include <vector>\n   38  \n   39  namespace Falcor {\n   ..\n  118          struct BuildingData {\n  119              AlignedAllocator& alignedAllocator;                                 ///< Allocator used for allocating the BVH nodes.\n  120:             std::vector<TriangleSortData> trianglesData;                        ///< Compact list of triangles to include in build.\n  121:             std::vector<uint64_t> triangleBitmasks;                             ///< Array containing the per triangle bit pattern retracing the tree traversal to reach the triangle: 0=left child, 1=right child; this array gets filled in during the build process. Indexed by global triangle index.\n  122              float currentNodeFlux = 0.f;                                        ///< Used by computeSAOHSplit() as the leaf creation cost.\n  123  \n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVHSampler.slang:\n  194  \n  195          const float3 L = normalize(center - origin);\n  196:         const float cosThetaL = clamp(dot(normalW, L), -1.f, 1.f);    // Cosine of the angle between normal and vector to AABB center.\n  197          const float sinThetaL = sqrt(max(0.f, 1.f - cosThetaL * cosThetaL));\n  198          // cos(max(0, thetaL - thetaCone)): conservative minimum angle between normal and AABB.\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightCollection.cpp:\n   61          // Update transform matrices and check for updates.\n   62          // TODO: Move per-mesh instance update flags into Scene. Return just a list of mesh lights that have changed.\n   63:         std::vector<uint32_t> updatedLights;\n   64          updatedLights.reserve(mMeshLights.size());\n   65  \n   ..\n  146  \n  147          std::string s;\n  148:         if (findFileInShaderDirectories(\"NVAPI/nvHLSLExtns.h\", s) == false) {\n  149              logError(\"LightCollection relies on NVAPI, which appears to be missing. Please make sure you have NVAPI installed (instructions are in the readme file)\");\n  150              return false;\n  ...\n  292          uint32_t instanceCount = mpScene->getMeshInstanceCount();\n  293          assert(instanceCount > 0);\n  294:         std::vector<uint32_t> triangleOffsets(instanceCount, kInvalidIndex);\n  295          for (const auto& it : mMeshLights) {\n  296              assert(it.meshInstanceID < instanceCount);\n  ...\n  430      }\n  431  \n  432:     void LightCollection::updateTrianglePositions(RenderContext* pRenderContext, const std::vector<uint32_t>& updatedLights) {\n  433          // This pass pre-transforms all emissive triangles into world space and updates their area and face normals.\n  434          // It is executed if any geometry in the scene has moved, which is wasteful since it will update also things\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightCollection.h:\n   61  \n   62      struct UpdateStatus {\n   63:         std::vector<UpdateFlags> lightsUpdateInfo;\n   64      };\n   65  \n   ..\n  152          Call prepareSyncCPUData() ahead of time to avoid stalling the GPU.\n  153      */\n  154:     const std::vector<MeshLightTriangle>& getMeshLightTriangles() const { syncCPUData(); return mMeshLightTriangles; }\n  155  \n  156      /** Returns a CPU buffer with all mesh lights.\n  157          Note that update() must have been called before for the data to be valid.\n  158      */\n  159:     const std::vector<MeshLightData>& getMeshLights() const { return mMeshLights; }\n  160  \n  161      /** Prepare for syncing the CPU data.\n  ...\n  190      void computeStats() const;\n  191      void buildTriangleList(RenderContext* pRenderContext);\n  192:     void updateTrianglePositions(RenderContext* pRenderContext, const std::vector<uint32_t>& updatedLights);\n  193  \n  194      void copyDataToStagingBuffer(RenderContext* pRenderContext) const;\n  ...\n  198      std::shared_ptr<Scene>                  mpScene;\n  199  \n  200:     std::vector<MeshLightData>              mMeshLights;            ///< List of all mesh lights.\n  201      uint32_t                                mTriangleCount = 0;     ///< Total number of triangles in all mesh lights (= mMeshLightTriangles.size()). This may include culled triangles.\n  202  \n  203:     mutable std::vector<MeshLightTriangle>  mMeshLightTriangles;    ///< List of all pre-processed mesh light triangles.\n  204      mutable MeshLightStats                  mMeshLightStats;        ///< Stats before/after pre-processing of mesh lights. Do not access this directly, use getStats() which ensures the stats are up-to-date.\n  205      mutable bool                            mStatsValid = false;    ///< True when stats are valid.\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Material/BxDF.slang:\n   65  static const float kMinGGXAlpha = 1e-3f;\n   66  \n   67: // Minimum cos(theta) for the view and light vectors.\n   68  // A few functions are not robust for cos(theta) == 0.0.\n   69  // TODO: Derive appropriate bounds\n   ..\n  186  \n  187  /** Frostbites's diffuse reflection.\n  188:     This is Disney's diffuse BRDF with an ad-hoc normalization factor to ensure energy conservation.\n  189      Based on https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n  190  */\n  ...\n  226          float wiDotH = dot(wi, h);\n  227          float energyBias = lerp(0, 0.5, linearRoughness);\n  228:         float energyFactor = lerp(1, 1.0 / 1.51, linearRoughness);\n  229          float fd90 = energyBias + 2 * wiDotH * wiDotH * linearRoughness;\n  230          float fd0 = 1;\n  231          float wiScatter = evalFresnelSchlick(fd0, fd90, wi.z).r;\n  232          float woScatter = evalFresnelSchlick(fd0, fd90, wo.z).r;\n  233:         return albedo * wiScatter * woScatter * energyFactor;\n  234      }\n  235  };\n  ...\n  263          if (wo.z <= kMinCosTheta) return false;\n  264  \n  265:         // Sample the GGX distribution to find a microfacet normal (half vector).\n  266  #if EnableVNDFSampling\n  267          float3 h = sampleGGX_VNDF(alpha, wo, sampleNext2D(sg), pdf);    // pdf = G1(wo) * D(h) * max(0,dot(wo,h)) / wo.z\n  ...\n  362          if (wo.z <= kMinCosTheta) return false;\n  363  \n  364:         // Sample the GGX distribution of (visible) normals. This is our half vector.\n  365  #if EnableVNDFSampling\n  366          float3 h = sampleGGX_VNDF(alpha, wo, sampleNext2D(sg), pdf);    // pdf = G1(wo) * D(h) * max(0,dot(wo,h)) / wo.z\n  ...\n  508          pSpecularReflectionTransmission = specularBSDF;\n  509  \n  510:         float normFactor = pDiffuseReflection + pSpecularReflection + pSpecularReflectionTransmission;\n  511:         if (normFactor > 0)\n  512          {\n  513:             normFactor = 1 / normFactor;\n  514:             pDiffuseReflection *= normFactor;\n  515:             pSpecularReflection *= normFactor;\n  516:             pSpecularReflectionTransmission *= normFactor;\n  517          }\n  518          else\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Material/MaterialHelpers.slang:\n   92  \n   93  /** Helper function for preparing a GeometryParams struct based on the local geometry.\n   94:     Note that the input vectors must not be (0,0,0) as the normalizations would cause NaNs.\n   95      \\param[in] worldPos World space position.\n   96      \\param[in] viewDir View direction (unnormalized).\n   ..\n  169  }\n  170  \n  171: /** Helper function to transform vector v from the local surface frame to world space.\n  172  */\n  173  float3 fromLocal(float3 v, ShadingData sd)\n  ...\n  176  }\n  177  \n  178: /** Helper function to transform vector v from the local surface frame to world space.\n  179  */\n  180  float3 fromLocal(float3 v, GeometryParams sd)\n  ...\n  183  }\n  184  \n  185: /** Helper function to transform world space vector v to the local surface frame.\n  186  */\n  187  float3 toLocal(float3 v, ShadingData sd)\n  ...\n  190  }\n  191  \n  192: /** Helper function to transform world space vector v to the local surface frame.\n  193  */\n  194  float3 toLocal(float3 v, GeometryParams sd)\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Material/MaterialShading.slang:\n  182      \\param[in] NdotL Dot product between shading normal and incident direction, in positive hemisphere.\n  183      \\param[in] NdotV Dot product between shading normal and outgoing direction, in positive hemisphere.\n  184:     \\param[in] LdotH Dot product between half vector and incident direction, in positive hemisphere.\n  185      \\return f_d\n  186  */\n  ...\n  195  \n  196  /** Frostbites's diffuse term.\n  197:     This is Disney's diffuse BRDF with an ad-hoc normalization factor to ensure energy conservation.\n  198      Based on https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n  199  \n  ...\n  201      \\param[in] NdotL Dot product between shading normal and incident direction, in positive hemisphere.\n  202      \\param[in] NdotV Dot product between shading normal and outgoing direction, in positive hemisphere.\n  203:     \\param[in] LdotH Dot product between half vector and incident direction, in positive hemisphere.\n  204      \\return f_d\n  205  */\n  ...\n  207  {\n  208      float energyBias = lerp(0, 0.5, sd.linearRoughness);\n  209:     float energyFactor = lerp(1, 1.0 / 1.51, sd.linearRoughness);\n  210      float fd90 = energyBias + 2 * LdotH * LdotH * sd.linearRoughness;\n  211      float fd0 = 1;\n  212      float lightScatter = evalFresnelSchlick(fd0, fd90, NdotL).r;\n  213      float viewScatter = evalFresnelSchlick(fd0, fd90, NdotV).r;\n  214:     return sd.diffuse.rgb * (viewScatter * lightScatter * energyFactor * (1 / M_PI));\n  215  }\n  216  \n  ...\n  220      \\param[in] NdotL Dot product between shading normal and incident direction, in positive hemisphere.\n  221      \\param[in] NdotV Dot product between shading normal and outgoing direction, in positive hemisphere.\n  222:     \\param[in] LdotH Dot product between half vector and incident direction, in positive hemisphere.\n  223      \\return f_d\n  224  */\n  ...\n  278      \\param[in] NdotL Dot product between shading normal and incident direction, in positive hemisphere.\n  279      \\param[in] NdotV Dot product between shading normal and outgoing direction, in positive hemisphere.\n  280:     \\param[in] NdotH Dot product between shading normal and half vector, in positive hemisphere.\n  281:     \\param[in] LdotH Dot product between half vector and incident direction, in positive hemisphere.\n  282      \\return f_r\n  283  */\n  ...\n  292  #endif\n  293      float3 F = evalFresnelSchlick(sd.specular, 1, LdotH);\n  294:     return D * G * F;   // Note: G already includes 1/(4*NdotL*NdotV) factor.\n  295  }\n  296  \n  ...\n  309      if (min(sd.NdotV, NdotL) < kMinCosTheta) return float3(0, 0, 0);\n  310  \n  311:     // Pre-compute half vector and dot products.\n  312      // TODO: Using saturate() here to be sure all dot products are within bounds.\n  313      // Some can be replaced by clamps on the upper end only (since we check NdotV and NdotL above) or removed altogether.\n  ...\n  377      float phiH = u.y * M_2PI;\n  378  \n  379:     // Convert half vector to world space.\n  380      float3 H = float3(sinThetaH * cos(phiH), sinThetaH * sin(phiH), cosThetaH);\n  381      H = fromLocal(H, sd);\n  ...\n  388  \n  389      // Evaluate the pdf.\n  390:     // The pdf in half vector space is pdf = D(H) * NdotH, which we multiply by the Jacobian of the half-vector transform.\n  391      float d = (a2 - 1) * cosThetaHSqr + 1;\n  392      pdf = (a2 * NdotH) / (d * d * VdotH * M_4PI);\n  ...\n  487      }\n  488  \n  489:     // Pre-compute half vector and dot products.\n  490      // TODO: Look into necessary conditions for numerical robustness below.\n  491      float NdotV = saturate(sd.NdotV);\n  ...\n  496      // Compute weight. Note that D cancels out by the pdf.\n  497  #if SpecularMaskingFunction == SpecularMaskingFunctionSmithGGXSeparable\n  498:     float G = evalMaskingSmithGGXSeparable_PreDivided(alpha, NdotL, NdotV); // Note: G already includes 1/(4*NdotL*NdotV) factor.\n  499  #elif SpecularMaskingFunction == SpecularMaskingFunctionSmithGGXCorrelated\n  500      float G = evalMaskingSmithGGXCorrelated_PreDivided(alpha, NdotL, NdotV);\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Material/Microfacet.slang:\n   31  \n   32      Introduced by Trowbridge and Reitz, \"Average irregularity representation of a rough surface for ray reflection\", Journal of the Optical Society of America, vol. 65(5), 1975.\n   33:     See the correct normalization factor in Walter et al. https://dl.acm.org/citation.cfm?id=2383874\n   34      We use the simpler, but equivalent expression in Eqn 19 from http://blog.selfshadow.com/publications/s2012-shading-course/hoffman/s2012_pbs_physics_math_notes.pdf\n   35  \n   ..\n   39  \n   40      \\param[in] alpha GGX width parameter (should be clamped to small epsilon beforehand).\n   41:     \\param[in] cosTheta Dot product between shading normal and half vector, in positive hemisphere.\n   42      \\return D(h)\n   43  */\n   ..\n   53  \n   54      \\param[in] alpha GGX width parameter (should be clamped to small epsilon beforehand).\n   55:     \\param[in] cosTheta Dot product between shading normal and half vector, in positive hemisphere.\n   56      \\return D(h) * cosTheta\n   57  */\n   ..\n   62  \n   63  /** Samples the GGX (Trowbridge-Reitz) normal distribution function (D) using Walter et al. 2007's method.\n   64:     Note that the sampled half vector may lie in the negative hemisphere. Such samples should be discarded.\n   65      See Eqn 35 & 36 in https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n   66      See Listing A.1 in https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n   ..\n   69      \\param[in] u Uniform random number (2D).\n   70      \\param[out] pdf Sampling probability.\n   71:     \\return Sampled half vector in local space.\n   72  */\n   73  float3 sampleGGX_NDF(float alpha, float2 u, out float pdf)\n   ..\n   88      \\param[in] alpha GGX width parameter (should be clamped to small epsilon beforehand).\n   89      \\param[in] wo View direction in local space, in the positive hemisphere.\n   90:     \\param[in] h Half vector in local space, in the positive hemisphere.\n   91      \\return D_V(h) = G1(wo) * D(h) * max(0,dot(wo,h)) / wo.z\n   92  */\n   ..\n  106      \\param[in] u Uniform random number (2D).\n  107      \\param[out] pdf Sampling probability.\n  108:     \\return Sampled half vector in local space, in the positive hemisphere.\n  109  */\n  110  float3 sampleGGX_VNDF(float alpha, float3 wo, float2 u, out float pdf)\n  ...\n  112      float alpha_x = alpha, alpha_y = alpha;\n  113  \n  114:     // Transform the view vector to the hemisphere configuration.\n  115      float3 Vh = normalize(float3(alpha_x * wo.x, alpha_y * wo.y, wo.z));\n  116  \n  ...\n  130      float3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0.f, 1.f - t1 * t1 - t2 * t2)) * Vh;\n  131  \n  132:     // Transform the normal back to the ellipsoid configuration. This is our half vector.\n  133      float3 h = normalize(float3(alpha_x * Nh.x, alpha_y * Nh.y, max(0.f, Nh.z)));\n  134  \n  ...\n  140      See Eq 34 in https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n  141  \n  142:     The evaluated direction is assumed to be in the positive hemisphere relative the half vector.\n  143      This is the case when both incident and outgoing direction are in the same hemisphere, but care should be taken with transmission.\n  144  \n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Material/TexLODHelpers.slang:\n  167      \\param[in] positionW Position of the hit point in world space.\n  168      \\param[in] normalW Normal of the hit point in world space.\n  169:     \\param[in] betaFactorK1 Optional factor, default value = 1. See Ray Tracing Gems, chapter 20.\n  170:     \\param[in] betaFactorK2 Optional factor, default value = 0. See Ray Tracing Gems, chapter 20.\n  171      \\return Spread angle at hit point.\n  172  */\n  173: float computeScreenSpaceSurfaceSpreadAngle(in float3 positionW, in float3 normalW, in float betaFactorK1 = 1.0, in float betaFactorK2 = 0.0)\n  174  {\n  175      float3 dNdx = ddx(normalW);\n  ...\n  180     float beta = sqrt(dot(dNdx, dNdx) + dot(dNdy, dNdy)) * sign(dot(dNdx, dPdx) + dot(dNdy, dPdy));\n  181  \n  182:     return 2.0 * beta * betaFactorK1 + betaFactorK2;\n  183  }\n  184  \n  ...\n  248  /** Computes the ray direction differential under the assumption that getCameraRayDir() is as commented out just above.\n  249      \\param[in] nonNormalizedCameraRaydir Non-normalized camera ray direction.\n  250:     \\param[in] cameraRight Camera right vector.\n  251:     \\param[in] cameraUp Camera up vector.\n  252      \\param[in] viewportDims Dimensions of the viewport.\n  253      \\param[out] dDdx The differential ray direction in x.\n\n/home/max/dev/Falcor/src/Falcor/Falcor.props:\n   15        <WarningLevel>Level3</WarningLevel>\n   16        <TreatWarningAsError>true</TreatWarningAsError>\n   17:       <AdditionalIncludeDirectories>$(FALCOR_CORE_DIRECTORY)\\Falcor;$(FALCOR_CORE_DIRECTORY)\\Externals\\.packman\\nvapi;$(FALCOR_CORE_DIRECTORY)\\Externals\\.packman\\GLM;$(FALCOR_CORE_DIRECTORY)\\Externals\\.packman\\VulkanSDK\\Include;$(FALCOR_CORE_DIRECTORY)\\Externals\\.packman\\RapidJson\\include;$(FALCOR_CORE_DIRECTORY)\\Externals\\.packman\\pybind11\\include;$(FALCOR_CORE_DIRECTORY)\\Externals\\.packman\\Python\\include;$(FALCOR_CORE_DIRECTORY)\\Externals\\.packman\\WinPixEventRuntime\\Include\\WinPixEventRuntime;$(FALCOR_CORE_DIRECTORY)\\Externals;$(FALCOR_CORE_DIRECTORY)\\Externals\\.packman;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n   18        <PreprocessorDefinitions>_$(OutputType);_CRT_SECURE_NO_WARNINGS;_SCL_SECURE_NO_WARNINGS;GLM_FORCE_DEPTH_ZERO_TO_ONE;$(FALCOR_BACKEND);_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n   19        <LanguageStandard>stdcpp17</LanguageStandard>\n   20      </ClCompile>\n   21      <Link>\n   22:       <AdditionalLibraryDirectories>$(FALCOR_CORE_DIRECTORY)\\Externals\\.packman\\FreeImage;$(FALCOR_CORE_DIRECTORY)\\Externals\\.packman\\Assimp\\lib\\$(PlatformName);$(FALCOR_CORE_DIRECTORY)\\Externals\\.packman\\FFMpeg\\lib\\$(PlatformName);$(FALCOR_CORE_DIRECTORY)\\Externals\\.packman\\nvapi\\amd64;$(FALCOR_CORE_DIRECTORY)\\Externals\\.packman\\VulkanSDK\\Lib;$(FALCOR_CORE_DIRECTORY)\\Externals\\.packman\\Slang\\bin\\windows-x64\\release;$(FALCOR_CORE_DIRECTORY)\\Externals\\.packman\\GLFW\\lib;$(FALCOR_CORE_DIRECTORY)\\Externals\\.packman\\Python\\libs;$(FALCOR_CORE_DIRECTORY)\\Externals\\.packman\\WinPixEventRuntime\\bin\\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>\n   23        <AdditionalDependencies>WinPixEventRuntime.lib;glfw3dll.lib;slang.lib;Comctl32.lib;Shlwapi.lib;assimp-vc141-mt.lib;freeimage.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;avcodec.lib;avutil.lib;avformat.lib;swscale.lib;Shcore.lib;%(AdditionalDependencies)</AdditionalDependencies>\n   24      </Link>\n\n/home/max/dev/Falcor/src/Falcor/Falcor.vcxproj:\n  252      <ShaderSource Include=\"Utils\\Debug\\ReflectPixelDebugTypes.cs.slang\" />\n  253      <ShaderSource Include=\"Utils\\Helpers.slang\" />\n  254:     <ClInclude Include=\"Utils\\Math\\Vector.h\" />\n  255      <ClInclude Include=\"Utils\\Perception\\Experiment.h\" />\n  256      <ClInclude Include=\"Utils\\Perception\\SingleThresholdMeasurement.h\" />\n  ...\n  778        <Optimization>Disabled</Optimization>\n  779        <PreprocessorDefinitions>FALCOR_DLL;IMGUI_API=__declspec(dllexport);_PROJECT_DIR_=R\"($(ProjectDir))\";_SCL_SECURE_NO_WARNINGS;_CRT_SECURE_NO_WARNINGS;FALCOR_D3D12;WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions);GLM_FORCE_DEPTH_ZERO_TO_ONE;_$(OutputType)</PreprocessorDefinitions>\n  780:       <AdditionalIncludeDirectories>$(ProjectDir);$(ProjectDir)\\..\\Externals\\.packman\\GLM;$(ProjectDir)\\..\\Externals\\.packman\\GLFW\\include;$(ProjectDir)\\..\\Externals\\.packman\\FreeImage;$(ProjectDir)\\..\\Externals\\.packman\\ASSIMP\\include;$(ProjectDir)\\..\\Externals\\.packman\\FFMpeg\\include;$(ProjectDir)\\..\\Externals\\.packman\\RapidJson\\include;$(ProjectDir)\\..\\Externals\\.packman\\VulkanSDK\\Include;$(ProjectDir)\\..\\Externals\\.packman\\Python\\Include;$(ProjectDir)\\..\\Externals\\.packman\\pybind11\\include;$(ProjectDir)\\..\\Externals\\;$(ProjectDir)\\..\\Externals\\.packman\\nvapi;$(ProjectDir)\\..\\Externals\\.packman</AdditionalIncludeDirectories>\n  781        <TreatWarningAsError>true</TreatWarningAsError>\n  782        <MultiProcessorCompilation>true</MultiProcessorCompilation>\n  ...\n  789        <SubSystem>Windows</SubSystem>\n  790        <GenerateDebugInformation>true</GenerateDebugInformation>\n  791:       <AdditionalLibraryDirectories>$(ProjectDir)..\\Externals\\.packman\\FreeImage;$(ProjectDir)..\\Externals\\.packman\\Assimp\\lib\\$(PlatformName)\\;$(ProjectDir)..\\Externals\\.packman\\FFMpeg\\lib\\$(PlatformName);$(ProjectDir)..\\Externals\\.packman\\openvr\\lib\\win64;$(ProjectDir)..\\Externals\\.packman\\nvapi\\amd64;$(ProjectDir)..\\Externals\\.packman\\VulkanSDK\\Lib;$(ProjectDir)..\\Externals\\.packman\\Slang\\bin\\windows-x64\\release;$(ProjectDir)..\\Externals\\.packman\\GLFW\\lib;$(ProjectDir)..\\Externals\\.packman\\Python\\libs;$(ProjectDir)..\\Externals\\.packman\\WinPixEventRuntime\\bin\\x64</AdditionalLibraryDirectories>\n  792        <AdditionalDependencies>WinPixEventRuntime.lib;glfw3dll.lib;slang.lib;Comctl32.lib;Shlwapi.lib;assimp-vc141-mt.lib;freeimage.lib;avcodec.lib;avutil.lib;avformat.lib;swscale.lib;Shcore.lib;%(AdditionalDependencies)</AdditionalDependencies>\n  793      </Link>\n  ...\n  816        <Optimization>Disabled</Optimization>\n  817        <PreprocessorDefinitions>FALCOR_DLL;IMGUI_API=__declspec(dllexport);_PROJECT_DIR_=R\"($(ProjectDir))\";_SCL_SECURE_NO_WARNINGS;_CRT_SECURE_NO_WARNINGS;FALCOR_VK;WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions);GLM_FORCE_DEPTH_ZERO_TO_ONE</PreprocessorDefinitions>\n  818:       <AdditionalIncludeDirectories>$(ProjectDir);$(ProjectDir)\\..\\Externals\\.packman\\GLM;$(ProjectDir)\\..\\Externals\\.packman\\GLFW\\include;$(ProjectDir)\\..\\Externals\\.packman\\FreeImage;$(ProjectDir)\\..\\Externals\\.packman\\ASSIMP\\include;$(ProjectDir)\\..\\Externals\\.packman\\FFMpeg\\include;$(ProjectDir)\\..\\Externals\\.packman\\RapidJson\\include;$(ProjectDir)\\..\\Externals\\.packman\\VulkanSDK\\Include;$(ProjectDir)\\..\\Externals\\.packman\\Python\\Include;$(ProjectDir)\\..\\Externals\\.packman\\pybind11\\include;$(ProjectDir)\\..\\Externals\\;$(ProjectDir)\\..\\Externals\\.packman\\nvapi;$(ProjectDir)\\..\\Externals\\.packman</AdditionalIncludeDirectories>\n  819        <TreatWarningAsError>true</TreatWarningAsError>\n  820        <MultiProcessorCompilation>true</MultiProcessorCompilation>\n  ...\n  827        <SubSystem>Windows</SubSystem>\n  828        <GenerateDebugInformation>true</GenerateDebugInformation>\n  829:       <AdditionalLibraryDirectories>$(ProjectDir)..\\Externals\\.packman\\FreeImage;$(ProjectDir)..\\Externals\\.packman\\Assimp\\lib\\$(PlatformName)\\;$(ProjectDir)..\\Externals\\.packman\\FFMpeg\\lib\\$(PlatformName);$(ProjectDir)..\\Externals\\.packman\\openvr\\lib\\win64;$(ProjectDir)..\\Externals\\.packman\\nvapi\\amd64;$(ProjectDir)..\\Externals\\.packman\\VulkanSDK\\Lib;$(ProjectDir)..\\Externals\\.packman\\Slang\\bin\\windows-x64\\release;$(ProjectDir)..\\Externals\\.packman\\GLFW\\lib;$(ProjectDir)..\\Externals\\.packman\\Python\\libs;$(ProjectDir)..\\Externals\\.packman\\WinPixEventRuntime\\bin\\x64</AdditionalLibraryDirectories>\n  830        <AdditionalDependencies>WinPixEventRuntime.lib;glfw3dll.lib;slang.lib;Comctl32.lib;Shlwapi.lib;assimp-vc141-mt.lib;freeimage.lib;avcodec.lib;avutil.lib;avformat.lib;swscale.lib;Shcore.lib;%(AdditionalDependencies)</AdditionalDependencies>\n  831      </Link>\n  ...\n  844        <AdditionalDependencies>\n  845        </AdditionalDependencies>\n  846:       <AdditionalLibraryDirectories>\n  847:       </AdditionalLibraryDirectories>\n  848      </Lib>\n  849      <PostBuildEvent>\n  ...\n  857        <IntrinsicFunctions>true</IntrinsicFunctions>\n  858        <PreprocessorDefinitions>FALCOR_DLL;IMGUI_API=__declspec(dllexport);_PROJECT_DIR_=R\"($(ProjectDir))\";_SCL_SECURE_NO_WARNINGS;_CRT_SECURE_NO_WARNINGS;FALCOR_D3D12;WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions);GLM_FORCE_DEPTH_ZERO_TO_ONE</PreprocessorDefinitions>\n  859:       <AdditionalIncludeDirectories>$(ProjectDir);$(ProjectDir)\\..\\Externals\\.packman\\GLM;$(ProjectDir)\\..\\Externals\\.packman\\GLFW\\include;$(ProjectDir)\\..\\Externals\\.packman\\FreeImage;$(ProjectDir)\\..\\Externals\\.packman\\ASSIMP\\include;$(ProjectDir)\\..\\Externals\\.packman\\FFMpeg\\include;$(ProjectDir)\\..\\Externals\\.packman\\RapidJson\\include;$(ProjectDir)\\..\\Externals\\.packman\\VulkanSDK\\Include;$(ProjectDir)\\..\\Externals\\.packman\\Python\\Include;$(ProjectDir)\\..\\Externals\\.packman\\pybind11\\include;$(ProjectDir)\\..\\Externals\\;$(ProjectDir)\\..\\Externals\\.packman\\nvapi;$(ProjectDir)\\..\\Externals\\.packman</AdditionalIncludeDirectories>\n  860        <TreatWarningAsError>true</TreatWarningAsError>\n  861        <MultiProcessorCompilation>true</MultiProcessorCompilation>\n  ...\n  870        <EnableCOMDATFolding>true</EnableCOMDATFolding>\n  871        <OptimizeReferences>true</OptimizeReferences>\n  872:       <AdditionalLibraryDirectories>$(ProjectDir)..\\Externals\\.packman\\FreeImage;$(ProjectDir)..\\Externals\\.packman\\Assimp\\lib\\$(PlatformName)\\;$(ProjectDir)..\\Externals\\.packman\\FFMpeg\\lib\\$(PlatformName);$(ProjectDir)..\\Externals\\.packman\\openvr\\lib\\win64;$(ProjectDir)..\\Externals\\.packman\\nvapi\\amd64;$(ProjectDir)..\\Externals\\.packman\\VulkanSDK\\Lib;$(ProjectDir)..\\Externals\\.packman\\Slang\\bin\\windows-x64\\release;$(ProjectDir)..\\Externals\\.packman\\GLFW\\lib;$(ProjectDir)..\\Externals\\.packman\\Python\\libs;$(ProjectDir)..\\Externals\\.packman\\WinPixEventRuntime\\bin\\x64</AdditionalLibraryDirectories>\n  873        <AdditionalDependencies>WinPixEventRuntime.lib;glfw3dll.lib;slang.lib;Comctl32.lib;Shlwapi.lib;assimp-vc141-mt.lib;freeimage.lib;avcodec.lib;avutil.lib;avformat.lib;swscale.lib;Shcore.lib;%(AdditionalDependencies)</AdditionalDependencies>\n  874      </Link>\n  ...\n  885      </CustomBuildStep>\n  886      <Lib>\n  887:       <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>\n  888        <AdditionalDependencies>\n  889        </AdditionalDependencies>\n  ...\n  899        <IntrinsicFunctions>true</IntrinsicFunctions>\n  900        <PreprocessorDefinitions>FALCOR_DLL;IMGUI_API=__declspec(dllexport);_PROJECT_DIR_=R\"($(ProjectDir))\";_SCL_SECURE_NO_WARNINGS;_CRT_SECURE_NO_WARNINGS;FALCOR_VK;WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions);GLM_FORCE_DEPTH_ZERO_TO_ONE</PreprocessorDefinitions>\n  901:       <AdditionalIncludeDirectories>$(ProjectDir);$(ProjectDir)\\..\\Externals\\.packman\\GLM;$(ProjectDir)\\..\\Externals\\.packman\\GLFW\\include;$(ProjectDir)\\..\\Externals\\.packman\\FreeImage;$(ProjectDir)\\..\\Externals\\.packman\\ASSIMP\\include;$(ProjectDir)\\..\\Externals\\.packman\\FFMpeg\\include;$(ProjectDir)\\..\\Externals\\.packman\\RapidJson\\include;$(ProjectDir)\\..\\Externals\\.packman\\VulkanSDK\\Include;$(ProjectDir)\\..\\Externals\\.packman\\Python\\Include;$(ProjectDir)\\..\\Externals\\.packman\\pybind11\\include;$(ProjectDir)\\..\\Externals\\;$(ProjectDir)\\..\\Externals\\.packman\\nvapi;$(ProjectDir)\\..\\Externals\\.packman</AdditionalIncludeDirectories>\n  902        <TreatWarningAsError>true</TreatWarningAsError>\n  903        <MultiProcessorCompilation>true</MultiProcessorCompilation>\n  ...\n  912        <EnableCOMDATFolding>true</EnableCOMDATFolding>\n  913        <OptimizeReferences>true</OptimizeReferences>\n  914:       <AdditionalLibraryDirectories>$(ProjectDir)..\\Externals\\.packman\\FreeImage;$(ProjectDir)..\\Externals\\.packman\\Assimp\\lib\\$(PlatformName)\\;$(ProjectDir)..\\Externals\\.packman\\FFMpeg\\lib\\$(PlatformName);$(ProjectDir)..\\Externals\\.packman\\openvr\\lib\\win64;$(ProjectDir)..\\Externals\\.packman\\nvapi\\amd64;$(ProjectDir)..\\Externals\\.packman\\VulkanSDK\\Lib;$(ProjectDir)..\\Externals\\.packman\\Slang\\bin\\windows-x64\\release;$(ProjectDir)..\\Externals\\.packman\\GLFW\\lib;$(ProjectDir)..\\Externals\\.packman\\Python\\libs;$(ProjectDir)..\\Externals\\.packman\\WinPixEventRuntime\\bin\\x64</AdditionalLibraryDirectories>\n  915        <AdditionalDependencies>WinPixEventRuntime.lib;glfw3dll.lib;slang.lib;Comctl32.lib;Shlwapi.lib;assimp-vc141-mt.lib;freeimage.lib;avcodec.lib;avutil.lib;avformat.lib;swscale.lib;Shcore.lib;%(AdditionalDependencies)</AdditionalDependencies>\n  916      </Link>\n  ...\n  927      </CustomBuildStep>\n  928      <Lib>\n  929:       <AdditionalLibraryDirectories>\n  930:       </AdditionalLibraryDirectories>\n  931        <AdditionalDependencies>\n  932        </AdditionalDependencies>\n\n/home/max/dev/Falcor/src/Falcor/Falcor.vcxproj.filters:\n  434        <Filter>Utils\\Algorithm</Filter>\n  435      </ClInclude>\n  436:     <ClInclude Include=\"Utils\\Math\\Vector.h\">\n  437        <Filter>Utils\\Math</Filter>\n  438      </ClInclude>\n\n/home/max/dev/Falcor/src/Falcor/Raytracing/RtProgram/RtProgram.cpp:\n  160  \n  161      EntryPointGroupKernels::SharedPtr RtProgram::createEntryPointGroupKernels(\n  162:         const std::vector<Shader::SharedPtr>& shaders,\n  163:         EntryPointBaseReflection::SharedPtr const& pReflector) const\n  164      {\n  165          assert(shaders.size() != 0);\n  166  \n  167:         auto localRootSignature = RootSignature::createLocal(pReflector.get());\n  168  \n  169          switch( shaders[0]->getType() )\n\n/home/max/dev/Falcor/src/Falcor/Raytracing/RtProgram/RtProgram.h:\n   58              void setMaxTraceRecursionDepth(uint32_t maxDepth) { mMaxTraceRecursionDepth = maxDepth; }\n   59  \n   60:             std::vector<GroupInfo> mRayGenEntryPoints;\n   61:             std::vector<GroupInfo> mMissEntryPoints;\n   62:             std::vector<GroupInfo> mHitGroups;\n   63              uint32_t mMaxTraceRecursionDepth = 1;\n   64          };\n   ..\n  129  \n  130          EntryPointGroupKernels::SharedPtr createEntryPointGroupKernels(\n  131:             const std::vector<Shader::SharedPtr>& shaders,\n  132:             EntryPointGroupReflection::SharedPtr const& pReflector) const override;\n  133  \n  134      private:\n\n/home/max/dev/Falcor/src/Falcor/Raytracing/RtProgramVars.cpp:\n   55          const RtProgram::SharedPtr& pProgram,\n   56          const Scene::SharedPtr& pScene)\n   57:         : ProgramVars(pProgram->getReflector())\n   58          , mpScene(pScene)\n   59      {\n   ..\n   79          assert(mpProgramVersion);\n   80          auto pProgram = (RtProgram*) mpProgramVersion->getProgram().get();\n   81:         auto pReflector = mpProgramVersion->getReflector();\n   82  \n   83          auto& descExtra = pProgram->getDescExtra();\n   ..\n  118              if(info.groupIndex < 0) continue;\n  119  \n  120:             mRayGenVars[i].pVars = EntryPointGroupVars::create(pReflector->getEntryPointGroup(info.groupIndex), info.groupIndex);\n  121          }\n  122  \n  ...\n  128              for(uint32_t j = 0; j < blockCountPerHitGroup; ++j)\n  129              {\n  130:                 mHitVars[j*descHitGroupCount + i].pVars = EntryPointGroupVars::create(pReflector->getEntryPointGroup(info.groupIndex), info.groupIndex);\n  131              }\n  132          }\n  ...\n  137              if(info.groupIndex < 0) continue;\n  138  \n  139:             mMissVars[i].pVars = EntryPointGroupVars::create(pReflector->getEntryPointGroup(info.groupIndex), info.groupIndex);\n  140          }\n  141  \n\n/home/max/dev/Falcor/src/Falcor/Raytracing/RtProgramVars.h:\n   75          };\n   76  \n   77:         using VarsVector = std::vector<EntryPointGroupInfo>;\n   78  \n   79          RtProgramVars(\n   ..\n   87          mutable ShaderTable::SharedPtr mpShaderTable;\n   88  \n   89:         VarsVector mRayGenVars;\n   90:         VarsVector mHitVars;\n   91:         VarsVector mMissVars;\n   92  \n   93          RtVarsContext::SharedPtr mpRtVarsHelper;\n\n/home/max/dev/Falcor/src/Falcor/Raytracing/RtProgramVarsHelper.h:\n   77          void RSSetViewports(UINT NumViewports, const D3D12_VIEWPORT *pViewports) { should_not_get_here(); }\n   78          void RSSetScissorRects(UINT NumRects, const D3D12_RECT *pRects) { should_not_get_here(); }\n   79:         void OMSetBlendFactor(const FLOAT BlendFactor[ 4 ]) { should_not_get_here(); }\n   80          void OMSetRenderTargets(UINT NumRenderTargetDescriptors, const D3D12_CPU_DESCRIPTOR_HANDLE *pRenderTargetDescriptors, BOOL RTsSingleHandleToDescriptorRange, const D3D12_CPU_DESCRIPTOR_HANDLE *pDepthStencilDescriptor) { should_not_get_here(); }\n   81          void OMSetStencilRef(UINT StencilRef) { should_not_get_here(); }\n\n/home/max/dev/Falcor/src/Falcor/Raytracing/RtStateObject.h:\n   68          ApiHandle mApiHandle;\n   69  \n   70:         std::vector<void const*> mShaderIdentifiers;\n   71          Desc mDesc;\n   72      };\n\n/home/max/dev/Falcor/src/Falcor/Raytracing/RtStateObjectHelper.h:\n   99  \n  100      private:\n  101:         using SubobjectVector = std::vector<D3D12_STATE_SUBOBJECT>;\n  102  \n  103          struct RtStateSubobjectBase\n  ...\n  106              D3D12_STATE_SUBOBJECT subobject = {};\n  107  \n  108:             virtual void addToVector(SubobjectVector& vec)\n  109              {\n  110                  vec.push_back(subobject);\n  ...\n  184              D3D12_HIT_GROUP_DESC desc = {};\n  185  \n  186:             virtual void addToVector(SubobjectVector& vec) override\n  187              {\n  188:                 if (desc.AnyHitShaderImport)        anyHitShader.addToVector(vec);\n  189:                 if (desc.ClosestHitShaderImport)    closestHitShader.addToVector(vec);\n  190:                 if (desc.IntersectionShaderImport)   intersectionShader.addToVector(vec);\n  191                  vec.push_back(subobject);\n  192              }\n  ...\n  216              }\n  217  \n  218:             std::vector<std::wstring> exportNames;\n  219:             std::vector<const WCHAR*> pName;\n  220              D3D12_SUBOBJECT_TO_EXPORTS_ASSOCIATION association = {};\n  221              RtStateSubobjectBase* pAssociatedSubobject = nullptr;\n  222  \n  223:             virtual void addToVector(SubobjectVector& vec) override\n  224              {\n  225                  // TODO: finalize() assumes that the subobject to associate comes right before the export associataion subobject. Need to figure out a way to remove this assumption\n  226                  assert(pAssociatedSubobject);\n  227:                 pAssociatedSubobject->addToVector(vec);\n  228                  vec.push_back(subobject);\n  229              }\n  ...\n  268  \n  269          bool mDirty = false;\n  270:         SubobjectVector mSubobjects;\n  271          std::list<RtStateSubobjectBase*> mBaseSubObjects;\n  272  \n  ...\n  285              for (const auto& l : mBaseSubObjects)\n  286              {\n  287:                 l->addToVector(mSubobjects);\n  288              }\n  289  \n\n/home/max/dev/Falcor/src/Falcor/Raytracing/ShaderTable.h:\n  142          RtStateObject*          mpRtso = nullptr;\n  143          Buffer::SharedPtr       mpBuffer;\n  144:         std::vector<uint8_t>    mData;\n  145      };\n  146  }\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/BasePasses/ComputePass.cpp:\n   52  void ComputePass::execute(ComputeContext* pContext, uint32_t nThreadX, uint32_t nThreadY, uint32_t nThreadZ) {\n   53      assert(mpVars);\n   54:     uint3 threadGroupSize = mpState->getProgram()->getReflector()->getThreadGroupSize();\n   55      uint3 groups = div_round_up(uint3(nThreadX, nThreadY, nThreadZ), threadGroupSize);\n   56      pContext->dispatch(mpState.get(), mpVars.get(), groups);\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/BasePasses/ComputePass.h:\n  105          /** Get the thread group size from the program\n  106          */\n  107:         uint3 getThreadGroupSize() const { return mpState->getProgram()->getReflector()->getThreadGroupSize(); }\n  108  \n  109      protected:\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraph.cpp:\n   35  namespace Falcor {\n   36  \n   37: std::vector<RenderGraph*> gRenderGraphs;\n   38  const FileDialogFilterVec RenderGraph::kFileExtensionFilters = { { \"py\", \"Render Graph Files\"} };\n   39  \n   ..\n  108  \n  109      // Unmark graph outputs that belong to this pass\n  110:     // Because the way std::vector works, we can't call umarkOutput() immediatly, so we store the outputs in a vector\n  111:     std::vector<std::string> outputsToDelete;\n  112      const std::string& outputPrefix = name + '.';\n  113      \n  ...\n  245  \n  246      // Make sure that this doesn't create a cycle\n  247:     if (DirectedGraphPathDetector::hasPath(mpGraph, dstIndex, srcIndex)) {\n  248          logError(\"RenderGraph::addEdge() - can't add the edge [\" + src + \", \" + dst + \"]. The edge will create a cycle in the graph which is not allowed\");\n  249          return kInvalidIndex;\n  ...\n  317  }\n  318  \n  319: std::vector<std::string> RenderGraph::getAvailableOutputs() const {\n  320:     std::vector<std::string> outputs;\n  321  \n  322      for (const auto& node : mNodeData) {\n  ...\n  368      }\n  369  \n  370:     std::vector<std::string> passesToRemove;\n  371  \n  372      // remove nodes that should no longer be within the graph\n  ...\n  539  \n  540  // Given a pair of src and dst RenderPass data, check if any src outputs can fulfill unsatisfied dst inputs\n  541: void RenderGraph::autoConnectPasses(const NodeData* pSrcNode, const RenderPassReflection& srcReflection, const NodeData* pdstNode, std::vector<RenderPassReflection::Field>& unsatisfiedInputs) {\n  542      // For every unsatisfied input in dst pass\n  543      auto dstFieldIt = unsatisfiedInputs.begin();\n  ...\n  566  }\n  567  \n  568: void RenderGraph::getUnsatisfiedInputs(const NodeData* pNodeData, const RenderPassReflection& passReflection, std::vector<RenderPassReflection::Field>& outList) const {\n  569      assert(mNameToIndex.count(pNodeData->name) > 0);\n  570  \n  571      // Get names of connected input edges\n  572:     std::vector<std::string> satisfiedFields;\n  573      const DirectedGraph::Node* pNode = mpGraph->getNode(mNameToIndex.at(pNodeData->name));\n  574      for (uint32_t i = 0; i < pNode->getIncomingEdgeCount(); i++) {\n  ...\n  588  }\n  589  \n  590: void RenderGraph::autoGenEdges(const std::vector<uint32_t>& executionOrder) {\n  591      // Remove all previously auto-generated edges\n  592      auto it = mEdgeData.begin();\n  ...\n  599  \n  600      // Gather list of passes by order they were added\n  601:     std::vector<NodeData*> nodeVec;\n  602      std::unordered_map<RenderPass*, RenderPassReflection> passReflectionMap;\n  603  \n  ...\n  615      }\n  616  \n  617:     // For all nodes, starting at end, iterate until index 1 of vector\n  618      for (size_t dst = nodeVec.size() - 1; dst > 0; dst--) {\n  619:         std::vector<RenderPassReflection::Field> unsatisfiedInputs;\n  620          getUnsatisfiedInputs(nodeVec[dst], passReflectionMap[nodeVec[dst]->pPass.get()], unsatisfiedInputs);\n  621  \n  622          // Find outputs to connect.\n  623:         // Start one before i, iterate until the beginning of vector\n  624          for (size_t src = dst - 1; src != size_t(-1) && unsatisfiedInputs.size() > 0; src--) {\n  625              // While there are unsatisfied inputs, keep searching for passes with outputs that can connect\n  ...\n  659  \n  660      auto graphClass = m.regClass(RenderGraph);\n  661:     //graphClass.ctor(&RenderGraph::create(const std::string&));\n  662:     //graphClass.ctor(&RenderGraph::create(std::shared_ptr<Device>, const std::string&));\n  663  \n  664:     graphClass.ctor(&create_default);\n  665:     graphClass.ctor(&create_on_device);\n  666  \n  667      graphClass.property(\"name\", &RenderGraph::getName, &RenderGraph::setName);\n  ...\n  690          return pPass;\n  691      };\n  692:     passClass.ctor(createRenderPass, \"device\"_a, \"name\"_a, \"dict\"_a = pybind11::dict());\n  693  \n  694      // RenderPassLibrary with default device\n  ...\n  702          return pPass;\n  703      };\n  704:     passClass.ctor(createRenderPassDefault, \"name\"_a, \"dict\"_a = pybind11::dict());\n  705      */\n  706  \n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraph.h:\n  166          /** Get all output names for the render graph\n  167          */\n  168:         std::vector<std::string> getAvailableOutputs() const;\n  169  \n  170          /** Attempts to auto generate edges for render passes.\n  171              \\param[in] executionOrder Optional. Ordered list of node ID's as an override of pass search order to use when generating edges.\n  172          */\n  173:         void autoGenEdges(const std::vector<uint32_t>& executionOrder = std::vector<uint32_t>());\n  174  \n  175          /** Render the UI\n  ...\n  230  \n  231          uint32_t getEdge(const std::string& src, const std::string& dst);\n  232:         void getUnsatisfiedInputs(const NodeData* pNodeData, const RenderPassReflection& passReflection, std::vector<RenderPassReflection::Field>& outList) const;\n  233:         void autoConnectPasses(const NodeData* pSrcNode, const RenderPassReflection& srcReflection, const NodeData* pDestNode, std::vector<RenderPassReflection::Field>& unsatisfiedInputs);\n  234  \n  235          Scene::SharedPtr mpScene;\n  ...\n  252          };\n  253  \n  254:         std::vector<GraphOut> mOutputs; // GRAPH_TODO should this be an unordered set?\n  255          bool isGraphOutput(const GraphOut& graphOut) const;\n  256  \n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraphCompiler.cpp:\n   70      for (const auto& p : mExecutionList) {\n   71          // Make sure all the inputs are satisfied\n   72:         for (uint32_t i = 0; i < p.reflector.getFieldCount(); i++) {\n   73:             const auto& f = *p.reflector.getField(i);\n   74              if (!is_set(f.getVisibility(), RenderPassReflection::Field::Visibility::Input)) continue;\n   75              if (is_set(f.getFlags(), RenderPassReflection::Field::Flags::Optional)) continue;\n   ..\n  128      auto topologicalSort = DirectedGraphTopologicalSort::sort(mGraph.mpGraph.get());\n  129  \n  130:     // For each object in the vector, if it's being used in the execution, put it in the list\n  131      for (auto& node : topologicalSort) {\n  132          if (participatingPasses.find(node) != participatingPasses.end()) {\n  ...\n  140      bool addedPasses = false;\n  141      for (size_t i = 0; i < mExecutionList.size(); i++) {\n  142:         const RenderPassReflection& passReflection = mExecutionList[i].reflector;\n  143  \n  144          // Check for opportunities to automatically resolve MSAA\n  ...\n  152              // Gather src field name, and every input it is connected to\n  153              std::string srcFieldName = srcPassName + '.' + srcField.getName();\n  154:             std::vector<std::string> dstFieldNames;\n  155  \n  156              const DirectedGraph::Node* pNode = mGraph.mpGraph->getNode(mExecutionList[i].index);\n  ...\n  167                      auto getPassReflection = [&](uint32_t index) -> std::optional<RenderPassReflection>\n  168                      {\n  169:                         for (const auto& e : mExecutionList) if (e.index == index) return e.reflector;\n  170                          return std::nullopt;\n  171                      };\n  ...\n  227          assert(pNode);\n  228          RenderPass* pCurrPass = mGraph.mNodeData[nodeIndex].pPass.get();\n  229:         const auto& passReflection = mExecutionList[i].reflector;\n  230  \n  231          auto isResourceUsed = [&](auto field) {\n  ...\n  276  \n  277              const auto& pSrcPass = mGraph.mNodeData[pEdge->getSourceNode()].pPass.get();\n  278:             const auto& srcReflection = mExecutionList[passToIndex.at(pSrcPass)].reflector;\n  279              pResourceCache->registerField(dstFieldName, dstField, passToIndex[pSrcPass], srcFieldName);\n  280          }\n  ...\n  311          for (const auto& otherPass : mExecutionList) {\n  312              if (otherPass.index == incomingPass) {\n  313:                 auto f = *otherPass.reflector.getField(mGraph.mEdgeData[e].srcField);\n  314:                 const auto& fIn = *passData.reflector.getField(mGraph.mEdgeData[e].dstField);\n  315                  f.name(fIn.getName()).visibility(fIn.getVisibility()).desc(fIn.getDesc());\n  316                  compileData.connectedResources.addField(f);\n  ...\n  338          for (const auto& otherPass : mExecutionList) {\n  339              if (otherPass.index == outgoingPass) {\n  340:                 auto f = *otherPass.reflector.getField(mGraph.mEdgeData[e].dstField);\n  341                  auto pField = compileData.connectedResources.getField(mGraph.mEdgeData[e].srcField);\n  342                  if (pField) {\n  343                      const_cast<RenderPassReflection::Field*>(pField)->merge(f);\n  344                  } else {\n  345:                     const auto& fOut = *passData.reflector.getField(mGraph.mEdgeData[e].srcField);\n  346                      f.name(fOut.getName()).visibility(fOut.getVisibility()).desc(fOut.getDesc());\n  347                      compileData.connectedResources.addField(f);\n  ...\n  373          for (auto& p : mExecutionList) {\n  374              auto newR = p.pPass->reflect(prepPassCompilationData(p));\n  375:             if (newR != p.reflector) {\n  376:                 p.reflector = newR;\n  377                  changed = true;\n  378              }\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraphCompiler.h:\n   54              RenderPass::SharedPtr pPass;\n   55              std::string name;\n   56:             RenderPassReflection reflector;\n   57          };\n   58:         std::vector<PassData> mExecutionList;\n   59  \n   60          // TODO Better way to track history, or avoid changing the original graph altogether?\n   61          struct\n   62          {\n   63:             std::vector<std::string> generatedPasses;\n   64:             std::vector<std::pair<std::string, std::string>> removedEdges;\n   65          } mCompilationChanges;\n   66  \n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraphExe.h:\n   94          };\n   95  \n   96:         std::vector<Pass> mExecutionList;\n   97          ResourceCache::SharedPtr mpResourceCache;\n   98      };\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraphImportExport.cpp:\n   44  void runScriptFile(const std::string& filename, const std::string& custom) {\n   45      std::string fullpath;\n   46:     if (findFileInDataDirectories(filename, fullpath) == false) {\n   47          throw std::runtime_error(\"Can't find the file: \" + filename);\n   48      }\n   ..\n   79  }\n   80  \n   81: std::vector<RenderGraph::SharedPtr> RenderGraphImporter::importAllGraphs(const std::string& filename) {\n   82      while(true) {\n   83          try {\n   84              runScriptFile(filename, {});\n   85              auto scriptObj = Scripting::getGlobalContext().getObjects<RenderGraph::SharedPtr>();\n   86:             std::vector<RenderGraph::SharedPtr> res;\n   87              res.reserve(scriptObj.size());\n   88  \n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraphImportExport.h:\n   44          /** Import all the graphs found in the script's global namespace\n   45          */\n   46:         static std::vector <RenderGraph::SharedPtr> importAllGraphs(const std::string& filename);\n   47      };\n   48  \n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraphUI.cpp:\n  188          }\n  189  \n  190:         ImGui::FieldInfoVector& getFields()\n  191          {\n  192              return fields;\n  ...\n  893          }\n  894  \n  895:         ImVector<const ImGui::Node*> selectedNodes;\n  896          mpNodeGraphEditor->getSelectedNodes(selectedNodes);\n  897  \n  ...\n 1093      }\n 1094  \n 1095:     std::vector<uint32_t> RenderGraphUI::getPassOrder()\n 1096      {\n 1097:         std::vector<uint32_t> executionOrder;\n 1098          std::map<float, uint32_t> posToIndex;\n 1099  \n ....\n 1245          auto topologicalSort = DirectedGraphTopologicalSort::sort(mpRenderGraph->mpGraph.get());\n 1246  \n 1247:         // For each object in the vector, if it's being used in the execution, put it in the list\n 1248          for (auto& node : topologicalSort)\n 1249          {\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraphUI.h:\n   62          };\n   63  \n   64:         std::vector<PinUI> mInputPins;\n   65          std::unordered_map<std::string, uint32_t> mNameToIndexInput;\n   66  \n   67:         std::vector<PinUI> mOutputPins;\n   68          std::unordered_map<std::string, uint32_t> mNameToIndexOutput;\n   69  \n   ..\n  128          /** Get an execution order for graph based on the visual layout of the graph\n  129          */\n  130:         std::vector<uint32_t> getPassOrder();\n  131  \n  132          /** Returns the current log from the events in the editor\n  ...\n  188  \n  189          std::unordered_set<std::string> mAllNodeTypeStrings;\n  190:         std::vector<const char*> mAllNodeTypes;\n  191  \n  192          std::unordered_map <std::string, RenderPassUI> mRenderPassUI;\n  ...\n  195  \n  196          // maps output pin name to input pin ids. Pair first is pin id, second is node id\n  197:         std::unordered_map <std::string, std::vector< std::pair<uint32_t, uint32_t > > > mOutputToInputPins;\n  198  \n  199          // if in external editing mode, building list of commands for changes to send to the other process\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderPass.h:\n   79          Render passes are expected to implement a static create() function that returns\n   80          a shared pointer to a new object, or throws an exception if creation failed.\n   81:         The constructor should be private to force creation of shared pointers.\n   82  \n   83          Render passes are inserted in a render graph, which is executed at runtime.\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderPassHelpers.h:\n   47      };\n   48  \n   49:     using ChannelList = std::vector<ChannelDesc>;\n   50  \n   51      /** Creates a list of defines to determine if optional render pass resources are valid to be accessed.\n   ..\n   76  \n   77      /** Adds a list of input channels to the render pass reflection.\n   78:         \\param[in] reflector Render pass reflection object.\n   79          \\param[in] channels List of channels.\n   80          \\param[in] bindFlags Optional bind flags. The default is 'ShaderResource' for all inputs.\n   81      */\n   82:     inline void addRenderPassInputs(RenderPassReflection& reflector, const ChannelList& channels, ResourceBindFlags bindFlags = ResourceBindFlags::ShaderResource)\n   83      {\n   84          for (const auto& it : channels)\n   85          {\n   86:             auto& buffer = reflector.addInput(it.name, it.desc);\n   87              buffer.bindFlags(bindFlags);\n   88              if (it.format != ResourceFormat::Unknown) buffer.format(it.format);\n   ..\n   92  \n   93      /** Adds a list of output channels to the render pass reflection.\n   94:         \\param[in] reflector Render pass reflection object.\n   95          \\param[in] channels List of channels.\n   96          \\param[in] bindFlags Optional bind flags. The default is 'UnorderedAccess' for all outputs.\n   97      */\n   98:     inline void addRenderPassOutputs(RenderPassReflection& reflector, const ChannelList& channels, ResourceBindFlags bindFlags = ResourceBindFlags::UnorderedAccess)\n   99      {\n  100          for (const auto& it : channels)\n  101          {\n  102:             auto& buffer = reflector.addOutput(it.name, it.desc);\n  103              buffer.bindFlags(bindFlags);\n  104              if (it.format != ResourceFormat::Unknown) buffer.format(it.format);\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderPassLibrary.cpp:\n   27   **************************************************************************/\n   28  #include <fstream>\n   29: #include <vector>\n   30  #include <map>\n   31  \n   ..\n   47  namespace Falcor {\n   48  \n   49:     extern std::vector<RenderGraph*> gRenderGraphs;\n   50  \n   51      #ifdef _MSC_VER\n   ..\n  169          if (filePath.extension() != kPassLibExt) filePath += kPassLibExt;\n  170  \n  171:         std::string fullpath = getExecutableDirectory() + \"/Passes/\" + getFilenameFromPath(filePath.string());\n  172  \n  173          if (doesFileExist(fullpath) == false) {\n  ...\n  188          auto func = (LibraryFunc)getDllProcAddress(l, \"getPasses\");\n  189  \n  190:         // Add the DLL project directory to the search paths\n  191          if (isDevelopmentMode()) {\n  192              auto libProjPath = (const char*(*)(void))getDllProcAddress(l, \"getProjDir\");\n  193              if (libProjPath) {\n  194                  const char* projDir = libProjPath();\n  195:                 addDataDirectory(std::string(projDir) + \"/Data/\");\n  196              }\n  197          }\n  ...\n  212  \n  213      void RenderPassLibrary::releaseLibrary(const std::string& filename) {\n  214:         std::string fullpath = getExecutableDirectory() + \"/Passes/\" + getFilenameFromPath(filename);\n  215  \n  216          auto libIt = mLibs.find(fullpath);\n  ...\n  229          }\n  230  \n  231:         // Remove the DLL project directory to the search paths\n  232          if (isDevelopmentMode()) {\n  233              auto libProjPath = (const char*(*)(void))getDllProcAddress(module, \"getProjDir\");\n  234              if (libProjPath) {\n  235                  const char* projDir = libProjPath();\n  236:                 removeDataDirectory(std::string(projDir) + \"/Data/\");\n  237              }\n  238          }\n  ...\n  257          };\n  258  \n  259:         std::vector<PassesToReplace> passesToReplace;\n  260  \n  261          for (auto& passDesc : mPasses) {\n  ...\n  287  \n  288      void RenderPassLibrary::reloadLibraries(RenderContext* pRenderContext) {\n  289:         // Copy the libs vector so we don't screw up the iterator\n  290          auto libs = mLibs;\n  291          for (const auto& l : libs) reloadLibrary(pRenderContext, l.first);\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderPassLibrary.h:\n   51          };\n   52  \n   53:         using DescVec = std::vector<RenderPassDesc>;\n   54  \n   55          /** Get an instance of the library. It's a singleton, you'll always get the same object\n   ..\n   93          using LibraryFunc = void(*)(RenderPassLibrary& lib);\n   94  \n   95:         using StrVec = std::vector<std::string>;\n   96  \n   97          /** Get list of registered render-pass libraries\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderPassReflection.h:\n  143      private:\n  144          Field& addField(const std::string& name, const std::string& desc, Field::Visibility visibility);\n  145:         std::vector<Field> mFields;\n  146      };\n  147  \n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/ResourceCache.h:\n   98      // Resources and properties for fields within (and therefore owned by) a render graph\n   99      std::unordered_map<std::string, uint32_t> mNameToIndex;\n  100:     std::vector<ResourceData> mResourceData;\n  101  \n  102      // References to output resources not to be allocated by the render graph\n\n/home/max/dev/Falcor/src/Falcor/RenderPasses/ResolvePass.cpp:\n   39  \n   40  RenderPassReflection ResolvePass::reflect(const CompileData& compileData) {\n   41:     RenderPassReflection reflector;\n   42:     reflector.addInput(kSrc, \"Multi-sampled texture\").format(mFormat).texture2D(0, 0, 0);\n   43:     reflector.addOutput(kDst, \"Destination texture. Must have a single sample\").format(mFormat).texture2D(0, 0, 1);\n   44:     return reflector;\n   45  }\n   46  \n\n/home/max/dev/Falcor/src/Falcor/RenderPasses/Shared/PathTracer/LoadShadingData.slang:\n   70      if (isValid(gWorldView))\n   71      {\n   72:         // If we have the view vector bound as a buffer, just fetch it. No need to compute anything.\n   73          return -gWorldView[pixel].xyz;\n   74      }\n   ..\n   76  #endif\n   77      {\n   78:         // Compute the view vector. This must exactly match what the G-buffer pass is doing (jitter etc.).\n   79          // Note that we do not take depth-of-field into account as it would require exactly matching the\n   80          // sample generator between the passes, which is error prone. The host side will issue a warning instead.\n\n/home/max/dev/Falcor/src/Falcor/RenderPasses/Shared/PathTracer/PathTracer.cpp:\n  105      RenderPassReflection PathTracer::reflect(const CompileData& compileData)\n  106      {\n  107:         RenderPassReflection reflector;\n  108  \n  109:         addRenderPassInputs(reflector, mInputChannels);\n  110:         addRenderPassOutputs(reflector, mOutputChannels);\n  111  \n  112:         return reflector;\n  113      }\n  114  \n\n/home/max/dev/Falcor/src/Falcor/RenderPasses/Shared/PathTracer/PathTracerHelpers.slang:\n  196      // Set relative probabilities of the different sampling techniques.\n  197      // TODO: These should use estimated irradiance from each light type. Using equal probabilities for now.\n  198:     // TODO: Refactor the selection pdf code the helpers above for evaluating the individual probabilities.\n  199      float p[3];\n  200      p[0] = kUseEnvLight ? 1.f : 0.f;\n\n/home/max/dev/Falcor/src/Falcor/Scene/Animation/Animation.cpp:\n   57          double keyframeDuration = end.time - start.time;\n   58          if (keyframeDuration < 0) keyframeDuration += mDurationInSeconds;\n   59:         float factor = keyframeDuration != 0 ? (float)(localTime / keyframeDuration) : 1;\n   60  \n   61:         float3 translation = lerp(start.translation, end.translation, factor);\n   62:         float3 scaling = lerp(start.scaling, end.scaling, factor);\n   63:         glm::quat rotation = slerp(start.rotation, end.rotation, factor);\n   64  \n   65          glm::mat4 T;\n   ..\n   83      }\n   84  \n   85:     void Animation::animate(double totalTime, std::vector<glm::mat4>& matrices)\n   86      {\n   87          // Calculate the relative time\n\n/home/max/dev/Falcor/src/Falcor/Scene/Animation/Animation.h:\n   27   **************************************************************************/\n   28  #pragma once\n   29: #include <vector>\n   30  \n   31  namespace Falcor\n   ..\n   81              \\param matrices The array of global matrices to update\n   82          */\n   83:         void animate(double currentTime, std::vector<glm::mat4>& matrices);\n   84  \n   85          /** Get the matrixID affected by a channel\n   ..\n   94              Channel(size_t matID) : matrixID(matID) {};\n   95              size_t matrixID;\n   96:             std::vector<Keyframe> keyframes;\n   97              size_t lastKeyframeUsed = 0;\n   98              double lastUpdateTime = 0;\n   99          };\n  100  \n  101:         std::vector<Channel> mChannels;\n  102          const std::string mName;\n  103          double mDurationInSeconds = 0;\n\n/home/max/dev/Falcor/src/Falcor/Scene/Animation/AnimationController.cpp:\n   38  }  // namespace\n   39  \n   40:     AnimationController::AnimationController(Scene* pScene, const StaticVertexVector& staticVertexData, const DynamicVertexVector& dynamicVertexData) :\n   41          mpScene(pScene), mLocalMatrices(pScene->mSceneGraph.size()), mInvTransposeGlobalMatrices(pScene->mSceneGraph.size()), mMatricesChanged(pScene->mSceneGraph.size())\n   42      {\n   ..\n   50      }\n   51  \n   52:     AnimationController::UniquePtr AnimationController::create(Scene* pScene, const StaticVertexVector& staticVertexData, const DynamicVertexVector& dynamicVertexData) {\n   53          return UniquePtr(new AnimationController(pScene, staticVertexData, dynamicVertexData));\n   54      }\n   ..\n  195      }\n  196  \n  197:     void AnimationController::createSkinningPass(const std::vector<PackedStaticVertexData>& staticVertexData, const std::vector<DynamicVertexData>& dynamicVertexData) {\n  198          // We always copy the static data, to initialize the non-skinned vertices\n  199          Buffer::ConstSharedPtrRef pVB = mpScene->mpVao->getVertexBuffer(Scene::kStaticDataBufferIndex);\n  ...\n  202  \n  203          // Initialize the previous positions for non-skinned vertices.\n  204:         std::vector<PrevVertexData> prevVertexData(staticVertexData.size());\n  205          for (size_t i = 0; i < staticVertexData.size(); i++) {\n  206              prevVertexData[i].position = staticVertexData[i].position;\n\n/home/max/dev/Falcor/src/Falcor/Scene/Animation/AnimationController.h:\n   58          ~AnimationController() = default;\n   59  \n   60:         using StaticVertexVector = std::vector<PackedStaticVertexData>;\n   61:         using DynamicVertexVector = std::vector<DynamicVertexData>;\n   62  \n   63          /** Create a new object\n   64          */\n   65:         static UniquePtr create(Scene* pScene, const StaticVertexVector& staticVertexData, const DynamicVertexVector& dynamicVertexData);\n   66          \n   67          /** Add an animation for a mesh\n   ..\n  108          /** Get the global matrices\n  109          */\n  110:         const std::vector<glm::mat4>& getGlobalMatrices() const { return mGlobalMatrices; }\n  111  \n  112          /** Check if a matrix changed\n  ...\n  116      private:\n  117          friend class SceneBuilder;\n  118:         AnimationController(Scene* pScene, const StaticVertexVector& staticVertexData, const DynamicVertexVector& dynamicVertexData);\n  119  \n  120          void allocatePrevWorldMatrixBuffer();\n  ...\n  125          struct MeshAnimation\n  126          {\n  127:             std::vector<Animation::SharedPtr> pAnimations;\n  128              uint32_t activeAnimation = kBindPoseAnimationId;\n  129          };\n  130  \n  131          std::map<uint32_t, MeshAnimation> mMeshes;\n  132:         std::vector<glm::mat4> mLocalMatrices;\n  133:         std::vector<glm::mat4> mGlobalMatrices;\n  134:         std::vector<glm::mat4> mInvTransposeGlobalMatrices;\n  135:         std::vector<bool> mMatricesChanged;\n  136  \n  137          bool mHasAnimations = false;\n  ...\n  147          // Skinning\n  148          ComputePass::SharedPtr mpSkinningPass;\n  149:         std::vector<glm::mat4> mSkinningMatrices;\n  150:         std::vector<glm::mat4> mInvTransposeSkinningMatrices;\n  151          uint32_t mSkinningDispatchSize = 0;\n  152:         void createSkinningPass(const std::vector<PackedStaticVertexData>& staticVertexData, const std::vector<DynamicVertexData>& dynamicVertexData);\n  153          void executeSkinningPass(RenderContext* pContext);\n  154  \n\n/home/max/dev/Falcor/src/Falcor/Scene/Camera/Camera.cpp:\n   60          if (firstFrame) mPrevData = mData;\n   61  \n   62:         // Keep copies of the transforms used for the previous frame. We need these for computing motion vectors etc.\n   63          mData.prevViewProjMatNoJitter = mPrevData.viewProjMatNoJitter;\n   64  \n   ..\n  107                      mData.projMat = glm::perspective(fovY, mData.aspectRatio, mData.nearZ, mData.farZ);\n  108                  } else {\n  109:                     // Take the length of look-at vector as half a viewport size\n  110                      const float halfLookAtLength = length(mData.posW - mData.target) * 0.5f;\n  111                      mData.projMat = glm::ortho(-halfLookAtLength, halfLookAtLength, -halfLookAtLength, halfLookAtLength, mData.nearZ, mData.farZ);\n  ...\n  142              }\n  143  \n  144:             // Ray tracing related vectors\n  145              mData.cameraW = glm::normalize(mData.target - mData.posW) * mData.focalDistance;\n  146              mData.cameraU = glm::normalize(glm::cross(mData.cameraW, mData.up));\n  ...\n  275              if (g.var(\"Target\", target, -FLT_MAX, FLT_MAX, 0.001f)) setTarget(target);\n  276  \n  277:             float3 up = getUpVector();\n  278:             if (g.var(\"Up\", up, -FLT_MAX, FLT_MAX, 0.001f)) setUpVector(up);\n  279  \n  280              g.release();\n  ...\n  296          camera.property(\"position\", &Camera::getPosition, &Camera::setPosition);\n  297          camera.property(\"target\", &Camera::getTarget, &Camera::setTarget);\n  298:         camera.property(\"up\", &Camera::getUpVector, &Camera::setUpVector);\n  299      }\n  300  \n\n/home/max/dev/Falcor/src/Falcor/Scene/Camera/Camera.h:\n  122          const float3& getPosition() const { return mData.posW; }\n  123  \n  124:         /** Get the camera's world space up vector.\n  125          */\n  126:         const float3& getUpVector() const {return mData.up;}\n  127  \n  128          /** Get the camera's world space target position.\n  ...\n  134          void setPosition(const float3& posW) { mData.posW = posW; mDirty = true; }\n  135  \n  136:         /** Set the camera's world space up vector.\n  137          */\n  138:         void setUpVector(const float3& up) { mData.up = up; mDirty = true; }\n  139  \n  140          /** Set the camera's world space target position.\n  ...\n  245              Frustum         = 0x10,\n  246              Aperture        = 0x20,\n  247:             History         = 0x40, ///< The previous frame matrix changed. This indicates that the camera motion-vectors changed\n  248          };\n  249  \n\n/home/max/dev/Falcor/src/Falcor/Scene/Camera/CameraController.cpp:\n   59              break;\n   60          case MouseEvent::Type::LeftButtonDown:\n   61:             mLastVector = project2DCrdToUnitSphere(convertCamPosRange(mouseEvent.pos));\n   62              mIsLeftButtonDown = true;\n   63              handled = true;\n   ..\n   70              if(mIsLeftButtonDown) {\n   71                  float3 curVec = project2DCrdToUnitSphere(convertCamPosRange(mouseEvent.pos));\n   72:                 glm::quat q = createQuaternionFromVectors(mLastVector, curVec);\n   73                  glm::mat3x3 rot = (glm::mat3x3)q;\n   74                  mRotation = rot * mRotation;\n   75                  mbDirty = true;\n   76:                 mLastVector = curVec;\n   77                  handled = true;\n   78                  mShouldRotate = true;\n   ..\n   98          float3 up(0, 1, 0);\n   99          up = up * mRotation;\n  100:         mpCamera->setUpVector(up);\n  101          return true;\n  102      }\n  ...\n  162              float3 camPos = mpCamera->getPosition();\n  163              float3 camTarget = mpCamera->getTarget();\n  164:             float3 camUp = b6DoF ? mpCamera->getUpVector() : float3(0, 1, 0);;\n  165  \n  166              float3 viewDir = glm::normalize(camTarget - camPos);\n  ...\n  180  \n  181                  mpCamera->setTarget(camPos + viewDir);\n  182:                 mpCamera->setUpVector(camUp);\n  183                  dirty = true;\n  184              }\n  ...\n  189                  glm::mat3 rot(q);\n  190                  camUp = camUp * rot;\n  191:                 mpCamera->setUpVector(camUp);\n  192                  dirty = true;\n  193              }\n  ...\n  207              float3 camPos = mpCamera->getPosition();\n  208              float3 camTarget = mpCamera->getTarget();\n  209:             float3 camUp = mpCamera->getUpVector();\n  210  \n  211              float3 viewDir = normalize(camTarget - camPos);\n\n/home/max/dev/Falcor/src/Falcor/Scene/Camera/CameraController.h:\n  106  \n  107          glm::mat3x3 mRotation;\n  108:         float3 mLastVector;\n  109          bool mIsLeftButtonDown = false;\n  110          bool mShouldRotate = false;\n\n/home/max/dev/Falcor/src/Falcor/Scene/Camera/CameraData.slang:\n   44      float3   posW                   = float3(0, 0, 0);  ///< Camera world-space position.\n   45      float    focalLength            = 21.0f;            ///< Camera focal length in mm. Default is 59 degree vertical, 90 horizontal FOV at 16:9 aspect ratio.\n   46:     float3   up                     = float3(0, 1, 0);  ///< Camera world-space up vector.\n   47      float    aspectRatio            = 1.7777f;          ///< 16:9 aspect-ratio.\n   48      float3   target                 = float3(0, 0, -1); ///< Camera target point in world-space.\n   49      float    nearZ                  = 0.1f;             ///< Camera near plane.\n   50:     float3   cameraU                = float3(0, 0, 1);  ///< Camera base vector U. Normalized it indicates the right image plane vector. The length is dependent on the FOV.\n   51      float    farZ                   = 1000.0f;          ///< Camera far plane.\n   52:     float3   cameraV                = float3(0, 1, 0);  ///< Camera base vector V. Normalized it indicates the up image plane vector. The length is dependent on the FOV.\n   53      float    jitterX                = 0.0f;             ///< Eventual camera jitter along the x axis expressed as a subpixel offset divided by screen width (positive value shifts the image right).\n   54:     float3   cameraW                = float3(1, 0, 0);  ///< Camera base vector W. Normalized it indicates the forward direction. The length is the camera focal distance.\n   55      float    jitterY                = 0.0f;             ///< Eventual camera jitter along the y axis expressed as a subpixel offset divided by screen height (positive value shifts the image up).\n   56  \n\n/home/max/dev/Falcor/src/Falcor/Scene/Importers/AssimpImporter.cpp:\n   39  \n   40      namespace {\n   41:         using BoneMeshMap = std::map<std::string, std::vector<uint32_t>>;\n   42:         using MeshInstanceList = std::vector<std::vector<const aiNode*>>;\n   43  \n   44          /** Converts specular power to roughness. Note there is no \"the conversion\".\n   ..\n   70          }\n   71  \n   72:         float3 aiCast(const aiVector3D& val) {\n   73              return float3(val.x, val.y, val.z);\n   74          }\n   ..\n   98          /** Mapping tables for different import modes.\n   99          */\n  100:         static const std::vector<TextureMapping> kTextureMappings[3] = {\n  101              // Default mappings,\n  102              {\n  ...\n  207           private:\n  208              std::map<const aiNode*, uint32_t> mAiToFalcorNodeID;\n  209:             std::map<const std::string, std::vector<const aiNode*>> mAiNodes;\n  210  \n  211          };\n  ...\n  253                  resetNegativeKeyframeTimes(pAiNode);\n  254  \n  255:                 std::vector<size_t> channels;\n  256                  for (uint32_t i = 0; i < data.getNodeInstanceCount(pAiNode->mNodeName.C_Str()); i++) {\n  257                      channels.push_back(pAnimation->addChannel(data.getFalcorNodeID(pAiNode->mNodeName.C_Str(), i)));\n  ...\n  302              Camera::SharedPtr pCamera = Camera::create();\n  303              pCamera->setPosition(aiCast(pAiCamera->mPosition));\n  304:             pCamera->setUpVector(aiCast(pAiCamera->mUp));\n  305              pCamera->setTarget(aiCast(pAiCamera->mLookAt) + aiCast(pAiCamera->mPosition));\n  306              // Some importers don't provide the aspect ratio, use default for that case.\n  ...\n  405          }\n  406  \n  407:         std::vector<float2> createTexCrdList(const aiVector3D* pAiTexCrd, uint32_t count) {\n  408:             std::vector<float2> v2(count);\n  409              for (uint32_t i = 0; i < count; i++) {\n  410                  assert(pAiTexCrd[i].z == 0);\n  ...\n  414          }\n  415  \n  416:         std::vector<uint32_t> createIndexList(const aiMesh* pAiMesh) {\n  417              const uint32_t perFaceIndexCount = pAiMesh->mFaces[0].mNumIndices;\n  418              const uint32_t indexCount = pAiMesh->mNumFaces * perFaceIndexCount;\n  419  \n  420:             std::vector<uint32_t> indices(indexCount);\n  421  \n  422              for (uint32_t i = 0; i < pAiMesh->mNumFaces; i++) {\n  ...\n  429          }\n  430  \n  431:         void loadBones(const aiMesh* pAiMesh, const ImporterData& data, std::vector<float4>& weights, std::vector<uint4>& ids) {\n  432              const uint32_t vertexCount = pAiMesh->mNumVertices;\n  433              weights.resize(vertexCount);\n  ...\n  494                  mesh.pNormals = (float3*)pAiMesh->mNormals;\n  495                  mesh.pBitangents = (float3*)pAiMesh->mBitangents;\n  496:                 const auto& texCrd = pAiMesh->HasTextureCoords(0) ? createTexCrdList(pAiMesh->mTextureCoords[0], pAiMesh->mNumVertices) : std::vector<float2>();\n  497                  mesh.pTexCrd = texCrd.size() ? texCrd.data() : nullptr;\n  498  \n  499:                 std::vector<uint4> boneIds;\n  500:                 std::vector<float4> boneWeights;\n  501  \n  502                  if (pAiMesh->HasBones()) {\n  ...\n  830                          boneMap.at(pMesh->mBones[boneID]->mName.C_Str()).push_back(meshID);\n  831                      } catch (const std::out_of_range&) {\n  832:                         std::vector<uint32_t> meshIDs;\n  833                          meshIDs.push_back(meshID);\n  834                          boneMap[pMesh->mBones[boneID]->mName.C_Str()] = meshIDs;\n  ...\n  897      bool AssimpImporter::import(std::shared_ptr<Device> pDevice, const std::string& filename, SceneBuilder& builder, const InstanceMatrices& meshInstances) {\n  898          std::string fullpath;\n  899:         if (findFileInDataDirectories(filename, fullpath) == false) {\n  900              logError(\"Can't find model file \" + filename);\n  901              return false;\n\n/home/max/dev/Falcor/src/Falcor/Scene/Importers/PythonImporter.cpp:\n   50      std::shared_ptr<Device> mpDevice;\n   51      std::string mFilename;\n   52:     std::string mDirectory;\n   53  };\n   54  \n   ..\n   61      std::string fullpath;\n   62  \n   63:     if (findFileInDataDirectories(filename, fullpath)) {\n   64:         // Get the directory of the script file\n   65:         const std::string directory = fullpath.substr(0, fullpath.find_last_of(\"/\\\\\"));\n   66  \n   67          // Load the script file\n   ..\n   74          }\n   75  \n   76:         addDataDirectory(directory);\n   77  \n   78          // Load referenced scene\n   ..\n   85          Scripting::runScriptFromFile(fullpath, context);\n   86  \n   87:         removeDataDirectory(directory);\n   88          return true;\n   89      } else {\n\n/home/max/dev/Falcor/src/Falcor/Scene/Importers/SceneImporter.cpp:\n  141      bool loadIncludeFile(const std::string& Include);\n  142  \n  143:     std::vector<glm::mat4> parseModelInstances(const rapidjson::Value& jsonVal);\n  144      bool createModel(const rapidjson::Value& jsonModel);\n  145      bool createPointLight(const rapidjson::Value& jsonLight);\n  ...\n  151      template<uint32_t VecSize>\n  152      bool getFloatVec(const rapidjson::Value& jsonVal, const std::string& desc, float vec[VecSize]);\n  153:     bool getFloatVecAnySize(const rapidjson::Value& jsonVal, const std::string& desc, std::vector<float>& vec);\n  154      rapidjson::Document mJDoc;\n  155      SceneBuilder& mBuilder;\n  156      std::shared_ptr<Device> mpDevice; \n  157      std::string mFilename;\n  158:     std::string mDirectory;\n  159  \n  160      using LightMap = std::map<std::string, Light::SharedPtr>;\n  ...\n  177  bool SceneImporterImpl::getFloatVec(const rapidjson::Value& jsonVal, const std::string& desc, float vec[VecSize]) {\n  178      if (jsonVal.IsArray() == false) {\n  179:         error(\"Trying to load a vector for \" + desc + \", but JValue is not an array\");\n  180          return false;\n  181      }\n  182  \n  183      if (jsonVal.Size() != VecSize) {\n  184:         return error(\"Trying to load a vector for \" + desc + \", but vector size mismatches. Required size is \" + std::to_string(VecSize) + \", array size is \" + std::to_string(jsonVal.Size()));\n  185      }\n  186  \n  187      for (uint32_t i = 0; i < jsonVal.Size(); i++) {\n  188          if (jsonVal[i].IsNumber() == false) {\n  189:             return error(\"Trying to load a vector for \" + desc + \", but one the elements is not a number.\");\n  190          }\n  191  \n  ...\n  195  }\n  196  \n  197: bool SceneImporterImpl::getFloatVecAnySize(const rapidjson::Value& jsonVal, const std::string& desc, std::vector<float>& vec) {\n  198      if (jsonVal.IsArray() == false) {\n  199:         return error(\"Trying to load a vector for \" + desc + \", but JValue is not an array\");\n  200      }\n  201  \n  ...\n  203      for (uint32_t i = 0; i < jsonVal.Size(); i++) {\n  204          if (jsonVal[i].IsNumber() == false) {\n  205:             return error(\"Trying to load a vector for \" + desc + \", but one the elements is not a number.\");\n  206          }\n  207  \n  ...\n  211  }\n  212  \n  213: std::vector<glm::mat4> SceneImporterImpl::parseModelInstances(const rapidjson::Value& jsonVal) {\n  214      struct ModelInstance {\n  215          float3 scaling = float3(1, 1, 1);\n  ...\n  218      };\n  219  \n  220:     std::vector<ModelInstance> instances;\n  221  \n  222      if (jsonVal.IsArray() == false) {\n  ...\n  232              std::string key(m->name.GetString());\n  233              if (key == SceneKeys::kName) continue;\n  234:             else if (key == SceneKeys::kTranslationVec) getFloatVec<3>(m->value, \"Model instance translation vector\", &instance.position[0]);\n  235:             else if (key == SceneKeys::kScalingVec)     getFloatVec<3>(m->value, \"Model instance scale vector\", &instance.scaling[0]);\n  236              else if (key == SceneKeys::kRotationVec) {\n  237:                 if (getFloatVec<3>(m->value, \"Model instance rotation vector\", &instance.rotation[0])) {\n  238                      instance.rotation = glm::radians(instance.rotation);\n  239                  }\n  ...\n  245      }\n  246  \n  247:     std::vector<glm::mat4> matrices(instances.size());\n  248      for (size_t i = 0; i < matrices.size(); i++) {\n  249          glm::mat4 T;\n  ...\n  269      }\n  270  \n  271:     std::string file = mDirectory + '/' + modelFile.GetString();\n  272      if (doesFileExist(file) == false) {\n  273          file = modelFile.GetString();\n  ...\n  295      }\n  296  \n  297:     std::vector<glm::mat4> instances;\n  298  \n  299      // Loop over the other members\n  ...\n  492              pAreaLight->setIntensity(intensity);\n  493          } else if (key == SceneKeys::kTranslationVec) {\n  494:             if (getFloatVec<3>(value, \"Area light translation vector\", &translation[0]) == false) {\n  495                  return false;\n  496              }\n  497          } else if (key == SceneKeys::kScalingVec) {\n  498:             if (getFloatVec<3>(value, \"Area light scale vector\", &scaling[0]) == false) {\n  499                  return false;\n  500              }\n  501          } else if (key == SceneKeys::kRotationVec) {\n  502:             if (getFloatVec<3>(value, \"Area light rotation vector\", &rotation[0]) == false) {\n  503                  return false;\n  504              }\n  ...\n  573          // Check if path is relative, if not, assume full path\n  574          std::string imagePath = lightProbe[SceneKeys::kFilename].GetString();\n  575:         std::string actualPath = mDirectory + '/' + imagePath;\n  576          if (doesFileExist(actualPath) == false) {\n  577              actualPath = imagePath;\n  ...\n  674          } else if (key == SceneKeys::kCamUp) {\n  675              float3 up;\n  676:             if (getFloatVec<3>(value, \"Camera's up vector\", &up[0]) == false) {\n  677                  return false;\n  678              }\n  679:             pCamera->setUpVector(up);\n  680          } else if (key == SceneKeys::kCamFocalLength) // Version 2 \n  681          {\n  ...\n  729      mFilename = filename;\n  730  \n  731:     if (findFileInDataDirectories(filename, fullpath)) {\n  732          // Load the file\n  733          std::string jsonData = readFile(fullpath);\n  734          rapidjson::StringStream JStream(jsonData.c_str());\n  735  \n  736:         // Get the file directory\n  737          auto last = fullpath.find_last_of(\"/\\\\\");\n  738:         mDirectory = fullpath.substr(0, last);\n  739  \n  740          // create the DOM\n  ...\n  805      }\n  806  \n  807:     std::string filename = mDirectory + '/' + jsonVal.GetString();\n  808      if (doesFileExist(filename) == false) {\n  809:         if (findFileInDataDirectories(jsonVal.GetString(), filename) == false) {\n  810              return error(\"Can't find environment map file \" + std::string(jsonVal.GetString()));\n  811          }\n  ...\n  828  bool SceneImporterImpl::loadIncludeFile(const std::string& include) {\n  829      // Find the file\n  830:     std::string fullpath = mDirectory + '/' + include;\n  831      if (doesFileExist(fullpath) == false) {\n  832:         // Look in the data directories\n  833:         if (findFileInDataDirectories(include, fullpath) == false) {\n  834              return error(\"Can't find include file \" + include);\n  835          }\n\n/home/max/dev/Falcor/src/Falcor/Scene/Lights/Light.cpp:\n  185          if (!(glm::length(dir) > 0.f)) // NaNs propagate\n  186          {\n  187:             logWarning(\"Can't set light direction to zero length vector. Ignoring call.\");\n  188              return;\n  189          }\n  ...\n  222          if (!(glm::length(dir) > 0.f)) // NaNs propagate\n  223          {\n  224:             logWarning(\"Can't set light direction to zero length vector. Ignoring call.\");\n  225              return;\n  226          }\n\n/home/max/dev/Falcor/src/Falcor/Scene/Lights/Light.h:\n  247  \n  248          /** Set light source scaling\n  249:             \\param[in] scale x,y,z scaling factors\n  250          */\n  251          void setScaling(float3 scale) { mScaling = scale; }\n\n/home/max/dev/Falcor/src/Falcor/Scene/Lights/LightData.slang:\n   57  \n   58      // Extra parameters for analytic area lights\n   59:     float3   tangent            = float3(0);        ///< Tangent vector of the light shape\n   60      float    surfaceArea        = 0.f;              ///< Surface area of the light shape\n   61:     float3   bitangent          = float3(0);        ///< Bitangent vector of the light shape\n   62      float    pad1;\n   63      float4x4 transMat           = {};               ///< Transformation matrix of the light shape, from local to world space.\n\n/home/max/dev/Falcor/src/Falcor/Scene/Lights/Lights.slang:\n  126      float a = 1.02341 * ggxAlpha - 1.51174;\n  127      float b = -0.511705 * ggxAlpha + 0.755868;\n  128:     float factor = saturate((saturate(dot(N, V)) * a + b) * ggxAlpha);\n  129:     return normalize(lerp(N, V, factor));\n  130  }\n  131  \n  ...\n  133  {\n  134      float smoothness = 1 - ggxAlpha;\n  135:     float factor = smoothness * (sqrt(smoothness) + ggxAlpha);\n  136:     return normalize(lerp(N, R, factor));\n  137  }\n  138  \n  ...\n  201      LightSample ls;\n  202  \n  203:     // Calculate the reflection vector\n  204      ls.L = reflect(-sd.V, sd.N);\n  205  \n\n/home/max/dev/Falcor/src/Falcor/Scene/Material/BRDF.slang:\n   69  {\n   70      float energyBias = lerp(0, 0.5, sd.linearRoughness);\n   71:     float energyFactor = lerp(1, 1.0 / 1.51, sd.linearRoughness);\n   72  \n   73      float fd90 = energyBias + 2 * ls.LdotH * ls.LdotH * sd.linearRoughness;\n   ..\n   75      float lightScatter = fresnelSchlick(fd0, fd90, ls.NdotL).r;\n   76      float viewScatter = fresnelSchlick(fd0, fd90, sd.NdotV).r;\n   77:     return (viewScatter * lightScatter * energyFactor * M_1_PI) * sd.diffuse.rgb;\n   78  }\n   79  \n\n/home/max/dev/Falcor/src/Falcor/Scene/Material/Material.cpp:\n  106          }\n  107  \n  108:         float emissiveFactor = getEmissiveFactor();\n  109:         if (widget.var(\"Emissive factor\", emissiveFactor, 0.f, std::numeric_limits<float>::max(), 0.01f))\n  110:             setEmissiveFactor(emissiveFactor);\n  111  \n  112          float IoR = getIndexOfRefraction();\n  ...\n  262      }\n  263  \n  264:     void Material::setEmissiveFactor(float factor)\n  265      {\n  266:         if (mData.emissiveFactor != factor)\n  267          {\n  268:             mData.emissiveFactor = factor;\n  269              markUpdates(UpdateFlags::DataChanged);\n  270              updateEmissiveType();\n  ...\n  315          compare_field(specular);\n  316          compare_field(emissive);\n  317:         compare_field(emissiveFactor);\n  318          compare_field(alphaThreshold);\n  319          compare_field(IoR);\n  ...\n  369      void Material::updateEmissiveType()\n  370      {\n  371:         setFlags(PACK_EMISSIVE_TYPE(mData.flags, getChannelMode(mResources.emissive != nullptr, mData.emissive * mData.emissiveFactor)));\n  372      }\n  373  \n  ...\n  400          material.property(\"indexOfRefraction\", &Material::getIndexOfRefraction, &Material::setIndexOfRefraction);\n  401          material.property(\"emissiveColor\", &Material::getEmissiveColor, &Material::setEmissiveColor);\n  402:         material.property(\"emissiveFactor\", &Material::getEmissiveFactor, &Material::setEmissiveFactor);\n  403          material.property(\"alphaMode\", &Material::getAlphaMode, &Material::setAlphaMode);\n  404          material.property(\"alphaThreshold\", &Material::getAlphaThreshold, &Material::setAlphaThreshold);\n\n/home/max/dev/Falcor/src/Falcor/Scene/Material/Material.h:\n  197          void setEmissiveColor(const float3& color);\n  198  \n  199:         /** Set the emissive factor\n  200          */\n  201:         void setEmissiveFactor(float factor);\n  202  \n  203          /** Get the emissive color\n  ...\n  205          const float3& getEmissiveColor() const { return mData.emissive; }\n  206  \n  207:         /** Get the emissive factor\n  208          */\n  209:         float getEmissiveFactor() const { return mData.emissiveFactor; }\n  210  \n  211          /** Set the alpha mode\n\n/home/max/dev/Falcor/src/Falcor/Scene/Material/MaterialData.slang:\n   60      float4   specular               = float4(0);        ///< Material specular channel encoding occlusion (R), roughness (G), metallic (B) in the default MetalRough mode. In SpecGloss mode specular color (RGB) and glossiness (A).\n   61      float3   emissive               = float3(0, 0, 0);  ///< Emissive color (RGB).\n   62:     float    emissiveFactor         = 1.f;              ///< Multiplication factor for the emissive color to control light intensity.\n   63  \n   64      float    alphaThreshold         = 0.5f;             ///< Alpha threshold, only used in case the alpha mode is mask.\n\n/home/max/dev/Falcor/src/Falcor/Scene/ParticleSystem/ParticleSystem.cpp:\n   71          uint3 simThreads;\n   72  \n   73:         simThreads = pSimulateCs->getReflector()->getThreadGroupSize();\n   74          mSimulateThreads = simThreads.x * simThreads.y * simThreads.z;\n   75  \n   ..\n   95          // Init data in dead list buffer\n   96          mpDeadList->getUAVCounter()->setBlob(&mMaxParticles, 0, sizeof(uint32_t));\n   97:         std::vector<uint32_t> indices;\n   98          indices.resize(mMaxParticles);\n   99          uint32_t counter = 0;\n  ...\n  114          //Vars\n  115          //emit\n  116:         mEmitResources.pVars = ComputeVars::create(device, pEmitCs->getReflector());\n  117          mEmitResources.pVars->setBuffer(\"deadList\", mpDeadList);\n  118          mEmitResources.pVars->setBuffer(\"particlePool\", mpParticlePool);\n  ...\n  120          mEmitResources.pVars->setBuffer(\"numAlive\", mpAliveList->getUAVCounter());\n  121          //simulate\n  122:         mSimulateResources.pVars = ComputeVars::create(device, pSimulateCs->getReflector());\n  123          mSimulateResources.pVars->setBuffer(\"deadList\", mpDeadList);\n  124          mSimulateResources.pVars->setBuffer(\"particlePool\", mpParticlePool);\n  ...\n  135  \n  136          //draw\n  137:         mDrawResources.pVars = GraphicsVars::create(device, pDrawProgram->getReflector());\n  138          mDrawResources.pVars->setBuffer(\"aliveList\", mpAliveList);\n  139          mDrawResources.pVars->setBuffer(\"particlePool\", mpParticlePool);\n  ...\n  154  \n  155          // Save bind locations for resourced updated during draw\n  156:         mBindLocations.simulateCB = pSimulateCs->getReflector()->getDefaultParameterBlock()->getResourceBinding(\"PerFrame\");\n  157:         mBindLocations.drawCB = pDrawProgram->getReflector()->getDefaultParameterBlock()->getResourceBinding(\"PerFrame\");\n  158:         mBindLocations.emitCB = pEmitCs->getReflector()->getDefaultParameterBlock()->getResourceBinding(\"PerEmit\");\n  159      }\n  160  \n  161      void ParticleSystem::emit(RenderContext* pCtx, uint32_t num) {\n  162:         std::vector<Particle> emittedParticles;\n  163          emittedParticles.resize(num);\n  164          for (uint32_t i = 0; i < num; ++i) {\n  ...\n  276  \n  277          //Vars and state\n  278:         mSortResources.pVars = ComputeVars::create(pDevice, pSortCs->getReflector());\n  279          mSortResources.pState = ComputeState::create(pDevice);\n  280          mSortResources.pState->setProgram(pSortCs);\n\n/home/max/dev/Falcor/src/Falcor/Scene/ParticleSystem/ParticleSystem.h:\n  222          void initSortResources(std::shared_ptr<Device> pDevice);\n  223          bool mShouldSort;\n  224:         std::vector<SortData> mSortDataReset;\n  225          struct SortResources\n  226          {\n\n/home/max/dev/Falcor/src/Falcor/Scene/ParticleSystem/ParticleVertex.vs.slang:\n   38  };\n   39  \n   40: float2 vectorRotate(float2 vec, float sinAngle, float cosAngle)\n   41  {\n   42      float2 result;\n   ..\n   73  \n   74      float4 viewPos = mul(float4(p.pos, 1.f), frameData.view);\n   75:     float2 rotOffset = vectorRotate(float2(xOffset[billboardIndex], yOffset[billboardIndex]), sin(p.rot), cos(p.rot));\n   76      viewPos.xy += float2(p.scale, p.scale) * rotOffset;\n   77      output.pos = mul(viewPos, frameData.proj);\n\n/home/max/dev/Falcor/src/Falcor/Scene/Scene.cpp:\n  192      GraphicsProgram::SharedPtr pProgram = GraphicsProgram::createFromFile(mpDevice, \"Scene/SceneBlock.slang\", \"\", \"main\");\n  193      pProgram->addDefines(getSceneDefines());\n  194:     ParameterBlockReflection::SharedConstPtr pReflection = pProgram->getReflector()->getParameterBlock(kParameterBlockName);\n  195  \n  196      assert(pReflection);\n  ...\n  251  void Scene::updateBounds() {\n  252      const auto& globalMatrices = mpAnimationController->getGlobalMatrices();\n  253:     std::vector<BoundingBox> instanceBBs;\n  254      instanceBBs.reserve(mMeshInstanceData.size());\n  255  \n  ...\n  320  template<>\n  321  void Scene::AnimatedObject<Camera>::setIntoObject(const float3& pos, const float3& up, const float3& lookAt) {\n  322:     pObject->setUpVector(up);\n  323      pObject->setPosition(pos);\n  324      pObject->setTarget(pos + lookAt);\n  ...\n  543      mCamera.pObject->setPosition(mSceneBB.center);\n  544      mCamera.pObject->setTarget(mSceneBB.center + float3(0, 0, -1));\n  545:     mCamera.pObject->setUpVector(float3(0, 1, 0));\n  546  \n  547      if(resetDepthRange) {\n  ...\n  554  void Scene::addViewpoint() {\n  555      auto camera = getCamera();\n  556:     addViewpoint(camera->getPosition(), camera->getTarget(), camera->getUpVector());\n  557  }\n  558  \n  ...\n  581      camera->setPosition(mViewpoints[index].position);\n  582      camera->setTarget(mViewpoints[index].target);\n  583:     camera->setUpVector(mViewpoints[index].up);\n  584      mCurrentViewpoint = index;\n  585  }\n  ...\n  610  \n  611  void Scene::createDrawList() {\n  612:     std::vector<D3D12_DRAW_INDEXED_ARGUMENTS> drawClockwiseMeshes, drawCounterClockwiseMeshes;\n  613      auto pMatricesBuffer = mpSceneBlock->getBuffer(\"worldMatrices\");\n  614      const glm::mat4* matrices = (glm::mat4*)pMatricesBuffer->map(Buffer::MapType::Read); // #SCENEV2 This will cause the pipeline to flush and sync, but it's probably not too bad as this only happens once\n  ...\n  653  \n  654      // Build a list of mesh instance indices per mesh.\n  655:     std::vector<std::vector<size_t>> instanceLists(mMeshDesc.size());\n  656      for (size_t i = 0; i < mMeshInstanceData.size(); i++) {\n  657          assert(mMeshInstanceData[i].meshID < instanceLists.size());\n  ...\n  660  \n  661      // The non-instanced meshes are grouped based on what global matrix ID their transform is.\n  662:     std::unordered_map<uint32_t, std::vector<uint32_t>> nodeToMeshList;\n  663      for (uint32_t meshId = 0; meshId < (uint32_t)instanceLists.size(); meshId++) {\n  664          const auto& instanceList = instanceLists[meshId];\n  ...\n  682          const auto& instanceList = instanceLists[meshId];\n  683          if (instanceList.size() == 1) continue; // Only processing instanced meshes here\n  684:         mMeshGroups.push_back({ std::vector<uint32_t>({ meshId }) });\n  685      }\n  686  \n  687      // Calculate mapping from new mesh instance ID to existing instance index.\n  688      // Here, just append existing instance ID's in order they appear in the mesh groups.\n  689:     std::vector<size_t> instanceMapping;\n  690      for (const auto& meshGroup : mMeshGroups) {\n  691          for (const uint32_t meshId : meshGroup.meshList) {\n  ...\n  705      // Now reorder mMeshInstanceData based on the new mapping.\n  706      // We'll make a copy of the existing data first, and the populate the array.\n  707:     std::vector<MeshInstanceData> prevInstanceData = mMeshInstanceData;\n  708      for (size_t i = 0; i < mMeshInstanceData.size(); i++) {\n  709          assert(instanceMapping[i] < prevInstanceData.size());\n  ...\n  841  }\n  842  \n  843: void Scene::fillInstanceDesc(std::vector<D3D12_RAYTRACING_INSTANCE_DESC>& instanceDescs, uint32_t rayCount, bool perMeshHitEntry) {\n  844      instanceDescs.clear();\n  845      uint32_t instanceContributionToHitGroupIndex = 0;\n\n/home/max/dev/Falcor/src/Falcor/Scene/Scene.h:\n   80          using SharedPtr = std::shared_ptr<Scene>;\n   81          using ConstSharedPtrRef = const SharedPtr&;\n   82:         using LightList = std::vector<Light::SharedPtr>;\n   83          static const uint32_t kMaxBonesPerVertex = 4;\n   84          static const FileDialogFilterVec kFileExtensionFilters;\n   ..\n   92              None                    = 0x0,\n   93              UserRasterizerState     = 0x1,  ///< Use the rasterizer state currently bound to `pState`. If this flag is not set, the default rasterizer state will be used.\n   94:                                             ///< Note that we need to change the rasterizer state during rendering because some meshes have a negative scale factor, and hence the triangles will have a different winding order.\n   95                                              ///< If such meshes exist, overriding the state may result in incorrect rendering output\n   96          };\n   ..\n  410              #SCENE TODO: Add argument to build descs based off a draw list\n  411          */\n  412:         void fillInstanceDesc(std::vector<D3D12_RAYTRACING_INSTANCE_DESC>& instanceDescs, uint32_t rayCount, bool perMeshHitEntry);\n  413  \n  414          /** Generate top level acceleration structure for the scene. Automatically determines whether to build or refit.\n  ...\n  463  \n  464          struct MeshGroup {\n  465:             std::vector<uint32_t> meshList;     ///< List of meshId's that are part of the group.\n  466          };\n  467  \n  468:         // #SCENE We don't need those vectors on the host\n  469:         std::vector<MeshDesc> mMeshDesc;                    ///< Copy of GPU buffer (mpMeshes)\n  470:         std::vector<MeshInstanceData> mMeshInstanceData;    ///< Copy of GPU buffer (mpMeshInstances)\n  471:         std::vector<MeshGroup> mMeshGroups;                 ///< Groups of meshes with identical transforms. Each group maps to a BLAS for ray tracing.\n  472:         std::vector<Node> mSceneGraph;                      ///< For each index i, the array element indicates the parent node. Indices are in relation to mLocalToWorldMatrices\n  473  \n  474:         std::vector<Material::SharedPtr> mMaterials;        ///< Bound to parameter block\n  475:         std::vector<AnimatedObject<Light>> mLights;         ///< Bound to parameter block\n  476          LightCollection::SharedPtr mpLightCollection;       ///< Bound to parameter block\n  477          LightProbe::SharedPtr mpLightProbe;                 ///< Bound to parameter block\n  ...\n  479  \n  480          // Scene Metadata (CPU Only)\n  481:         std::vector<BoundingBox> mMeshBBs;                          ///< Bounding boxes for meshes (not instances)\n  482:         std::vector<std::vector<uint32_t>> mMeshIdToInstanceIds;    ///< Mapping of what instances belong to which mesh\n  483          BoundingBox mSceneBB;                                       ///< Bounding boxes of the entire scene\n  484:         std::vector<bool> mMeshHasDynamicData;                      ///< Whether a Mesh has dynamic data, meaning it is skinned\n  485          GeometryStats mGeometryStats;                               ///< Geometry statistics for the scene.\n  486  \n  ...\n  504              float3 up;\n  505          };\n  506:         std::vector<Viewpoint> mViewpoints;\n  507          uint32_t mCurrentViewpoint = 0;\n  508  \n  ...\n  517  \n  518  #ifdef FALCOR_D3D12\n  519:         std::vector<D3D12_RAYTRACING_INSTANCE_DESC> mInstanceDescs; ///< Shared between TLAS builds to avoid reallocating CPU memory\n  520  \n  521          struct TlasData {\n  ...\n  536  \n  537              D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO prebuildInfo;\n  538:             std::vector<D3D12_RAYTRACING_GEOMETRY_DESC> geomDescs;\n  539              bool hasSkinnedMesh = false;                ///< Whether the BLAS contains a skinned mesh, which means the BLAS may need to be updated\n  540              UpdateMode updateMode = UpdateMode::Refit;  ///< Update mode this BLAS was created with.\n  541          };\n  542  \n  543:         std::vector<BlasData> mBlasData;    ///< All data related to the scene's BLASes\n  544  #endif\n  545          \n\n/home/max/dev/Falcor/src/Falcor/Scene/Scene.slang:\n  239      {\n  240          // Compute face normal in world space.\n  241:         // The length of the vector is twice the triangle area since we're in world space.\n  242          // Note that this is not true if the normal is transformed using the inverse-transpose.\n  243          float3 e[2];\n  ...\n  484          MaterialData m = materials[materialID];\n  485          ExplicitLodTextureSampler lod = { 0.0 };\n  486:         return sampleTexture(mr.emissive, mr.samplerState, uv, float4(m.emissive, 1.0), EXTRACT_EMISSIVE_TYPE(m.flags), lod).rgb * m.emissiveFactor;\n  487      }\n  488  };\n\n/home/max/dev/Falcor/src/Falcor/Scene/SceneBuilder.cpp:\n   43          class MikkTSpaceWrapper {\n   44           public:\n   45:             static std::vector<float3> generateBitangents(const float3* pPositions, const float3* pNormals, const float2* pTexCrd, const uint32_t* pIndices, size_t vertexCount, size_t indexCount)\n   46              {\n   47                  if (!pNormals || !pPositions || !pTexCrd || !pIndices) {\n   ..\n   51                      if (pTexCrd) logWarning(\"Can't generate tangent space. The mesh doesn't have texture coordinates\");\n   52                      if (pIndices) logWarning(\"Can't generate tangent space. The mesh doesn't have indices\");\n   53:                     return std::vector<float3>(vertexCount, float3(0, 0, 0));\n   54                  }\n   55  \n   ..\n   70                  {\n   71                      logError(\"Failed to generate MikkTSpace tangents\");\n   72:                     return std::vector<float3>(vertexCount, float3(0, 0, 0));\n   73                  }\n   74  \n   ..\n   84              const uint32_t* mpIndices;\n   85              size_t mFaceCount;\n   86:             std::vector<float3> mBitangents;\n   87              int32_t getFaceCount() const { return (int32_t)mFaceCount; }\n   88              int32_t getIndex(int32_t face, int32_t vert) { return mpIndices[face * 3 + vert]; }\n   ..\n  201  \n  202          // Generate tangent space if that's required\n  203:         std::vector<float3> bitangents;\n  204          if (!is_set(mFlags, Flags::UseOriginalTangentSpace) || !mesh.pBitangents) {\n  205              bitangents = MikkTSpaceWrapper::generateBitangents(mesh.pPositions, mesh.pNormals, mesh.pTexCrd, mesh.pIndices, mesh.vertexCount, mesh.indexCount);\n  ...\n  293          pVBs[Scene::kStaticDataBufferIndex] = pStaticBuffer;\n  294          pVBs[Scene::kPrevVertexBufferIndex] = pPrevBuffer;\n  295:         std::vector<uint16_t> drawIDs(drawCount);\n  296          for (uint32_t i = 0; i < drawCount; i++) drawIDs[i] = i;\n  297          pVBs[Scene::kDrawIdBufferIndex] = Buffer::create(pDevice, drawCount * sizeof(uint16_t), ResourceBindFlags::Vertex, Buffer::CpuAccess::None, drawIDs.data());\n\n/home/max/dev/Falcor/src/Falcor/Scene/SceneBuilder.h:\n   83      };\n   84  \n   85:     using InstanceMatrices = std::vector<glm::mat4>;\n   86  \n   87      /** Construct a new object\n   ..\n  178          InternalNode() = default;\n  179          InternalNode(const Node& n) : Node(n) {}\n  180:         std::vector<uint32_t> children;\n  181:         std::vector<uint32_t> meshes;\n  182      };\n  183  \n  ...\n  192          uint32_t vertexCount = 0;\n  193          bool hasDynamicData = false;\n  194:         std::vector<uint32_t> instances; // Node IDs\n  195:         std::vector<Animation::SharedPtr> animations;\n  196      };\n  197  \n  198      // Geometry data\n  199      struct BuffersData {\n  200:         std::vector<uint32_t> indices;\n  201:         std::vector<PackedStaticVertexData> staticData;\n  202:         std::vector<DynamicVertexData> dynamicData;\n  203      } mBuffersData;\n  204  \n  205:     using SceneGraph = std::vector<InternalNode>;\n  206:     using MeshList = std::vector<MeshSpec>;\n  207  \n  208      bool mDirty = true;\n  ...\n  215  \n  216      MeshList mMeshes;\n  217:     std::vector<Material::SharedPtr> mMaterials;\n  218      std::unordered_map<const Material*, uint32_t> mMaterialToId;\n  219  \n  220      Scene::AnimatedObject<Camera> mCamera;\n  221:     std::vector<Scene::AnimatedObject<Light>> mLights;\n  222      LightProbe::SharedPtr mpLightProbe;\n  223      Texture::SharedPtr mpEnvMap;\n\n/home/max/dev/Falcor/src/Falcor/Scene/Shading.slang:\n   53  }\n   54  \n   55: ShadingResult evalMaterial(ShadingData sd, LightData light, float shadowFactor)\n   56  {\n   57      ShadingResult sr = initShadingResult();\n   ..\n   73      sr.color.rgb += sr.specular;\n   74  \n   75:     // Apply the shadow factor\n   76:     sr.color.rgb *= shadowFactor;\n   77  \n   78      return sr;\n\n/home/max/dev/Falcor/src/Falcor/Scene/ShadingData.slang:\n  231      sd.doubleSided = EXTRACT_DOUBLE_SIDED(md.flags);\n  232  \n  233:     // Check that bitangent exists, otherwise leave the vectors at zero to avoid NaNs.\n  234      const bool validTangentSpace = dot(v.bitangentW, v.bitangentW) > 0.f;\n  235      if (validTangentSpace)\n  ...\n  283      if (sd.frontFacing)\n  284      {\n  285:         sd.emissive = sampleTexture(mr.emissive, mr.samplerState, v.texC, float4(md.emissive, 1), EXTRACT_EMISSIVE_TYPE(md.flags), lod).rgb * md.emissiveFactor;\n  286      }\n  287  \n  ...\n  378          sd.NdotV = dot(sd.N, sd.V);\n  379  \n  380:         // Check that bitangent exists, otherwise leave the vectors at zero to avoid NaNs.\n  381          const bool validTangentSpace = dot(v.bitangentW, v.bitangentW) > 0.f;\n  382          if (validTangentSpace)\n\n/home/max/dev/Falcor/src/Falcor/Scene/TextureSampler.slang:\n  127      texture level of detail, and must implement the `ITextureSampler` interface.\n  128  */\n  129: float4 sampleTexture<L:ITextureSampler>(Texture2D t, SamplerState s, float2 uv, float4 factor, uint mode, L lod)\n  130  {\n  131      if (mode == ChannelTypeUnused) return 0;\n  132:     if (mode == ChannelTypeConst) return factor;\n  133      // else mode == ChannelTypeTexture\n  134      return lod.sampleTexture(t, s, uv);\n\n/home/max/dev/Falcor/src/Falcor/Testing/UnitTest.cpp:\n   60  \n   61      Status status;\n   62:     std::vector<std::string> messages;\n   63      uint64_t elapsedMS = 0;\n   64  };\n   ..\n   68       initialization fiasco.)\n   69   */\n   70: std::vector<Test>* testRegistry;\n   71  \n   72  }   // end anonymous namespace\n   ..\n   76                           const std::string& skipMessage, CPUTestFunc func)\n   77      {\n   78:         if (!testRegistry) testRegistry = new std::vector<Test>;\n   79          testRegistry->push_back({ filename, name, skipMessage, std::move(func), {} });\n   80      }\n   ..\n   83                           const std::string& skipMessage, GPUTestFunc func)\n   84      {\n   85:         if (!testRegistry) testRegistry = new std::vector<Test>;\n   86          testRegistry->push_back({ filename, name, skipMessage, {}, std::move(func) });\n   87      }\n   ..\n  139          if (testRegistry == nullptr) return 0;\n  140  \n  141:         std::vector<Test> tests;\n  142  \n  143          // Filter tests.\n  ...\n  198      void GPUUnitTestContext::createVars() {\n  199          // Create shader variables.\n  200:         ProgramReflection::SharedConstPtr pReflection = mpProgram->getReflector();\n  201          mpVars = ComputeVars::create(mpDevice, pReflection);\n  202          assert(mpVars);\n\n/home/max/dev/Falcor/src/Falcor/Testing/UnitTest.h:\n   36  #include <tuple>\n   37  #include <type_traits>\n   38: #include <vector>\n   39  \n   40  #include \"Falcor/Falcor.h\"\n   ..\n   87          }\n   88  \n   89:         std::vector<std::string> getFailureMessages() const { return mFailureMessages; }\n   90  \n   91          int mNumFailures = 0;\n   92  \n   93       private:\n   94:         std::vector<std::string> mFailureMessages;\n   95      };\n   96  \n   ..\n  213      class StreamSink {\n  214       public:\n  215:         /** We need to declare this constructor in order to return\n  216              StreamSinks as rvalues from functions because we've declared a\n  217:             StreamSink destructor below.\n  218           */\n  219          StreamSink(StreamSink &&) = default;\n  ...\n  222              If a non-nullptr UnitTestContext is provided, the values printed\n  223              will be accumulated and passed to the context's reportFailure()\n  224:             method when the StreamSink destructor runs.\n  225          */\n  226          StreamSink(UnitTestContext* ctx) : mpCtx(ctx) {}\n  ...\n  365      The macro defines an instance of the |CPUUnitTestRegisterer| class,\n  366      which in turn registers the test with the test framework when its\n  367:     constructor executes at program startup time. Next, it starts the\n  368      definition of the testing function, up to the point at which\n  369      the user should supply an open brace and start writing code.\n\n/home/max/dev/Falcor/src/Falcor/Utils/Algorithm/ComputeParallelReduction.cpp:\n   46  \n   47          // Check assumptions on thread group sizes. The initial pass is a 2D dispatch, the final pass a 1D.\n   48:         assert(mpInitialProgram->getReflector()->getThreadGroupSize().z == 1);\n   49:         assert(mpFinalProgram->getReflector()->getThreadGroupSize().y == 1 && mpFinalProgram->getReflector()->getThreadGroupSize().z == 1);\n   50  \n   51          mpState = ComputeState::create(pDevice);\n   ..\n   58  \n   59              // Buffer 1 has one element per N elements in buffer 0.\n   60:             const uint32_t numElem1 = div_round_up(elementCount, mpFinalProgram->getReflector()->getThreadGroupSize().x);\n   61              if (mpBuffers[1] == nullptr || mpBuffers[1]->getElementCount() < numElem1) {\n   62                  mpBuffers[1] = Buffer::createTyped<uint4>(mpDevice, numElem1);\n   ..\n  108          assert(resolution.x > 0 && resolution.y > 0);\n  109  \n  110:         const uint2 numTiles = div_round_up(resolution, uint2(mpInitialProgram->getReflector()->getThreadGroupSize()));\n  111          allocate(numTiles.x * numTiles.y);\n  112          assert(mpBuffers[0]);\n  ...\n  129  \n  130          mpState->setProgram(mpInitialProgram);\n  131:         uint3 numGroups = div_round_up(uint3(resolution.x, resolution.y, 1), mpInitialProgram->getReflector()->getThreadGroupSize());\n  132          pRenderContext->dispatch(mpState.get(), mpVars.get(), numGroups);\n  133  \n  134:         // Final pass(es): Reduction by a factor N for each pass.\n  135          uint elems = numTiles.x * numTiles.y;\n  136          uint inputsBufferIndex = 0;\n  ...\n  142  \n  143              mpState->setProgram(mpFinalProgram);\n  144:             uint32_t numGroups = div_round_up(elems, mpFinalProgram->getReflector()->getThreadGroupSize().x);\n  145              pRenderContext->dispatch(mpState.get(), mpVars.get(), { numGroups, 1, 1 });\n  146  \n\n/home/max/dev/Falcor/src/Falcor/Utils/Algorithm/ComputeParallelReduction.h:\n   30  #include \"Core/Program/ProgramVars.h\"\n   31  #include \"Core/State/ComputeState.h\"\n   32: #include \"Utils/Math/Vector.h\"\n   33  \n   34  namespace Falcor {\n\n/home/max/dev/Falcor/src/Falcor/Utils/Algorithm/DirectedGraph.h:\n  133          private:\n  134              friend DirectedGraph;\n  135:             std::vector<uint32_t> mIncomingEdges;\n  136:             std::vector<uint32_t> mOutgoingEdges;\n  137          };\n  138  \n  ...\n  193  \n  194          template<bool removeSrc>\n  195:         void findEdgesToRemove(std::vector<uint32_t>& edges, uint32_t nodeToRemove, std::unordered_set<uint32_t>& removedEdges)\n  196          {\n  197              for (size_t i = 0; i < edges.size(); i++)\n\n/home/max/dev/Falcor/src/Falcor/Utils/Algorithm/DirectedGraphTraversal.h:\n   52          typename DirectedGraph::SharedPtr mpGraph;\n   53          Flags mFlags;\n   54:         std::vector<bool> mVisited;\n   55  \n   56          bool reset(uint32_t rootNode)\n   ..\n  148      using DirectedGraphBfsTraversal = DirectedGraphTraversalTemplate<BfsArgs>;\n  149  \n  150:     class DirectedGraphLoopDetector\n  151      {\n  152      public:\n  ...\n  169      {\n  170      public:\n  171:         static std::vector<uint32_t> sort(DirectedGraph* pGraph)\n  172          {\n  173              DirectedGraphTopologicalSort ts(pGraph);\n  ...\n  180              }\n  181  \n  182:             std::vector<uint32_t> result;\n  183              result.reserve(ts.mStack.size());\n  184              while (ts.mStack.empty() == false)\n  ...\n  193          DirectedGraph* mpGraph;\n  194          std::stack<uint32_t> mStack;\n  195:         std::vector<bool> mVisited;\n  196  \n  197          void sortInternal(uint32_t node)\n  ...\n  212      };\n  213  \n  214:     namespace DirectedGraphPathDetector\n  215      {\n  216          inline bool hasPath(const DirectedGraph::SharedPtr& pGraph, uint32_t from, uint32_t to)\n\n/home/max/dev/Falcor/src/Falcor/Utils/Algorithm/ParallelReduction.cs.slang:\n   44  // Typedef the data format as 'DataType'. The format is specified from the host.\n   45  #if FORMAT_TYPE == FORMAT_TYPE_FLOAT\n   46: typedef vector<float, 4> DataType;\n   47  #elif FORMAT_TYPE == FORMAT_TYPE_SINT\n   48: typedef vector<int, 4> DataType;\n   49  #elif FORMAT_TYPE == FORMAT_TYPE_UINT\n   50: typedef vector<uint, 4> DataType;\n   51  #endif\n   52  \n\n/home/max/dev/Falcor/src/Falcor/Utils/Algorithm/ParallelReduction.h:\n   63          Fbo::SharedPtr pFbo;\n   64      };\n   65:     std::vector<ResultData> mResultData;\n   66  \n   67      uint32_t mCurFbo = 0;\n   ..\n   69      Sampler::SharedPtr mpPointSampler;\n   70  \n   71:     std::vector<Fbo::SharedPtr> mpTmpResultFbo;\n   72      static const uint32_t kTileSize = 16;\n   73  \n\n/home/max/dev/Falcor/src/Falcor/Utils/Algorithm/PrefixSum.cs.slang:\n   32      GROUP_SIZE <N>      Thread group size, must be a power-of-two <= 1024.\n   33  \n   34:     The implementation is based on G. Blelloch, \"Vector Models for Data-Parallel Computing\", MIT Press, 1990.\n   35      See CUDA code: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch39.html\n   36      See also: http://www.umiacs.umd.edu/~ramani/cmsc828e_gpusci/ScanTalk.pdf\n\n/home/max/dev/Falcor/src/Falcor/Utils/AlignedAllocator.h:\n   67          }\n   68  \n   69:         /** Allocates an object of given type and executes its constructor.\n   70:             \\param[in] args Arguments to pass to the constructor.\n   71              \\return pointer to allocated object.\n   72          */\n   ..\n   80  \n   81          /** Allocates an object of given type, potentially including additional memory at\n   82:             the end of it, and executes its constructor.\n   83              \\param[in] size Amount of memory to allocate. Must be >= sizeof(T).\n   84:             \\param[in] args Arguments to pass to the constructor.\n   85              \\return pointer to allocated object.\n   86          */\n   ..\n  152          int mMinAlignment = 16;\n  153          int mCacheLineSize = 128;\n  154:         std::vector<uint8_t> mBuffer;\n  155      };\n  156  }\n\n/home/max/dev/Falcor/src/Falcor/Utils/ArgList.cpp:\n   89  \n   90      void ArgList::addArg(const std::string& arg) {\n   91:         mMap.insert(std::make_pair(arg, std::vector<Arg>()));\n   92      }\n   93  \n   ..\n  100      }\n  101  \n  102:     std::vector<ArgList::Arg> ArgList::getValues(const std::string& key) const {\n  103          try  {\n  104              return mMap.at(key);\n  105          } catch(const std::out_of_range&) {\n  106:             return std::vector<ArgList::Arg>();\n  107          }\n  108      }\n\n/home/max/dev/Falcor/src/Falcor/Utils/ArgList.h:\n   93      bool argExists(const std::string& key) const;\n   94  \n   95:     /** Return the values associated with an arg, or an empty vector if none\n   96          \\param key the key to get the values for \n   97      */\n   98:     std::vector<Arg> getValues(const std::string& key) const;\n   99  \n  100      /** Return the value associated with key, or asserts if key has no values or multiple values\n  ...\n  104  \n  105   private:\n  106:     std::unordered_map<std::string, std::vector<Arg>> mMap;\n  107  };\n  108  \n\n/home/max/dev/Falcor/src/Falcor/Utils/BinaryFileStream.h:\n   46      };\n   47  \n   48:     /** Default constructor.\n   49      */\n   50      BinaryFileStream() {};\n   51  \n   52:     /** Constructor that opens a file\n   53          \\param[in] filename Name of file to open or create\n   54          \\param[in] mode Mode to open file as\n   ..\n   58      }\n   59  \n   60:     /** Destructor\n   61      */\n   62      ~BinaryFileStream() {\n\n/home/max/dev/Falcor/src/Falcor/Utils/Debug/DebugConsole.h:\n   44      class DebugConsole {\n   45       public:\n   46:         /** Opens a console window. The destructor closes it again.\n   47              \\param[in] waitForKey If true, the console waits for a key press before closing.\n   48          */\n\n/home/max/dev/Falcor/src/Falcor/Utils/Debug/PixelDebug.h:\n  105      bool                        mDataValid = false;             ///< True if data has been read back and is valid.\n  106  \n  107:     std::vector<PixelLogValue>  mPixelLogData;                  ///< Pixel log data read back from the GPU.\n  108:     std::vector<AssertLogValue> mAssertLogData;                 ///< Assert log data read back from the GPU.\n  109  \n  110      const uint32_t              mLogSize = 0;                   ///< Size of the log buffers in elements.\n\n/home/max/dev/Falcor/src/Falcor/Utils/Debug/PixelDebug.slang:\n   67      */\n   68      #define PRINT_FUNC(Type, Count, ValueType)                  \\\n   69:     void print(vector<Type, Count> v)                           \\\n   70      {                                                           \\\n   71          if (all(gPixelDebugPixel == gPixelLogSelected))         \\\n   ..\n  108      */\n  109      #define PRINT_FUNC(Type, Count, DataType) \\\n  110:     void print(vector<Type, Count> v) {}\n  111  \n  112      void assert(bool condition) {}\n\n/home/max/dev/Falcor/src/Falcor/Utils/Helpers.slang:\n  153  float4 applyAmbientOcclusion(float4 color, Texture2D aoTex, SamplerState s, float2 texC)\n  154  {\n  155:     float aoFactor = aoTex.SampleLevel(s, texC, 0).r;\n  156:     return float4(color.rgb * aoFactor, color.a);\n  157  }\n  158  \n  ...\n  176  \n  177  /*******************************************************************\n  178:                     Motion vectors\n  179  *******************************************************************/\n  180  \n  181: /** Calculate screen-space motion vector.\n  182      \\param[in] pixelCrd Sample in current frame expressed in pixel coordinates with origin in the top-left corner.\n  183      \\param[in] prevPosH Sample in previous frame expressed in homogeneous clip space coordinates. Note that the definition differs between D3D12 and Vulkan.\n  184      \\param[in] renderTargetDim Render target dimension in pixels.\n  185:     \\return Motion vector pointing from current to previous position expressed in sceen space [0,1] with origin in the top-left corner.\n  186  */\n  187: float2 calcMotionVector(float2 pixelCrd, float4 prevPosH, float2 renderTargetDim)\n  188  {\n  189      float2 prevCrd = prevPosH.xy / prevPosH.w;\n  ...\n  250          float2 alpha = float2(sineHash3D(floor(scaleFlr * hashInputCoord)),\n  251                                sineHash3D(floor(scaleCeil * hashInputCoord)));\n  252:         // Factor to linearly interpolate with\n  253          float3 fractLoc = float3(frac(log2(anisoScales.x)),\n  254                                   frac(log2(anisoScales.y)),\n  ...\n  256          float2 toCorners = float2(length(fractLoc),\n  257                                    length(float3(1.0f, 1.0f, 1.0f) - fractLoc));\n  258:         float lerpFactor = toCorners.x / (toCorners.x + toCorners.y);\n  259          // Interpolate alpha threshold from noise at two scales\n  260:         float x = (1 - lerpFactor) * alpha.x + lerpFactor * alpha.y;\n  261          // Pass into CDF to compute uniformly distrib threshold\n  262:         float a = min(lerpFactor, 1 - lerpFactor);\n  263          float3 cases = float3(x * x / (2 * a * (1 - a)), (x - 0.5 * a) / (1 - a), 1.0 - ((1 - x) * (1 - x) / (2 * a * (1 - a))));\n  264          // Find our final, uniformly distributed alpha threshold\n  ...\n  277          // Compute alpha thresholds at our two noise scales\n  278          float2 alpha = float2(sineHash3D(floor(pixScales.x * hashInputCoord)), sineHash3D(floor(pixScales.y * hashInputCoord)));\n  279:         // Factor to interpolate lerp with\n  280:         float lerpFactor = frac(log2(pixScale));\n  281          // Interpolate alpha threshold from noise at two scales\n  282:         float x = (1 - lerpFactor) * alpha.x + lerpFactor * alpha.y;\n  283:         float a = min(lerpFactor, 1 - lerpFactor);\n  284          // Pass into CDF to compute uniformly distrib threshold\n  285          float3 cases = float3(x * x / (2 * a * (1 - a)), (x - 0.5 * a) / (1 - a), 1.0 - ((1 - x) * (1 - x) / (2 * a * (1 - a))));\n\n/home/max/dev/Falcor/src/Falcor/Utils/Image/Bitmap.cpp:\n   59      /** Converts half float image to RGBA float image.\n   60      */\n   61:     static std::vector<float> convertHalfToRGBA32Float(uint32_t width, uint32_t height, uint32_t channelCount, const void* pData)\n   62      {\n   63:         std::vector<float> newData(width * height * 4u, 0.f);\n   64          const glm::detail::hdata* pSrc = reinterpret_cast<const glm::detail::hdata*>(pData);\n   65          float* pDst = newData.data();\n   ..\n   81      */\n   82      template<typename SrcT>\n   83:     static std::vector<float> convertIntToRGBA32Float(uint32_t width, uint32_t height, uint32_t channelCount, const void* pData)\n   84      {\n   85:         std::vector<float> newData(width * height * 4u, 0.f);\n   86          const SrcT* pSrc = reinterpret_cast<const SrcT*>(pData);\n   87          float* pDst = newData.data();\n   ..\n  101      /** Converts an image of the given format to an RGBA float image.\n  102      */\n  103:     static std::vector<float> convertToRGBA32Float(ResourceFormat format, uint32_t width, uint32_t height, const void* pData)\n  104      {\n  105          assert(isConvertibleToRGBA32Float(format));\n  ...\n  109          uint32_t channelBits = getNumChannelBits(format, 0);\n  110  \n  111:         std::vector<float> floatData;\n  112  \n  113          if (type == FormatType::Float && channelBits == 16)\n  ...\n  184      Bitmap::UniqueConstPtr Bitmap::createFromFile(std::shared_ptr<Device> pDevice, const std::string& filename, bool isTopDown) {\n  185          std::string fullpath;\n  186:         if (findFileInDataDirectories(filename, fullpath) == false) {\n  187              logError(\"Error when loading image file. Can't find image file \" + filename);\n  188              return nullptr;\n  ...\n  415  \n  416          if (fileFormat == Bitmap::FileFormat::PfmFile || fileFormat == Bitmap::FileFormat::ExrFile) {\n  417:             std::vector<float> floatData;\n  418              if (isConvertibleToRGBA32Float(resourceFormat)) {\n  419                  floatData = convertToRGBA32Float(resourceFormat, width, height, pData);\n  ...\n  481              }\n  482  \n  483:             std::vector<std::string> warnings;\n  484              switch(fileFormat) {\n  485              case FileFormat::JpegFile:\n\n/home/max/dev/Falcor/src/Falcor/Utils/Image/Bitmap.h:\n   61  \n   62      /** Create a new object from file.\n   63:         \\param[in] filename Filename, including a path. If the file can't be found relative to the current directory, Falcor will search for it in the common directories.\n   64          \\param[in] isTopDown Control the memory layout of the image. If true, the top-left pixel is the first pixel in the buffer, otherwise the bottom-left pixel is first.\n   65          \\return If loading was successful, a new object. Otherwise, nullptr.\n   ..\n   68  \n   69      /** Store a memory buffer to a PNG file.\n   70:         \\param[in] filename Output filename. Can include a path - absolute or relative to the executable directory.\n   71          \\param[in] width The width of the image.\n   72          \\param[in] height The height of the image.\n\n/home/max/dev/Falcor/src/Falcor/Utils/Image/DDSHeader.h:\n  115              DdsHeaderDX10 dx10Header;\n  116              bool hasDX10Header;\n  117:             std::vector<uint8_t> data;\n  118          };\n  119      }\n\n/home/max/dev/Falcor/src/Falcor/Utils/Logger.cpp:\n   44      // Get current process name\n   45      std::string filename = getExecutableName();\n   46:     std::string executableDir = getExecutableDirectory();\n   47  \n   48      std::string prefix = std::string(filename);\n   ..\n  143  \n  144              // Setup message box buttons\n  145:             std::vector<MsgBoxCustomButton> buttons;\n  146              if (L != Level::Fatal) buttons.push_back({ContinueOrRetry, mbox == MsgBox::ContinueAbort ? \"Continue\" : \"Retry\"});\n  147              if (isDebuggerPresent()) buttons.push_back({Debug, \"Debug\"});\n\n/home/max/dev/Falcor/src/Falcor/Utils/Logger.h:\n   34      /** Container class for logging messages.\n   35      *   To enable log messages, make sure _LOG_ENABLED is set to true in FalcorConfig.h.\n   36:     *   Messages are printed to a log file in the application directory. Using Logger#ShowBoxOnError() you can control if a message box will be shown as well.\n   37      */\n   38      class dlldecl Logger {\n\n/home/max/dev/Falcor/src/Falcor/Utils/Math/AABB.h:\n   27   **************************************************************************/\n   28  #pragma once\n   29: #include \"Vector.h\"\n   30  \n   31  namespace Falcor\n\n/home/max/dev/Falcor/src/Falcor/Utils/Math/BBox.h:\n   27   **************************************************************************/\n   28  #pragma once\n   29: #include \"Utils/Math/Vector.h\"\n   30  #include <limits>\n   31  \n\n/home/max/dev/Falcor/src/Falcor/Utils/Math/CubicSpline.h:\n   48  \n   49              // Calculate Gamma\n   50:             std::vector<T> gamma(pointCount);\n   51              gamma[0] = kHalf;\n   52              for(uint32_t i = 1; i < pointCount - 1; i++)\n   ..\n   57  \n   58              // Calculate Delta\n   59:             std::vector<T> delta(pointCount);\n   60              delta[0] = kThree * (controlPoints[1] - controlPoints[0]) * gamma[0];\n   61  \n   ..\n   67  \n   68              // Calculate D\n   69:             std::vector<T> D(pointCount);\n   70              D[pointCount - 1] = delta[pointCount - 1];\n   71  \n   ..\n  149              T a, b, c, d;\n  150          };\n  151:         std::vector<CubicCoeff> mCoefficient;\n  152      };\n  153  }\n\n/home/max/dev/Falcor/src/Falcor/Utils/Math/FalcorMath.h:\n   40      */\n   41  \n   42:     /** Creates a quaternion representing rotation between 2 vectors\n   43:         \\param[in] from The source vector\n   44:         \\param[in] to The destination vector\n   45      */\n   46:     inline glm::quat createQuaternionFromVectors(const float3& from, const float3& to)\n   47      {\n   48          glm::quat quat;\n   ..\n   97      }\n   98  \n   99:     /** Creates a rotation matrix from individual basis vectors.\n  100:         \\param[in] forward Forward vector.\n  101:         \\param[in] up Up vector.\n  102          \\return 3x3 rotation matrix.\n  103      */\n  ...\n  114          \\param[in] position Object's position.\n  115          \\param[in] target Object's look-at target.\n  116:         \\param[in] up Object's up vector.\n  117          \\return 3x3 rotation matrix.\n  118      */\n\n/home/max/dev/Falcor/src/Falcor/Utils/Math/MathHelpers.slang:\n   56  \n   57  /** Converts Cartesian coordinates to spherical coordinates (unsigned normalized).\n   58:     'theta' is the polar angle (inclination) between the +z axis and the vector from origin to p, normalized to [0,1].\n   59      'phi' is the azimuthal angle from the +x axis in the xy-plane, normalized to [0,1].\n   60      \\param[in] p Cartesian coordinates (x,y,z).\n   ..\n   71  \n   72  /** Converts Cartesian coordinates to spherical coordinates (radians).\n   73:     'theta' is the polar angle (inclination) between the +z axis and the vector from origin to p, in the range [0,pi].\n   74      'phi' is the azimuthal angle from the +x axis in the xy-plane, in the range [0,2pi].\n   75      \\param[in] p Cartesian coordinates (x,y,z).\n   ..\n  110      For details refer to:\n  111      - Clarberg 2008, \"Fast Equal-Area Mapping of the (Hemi)Sphere using SIMD\".\n  112:     - Cigolle et al. 2014, \"Survey of Efficient Representations for Independent Unit Vectors\".\n  113  \n  114  ******************************************************************************/\n  ...\n  340  }\n  341  \n  342: /** Gernerate a vector that is orthogonal to the input vector.\n  343      This can be used to invent a tangent frame for meshes that don't have real tangents/bitangents.\n  344  */\n  ...\n  363      \\param[in] aabbMin minimum corner of the AABB.\n  364      \\param[in] aabbMax maximum corner of the AABB.\n  365:     \\param[out] coneDir normalized vector defining the cone's axis.\n  366      \\param[out] sinTheta Sine of the angle from the central direction to the cone edge. If the AABB can't be bounded we return 0.\n  367      \\param[out] cosTheta Cosine of the angle from the central direction to the cone edge. If the AABB can't be bounded we return -1 (max cone).\n  ...\n  398      {\n  399          // Compute distance x from origin to corner projected onto central axis.\n  400:         // Note that x is scaled by |dir| since we use unnormalized vectors.\n  401          float d = abs(dot(dir, e[i]));\n  402          float x = distSqr - d;\n  ...\n  425  \n  426  /** Computes the solid angle subtended by an AABB by first computing the\n  427:     average vector to all of its vertices and then finding the maximum\n  428:     angle between that and each of the vectors to its vertices.\n  429  \n  430      \\param[in] origin point from which the solid angle is being comupted.\n  431      \\param[in] aabbMin minimum corner of the AABB.\n  432      \\param[in] aabbMax maximum corner of the AABB.\n  433:     \\param[out] coneDir central cone direction (normalized) or null vector if origin is inside the AABB.\n  434      \\param[out] sinTheta sine of the angle.\n  435      \\param[out] cosTheta cosine of the angle.\n  ...\n  447      }\n  448  \n  449:     // Compute the average vector to each of the bounding box corners.\n  450      float3 dirSum = float3(0.f, 0.f, 0.f);\n  451      // Workaround slang/fxc bug (https://github.com/NVIDIAGameWorks/Falcor/issues/164). This can go away when we always use dxc.\n  ...\n  465  \n  466      // Compute the cosine of the maximum angle between a corner and the\n  467:     // average vector.\n  468      cosTheta = 1.f;\n  469  #if 0\n  ...\n  488      \\param[in] center Sphere's center.\n  489      \\param[in] radius Sphere's radius.\n  490:     \\param[out] sinTheta sine of the angle between a vector from the origin to |center| and a\n  491:                 vector from the origin that is tangent to the sphere.\n  492      \\param[out] cosTheta cosine of that angle.\n  493  */\n\n/home/max/dev/Falcor/src/Falcor/Utils/Perception/Experiment.cpp:\n   62              // Choose any staircase whose progress ratio is minimum\n   63              float minimumProgressRatio = 1;\n   64:             std::vector<int32_t> validIndex;\n   65              // Find minimum progress ratio\n   66              for (int32_t i = 0; i < (int32_t)mMeasurements.size(); i++)\n   ..\n   71                  }\n   72              }\n   73:             // Make a vector with all the measurement cells with minimum progress ratio\n   74              for (int32_t i = 0; i < (int32_t)mMeasurements.size(); i++)\n   75              {\n   ..\n   98              // First record the condition and response and then process the response.\n   99              // Recording...\n  100:             std::vector<float> newRecord;\n  101              newRecord.push_back((float)mCurrentConditionIndex);\n  102              for (auto keyval : getConditionParamForCurrentCondition().mParamList)\n\n/home/max/dev/Falcor/src/Falcor/Utils/Perception/Experiment.h:\n   98          private:\n   99  \n  100:             std::vector<std::string> mConditionParamNames;\n  101:             std::vector<float> mConditionParamValues;\n  102:             std::vector<SingleThresholdMeasurement> mMeasurements;\n  103:             std::vector<std::string> mRecordFieldNames;\n  104:             std::vector<std::vector <float>> mRecordFieldValues;\n  105              int32_t mCurrentConditionIndex;\n  106              int32_t mTrialCount = 0;\n\n/home/max/dev/Falcor/src/Falcor/Utils/Perception/SingleThresholdMeasurement.cpp:\n  327              {\n  328                  // count number of trials & calculate progress ratio per each stimuli level\n  329:                 std::vector<float> progressRatio;\n  330                  float minimumProgressRatio = 1;\n  331                  for (int32_t i = 0; i < (int32_t)mTrialCounts.size(); i++)\n  ...\n  344                  }\n  345                  // select one stimuli level from those with minimum progress ratio\n  346:                 std::vector<int32_t> validIndex;\n  347                  for (int32_t i = 0; i<(int32_t)progressRatio.size(); i++)\n  348                  {\n\n/home/max/dev/Falcor/src/Falcor/Utils/Perception/SingleThresholdMeasurement.h:\n   52              int32_t mNumUp, mNumDown, mMaxReversals, mMaxTotalTrialCount, mMaxLimitHitCount; // for SC\n   53              int32_t mInitIndex, mInitIndexRandomRange, mInitIndexStepSize; // SC with pre-determined stimLevels. Some values are self-obvious (minIndexLevel = 0, maxIndexLevel = stimLevels.size(), minIndexStepSize = 1)\n   54:             std::vector<float> mStimLevels; // for SC with pre-determined stimLevels or Method of Constant Stimuli\n   55:             std::vector<int32_t> mMaxTrialCounts; // for Method of Constant Stimuli\n   56          };\n   57  \n   ..\n  104  \n  105              ExperimentalDesignParameter mExpParam;\n  106:             std::vector<Response> mResponses;\n  107              float mCurrentLevel; // universal for both general SC and MCS\n  108              float mLevelStepSize; // for general SC only\n  109              int32_t mCurrentIndex, mIndexStepSize; // for SC with pre-determined stimulus levels\n  110              int32_t mUpCount, mDownCount, mCurrentDirection, mReversalCount, mLimitHitCount; // for SC only\n  111:             std::vector<int32_t> mTrialCounts; // for MCS only\n  112                                                 // description of condition for the current measurement\n  113              ConditionParameter mConditionParam;\n\n/home/max/dev/Falcor/src/Falcor/Utils/SampleGenerators/StratifiedSamplePattern.cpp:\n   43          sampleCount = std::clamp(sampleCount, 1u, 1024u);\n   44  \n   45:         // Factorize sampleCount into an M x N grid, where M and N are as close as possible.\n   46          // In the worst case sampleCount is prime and we'll end up with a sampleCount x 1 grid.\n   47          mBinsX = (uint32_t)std::sqrt((double)sampleCount);\n\n/home/max/dev/Falcor/src/Falcor/Utils/SampleGenerators/StratifiedSamplePattern.h:\n   67      uint32_t mCurSample = 0;\n   68      std::mt19937 mRng;\n   69:     std::vector<uint32_t> mPermutation;\n   70  };\n   71  \n\n/home/max/dev/Falcor/src/Falcor/Utils/Sampling/SampleGenerator.cpp:\n   31  namespace Falcor {\n   32  \n   33:     static std::map<uint32_t, std::function<SampleGenerator::SharedPtr()>> sFactory;\n   34      static Gui::DropdownList sGuiDropdownList;\n   35  \n   36      SampleGenerator::SharedPtr SampleGenerator::create(uint32_t type) {\n   37:         if (auto it = sFactory.find(type); it != sFactory.end()) {\n   38              return it->second();\n   39          } else {\n   ..\n   57      void SampleGenerator::registerType(uint32_t type, const std::string& name, std::function<SharedPtr()> createFunc) {\n   58          sGuiDropdownList.push_back({ type, name });\n   59:         sFactory[type] = createFunc;\n   60      }\n   61  \n\n/home/max/dev/Falcor/src/Falcor/Utils/Sampling/SampleGenerator.h:\n   47          virtual ~SampleGenerator() = default;\n   48  \n   49:         /** Factory function for creating a sample generator of the specified type.\n   50              \\param[in] type The type of sample generator. See SampleGeneratorType.slangh.\n   51              \\return New object, or throws an exception on error.\n\n/home/max/dev/Falcor/src/Falcor/Utils/Scripting/ScriptBindings.cpp:\n   43           allocated when registerBinding() is called.  (The C++ static objectinitialization fiasco.)\n   44           */\n   45:         std::vector<BindComponentFunc>* gBindFuncs = nullptr;\n   46      }  // namespace\n   47  \n   ..\n   63              }\n   64          } else {\n   65:             if (!gBindFuncs) gBindFuncs = new std::vector<BindComponentFunc>();\n   66              gBindFuncs->push_back(f);\n   67          }\n   ..\n   76      template<typename VecT, typename...Args>\n   77      void addVecType(pybind11::module& m, const std::string name) {\n   78:         auto ctor = [](Args...components) { return makeVec<VecT>(components...); };\n   79          auto repr = [](const VecT& v) { return to_string(v); };\n   80          auto vecStr = [](const VecT& v) {\n   ..\n   87          };\n   88          pybind11::class_<VecT>(m, name.c_str())\n   89:             .def(pybind11::init(ctor))\n   90              .def(\"__repr__\", repr)\n   91              .def(\"__str__\", vecStr);\n\n/home/max/dev/Falcor/src/Falcor/Utils/Scripting/ScriptBindings.h:\n  128  \n  129      template <typename Func, typename... Extra>\n  130:     Class& ctor(Func&& f, const Extra&... extra) {\n  131          pyclass.def(pybind11::init(f), extra...);\n  132          return *this;\n\n/home/max/dev/Falcor/src/Falcor/Utils/Scripting/Scripting.cpp:\n   26   # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n   27   **************************************************************************/\n   28: #include <vector>\n   29  #include <string>\n   30  \n   ..\n   61  static bool insertNewFloatVec(const std::pair<pybind11::handle, pybind11::handle>& pyVar, Dictionary& falcorDict) {\n   62      try {\n   63:         std::vector<float> floatVec = pyVar.second.cast<std::vector<float>>();\n   64          std::string name = pyVar.first.cast<std::string>();\n   65  \n   ..\n   87          sRunning = true;\n   88  #ifdef _WIN32\n   89:         static std::wstring pythonHome = string_2_wstring(getExecutableDirectory() + \"/Python\");\n   90          Py_SetPythonHome(pythonHome.c_str());\n   91  #endif\n\n/home/max/dev/Falcor/src/Falcor/Utils/Scripting/Scripting.h:\n   30  \n   31  #include <functional>\n   32: #include <vector>\n   33  \n   34  #include \"ScriptBindings.h\"\n   ..\n   57  \n   58              template<typename T>\n   59:             std::vector<ObjectDesc<T>> getObjects() {\n   60:                 std::vector<ObjectDesc<T>> v;\n   61                  for (const auto& l : mLocals) {\n   62                      try {\n   ..\n  131  \n  132          static std::string getFilenameString(const std::string& s, bool stripDataDirs = true) {\n  133:             std::string filename = stripDataDirs ? stripDataDirectories(s) : s;\n  134              std::replace(filename.begin(), filename.end(), '\\\\', '/');\n  135              return filename;\n\n/home/max/dev/Falcor/src/Falcor/Utils/StringUtils.h:\n   35  #include <locale>\n   36  #include <codecvt>\n   37: #include <vector>\n   38  #include <cassert>\n   39  \n   ..\n  103      }\n  104  \n  105:     /** Split a string into a vector of strings based on d delimiter\n  106          \\param[in] str String to split\n  107          \\param[in] delim Delimiter to split strings by\n  108          \\return Array of split strings excluding delimiters.\n  109      */\n  110:     inline std::vector<std::string> splitString(const std::string& str, const std::string& delim) {\n  111          std::string s;\n  112:         std::vector<std::string> vec;\n  113          for(char c : str) {\n  114              if(delim.find(c) != std::string::npos) {\n  ...\n  133          \\return Joined string.\n  134      */\n  135:     inline std::string joinStrings(const std::vector<std::string>& strings, const std::string& separator) {\n  136          std::string result;\n  137          for(auto it = strings.begin(); it != strings.end(); it++) {\n\n/home/max/dev/Falcor/src/Falcor/Utils/Threading.cpp:\n   35  struct ThreadingData {\n   36      bool initialized = false;\n   37:     std::vector<std::thread> threads;\n   38      uint32_t current;\n   39  } gData;\n\n/home/max/dev/Falcor/src/Falcor/Utils/Timing/FrameRate.h:\n   29  #define SRC_FALCOR_UTILS_TIMING_FRAMERATE_H_\n   30  \n   31: #include <vector>\n   32  #include \"Clock.h\"\n   33  \n   ..\n   94  private:\n   95      Clock *mClock;\n   96:     std::vector<double> mFrameTimes;\n   97      uint64_t mFrameCount = 0;\n   98      static const uint64_t sFrameWindow;\n\n/home/max/dev/Falcor/src/Falcor/Utils/Timing/Profiler.cpp:\n   46  \n   47      std::unordered_map<Profiler::DeviceEventKey, Profiler::EventData*, Profiler::device_event_key_hash> Profiler::sProfilerEvents;\n   48:     std::vector<Profiler::EventData*> Profiler::sRegisteredEvents;\n   49      std::string curEventName = \"\";\n   50      uint32_t Profiler::sCurrentLevel = 0;\n\n/home/max/dev/Falcor/src/Falcor/Utils/Timing/Profiler.h:\n   31  #include <stack>\n   32  #include <unordered_map>\n   33: #include <vector>\n   34  \n   35  #include \"CpuTimer.h\"\n   ..\n   77  \n   78          struct FrameData {\n   79:             std::vector<GpuTimer::SharedPtr> pTimers;\n   80              size_t currentTimer = 0;\n   81          };\n   ..\n  162  \n  163      static std::unordered_map<DeviceEventKey, EventData*, device_event_key_hash> sProfilerEvents;\n  164:     static std::vector<EventData*> sRegisteredEvents;\n  165      static uint32_t sCurrentLevel;\n  166      static uint32_t sGpuTimerIndex;\n\n/home/max/dev/Falcor/src/Falcor/Utils/UI/DebugDrawer.cpp:\n  114  //         float3 currToNextUp = glm::normalize(glm::cross(currToNextRight, currToNextFoward));\n  115  //\n  116: //         // Half vector between two direction normals\n  117  //         float3 midUp = (lastToCurrUp + currToNextUp) / 2.0f;\n  118  //         float3 midRight = (lastToCurrRight + currToNextRight) / 2.0f;\n\n/home/max/dev/Falcor/src/Falcor/Utils/UI/DebugDrawer.h:\n  105  \n  106      Vao::SharedPtr mpVao;\n  107:     std::vector<LineVertex> mVertexData;\n  108      bool mDirty = true;\n  109  \n\n/home/max/dev/Falcor/src/Falcor/Utils/UI/Font.cpp:\n   84          std::string Filename = \"Framework/Fonts/\" + GetFontFilename(FontName, size);\n   85          std::string TextureFilename;\n   86:         findFileInDataDirectories(Filename + \".dds\", TextureFilename);\n   87          std::string DataFilename;\n   88:         findFileInDataDirectories(Filename + \".bin\", DataFilename);\n   89          if ((doesFileExist(TextureFilename) == false) || (doesFileExist(DataFilename) == false)) {\n   90              LOG_FTL(\"Unable to load .bin .dds files with base name %s\", Filename.c_str());\n\n/home/max/dev/Falcor/src/Falcor/Utils/UI/Gui.cpp:\n   47       private:\n   48          friend class Gui;\n   49:         void init(Gui* pGui, float scaleFactor);\n   50          void createVao(uint32_t vertexCount, uint32_t indexCount);\n   51          void compileFonts();\n   ..\n   77          GraphicsProgram::SharedPtr mpProgram;\n   78          GraphicsVars::SharedPtr mpProgramVars;\n   79:         std::vector<Texture::SharedPtr> mpImages;\n   80          ParameterBlockReflection::BindLocation mGuiImageLoc;\n   81:         float mScaleFactor = 1.0f;\n   82          std::unordered_map<std::string, ImFont*> mFontMap;\n   83          ImFont* mpActiveFont = nullptr;\n   ..\n  123          bool addTextbox(const char label[], std::string& text, uint32_t lineCount = 1, Gui::TextFlags flags = Gui::TextFlags::Empty);\n  124          bool addTextbox(const char label[], char buf[], size_t bufSize, uint32_t lineCount = 1, Gui::TextFlags flags = Gui::TextFlags::Empty);\n  125:         bool addMultiTextbox(const char label[], const std::vector<std::string>& textLabels, std::vector<std::string>& textEntries);\n  126          void addTooltip(const char tip[], bool sameLine = true);\n  127  \n  ...\n  148      };\n  149  \n  150:     void GuiImpl::init(Gui* pGui, float scaleFactor) {\n  151          assert(mpDevice);\n  152  \n  153:         mScaleFactor = scaleFactor;\n  154          ImGui::CreateContext();\n  155          ImGuiIO& io = ImGui::GetIO();\n  ...\n  184  \n  185          style.Colors[ImGuiCol_MenuBarBg] = style.Colors[ImGuiCol_WindowBg];\n  186:         style.ScaleAllSizes(scaleFactor);\n  187  \n  188          // Create the pipeline state cache\n  ...\n  192          LOG_DBG(\"mpDevice uid: %u\", mpDevice->uid());\n  193          mpProgram = GraphicsProgram::createFromFile(mpDevice, \"Utils/UI/Gui.slang\", \"vs\", \"ps\");\n  194:         mpProgramVars = GraphicsVars::create(mpDevice, mpProgram->getReflector());\n  195          mpPipelineState->setProgram(mpProgram);\n  196  \n  ...\n  222          mpLayout->addBufferLayout(0, pBufLayout);\n  223  \n  224:         mGuiImageLoc = mpProgram->getReflector()->getDefaultParameterBlock()->getResourceBinding(\"guiImage\");\n  225      }\n  226  \n  ...\n  242  \n  243          // Need to create a new VAO\n  244:         std::vector<Buffer::SharedPtr> pVB(1);\n  245          pVB[0] = createVB ? Buffer::create(mpDevice, requiredVbSize + sizeof(ImDrawVert) * 1000, Buffer::BindFlags::Vertex, Buffer::CpuAccess::Write, nullptr) : mpVao->getVertexBuffer(0);\n  246          Buffer::SharedPtr pIB = createIB ? Buffer::create(mpDevice, requiredIbSize, Buffer::BindFlags::Index, Buffer::CpuAccess::Write, nullptr) : mpVao->getIndexBuffer();\n  ...\n  329  \n  330          float2 posFloat(pos);\n  331:         posFloat *= mScaleFactor;\n  332          ImVec2 fPos(posFloat.x, posFloat.y);\n  333          ImVec2 fSize(float(size.x), float(size.y));\n  ...\n  551      }\n  552  \n  553:     bool GuiImpl::addMultiTextbox(const char label[], const std::vector<std::string>& textLabels, std::vector<std::string>& textEntries) {\n  554          static uint32_t sIdOffset = 0;\n  555          bool result = false;\n  ...\n  764      }\n  765  \n  766:     Gui::UniquePtr Gui::create(std::shared_ptr<Device> pDevice, uint32_t width, uint32_t height, float scaleFactor) {\n  767          UniquePtr pGui = UniquePtr(new Gui(pDevice));\n  768          pGui->mpWrapper = new GuiImpl(pDevice);\n  769:         pGui->mpWrapper->init(pGui.get(), scaleFactor);\n  770          pGui->onWindowResize(width, height);\n  771          return pGui;\n  ...\n  785      void Gui::addFont(const std::string& name, const std::string& filename) {\n  786          std::string fullpath;\n  787:         if (findFileInDataDirectories(filename, fullpath) == false) {\n  788              logWarning(\"Can't find font file `\" + filename + \"`\");\n  789              return;\n  790          }\n  791  \n  792:         float size = 14.0f * mpWrapper->mScaleFactor;\n  793          ImFont* pFont = ImGui::GetIO().Fonts->AddFontFromFileTTF(fullpath.c_str(), size);\n  794          mpWrapper->mFontMap[name] = pFont;\n  ...\n 1056      }\n 1057  \n 1058:     template<typename T, std::enable_if_t<!is_vector<T>::value, bool>>\n 1059      bool Gui::Widgets::var(const char label[], T& var, T minVal, T maxVal, float step, bool sameLine, const char* displayFormat) {\n 1060          return mpGui ? mpGui->mpWrapper->addScalarVar(label, var, minVal, maxVal, step, sameLine, displayFormat) : false;\n ....\n 1070  #undef add_scalarVar_type\n 1071  \n 1072:     template<typename T, std::enable_if_t<!is_vector<T>::value, bool>>\n 1073      bool Gui::Widgets::slider(const char label[], T& var, T minVal, T maxVal, bool sameLine, const char* displayFormat)\n 1074      {\n ....\n 1087  #undef add_scalarSlider_type\n 1088  \n 1089:     template<typename T, std::enable_if_t<is_vector<T>::value, bool>>\n 1090      bool Gui::Widgets::var(const char label[], T& var, typename T::value_type minVal, typename T::value_type maxVal, float step, bool sameLine, const char* displayFormat) {\n 1091          return mpGui ? mpGui->mpWrapper->addVecVar(label, var, minVal, maxVal, step, sameLine, displayFormat) : false;\n ....\n 1106  #undef add_vecVar_type\n 1107  \n 1108:     template<typename T, std::enable_if_t<is_vector<T>::value, bool>>\n 1109      bool Gui::Widgets::slider(const char label[], T& var, typename T::value_type minVal, typename T::value_type maxVal, bool sameLine, const char* displayFormat) {\n 1110          typename T::value_type lowerBound = glm::clamp(minVal, std::numeric_limits<typename T::value_type>::lowest() / 2, std::numeric_limits<typename T::value_type>::max() / 2);\n ....\n 1139      }\n 1140  \n 1141:     bool Gui::Widgets::multiTextbox(const char label[], const std::vector<std::string>& textLabels, std::vector<std::string>& textEntries) {\n 1142          return mpGui ? mpGui->mpWrapper->addMultiTextbox(label, textLabels, textEntries) : false;\n 1143      }\n\n/home/max/dev/Falcor/src/Falcor/Utils/UI/Gui.h:\n   46      class GuiImpl;\n   47  \n   48:     // Helper to check if a class is a vector\n   49      template<typename T, typename = void>\n   50:     struct is_vector : std::false_type {};\n   51  \n   52      template<typename T>\n   53:     struct is_vector<T, std::void_t<typename T::value_type>> : std::true_type {};\n   54  \n   55      /** A class wrapping the external GUI library\n   ..\n   68          };\n   69  \n   70:         using DropdownList = std::vector <DropdownValue>;\n   71  \n   72          struct RadioButton {\n   ..\n   76          };\n   77  \n   78:         using RadioButtonGroup = std::vector<RadioButton>;\n   79  \n   80          enum class TextFlags {\n   ..\n  206              /** Adds multiple text boxes for one confirmation button\n  207              */\n  208:             bool multiTextbox(const char label[], const std::vector<std::string>& textLabels, std::vector<std::string>& textEntries);\n  209  \n  210              /** Render a tooltip. This will display a small question mark next to the last label item rendered and will display the tooltip if the user hover over it\n  ...\n  217              /** Adds an RGB color UI widget.\n  218                  \\param[in] label The name of the widget.\n  219:                 \\param[in] var A reference to a vector that will be updated directly when the widget state changes.\n  220                  \\param[in] sameLine Optional. If set to true, the widget will appear on the same line as the previous widget\n  221                  \\return true if the value changed, otherwise false\n  ...\n  225              /** Adds an RGBA color UI widget.\n  226                  \\param[in] label The name of the widget.\n  227:                 \\param[in] var A reference to a vector that will be updated directly when the widget state changes.\n  228                  \\param[in] sameLine Optional. If set to true, the widget will appear on the same line as the previous widget\n  229                  \\return true if the value changed, otherwise false\n  ...\n  252                  \\return true if the value changed, otherwise false\n  253              */\n  254:             template<typename T, std::enable_if_t<!is_vector<T>::value, bool> = true>\n  255              bool var(const char label[], T& var, T minVal = std::numeric_limits<T>::lowest(), T maxVal = std::numeric_limits<T>::max(),\n  256                       float step = std::is_floating_point_v<T> ? 0.001f : 1.0f, bool sameLine = false, const char* displayFormat = nullptr);\n  257  \n  258:             template<typename T, std::enable_if_t<!is_vector<T>::value, bool> = true>\n  259              bool slider(const char label[], T& var, T minVal = std::numeric_limits<T>::lowest() / 2, T maxVal = std::numeric_limits<T>::max() / 2, bool sameLine = false, const char* displayFormat = nullptr);\n  260  \n  261:             // Vectors\n  262:             /** Adds a UI element for setting vector values.\n  263                  \\param[in] label The name of the widget.\n  264                  \\param[in] var A reference that will be updated directly when the widget state changes.\n  ...\n  270                  \\return true if the value changed, otherwise false\n  271              */\n  272:             template<typename T, std::enable_if_t<is_vector<T>::value, bool> = true>\n  273              bool var(const char label[], T& var, typename T::value_type minVal = std::numeric_limits<typename T::value_type>::lowest(), typename T::value_type maxVal = std::numeric_limits<typename T::value_type>::max(),\n  274                       float step = std::is_floating_point_v<typename T::value_type> ? 0.001f : 1.0f, bool sameLine = false, const char* displayFormat = nullptr);\n  275  \n  276:             template<typename T, std::enable_if_t<is_vector<T>::value, bool> = true>\n  277              bool slider(const char label[], T& var, typename T::value_type minVal = std::numeric_limits<typename T::value_type>::lowest() / 2,\n  278                          typename T::value_type maxVal = std::numeric_limits<typename T::value_type>::max() / 2, bool sameLine = false, const char* displayFormat = nullptr);\n  ...\n  482          /** Create a new GUI object. Each object is essentially a container for a GUI window\n  483          */\n  484:         static UniquePtr create(std::shared_ptr<Device> pDevice, uint32_t width, uint32_t height, float scaleFactor = 1.0f);\n  485  \n  486          ~Gui();\n\n/home/max/dev/Falcor/src/houdini/CMakeLists.txt:\n    8  \n    9  \n   10: #add_subdirectory( ropLava ) # Houdini render node\n   11  \n   12  install(DIRECTORY soho DESTINATION ${HOUDINI_USER})\n\n/home/max/dev/Falcor/src/houdini/ropLava/CMakeLists.txt:\n    9  )\n   10  \n   11: # Link against the Houdini libraries, and add required include directories and compile definitions.\n   12  target_link_libraries( \n   13  \t${library_name} \n   ..\n   17  )\n   18  \n   19: # Configure several common target properties, such as its output directory.\n   20  houdini_configure_target( ${library_name} )\n\n/home/max/dev/Falcor/src/houdini/ropLava/ROP_Lava.cpp:\n    2  #include <ROP/ROP_Templates.h>\n    3  #include <SOP/SOP_Node.h>\n    4: #include <OP/OP_Director.h>\n    5  #include <OP/OP_OperatorTable.h>\n    6  #include <OP/OP_DataTypes.h>\n    .\n  138  }\n  139  \n  140: OP_Node* ROP_Lava::myConstructor(OP_Network *net, const char *name, OP_Operator *op) {\n  141      return new ROP_Lava(net, name, op);\n  142  }\n  ...\n  216          std::cout << \" Rendering frame\" << std::endl;\n  217  \n  218:         std::vector<float> data(XRES * YRES * 8); // all the planes as float arrays\n  219          //std::fill(data.begin(), data.end(), 1.0f);\n  220          void *d_color = static_cast<void*>(&data[0]);\n  ...\n  271              \"lava\",\n  272              \"Lava\",\n  273:             ROP_Lava::myConstructor,\n  274              ROP_Lava::getTemplatePair(),\n  275              0,\n\n/home/max/dev/Falcor/src/houdini/ropLava/ROP_Lava.h:\n    2  #define ROP_LAVA_H_\n    3  \n    4: #include <vector>\n    5  \n    6  #include <ROP/ROP_Node.h>\n    .\n   31      static OP_VariablePair      *getVariablePair();\n   32      /// Creates an instance of this node.\n   33:     static OP_Node              *myConstructor(OP_Network *net, const char*name, OP_Operator *op);\n   34  protected:\n   35               ROP_Lava(OP_Network *net, const char *name, OP_Operator *entry);\n\n/home/max/dev/Falcor/src/houdini/soho/LSDapi.py:\n  272  def cmd_prefilter(path, prefilter_path, filter, count, ratio):\n  273      soho.indent()\n  274:     # Create a temporary file in the same directory as the original map\n  275      pathsplit = os.path.split(path)\n  276      args = [ '\"%s\" prefilter' % path,\n\n/home/max/dev/Falcor/src/houdini/soho/LSDframe.py:\n   69          # find the position of the object's center and construct a\n   70          # transform based on that position.\n   71:         P = hou.Vector3((0,0,0)) * hou.Matrix4(xform)\n   72          hxform = hou.hmath.buildTranslate(P[0], P[1], P[2])\n   73          # Transform to orient for the face we're rendering\n   ..\n  237      cmd_image(cubemap.Filename, '', '')\n  238      LSDsettings.outputImageFormatOptions(None, cam, now)\n  239:     defplane(\"C\", 'Cf+Af', 'vector4', -1, None, cam, now)\n  240      soho.indent(-1, \"\", None)\n  241      LSDhooks.call('post_envmapDisplay', cam, now, cubemap)\n  ...\n  265          cmd_property('plane', 'planefile', ['null:'])\n  266          cmd_property('plane', 'variable', ['Of'])\n  267:         cmd_property('plane', 'vextype', ['vector'])\n  268      else:\n  269          soho.makeFilePathDirsIfEnabled(filename)\n  ...\n  275      cmd_end()\n  276      if deep:\n  277:         # Make intermdiate directories\n  278          for parm in plist:\n  279              if parm.Houdini == 'vm_dsmfilename':\n  ...\n  432      skipCf = cam.wrangleInt(wrangler, 'vm_bake_skipcf', now, [0])[0]\n  433      if not skipCf:\n  434:         defplane(\"C\", 'Cf+Af', 'vector4', -1, wrangler, cam, now)\n  435      else:\n  436:         defplane(\"C\", 'Of', 'vector', -1, wrangler, cam, now)\n  437  \n  438      vm_relightingbuffer = [0]\n  ...\n  443  \n  444      if is_preview and vm_relightingbuffer[0]:\n  445:         defplane(\"C_Relighting\", 'Cf+Af', 'vector4', -1,\n  446                   wrangler, cam, now, showrelightingbuffer=True)\n  447  \n  ...\n  971          shutter_open = -LSDmisc.CameraDelta\n  972          shutter_close = shutter_open + LSDmisc.CameraShutter\n  973:         cmd_declare('global', 'vector2', 'camera:shutter',\n  974              [shutter_open * LSDmisc.FPS, shutter_close * LSDmisc.FPS] )\n  975          LSDmisc.ouputMotionBlurInfo(cam,now,required=True)\n  ...\n 1357      objectTransform('space:world', obj, times)\n 1358  \n 1359:     cmd_declare('object', 'vector2', 'camera:shutter',\n 1360          LSDmisc.obj_shutter_open_close(obj, now))\n 1361      soho.indent()\n\n/home/max/dev/Falcor/src/houdini/soho/LSDgeo.py:\n  828      if proc:\n  829          cmd_procedural(proc[0], proc[1], proc[2])\n  830:         cmd_declare('object', 'vector2', 'camera:shutter',\n  831              LSDmisc.obj_shutter_open_close(obj, now))\n  832          if not _forceGeometry(obj, now):\n\n/home/max/dev/Falcor/src/houdini/soho/LSDmantra.py:\n   55      Renderer(\"renderer\", \"iprfixsamples\", \"bool\", \"vm_iprfixsamples\")\n   56      Renderer(\"renderer\", \"iprpasssamples\", \"float\", \"vm_iprpasssamples\")\n   57:     Renderer(\"renderer\", \"kdmemfactor\", \"float\", \"vm_kdmemfactor\")\n   58      Renderer(\"renderer\", \"logcolors\", \"int\", \"vm_logcolors\", skipdefault=False)\n   59      Renderer(\"renderer\", \"logtimestamps\", \"bool\", \"vm_logtimestamps\")\n   ..\n   72      Renderer(\"renderer\", \"preview\", \"bool\", \"vm_preview\")\n   73      Renderer(\"renderer\", \"previewadaptive\", \"bool\", \"vm_previewadaptive\")\n   74:     Renderer(\"renderer\", \"previewadaptivefactor\", \"float\", \"vm_previewadaptivefactor\")\n   75      Renderer(\"renderer\", \"previewmode\", \"string\", \"vm_previewmode\")\n   76      Renderer(\"renderer\", \"previewmouseradius\", \"float\", \"vm_previewmouseradius\")\n   ..\n   95      Renderer(\"renderer\", \"renderinterrupt\", \"bool\", \"vm_renderinterrupt\")\n   96      Renderer(\"renderer\", \"samplecachesize\", \"int\", \"vm_samplecachesize\")\n   97:     Renderer(\"renderer\", \"shadingfactor\", \"float\", \"vm_shadingfactor\")\n   98      Renderer(\"renderer\", \"shadingqueuesize\", \"int\", \"vm_shadingqueuesize\")\n   99      Renderer(\"renderer\", \"ssscomponents\", \"string\", \"vm_ssscomponents\")\n  ...\n  208      Object(\"minindirectraysamples\", \"int\", \"vm_minindirectraysamples\")\n  209      Object(\"minraysamples\", \"int\", \"vm_minraysamples\")\n  210:     Object(\"motionfactor\", \"float\", \"vm_motionfactor\")\n  211      Object(\"osd_fvarinterp\", \"int\", \"vm_osd_fvarinterp\")\n  212      Object(\"osd_quality\", \"float\", \"vm_osd_quality\")\n  ...\n  274      Object(\"volumeuniformflipthresh\", \"float\", \"vm_volumeuniformflipthresh\")\n  275      Object(\"volumeuniformtype\", \"int\", \"vm_volumeuniformtype\")\n  276:     Object(\"volumeupvector\", \"float\", \"vm_volumeupvector\")\n  277      Object(\"volumezerothresh\", \"float\", \"vm_volumezerothresh\")\n  278  \n  ...\n  379      ImageOption(\"RAT.makemips\", \"bool\", \"vm_image_rat_makemips\")\n  380      ImageOption(\"TIFF.compression\", \"string\", \"vm_image_tiff_compression\")\n  381:     ImageOption(\"TIFF.predictor\", \"string\", \"vm_image_tiff_predictor\")\n  382      ImageOption(\"artist\", \"string\", \"vm_image_artist\")\n  383      ImageOption(\"comment\", \"string\", \"vm_image_comment\")\n\n/home/max/dev/Falcor/src/houdini/soho/LSDmisc.py:\n   41  ExternalSessionId = ''          # A string based on the frame number/hip file\n   42  ExternalSharedSessionId = ''    # A string based on the hip file alone\n   43: TmpSharedStorage = ''        # Directory used to store side-car files\n   44: TmpLocalStorage = ''     # Directory used to store piped temporary files\n   45  \n   46  headerParms = {\n   ..\n  181  \n  182      def isValidTempDir(path):\n  183:         # Make sure we can either create the sub-directories of the path, or\n  184          # that the path itself is writeable.\n  185          if os.path.isdir(path):\n  ...\n  190      if not tmpsharedstorage:\n  191          # We still need to create a storage path, so put it in the HIP\n  192:         # directory.  This is where assets will be saved for the LSD.\n  193          tmpsharedstorage = hou.expandString(\"$HIP/ifds/storage\")\n  194      else:\n  ...\n  201      if not tmplocalstorage:\n  202          # We still need to create a storage path, so put it in the\n  203:         # HOUDINI_TEMP_DIR directory.  This is where assets will be saved for\n  204          # the LSD.\n  205          tmplocalstorage = hou.expandString(\"$HOUDINI_TEMP_DIR/ifds/storage\")\n\n/home/max/dev/Falcor/src/houdini/soho/LSDsettings.py:\n  100      #   bool\n  101      #   int             (integer)\n  102:     #   vector2\n  103:     #   vector3         (vector)\n  104:     #   vector4\n  105      #   matrix3\n  106      #   matrix4         (matrix)\n  ...\n  114      elif type == 'float':\n  115          value = plist['vm_userscalar'].Value\n  116:     elif type == 'vector':\n  117          value = plist['vm_user3tuple'].Value\n  118:     elif type == 'vector4':\n  119          value = plist['vm_user4tuple'].Value\n  120      elif type == 'matrix3':\n\n/home/max/dev/Falcor/src/lava_cmd/CMakeLists.txt:\n    8  # Find BOOST\n    9  find_package( Boost COMPONENTS program_options log REQUIRED )\n   10: include_directories( ${Boost_INCLUDE_DIRS} )\n   11  # we will use static libs\n   12  add_definitions(-DBOOST_LOG_DYN_LINK)\n   ..\n   14  # Python\n   15  find_package( PythonLibs 3.7 REQUIRED )\n   16: include_directories( ${PYTHON_INCLUDE_DIRS} )\n   17  \n   18  # RPATH \n   ..\n   20  SET(CMAKE_BUILD_WITH_INSTALL_RPATH FALSE) # when building, don't use the install RPATH already (but later on when installing)\n   21  SET(CMAKE_INSTALL_RPATH \"${CMAKE_INSTALL_PREFIX}/lib\")\n   22: SET(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE) # add the automatically determined parts of the RPATH which point to directories outside the build tree to the install RPATH\n   23  \n   24  # Executable \n\n/home/max/dev/Falcor/src/lava_cmd/lava_cmd.cpp:\n   84      config.add_options()\n   85          (\"optimization\", po::value<int>(&opt)->default_value(10), \"optimization level\")\n   86:         (\"include-path,I\", po::value< std::vector<std::string> >()->composing(), \"include path\")\n   87          ;\n   88  \n   ..\n   90      po::options_description hidden(\"Hidden options\");\n   91      hidden.add_options()\n   92:         (\"input-file\", po::value< std::vector<std::string> >(), \"input file\")\n   93          ;\n   94  \n   ..\n  134      SceneReadersRegistry::getInstance().addReader(\n  135        ReaderLSD::myExtensions, \n  136:       ReaderLSD::myConstructor\n  137      );\n  138  \n  ...\n  142      if (vm.count(\"input-file\")) {\n  143        // loading provided files\n  144:       std::vector<std::string> files = vm[\"input-file\"].as< std::vector<std::string> >();\n  145        BOOST_LOG_TRIVIAL(debug) << \"Input scene files are: \"<< boost::algorithm::join(files, \" \") << \"\\n\";\n  146:       for (std::vector<std::string>::const_iterator fi = files.begin(); fi != files.end(); ++fi) {\n  147          std::ifstream in_file(*fi, std::ifstream::binary);\n  148          \n\n/home/max/dev/Falcor/src/lava_lib/_bak/loader_base.cpp:\n    1: #include <vector>\n    2  #include <fstream>\n    3  \n\n/home/max/dev/Falcor/src/lava_lib/_bak/loader_base.h:\n    4  #include <cstddef>\n    5  #include <string>\n    6: #include <vector>\n    7  #include <memory>\n    8  #include <iostream>\n\n/home/max/dev/Falcor/src/lava_lib/_bak/loader_lsd.cpp:\n    1: #include <vector>\n    2  #include <fstream>\n    3  \n\n/home/max/dev/Falcor/src/lava_lib/_bak/syntax_lsd.h:\n   34                  //ribDouble = real_p[&printDbl];\n   35                  ribDouble       =   real_p;\n   36:                 ribInnerVector  =   ribDouble >> ribDouble >> ribDouble;\n   37:                 ribVector       =   ribInnerVector | ('[' >> ribInnerVector >> ']');\n   38  \n   39                  //ribInnerColor   =   repeat_p(self.scn.getColorSize())[ real_p ];\n   ..\n   42  \n   43                  ribArray        =   '[' >> (+real_p | +ribString) >> ']';\n   44:                 ribParameter    =   ribString >> (real_p | ribVector | ribArray | ribColor | ribString);\n   45  \n   46                  // Graphical state query definitions (without subcategories)\n   ..\n   78                  \n   79                  // Transformation type query definitions\n   80:                 translate           =   \"Translate\" >> ribVector;\n   81:                 rotate              =   \"Rotate\" >> real_p >> ribVector;\n   82  \n   83                  transformationRules =   translate | rotate;\n   ..\n  105              // Lists of rules used\n  106              rule<ScannerT>  root, request;\n  107:             rule<ScannerT>  ribString, ribDouble, ribInnerVector, ribVector, ribInnerColor, ribColor, ribArray, ribParameter;\n  108              rule<ScannerT>  graphicStateRules,\n  109                                  topLevelGSRules, worldBegin, worldEnd;\n\n/home/max/dev/Falcor/src/lava_lib/_bak2/generated/LSDLexer.cpp:\n   22  }\n   23  \n   24: const std::vector<std::string>& LSDLexer::getRuleNames() const {\n   25    return _ruleNames;\n   26  }\n   27  \n   28: const std::vector<std::string>& LSDLexer::getChannelNames() const {\n   29    return _channelNames;\n   30  }\n   31  \n   32: const std::vector<std::string>& LSDLexer::getModeNames() const {\n   33    return _modeNames;\n   34  }\n   35  \n   36: const std::vector<std::string>& LSDLexer::getTokenNames() const {\n   37    return _tokenNames;\n   38  }\n   ..\n   42  }\n   43  \n   44: const std::vector<uint16_t> LSDLexer::getSerializedATN() const {\n   45    return _serializedATN;\n   46  }\n   ..\n   54  \n   55  // Static vars and initialization.\n   56: std::vector<dfa::DFA> LSDLexer::_decisionToDFA;\n   57  atn::PredictionContextCache LSDLexer::_sharedContextCache;\n   58  \n   59  // We own the ATN which in turn owns the ATN states.\n   60  atn::ATN LSDLexer::_atn;\n   61: std::vector<uint16_t> LSDLexer::_serializedATN;\n   62  \n   63: std::vector<std::string> LSDLexer::_ruleNames = {\n   64    u8\"T__0\", u8\"T__1\", u8\"T__2\", u8\"T__3\", u8\"T__4\", u8\"T__5\", u8\"T__6\", \n   65    u8\"T__7\", u8\"T__8\", u8\"T__9\", u8\"T__10\", u8\"T__11\", u8\"T__12\", u8\"T__13\", \n   ..\n   71  };\n   72  \n   73: std::vector<std::string> LSDLexer::_channelNames = {\n   74    \"DEFAULT_TOKEN_CHANNEL\", \"HIDDEN\"\n   75  };\n   76  \n   77: std::vector<std::string> LSDLexer::_modeNames = {\n   78    u8\"DEFAULT_MODE\"\n   79  };\n   80  \n   81: std::vector<std::string> LSDLexer::_literalNames = {\n   82    \"\", u8\"'cmd_end'\", u8\"'setenv'\", u8\"'='\", u8\"'cmd_version'\", u8\"'cmd_defaults'\", \n   83    u8\"'cmd_declare'\", u8\"';'\", u8\"'cmd_start'\", u8\"'cmd_detail'\", u8\"'-T'\", \n   ..\n   86  };\n   87  \n   88: std::vector<std::string> LSDLexer::_symbolicNames = {\n   89    \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \n   90    \"\", \"\", u8\"COMMENT\", u8\"OBJNAME\", u8\"TYPE\", u8\"OBJECT\", u8\"VEX_VERSION\", \n   ..\n   95  dfa::Vocabulary LSDLexer::_vocabulary(_literalNames, _symbolicNames);\n   96  \n   97: std::vector<std::string> LSDLexer::_tokenNames;\n   98  \n   99  LSDLexer::Initializer::Initializer() {\n\n/home/max/dev/Falcor/src/lava_lib/_bak2/generated/LSDLexer.h:\n   26  \n   27    virtual std::string getGrammarFileName() const override;\n   28:   virtual const std::vector<std::string>& getRuleNames() const override;\n   29  \n   30:   virtual const std::vector<std::string>& getChannelNames() const override;\n   31:   virtual const std::vector<std::string>& getModeNames() const override;\n   32:   virtual const std::vector<std::string>& getTokenNames() const override; // deprecated, use vocabulary instead\n   33    virtual antlr4::dfa::Vocabulary& getVocabulary() const override;\n   34  \n   35:   virtual const std::vector<uint16_t> getSerializedATN() const override;\n   36    virtual const antlr4::atn::ATN& getATN() const override;\n   37  \n   38  private:\n   39:   static std::vector<antlr4::dfa::DFA> _decisionToDFA;\n   40    static antlr4::atn::PredictionContextCache _sharedContextCache;\n   41:   static std::vector<std::string> _ruleNames;\n   42:   static std::vector<std::string> _tokenNames;\n   43:   static std::vector<std::string> _channelNames;\n   44:   static std::vector<std::string> _modeNames;\n   45  \n   46:   static std::vector<std::string> _literalNames;\n   47:   static std::vector<std::string> _symbolicNames;\n   48    static antlr4::dfa::Vocabulary _vocabulary;\n   49    static antlr4::atn::ATN _atn;\n   50:   static std::vector<uint16_t> _serializedATN;\n   51  \n   52  \n\n/home/max/dev/Falcor/src/lava_lib/_bak2/generated/LSDParser.cpp:\n   25  }\n   26  \n   27: const std::vector<std::string>& LSDParser::getRuleNames() const {\n   28    return _ruleNames;\n   29  }\n   ..\n   40  }\n   41  \n   42: std::vector<LSDParser::LineContext *> LSDParser::FileContext::line() {\n   43    return getRuleContexts<LSDParser::LineContext>();\n   44  }\n   ..\n  619  }\n  620  \n  621: std::vector<tree::TerminalNode *> LSDParser::DeclareContext::VAR_NAME() {\n  622    return getTokens(LSDParser::VAR_NAME);\n  623  }\n  ...\n  627  }\n  628  \n  629: std::vector<tree::TerminalNode *> LSDParser::DeclareContext::VALUE() {\n  630    return getTokens(LSDParser::VALUE);\n  631  }\n  ...\n  831  }\n  832  \n  833: std::vector<tree::TerminalNode *> LSDParser::DetailContext::VALUE() {\n  834    return getTokens(LSDParser::VALUE);\n  835  }\n  ...\n 1029  }\n 1030  \n 1031: std::vector<tree::TerminalNode *> LSDParser::ImageContext::VALUE() {\n 1032    return getTokens(LSDParser::VALUE);\n 1033  }\n ....\n 1320  \n 1321  // Static vars and initialization.\n 1322: std::vector<dfa::DFA> LSDParser::_decisionToDFA;\n 1323  atn::PredictionContextCache LSDParser::_sharedContextCache;\n 1324  \n 1325  // We own the ATN which in turn owns the ATN states.\n 1326  atn::ATN LSDParser::_atn;\n 1327: std::vector<uint16_t> LSDParser::_serializedATN;\n 1328  \n 1329: std::vector<std::string> LSDParser::_ruleNames = {\n 1330    \"file\", \"line\", \"bgeo\", \"setenv\", \"version\", \"defaults\", \"declare\", \"start\", \n 1331    \"end\", \"detail\", \"property\", \"image\", \"geomerty\", \"time\", \"raytrace\", \n ....\n 1333  };\n 1334  \n 1335: std::vector<std::string> LSDParser::_literalNames = {\n 1336    \"\", \"'cmd_end'\", \"'setenv'\", \"'='\", \"'cmd_version'\", \"'cmd_defaults'\", \n 1337    \"'cmd_declare'\", \"';'\", \"'cmd_start'\", \"'cmd_detail'\", \"'-T'\", \"'-v'\", \n ....\n 1340  };\n 1341  \n 1342: std::vector<std::string> LSDParser::_symbolicNames = {\n 1343    \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \n 1344    \"\", \"\", \"COMMENT\", \"OBJNAME\", \"TYPE\", \"OBJECT\", \"VEX_VERSION\", \"VAR_NAME\", \n ....\n 1349  dfa::Vocabulary LSDParser::_vocabulary(_literalNames, _symbolicNames);\n 1350  \n 1351: std::vector<std::string> LSDParser::_tokenNames;\n 1352  \n 1353  LSDParser::Initializer::Initializer() {\n\n/home/max/dev/Falcor/src/lava_lib/_bak2/generated/LSDParser.h:\n   34    virtual std::string getGrammarFileName() const override;\n   35    virtual const antlr4::atn::ATN& getATN() const override { return _atn; };\n   36:   virtual const std::vector<std::string>& getTokenNames() const override { return _tokenNames; }; // deprecated: use vocabulary instead.\n   37:   virtual const std::vector<std::string>& getRuleNames() const override;\n   38    virtual antlr4::dfa::Vocabulary& getVocabulary() const override;\n   39  \n   ..\n   60      FileContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n   61      virtual size_t getRuleIndex() const override;\n   62:     std::vector<LineContext *> line();\n   63      LineContext* line(size_t i);\n   64  \n   ..\n  168      antlr4::tree::TerminalNode *OBJECT();\n  169      antlr4::tree::TerminalNode *TYPE();\n  170:     std::vector<antlr4::tree::TerminalNode *> VAR_NAME();\n  171      antlr4::tree::TerminalNode* VAR_NAME(size_t i);\n  172:     std::vector<antlr4::tree::TerminalNode *> VALUE();\n  173      antlr4::tree::TerminalNode* VALUE(size_t i);\n  174  \n  ...\n  217      antlr4::tree::TerminalNode *OBJNAME();\n  218      antlr4::tree::TerminalNode *STRING();\n  219:     std::vector<antlr4::tree::TerminalNode *> VALUE();\n  220      antlr4::tree::TerminalNode* VALUE(size_t i);\n  221  \n  ...\n  250      ImageContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n  251      virtual size_t getRuleIndex() const override;\n  252:     std::vector<antlr4::tree::TerminalNode *> VALUE();\n  253      antlr4::tree::TerminalNode* VALUE(size_t i);\n  254  \n  ...\n  322  \n  323  private:\n  324:   static std::vector<antlr4::dfa::DFA> _decisionToDFA;\n  325    static antlr4::atn::PredictionContextCache _sharedContextCache;\n  326:   static std::vector<std::string> _ruleNames;\n  327:   static std::vector<std::string> _tokenNames;\n  328  \n  329:   static std::vector<std::string> _literalNames;\n  330:   static std::vector<std::string> _symbolicNames;\n  331    static antlr4::dfa::Vocabulary _vocabulary;\n  332    static antlr4::atn::ATN _atn;\n  333:   static std::vector<uint16_t> _serializedATN;\n  334  \n  335  \n\n/home/max/dev/Falcor/src/lava_lib/_bak2/input_stream.cpp:\n   19    InitializeInstanceFields();\n   20  \n   21:   // The vector's size is what used to be n in Java code.\n   22    fill(1); // prime\n   23  }\n   ..\n   28    }\n   29  \n   30:   // buf always has at least data[p==0] in this method due to ctor\n   31    _lastChar = _data[_p]; // track last char for LA(-1)\n   32  \n\n/home/max/dev/Falcor/src/lava_lib/_bak2/input_stream.cpp.bak:\n   19    InitializeInstanceFields();\n   20  \n   21:   // The vector's size is what used to be n in Java code.\n   22    fill(1); // prime\n   23  }\n   ..\n   29    }\n   30  \n   31:   // buf always has at least data[p==0] in this method due to ctor\n   32    _lastChar = _data[_p]; // track last char for LA(-1)\n   33  \n\n/home/max/dev/Falcor/src/lava_lib/_bak2/reader_lsd.cpp:\n  171  \n  172  \n  173: void ReaderLSD::getFileExtensions(std::vector<std::string> &extensions) const{\n  174      extensions.insert(extensions.end(), _lsd_extensions.begin(), _lsd_extensions.end());\n  175  }\n  ...\n  244  \n  245  \n  246: // factory methods\n  247  \n  248: std::vector<std::string> *ReaderLSD::myExtensions() {\n  249      return &_lsd_extensions;\n  250  }\n  251  \n  252: ReaderBase::SharedPtr ReaderLSD::myConstructor() {\n  253      return ReaderBase::SharedPtr(new ReaderLSD());\n  254  }\n\n/home/max/dev/Falcor/src/lava_lib/_bak2/reader_lsd.h:\n    3  \n    4  #include <string>\n    5: #include <vector>\n    6  #include <iostream>\n    7  #include <fstream>\n    .\n   14  namespace lava {\n   15  \n   16: static std::vector<std::string> _lsd_extensions = {\".lsd\",\".lsd.gz\",\".lsd.zip\"};\n   17  \n   18  class ReaderLSD : public ReaderBase {\n   ..\n   24      bool                checkExtension(const char *name);\n   25  \n   26:     void                getFileExtensions(std::vector<std::string> &extensions) const;\n   27  \n   28      // Method to check if the given magic number matches the magic number. Return true on a match.\n   ..\n   33  \n   34   public:\n   35:  \t// factory methods\n   36:     static ReaderBase::SharedPtr    \tmyConstructor();\n   37:     static std::vector<std::string>*\tmyExtensions();\n   38  };\n   39  \n\n/home/max/dev/Falcor/src/lava_lib/CMakeLists.txt:\n    6  # Python\n    7  find_package( PythonLibs 3.7 REQUIRED )\n    8: include_directories( ${PYTHON_INCLUDE_DIRS} )\n    9  \n   10  # FreeImage\n   11  find_package(FreeImage REQUIRED)\n   12: include_directories( ${FREEIMAGE_INCLUDE_DIRS} )\n   13  \n   14  # Find Boost libs\n   15  find_package( Boost COMPONENTS system filesystem REQUIRED )\n   16  if(Boost_FOUND)\n   17:     include_directories(${Boost_INCLUDE_DIRS}) \n   18  endif()\n   19  \n   20: include_directories( ${Boost_INCLUDE_DIRS} )\n   21  \n   22  # We use Boost static libs\n\n/home/max/dev/Falcor/src/lava_lib/display.h:\n    3  \n    4  #include <string>\n    5: #include <vector>\n    6  #include <memory>\n    7  \n\n/home/max/dev/Falcor/src/lava_lib/LSD.g4:\n   76  \n   77  TYPE\n   78:    : 'float' | 'bool' | 'int' | 'vector2' | 'vector3' | 'vector4' | 'matrix3' | 'matrix4' | 'string'\n   79     ;\n   80  \n\n/home/max/dev/Falcor/src/lava_lib/pymodule/pymodule.cpp:\n   21  class Li {\n   22   public:\n   23: \tLi() { std::cout << \"Li (Lava interfac ) class contructor\" << std::endl; }\t\n   24  };\n   25  \n\n/home/max/dev/Falcor/src/lava_lib/readers/grammar_bgeo.h:\n   32  #include <boost/fusion/adapted.hpp>\n   33  \n   34: #include <boost/container/static_vector.hpp>\n   35  \n   36  \n   ..\n   46      typedef x3::variant<int, double> number_t;\n   47      typedef x3::variant<std::string, number_t, bool> value_t;\n   48:     typedef std::vector<std::pair<std::string, value_t>> object_t;\n   49:     typedef std::vector<value_t> array_t;\n   50      typedef x3::variant<object_t, array_t> bgeo_t;\n   51      */\n   ..\n   65      };\n   66  \n   67:     struct Object: std::vector<Pair> { };\n   68      \n   69:     struct Array: std::vector<Value> { };\n   70      \n   71      struct Value: x3::variant<std::string, Number, bool, Object, Array, bool, NoValue> {\n\n/home/max/dev/Falcor/src/lava_lib/readers/grammar_lsd.h:\n   30  #include <boost/fusion/adapted/std_pair.hpp>\n   31  \n   32: #include <boost/container/static_vector.hpp>\n   33  \n   34  //#include \"renderer_iface_lsd.h\"\n   ..\n   44  \n   45  namespace lsd {\n   46:     using boost::container::static_vector;\n   47  \n   48      struct NoValue {\n   ..\n   50      };\n   51  \n   52:     typedef static_vector<uint, 3> Version;\n   53      \n   54:     typedef static_vector<int, 2> Int2;\n   55:     typedef static_vector<int, 3> Int3;\n   56:     typedef static_vector<int, 4> Int4; \n   57  \n   58:     typedef static_vector<double, 2> Vector2; \n   59:     typedef static_vector<double, 3> Vector3;\n   60:     typedef static_vector<double, 4> Vector4; \n   61:     typedef static_vector<double, 9> Matrix3;\n   62:     typedef static_vector<double, 16> Matrix4;\n   63:     typedef x3::variant<int, Int2, Int3, Int4, double, Vector2, Vector3, Vector4, std::string> PropValue;\n   64  \n   65  namespace ast {\n   ..\n  123      struct ifthen{\n  124          expr::ast::Expr expr;\n  125:         std::vector<Command> commands;\n  126      };\n  127  \n  ...\n  174          Object style;\n  175          std::string token;\n  176:         std::vector<PropValue> values;\n  177      };\n  178  \n  ...\n  180          Type type;\n  181          std::string name;\n  182:         std::vector<PropValue> values;\n  183      };\n  184  \n  ...\n  187          Type type;\n  188          std::string token;\n  189:         std::vector<PropValue> values;\n  190      };\n  191  \n  192  }  // namespace ast\n  193  \n  194: static inline std::ostream& operator<<(std::ostream& os, const std::vector<std::string>& v) {\n  195      std::copy(v.begin(), v.end(), std::ostream_iterator<std::string>(os, \" \"));\n  196      return os;\n  ...\n  215  };\n  216  \n  217: static inline std::ostream& operator<<(std::ostream& os, const Vector2& m) {\n  218:     os << \"Vector2[ \";\n  219      std::copy(m.begin(), m.end(), std::ostream_iterator<double>(os, \" \"));\n  220      return os << \"]\";\n  221  };\n  222  \n  223: static inline std::ostream& operator<<(std::ostream& os, const Vector3& m) {\n  224:     os << \"Vector3[ \";\n  225      std::copy(m.begin(), m.end(), std::ostream_iterator<double>(os, \" \"));\n  226      return os << \"]\";\n  227  };\n  228  \n  229: static inline std::ostream& operator<<(std::ostream& os, const Vector4& m) {\n  230:     os << \"Vector4[ \";\n  231      std::copy(m.begin(), m.end(), std::ostream_iterator<double>(os, \" \"));\n  232      return os << \"]\";\n  ...\n  249  };\n  250  \n  251: static inline std::ostream& operator<<(std::ostream& os, std::vector<PropValue> v) {\n  252      std::copy(v.begin(), v.end(), std::ostream_iterator<PropValue>(os, \" \"));\n  253      return os;\n  ...\n  261          case Type::FLOAT: return os << \"float\";\n  262          case Type::STRING: return os << \"string\";\n  263:         case Type::VECTOR2: return os << \"vector2\";\n  264:         case Type::VECTOR3: return os << \"vector3\";\n  265:         case Type::VECTOR4: return os << \"vector4\";\n  266          case Type::MATRIX3: return os << \"matrix3\";\n  267          case Type::MATRIX4: return os << \"matrix4\";\n  ...\n  371  \n  372   //private:\n  373:     void operator()(std::vector<PropValue> const& v) const;\n  374      void operator()(int v) const;\n  375      void operator()(double v) const;\n  ...\n  378      void operator()(Int3 const& v) const;\n  379      void operator()(Int4 const& v) const;\n  380:     void operator()(Vector2 const& v) const;\n  381:     void operator()(Vector3 const& v) const;\n  382:     void operator()(Vector4 const& v) const;\n  383      void operator()(PropValue const& v) const;\n  384  \n  ...\n  389  \n  390  namespace validators {\n  391:     auto is_valid_vector2 = [](auto& ctx) {\n  392          _pass(ctx) = 0 == (_val(ctx).size() % 2);\n  393      };\n  394  \n  395:     auto is_valid_vector3 = [](auto& ctx) {\n  396          _pass(ctx) = 0 == (_val(ctx).size() % 3);\n  397      };\n  398  \n  399:     auto is_valid_vector4 = [](auto& ctx) {\n  400          _pass(ctx) = 0 == (_val(ctx).size() % 4);\n  401      };\n  ...\n  494      BOOST_SPIRIT_DEFINE(int4)\n  495  \n  496:     x3::rule<class vector2_, Vector2> const vector2 = \"vector2\";\n  497:     auto const vector2_def = repeat(2) [ double_ | int_ ];\n  498:     BOOST_SPIRIT_DEFINE(vector2)\n  499  \n  500:     x3::rule<class vector3_, Vector3> const vector3 = \"vector3\";\n  501:     auto const vector3_def = repeat(3) [ double_ | int_ ];\n  502:     BOOST_SPIRIT_DEFINE(vector3)\n  503  \n  504:     x3::rule<class vector4_, Vector4> const vector4 = \"vector4\";\n  505:     auto const vector4_def = repeat(4) [ double_ | int_ ];\n  506:     BOOST_SPIRIT_DEFINE(vector4)\n  507  \n  508      x3::rule<class matrix3_, Matrix3> const matrix3 = \"matrix3\";\n  ...\n  533      x3::rule<class prop_value_, PropValue> const prop_value = \"prop_value\";\n  534      auto const prop_value_def = \n  535:         vector4 | vector3 | vector2 | double_\n  536        | int4 | int3 | int2 | int_\n  537        | any_string ;\n  ...\n  543          | lit(\"cmd_version\") | lit(\"cmd_defaults\") | lit(\"cmd_declare\") | lit(\"cmd_config\");\n  544  \n  545:     x3::rule<class prop_values_, std::vector<PropValue>> const prop_values = \"prop_values\";\n  546      auto const prop_values_def = *(prop_value - keyword);\n  547      BOOST_SPIRIT_DEFINE(prop_values)\n  548  \n  549:     x3::rule<class image_values_, std::vector<std::string>> const image_values = \"image_values\";\n  550      auto const image_values_def = *(quoted_string);\n  551      BOOST_SPIRIT_DEFINE(image_values)\n  ...\n  575                  (\"bool\"     , ast::Type::BOOL)\n  576                  (\"int\"      , ast::Type::INT)\n  577:                 (\"vector2\"  , ast::Type::VECTOR2)\n  578:                 (\"vector3\"  , ast::Type::VECTOR3)\n  579:                 (\"vector4\"  , ast::Type::VECTOR4)\n  580                  (\"matrix3\"  , ast::Type::MATRIX3)\n  581                  (\"matrix4\"  , ast::Type::MATRIX4)\n\n/home/max/dev/Falcor/src/lava_lib/readers/grammar_lsd_expr.h:\n   32  #include <boost/fusion/adapted.hpp>\n   33  \n   34: #include <boost/container/static_vector.hpp>\n   35  \n   36  \n\n/home/max/dev/Falcor/src/lava_lib/readers/lsd_echo_visitor.cpp:\n   42  }\n   43  \n   44: void EchoVisitor::operator()(Vector2 const& v) const {\n   45      _os << v;\n   46  }\n   47  \n   48: void EchoVisitor::operator()(Vector3 const& v) const {\n   49      _os << v;\n   50  }\n   51  \n   52: void EchoVisitor::operator()(Vector4 const& v) const {\n   53      _os << v;\n   54  }\n   ..\n   58  }\n   59  \n   60: void EchoVisitor::operator()(std::vector<PropValue> const& v) const {\n   61      if (!v.empty()) {\n   62          _os << \"[ \";\n   63:         for(std::vector<PropValue>::const_iterator it = v.begin(); it != (v.end() - 1); it++) {\n   64              boost::apply_visitor(*this, *it);\n   65              _os << \" \";\n\n/home/max/dev/Falcor/src/lava_lib/readers/reader_lsd.cpp:\n    1: #include <vector>\n    2  #include <fstream>\n    3  #include <iterator>\n    .\n   44  \n   45  \n   46: void ReaderLSD::getFileExtensions(std::vector<std::string> &extensions) const{\n   47      extensions.insert(extensions.end(), _lsd_extensions.begin(), _lsd_extensions.end());\n   48  }\n   ..\n   63      boost::spirit::istream_iterator iter(in), end;\n   64  \n   65:     std::vector<lsd::ast::Command> commands; // ast tree\n   66      bool result = x3::parse(iter, end, lsd::parser::input, commands); \n   67  \n   ..\n   88      auto iter = line.begin(), end = line.end();\n   89      \n   90:     std::vector<lsd::ast::Command> commands; // ast tree\n   91      bool result = x3::parse(iter, end, lsd::parser::input, commands);\n   92  \n   ..\n  110  }\n  111  \n  112: // factory methods\n  113: std::vector<std::string> *ReaderLSD::myExtensions() {\n  114      return &_lsd_extensions;\n  115  }\n  116  \n  117: ReaderBase::SharedPtr ReaderLSD::myConstructor() {\n  118      return ReaderBase::SharedPtr(new ReaderLSD());\n  119  }\n\n/home/max/dev/Falcor/src/lava_lib/readers/reader_lsd.h:\n   15  namespace lava {\n   16  \n   17: static std::vector<std::string> _lsd_extensions = {\".lsd\",\".lsd.gz\",\".lsd.zip\"};\n   18  \n   19  typedef std::string::const_iterator It;\n   ..\n   28      const char* formatName() const override;\n   29      bool        checkExtension(const char *name) override;\n   30:     void        getFileExtensions(std::vector<std::string> &extensions) const override;\n   31  \n   32      // Method to check if the given magic number matches the magic number. Return true on a match.\n   ..\n   41  \n   42   public:\n   43:     // factory methods\n   44:     static ReaderBase::SharedPtr        myConstructor();\n   45:     static std::vector<std::string>*    myExtensions();\n   46  };\n   47  \n\n/home/max/dev/Falcor/src/lava_lib/readers/syntax_lsd.h:\n   34                  //ribDouble = real_p[&printDbl];\n   35                  ribDouble       =   real_p;\n   36:                 ribInnerVector  =   ribDouble >> ribDouble >> ribDouble;\n   37:                 ribVector       =   ribInnerVector | ('[' >> ribInnerVector >> ']');\n   38  \n   39                  //ribInnerColor   =   repeat_p(self.scn.getColorSize())[ real_p ];\n   ..\n   42  \n   43                  ribArray        =   '[' >> (+real_p | +ribString) >> ']';\n   44:                 ribParameter    =   ribString >> (real_p | ribVector | ribArray | ribColor | ribString);\n   45  \n   46                  // Graphical state query definitions (without subcategories)\n   ..\n   78                  \n   79                  // Transformation type query definitions\n   80:                 translate           =   \"Translate\" >> ribVector;\n   81:                 rotate              =   \"Rotate\" >> real_p >> ribVector;\n   82  \n   83                  transformationRules =   translate | rotate;\n   ..\n  105              // Lists of rules used\n  106              rule<ScannerT>  root, request;\n  107:             rule<ScannerT>  ribString, ribDouble, ribInnerVector, ribVector, ribInnerColor, ribColor, ribArray, ribParameter;\n  108              rule<ScannerT>  graphicStateRules,\n  109                                  topLevelGSRules, worldBegin, worldEnd;\n\n/home/max/dev/Falcor/src/lava_lib/renderer.cpp:\n  107      // Unmark the current output if it wasn't originally marked\n  108      auto pActiveGraph = mGraphs[mActiveGraph].pGraph;\n  109:     bool hasUnmarkedOut = (isInVector(mGraphs[mActiveGraph].originalOutputs, mGraphs[mActiveGraph].mainOutput) == false);\n  110      if (hasUnmarkedOut) pActiveGraph->unmarkOutput(mGraphs[mActiveGraph].mainOutput);\n  111  \n  ...\n  119      // If the output before the update was not initially marked but still exists, re-mark it.\n  120      // If it no longer exists, mark a new output from the list of currently marked outputs.\n  121:     if (hasUnmarkedOut && isInVector(pActiveGraph->getAvailableOutputs(), mGraphs[mActiveGraph].mainOutput)) {\n  122          pActiveGraph->markOutput(mGraphs[mActiveGraph].mainOutput);\n  123:     } else if (isInVector(mGraphs[mActiveGraph].originalOutputs, mGraphs[mActiveGraph].mainOutput) == false) {\n  124          mGraphs[mActiveGraph].mainOutput = mGraphs[mActiveGraph].originalOutputs[0];\n  125      }\n  ...\n  129  */\n  130  \n  131: bool isInVector(const std::vector<std::string>& strVec, const std::string& str) {\n  132      return std::find(strVec.begin(), strVec.end(), str) != strVec.end();\n  133  }\n  ...\n  164  }\n  165  \n  166: std::vector<std::string> Renderer::getGraphOutputs(const Falcor::RenderGraph::SharedPtr& pGraph) {\n  167:     std::vector<std::string> outputs;\n  168      for (size_t i = 0; i < pGraph->getOutputCount(); i++) outputs.push_back(pGraph->getOutputName(i));\n  169      return outputs;\n\n/home/max/dev/Falcor/src/lava_lib/renderer.h:\n    4  #include <cstddef>\n    5  #include <string>\n    6: #include <vector>\n    7  #include <memory>\n    8  \n    .\n   26          std::string mainOutput;\n   27          bool showAllOutputs = false;\n   28:         std::vector<std::string> originalOutputs;\n   29          std::unordered_map<std::string, uint32_t> graphOutputRefs;\n   30  \t};\n   ..\n   51   \tvoid addGraph(const Falcor::RenderGraph::SharedPtr& pGraph);\n   52   \tvoid initGraph(const Falcor::RenderGraph::SharedPtr& pGraph, GraphData* pData);\n   53:  \tstd::vector<std::string> getGraphOutputs(const Falcor::RenderGraph::SharedPtr& pGraph);\n   54   \tvoid executeActiveGraph(Falcor::RenderContext* pRenderContext);\n   55   \tvoid beginFrame(Falcor::RenderContext* pRenderContext, const Falcor::Fbo::SharedPtr& pTargetFbo);\n   ..\n   92      /** Takes and outputs a screenshot.\n   93      */\n   94:     virtual std::string captureScreen(const std::string explicitFilename = \"\", const std::string explicitOutputDirectory = \"\") override { return \"\"; };\n   95  \n   96      /* Shutdown the app\n   ..\n  128   private:\n  129  \tRenderer();\n  130:  \tstd::vector<std::string> \tmErrorMessages;\n  131   \tFalcor::Device::SharedPtr \tmpDevice;\n  132  \n  ...\n  142  \n  143      Falcor::Scene::SharedPtr \tmpScene;\n  144:     std::vector<GraphData> \t\tmGraphs;\n  145      uint32_t mActiveGraph = 0;\n  146  }; \n\n/home/max/dev/Falcor/src/lava_lib/scene_reader_base.h:\n    3  \n    4  #include <string>\n    5: #include <vector>\n    6  #include <iostream>\n    7  #include <fstream>\n    .\n   30      virtual bool                checkExtension(const char *name) = 0;\n   31  \n   32:     virtual void                getFileExtensions(std::vector<std::string>& extensions) const = 0;\n   33  \n   34      // Method to check if the given magic number matches the magic number. Return true on a match.\n\n/home/max/dev/Falcor/src/lava_lib/scene_readers_registry.cpp:\n    1  #include <string>\n    2: #include <vector>\n    3  \n    4  #include <boost/log/core.hpp>\n    .\n   13  namespace lava {\n   14  \n   15: void SceneReadersRegistry::addReader(ReaderExtensions extensions, ReaderConstructor constructor) {\n   16  \tstd::string registered_extensions = \"\";\n   17  \tfor (auto ext : *extensions()) {\n   18: \t\treadersByExtension.insert ( std::pair<std::string, ReaderConstructor>(ext, constructor) );\n   19  \t\tregistered_extensions += \" \" + ext;\n   20  \t}\n\n/home/max/dev/Falcor/src/lava_lib/scene_readers_registry.h:\n    3  \n    4  #include <string>\n    5: #include <vector>\n    6  #include <map>\n    7  \n    .\n   10  namespace lava {\n   11  \n   12: typedef std::vector<std::string> *(*ReaderExtensions)();\n   13: typedef ReaderBase::SharedPtr (*ReaderConstructor)();\n   14  \n   15  class SceneReadersRegistry {\n   ..\n   23      void operator=(SceneReadersRegistry const&) = delete;\n   24  \n   25: \tvoid\t          \t\taddReader(ReaderExtensions extensions, ReaderConstructor constructor);\n   26  \tReaderBase::SharedPtr\tgetReaderByExt(const std::string& ext);\n   27  \n   28   private:\n   29  \tSceneReadersRegistry() {};\n   30: \tstd::map<std::string, ReaderConstructor> readersByExtension;\n   31  };\n   32  \n\n/home/max/dev/Falcor/src/lava_utils_lib/CMakeLists.txt:\n    5  # find boost libs\n    6  find_package( Boost COMPONENTS log log_setup thread filesystem system REQUIRED )\n    7: include_directories( ${Boost_INCLUDE_DIRS} )\n    8  \n    9  # we will use static libs\n\n/home/max/dev/Falcor/src/Mogwai/AppData.cpp:\n   52  \n   53      AppData::AppData(const fs::path& path): mPath(path.lexically_normal()) {\n   54:         // Make sure directories exist.\n   55:         fs::create_directories(mPath.parent_path());\n   56  \n   57          loadFromFile(mPath);\n   ..\n   66      }\n   67  \n   68:     void AppData::addRecentFile(std::vector<std::string>& recentFiles, const std::string& filename) {\n   69          if (!doesFileExist(filename)) return;\n   70          std::string path = canonicalizeFilename(filename);\n   ..\n   75      }\n   76  \n   77:     void AppData::removeNonExistingFiles(std::vector<std::string>& files) {\n   78          files.erase(std::remove_if(files.begin(), files.end(), [](const std::string& filename) {\n   79              return !doesFileExist(filename);\n   ..\n  100  \n  101          auto readStringArray = [](const rapidjson::Value& value) {\n  102:             std::vector<std::string> strings;\n  103              if (value.IsArray()) {\n  104                  for (const auto& item : value.GetArray()) {\n  ...\n  121          auto& allocator = document.GetAllocator();\n  122  \n  123:         auto writeStringArray = [&allocator](const std::vector<std::string>& strings) {\n  124              rapidjson::Value value(rapidjson::kArrayType);\n  125              for (const auto& item : strings) value.PushBack(rapidjson::StringRef(item), allocator);\n\n/home/max/dev/Falcor/src/Mogwai/AppData.h:\n   29  #define SRC_MOGWAI_APPDATA_H_\n   30  \n   31: #include <vector>\n   32  #include <string>\n   33  \n   ..\n   44  namespace Mogwai {\n   45  \n   46: /** Holds a set of persistent application data stored in the user directory.\n   47  */\n   48  class AppData {\n   ..\n   50      explicit AppData(const fs::path& path);\n   51  \n   52:     const std::vector<std::string>& getRecentScripts() const { return mRecentScripts; }\n   53:     const std::vector<std::string>& getRecentScenes() const { return mRecentScenes; }\n   54  \n   55      void addRecentScript(const std::string& filename);\n   ..\n   57  \n   58   private:\n   59:     void addRecentFile(std::vector<std::string>& recentFiles, const std::string& filename);\n   60:     void removeNonExistingFiles(std::vector<std::string>& files);\n   61  \n   62      void save();\n   ..\n   67      fs::path mPath;\n   68  \n   69:     std::vector<std::string> mRecentScripts;\n   70:     std::vector<std::string> mRecentScenes;\n   71  };\n   72  \n\n/home/max/dev/Falcor/src/Mogwai/CMakeLists.txt:\n   10  \n   11  # ImGui\n   12: include_directories(${PROJECT_SOURCE_DIR}/third_party/imgui)\n   13  \n   14  # Python\n   15  find_package(PythonLibs 3.7 REQUIRED)\n   16: include_directories(${PYTHON_INCLUDE_DIRS})\n   17  \n   18  # GLFW \n   19  find_package(glfw3 REQUIRED)\n   20: include_directories(${GLFW_INCLUDE_DIRS})\n   21  link_libraries(${GLFW_LIBRARIES})\n   22  \n   ..\n   28  \n   29  find_package( Boost COMPONENTS system filesystem REQUIRED )\n   30: include_directories( ${Boost_INCLUDE_DIRS} )\n   31  # we will use static libs\n   32  add_definitions(-DBOOST_LOG_DYN_LINK)\n   ..\n   44  SET(CMAKE_BUILD_WITH_INSTALL_RPATH FALSE) # when building, don't use the install RPATH already (but later on when installing)\n   45  SET(CMAKE_INSTALL_RPATH \"${CMAKE_INSTALL_PREFIX}/lib\")\n   46: SET(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE) # add the automatically determined parts of the RPATH which point to directories outside the build tree to the install RPATH\n   47  \n   48  # Executable \n\n/home/max/dev/Falcor/src/Mogwai/Extensions/Capture/CaptureTrigger.cpp:\n  138      void CaptureTrigger::renderUI(Gui::Window& w) {\n  139          w.textbox(\"Base Filename\", mBaseFilename);\n  140:         w.text(\"Output Directory\\n\" + mOutputDir);\n  141          std::string folder;\n  142          \n  ...\n  145          \n  146          changed = w.checkbox(\"Absolute Path\", mAbsolutePath, true) || changed; // Avoid short-circuit\n  147:         if (changed) setOutputDirectory(mOutputDir);\n  148:         w.tooltip(\"If checked, will use an absolute path. Otherwise, the path will be relative to the executable directory\");\n  149      }\n  150  \n  151:     void CaptureTrigger::setOutputDirectory(const std::string& outDir) {\n  152          bool absolute = fs::path(outDir).is_absolute();\n  153:         if (absolute && !mAbsolutePath) mOutputDir = fs::relative(outDir, getExecutableDirectory()).string();\n  154:         else if (!absolute && mAbsolutePath) mOutputDir = fs::absolute(getExecutableDirectory() + \"/\" + outDir).string();\n  155          else mOutputDir = outDir;\n  156      }\n  ...\n  169  \n  170          // Properties\n  171:         ct.property(kOutputDir.c_str(), &CaptureTrigger::getOutputDirectory, &CaptureTrigger::setOutputDirectory);\n  172          ct.property(kBaseFilename.c_str(), &CaptureTrigger::getBaseFilename, &CaptureTrigger::setBaseFilename);\n  173      }\n  ...\n  182      std::string CaptureTrigger::getOutputNamePrefix(const std::string& output) const {\n  183          auto outDir = fs::path(mOutputDir);\n  184:         if (outDir.is_absolute() == false) outDir = fs::absolute(getExecutableDirectory() + \"/\" + outDir.string());\n  185          std::string absPath = outDir.string();\n  186          std::string filename = absPath + \"/\" + mBaseFilename + \".\" + output + \".\";\n\n/home/max/dev/Falcor/src/Mogwai/Extensions/Capture/CaptureTrigger.h:\n   56          void renderUI(Gui::Window& w);\n   57  \n   58:         void setOutputDirectory(const std::string& outDir);\n   59:         const std::string& getOutputDirectory() const { return mOutputDir; }\n   60  \n   61          void setBaseFilename(const std::string& baseFilename);\n   ..\n   65          std::string getOutputNamePrefix(const std::string& output) const;\n   66  \n   67:         using range_vec = std::vector<Range>;\n   68          std::unordered_map<const RenderGraph*, range_vec> mGraphRanges;\n   69  \n\n/home/max/dev/Falcor/src/Mogwai/Extensions/Capture/FrameCapture.cpp:\n   50  \n   51  template<typename T>\n   52: std::vector<typename T::value_type::first_type> getFirstOfPair(const T& pair) {\n   53:     std::vector<typename T::value_type::first_type> v;\n   54      v.reserve(pair.size());\n   55      for (auto p : pair) v.push_back(p.first);\n\n/home/max/dev/Falcor/src/Mogwai/Extensions/Capture/FrameCapture.h:\n   45      FrameCapture(Renderer* pRenderer) : CaptureTrigger(pRenderer) {}\n   46      bool mShowUI = false;\n   47:     using uint64_vec = std::vector<uint64_t>;\n   48      void addFrames(const RenderGraph* pGraph, const uint64_vec& frames);\n   49      void addFrames(const std::string& graphName, const uint64_vec& frames);\n\n/home/max/dev/Falcor/src/Mogwai/Extensions/Capture/VideoCapture.h:\n   61              Texture::SharedPtr pBlitTex;\n   62          };\n   63:         std::vector<EncodeData> mEncoders;\n   64      };\n   65  }\n\n/home/max/dev/Falcor/src/Mogwai/Mogwai.cpp:\n   63  const char* kGraphNameSwitch = \"graphName\";\n   64  \n   65: const std::string kAppDataPath = getAppDataDirectory() + \"/NVIDIA/Falcor/Mogwai.json\";\n   66  \n   67  }  // namespace\n   ..\n  111  }\n  112  \n  113: bool isInVector(const std::vector<std::string>& strVec, const std::string& str) {\n  114      return std::find(strVec.begin(), strVec.end(), str) != strVec.end();\n  115  }\n  116  \n  117: Gui::DropdownList createDropdownFromVec(const std::vector<std::string>& strVec, const std::string& currentLabel) {\n  118      Gui::DropdownList dropdown;\n  119      for (size_t i = 0; i < strVec.size(); i++) dropdown.push_back({ (uint32_t)i, strVec[i] });\n  ...\n  132      auto& graphData = mGraphs[mActiveGraph];\n  133      // Skip the original outputs\n  134:     if (isInVector(graphData.originalOutputs, name)) return;\n  135  \n  136      // Decrease the reference counter\n  ...\n  146      auto& graphData = mGraphs[mActiveGraph];\n  147      // Skip the original outputs\n  148:     if (isInVector(graphData.originalOutputs, name)) return;\n  149      auto& refVec = mGraphs[mActiveGraph].graphOutputRefs;\n  150      refVec[name]++;\n  ...\n  252  \n  253  void Renderer::openEditor() {\n  254:     bool unmarkOut = (isInVector(mGraphs[mActiveGraph].originalOutputs, mGraphs[mActiveGraph].mainOutput) == false);\n  255      // If the current graph output is not an original output, unmark it\n  256      if (unmarkOut) mGraphs[mActiveGraph].pGraph->unmarkOutput(mGraphs[mActiveGraph].mainOutput);\n  ...\n  327  }\n  328  \n  329: std::vector<std::string> Renderer::getGraphOutputs(const RenderGraph::SharedPtr& pGraph) {\n  330:     std::vector<std::string> outputs;\n  331      for (size_t i = 0; i < pGraph->getOutputCount(); i++) outputs.push_back(pGraph->getOutputName(i));\n  332      return outputs;\n  ...\n  441      // Unmark the current output if it wasn't originally marked\n  442      auto pActiveGraph = mGraphs[mActiveGraph].pGraph;\n  443:     bool hasUnmarkedOut = (isInVector(mGraphs[mActiveGraph].originalOutputs, mGraphs[mActiveGraph].mainOutput) == false);\n  444      if (hasUnmarkedOut) pActiveGraph->unmarkOutput(mGraphs[mActiveGraph].mainOutput);\n  445  \n  ...\n  453      // If the output before the update was not initially marked but still exists, re-mark it.\n  454      // If it no longer exists, mark a new output from the list of currently marked outputs.\n  455:     if (hasUnmarkedOut && isInVector(pActiveGraph->getAvailableOutputs(), mGraphs[mActiveGraph].mainOutput)) {\n  456          pActiveGraph->markOutput(mGraphs[mActiveGraph].mainOutput);\n  457:     } else if (isInVector(mGraphs[mActiveGraph].originalOutputs, mGraphs[mActiveGraph].mainOutput) == false) {\n  458          mGraphs[mActiveGraph].mainOutput = mGraphs[mActiveGraph].originalOutputs[0];\n  459      }\n  ...\n  523                  uint32_t channels;\n  524                  ResourceFormat format;\n  525:                 std::vector<uint8_t> textureData;\n  526                  pOutTex->readTextureData(0, 0, textureData, format, channels);\n  527  \n\n/home/max/dev/Falcor/src/Mogwai/Mogwai.h:\n   29  #define SRC_MOGWAI_MOGWAI_H_\n   30  \n   31: #include <vector>\n   32  #include <memory>\n   33  #include <string>\n   ..\n  130  //    private: // MOGWAI\n  131      friend class Extension;\n  132:     std::vector<Extension::UniquePtr> mpExtensions;\n  133  \n  134      struct DebugWindow {\n  ...\n  142          std::string mainOutput;\n  143          bool showAllOutputs = false;\n  144:         std::vector<std::string> originalOutputs;\n  145:         std::vector<DebugWindow> debugWindows;\n  146          std::unordered_map<std::string, uint32_t> graphOutputRefs;\n  147      };\n  ...\n  165      void endFrame(RenderContext* pRenderContext, const Fbo::SharedPtr& pTargetFbo);\n  166  \n  167:     std::vector<std::string> getGraphOutputs(const RenderGraph::SharedPtr& pGraph);\n  168      void graphOutputsGui(Gui::Widgets& widget);\n  169      bool renderDebugWindow(Gui::Widgets& widget, const Gui::DropdownList& dropdown, DebugWindow& data, const uint2& winSize); // Returns false if the window was closed\n  ...\n  177      AppData mAppData;\n  178  \n  179:     std::vector<GraphData> mGraphs;\n  180      uint32_t mActiveGraph = 0;\n  181      Sampler::SharedPtr mpSampler = nullptr;\n\n/home/max/dev/Falcor/src/pxr/CMakeLists.txt:\n   22  LINK_DIRECTORIES(${PXR_LIBRARIES})\n   23  \n   24: add_subdirectory( imaging/plugin/hdLava ) # usdview hydra renderer plugin\n   25  \n\n/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/aovDescriptor.h:\n  113      std::map<TfToken, AovNameLookupValue> m_aovNameLookup;\n  114  \n  115:     std::vector<HdLavaAovDescriptor> m_aovDescriptors;\n  116:     std::vector<HdLavaAovDescriptor> m_computedAovDescriptors;\n  117  };\n  118  \n\n/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/CMakeLists.txt:\n   77  \n   78  set(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE)\n   79: target_include_directories(hdLava PUBLIC ${PROJECT_SOURCE_DIR}/src/pxr/imaging/plugin/hdLava)\n   80  \n   81  #GroupSources(hdLava)\n\n/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/debugCodes.cpp:\n   21  TF_REGISTRY_FUNCTION(TfDebug) {\n   22      TF_DEBUG_ENVIRONMENT_SYMBOL(LAVA_USD_DEBUG_CORE_UNSUPPORTED_ERROR, \"signal about unsupported errors\");\n   23:     TF_DEBUG_ENVIRONMENT_SYMBOL(LAVA_USD_DEBUG_DUMP_MATERIALS, \"Dump material networks to the files in the current working directory\")\n   24  }\n   25  \n\n/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/lavaApi.cpp:\n   51  \n   52  #include <fstream>\n   53: #include <vector>\n   54  #include <mutex>\n   55  \n   ..\n   68  using LockGuard = std::lock_guard<std::mutex>;\n   69  \n   70: bool ArchCreateDirectory(const char* path) {\n   71  #ifdef WIN32\n   72:     return CreateDirectory(path, NULL) == TRUE;\n   73  #else\n   74      return mkdir(path, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH) == 0;\n   ..\n  104          addMappingEntry(\"float4\", HdFormatFloat32Vec4);\n  105          addMappingEntry(\"point3f\", HdFormatFloat32Vec3);\n  106:         addMappingEntry(\"vector3f\", HdFormatFloat32Vec3);\n  107          addMappingEntry(\"normal3f\", HdFormatFloat32Vec3);\n  108          addMappingEntry(\"color3f\", HdFormatFloat32Vec3);\n  ...\n  132  \n  133  HdLavaApi::HdLavaApi(HdLavaDelegate* delegate) : mDelegate(delegate) {\n  134:     printf(\"HdLavaApi constructor\\n\");\n  135      mRenderer = lava::Renderer::create();\n  136  }\n\n/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/lavaApi.cpp.old:\n   55  \n   56  #include <fstream>\n   57: #include <vector>\n   58  #include <mutex>\n   59  \n   ..\n   72  using LockGuard = std::lock_guard<std::mutex>;\n   73  \n   74: bool ArchCreateDirectory(const char* path) {\n   75  #ifdef WIN32\n   76:     return CreateDirectory(path, NULL) == TRUE;\n   77  #else\n   78      return mkdir(path, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH) == 0;\n   ..\n  118          addMappingEntry(\"float4\", HdFormatFloat32Vec4);\n  119          addMappingEntry(\"point3f\", HdFormatFloat32Vec3);\n  120:         addMappingEntry(\"vector3f\", HdFormatFloat32Vec3);\n  121          addMappingEntry(\"normal3f\", HdFormatFloat32Vec3);\n  122          addMappingEntry(\"color3f\", HdFormatFloat32Vec3);\n  ...\n  149          rpr::Context* rprContext,\n  150          rpr::MaterialNodeType nodeType,\n  151:         std::vector<std::pair<rpr::MaterialNodeInput, GfVec4f>> const& inputs) {\n  152  \n  153          rpr::Status status;\n  ...\n  377          size_t dummy;\n  378          int oldLevel;\n  379:         if (!RPR_ERROR_CHECK(mesh->GetInfo(RPR_SHAPE_SUBDIVISION_FACTOR, sizeof(oldLevel), &oldLevel, &dummy), \"Failed to query mesh subdivision factor\")) {\n  380              dirty = level != oldLevel;\n  381          }\n  382  \n  383          if (dirty) {\n  384:             if (RPR_ERROR_CHECK(mesh->SetSubdivisionFactor(level), \"Failed to set mesh subdividion level\")) return;\n  385              m_dirtyFlags |= ChangeTracker::DirtyScene;\n  386          }\n  ...\n  736          rpr_image_format format = {3, RPR_COMPONENT_TYPE_FLOAT32};\n  737          rpr_uint imageSize = m_rprContextMetadata.pluginType == kPluginHybrid ? 64 : 1;\n  738:         std::vector<std::array<float, 3>> imageData(imageSize * imageSize, backgroundColor);\n  739  \n  740          LockGuard rprLock(m_rprContext->GetMutex());\n  ...\n  793          // At this point, the matrix is orthonormal.\n  794          // Check for a coordinate system flip. If the determinant\n  795:         // is -1, then negate the matrix and the scaling factors.\n  796          if (GfDot(col[0], GfCross(col[1], col[2])) < 0.0f) {\n  797              for (int i = 0; i < 3; i++) {\n  ...\n  955      RprUsdMaterial* CreateRawMaterial(\n  956          rpr::MaterialNodeType nodeType,\n  957:         std::vector<std::pair<rpr::MaterialNodeInput, GfVec4f>> const& inputs) {\n  958          if (!m_rprContext) {\n  959              return nullptr;\n  ...\n 1129      }\n 1130  \n 1131:     void SetAovBindings(HdRenderPassAovBindingVector const& aovBindings) {\n 1132          m_aovBindings = aovBindings;\n 1133          m_dirtyFlags |= ChangeTracker::DirtyAOVBindings;\n 1134      }\n 1135  \n 1136:     HdRenderPassAovBindingVector const& GetAovBindings() const {\n 1137          return m_aovBindings;\n 1138      }\n 1139  \n 1140      void ResolveFramebuffers(bool* firstResolve) {\n 1141:         std::vector<std::shared_ptr<HdLavaApiAov>> computedAovsToResolve;\n 1142          for (auto& aovEntry : m_aovRegistry) {\n 1143              auto aov = aovEntry.second.lock();\n ....\n 2470      std::map<TfToken, std::weak_ptr<HdLavaApiAov>> m_aovRegistry;\n 2471      std::map<TfToken, std::shared_ptr<HdLavaApiAov>> m_internalAovs;\n 2472:     HdRenderPassAovBindingVector m_aovBindings;\n 2473  \n 2474      struct OutputRenderBuffer {\n ....\n 2481          size_t mappedDataSize;\n 2482      };\n 2483:     std::vector<OutputRenderBuffer> m_outputRenderBuffers;\n 2484  \n 2485      GfVec2i m_viewportSize = GfVec2i(0);\n ....\n 2712  }\n 2713  \n 2714: void HdLavaApi::SetAovBindings(HdRenderPassAovBindingVector const& aovBindings) {\n 2715      m_impl->InitIfNeeded();\n 2716      m_impl->SetAovBindings(aovBindings);\n 2717  }\n 2718  \n 2719: HdRenderPassAovBindingVector HdLavaApi::GetAovBindings() const {\n 2720      return m_impl->GetAovBindings();\n 2721  }\n ....\n 2794      }();\n 2795      if (!appDataPath.empty()) {\n 2796:         ArchCreateDirectory(appDataPath.c_str());\n 2797      }\n 2798      return appDataPath;\n ....\n 2803      if (!path.empty()) {\n 2804          path = (path + ARCH_PATH_SEP) + \"cache\";\n 2805:         ArchCreateDirectory(path.c_str());\n 2806      }\n 2807      return path;\n\n/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/lavaApi.h:\n   30  \n   31  #include <memory>\n   32: #include <vector>\n   33  #include <string>\n   34  \n\n/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/lavaApi.h.old:\n   32  \n   33  #include <memory>\n   34: #include <vector>\n   35  #include <string>\n   36  \n   ..\n  137      void SetViewportSize(GfVec2i const& size);\n  138  \n  139:     //void SetAovBindings(HdRenderPassAovBindingVector const& aovBindings);\n  140:     //HdRenderPassAovBindingVector GetAovBindings() const;\n  141  \n  142      int GetNumCompletedSamples() const;\n\n/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/lavaApiAov.h:\n  141  \n  142      Filter m_mainFilterType = kFilterNone;\n  143:     std::vector<std::pair<Filter, std::unique_ptr<rif::Filter>>> m_auxFilters;\n  144  \n  145      uint32_t m_enabledFilters = kFilterNone;\n\n/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/pch.h:\n   64  #include BOOST_INCLUDE_PATH(mpl/pop_front.hpp)\n   65  #include BOOST_INCLUDE_PATH(mpl/remove.hpp)\n   66: #include BOOST_INCLUDE_PATH(mpl/vector.hpp)\n   67  #include BOOST_INCLUDE_PATH(noncopyable.hpp)\n   68  #include BOOST_INCLUDE_PATH(operators.hpp)\n   ..\n  133  #include <unordered_set>\n  134  #include <utility>\n  135: #include <vector>\n  136  #include <tbb/atomic.h>\n\n/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/renderBuffer.h:\n   64      HdFormat m_format = HdFormat::HdFormatInvalid;\n   65  \n   66:     std::vector<uint8_t> m_mappedBuffer;\n   67      std::atomic<int> m_numMappers;\n   68      std::atomic<bool> m_isConverged;\n\n/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/renderDelegate.cpp:\n  123  );\n  124  \n  125: const TfTokenVector HdLavaDelegate::SUPPORTED_RPRIM_TYPES = {\n  126      HdPrimTypeTokens->mesh,\n  127      HdPrimTypeTokens->basisCurves,\n  ...\n  132  };\n  133  \n  134: const TfTokenVector HdLavaDelegate::SUPPORTED_SPRIM_TYPES = {\n  135      HdPrimTypeTokens->camera,\n  136      HdPrimTypeTokens->material,\n  ...\n  144  };\n  145  \n  146: const TfTokenVector HdLavaDelegate::SUPPORTED_BPRIM_TYPES = {\n  147  #ifdef USE_VOLUME\n  148      _tokens->openvdbAsset,\n  ...\n  152  \n  153  HdLavaDelegate::HdLavaDelegate() {\n  154:     printf(\"HdLavaDelegate constructor\\n\");\n  155      m_isBatch = GetRenderSetting(_tokens->renderMode) == _tokens->batch;\n  156      m_isProgressive = GetRenderSetting(_tokens->progressive).GetWithDefault(true);\n  ...\n  185  \n  186  HdLavaDelegate::~HdLavaDelegate() {\n  187:     printf(\"HdLavaDelegate destructor\\n\");\n  188      g_rprApi = nullptr;\n  189  }\n  ...\n  199  }\n  200  \n  201: TfToken HdLavaDelegate::GetMaterialNetworkSelector() const {\n  202:     //return LavaUsdMaterialRegistry::GetInstance().GetMaterialNetworkSelector();\n  203      return TfToken();\n  204  }\n  205  \n  206: TfTokenVector const& HdLavaDelegate::GetSupportedRprimTypes() const {\n  207      return SUPPORTED_RPRIM_TYPES;\n  208  }\n  209  \n  210: TfTokenVector const& HdLavaDelegate::GetSupportedSprimTypes() const {\n  211      return SUPPORTED_SPRIM_TYPES;\n  212  }\n  213  \n  214: TfTokenVector const& HdLavaDelegate::GetSupportedBprimTypes() const {\n  215      return SUPPORTED_BPRIM_TYPES;\n  216  }\n\n/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/renderDelegate.h:\n   22      HdLavaDelegate& operator =(const HdLavaDelegate&) = delete;\n   23  \n   24:     const TfTokenVector& GetSupportedRprimTypes() const override;\n   25:     const TfTokenVector& GetSupportedSprimTypes() const override;\n   26:     const TfTokenVector& GetSupportedBprimTypes() const override;\n   27  \n   28      HdRenderParam* GetRenderParam() const override;\n   ..\n   49  \n   50      TfToken GetMaterialBindingPurpose() const override { return HdTokens->full; }\n   51:     TfToken GetMaterialNetworkSelector() const override;\n   52  \n   53      HdAovDescriptor GetDefaultAovDescriptor(TfToken const& name) const override;\n   ..\n   71  \n   72  private:\n   73:     static const TfTokenVector SUPPORTED_RPRIM_TYPES;\n   74:     static const TfTokenVector SUPPORTED_SPRIM_TYPES;\n   75:     static const TfTokenVector SUPPORTED_BPRIM_TYPES;\n   76  \n   77      bool m_isBatch;\n\n/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/renderParam.h:\n   42  \n   43      std::mutex mSubscribedVolumesMutex;\n   44:     std::map<SdfPath, std::vector<HdLavaVolumeFieldSubscriptionHandle>> mSubscribedVolumes;\n   45  \n   46      std::atomic<bool> mRestartRender;\n\n/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/renderPass.cpp:\n   12  \n   13  HdLavaRenderPass::HdLavaRenderPass(HdRenderIndex* index, HdRprimCollection const& collection, HdLavaRenderParam* renderParam): HdRenderPass(index, collection), m_renderParam(renderParam) {\n   14:     printf(\"HdLavaRenderPass constructor\\n\");\n   15  \n   16      glEnable(GL_TEXTURE_2D);\n   ..\n   24  }\n   25  \n   26: void HdLavaRenderPass::_Execute(HdRenderPassStateSharedPtr const& renderPassState, TfTokenVector const& renderTags) {\n   27      // To avoid potential deadlock:\n   28      //   main thread locks config instance and requests render stop and\n\n/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/renderPass.h:\n   22  \n   23      void _Execute(HdRenderPassStateSharedPtr const& renderPassState,\n   24:                   TfTokenVector const& renderTags) override;\n   25  \n   26   private:\n\n/home/max/dev/Falcor/src/RenderPasses/AccumulatePass/AccumulatePass.cpp:\n   56  const char kPrecisionMode[] = \"precisionMode\";\n   57  \n   58: const Gui::DropdownList kModeSelectorList = {\n   59      { (uint32_t)AccumulatePass::Precision::Double, \"Double precision\" },\n   60      { (uint32_t)AccumulatePass::Precision::Single, \"Single precision\" },\n   ..\n   81      mpProgram[Precision::Single] = ComputeProgram::createFromFile(pDevice, kShaderFile, \"accumulateSingle\", Program::DefineList(), Shader::CompilerFlags::TreatWarningsAsErrors);\n   82      mpProgram[Precision::SingleCompensated] = ComputeProgram::createFromFile(pDevice, kShaderFile, \"accumulateSingleCompensated\", Program::DefineList(), Shader::CompilerFlags::FloatingPointModePrecise | Shader::CompilerFlags::TreatWarningsAsErrors);\n   83:     mpVars = ComputeVars::create(pDevice, mpProgram[Precision::Single]->getReflector());\n   84  \n   85      mpState = ComputeState::create(pDevice);\n   ..\n   94  \n   95  RenderPassReflection AccumulatePass::reflect(const CompileData& compileData) {\n   96:     RenderPassReflection reflector;\n   97:     reflector.addInput(kInputChannel, \"Input data to be temporally accumulated\").bindFlags(ResourceBindFlags::ShaderResource);\n   98:     reflector.addOutput(kOutputChannel, \"Output data that is temporally accumulated\").bindFlags(ResourceBindFlags::RenderTarget | ResourceBindFlags::UnorderedAccess | ResourceBindFlags::ShaderResource).format(ResourceFormat::RGBA32Float);\n   99:     return reflector;\n  100  }\n  101  \n  ...\n  166      auto pProgram = mpProgram[mPrecisionMode];\n  167      assert(pProgram);\n  168:     uint3 numGroups = div_round_up(uint3(resolution.x, resolution.y, 1u), pProgram->getReflector()->getThreadGroupSize());\n  169      mpState->setProgram(pProgram);\n  170      pRenderContext->dispatch(mpState.get(), mpVars.get(), numGroups);\n  ...\n  178  \n  179      if (mEnableAccumulation) {\n  180:         if (widget.dropdown(\"Mode\", kModeSelectorList, (uint32_t&)mPrecisionMode)) {\n  181              // Reset accumulation when mode changes.\n  182              mFrameCount = 0;\n\n/home/max/dev/Falcor/src/RenderPasses/Antialiasing/FXAA/FXAA.cpp:\n   74  \n   75  RenderPassReflection FXAA::reflect(const CompileData& compileData) {\n   76:     RenderPassReflection reflector;\n   77:     reflector.addInput(kSrc, \"Source color-buffer\");\n   78:     reflector.addOutput(kDst, \"Destination color-buffer\");\n   79:     return reflector;\n   80  }\n   81  \n\n/home/max/dev/Falcor/src/RenderPasses/Antialiasing/TAA/TAA.cpp:\n   69  RenderPassReflection TAA::reflect(const CompileData& compileData) {\n   70      RenderPassReflection reflection;\n   71:     reflection.addInput(kMotionVec, \"Screen-space motion vectors\");\n   72      reflection.addInput(kColorIn, \"Color-buffer of the current frame\");\n   73      reflection.addOutput(kColorOut, \"Anti-aliased color buffer\");\n\n/home/max/dev/Falcor/src/RenderPasses/Antialiasing/TAA/TAA.ps.slang:\n  114      float3 colorMax = colorAvg + gColorBoxSigma * sigma;    \n  115  \n  116:     // Find the longest motion vector\n  117      float2 motion = gTexMotionVec.Load(int3(ipos, 0)).xy;\n  118      [unroll]\n  ...\n  123      }\n  124  \n  125:     // Use motion vector to fetch previous frame color (history)\n  126      float3 history = bicubicSampleCatmullRom(gTexPrevColor, gSampler, (texC + motion) * texDim, texDim);\n  127  \n  ...\n  130      // Anti-flickering, based on Brian Karis talk @Siggraph 2014\n  131      // https://de45xmedrsdbp.cloudfront.net/Resources/files/TemporalAA_small-59732822.pdf\n  132:     // Reduce blend factor when history is near clamping\n  133      float distToClamp = min(abs(colorMin.x - history.x), abs(colorMax.x - history.x));\n  134      float alpha = clamp((gAlpha * distToClamp) / (distToClamp + colorMax.x - colorMin.x), 0.0f, 1.0f);\n\n/home/max/dev/Falcor/src/RenderPasses/BlitPass/BlitPass.cpp:\n   44  \n   45  RenderPassReflection BlitPass::reflect(const CompileData& compileData) {\n   46:     RenderPassReflection reflector;\n   47  \n   48:     reflector.addOutput(kDst, \"The destination texture\");\n   49:     reflector.addInput(kSrc, \"The source texture\");\n   50  \n   51:     return reflector;\n   52  }\n   53  \n\n/home/max/dev/Falcor/src/RenderPasses/BSDFViewer/BSDFViewer.cs.slang:\n   75      \\param[out] v Interpolated attributes for the point on the sphere.\n   76      \\param[out] viewDir View direction.\n   77:     \\return Normalized incident direction (light vector).\n   78  */\n   79  float3 calculateSliceGeometry(float2 uv, out VertexData v, out float3 viewDir)\n   ..\n   95      float HdotL = cos(theta_d);     // Note: HdotL = HdotV\n   96  \n   97:     // Place the H vector at (0,0,1) to start.\n   98      // Compute L, V that are mirrored about the yz-plane.\n   99      float3 L = float3(sqrt(1.f - HdotL * HdotL), 0, HdotL);\n  ...\n  106      V = float3(V.x, cos_h * V.y - sin_h * V.z, sin_h * V.y + cos_h * V.z);\n  107  \n  108:     // Return vectors.\n  109      viewDir = V;\n  110      return normalize(L);\n  ...\n  353      The viewport shows an analytic sphere of the specified material at infinite distance.\n  354      When each pixel is evaluated using a random light direction and omnidirectional white light,\n  355:     the result converges to the total reflectance (integral of BSDF times the dot(N,L) factor.\n  356      \\return Outgoing radiance value.\n  357  */\n\n/home/max/dev/Falcor/src/RenderPasses/BSDFViewer/BSDFViewerParams.slang:\n   59      float   _mpad4;\n   60  \n   61:     float   metallic = 0.f;                     ///< Metallic factor in [0,1]. This blends between the dielectric BSDF and the metallic BRDF.\n   62      float   IoR = 1.5f;                         ///< Index of refraction in [1,inf). This is used to compute the specular reflectance/transmittance for dielectrics.\n   63      float2  texCoords = { 0.f, 0.f };           ///< Texture coordinates to use when 'useFixedTexCoords' is true.\n\n/home/max/dev/Falcor/src/RenderPasses/CMakeLists.txt:\n   11  # Python\n   12  find_package(PythonLibs 3.7 REQUIRED)\n   13: include_directories(${PYTHON_INCLUDE_DIRS})\n   14  \n   15  # This function builds render pass library\n   ..\n   44      #endif\n   45  \n   46:     link_directories(\n   47          ${PASS_LIBRARY_OUTPUT_DIRECTORY}\n   48      )\n   ..\n   98  makeRenderPassLib(NAME \"ForwardLightingPass\")\n   99  makeRenderPassLib(NAME \"SkyBox\")\n  100: makeRenderPassLib(NAME \"PixelInspectorPass\")\n  101  makeRenderPassLib(NAME \"AccumulatePass\")\n  102  makeRenderPassLib(NAME \"Antialiasing\")\n\n/home/max/dev/Falcor/src/RenderPasses/CSM/CascadedShadowMap.slang:\n  234  }\n  235  \n  236: float calcShadowFactorWithCascadeIdx(CsmData csmData, uint32_t cascadeIndex, float3 posW, float2 posSxy)\n  237  {\n  238      // Apply normal offset\n  ...\n  293  #if !defined(_CSM_CASCADE_COUNT) || (_CSM_CASCADE_COUNT != 1)\n  294      cascadeIndex = getCascadeIndex(csmData, cameraDepth);\n  295:     // Get the prev cascade factor\n  296      weight = 1 - ((cameraDepth - csmData.cascadeRange[cascadeIndex].x) / csmData.cascadeRange[cascadeIndex].y);\n  297      blend = weight < csmData.cascadeBlendThreshold;\n  ...\n  323  }\n  324  \n  325: float calcShadowFactor(CsmData csmData, float cameraDepth, float3 posW, float2 posSxy)\n  326  {\n  327      float weight;\n  328      int cascadeIndex;\n  329      bool blend = getCascadeParamsAndCheckForBlend(csmData, cameraDepth, cascadeIndex, weight);\n  330:     float s = calcShadowFactorWithCascadeIdx(csmData, cascadeIndex, posW, posSxy);\n  331  \n  332      if(blend)\n  333      {       \n  334          int nextCascade = min(getCascadeCount(csmData) - 1, cascadeIndex + 1);\n  335:         float nextS = calcShadowFactorWithCascadeIdx(csmData, nextCascade, posW, posSxy);\n  336          s = lerp(nextS, s, weight);\n  337      }\n\n/home/max/dev/Falcor/src/RenderPasses/CSM/CSM.cpp:\n  282  \n  283  RenderPassReflection CSM::reflect(const CompileData& compileData) {\n  284:     RenderPassReflection reflector;\n  285:     reflector.addOutput(kVisibility, \"Visibility map. Values are [0,1] where 0 means the pixel is completely shadowed and 1 means it's not shadowed at all\")\n  286          .format(getVisBufferFormat(mVisibilityPassData.mapBitsPerChannel, mVisibilityPassData.shouldVisualizeCascades))\n  287          .texture2D(mVisibilityPassData.screenDim.x, mVisibilityPassData.screenDim.y);\n  288:     reflector.addInput(kDepth, \"Pre-initialized scene depth buffer used for SDSM.\\nIf not provided, the pass will run a depth-pass internally\").flags(RenderPassReflection::Field::Flags::Optional);\n  289:     return reflector;\n  290  }\n  291  \n  ...\n  647      if (mpScene) {\n  648          mDepthPass.pProgram->addDefines(mpScene->getSceneDefines());\n  649:         mDepthPass.pVars = GraphicsVars::create(mpDevice, mDepthPass.pProgram->getReflector());\n  650  \n  651          mShadowPass.pProgram->addDefines(mpScene->getSceneDefines());\n  652:         mShadowPass.pVars = GraphicsVars::create(mpDevice, mShadowPass.pProgram->getReflector());\n  653  \n  654:         const auto& pReflector = mShadowPass.pVars->getReflection();\n  655:         const auto& pDefaultBlock = pReflector->getDefaultParameterBlock();\n  656          mPerLightCbLoc = pDefaultBlock->getResourceBinding(\"PerLightCB\");\n  657      } else {\n\n/home/max/dev/Falcor/src/RenderPasses/CSM/VisibilityPass.ps.slang:\n   67  \n   68      float4 color = float4(0,0,0,0);\n   69:     color.r = calcShadowFactor(gCsmData, depth, posW, ndcXy);\n   70  \n   71      if(gPass.visualizeCascades)\n\n/home/max/dev/Falcor/src/RenderPasses/DepthPass/DepthPass.cpp:\n   79  \n   80  RenderPassReflection DepthPass::reflect(const CompileData& compileData) {\n   81:     RenderPassReflection reflector;\n   82:     reflector.addOutput(kDepth, \"Depth-buffer\").bindFlags(Resource::BindFlags::DepthStencil).format(mDepthFormat).texture2D(0, 0, 0);\n   83:     return reflector;\n   84  }\n   85  \n   ..\n   87      mpScene = pScene;\n   88      if (mpScene) mpState->getProgram()->addDefines(mpScene->getSceneDefines());\n   89:     mpVars = GraphicsVars::create(pRenderContext->device(), mpState->getProgram()->getReflector());\n   90  }\n   91  \n\n/home/max/dev/Falcor/src/RenderPasses/ErrorMeasurePass/ErrorMeasurePass.cpp:\n  115  \n  116  RenderPassReflection ErrorMeasurePass::reflect(const CompileData& compileData) {\n  117:     RenderPassReflection reflector;\n  118:     reflector.addInput(kInputChannelSourceImage, \"Source image\");\n  119:     reflector.addInput(kInputChannelReferenceImage, \"Reference image (optional)\").flags(RenderPassReflection::Field::Flags::Optional);\n  120:     reflector.addInput(kInputChannelWorldPosition, \"World-space position\").flags(RenderPassReflection::Field::Flags::Optional);\n  121      // TODO: when compile() is available, match the format of the source image?\n  122:     reflector.addOutput(kOutputChannelImage, \"Output image\").format(ResourceFormat::RGBA32Float);\n  123:     return reflector;\n  124  }\n  125  \n\n/home/max/dev/Falcor/src/RenderPasses/ForwardLightingPass/ForwardLightingPass.cpp:\n   40  \n   41  const char* ForwardLightingPass::kDesc = \"The pass computes the lighting results for the current scene. It will compute direct-illumination, indirect illumination from the light-probe and apply shadows (if a visibility map is provided).\\n\"\n   42: \"The pass can output the world-space normals and screen-space motion vectors, both are optional\";\n   43  \n   44  namespace {\n   ..\n   87  \n   88  RenderPassReflection ForwardLightingPass::reflect(const CompileData& compileData) {\n   89:     RenderPassReflection reflector;\n   90  \n   91:     reflector.addInput(kVisBuffer, \"Visibility buffer used for shadowing. Range is [0,1] where 0 means the pixel is fully-shadowed and 1 means the pixel is not shadowed at all\").flags(RenderPassReflection::Field::Flags::Optional);\n   92:     reflector.addInputOutput(kColor, \"Color texture\").format(mColorFormat).texture2D(0, 0, mSampleCount);\n   93  \n   94:     auto& depthField = mUsePreGenDepth ? reflector.addInputOutput(kDepth, \"Pre-initialized depth-buffer\") : reflector.addOutput(kDepth, \"Depth buffer\");\n   95      depthField.bindFlags(Resource::BindFlags::DepthStencil).texture2D(0, 0, mSampleCount);\n   96  \n   97      if (mNormalMapFormat != ResourceFormat::Unknown) {\n   98:         reflector.addOutput(kNormals, \"World-space normal, [0,1] range. Don't forget to transform it to [-1, 1] range\").format(mNormalMapFormat).texture2D(0, 0, mSampleCount);\n   99      }\n  100  \n  101      if (mMotionVecFormat != ResourceFormat::Unknown) {\n  102:         reflector.addOutput(kMotionVecs, \"Screen-space motion vectors\").format(mMotionVecFormat).texture2D(0, 0, mSampleCount);\n  103      }\n  104  \n  105:     return reflector;\n  106  }\n  107  \n  ...\n  111      if (mpScene) mpState->getProgram()->addDefines(mpScene->getSceneDefines());\n  112  \n  113:     mpVars = GraphicsVars::create(pRenderContext->device(), mpState->getProgram()->getReflector());\n  114  \n  115      Sampler::Desc samplerDesc;\n\n/home/max/dev/Falcor/src/RenderPasses/ForwardLightingPass/ForwardLightingPass.h:\n   60      ForwardLightingPass& setNormalMapFormat(ResourceFormat format);\n   61  \n   62:     /** Set the motion vectors map format. Setting this to ResourceFormat::Unknown will disable this output\n   63      */\n   64      ForwardLightingPass& setMotionVecFormat(ResourceFormat format);\n\n/home/max/dev/Falcor/src/RenderPasses/ForwardLightingPass/ForwardLightingPass.slang:\n   69      for (uint l = 0; l < gScene.getLightCount(); l++)\n   70      {\n   71:         float shadowFactor = 1;\n   72         if (l == 0)\n   73          {\n   74:             shadowFactor = visibilityBuffer.Load(int3(vOut.posH.xy, 0)).r;\n   75:             shadowFactor *= sd.opacity;\n   76          }\n   77:         finalColor.rgb += evalMaterial(sd, gScene.getLight(l), shadowFactor).color.rgb;\n   78      }\n   79  \n   ..\n   88  #ifdef _OUTPUT_MOTION_VECTORS\n   89      // Using vOut.posH.xy as pixel coordinate since it has the SV_Position semantic.\n   90:     psOut.motion = calcMotionVector(vOut.posH.xy, vOut.prevPosH, gRenderTargetDim);\n   91  #endif\n   92  \n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/GBuffer/GBuffer.cpp:\n  101      // Bent normals control.\n  102      mOptionsChanged |= widget.checkbox(\"Use bent normals\", mUseBentShadingNormals);\n  103:     widget.tooltip(\"Enables adjustment of the shading normals to reduce the risk of black pixels due to back-facing vectors.\", true);\n  104  }\n  105  \n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/GBuffer/GBufferRaster.3d.slang:\n   36  // UAV output channels\n   37  RWTexture2D<uint2>  gVBuffer;\n   38: RWTexture2D<float2> gMotionVectors;\n   39  RWTexture2D<float4> gFaceNormalW;\n   40  RWTexture2D<float2> gPosNormalFwidth;\n   ..\n  108      }\n  109  \n  110:     // Compute motion vectors.\n  111:     if (isValid(gMotionVectors))\n  112      {\n  113          const float2 pixelPos = ipos + float2(0.5, 0.5); // Current sample in pixel coords.\n  114          const float4 prevPosH = vsOut.prevPosH; // Sample in previous frame in clip space coords, no jittering applied.\n  115:         const float2 mv = calcMotionVector(pixelPos, prevPosH, gParams.frameSize) + float2(gScene.camera.data.jitterX, -gScene.camera.data.jitterY); // Remove camera jitter from motion vector\n  116:         gMotionVectors[ipos] = mv;\n  117      }\n  118  \n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/GBuffer/GBufferRaster.cpp:\n   47  const ChannelList kGBufferExtraChannels = {\n   48      { \"vbuffer\",          \"gVBuffer\",            \"Visibility buffer\",                true /* optional */, ResourceFormat::RG32Uint    },\n   49:     { \"mvec\",             \"gMotionVectors\",      \"Motion vectors\",                   true /* optional */, ResourceFormat::RG32Float   },\n   50      { \"faceNormalW\",      \"gFaceNormalW\",        \"Face normal in world space\",       true /* optional */, ResourceFormat::RGBA32Float },\n   51      { \"pnFwidth\",         \"gPosNormalFwidth\",    \"position and normal filter width\", true /* optional */, ResourceFormat::RG32Float   },\n   ..\n   62  \n   63  RenderPassReflection GBufferRaster::reflect(const CompileData& compileData) {\n   64:     RenderPassReflection reflector;\n   65  \n   66      // Add the required depth output. This always exists.\n   67:     reflector.addOutput(kDepthName, \"Depth buffer\").format(ResourceFormat::D32Float).bindFlags(Resource::BindFlags::DepthStencil);\n   68  \n   69      // Add all the other outputs.\n   70      // The default channels are written as render targets, the rest as UAVs as there is way to assign/pack render targets yet.\n   71:     addRenderPassOutputs(reflector, kGBufferChannels, Resource::BindFlags::RenderTarget);\n   72:     addRenderPassOutputs(reflector, kGBufferExtraChannels, Resource::BindFlags::UnorderedAccess);\n   73  \n   74:     return reflector;\n   75  }\n   76  \n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/GBuffer/GBufferRT.cpp:\n   57      {\n   58          { \"vbuffer\",        \"gVBuffer\",         \"Visibility buffer\",                true /* optional */, ResourceFormat::RG32Uint    },\n   59:         { \"mvec\",           \"gMotionVectors\",   \"Motion vectors\",                   true /* optional */, ResourceFormat::RG32Float   },\n   60          { \"faceNormalW\",    \"gFaceNormalW\",     \"Face normal in world space\",       true /* optional */, ResourceFormat::RGBA32Float },\n   61          { \"viewW\",          \"gViewW\",           \"View direction in world space\",    true /* optional */, ResourceFormat::RGBA32Float }, // TODO: Switch to packed 2x16-bit snorm format.\n   ..\n   73  RenderPassReflection GBufferRT::reflect(const CompileData& compileData)\n   74  {\n   75:     RenderPassReflection reflector;\n   76  \n   77      // Add all outputs as UAVs.\n   78:     addRenderPassOutputs(reflector, kGBufferChannels);\n   79:     addRenderPassOutputs(reflector, kGBufferExtraChannels);\n   80  \n   81:     return reflector;\n   82  }\n   83  \n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/GBuffer/GBufferRT.rt.slang:\n   43  // GBufferRT channels\n   44  RWTexture2D<uint2> gVBuffer;\n   45: RWTexture2D<float2> gMotionVectors;\n   46  RWTexture2D<float4> gFaceNormalW;\n   47  RWTexture2D<float4> gViewW;\n   ..\n  160      }\n  161  \n  162:     // Compute motion vectors.\n  163:     if (isValid(gMotionVectors))\n  164      {\n  165          float2 pixelPos = launchIndex + float2(0.5f, 0.5f);\n  166          float3 prevPosW = getPrevPosW(hitParams, triangleIndex, attribs);\n  167          float4 prevPosH = mul(float4(prevPosW, 1.f), gScene.camera.data.prevViewProjMatNoJitter);\n  168:         float2 motionVec = calcMotionVector(pixelPos, prevPosH, gParams.frameSize) + float2(gScene.camera.data.jitterX, -gScene.camera.data.jitterY); // Remove camera jitter from motion vector\n  169:         gMotionVectors[launchIndex] = motionVec;\n  170      }\n  171  \n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/VBuffer/VBufferRaster.cpp:\n   42  \n   43  RenderPassReflection VBufferRaster::reflect(const CompileData& compileData) {\n   44:     RenderPassReflection reflector;\n   45  \n   46:     reflector.addOutput(kDepthName, \"Depth buffer\").format(ResourceFormat::D32Float).bindFlags(Resource::BindFlags::DepthStencil);\n   47:     reflector.addOutput(kOutputName, kOutputDesc).bindFlags(Resource::BindFlags::RenderTarget | Resource::BindFlags::UnorderedAccess).format(ResourceFormat::RG32Uint);\n   48  \n   49:     return reflector;\n   50  }\n   51  \n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/VBuffer/VBufferRT.cpp:\n   48  RenderPassReflection VBufferRT::reflect(const CompileData& compileData)\n   49  {\n   50:     RenderPassReflection reflector;\n   51  \n   52:     reflector.addOutput(kOutputName, kOutputDesc).bindFlags(Resource::BindFlags::UnorderedAccess).format(ResourceFormat::RG32Uint);\n   53  \n   54:     return reflector;\n   55  }\n   56  \n\n/home/max/dev/Falcor/src/RenderPasses/ImageLoader/ImageLoader.cpp:\n   49  \n   50  RenderPassReflection ImageLoader::reflect(const CompileData& compileData) {\n   51:     RenderPassReflection reflector;\n   52:     reflector.addOutput(kDst, \"Destination texture\");\n   53:     return reflector;\n   54  }\n   55  \n   ..\n  114  \n  115      if (reloadImage && mImageName.size()) {\n  116:         mImageName = stripDataDirectories(mImageName);\n  117          mpTex = Texture::createFromFile(widget.gui()->device(), mImageName, mGenerateMips, mLoadSRGB);\n  118      }\n\n/home/max/dev/Falcor/src/RenderPasses/make_new_pass_project.py:\n    8  \n    9  def create_project(name):\n   10:     # Source and destination directories.\n   11      src_dir = RENDER_PASSES_DIR / TEMPLATE_NAME\n   12      dst_dir = RENDER_PASSES_DIR / name\n\n/home/max/dev/Falcor/src/RenderPasses/MegakernelPathTracer/MegakernelPathTracer.cpp:\n  173  \n  174      // Create parameter block for shared data.\n  175:     ProgramReflection::SharedConstPtr pReflection = mTracer.pProgram->getReflector();\n  176      ParameterBlockReflection::SharedConstPtr pBlockReflection = pReflection->getParameterBlock(kParameterBlockName);\n  177      assert(pBlockReflection);\n\n/home/max/dev/Falcor/src/RenderPasses/MinimalPathTracer/MinimalPathTracer.cpp:\n  104  RenderPassReflection MinimalPathTracer::reflect(const CompileData& compileData)\n  105  {\n  106:     RenderPassReflection reflector;\n  107  \n  108      // Define our input/output channels.\n  109:     addRenderPassInputs(reflector, kInputChannels);\n  110:     addRenderPassOutputs(reflector, kOutputChannels);\n  111  \n  112:     return reflector;\n  113  }\n  114  \n\n/home/max/dev/Falcor/src/RenderPasses/MinimalPathTracer/MinimalPathTracer.rt.slang:\n  151      if (isValid(gWorldView))\n  152      {\n  153:         // If we have the view vector bound as a buffer, just fetch it. No need to compute anything.\n  154          return -gWorldView[launchIndex].xyz;\n  155      }\n  156      else\n  157      {\n  158:         // Compute the view vector. This must exactly match what the G-buffer pass is doing (jitter etc.).\n  159          // Note that we do not take depth-of-field into account as it would require exactly matching the\n  160          // sample generator between the passes, which is error prone. The host side will issue a warning instead.\n\n/home/max/dev/Falcor/src/RenderPasses/PassLibraryTemplate/PassLibraryTemplate.cpp:\n   53  {\n   54      // Define the required resources here\n   55:     RenderPassReflection reflector;\n   56:     //reflector.addOutput(\"dst\");\n   57:     //reflector.addInput(\"src\");\n   58:     return reflector;\n   59  }\n   60  \n\n/home/max/dev/Falcor/src/RenderPasses/PixelInspectorPass/PixelInspector.cs.slang:\n   30  import Experimental.Scene.Material.MaterialHelpers;\n   31  import Utils.Color.ColorHelpers;\n   32: import PixelInspectorData;\n   33  \n   34  cbuffer PerFrameCB\n   ..\n   95      const float3 faceNormal = gWorldFaceNormal[gWorldFaceNormalCoord].xyz;\n   96  \n   97:     // Compute the view vector. This must exactly match what the G-buffer pass is doing (jitter etc.).\n   98      // Note that we do not take depth-of-field into account as it would require exactly matching the\n   99      // sample generator between the passes, which is error prone. The host side will issue a warning instead.\n\n/home/max/dev/Falcor/src/RenderPasses/PixelInspectorPass/PixelInspectorData.slang:\n   35  #endif\n   36  \n   37: /** Pixel data read out by the InspectorPass.\n   38  */\n   39  struct PixelData\n\n/home/max/dev/Falcor/src/RenderPasses/PixelInspectorPass/PixelInspectorPass.cpp:\n   26   # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n   27   **************************************************************************/\n   28: #include \"PixelInspectorPass.h\"\n   29: #include \"PixelInspectorData.slang\"\n   30  #include \"RenderGraph/RenderPassHelpers.h\"\n   31  \n   ..\n   36  \n   37  extern \"C\" falcorexport void getPasses(Falcor::RenderPassLibrary& lib) {\n   38:     lib.registerClass(\"PixelInspectorPass\", \"Per pixel surface attributes inspector\", PixelInspectorPass::create);\n   39  }\n   40  \n   41  namespace {\n   42  \n   43: const char kShaderFile[] = \"RenderPasses/PixelInspectorPass/PixelInspector.cs.slang\";\n   44  \n   45  const ChannelList kInputChannels = {\n   ..\n   61  }\n   62  \n   63: PixelInspectorPass::SharedPtr PixelInspectorPass::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   64:     return SharedPtr(new PixelInspectorPass(pRenderContext->device()));\n   65  }\n   66  \n   67: PixelInspectorPass::PixelInspectorPass(Device::SharedPtr pDevice): RenderPass(pDevice) {\n   68      for (auto it : kInputChannels) {\n   69          mAvailableInputs[it.name] = false;\n   ..\n   73      assert(mpProgram);\n   74  \n   75:     mpVars = ComputeVars::create(pDevice, mpProgram->getReflector());\n   76      mpState = ComputeState::create(pDevice);\n   77      mpState->setProgram(mpProgram);\n   ..\n   81  }\n   82  \n   83: std::string PixelInspectorPass::getDesc() {\n   84      return\n   85          \"Inspect geometric and material properties at a given pixel.\\n\"\n   ..\n   88  }\n   89  \n   90: RenderPassReflection PixelInspectorPass::reflect(const CompileData& compileData) {\n   91      // Define the required resources here\n   92:     RenderPassReflection reflector;\n   93      for (auto it : kInputChannels) {\n   94:         auto& f = reflector.addInput(it.name, it.desc).format(it.format);\n   95          if (it.optional) f.flags(RenderPassReflection::Field::Flags::Optional);\n   96      }\n   97:     return reflector;\n   98  }\n   99  \n  100: void PixelInspectorPass::execute(RenderContext* pRenderContext, const RenderData& renderData) {\n  101      for (auto it : kInputChannels) {\n  102          mAvailableInputs[it.name] = renderData[it.name] != nullptr;\n  ...\n  111      if (pCamera->getApertureRadius() > 0.f) {\n  112          // TODO: Take view dir as optional input. For now issue warning if DOF is enabled.\n  113:         logWarning(\"Depth-of-field is enabled, but PixelInspectorPass assumes a pinhole camera. Expect the view vector to be inaccurate.\");\n  114      }\n  115  \n  ...\n  143      mpVars[kOutputChannel] = mpPixelDataBuffer;\n  144  \n  145:     // Run the inspector program.\n  146      pRenderContext->dispatch(mpState.get(), mpVars.get(), { 1u, 1u, 1u });\n  147  }\n  148  \n  149: void PixelInspectorPass::renderUI(Gui::Widgets& widget) {\n  150      PixelData pixelData = *reinterpret_cast<const PixelData*>(mpPixelDataBuffer->map(Buffer::MapType::Read));\n  151      mpPixelDataBuffer->unmap();\n  ...\n  159          \"Otherwise, left-mouse click on a pixel to select it.\", true);\n  160  \n  161:     const auto displayValues = [&pixelData, &widget, this](const std::vector<std::string>& inputNames, const std::vector<std::string>& values, const std::function<void(PixelData&)>& displayValues) {\n  162          bool areAllInputsAvailable = true;\n  163          for (const std::string& inputName : inputNames) areAllInputsAvailable = areAllInputsAvailable && mAvailableInputs[inputName];\n  ...\n  225          });\n  226  \n  227:         geometryGroup.var(\"View vector\", pixelData.view, -1.f, 1.f, 0.001f, false, \"%.6f\");\n  228  \n  229          displayValues({ \"normW\" }, { \"NdotV\" }, [&geometryGroup](PixelData& pixelData) {\n  ...\n  292  }\n  293  \n  294: void PixelInspectorPass::setScene(RenderContext* pRenderContext, const Scene::SharedPtr& pScene) {\n  295      mpScene = pScene;\n  296  }\n  297  \n  298: bool PixelInspectorPass::onMouseEvent(const MouseEvent& mouseEvent) {\n  299      if (mouseEvent.type == MouseEvent::Type::Move) {\n  300          mCursorPosition = mouseEvent.pos;\n\n/home/max/dev/Falcor/src/RenderPasses/PixelInspectorPass/PixelInspectorPass.h:\n   35  /** Pass extracting material information for the currently selected pixel.\n   36  */\n   37: class PixelInspectorPass : public RenderPass, public inherit_shared_from_this<RenderPass, PixelInspectorPass> {\n   38   public:\n   39:     using SharedPtr = std::shared_ptr<PixelInspectorPass>;\n   40  \n   41      /** Create a new object\n   ..\n   51  \n   52   private:\n   53:     PixelInspectorPass(Device::SharedPtr pDevice);\n   54  \n   55      // Internal state\n\n/home/max/dev/Falcor/src/RenderPasses/PixelInspectorPass/PixelInspectorPass.vcxproj:\n   14      <ProjectGuid>{80DDDE59-A412-4E64-880A-6B52697C967B}</ProjectGuid>\n   15      <Keyword>Win32Proj</Keyword>\n   16:     <RootNamespace>InspectorPass</RootNamespace>\n   17      <WindowsTargetPlatformVersion>10.0.18362.0</WindowsTargetPlatformVersion>\n   18:     <ProjectName>PixelInspectorPass</ProjectName>\n   19    </PropertyGroup>\n   20    <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.Default.props\" />\n   ..\n   26    </ImportGroup>\n   27    <ItemGroup>\n   28:     <ClCompile Include=\"PixelInspectorPass.cpp\" />\n   29    </ItemGroup>\n   30    <ItemGroup>\n   31:     <ClInclude Include=\"PixelInspectorPass.h\" />\n   32    </ItemGroup>\n   33    <ItemGroup>\n   ..\n   37    </ItemGroup>\n   38    <ItemGroup>\n   39:     <ShaderSource Include=\"PixelInspector.cs.slang\" />\n   40:     <ShaderSource Include=\"PixelInspectorData.slang\" />\n   41    </ItemGroup>\n   42    <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" Label=\"Configuration\">\n\n/home/max/dev/Falcor/src/RenderPasses/PixelInspectorPass/PixelInspectorPass.vcxproj.filters:\n    2  <Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    3    <ItemGroup>\n    4:     <ShaderSource Include=\"PixelInspector.cs.slang\" />\n    5:     <ShaderSource Include=\"PixelInspectorData.slang\" />\n    6    </ItemGroup>\n    7    <ItemGroup>\n    8:     <ClCompile Include=\"PixelInspectorPass.cpp\" />\n    9    </ItemGroup>\n   10    <ItemGroup>\n   11:     <ClInclude Include=\"PixelInspectorPass.h\" />\n   12    </ItemGroup>\n   13  </Project>\n\n/home/max/dev/Falcor/src/RenderPasses/SkyBox/SkyBox.cpp:\n   69      mpProgram = GraphicsProgram::createFromFile(pDevice, \"RenderPasses/SkyBox/SkyBox.slang\", \"vs\", \"ps\");\n   70      mpProgram->addDefines(mpCubeScene->getSceneDefines());\n   71:     mpVars = GraphicsVars::create(pDevice, mpProgram->getReflector());\n   72      mpFbo = Fbo::create(pDevice);\n   73  \n   ..\n  126  \n  127  RenderPassReflection SkyBox::reflect(const CompileData& compileData) {\n  128:     RenderPassReflection reflector;\n  129:     reflector.addOutput(kTarget, \"Color buffer\").format(ResourceFormat::RGBA32Float);\n  130:     auto& depthField = reflector.addInputOutput(kDepth, \"Depth-buffer. Should be pre-initialized or cleared before calling the pass\").bindFlags(Resource::BindFlags::DepthStencil);\n  131:     return reflector;\n  132  }\n  133  \n\n/home/max/dev/Falcor/src/RenderPasses/SSAO/SSAO.cpp:\n  127  \n  128  RenderPassReflection SSAO::reflect(const CompileData& compileData) {\n  129:     RenderPassReflection reflector;\n  130:     reflector.addInput(kColorIn, \"Color buffer\");\n  131:     reflector.addOutput(kColorOut, \"Color-buffer with AO applied to it\");\n  132:     reflector.addInput(kDepth, \"Depth-buffer\");\n  133:     reflector.addInput(kNormals, \"World space normals, [0, 1] range\").flags(RenderPassReflection::Field::Flags::Optional);\n  134:     reflector.addInternal(kAoMap, \"AO Map\");\n  135:     return reflector;\n  136  }\n  137  \n  ...\n  266  \n  267  void SSAO::setNoiseTexture(uint32_t width, uint32_t height) {\n  268:     std::vector<uint32_t> data;\n  269      data.resize(width * height);\n  270  \n\n/home/max/dev/Falcor/src/RenderPasses/SSAO/SSAO.ps.slang:\n  107      }\n  108  \n  109:     float factor = 1 - (occlusion / float(gData.kernelSize));\n  110:     return float4(factor.xxx, 1);\n  111  }\n  112  \n\n/home/max/dev/Falcor/src/RenderPasses/SVGFPass/SVGFPass.cpp:\n   63      const char kInputBufferPosNormalFwidth[] = \"PositionNormalFwidth\";\n   64      const char kInputBufferLinearZ[] = \"LinearZ\";\n   65:     const char kInputBufferMotionVector[] = \"MotionVec\";\n   66  \n   67      // Internal buffer names\n   ..\n  136  \n  137  RenderPassReflection SVGFPass::reflect(const CompileData& compileData) {\n  138:     RenderPassReflection reflector;\n  139  \n  140:     reflector.addInput(kInputBufferAlbedo, \"Albedo\");\n  141:     reflector.addInput(kInputBufferColor, \"Color\");\n  142:     reflector.addInput(kInputBufferEmission, \"Emission\");\n  143:     reflector.addInput(kInputBufferWorldPosition, \"World Position\");\n  144:     reflector.addInput(kInputBufferWorldNormal, \"World Normal\");\n  145:     reflector.addInput(kInputBufferPosNormalFwidth, \"PositionNormalFwidth\");\n  146:     reflector.addInput(kInputBufferLinearZ, \"LinearZ\");\n  147:     reflector.addInput(kInputBufferMotionVector, \"Motion vectors\");\n  148  \n  149:     reflector.addInternal(kInternalBufferPreviousLinearZAndNormal, \"Previous Linear Z and Packed Normal\")\n  150          .format(ResourceFormat::RGBA32Float)\n  151          .bindFlags(Resource::BindFlags::RenderTarget | Resource::BindFlags::ShaderResource)\n  152          ;\n  153:     reflector.addInternal(kInternalBufferPreviousLighting, \"Previous Filtered Lighting\")\n  154          .format(ResourceFormat::RGBA32Float)\n  155          .bindFlags(Resource::BindFlags::RenderTarget | Resource::BindFlags::ShaderResource)\n  156          ;\n  157:     reflector.addInternal(kInternalBufferPreviousMoments, \"Previous Moments\")\n  158          .format(ResourceFormat::RG32Float)\n  159          .bindFlags(Resource::BindFlags::RenderTarget | Resource::BindFlags::ShaderResource)\n  160          ;\n  161  \n  162:     reflector.addOutput(kOutputBufferFilteredImage, \"Filtered image\").format(ResourceFormat::RGBA16Float);\n  163  \n  164:     return reflector;\n  165  }\n  166  \n  ...\n  178      Texture::SharedPtr pPosNormalFwidthTexture = renderData[kInputBufferPosNormalFwidth]->asTexture();\n  179      Texture::SharedPtr pLinearZTexture = renderData[kInputBufferLinearZ]->asTexture();\n  180:     Texture::SharedPtr pMotionVectorTexture = renderData[kInputBufferMotionVector]->asTexture();\n  181  \n  182      Texture::SharedPtr pOutputTexture = renderData[kOutputBufferFilteredImage]->asTexture();\n  ...\n  203              renderData[kInternalBufferPreviousLinearZAndNormal]->asTexture();\n  204          computeReprojection(pRenderContext, pAlbedoTexture, pColorTexture, pEmissionTexture,\n  205:                             pMotionVectorTexture, pPosNormalFwidthTexture,\n  206                              pPrevLinearZAndNormalTexture);\n  207  \n  ...\n  300  void SVGFPass::computeReprojection(RenderContext* pRenderContext, Texture::SharedPtr pAlbedoTexture,\n  301                                     Texture::SharedPtr pColorTexture, Texture::SharedPtr pEmissionTexture,\n  302:                                    Texture::SharedPtr pMotionVectorTexture,\n  303                                     Texture::SharedPtr pPositionNormalFwidthTexture,\n  304                                     Texture::SharedPtr pPrevLinearZTexture)\n  ...\n  307  \n  308      // Setup textures for our reprojection shader pass\n  309:     perImageCB[\"gMotion\"]        = pMotionVectorTexture;\n  310      perImageCB[\"gColor\"]         = pColorTexture;\n  311      perImageCB[\"gEmission\"]      = pEmissionTexture;\n\n/home/max/dev/Falcor/src/RenderPasses/SVGFPass/SVGFPass.h:\n   58      void computeReprojection(RenderContext* pRenderContext, Texture::SharedPtr pAlbedoTexture,\n   59                               Texture::SharedPtr pColorTexture, Texture::SharedPtr pEmissionTexture,\n   60:                              Texture::SharedPtr pMotionVectorTexture,\n   61                               Texture::SharedPtr pPositionNormalFwidthTexture,\n   62                               Texture::SharedPtr pPrevLinearZAndNormalTexture);\n\n/home/max/dev/Falcor/src/RenderPasses/TemporalDelayPass/TemporalDelayPass.vcxproj:\n   66        <Optimization>Disabled</Optimization>\n   67        <PreprocessorDefinitions>WIN32;PROJECT_DIR=R\"($(ProjectDir))\";_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n   68:       <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n   69        <LanguageStandard>stdcpp17</LanguageStandard>\n   70        <ConformanceMode>true</ConformanceMode>\n   ..\n   84        <IntrinsicFunctions>true</IntrinsicFunctions>\n   85        <PreprocessorDefinitions>WIN32;PROJECT_DIR=R\"($(ProjectDir))\";NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n   86:       <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n   87        <LanguageStandard>stdcpp17</LanguageStandard>\n   88        <ConformanceMode>true</ConformanceMode>\n\n/home/max/dev/Falcor/src/RenderPasses/ToneMapper/ToneMapper.cpp:\n  167  \n  168  RenderPassReflection ToneMapper::reflect(const CompileData& compileData) {\n  169:     RenderPassReflection reflector;\n  170:     reflector.addInput(kSrc, \"Source texture\");\n  171:     auto& output = reflector.addOutput(kDst, \"Tone-mapped output texture\");\n  172      if (mOutputFormat != ResourceFormat::Unknown)\n  173      {\n  ...\n  175      }\n  176  \n  177:     return reflector;\n  178  }\n  179  \n\n/home/max/dev/Falcor/src/RenderPasses/Utils/Composite/Composite.cpp:\n   73  \n   74  RenderPassReflection Composite::reflect(const CompileData& compileData) {\n   75:     RenderPassReflection reflector;\n   76:     reflector.addInput(kInputA, \"Input A\").bindFlags(ResourceBindFlags::ShaderResource);\n   77:     reflector.addInput(kInputB, \"Input B\").bindFlags(ResourceBindFlags::ShaderResource);\n   78:     reflector.addOutput(kOutput, \"Output\").bindFlags(ResourceBindFlags::UnorderedAccess).format(ResourceFormat::RGBA32Float); // TODO: Allow user to specify output format\n   79:     return reflector;\n   80  }\n   81  \n\n/home/max/dev/Falcor/src/RenderPasses/Utils/GaussianBlur/GaussianBlur.cpp:\n   73  \n   74  RenderPassReflection GaussianBlur::reflect(const CompileData& compileData) {\n   75:     RenderPassReflection reflector;\n   76      mReady = false;\n   77      if (compileData.connectedResources.getFieldCount() > 0) {\n   ..\n   90          };\n   91  \n   92:         formatField(reflector.addInput(kSrc, \"input image to be blurred\"));\n   93:         formatField(reflector.addOutput(kDst, \"output blurred image\"));\n   94          mReady = true;\n   95      } else {\n   96:         reflector.addInput(kSrc, \"input image to be blurred\");\n   97:         reflector.addOutput(kDst, \"output blurred image\");\n   98      }\n   99:     return reflector;\n  100  }\n  101  \n  ...\n  181      uint32_t center = mKernelWidth / 2;\n  182      float sum = 0;\n  183:     std::vector<float> weights(center + 1);\n  184  \n  185      for (uint32_t i = 0; i <= center; i++) {\n\n/home/max/dev/Falcor/src/RenderPasses/WhittedRayTracer/WhittedRayTracer.cpp:\n  156  RenderPassReflection WhittedRayTracer::reflect(const CompileData& compileData)\n  157  {\n  158:     RenderPassReflection reflector;\n  159  \n  160:     addRenderPassInputs(reflector, mInputChannels);\n  161:     addRenderPassOutputs(reflector, kOutputChannels);\n  162  \n  163:     return reflector;\n  164  }\n  165  \n\n/home/max/dev/Falcor/src/Samples/CMakeLists.txt:\n    3  # Python\n    4  find_package(PythonLibs 3.7 REQUIRED)\n    5: include_directories(${PYTHON_INCLUDE_DIRS})\n    6  \n    7  # This function builds render pass library\n\n/home/max/dev/Falcor/src/Samples/CudaInterop/FalcorCUDA.props:\n    6    <ItemDefinitionGroup>\n    7      <ClCompile>\n    8:       <AdditionalIncludeDirectories>$(CUDA_PATH)\\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n    9      </ClCompile>\n   10      <Link>\n   11:       <AdditionalLibraryDirectories>$(CUDA_PATH)\\lib\\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>\n   12        <AdditionalDependencies>cuda.lib;%(AdditionalDependencies)</AdditionalDependencies>\n   13      </Link>\n\n/home/max/dev/Falcor/src/Samples/HelloDXR/HelloDXR.vcxproj:\n   78        <SubSystem>Windows</SubSystem>\n   79        <GenerateDebugInformation>true</GenerateDebugInformation>\n   80:       <AdditionalLibraryDirectories>$(SolutionDir)\\Framework\\Externals\\DXRT\\Lib\\;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>\n   81      </Link>\n   82    </ItemDefinitionGroup>\n   ..\n   98        <EnableCOMDATFolding>true</EnableCOMDATFolding>\n   99        <OptimizeReferences>true</OptimizeReferences>\n  100:       <AdditionalLibraryDirectories>$(SolutionDir)\\Framework\\Externals\\DXRT\\Lib\\;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>\n  101      </Link>\n  102    </ItemDefinitionGroup>\n\n/home/max/dev/Falcor/src/Samples/make_new_project.py:\n    8  \n    9  def create_project(name):\n   10:     # Source and destination directories.\n   11      src_dir = SAMPLES_DIR / TEMPLATE_NAME\n   12      dst_dir = SAMPLES_DIR / name\n\n/home/max/dev/Falcor/src/Samples/ModelViewer/ModelViewer.cpp:\n   67  \n   68      mpProgram->addDefines(mpScene->getSceneDefines());\n   69:     mpProgramVars = GraphicsVars::create(mpProgram->getReflector());\n   70      mpScene->bindSamplerToMaterials(mUseTriLinearFiltering ? mpLinearSampler : mpPointSampler);\n   71      setCamController();\n\n/home/max/dev/Falcor/src/Tools/CMakeLists.txt:\n    3  # Python\n    4  find_package(PythonLibs 3.7 REQUIRED)\n    5: include_directories(${PYTHON_INCLUDE_DIRS})\n    6  \n    7  # This function builds render pass library\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/FalcorTest.cpp:\n   28  #include <cstdio>\n   29  #include <string>\n   30: #include <vector>\n   31  \n   32  #include \"Falcor/Core/Window.h\"\n   ..\n   37  using namespace Falcor;\n   38  \n   39: static std::vector<std::string> librariesWithTests = {\n   40  \n   41  };\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Core/BufferAccessTests.cpp:\n   39  */\n   40  Buffer::SharedPtr createTestBuffer(Buffer::CpuAccess cpuAccess, bool initialize = true) {\n   41:     std::vector<uint32_t> initData(elems);\n   42      for (uint32_t i = 0; i < elems; i++) initData[i] = i;\n   43      return Buffer::create(elems * sizeof(uint32_t), Resource::BindFlags::ShaderResource, cpuAccess, initialize ? initData.data() : nullptr);\n   ..\n  101  \n  102          // Set data into buffer using its setBlob() function.\n  103:         std::vector<uint32_t> initData(elems);\n  104          for (uint32_t i = 0; i < elems; i++) initData[i] = i;\n  105          pBuf->setBlob(initData.data(), 0, elems * sizeof(uint32_t));\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Core/BufferTests.cpp:\n   48              // Create a data blob for the test.\n   49              // We fill it some numbers that don't overlap with the test buffers values.\n   50:             std::vector<uint32_t> blob;\n   51              if (count > 0) {\n   52                  blob.resize(count);\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Core/RootBufferParamBlockTests.cpp:\n   64              auto pReflectionProgram = ComputePass::create(reflDesc, defines);\n   65              EXPECT(pReflectionProgram != nullptr);\n   66:             auto pBlockReflection = pReflectionProgram->getProgram()->getReflector()->getParameterBlock(\"gParamBlock\");\n   67              EXPECT(pBlockReflection != nullptr);\n   68              auto pParamBlock = ParameterBlock::create(pBlockReflection);\n   ..\n   74              block[\"c0\"] = c0;\n   75  \n   76:             std::vector<uint32_t> bufA[2];\n   77              for (uint32_t j = 0; j < 2; j++)\n   78              {\n   ..\n   81                  block[\"bufA\"][j] = Buffer::create(kNumElems * sizeof(uint32_t), Resource::BindFlags::ShaderResource, Buffer::CpuAccess::None, bufA[j].data());\n   82              }\n   83:             std::vector<float> bufB[3];\n   84              for (uint32_t j = 0; j < 3; j++)\n   85              {\n   ..\n   88                  block[\"bufB\"][j] = Buffer::createTyped<float>(kNumElems, Resource::BindFlags::UnorderedAccess, Buffer::CpuAccess::None, bufB[j].data());\n   89              }\n   90:             std::vector<uint32_t> bufC[4];\n   91              for (uint32_t j = 0; j < 4; j++) {\n   92                  bufC[j].resize(kNumElems);\n   ..\n   96  \n   97              // Bind root buffer to the parameter block.\n   98:             std::vector<uint32_t> testBuffer(kNumElems);\n   99              {\n  100                  for (uint32_t i = 0; i < kNumElems; i++) testBuffer[i] = r();\n  ...\n  116  \n  117              // Bind some buffers at the global scope, both root and non-root resources.\n  118:             std::vector<uint32_t> globalBufA;\n  119              {\n  120                  globalBufA.resize(kNumElems);\n  ...\n  122                  var[\"globalBufA\"] = Buffer::createTyped<uint32_t>(kNumElems, Resource::BindFlags::ShaderResource, Buffer::CpuAccess::None, globalBufA.data());\n  123              }\n  124:             std::vector<uint32_t> globalTestBuffer(kNumElems);\n  125              {\n  126                  for (uint32_t i = 0; i < kNumElems; i++) globalTestBuffer[i] = r();\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Core/RootBufferStructTests.cpp:\n   51  \n   52              // Bind some regular buffers.\n   53:             std::vector<uint32_t> buf(kNumElems);\n   54              {\n   55                  for (uint32_t i = 0; i < kNumElems; i++) buf[i] = r();\n   56                  data[\"buf\"] = Buffer::createTyped<uint32_t>(kNumElems, ResourceBindFlags::ShaderResource, Buffer::CpuAccess::None, buf.data());\n   57              }\n   58:             std::vector<uint32_t> rwBuf(kNumElems);\n   59              {\n   60                  for (uint32_t i = 0; i < kNumElems; i++) rwBuf[i] = r();\n   ..\n   63  \n   64              // Test binding structured buffer to root descriptor inside struct in CB.\n   65:             std::vector<uint32_t> rootBuf(kNumElems);\n   66              {\n   67                  for (uint32_t i = 0; i < kNumElems; i++) rootBuf[i] = r();\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Core/RootBufferTests.cpp:\n   62  \n   63              // Bind some regular buffers.\n   64:             std::vector<uint32_t> rawBuffer(kNumElems);\n   65              {\n   66                  for (uint32_t i = 0; i < kNumElems; i++) rawBuffer[i] = r();\n   ..\n   68              }\n   69  \n   70:             std::vector<S> structBuffer(kNumElems);\n   71              {\n   72                  for (uint32_t i = 0; i < kNumElems; i++) structBuffer[i] = { r() + 0.5f, r() };\n   ..\n   74              }\n   75  \n   76:             std::vector<uint32_t> typedBufferUint(kNumElems);\n   77              {\n   78                  for (uint32_t i = 0; i < kNumElems; i++) typedBufferUint[i] = r();\n   ..\n   80              }\n   81  \n   82:             std::vector<float4> typedBufferFloat4(kNumElems);\n   83              {\n   84                  for (uint32_t i = 0; i < kNumElems; i++) typedBufferFloat4[i] = { r() * 0.25f, r() * 0.5f, r() * 0.75f, r() };\n   ..\n   87  \n   88              // Test binding buffer to root descriptor.\n   89:             std::vector<uint32_t> testBuffer(kNumElems);\n   90              {\n   91                  for (uint32_t i = 0; i < kNumElems; i++) testBuffer[i] = r();\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Core/UserConstantBufferTests.cpp:\n   57  \n   58          // Create a parameter block instead to replace the automatically allocated block.\n   59:         //auto vars = ctx[\"params\"]; // TODO: Can we get a ParameterBlockReflector from ShaderVar?\n   60:         auto reflector = ctx.getProgram()->getReflector()->getParameterBlock(\"params\");\n   61:         auto pCB = ParameterBlock::create(reflector);\n   62          ctx[\"params\"] = pCB;\n   63  \n   ..\n  102              ctx.getRenderContext()->flush(true);\n  103  \n  104:             std::vector<uint32_t> initData(3);\n  105              initData[0] = 4;\n  106              initData[1] = 17;\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/DebugPasses/InvalidPixelDetectionTests.cpp:\n   52          pGraph->execute(pRenderContext);\n   53          Resource::SharedPtr pOutput = pGraph->getOutput(\"InvalidPixelDetectionPass.dst\");\n   54:         std::vector<uint8_t> color = pRenderContext->readTextureSubresource(pOutput->asTexture().get(), 0);\n   55          uint32_t* output = (uint32_t*)color.data();\n   56  \n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Sampling/PseudorandomTests.cpp:\n   76          const uint32_t kDimensions = 64;\n   77  \n   78:         Buffer::SharedPtr createSeed(size_t elements, std::vector<uint32_t>& seed)\n   79          {\n   80              // Initialize buffer of random seed data.\n   ..\n   95      {\n   96          // Create random seed (128 bits per instance).\n   97:         std::vector<uint32_t> seed;\n   98          auto pSeedBuf = createSeed(kInstances * 4, seed);\n   99  \n  ...\n  129      {\n  130          // Create random seed (64 bits per instance).\n  131:         std::vector<uint32_t> seed;\n  132          auto pSeedBuf = createSeed(kInstances * 2, seed);\n  133  \n  ...\n  160      {\n  161          // Create random seed (32 bits per instance).\n  162:         std::vector<uint32_t> seed;\n  163          auto pSeedBuf = createSeed(kInstances, seed);\n  164  \n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Scene/EnvProbeTests.cpp:\n   33      namespace\n   34      {\n   35:         // This file is located in the Media/ directory fetched by packman.\n   36          const char kLightProbeFile[] = \"LightProbes/20050806-03_hd.hdr\";\n   37      }\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/ShadingUtils/RaytracingTests.cpp:\n   69  \n   70          // Create random test data.\n   71:         std::vector<float3> testPositions(n);\n   72:         std::vector<float3> testNormals(n);\n   73          for (uint32_t i = 0; i < n; i++)\n   74          {\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/ShadingUtils/ShadingUtilsTests.cpp:\n  185          ctx.runProgram(n);\n  186  \n  187:         // The shader generates a bunch of random vectors, converts them to\n  188          // spherical coordinates and back, and computes the dot product with\n  189:         // the original vector.  Here, we'll check that the dot product is\n  190          // pretty close to one.\n  191          const float* r = ctx.mapBuffer<const float>(\"result\");\n  ...\n  205          auto r = [&]() -> float { return dist(rng); };\n  206  \n  207:         std::vector<float3> testSphereCenters(12);\n  208:         std::vector<float> testSphereRadii(12);\n  209:         std::vector<float3> refIsects(12);\n  210:         std::vector<float3> testRayOrigins(12);\n  211:         std::vector<float3> testRayDirs(12);\n  212  \n  213          for (int32_t i = 0; i < 12; i++)\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Slang/Int64Tests.cpp:\n   32      namespace\n   33      {\n   34:         std::vector<std::string> kShaderModels =\n   35          {\n   36              #ifdef FALCOR_VK\n   ..\n   57              ctx.allocateStructuredBuffer(\"result\", kNumElems * 2);\n   58  \n   59:             std::vector<uint64_t> elems(kNumElems);\n   60              for (auto& v : elems) v = ((uint64_t)r() << 32) | r();\n   61              auto var = ctx.vars().getRootVar();\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Slang/SlangTests.cpp:\n   37  #include \"Falcor/Utils/Debug/debug.h\"\n   38  \n   39: // #include <DirectXPackedVector.h>\n   40  \n   41: // using half = DirectX::PackedVector::HALF;\n   42  \n   43  namespace Falcor\n   ..\n   72          }\n   73  \n   74:         //half f32tof16(float fval) { return DirectX::PackedVector::XMConvertFloatToHalf(fval); }\n   75:         //float f16tof32(half hval) { return DirectX::PackedVector::XMConvertHalfToFloat(hval); }\n   76  \n   77          uint32_t asuint(float a) { return *reinterpret_cast<uint32_t*>(&a); }\n   ..\n  171      {\n  172          const uint32_t maxTests = 100, usedTests = 35;\n  173:         std::vector<uint32_t> initData(maxTests, -1);\n  174  \n  175          auto test = [&](const std::string& shaderModel)\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Slang/SlangTests.cs.slang:\n  174  #endif\n  175  \n  176:     // Vector/matrix types (i=9)\n  177      {\n  178          float4 a = float4(1, 2, 3, 4), b = {};\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Slang/WaveOps.cpp:\n   37          std::mt19937 rng;\n   38  \n   39:         std::vector<uint32_t> generateMatchData(size_t numElems, size_t numUnique = 20)\n   40          {\n   41:             std::vector<uint32_t> elems(numUnique);\n   42              for (auto& e : elems) e = rng();\n   43  \n   44              std::uniform_int_distribution<size_t> select(0, numUnique-1);\n   45:             std::vector<uint32_t> data(numElems);\n   46              for (auto& d : data) d = elems[select(rng)];\n   47  \n   ..\n   49          }\n   50  \n   51:         std::vector<uint4> computeMatchResult(const std::vector<uint32_t>& data, uint32_t laneCount)\n   52          {\n   53              assert(laneCount >= 4 && laneCount <= 128);\n   54:             std::vector<uint4> masks(data.size(), uint4(0));\n   55  \n   56              for (size_t i = 0; i < data.size(); i++)\n   ..\n  114          var[\"laneCount\"] = pLaneCount;\n  115  \n  116:         std::vector<uint32_t> matchData = generateMatchData(kNumElems);\n  117          assert(matchData.size() == kNumElems);\n  118          var[\"testData\"] = Buffer::createTyped<uint32_t>(kNumElems, ResourceBindFlags::ShaderResource, Buffer::CpuAccess::None, matchData.data());\n  ...\n  128  \n  129          // Verify results of wave match.\n  130:         std::vector<uint4> expectedResult = computeMatchResult(matchData, laneCount);\n  131          assert(expectedResult.size() == matchData.size());\n  132  \n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Utils/BitonicSortTests.cpp:\n   35      {\n   36          // Sort the 'data' array in ascending order within chunks of 'chunkSize' elements.\n   37:         void sort(std::vector<uint32_t>& data, const uint32_t chunkSize)\n   38          {\n   39              if (chunkSize <= 1) return;\n   ..\n   48          {\n   49              // Create a buffer of random data to use as test data.\n   50:             std::vector<uint32_t> testData(n);\n   51              std::mt19937 r;\n   52              for (auto& it : testData) it = r();\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Utils/BitTricksTests.cpp:\n   57  \n   58          // Create a buffer of random bits to use as test data.\n   59:         std::vector<uint32_t> testData(n);\n   60          std::mt19937 r;\n   61          for (auto& it : testData) it = r();\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Utils/HalfUtilsTests.cpp:\n   30  #ifdef FALCOR_D3D12\n   31  \n   32: // TODO: Replace DirectXPackedVector.h by a platform-independent alternative that\n   33  // allows configuring the rounding modes to match what we detect on the GPU.\n   34: #include <DirectXPackedVector.h>\n   35: using half = DirectX::PackedVector::HALF;\n   36  \n   37  /** Notes on IEEE 754 fp16 floating-point representation:\n   ..\n   61          half f32tof16(float fval)\n   62          {\n   63:             return DirectX::PackedVector::XMConvertFloatToHalf(fval);\n   64          }\n   65  \n   ..\n   68          float f16tof32(half hval)\n   69          {\n   70:             return DirectX::PackedVector::XMConvertHalfToFloat(hval);\n   71          }\n   72  \n   ..\n  117          /** Generates test data to verify round-to-nearest-even in fp32->fp16 conversion.\n  118          */\n  119:         void generateFP16RNETestData(std::vector<float>& input, std::vector<float>& expected)\n  120          {\n  121              {\n  ...\n  161          }\n  162  \n  163:         std::vector<uint32_t> generateAllFiniteFP16()\n  164          {\n  165:             std::vector<uint32_t> data;\n  166  \n  167              // Loop over all finite numbers in fp16.\n  ...\n  175          }\n  176  \n  177:         std::vector<float> generateFP16TestData(UnitTestContext& ctx)\n  178          {\n  179:             std::vector<float> data;\n  180  \n  181              // Loop over all finite numbers in fp16.\n  ...\n  208      GPU_TEST(FP32ToFP16Conversion, \"Disabled due to lacking fp16 library (#391)\")\n  209      {\n  210:         std::vector<float> testData = generateFP16TestData(ctx);\n  211  \n  212          ctx.createProgram(\"Tests/Utils/HalfUtilsTests.cs.slang\", \"testFP32ToFP16\");\n  ...\n  228      GPU_TEST(FP16ToFP32Conversion)\n  229      {\n  230:         std::vector<uint32_t> testData = generateAllFiniteFP16();\n  231  \n  232          ctx.createProgram(\"Tests/Utils/HalfUtilsTests.cs.slang\", \"testFP16ToFP32\");\n  ...\n  257  \n  258          // Test f32->f16 rounding functions on the CPU.\n  259:         std::vector<float> testData = generateFP16TestData(ctx);\n  260          for (size_t i = 0; i < testData.size(); i++)\n  261          {\n  ...\n  282      GPU_TEST(FP32ToFP16ConservativeRoundingGPU)\n  283      {\n  284:         std::vector<float> testData = generateFP16TestData(ctx);\n  285  \n  286          ctx.createProgram(\"Tests/Utils/HalfUtilsTests.cs.slang\", \"testFP32ToFP16ConservativeRounding\");\n  ...\n  317      GPU_TEST(FP16RoundingModeGPU, \"Disabled due to lacking fp16 library (#391)\")\n  318      {\n  319:         std::vector<float> input, expected;\n  320          generateFP16RNETestData(input, expected);\n  321  \n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Utils/HashUtilsTests.cpp:\n   27   **************************************************************************/\n   28  #include \"Testing/UnitTest.h\"\n   29: #include <vector>\n   30  \n   31  // The perfect hash tests are disabled by default as they take a really long time to run.\n   ..\n   79  #endif\n   80      {\n   81:         std::vector<uint32_t> result(1 << 27, 0);\n   82          for (uint64_t i = 0; i < (1ull << 32); i++)\n   83          {\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Utils/MathHelpersTests.cpp:\n   31  #include <limits>\n   32  #include <random>\n   33: #include <vector>\n   34  \n   35  namespace Falcor\n   ..\n  115          {\n  116              // Generate test data.\n  117:             std::vector<BBoxTestCase> testCases;\n  118              std::random_device rd;\n  119              std::mt19937 gen(rd());\n  ...\n  153                    for (int j = 0; j < 8; ++j)\n  154                      {\n  155:                       // Make sure that the vector to AABB corner is inside the cone.\n  156                        float3 corner = float3((j & 1) ? b.aabbMin.x : b.aabbMax.x,\n  157                                               (j & 2) ? b.aabbMin.y : b.aabbMax.y,\n  ...\n  162                        minCosTheta = std::min(minCosTheta, ct);\n  163                      }\n  164:                   // Make sure that the maximum angle between a vector to an AABB corner and the\n  165                    // cone axis isn't much bigger than the reported cone axis.\n  166                    EXPECT_LT(minCosTheta, (cosTheta[i] > 0 ? (1.01f * cosTheta[i]) : (0.99f * cosTheta[i])));\n  ...\n  207          TestCase testCases[] =\n  208          {\n  209:            // sin(theta) between a vector to the center of the sphere and a\n  210:            // vector that is tangent to the sphere is the sphere radius\n  211             // divided by the distance from the starting point to the center\n  212             // of the sphere.\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Utils/PrefixSumTests.cpp:\n   36      namespace\n   37      {\n   38:         uint32_t prefixSum(std::vector<uint32_t>& elems)\n   39          {\n   40              // Perform exclusive scan. Return sum of all elements.\n   ..\n   55              assert(numElems > 0);\n   56              const uint32_t maxVal = std::numeric_limits<uint32_t>::max() / numElems;\n   57:             std::vector<uint32_t> testData(numElems);\n   58              std::mt19937 r;\n   59              for (auto& it : testData) it = r() % maxVal;\n   ..\n   94      {\n   95          // Quick test of our reference function.\n   96:         std::vector<uint32_t> x({ 5, 17, 2, 9, 23 });\n   97          uint32_t sum = prefixSum(x);\n   98          assert(x[0] == 0 && x[1] == 5 && x[2] == 22 && x[3] == 24 && x[4] == 33);\n\n/home/max/dev/Falcor/src/Tools/ImageCompare/args.h:\n   41  #include <string>\n   42  #include <tuple>\n   43: #include <vector>\n   44  #include <unordered_map>\n   45  #include <unordered_set>\n   ..\n   90      }\n   91  \n   92:     /** (INTERNAL) Wrap a vector of words into a vector of lines\n   93       *\n   94       * Empty words are skipped. Word \"\\n\" forces wrapping.\n   ..\n   99       * \\param firstlinewidth the width of the first line, defaults to the width of the body\n  100       * \\param firstlineindent the indent of the first line, defaults to 0\n  101:      * \\return the vector of lines\n  102       */\n  103      template <typename It>\n  104:     inline std::vector<std::string> Wrap(It begin,\n  105                                           It end,\n  106                                           const std::string::size_type width,\n  ...\n  108                                           std::string::size_type firstlineindent = 0)\n  109      {\n  110:         std::vector<std::string> output;\n  111          std::string line(firstlineindent, ' ');\n  112          bool empty = true;\n  ...\n  191      }\n  192  \n  193:     /** (INTERNAL) Wrap a string into a vector of lines\n  194       *\n  195       * This is quick and hacky, but works well enough.  You can specify a\n  ...\n  198       * \\param width The width of the body\n  199       * \\param firstlinewid the width of the first line, defaults to the width of the body\n  200:      * \\return the vector of lines\n  201       */\n  202:     inline std::vector<std::string> Wrap(const std::string &in, const std::string::size_type width, std::string::size_type firstlinewidth = 0)\n  203      {\n  204          // Preserve existing line breaks\n  ...\n  480              }\n  481  \n  482:             /** (INTERNAL) Get all flag strings as a vector, with the prefixes embedded\n  483               */\n  484:             std::vector<EitherFlag> GetFlagStrings() const\n  485              {\n  486:                 std::vector<EitherFlag> flagStrings;\n  487                  flagStrings.reserve(shortFlags.size() + longFlags.size());\n  488                  for (const char flag: shortFlags)\n  ...\n  823              }\n  824  \n  825:             virtual std::vector<std::tuple<std::string, std::string, unsigned>> GetDescription(const HelpParams &, const unsigned indentLevel) const\n  826              {\n  827                  std::tuple<std::string, std::string, unsigned> description;\n  ...\n  831              }\n  832  \n  833:             virtual std::vector<Command*> GetCommands()\n  834              {\n  835                  return {};\n  ...\n  851              }\n  852  \n  853:             virtual std::vector<FlagBase*> GetAllFlags()\n  854              {\n  855                  return {};\n  ...\n  871              }\n  872  \n  873:             virtual std::vector<std::string> GetProgramLine(const HelpParams &) const\n  874              {\n  875                  return {};\n  ...\n  928              std::string defaultString;\n  929              bool defaultStringManual = false;\n  930:             std::vector<std::string> choicesStrings;\n  931              bool choicesStringManual = false;\n  932  \n  933              virtual std::string GetDefaultString(const HelpParams&) const { return {}; }\n  934  \n  935:             virtual std::vector<std::string> GetChoicesStrings(const HelpParams&) const { return {}; }\n  936  \n  937              virtual std::string GetNameString(const HelpParams&) const { return Name(); }\n  ...\n  972  \n  973              /** Sets choices strings that will be added to argument description.\n  974:              *  Use empty vector to disable it for this argument.\n  975               */\n  976:             void HelpChoices(const std::vector<std::string> &array)\n  977              {\n  978                  choicesStringManual = true;\n  ...\n  982              /** Gets choices strings that will be added to argument description.\n  983               */\n  984:             std::vector<std::string> HelpChoices(const HelpParams &params) const\n  985              {\n  986                  return choicesStringManual ? choicesStrings : GetChoicesStrings(params);\n  987              }\n  988  \n  989:             virtual std::vector<std::tuple<std::string, std::string, unsigned>> GetDescription(const HelpParams &params, const unsigned indentLevel) const override\n  990              {\n  991                  std::tuple<std::string, std::string, unsigned> description;\n  ...\n 1031  \n 1032          template <typename T>\n 1033:         std::vector<std::string> MapKeysToStrings(const T &map)\n 1034          {\n 1035:             std::vector<std::string> res;\n 1036              using K = typename std::decay<decltype(std::begin(map)->first)>::type;\n 1037              if (IsConvertableToString<K>::value)\n ....\n 1110              }\n 1111  \n 1112:             virtual std::vector<FlagBase*> GetAllFlags() override\n 1113              {\n 1114                  return { this };\n ....\n 1135              }\n 1136  \n 1137:             virtual std::vector<std::string> GetProgramLine(const HelpParams &params) const override\n 1138              {\n 1139                  if (!params.proglineShowFlags)\n ....\n 1187              /** Parse values of this option.\n 1188               *\n 1189:              * \\param value Vector of values. It's size must be in NumberOfArguments() interval.\n 1190               */\n 1191:             virtual void ParseValue(const std::vector<std::string> &value) = 0;\n 1192      };\n 1193  \n ....\n 1210      {\n 1211          public:\n 1212:             std::vector<std::string> reply;\n 1213              size_t cword = 0;\n 1214              std::string syntax;\n ....\n 1227              }\n 1228  \n 1229:             virtual void ParseValue(const std::vector<std::string> &value_) override\n 1230              {\n 1231                  syntax = value_.at(0);\n ....\n 1288              }\n 1289  \n 1290:             virtual std::vector<std::string> GetProgramLine(const HelpParams &params) const override\n 1291              {\n 1292                  return { IsRequired() ? params.proglineRequiredOpen + Name() + params.proglineRequiredClose\n ....\n 1315      {\n 1316          private:\n 1317:             std::vector<Base*> children;\n 1318              std::function<bool(const Group &)> validator;\n 1319  \n ....\n 1388              /** Get all this group's children\n 1389               */\n 1390:             const std::vector<Base *> &Children() const\n 1391              {\n 1392                  return children;\n ....\n 1410              }\n 1411  \n 1412:             virtual std::vector<FlagBase*> GetAllFlags() override\n 1413              {\n 1414:                 std::vector<FlagBase*> res;\n 1415                  for (Base *child: Children())\n 1416                  {\n ....\n 1474              /** Count the number of matched children this group has\n 1475               */\n 1476:             std::vector<Base *>::size_type MatchedChildren() const\n 1477              {\n 1478                  // Cast to avoid warnings from -Wsign-conversion\n 1479:                 return static_cast<std::vector<Base *>::size_type>(\n 1480                          std::count_if(std::begin(Children()), std::end(Children()), [](const Base *child){return child->Matched();}));\n 1481              }\n ....\n 1497              /** Get all the child descriptions for help generation\n 1498               */\n 1499:             virtual std::vector<std::tuple<std::string, std::string, unsigned>> GetDescription(const HelpParams &params, const unsigned int indent) const override\n 1500              {\n 1501:                 std::vector<std::tuple<std::string, std::string, unsigned int>> descriptions;\n 1502  \n 1503                  // Push that group description on the back if not empty\n ....\n 1527              /** Get the names of positional parameters\n 1528               */\n 1529:             virtual std::vector<std::string> GetProgramLine(const HelpParams &params) const override\n 1530              {\n 1531:                 std::vector <std::string> names;\n 1532                  for (Base *child: Children())\n 1533                  {\n ....\n 1546              }\n 1547  \n 1548:             virtual std::vector<Command*> GetCommands() override\n 1549              {\n 1550:                 std::vector<Command*> res;\n 1551                  for (const auto &child : Children())\n 1552                  {\n ....\n 1629      {\n 1630          private:\n 1631:             std::vector<std::string> args;\n 1632:             std::vector<std::string> kicked;\n 1633              ArgumentParser *parser = nullptr;\n 1634              const HelpParams &helpParams;\n ....\n 1637  \n 1638          public:\n 1639:             Subparser(std::vector<std::string> args_, ArgumentParser &parser_, const Command &command_, const HelpParams &helpParams_)\n 1640                  : Group({}, Validators::AllChildGroups), args(std::move(args_)), parser(&parser_), helpParams(helpParams_), command(command_)\n 1641              {\n ....\n 1667              void Parse();\n 1668  \n 1669:             /** Returns a vector of kicked out arguments.\n 1670               *\n 1671               * \\sa Base::KickOut\n 1672               */\n 1673:             const std::vector<std::string> &KickedOut() const noexcept\n 1674              {\n 1675                  return kicked;\n ....\n 1696              Command *selectedCommand = nullptr;\n 1697  \n 1698:             mutable std::vector<std::tuple<std::string, std::string, unsigned>> subparserDescription;\n 1699:             mutable std::vector<std::string> subparserProgramLine;\n 1700              mutable bool subparserHasFlag = false;\n 1701              mutable bool subparserHasPositional = false;\n ....\n 1711              {\n 1712                  public:\n 1713:                     RaiiSubparser(ArgumentParser &parser_, std::vector<std::string> args_);\n 1714                      RaiiSubparser(const Command &command_, const HelpParams &params_);\n 1715  \n ....\n 1885              }\n 1886  \n 1887:             virtual std::vector<FlagBase*> GetAllFlags() override\n 1888              {\n 1889:                 std::vector<FlagBase*> res;\n 1890  \n 1891                  if (!Matched())\n ....\n 1964              }\n 1965  \n 1966:             std::vector<std::string> GetCommandProgramLine(const HelpParams &params) const\n 1967              {\n 1968                  UpdateSubparserHelp(params);\n ....\n 2019              }\n 2020  \n 2021:             virtual std::vector<std::string> GetProgramLine(const HelpParams &params) const override\n 2022              {\n 2023                  if (!Matched())\n ....\n 2029              }\n 2030  \n 2031:             virtual std::vector<Command*> GetCommands() override\n 2032              {\n 2033                  if (selectedCommand != nullptr)\n ....\n 2044              }\n 2045  \n 2046:             virtual std::vector<std::tuple<std::string, std::string, unsigned>> GetDescription(const HelpParams &params, const unsigned int indent) const override\n 2047              {\n 2048:                 std::vector<std::tuple<std::string, std::string, unsigned>> descriptions;\n 2049                  unsigned addindent = 0;\n 2050  \n ....\n 2289               * \\param joinedArg Joined value (e.g. bar in --foo=bar)\n 2290               * \\param canDiscardJoined If true joined value can be parsed as flag not as a value (as in -abcd)\n 2291:              * \\param[out] values The vector to store parsed arg's values\n 2292               */\n 2293              template <typename It>\n ....\n 2295                                          const bool allowSeparate, const bool allowJoined,\n 2296                                          const bool hasJoined, const std::string &joinedArg,\n 2297:                                         const bool canDiscardJoined, std::vector<std::string> &values)\n 2298              {\n 2299                  values.clear();\n ....\n 2381                  if (auto flag = Match(arg))\n 2382                  {\n 2383:                     std::vector<std::string> values;\n 2384                      const std::string errorMessage = ParseArgsValues(*flag, arg, it, end, allowSeparateLongValue, allowJoinedLongValue,\n 2385                                                                       separator != argchunk.npos, joined, false, values);\n ....\n 2432                      {\n 2433                          const std::string value(argit + 1, std::end(argchunk));\n 2434:                         std::vector<std::string> values;\n 2435                          const std::string errorMessage = ParseArgsValues(*flag, std::string(1, arg), it, end,\n 2436                                                                           allowSeparateShortValue, allowJoinedShortValue,\n ....\n 2507                  const auto &chunk = *it;\n 2508                  auto pos = GetNextPositional();\n 2509:                 std::vector<Command *> commands = GetCommands();\n 2510                  const auto optionType = ParseOption(chunk, true);\n 2511  \n ....\n 2611              {\n 2612                  bool terminated = false;\n 2613:                 std::vector<Command *> commands = GetCommands();\n 2614  \n 2615                  // Check all arg chunks\n ....\n 2658                          {\n 2659                              ++it;\n 2660:                             RaiiSubparser coro(*this, std::vector<std::string>(it, end));\n 2661                              coroutine(coro.Parser());\n 2662  #ifdef ARGS_NOEXCEPT\n ....\n 2722                          }\n 2723  \n 2724:                         std::vector<std::string> curArgs(++it, end);\n 2725                          curArgs.resize(completion->cword);\n 2726  \n ....\n 2911                  const bool hasarguments = command.HasPositional();\n 2912  \n 2913:                 std::vector<std::string> prognameline;\n 2914                  prognameline.push_back(helpParams.usageString);\n 2915                  prognameline.push_back(Prog());\n ....\n 3055              /** Convenience function to parse the CLI from argc and argv\n 3056               *\n 3057:              * Just assigns the program name and vectorizes arguments for passing into ParseArgs()\n 3058               *\n 3059               * \\return whether or not all arguments were parsed.  This works for detecting kick-out, but is generally useless as it can't do anything with it.\n ....\n 3065                      Prog(argv[0]);\n 3066                  }\n 3067:                 const std::vector<std::string> args(argv + 1, argv + argc);\n 3068                  return ParseArgs(args) == std::end(args);\n 3069              }\n ....\n 3076      };\n 3077  \n 3078:     inline Command::RaiiSubparser::RaiiSubparser(ArgumentParser &parser_, std::vector<std::string> args_)\n 3079          : command(parser_.SelectedCommand()), parser(std::move(args_), parser_, command, parser_.helpParams), oldSubparser(command.subparser)\n 3080      {\n ....\n 3149              }\n 3150  \n 3151:             virtual void ParseValue(const std::vector<std::string>&) override\n 3152              {\n 3153              }\n ....\n 3165              virtual ~HelpFlag() {}\n 3166  \n 3167:             virtual void ParseValue(const std::vector<std::string> &)\n 3168              {\n 3169  #ifdef ARGS_NOEXCEPT\n ....\n 3226      {\n 3227          private:\n 3228:             std::function<void(const std::vector<std::string> &)> action;\n 3229              Nargs nargs;\n 3230  \n 3231          public:\n 3232:             ActionFlag(Group &group_, const std::string &name_, const std::string &help_, Matcher &&matcher_, Nargs nargs_, std::function<void(const std::vector<std::string> &)> action_, Options options_ = {}):\n 3233                  FlagBase(name_, help_, std::move(matcher_), options_), action(std::move(action_)), nargs(nargs_)\n 3234              {\n ....\n 3240              {\n 3241                  group_.Add(*this);\n 3242:                 action = [action_](const std::vector<std::string> &a) { return action_(a.at(0)); };\n 3243              }\n 3244  \n ....\n 3247              {\n 3248                  group_.Add(*this);\n 3249:                 action = [action_](const std::vector<std::string> &) { return action_(); };\n 3250              }\n 3251  \n ....\n 3253              { return nargs; }\n 3254  \n 3255:             virtual void ParseValue(const std::vector<std::string> &value) override\n 3256              { action(value); }\n 3257      };\n ....\n 3303       * \n 3304       * \\tparam T the type to extract the argument as\n 3305:      * \\tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with operator(), and returning a bool (if ARGS_NOEXCEPT is defined)\n 3306       */\n 3307      template <\n ....\n 3339              virtual ~ValueFlag() {}\n 3340  \n 3341:             virtual void ParseValue(const std::vector<std::string> &values_) override\n 3342              {\n 3343                  const std::string &value_ = values_.at(0);\n ....\n 3377       *\n 3378       * \\tparam T the type to extract the argument as\n 3379:      * \\tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with operator(), and returning a bool (if ARGS_NOEXCEPT is defined)\n 3380       */\n 3381      template <\n ....\n 3411              }\n 3412  \n 3413:             virtual void ParseValue(const std::vector<std::string> &value_) override\n 3414              {\n 3415                  if (value_.empty())\n ....\n 3427       * \\tparam T the type to extract the argument as\n 3428       * \\tparam List the list type that houses the values\n 3429:      * \\tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with operator(), and returning a bool (if ARGS_NOEXCEPT is defined)\n 3430       */\n 3431      template <\n 3432          typename T,\n 3433:         template <typename...> class List = std::vector,\n 3434          typename Reader = ValueReader>\n 3435      class NargsValueFlag : public FlagBase\n ....\n 3471              }\n 3472  \n 3473:             virtual void ParseValue(const std::vector<std::string> &values_) override\n 3474              {\n 3475                  values.clear();\n ....\n 3547       * \\tparam T the type to extract the argument as\n 3548       * \\tparam List the list type that houses the values\n 3549:      * \\tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with operator(), and returning a bool (if ARGS_NOEXCEPT is defined)\n 3550       */\n 3551      template <\n 3552          typename T,\n 3553:         template <typename...> class List = std::vector,\n 3554          typename Reader = ValueReader>\n 3555      class ValueFlagList : public ValueFlagBase\n ....\n 3584              virtual ~ValueFlagList() {}\n 3585  \n 3586:             virtual void ParseValue(const std::vector<std::string> &values_) override\n 3587              {\n 3588                  const std::string &value_ = values_.at(0);\n ....\n 3664       * \\tparam K the type to extract the argument as\n 3665       * \\tparam T the type to store the result as\n 3666:      * \\tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with operator(), and returning a bool (if ARGS_NOEXCEPT is defined)\n 3667       * \\tparam Map The Map type.  Should operate like std::map or std::unordered_map\n 3668       */\n ....\n 3681  \n 3682          protected:\n 3683:             virtual std::vector<std::string> GetChoicesStrings(const HelpParams &) const override\n 3684              {\n 3685                  return detail::MapKeysToStrings(map);\n ....\n 3703              virtual ~MapFlag() {}\n 3704  \n 3705:             virtual void ParseValue(const std::vector<std::string> &values_) override\n 3706              {\n 3707                  const std::string &value_ = values_.at(0);\n ....\n 3752       * \\tparam T the type to store the result as\n 3753       * \\tparam List the list type that houses the values\n 3754:      * \\tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with operator(), and returning a bool (if ARGS_NOEXCEPT is defined)\n 3755       * \\tparam Map The Map type.  Should operate like std::map or std::unordered_map\n 3756       */\n ....\n 3758          typename K,\n 3759          typename T,\n 3760:         template <typename...> class List = std::vector,\n 3761          typename Reader = ValueReader,\n 3762          template <typename...> class Map = std::unordered_map>\n ....\n 3771  \n 3772          protected:\n 3773:             virtual std::vector<std::string> GetChoicesStrings(const HelpParams &) const override\n 3774              {\n 3775                  return detail::MapKeysToStrings(map);\n ....\n 3797              virtual ~MapFlagList() {}\n 3798  \n 3799:             virtual void ParseValue(const std::vector<std::string> &values_) override\n 3800              {\n 3801                  const std::string &value = values_.at(0);\n ....\n 3890       *\n 3891       * \\tparam T the type to extract the argument as\n 3892:      * \\tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with operator(), and returning a bool (if ARGS_NOEXCEPT is defined)\n 3893       */\n 3894      template <\n ....\n 3945       * \\tparam T the type to extract the argument as\n 3946       * \\tparam List the list type that houses the values\n 3947:      * \\tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with operator(), and returning a bool (if ARGS_NOEXCEPT is defined)\n 3948       */\n 3949      template <\n 3950          typename T,\n 3951:         template <typename...> class List = std::vector,\n 3952          typename Reader = ValueReader>\n 3953      class PositionalList : public PositionalBase\n ....\n 4063       * \\tparam K the type to extract the argument as\n 4064       * \\tparam T the type to store the result as\n 4065:      * \\tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with operator(), and returning a bool (if ARGS_NOEXCEPT is defined)\n 4066       * \\tparam Map The Map type.  Should operate like std::map or std::unordered_map\n 4067       */\n ....\n 4080  \n 4081          protected:\n 4082:             virtual std::vector<std::string> GetChoicesStrings(const HelpParams &) const override\n 4083              {\n 4084                  return detail::MapKeysToStrings(map);\n ....\n 4144       * \\tparam T the type to store the result as\n 4145       * \\tparam List the list type that houses the values\n 4146:      * \\tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with operator(), and returning a bool (if ARGS_NOEXCEPT is defined)\n 4147       * \\tparam Map The Map type.  Should operate like std::map or std::unordered_map\n 4148       */\n ....\n 4150          typename K,\n 4151          typename T,\n 4152:         template <typename...> class List = std::vector,\n 4153          typename Reader = ValueReader,\n 4154          template <typename...> class Map = std::unordered_map>\n ....\n 4164  \n 4165          protected:\n 4166:             virtual std::vector<std::string> GetChoicesStrings(const HelpParams &) const override\n 4167              {\n 4168                  return detail::MapKeysToStrings(map);\n\n/home/max/dev/Falcor/src/Tools/ImageCompare/ImageCompare.cpp:\n   29  #include <memory>\n   30  #include <string>\n   31: #include <vector>\n   32  #include <stdexcept>\n   33  #include <map>\n   ..\n  228  };\n  229  \n  230: static const std::vector<ErrorMetric> errorMetrics =\n  231  {\n  232      { \"mse\", \"Mean Squared Error\", compare<MSE> },\n\n/home/max/dev/Falcor/src/Tools/ImageCompare/ImageCompare.vcxproj:\n   69        <LanguageStandard>stdcpp17</LanguageStandard>\n   70        <MultiProcessorCompilation>true</MultiProcessorCompilation>\n   71:       <AdditionalIncludeDirectories>$(ProjectDir)\\..\\..\\Externals\\.packman\\FreeImage;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n   72      </ClCompile>\n   73      <Link>\n   ..\n   88        <LanguageStandard>stdcpp17</LanguageStandard>\n   89        <MultiProcessorCompilation>true</MultiProcessorCompilation>\n   90:       <AdditionalIncludeDirectories>$(ProjectDir)\\..\\..\\Externals\\.packman\\FreeImage;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n   91      </ClCompile>\n   92      <Link>\n\n/home/max/dev/Falcor/src/Tools/RenderGraphEditor/RenderGraphEditor.cpp:\n  288  \n  289      if (settingsWindow.button(\"Auto-Generate Edges\")) {\n  290:         std::vector<uint32_t> executionOrder = mRenderGraphUIs[mCurrentGraphIndex].getPassOrder();\n  291          mpGraphs[mCurrentGraphIndex]->autoGenEdges(executionOrder);\n  292          mRenderGraphUIs[mCurrentGraphIndex].setToRebuild();\n  ...\n  299  //     }\n  300  \n  301:     std::vector<std::string> graphOutputString{ mGraphOutputEditString };\n  302      if (settingsWindow.multiTextbox(\"Add Output\", { \"GraphOutput\" }, graphOutputString)) {\n  303          if (mCurrentGraphOutput != mGraphOutputEditString) {\n  ...\n  374  \n  375  void RenderGraphEditor::loadAllPassLibraries() {\n  376:     std::string executableDirectory = getExecutableDirectory();\n  377  \n  378      // iterate through and find all render pass libraries\n  379:     LOG_DBG(\"Loading render-pass libraries from %s directory...\", executableDirectory.c_str());\n  380:     for (auto& file : fs::directory_iterator(executableDirectory)) {\n  381          std::string filename = file.path().string();\n  382          \n  ...\n  417  \n  418      // behavior is load each graph defined within the file as a separate editor ui\n  419:     std::vector <RenderGraph::SharedPtr> newGraphs;\n  420      if (graphName.size()) {\n  421          auto pGraph = RenderGraphImporter::import(graphName, fileName);\n\n/home/max/dev/Falcor/src/Tools/RenderGraphEditor/RenderGraphEditor.h:\n   29  \n   30  #include <string>\n   31: #include <vector>\n   32  #include <unordered_map>\n   33  \n   ..\n   55      void loadAllPassLibraries();\n   56  \n   57:     std::vector<RenderGraph::SharedPtr> mpGraphs;\n   58:     std::vector<RenderGraphUI> mRenderGraphUIs;\n   59      std::unordered_map<std::string, uint32_t> mGraphNamesToIndex;\n   60      size_t mCurrentGraphIndex;\n\n4340 matches across 543 files\n\n\nSearching 1246 files for \".ctor\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Device.cpp:\n  392  \n  393      auto deviceClass = m.regClass(Device);\n  394:     //deviceClass.ctor(&Device::create);\n  395:     deviceClass.ctor(&create_headless);\n  396  }\n  397  \n  ...\n  401  SCRIPT_BINDING(RenderGraph) {\n  402      auto graphClass = m.regClass(RenderGraph);\n  403:     graphClass.ctor(&RenderGraph::create);\n  404      graphClass.property(\"name\", &RenderGraph::getName, &RenderGraph::setName);\n  405      graphClass.func_(RenderGraphIR::kAddPass, &RenderGraph::addPass, \"pass\"_a, \"name\"_a);\n  ...\n  426          return pPass;\n  427      };\n  428:     passClass.ctor(createRenderPass, \"device\"_a, \"name\"_a, \"dict\"_a = pybind11::dict());\n  429  \n  430      const auto& loadPassLibrary = [](const std::string& library) {\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraph.cpp:\n  659  \n  660      auto graphClass = m.regClass(RenderGraph);\n  661:     //graphClass.ctor(&RenderGraph::create(const std::string&));\n  662:     //graphClass.ctor(&RenderGraph::create(std::shared_ptr<Device>, const std::string&));\n  663  \n  664:     graphClass.ctor(&create_default);\n  665:     graphClass.ctor(&create_on_device);\n  666  \n  667      graphClass.property(\"name\", &RenderGraph::getName, &RenderGraph::setName);\n  ...\n  690          return pPass;\n  691      };\n  692:     passClass.ctor(createRenderPass, \"device\"_a, \"name\"_a, \"dict\"_a = pybind11::dict());\n  693  \n  694      // RenderPassLibrary with default device\n  ...\n  702          return pPass;\n  703      };\n  704:     passClass.ctor(createRenderPassDefault, \"name\"_a, \"dict\"_a = pybind11::dict());\n  705      */\n  706  \n\n10 matches across 2 files\n",
			"settings":
			{
				"buffer_size": 945414,
				"line_ending": "Unix",
				"name": "Find Results",
				"scratch": true
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderPassStandardFlags.h",
			"settings":
			{
				"buffer_size": 2479,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKTexture.cpp",
			"settings":
			{
				"buffer_size": 7857,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Platform/OS.cpp",
			"settings":
			{
				"buffer_size": 8922,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Platform/OS.h",
			"settings":
			{
				"buffer_size": 15995,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Platform/Linux/Linux.cpp",
			"settings":
			{
				"buffer_size": 15074,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/ProgramVersion.cpp",
			"settings":
			{
				"buffer_size": 8172,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/Program.cpp",
			"settings":
			{
				"buffer_size": 34652,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/Gui.cpp",
			"settings":
			{
				"buffer_size": 57140,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/slang.h",
			"settings":
			{
				"buffer_size": 132132,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Sample.cpp",
			"settings":
			{
				"buffer_size": 25381,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/FBO.h",
			"settings":
			{
				"buffer_size": 13546,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/FBO.cpp",
			"settings":
			{
				"buffer_size": 18222,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKFbo.cpp",
			"settings":
			{
				"buffer_size": 5790,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Texture.cpp",
			"settings":
			{
				"buffer_size": 16621,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/ResourceViews.h",
			"settings":
			{
				"buffer_size": 9621,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKResourceViews.cpp",
			"settings":
			{
				"buffer_size": 13548,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/ResourceViews.cpp",
			"settings":
			{
				"buffer_size": 5611,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Device.cpp",
			"settings":
			{
				"buffer_size": 18398,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKDevice.cpp",
			"settings":
			{
				"buffer_size": 30042,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Formats.h",
			"settings":
			{
				"buffer_size": 13822,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKBuffer.cpp",
			"settings":
			{
				"buffer_size": 6579,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 491,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/Mogwai.cpp",
			"settings":
			{
				"buffer_size": 25155,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Scripting/Scripting.cpp",
			"settings":
			{
				"buffer_size": 5902,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderGraphExe.h",
			"settings":
			{
				"buffer_size": 4072,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Renderer.h",
			"settings":
			{
				"buffer_size": 7238,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/Mogwai.h",
			"settings":
			{
				"buffer_size": 8364,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Device.h",
			"settings":
			{
				"buffer_size": 11497,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/lava_lib/renderer.cpp",
			"settings":
			{
				"buffer_size": 10319,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/lava_cmd/conf/default.py",
			"settings":
			{
				"buffer_size": 1458,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/lava_lib/renderer.h",
			"settings":
			{
				"buffer_size": 4559,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/lava_lib/renderer_scripting.cpp",
			"settings":
			{
				"buffer_size": 4793,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/lava_lib/scene_reader_base.h",
			"settings":
			{
				"buffer_size": 1301,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/lava_lib/scene_reader_base.cpp",
			"settings":
			{
				"buffer_size": 1003,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/lava_lib/renderer_iface.h",
			"settings":
			{
				"buffer_size": 899,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/lava_lib/renderer_iface.cpp",
			"settings":
			{
				"buffer_size": 1344,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/lava_lib/readers/lsd_visitor.cpp",
			"settings":
			{
				"buffer_size": 1855,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/lava_lib/readers/renderer_iface_lsd.h",
			"settings":
			{
				"buffer_size": 801,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/lava_lib/readers/renderer_iface_lsd.cpp",
			"settings":
			{
				"buffer_size": 2379,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/lava_lib/readers/reader_lsd.cpp",
			"settings":
			{
				"buffer_size": 2997,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/lava_lib/readers/grammar_lsd.h",
			"settings":
			{
				"buffer_size": 25150,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/lava_lib/readers/reader_lsd.h",
			"settings":
			{
				"buffer_size": 1537,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"Package Control: ",
				"Package Control: Install Package"
			]
		],
		"width": 0.0
	},
	"console":
	{
		"height": 320.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/max/dev/Falcor",
		"/home/max/dev/Falcor/cmake",
		"/home/max/dev/Falcor/contrib",
		"/home/max/dev/Falcor/contrib/houdini",
		"/home/max/dev/Falcor/contrib/houdini/config",
		"/home/max/dev/Falcor/contrib/houdini/otls",
		"/home/max/dev/Falcor/contrib/linux",
		"/home/max/dev/Falcor/contrib/linux/etc",
		"/home/max/dev/Falcor/src",
		"/home/max/dev/Falcor/src/Falcor",
		"/home/max/dev/Falcor/src/Falcor/Core",
		"/home/max/dev/Falcor/src/Falcor/Core/API",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan",
		"/home/max/dev/Falcor/src/Falcor/Core/Program",
		"/home/max/dev/Falcor/src/Falcor/RenderGraph",
		"/home/max/dev/Falcor/src/Falcor/Utils",
		"/home/max/dev/Falcor/src/Falcor/Utils/Debug",
		"/home/max/dev/Falcor/src/Falcor/Utils/Scripting",
		"/home/max/dev/Falcor/src/Falcor/Utils/UI",
		"/home/max/dev/Falcor/src/houdini",
		"/home/max/dev/Falcor/src/houdini/ropLava",
		"/home/max/dev/Falcor/src/houdini/soho",
		"/home/max/dev/Falcor/src/lava_cmd",
		"/home/max/dev/Falcor/src/lava_cmd/bin",
		"/home/max/dev/Falcor/src/lava_cmd/conf",
		"/home/max/dev/Falcor/src/lava_lib",
		"/home/max/dev/Falcor/src/lava_lib/readers",
		"/home/max/dev/Falcor/src/lava_utils_lib",
		"/home/max/dev/Falcor/src/Mogwai",
		"/home/max/dev/Falcor/src/Mogwai/Data"
	],
	"file_history":
	[
		"/home/max/dev/Falcor/src/USD/hgiVk/pipeline.h",
		"/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12ResourceViews.cpp",
		"/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/atn/LexerATNSimulator.cpp",
		"/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/UnbufferedTokenStream.cpp",
		"/home/max/dev/RadeonProRenderUSD/deps/RPR/RadeonProRender/inc/RadeonProRender_v2.h",
		"/home/max/dev/Falcor/src/lava/lava.h",
		"/home/max/dev/Falcor/src/lava/types.h",
		"/home/max/dev/RadeonProRenderUSD/deps/RPR/RadeonProRender/inc/RadeonProRender.cs",
		"/home/max/dev/RadeonProRenderUSD/pxr/imaging/plugin/hdRpr/python/generateRenderSettingFiles.py",
		"/home/max/dev/Falcor/third_party/USD/cmake/macros/Private.cmake",
		"/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12NvApiExDesc.h",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VkResource.cpp",
		"/home/max/dev/Falcor/src/Mogwai/Data/ForwardRenderer.py",
		"/home/max/dev/Falcor/src/Mogwai/Data/BSDFViewer.py",
		"/home/max/dev/Falcor/third_party/slang/external/glslang/glslang/Include/BaseTypes.h",
		"/home/max/dev/Falcor/third_party/slang/external/glslang/glslang/MachineIndependent/Initialize.cpp",
		"/home/max/dev/Falcor/src/Falcor/Scene/Raster.slang",
		"/home/max/dev/Falcor/src/RenderPasses/GBuffer/GBuffer/GBufferRaster.3d.slang",
		"/home/max/dev/Falcor/src/Falcor/Scene/ShadingData.slang",
		"/home/max/dev/Falcor/src/RenderPasses/Antialiasing/TAA/TAA.ps.slang",
		"/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVH.cpp",
		"/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVHBuilder.h",
		"/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVHBuilder.cpp",
		"/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVH.h",
		"/home/max/dev/Falcor/src/Falcor/Utils/Algorithm/ParallelReduction.ps.slang",
		"/home/max/dev/Falcor/src/RenderPasses/BSDFViewer/BSDFViewerParams.slang",
		"/home/max/dev/Falcor/third_party/slang/external/glslang/glslang/MachineIndependent/ParseHelper.cpp",
		"/home/max/dev/Falcor/third_party/slang/external/glslang/SPIRV/SpvBuilder.cpp",
		"/home/max/dev/Falcor/third_party/slang/source/slang/slang-ir.cpp",
		"/home/max/dev/Falcor/third_party/slang/external/glslang/SPIRV/SpvBuilder.h",
		"/home/max/dev/Falcor/third_party/slang/source/slang-glslang/slang-glslang.cpp",
		"/home/max/dev/Falcor/third_party/slang/external/spirv-tools/source/spirv_target_env.cpp",
		"/home/max/dev/Falcor/third_party/slang/external/spirv-tools/CHANGES",
		"/home/max/dev/Falcor/src/Falcor/Scene/SceneBuilder.cpp",
		"/home/max/dev/Falcor/src/Falcor/Scene/SceneTypes.slang",
		"/home/max/dev/Falcor/third_party/slang/source/slang/slang-type-layout.cpp",
		"/home/max/dev/Falcor/third_party/slang/source/slang/slang-type-layout.h",
		"/home/max/dev/Falcor/third_party/slang/slang.h",
		"/home/max/dev/Falcor/third_party/slang/external/glm/test/core/core_type_aligned.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Formats.cpp",
		"/home/max/dev/Falcor/third_party/slang/external/glm/glm/gtx/compatibility.hpp",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKFormats.cpp",
		"/home/max/dev/Falcor/third_party/slang/external/glslang/glslang/Include/intermediate.h",
		"/home/max/dev/Falcor/third_party/slang/docs/language-reference/04-types.md",
		"/home/max/dev/Falcor/third_party/slang/external/glslang/CMakeLists.txt",
		"/home/max/dev/Falcor/third_party/slang/external/glslang/SPIRV/GlslangToSpv.cpp",
		"/home/max/dev/Falcor/third_party/slang/external/glslang/Test/100.frag",
		"/home/max/dev/Falcor/third_party/slang/external/glext.h",
		"/home/max/dev/Falcor/third_party/slang/docs/wave-intrinsics.md",
		"/home/max/dev/Falcor/src/RenderPasses/DebugPasses/InvalidPixelDetectionPass/InvalidPixelDetectionPass.cpp",
		"/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Core/RootBufferParamBlockTests.cpp",
		"/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Core/RootBufferParamBlockTests.cs.slang",
		"/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Core/ParamBlockDefinition.slang",
		"/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramVersion.cpp",
		"/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraphIR.cpp",
		"/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraphIR.h",
		"/home/max/dev/Falcor/src/Falcor/Scene/Importers/AssimpImporter.cpp",
		"/home/max/dev/Falcor/src/Falcor/Scene/Importers/AssimpImporter.h",
		"/home/max/dev/Falcor/src/Falcor/Scene/Importers/PythonImporter.h",
		"/home/max/dev/Falcor/src/Falcor/Scene/Camera/Camera.h",
		"/home/max/dev/Falcor/src/Falcor/Utils/Sampling/SampleGenerator.h",
		"/home/max/dev/Falcor/src/Falcor/Utils/SampleGenerators/StratifiedSamplePattern.h",
		"/home/max/dev/Falcor/src/Falcor/Utils/SampleGenerators/HaltonSamplePattern.h",
		"/home/max/dev/Falcor/src/Falcor/Utils/SampleGenerators/CPUSampleGenerator.h",
		"/home/max/dev/Falcor/src/Falcor/Core/API/GraphicsStateObject.h",
		"/home/max/dev/Falcor/src/Falcor/Core/API/GraphicsStateObject.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKFbo.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/API/ComputeStateObject.h",
		"/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/EnvProbe.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/API/ComputeContext.h",
		"/home/max/dev/Falcor/src/Falcor/Core/API/GpuTimer.h",
		"/home/max/dev/Falcor/src/Falcor/Core/API/LowLevelContextData.h",
		"/home/max/dev/Falcor/src/Falcor/Utils/Timing/Profiler.h",
		"/home/max/dev/Falcor/src/Falcor/Core/Platform/Windows/Windows.cpp",
		"/home/max/dev/Falcor/third_party/slang/tools/gfx/d3d12/render-d3d12.cpp",
		"/home/max/dev/Falcor/third_party/slang/tools/gfx/vulkan/render-vk.cpp",
		"/home/max/dev/Falcor/src/Falcor/Raytracing/RtProgramVarsHelper.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/FalcorD3D12.h",
		"/home/max/dev/Falcor/src/Falcor/Core/Platform/OS.cpp",
		"/home/max/dev/Falcor/src/RenderPasses/SkyBox/SkyBox.slang",
		"/home/max/dev/Falcor/src/RenderPasses/CSM/VisibilityPass.ps.slang",
		"/home/max/dev/Falcor/src/RenderPasses/ToneMapper/ToneMapping.ps.slang",
		"/home/max/dev/Falcor/src/RenderPasses/ToneMapper/Luminance.ps.slang",
		"/home/max/dev/Falcor/src/Falcor/Scene/Importers/PythonImporter.cpp",
		"/home/max/dev/Falcor/src/Falcor/Scene/Importers/SceneImporter.cpp",
		"/home/max/dev/Falcor/src/Falcor/Scene/Importers/SceneImporter.h",
		"/home/max/dev/Falcor/src/Falcor/Core/Program/Program.h",
		"/home/max/dev/Falcor/src/Falcor/Core/Program/GraphicsProgram.h",
		"/home/max/dev/Falcor/src/Falcor/Core/Program/ComputeProgram.h",
		"/home/max/dev/Falcor/src/Falcor/Core/Program/GraphicsProgram.cpp",
		"/home/max/dev/Falcor/src/Falcor/Scene/Camera/Camera.slang",
		"/home/max/dev/Falcor/src/Falcor/Utils/ArgList.h",
		"/home/max/dev/Falcor/src/Mogwai/Mogwai.cpp",
		"/home/max/dev/Falcor/src/Mogwai/stdafx.h",
		"/home/max/dev/Falcor/src/Falcor/Core/Renderer.h",
		"/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderPassLibrary.cpp",
		"/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderPassLibrary.h",
		"/home/max/dev/Falcor/src/Falcor/Utils/UI/UserInput.h",
		"/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/compatibility.hpp",
		"/home/max/dev/Falcor/src/Falcor/Core/Sample.h",
		"/home/max/dev/Falcor/src/Falcor/Utils/UI/Gui.h",
		"/home/max/dev/Falcor/src/Falcor/Core/Window.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/Window.h",
		"/home/max/dev/Falcor/src/Falcor/Utils/ArgList.cpp",
		"/home/max/dev/Falcor/src/Falcor/Utils/AlignedAllocator.h",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Resource.h",
		"/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Core/BufferTests.cpp",
		"/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/DebugPasses/InvalidPixelDetectionTests.cpp",
		"/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/ShadingUtils/ShadingUtilsTests.cpp",
		"/home/max/dev/Falcor/src/Falcor/Testing/UnitTest.h",
		"/home/max/dev/Falcor/src/Falcor/Testing/UnitTest.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/Program/ComputeProgram.cpp",
		"/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Core/BufferAccessTests.cpp",
		"/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Core/BufferAccessTests.cs.slang",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Resource.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/API/RenderContext.h",
		"/home/max/dev/Falcor/src/Falcor/Core/API/RenderContext.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/API/RasterizerState.h",
		"/home/max/dev/Falcor/src/Falcor/Core/API/RasterizerState.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKRasterizerState.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/API/QueryHeap.h",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Formats.h",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Buffer.h",
		"/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/EnvProbe.h",
		"/home/max/dev/Falcor/src/Mogwai/CMakeLists.txt",
		"/home/max/dev/Falcor/src/Mogwai/Extensions/Capture/CaptureTrigger.cpp",
		"/home/max/dev/Falcor/src/Mogwai/Extensions/Capture/VideoCapture.cpp",
		"/home/max/dev/Falcor/src/Mogwai/Extensions/Capture/FrameCapture.cpp"
	],
	"find":
	{
		"height": 39.0
	},
	"find_in_files":
	{
		"height": 125.0,
		"where_history":
		[
			"/home/max/dev/Falcor/src",
			"/home/max/dev/Falcor/",
			"/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src",
			"/home/max/dev/Falcor/",
			"/home/max/dev/Falcor/contrib",
			"/home/max/dev/Falcor/src",
			"/home/max/dev/Falcor/src/Falcor",
			"/opt/USD",
			"/home/max/dev/Falcor/src",
			"/home/max/dev/Falcor/",
			"/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava",
			"/home/max/dev/RadeonProRenderUSD",
			"/home/max/dev/Falcor",
			"/home/max/dev/RadeonProRenderUSD",
			"/home/max/dev/Falcor",
			"/home/max/dev/Falcor/src",
			"/home/max/dev/Falcor/src,/home/max/dev/Falcor/third_party/slang",
			"/home/max/dev/Falcor/src",
			"/home/max/dev/Falcor/src/Falcor",
			"/home/max/dev/Falcor/src/Falcor,/home/max/dev/Falcor/third_party/slang",
			"/home/max/dev/Falcor/src/Falcor",
			"/home/max/dev/Falcor/third_party/slang/source",
			"/home/max/dev/Falcor/src",
			"/home/max/dev/Falcor/third_party/slang",
			"/home/max/dev/Falcor/src",
			"/home/max/dev/Falcor/third_party/slang",
			"/home/max/dev/Falcor/src",
			"/home/max/dev/Falcor/Build",
			"/home/max/dev/Falcor/",
			"/home/max/dev/Falcor/src/",
			"/home/max/dev/Falcor/src/Mogwai",
			"/home/max/dev/Falcor/src/Falcor",
			"/home/max/dev/Falcor/",
			"/home/max/dev/Falcor/src/Falcor",
			"/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan",
			"/home/max/dev/Falcor/src",
			"/home/max/dev/Falcor/src/Falcor",
			"/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan",
			"/home/max/dev/Falcor"
		]
	},
	"find_state":
	{
		"case_sensitive": true,
		"find_history":
		[
			".ctor",
			"ctor",
			"registerScriptBindings",
			"kRenderPassRefreshFlags",
			"vkCreateImage",
			"mpTargetFBO",
			"GraphicsProgram::createFromFile",
			"GuiImpl::create",
			"GuiImpl",
			"Failed to link program",
			"findFileInShaderDirectories",
			"Shaders",
			"build",
			"Failed to link program",
			"RenderGraph::create",
			"mpTargetFBO",
			"gpFramework",
			"Can't construct RenderGraph",
			"tcur",
			"Operand",
			" ]",
			"build",
			"addParseListener",
			"getText",
			"context",
			"ctx",
			"IFD",
			"ExternalProject_Add_Step",
			"ray_",
			"lv_samples",
			"lv_samplesx",
			"vm_samples",
			"samples",
			"lv_samples",
			"vm_",
			"vm_picture",
			"vm_device",
			"vm_display",
			"ri_",
			"ri_device",
			"Unable to find:",
			"LSDapilavatext",
			"RIB",
			"IFD",
			"ray_",
			"IFD",
			"ray_",
			"IFD",
			"ray_",
			"IFD",
			"ray_",
			"IFD",
			"ray_",
			"outputCamera",
			"ray_",
			"ray_geometry",
			"ROP_Xenon",
			"Xenon",
			"fasta",
			"Render",
			"_Execute",
			"HdLavaRenderBuffer",
			"PYBIND11_EMBEDDED_MODULE",
			"pybind11::module",
			"pybind11",
			"initialize_interpreter",
			"Can't add new modules after the interpreter has been initialized",
			"Scripting::start",
			"Can't add new modules after the interpreter has been initialized",
			"GetNumActivePixels",
			"m_delegate",
			"m_rprContext",
			"CONTEXT",
			"RPR",
			"RPR_CONTEXT_LAST_ERROR_MESSAGE",
			"RPR",
			"RPR_SUCCESS",
			"RPR",
			"rpr_aov",
			"Aov",
			"class Aov",
			"enum Aov",
			"Rpr",
			"RPR",
			"Rpr",
			"RPR",
			"HdRpr",
			"LavaRenderSettingsTokens",
			"HdRpr",
			"HDRPR",
			"HdRpr",
			"GetRenderSettingDescriptors",
			"config.h",
			"HdOSPRay",
			"HdRpr",
			"HDRPR",
			"HdRpr",
			"HDRPR",
			"HdRpr",
			"copyHeaderForBuild",
			"HDRPR",
			"HdRpr",
			"HDRPR",
			"HdRpr",
			"HDRPR",
			"HdRpr",
			"OSPRay",
			"_sceneVersion",
			"_modelVersion",
			"_sceneVersion",
			"_renderer",
			"opp::Renderer",
			"OSPRay",
			"OSPRAY",
			"OSPRay",
			"OSPRAY",
			"HDOSPRAY",
			"_sceneVersion",
			"_sce",
			"_settingDescriptors",
			"_lastCommittedModelVersion",
			"_renderParam",
			"mRenderParam",
			"OSPRAY",
			"OSPRay",
			"OSPRAY",
			"OSPRay",
			"IRenderer"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"ExprValue",
			"ctx",
			"context",
			"LSD",
			"cmd_",
			"lv_",
			"li_",
			"LSD",
			"cmd_",
			"LSD",
			"cmd_",
			"LSD",
			"cmd_",
			"LSD",
			"cmd_",
			"LSD",
			"cmd_",
			"ROP_Lava",
			"Lava",
			"lava",
			"mRenderer",
			"RENDERER",
			"LAVA",
			"Lava",
			"LAVA",
			"Lava",
			"LAVA",
			"HdLava",
			"HDLAVA",
			"HdLava",
			"HDLAVA",
			"HdLava",
			"HDLAVA",
			"HdLava",
			"HDLAVA",
			"HdLava",
			"HDLAVA",
			"HdLava",
			"HDLAVA",
			"HdLava",
			"Lava",
			"mSceneVersion",
			"mModelVersion",
			"mSceneVersion",
			"mRenderer",
			"Falcor::LavaRenderer",
			"Lava",
			"LAVA",
			"Lava",
			"LAVA",
			"mSceneVersion",
			"mSettingDescriptors",
			"mLastCommittedModelVersion",
			"mRenderParam",
			"LAVA",
			"Lava",
			"LAVA",
			"Lava",
			"mpDevice",
			"kPassTempLibSuffix",
			"PROJECT_DIR",
			"spData"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 30,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "src/Falcor/Core/Program/GraphicsProgram.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2616,
						"regions":
						{
						},
						"selection":
						[
							[
								2182,
								2182
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 117.0,
						"zoom_level": 1.0
					},
					"stack_index": 42,
					"type": "text"
				},
				{
					"buffer": 1,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 945414,
						"regions":
						{
							"match":
							{
								"flags": 112,
								"regions":
								[
									[
										237,
										256
									],
									[
										647,
										666
									],
									[
										812,
										831
									],
									[
										1085,
										1104
									],
									[
										1207,
										1226
									],
									[
										1320,
										1339
									],
									[
										1392,
										1411
									],
									[
										1681,
										1700
									],
									[
										2028,
										2047
									],
									[
										2375,
										2394
									],
									[
										2921,
										2940
									],
									[
										3368,
										3387
									],
									[
										3694,
										3716
									],
									[
										3871,
										3893
									],
									[
										4111,
										4133
									],
									[
										4283,
										4305
									],
									[
										4724,
										4729
									],
									[
										5061,
										5066
									],
									[
										5465,
										5470
									],
									[
										5690,
										5695
									],
									[
										5881,
										5886
									],
									[
										6037,
										6042
									],
									[
										6197,
										6202
									],
									[
										6363,
										6368
									],
									[
										6521,
										6526
									],
									[
										6692,
										6697
									],
									[
										6855,
										6860
									],
									[
										7026,
										7031
									],
									[
										7189,
										7194
									],
									[
										7359,
										7364
									],
									[
										7521,
										7526
									],
									[
										7689,
										7694
									],
									[
										7849,
										7854
									],
									[
										8017,
										8022
									],
									[
										8177,
										8182
									],
									[
										8318,
										8323
									],
									[
										8451,
										8456
									],
									[
										8619,
										8624
									],
									[
										8779,
										8784
									],
									[
										8920,
										8925
									],
									[
										9053,
										9058
									],
									[
										9196,
										9201
									],
									[
										9331,
										9336
									],
									[
										9476,
										9481
									],
									[
										9613,
										9618
									],
									[
										9681,
										9686
									],
									[
										9844,
										9849
									],
									[
										10155,
										10160
									],
									[
										10428,
										10433
									],
									[
										10720,
										10725
									],
									[
										10861,
										10866
									],
									[
										11109,
										11114
									],
									[
										11472,
										11477
									],
									[
										11742,
										11747
									],
									[
										12006,
										12011
									],
									[
										12089,
										12094
									],
									[
										12261,
										12266
									],
									[
										12484,
										12489
									],
									[
										12762,
										12767
									],
									[
										13003,
										13008
									],
									[
										13163,
										13168
									],
									[
										13384,
										13389
									],
									[
										13527,
										13532
									],
									[
										13750,
										13755
									],
									[
										14005,
										14010
									],
									[
										14215,
										14220
									],
									[
										14325,
										14330
									],
									[
										14494,
										14499
									],
									[
										14803,
										14808
									],
									[
										14894,
										14899
									],
									[
										15108,
										15113
									],
									[
										15387,
										15392
									],
									[
										15551,
										15556
									],
									[
										15638,
										15643
									],
									[
										15965,
										15970
									],
									[
										16333,
										16338
									],
									[
										16648,
										16653
									],
									[
										16867,
										16872
									],
									[
										17141,
										17146
									],
									[
										17322,
										17327
									],
									[
										17454,
										17459
									],
									[
										17581,
										17586
									],
									[
										17678,
										17683
									],
									[
										17736,
										17741
									],
									[
										17981,
										17986
									],
									[
										18339,
										18344
									],
									[
										18641,
										18646
									],
									[
										18830,
										18835
									],
									[
										18968,
										18973
									],
									[
										19114,
										19119
									],
									[
										19255,
										19260
									],
									[
										19396,
										19401
									],
									[
										19540,
										19545
									],
									[
										20226,
										20231
									],
									[
										20252,
										20257
									],
									[
										20675,
										20680
									],
									[
										20840,
										20845
									],
									[
										21020,
										21025
									],
									[
										21170,
										21175
									],
									[
										21477,
										21482
									],
									[
										21706,
										21711
									],
									[
										21888,
										21893
									],
									[
										22150,
										22155
									],
									[
										22309,
										22314
									],
									[
										22489,
										22494
									],
									[
										22852,
										22857
									],
									[
										23115,
										23120
									],
									[
										23424,
										23429
									],
									[
										23734,
										23739
									],
									[
										24205,
										24210
									],
									[
										24694,
										24699
									],
									[
										24965,
										24970
									],
									[
										25043,
										25048
									],
									[
										25249,
										25254
									],
									[
										25499,
										25504
									],
									[
										25803,
										25808
									],
									[
										26133,
										26138
									],
									[
										26355,
										26360
									],
									[
										26752,
										26757
									],
									[
										26926,
										26931
									],
									[
										27320,
										27325
									],
									[
										27384,
										27389
									],
									[
										27589,
										27594
									],
									[
										27943,
										27948
									],
									[
										28216,
										28221
									],
									[
										29254,
										29259
									],
									[
										29903,
										29908
									],
									[
										30100,
										30105
									],
									[
										30145,
										30150
									],
									[
										30547,
										30552
									],
									[
										30810,
										30815
									],
									[
										31248,
										31253
									],
									[
										31577,
										31582
									],
									[
										31734,
										31739
									],
									[
										32071,
										32076
									],
									[
										32594,
										32599
									],
									[
										32634,
										32639
									],
									[
										32692,
										32697
									],
									[
										32751,
										32756
									],
									[
										32813,
										32818
									],
									[
										32855,
										32860
									],
									[
										32897,
										32902
									],
									[
										33285,
										33290
									],
									[
										33534,
										33539
									],
									[
										33572,
										33577
									],
									[
										33611,
										33616
									],
									[
										33678,
										33683
									],
									[
										33725,
										33730
									],
									[
										33799,
										33804
									],
									[
										33878,
										33883
									],
									[
										34176,
										34181
									],
									[
										34518,
										34523
									],
									[
										34740,
										34745
									],
									[
										34812,
										34817
									],
									[
										34929,
										34934
									],
									[
										35264,
										35269
									],
									[
										35595,
										35600
									],
									[
										35916,
										35921
									],
									[
										36115,
										36120
									],
									[
										36270,
										36275
									],
									[
										36301,
										36306
									],
									[
										36354,
										36359
									],
									[
										36624,
										36629
									],
									[
										36825,
										36830
									],
									[
										37217,
										37222
									],
									[
										37259,
										37264
									],
									[
										37378,
										37383
									],
									[
										37700,
										37705
									],
									[
										37816,
										37821
									],
									[
										38114,
										38119
									],
									[
										38404,
										38409
									],
									[
										38754,
										38759
									],
									[
										39061,
										39066
									],
									[
										39292,
										39297
									],
									[
										39588,
										39593
									],
									[
										39884,
										39889
									],
									[
										40180,
										40185
									],
									[
										40554,
										40559
									],
									[
										40911,
										40916
									],
									[
										41621,
										41626
									],
									[
										41709,
										41714
									],
									[
										41811,
										41816
									],
									[
										42583,
										42588
									],
									[
										42768,
										42773
									],
									[
										42833,
										42838
									],
									[
										43084,
										43089
									],
									[
										43355,
										43360
									],
									[
										43541,
										43546
									],
									[
										43598,
										43603
									],
									[
										43845,
										43850
									],
									[
										43971,
										43976
									],
									[
										44171,
										44176
									],
									[
										44498,
										44503
									],
									[
										44604,
										44609
									],
									[
										44694,
										44699
									],
									[
										44707,
										44712
									],
									[
										44918,
										44923
									],
									[
										45214,
										45219
									],
									[
										45502,
										45507
									],
									[
										45566,
										45571
									],
									[
										45970,
										45975
									],
									[
										46078,
										46083
									],
									[
										46318,
										46323
									],
									[
										46711,
										46716
									],
									[
										46847,
										46852
									],
									[
										47066,
										47071
									],
									[
										47131,
										47136
									],
									[
										47428,
										47433
									],
									[
										47703,
										47708
									],
									[
										47996,
										48001
									],
									[
										48256,
										48261
									],
									[
										48345,
										48350
									],
									[
										48481,
										48486
									],
									[
										48767,
										48772
									],
									[
										48787,
										48792
									],
									[
										48842,
										48847
									],
									[
										48910,
										48915
									],
									[
										49002,
										49007
									],
									[
										49105,
										49110
									],
									[
										49473,
										49478
									],
									[
										49771,
										49776
									],
									[
										50001,
										50006
									],
									[
										50016,
										50021
									],
									[
										50415,
										50420
									],
									[
										50715,
										50720
									],
									[
										50956,
										50961
									],
									[
										51065,
										51070
									],
									[
										51360,
										51365
									],
									[
										51476,
										51481
									],
									[
										51777,
										51782
									],
									[
										51816,
										51821
									],
									[
										52021,
										52026
									],
									[
										52080,
										52085
									],
									[
										52361,
										52366
									],
									[
										52620,
										52625
									],
									[
										52659,
										52664
									],
									[
										52837,
										52842
									],
									[
										53176,
										53181
									],
									[
										53340,
										53345
									],
									[
										53729,
										53734
									],
									[
										53900,
										53905
									],
									[
										54179,
										54184
									],
									[
										54450,
										54455
									],
									[
										54544,
										54549
									],
									[
										54601,
										54606
									],
									[
										54822,
										54827
									],
									[
										54850,
										54855
									],
									[
										55126,
										55131
									],
									[
										55331,
										55336
									],
									[
										55359,
										55364
									],
									[
										55576,
										55581
									],
									[
										55626,
										55631
									],
									[
										55733,
										55738
									],
									[
										55884,
										55889
									],
									[
										56044,
										56049
									],
									[
										56190,
										56195
									],
									[
										56288,
										56293
									],
									[
										56450,
										56455
									],
									[
										56803,
										56808
									],
									[
										56859,
										56864
									],
									[
										57001,
										57006
									],
									[
										57154,
										57159
									],
									[
										57182,
										57187
									],
									[
										57248,
										57253
									],
									[
										57541,
										57546
									],
									[
										57591,
										57596
									],
									[
										57724,
										57729
									],
									[
										57937,
										57942
									],
									[
										58350,
										58355
									],
									[
										58539,
										58544
									],
									[
										58794,
										58799
									],
									[
										59097,
										59102
									],
									[
										59243,
										59248
									],
									[
										59554,
										59559
									],
									[
										59742,
										59747
									],
									[
										59947,
										59952
									],
									[
										60299,
										60304
									],
									[
										60664,
										60669
									],
									[
										61124,
										61129
									],
									[
										61288,
										61293
									],
									[
										61563,
										61568
									],
									[
										62004,
										62009
									],
									[
										62100,
										62105
									],
									[
										62299,
										62304
									],
									[
										62469,
										62474
									],
									[
										62548,
										62553
									],
									[
										62613,
										62618
									],
									[
										62698,
										62703
									],
									[
										62782,
										62787
									],
									[
										62868,
										62873
									],
									[
										62944,
										62949
									],
									[
										63028,
										63033
									],
									[
										63110,
										63115
									],
									[
										63193,
										63198
									],
									[
										63417,
										63422
									],
									[
										63632,
										63637
									],
									[
										63754,
										63759
									],
									[
										64148,
										64153
									],
									[
										64453,
										64458
									],
									[
										64720,
										64725
									],
									[
										64964,
										64969
									],
									[
										65192,
										65197
									],
									[
										65541,
										65546
									],
									[
										65703,
										65708
									],
									[
										65958,
										65963
									],
									[
										66145,
										66150
									],
									[
										66415,
										66420
									],
									[
										66734,
										66739
									],
									[
										67122,
										67127
									],
									[
										67189,
										67194
									],
									[
										67472,
										67477
									],
									[
										67694,
										67699
									],
									[
										67761,
										67766
									],
									[
										68044,
										68049
									],
									[
										68241,
										68246
									],
									[
										68388,
										68393
									],
									[
										68614,
										68619
									],
									[
										68965,
										68970
									],
									[
										69269,
										69274
									],
									[
										69596,
										69601
									],
									[
										70039,
										70044
									],
									[
										70372,
										70377
									],
									[
										70687,
										70692
									],
									[
										71016,
										71021
									],
									[
										71321,
										71326
									],
									[
										71642,
										71647
									],
									[
										71947,
										71952
									],
									[
										72272,
										72277
									],
									[
										72533,
										72538
									],
									[
										72735,
										72740
									],
									[
										73041,
										73046
									],
									[
										73352,
										73357
									],
									[
										73654,
										73659
									],
									[
										73981,
										73986
									],
									[
										74287,
										74292
									],
									[
										74610,
										74615
									],
									[
										74928,
										74933
									],
									[
										75287,
										75292
									],
									[
										75630,
										75635
									],
									[
										75940,
										75945
									],
									[
										76259,
										76264
									],
									[
										76577,
										76582
									],
									[
										76904,
										76909
									],
									[
										77232,
										77237
									],
									[
										77577,
										77582
									],
									[
										77908,
										77913
									],
									[
										78247,
										78252
									],
									[
										78579,
										78584
									],
									[
										78922,
										78927
									],
									[
										79254,
										79259
									],
									[
										79595,
										79600
									],
									[
										79906,
										79911
									],
									[
										80223,
										80228
									],
									[
										80514,
										80519
									],
									[
										80827,
										80832
									],
									[
										81124,
										81129
									],
									[
										81445,
										81450
									],
									[
										81764,
										81769
									],
									[
										82103,
										82108
									],
									[
										82417,
										82422
									],
									[
										82742,
										82747
									],
									[
										83039,
										83044
									],
									[
										83354,
										83359
									],
									[
										83668,
										83673
									],
									[
										84005,
										84010
									],
									[
										84227,
										84232
									],
									[
										84555,
										84560
									],
									[
										84866,
										84871
									],
									[
										85187,
										85192
									],
									[
										85503,
										85508
									],
									[
										85715,
										85720
									],
									[
										85973,
										85978
									],
									[
										86295,
										86300
									],
									[
										86608,
										86613
									],
									[
										86938,
										86943
									],
									[
										87243,
										87248
									],
									[
										87561,
										87566
									],
									[
										87774,
										87779
									],
									[
										88094,
										88099
									],
									[
										88412,
										88417
									],
									[
										88627,
										88632
									],
									[
										88810,
										88815
									],
									[
										88961,
										88966
									],
									[
										89109,
										89114
									],
									[
										89368,
										89373
									],
									[
										89674,
										89679
									],
									[
										90104,
										90109
									],
									[
										90341,
										90346
									],
									[
										90602,
										90607
									],
									[
										90973,
										90980
									],
									[
										91329,
										91336
									],
									[
										91467,
										91474
									],
									[
										91743,
										91750
									],
									[
										92094,
										92101
									],
									[
										92297,
										92304
									],
									[
										92362,
										92369
									],
									[
										92533,
										92540
									],
									[
										92752,
										92759
									],
									[
										93007,
										93014
									],
									[
										93249,
										93256
									],
									[
										93355,
										93362
									],
									[
										93642,
										93649
									],
									[
										93751,
										93758
									],
									[
										93956,
										93963
									],
									[
										93965,
										93972
									],
									[
										94097,
										94104
									],
									[
										94338,
										94345
									],
									[
										94604,
										94611
									],
									[
										94859,
										94866
									],
									[
										95203,
										95210
									],
									[
										95402,
										95409
									],
									[
										95616,
										95623
									],
									[
										95875,
										95882
									],
									[
										96107,
										96114
									],
									[
										96164,
										96171
									],
									[
										96450,
										96457
									],
									[
										96587,
										96594
									],
									[
										96909,
										96916
									],
									[
										97251,
										97258
									],
									[
										97605,
										97612
									],
									[
										97947,
										97954
									],
									[
										98293,
										98300
									],
									[
										98635,
										98642
									],
									[
										98985,
										98992
									],
									[
										99327,
										99334
									],
									[
										99660,
										99667
									],
									[
										99950,
										99957
									],
									[
										100292,
										100299
									],
									[
										100644,
										100651
									],
									[
										100986,
										100993
									],
									[
										101334,
										101341
									],
									[
										101676,
										101683
									],
									[
										102038,
										102045
									],
									[
										102380,
										102387
									],
									[
										102748,
										102755
									],
									[
										103090,
										103097
									],
									[
										103434,
										103441
									],
									[
										103776,
										103783
									],
									[
										104128,
										104135
									],
									[
										104470,
										104477
									],
									[
										104840,
										104847
									],
									[
										105182,
										105189
									],
									[
										105546,
										105553
									],
									[
										105888,
										105895
									],
									[
										106256,
										106263
									],
									[
										106598,
										106605
									],
									[
										106964,
										106971
									],
									[
										107306,
										107313
									],
									[
										107648,
										107655
									],
									[
										107990,
										107997
									],
									[
										108328,
										108335
									],
									[
										108670,
										108677
									],
									[
										109016,
										109023
									],
									[
										109358,
										109365
									],
									[
										109708,
										109715
									],
									[
										110050,
										110057
									],
									[
										110390,
										110397
									],
									[
										110732,
										110739
									],
									[
										111094,
										111101
									],
									[
										111436,
										111443
									],
									[
										111758,
										111765
									],
									[
										112037,
										112044
									],
									[
										112374,
										112381
									],
									[
										112716,
										112723
									],
									[
										113053,
										113060
									],
									[
										113403,
										113410
									],
									[
										113740,
										113747
									],
									[
										114078,
										114085
									],
									[
										114415,
										114422
									],
									[
										114783,
										114790
									],
									[
										115103,
										115130
									],
									[
										115457,
										115484
									],
									[
										115740,
										115767
									],
									[
										116093,
										116120
									],
									[
										116610,
										116632
									],
									[
										116787,
										116809
									],
									[
										117027,
										117049
									],
									[
										117199,
										117221
									],
									[
										117473,
										117480
									],
									[
										117518,
										117525
									],
									[
										117656,
										117663
									],
									[
										117827,
										117834
									],
									[
										118115,
										118122
									],
									[
										118257,
										118264
									],
									[
										118508,
										118515
									],
									[
										118721,
										118728
									],
									[
										118937,
										118944
									],
									[
										119059,
										119066
									],
									[
										119157,
										119164
									],
									[
										119310,
										119317
									],
									[
										119415,
										119422
									],
									[
										119548,
										119555
									],
									[
										119647,
										119654
									],
									[
										119806,
										119813
									],
									[
										119982,
										119989
									],
									[
										120238,
										120245
									],
									[
										120360,
										120367
									],
									[
										120538,
										120545
									],
									[
										120736,
										120743
									],
									[
										120861,
										120868
									],
									[
										120958,
										120965
									],
									[
										121201,
										121208
									],
									[
										121345,
										121352
									],
									[
										121442,
										121449
									],
									[
										121591,
										121598
									],
									[
										121798,
										121805
									],
									[
										121985,
										121992
									],
									[
										122243,
										122250
									],
									[
										122428,
										122435
									],
									[
										122608,
										122615
									],
									[
										122840,
										122847
									],
									[
										123046,
										123053
									],
									[
										123284,
										123291
									],
									[
										123478,
										123485
									],
									[
										123816,
										123823
									],
									[
										124020,
										124027
									],
									[
										124203,
										124210
									],
									[
										124509,
										124516
									],
									[
										124737,
										124744
									],
									[
										124992,
										124999
									],
									[
										125181,
										125188
									],
									[
										125406,
										125413
									],
									[
										125632,
										125639
									],
									[
										125864,
										125871
									],
									[
										126122,
										126129
									],
									[
										126488,
										126495
									],
									[
										126842,
										126849
									],
									[
										127265,
										127272
									],
									[
										127685,
										127692
									],
									[
										127931,
										127938
									],
									[
										128526,
										128533
									],
									[
										128766,
										128773
									],
									[
										128931,
										128938
									],
									[
										129195,
										129210
									],
									[
										129663,
										129694
									],
									[
										130106,
										130137
									],
									[
										130547,
										130578
									],
									[
										131008,
										131039
									],
									[
										131417,
										131448
									],
									[
										131810,
										131841
									],
									[
										132198,
										132211
									],
									[
										132532,
										132545
									],
									[
										132908,
										132921
									],
									[
										133346,
										133369
									],
									[
										133699,
										133722
									],
									[
										133739,
										133762
									],
									[
										134004,
										134027
									],
									[
										134239,
										134262
									],
									[
										134485,
										134508
									],
									[
										134905,
										134928
									],
									[
										134937,
										134960
									],
									[
										135290,
										135313
									],
									[
										135330,
										135353
									],
									[
										135390,
										135413
									],
									[
										135798,
										135821
									],
									[
										135838,
										135861
									],
									[
										135898,
										135921
									],
									[
										136251,
										136274
									],
									[
										136291,
										136314
									],
									[
										136351,
										136374
									],
									[
										136759,
										136782
									],
									[
										136799,
										136822
									],
									[
										136859,
										136882
									],
									[
										137212,
										137235
									],
									[
										137252,
										137275
									],
									[
										137312,
										137335
									],
									[
										137675,
										137698
									],
									[
										137715,
										137738
									],
									[
										137775,
										137798
									],
									[
										138136,
										138159
									],
									[
										138176,
										138199
									],
									[
										138236,
										138259
									],
									[
										138650,
										138673
									],
									[
										139003,
										139026
									],
									[
										139043,
										139066
									],
									[
										139308,
										139331
									],
									[
										139543,
										139566
									],
									[
										139797,
										139820
									],
									[
										140217,
										140240
									],
									[
										140249,
										140272
									],
									[
										140602,
										140625
									],
									[
										140642,
										140665
									],
									[
										140702,
										140725
									],
									[
										141110,
										141133
									],
									[
										141150,
										141173
									],
									[
										141210,
										141233
									],
									[
										141563,
										141586
									],
									[
										141603,
										141626
									],
									[
										141663,
										141686
									],
									[
										142071,
										142094
									],
									[
										142111,
										142134
									],
									[
										142171,
										142194
									],
									[
										142524,
										142547
									],
									[
										142564,
										142587
									],
									[
										142624,
										142647
									],
									[
										142987,
										143010
									],
									[
										143027,
										143050
									],
									[
										143087,
										143110
									],
									[
										143448,
										143471
									],
									[
										143488,
										143511
									],
									[
										143548,
										143571
									],
									[
										143845,
										143849
									],
									[
										143903,
										143907
									],
									[
										143967,
										143971
									],
									[
										144032,
										144036
									],
									[
										144088,
										144092
									],
									[
										144148,
										144152
									],
									[
										144199,
										144203
									],
									[
										144259,
										144263
									],
									[
										144308,
										144312
									],
									[
										144360,
										144364
									],
									[
										144645,
										144649
									],
									[
										144741,
										144745
									],
									[
										145156,
										145160
									],
									[
										145617,
										145621
									],
									[
										146030,
										146034
									],
									[
										146280,
										146284
									],
									[
										146302,
										146306
									],
									[
										146385,
										146389
									],
									[
										146631,
										146635
									],
									[
										146856,
										146860
									],
									[
										147042,
										147046
									],
									[
										147248,
										147252
									],
									[
										147737,
										147741
									],
									[
										147931,
										147935
									],
									[
										148081,
										148085
									],
									[
										148228,
										148232
									],
									[
										148295,
										148299
									],
									[
										148397,
										148401
									],
									[
										148532,
										148536
									],
									[
										148775,
										148779
									],
									[
										149123,
										149127
									],
									[
										149216,
										149220
									],
									[
										149237,
										149241
									],
									[
										149261,
										149265
									],
									[
										149282,
										149286
									],
									[
										149465,
										149469
									],
									[
										149795,
										149799
									],
									[
										149884,
										149888
									],
									[
										150335,
										150339
									],
									[
										150483,
										150487
									],
									[
										150551,
										150555
									],
									[
										150653,
										150657
									],
									[
										150790,
										150794
									],
									[
										151034,
										151038
									],
									[
										151373,
										151377
									],
									[
										151466,
										151470
									],
									[
										151487,
										151491
									],
									[
										151511,
										151515
									],
									[
										151532,
										151536
									],
									[
										151726,
										151730
									],
									[
										152059,
										152063
									],
									[
										152148,
										152152
									],
									[
										152723,
										152727
									],
									[
										153155,
										153159
									],
									[
										153624,
										153628
									],
									[
										153989,
										153993
									],
									[
										154010,
										154014
									],
									[
										154389,
										154393
									],
									[
										154415,
										154419
									],
									[
										154735,
										154739
									],
									[
										155011,
										155015
									],
									[
										155420,
										155424
									],
									[
										155712,
										155716
									],
									[
										155780,
										155784
									],
									[
										156043,
										156047
									],
									[
										156077,
										156081
									],
									[
										156509,
										156513
									],
									[
										156543,
										156547
									],
									[
										156904,
										156908
									],
									[
										157100,
										157104
									],
									[
										157362,
										157366
									],
									[
										157690,
										157694
									],
									[
										158033,
										158037
									],
									[
										158392,
										158396
									],
									[
										158754,
										158758
									],
									[
										159089,
										159093
									],
									[
										159455,
										159459
									],
									[
										159882,
										159886
									],
									[
										160177,
										160181
									],
									[
										160434,
										160438
									],
									[
										160669,
										160673
									],
									[
										160940,
										160944
									],
									[
										161434,
										161438
									],
									[
										161515,
										161519
									],
									[
										161629,
										161633
									],
									[
										161710,
										161714
									],
									[
										161947,
										161951
									],
									[
										162218,
										162222
									],
									[
										162437,
										162441
									],
									[
										162774,
										162778
									],
									[
										163160,
										163164
									],
									[
										163550,
										163554
									],
									[
										163941,
										163945
									],
									[
										164332,
										164336
									],
									[
										164724,
										164728
									],
									[
										165101,
										165105
									],
									[
										165330,
										165334
									],
									[
										165684,
										165688
									],
									[
										166146,
										166150
									],
									[
										166518,
										166522
									],
									[
										166854,
										166858
									],
									[
										167075,
										167079
									],
									[
										167157,
										167161
									],
									[
										167175,
										167179
									],
									[
										167397,
										167401
									],
									[
										167617,
										167621
									],
									[
										168011,
										168015
									],
									[
										168265,
										168269
									],
									[
										168319,
										168323
									],
									[
										168347,
										168351
									],
									[
										168830,
										168834
									],
									[
										168905,
										168909
									],
									[
										169157,
										169161
									],
									[
										169177,
										169181
									],
									[
										169513,
										169517
									],
									[
										169624,
										169628
									],
									[
										169988,
										169992
									],
									[
										170236,
										170240
									],
									[
										170528,
										170532
									],
									[
										170874,
										170878
									],
									[
										171331,
										171335
									],
									[
										171352,
										171356
									],
									[
										171980,
										171984
									],
									[
										172501,
										172505
									],
									[
										172657,
										172661
									],
									[
										173084,
										173088
									],
									[
										173116,
										173120
									],
									[
										173269,
										173273
									],
									[
										173301,
										173305
									],
									[
										173879,
										173883
									],
									[
										174010,
										174014
									],
									[
										174428,
										174432
									],
									[
										174769,
										174773
									],
									[
										175028,
										175032
									],
									[
										175609,
										175613
									],
									[
										176100,
										176104
									],
									[
										176265,
										176269
									],
									[
										176386,
										176390
									],
									[
										176681,
										176685
									],
									[
										176900,
										176904
									],
									[
										176938,
										176942
									],
									[
										177041,
										177045
									],
									[
										177293,
										177297
									],
									[
										177518,
										177522
									],
									[
										177721,
										177725
									],
									[
										178239,
										178243
									],
									[
										178395,
										178399
									],
									[
										178454,
										178458
									],
									[
										178483,
										178487
									],
									[
										178647,
										178651
									],
									[
										178983,
										178987
									],
									[
										179277,
										179281
									],
									[
										179574,
										179578
									],
									[
										179876,
										179880
									],
									[
										180165,
										180169
									],
									[
										180437,
										180441
									],
									[
										180712,
										180716
									],
									[
										180972,
										180976
									],
									[
										181181,
										181185
									],
									[
										181453,
										181457
									],
									[
										181735,
										181739
									],
									[
										181992,
										181996
									],
									[
										182262,
										182266
									],
									[
										182554,
										182558
									],
									[
										182834,
										182838
									],
									[
										183090,
										183094
									],
									[
										183382,
										183386
									],
									[
										183662,
										183666
									],
									[
										183924,
										183928
									],
									[
										184226,
										184230
									],
									[
										184512,
										184516
									],
									[
										184825,
										184829
									],
									[
										185082,
										185086
									],
									[
										185116,
										185120
									],
									[
										185422,
										185426
									],
									[
										185655,
										185659
									],
									[
										185728,
										185732
									],
									[
										185750,
										185754
									],
									[
										185960,
										185964
									],
									[
										186266,
										186270
									],
									[
										186543,
										186547
									],
									[
										186818,
										186822
									],
									[
										187047,
										187051
									],
									[
										187367,
										187371
									],
									[
										187608,
										187612
									],
									[
										187879,
										187883
									],
									[
										188112,
										188116
									],
									[
										188341,
										188345
									],
									[
										188570,
										188574
									],
									[
										188752,
										188756
									],
									[
										189019,
										189023
									],
									[
										189280,
										189284
									],
									[
										189565,
										189569
									],
									[
										189707,
										189711
									],
									[
										189893,
										189897
									],
									[
										190116,
										190120
									],
									[
										190267,
										190271
									],
									[
										190604,
										190608
									],
									[
										190832,
										190836
									],
									[
										191026,
										191030
									],
									[
										191403,
										191407
									],
									[
										191549,
										191553
									],
									[
										191832,
										191836
									],
									[
										192115,
										192119
									],
									[
										192398,
										192402
									],
									[
										192681,
										192685
									],
									[
										192815,
										192819
									],
									[
										193097,
										193101
									],
									[
										193379,
										193383
									],
									[
										193661,
										193665
									],
									[
										193955,
										193959
									],
									[
										194097,
										194101
									],
									[
										194369,
										194373
									],
									[
										194641,
										194645
									],
									[
										194913,
										194917
									],
									[
										195322,
										195326
									],
									[
										195597,
										195601
									],
									[
										195785,
										195789
									],
									[
										195959,
										195963
									],
									[
										196117,
										196121
									],
									[
										196261,
										196265
									],
									[
										196438,
										196442
									],
									[
										196686,
										196690
									],
									[
										196971,
										196975
									],
									[
										197159,
										197163
									],
									[
										197346,
										197350
									],
									[
										197529,
										197533
									],
									[
										197702,
										197706
									],
									[
										197855,
										197859
									],
									[
										198020,
										198024
									],
									[
										198173,
										198177
									],
									[
										198340,
										198344
									],
									[
										198599,
										198603
									],
									[
										198834,
										198838
									],
									[
										199114,
										199118
									],
									[
										199341,
										199345
									],
									[
										199612,
										199616
									],
									[
										199859,
										199863
									],
									[
										200143,
										200147
									],
									[
										200390,
										200394
									],
									[
										200678,
										200682
									],
									[
										201007,
										201011
									],
									[
										201262,
										201266
									],
									[
										201474,
										201478
									],
									[
										201715,
										201719
									],
									[
										201946,
										201950
									],
									[
										202249,
										202253
									],
									[
										202476,
										202480
									],
									[
										202667,
										202671
									],
									[
										202852,
										202856
									],
									[
										203072,
										203076
									],
									[
										203284,
										203288
									],
									[
										203500,
										203504
									],
									[
										203720,
										203724
									],
									[
										203932,
										203936
									],
									[
										204150,
										204154
									],
									[
										204407,
										204411
									],
									[
										204654,
										204658
									],
									[
										204904,
										204908
									],
									[
										205163,
										205167
									],
									[
										205391,
										205395
									],
									[
										205723,
										205727
									],
									[
										205764,
										205768
									],
									[
										206027,
										206031
									],
									[
										206209,
										206213
									],
									[
										206418,
										206422
									],
									[
										206594,
										206598
									],
									[
										206760,
										206764
									],
									[
										206927,
										206931
									],
									[
										207102,
										207106
									],
									[
										207339,
										207343
									],
									[
										207544,
										207548
									],
									[
										207768,
										207772
									],
									[
										207994,
										207998
									],
									[
										208059,
										208063
									],
									[
										208124,
										208128
									],
									[
										208189,
										208193
									],
									[
										208254,
										208258
									],
									[
										208319,
										208323
									],
									[
										208435,
										208439
									],
									[
										208459,
										208463
									],
									[
										208483,
										208487
									],
									[
										208521,
										208525
									],
									[
										208545,
										208549
									],
									[
										208569,
										208573
									],
									[
										208607,
										208611
									],
									[
										208631,
										208635
									],
									[
										208655,
										208659
									],
									[
										208693,
										208697
									],
									[
										208717,
										208721
									],
									[
										208741,
										208745
									],
									[
										208871,
										208875
									],
									[
										209061,
										209065
									],
									[
										209249,
										209253
									],
									[
										209419,
										209423
									],
									[
										209585,
										209589
									],
									[
										209751,
										209755
									],
									[
										209918,
										209922
									],
									[
										210086,
										210090
									],
									[
										210277,
										210281
									],
									[
										210453,
										210457
									],
									[
										210621,
										210625
									],
									[
										210789,
										210793
									],
									[
										210957,
										210961
									],
									[
										211126,
										211130
									],
									[
										211296,
										211300
									],
									[
										211466,
										211470
									],
									[
										211693,
										211697
									],
									[
										211937,
										211941
									],
									[
										212212,
										212216
									],
									[
										212497,
										212501
									],
									[
										212689,
										212693
									],
									[
										212820,
										212824
									],
									[
										213063,
										213067
									],
									[
										213255,
										213259
									],
									[
										213386,
										213390
									],
									[
										213629,
										213633
									],
									[
										213821,
										213825
									],
									[
										213952,
										213956
									],
									[
										214195,
										214199
									],
									[
										214387,
										214391
									],
									[
										214518,
										214522
									],
									[
										214761,
										214765
									],
									[
										214953,
										214957
									],
									[
										215084,
										215088
									],
									[
										215327,
										215331
									],
									[
										215519,
										215523
									],
									[
										215650,
										215654
									],
									[
										215893,
										215897
									],
									[
										216085,
										216089
									],
									[
										216216,
										216220
									],
									[
										216459,
										216463
									],
									[
										216651,
										216655
									],
									[
										216782,
										216786
									],
									[
										217025,
										217029
									],
									[
										217217,
										217221
									],
									[
										217477,
										217481
									],
									[
										217702,
										217706
									],
									[
										217927,
										217931
									],
									[
										218152,
										218156
									],
									[
										218385,
										218389
									],
									[
										218610,
										218614
									],
									[
										218835,
										218839
									],
									[
										219060,
										219064
									],
									[
										219293,
										219297
									],
									[
										219518,
										219522
									],
									[
										219744,
										219748
									],
									[
										219970,
										219974
									],
									[
										220204,
										220208
									],
									[
										220430,
										220434
									],
									[
										220656,
										220660
									],
									[
										220882,
										220886
									],
									[
										221188,
										221192
									],
									[
										221413,
										221417
									],
									[
										221638,
										221642
									],
									[
										221863,
										221867
									],
									[
										222159,
										222163
									],
									[
										222400,
										222404
									],
									[
										222586,
										222590
									],
									[
										222776,
										222780
									],
									[
										223011,
										223015
									],
									[
										223219,
										223223
									],
									[
										223355,
										223359
									],
									[
										223471,
										223475
									],
									[
										223673,
										223677
									],
									[
										223742,
										223746
									],
									[
										223802,
										223806
									],
									[
										224046,
										224050
									],
									[
										224296,
										224300
									],
									[
										224485,
										224489
									],
									[
										224599,
										224603
									],
									[
										224611,
										224615
									],
									[
										224711,
										224715
									],
									[
										224952,
										224956
									],
									[
										225193,
										225197
									],
									[
										225442,
										225446
									],
									[
										225638,
										225642
									],
									[
										225837,
										225841
									],
									[
										225932,
										225936
									],
									[
										226068,
										226072
									],
									[
										226179,
										226183
									],
									[
										226191,
										226195
									],
									[
										226414,
										226418
									],
									[
										226664,
										226668
									],
									[
										226853,
										226857
									],
									[
										227024,
										227028
									],
									[
										227249,
										227253
									],
									[
										227510,
										227514
									],
									[
										227522,
										227526
									],
									[
										227622,
										227626
									],
									[
										227863,
										227867
									],
									[
										228112,
										228116
									],
									[
										228308,
										228312
									],
									[
										228532,
										228536
									],
									[
										228627,
										228631
									],
									[
										228763,
										228767
									],
									[
										228886,
										228890
									],
									[
										228997,
										229001
									],
									[
										229009,
										229013
									],
									[
										229232,
										229236
									],
									[
										229482,
										229486
									],
									[
										229671,
										229675
									],
									[
										229854,
										229858
									],
									[
										230079,
										230083
									],
									[
										230383,
										230387
									],
									[
										230395,
										230399
									],
									[
										230495,
										230499
									],
									[
										230743,
										230747
									],
									[
										231009,
										231013
									],
									[
										231257,
										231261
									],
									[
										231523,
										231527
									],
									[
										231772,
										231776
									],
									[
										231968,
										231972
									],
									[
										232198,
										232202
									],
									[
										232293,
										232297
									],
									[
										232429,
										232433
									],
									[
										232552,
										232556
									],
									[
										232663,
										232667
									],
									[
										232675,
										232679
									],
									[
										232898,
										232902
									],
									[
										233148,
										233152
									],
									[
										233337,
										233341
									],
									[
										233525,
										233529
									],
									[
										233750,
										233754
									],
									[
										234099,
										234103
									],
									[
										234111,
										234115
									],
									[
										234211,
										234215
									],
									[
										234477,
										234481
									],
									[
										234761,
										234765
									],
									[
										235045,
										235049
									],
									[
										235347,
										235351
									],
									[
										235613,
										235617
									],
									[
										235897,
										235901
									],
									[
										236181,
										236185
									],
									[
										236483,
										236487
									],
									[
										236749,
										236753
									],
									[
										237033,
										237037
									],
									[
										237317,
										237321
									],
									[
										237619,
										237623
									],
									[
										237868,
										237872
									],
									[
										238135,
										238139
									],
									[
										238384,
										238388
									],
									[
										238651,
										238655
									],
									[
										238926,
										238930
									],
									[
										239122,
										239126
									],
									[
										239360,
										239364
									],
									[
										239488,
										239492
									],
									[
										239624,
										239628
									],
									[
										239747,
										239751
									],
									[
										239858,
										239862
									],
									[
										239870,
										239874
									],
									[
										240233,
										240237
									],
									[
										240548,
										240552
									],
									[
										240867,
										240871
									],
									[
										241183,
										241187
									],
									[
										241499,
										241503
									],
									[
										241822,
										241826
									],
									[
										242023,
										242027
									],
									[
										242064,
										242068
									],
									[
										242115,
										242119
									],
									[
										242156,
										242160
									],
									[
										242207,
										242211
									],
									[
										242248,
										242252
									],
									[
										242299,
										242303
									],
									[
										242340,
										242344
									],
									[
										242399,
										242403
									],
									[
										242442,
										242446
									],
									[
										242495,
										242499
									],
									[
										242538,
										242542
									],
									[
										242591,
										242595
									],
									[
										242634,
										242638
									],
									[
										242687,
										242691
									],
									[
										242730,
										242734
									],
									[
										242791,
										242795
									],
									[
										242833,
										242837
									],
									[
										242885,
										242889
									],
									[
										242927,
										242931
									],
									[
										242979,
										242983
									],
									[
										243021,
										243025
									],
									[
										243073,
										243077
									],
									[
										243115,
										243119
									],
									[
										243175,
										243179
									],
									[
										243215,
										243219
									],
									[
										243265,
										243269
									],
									[
										243305,
										243309
									],
									[
										243355,
										243359
									],
									[
										243395,
										243399
									],
									[
										243445,
										243449
									],
									[
										243485,
										243489
									],
									[
										243543,
										243547
									],
									[
										243597,
										243601
									],
									[
										243638,
										243642
									],
									[
										243689,
										243693
									],
									[
										243730,
										243734
									],
									[
										243781,
										243785
									],
									[
										243822,
										243826
									],
									[
										243873,
										243877
									],
									[
										243914,
										243918
									],
									[
										244099,
										244103
									],
									[
										244297,
										244301
									],
									[
										244338,
										244342
									],
									[
										244589,
										244593
									],
									[
										244804,
										244808
									],
									[
										245139,
										245143
									],
									[
										245444,
										245448
									],
									[
										245487,
										245491
									],
									[
										245563,
										245567
									],
									[
										245821,
										245825
									],
									[
										245980,
										245984
									],
									[
										246188,
										246192
									],
									[
										246445,
										246449
									],
									[
										246718,
										246722
									],
									[
										246991,
										246995
									],
									[
										247246,
										247250
									],
									[
										247444,
										247448
									],
									[
										247678,
										247682
									],
									[
										247908,
										247912
									],
									[
										248203,
										248207
									],
									[
										248503,
										248507
									],
									[
										248541,
										248545
									],
									[
										248690,
										248694
									],
									[
										248926,
										248930
									],
									[
										249191,
										249195
									],
									[
										249378,
										249382
									],
									[
										249613,
										249617
									],
									[
										249651,
										249655
									],
									[
										249801,
										249805
									],
									[
										249839,
										249843
									],
									[
										249892,
										249896
									],
									[
										249913,
										249917
									],
									[
										249986,
										249990
									],
									[
										250038,
										250042
									],
									[
										250126,
										250130
									],
									[
										250308,
										250312
									],
									[
										250422,
										250426
									],
									[
										250483,
										250487
									],
									[
										250653,
										250657
									],
									[
										250701,
										250705
									],
									[
										250764,
										250768
									],
									[
										250795,
										250799
									],
									[
										250960,
										250964
									],
									[
										251175,
										251179
									],
									[
										251299,
										251303
									],
									[
										251369,
										251373
									],
									[
										251475,
										251479
									],
									[
										251584,
										251588
									],
									[
										251776,
										251780
									],
									[
										251886,
										251890
									],
									[
										251941,
										251945
									],
									[
										252098,
										252102
									],
									[
										252287,
										252291
									],
									[
										252407,
										252411
									],
									[
										252472,
										252476
									],
									[
										252649,
										252653
									],
									[
										252894,
										252898
									],
									[
										253073,
										253077
									],
									[
										253321,
										253325
									],
									[
										253497,
										253501
									],
									[
										253819,
										253823
									],
									[
										253929,
										253933
									],
									[
										253984,
										253988
									],
									[
										254141,
										254145
									],
									[
										254330,
										254334
									],
									[
										254450,
										254454
									],
									[
										254515,
										254519
									],
									[
										254692,
										254696
									],
									[
										254937,
										254941
									],
									[
										255116,
										255120
									],
									[
										255364,
										255368
									],
									[
										255540,
										255544
									],
									[
										255862,
										255866
									],
									[
										255972,
										255976
									],
									[
										256027,
										256031
									],
									[
										256184,
										256188
									],
									[
										256373,
										256377
									],
									[
										256493,
										256497
									],
									[
										256558,
										256562
									],
									[
										256735,
										256739
									],
									[
										256980,
										256984
									],
									[
										257159,
										257163
									],
									[
										257407,
										257411
									],
									[
										257583,
										257587
									],
									[
										257880,
										257884
									],
									[
										257919,
										257923
									],
									[
										257973,
										257977
									],
									[
										257995,
										257999
									],
									[
										258096,
										258100
									],
									[
										258154,
										258158
									],
									[
										258371,
										258375
									],
									[
										258486,
										258490
									],
									[
										258689,
										258693
									],
									[
										258977,
										258981
									],
									[
										259265,
										259269
									],
									[
										259553,
										259557
									],
									[
										259914,
										259918
									],
									[
										260264,
										260268
									],
									[
										260614,
										260618
									],
									[
										260964,
										260968
									],
									[
										261314,
										261318
									],
									[
										261664,
										261668
									],
									[
										262014,
										262018
									],
									[
										262364,
										262368
									],
									[
										262524,
										262528
									],
									[
										262646,
										262650
									],
									[
										262838,
										262842
									],
									[
										263059,
										263063
									],
									[
										263266,
										263270
									],
									[
										263487,
										263491
									],
									[
										263634,
										263638
									],
									[
										263674,
										263678
									],
									[
										263729,
										263733
									],
									[
										263752,
										263756
									],
									[
										263853,
										263857
									],
									[
										263924,
										263928
									],
									[
										264014,
										264018
									],
									[
										264070,
										264074
									],
									[
										264243,
										264247
									],
									[
										264357,
										264361
									],
									[
										264420,
										264424
									],
									[
										264626,
										264630
									],
									[
										264676,
										264680
									],
									[
										264741,
										264745
									],
									[
										264774,
										264778
									],
									[
										264941,
										264945
									],
									[
										265041,
										265045
									],
									[
										265204,
										265208
									],
									[
										265330,
										265334
									],
									[
										265402,
										265406
									],
									[
										265585,
										265589
									],
									[
										265774,
										265778
									],
									[
										266044,
										266048
									],
									[
										266156,
										266160
									],
									[
										266211,
										266215
									],
									[
										266400,
										266404
									],
									[
										266593,
										266597
									],
									[
										266715,
										266719
									],
									[
										266780,
										266784
									],
									[
										266974,
										266978
									],
									[
										267221,
										267225
									],
									[
										267417,
										267421
									],
									[
										267668,
										267672
									],
									[
										267861,
										267865
									],
									[
										268187,
										268191
									],
									[
										268299,
										268303
									],
									[
										268354,
										268358
									],
									[
										268543,
										268547
									],
									[
										268736,
										268740
									],
									[
										268858,
										268862
									],
									[
										268923,
										268927
									],
									[
										269176,
										269180
									],
									[
										269423,
										269427
									],
									[
										269678,
										269682
									],
									[
										269929,
										269933
									],
									[
										270181,
										270185
									],
									[
										270507,
										270511
									],
									[
										270619,
										270623
									],
									[
										270674,
										270678
									],
									[
										270863,
										270867
									],
									[
										271056,
										271060
									],
									[
										271178,
										271182
									],
									[
										271243,
										271247
									],
									[
										271496,
										271500
									],
									[
										271743,
										271747
									],
									[
										271998,
										272002
									],
									[
										272249,
										272253
									],
									[
										272501,
										272505
									],
									[
										272800,
										272804
									],
									[
										272839,
										272843
									],
									[
										272893,
										272897
									],
									[
										272915,
										272919
									],
									[
										273015,
										273019
									],
									[
										273086,
										273090
									],
									[
										273175,
										273179
									],
									[
										273230,
										273234
									],
									[
										273404,
										273408
									],
									[
										273519,
										273523
									],
									[
										273581,
										273585
									],
									[
										273784,
										273788
									],
									[
										273833,
										273837
									],
									[
										273897,
										273901
									],
									[
										273929,
										273933
									],
									[
										274092,
										274096
									],
									[
										274191,
										274195
									],
									[
										274364,
										274368
									],
									[
										274489,
										274493
									],
									[
										274560,
										274564
									],
									[
										274741,
										274745
									],
									[
										274928,
										274932
									],
									[
										275196,
										275200
									],
									[
										275307,
										275311
									],
									[
										275362,
										275366
									],
									[
										275551,
										275555
									],
									[
										275740,
										275744
									],
									[
										275861,
										275865
									],
									[
										275926,
										275930
									],
									[
										276120,
										276124
									],
									[
										276365,
										276369
									],
									[
										276561,
										276565
									],
									[
										276810,
										276814
									],
									[
										277003,
										277007
									],
									[
										277327,
										277331
									],
									[
										277438,
										277442
									],
									[
										277493,
										277497
									],
									[
										277682,
										277686
									],
									[
										277872,
										277876
									],
									[
										277993,
										277997
									],
									[
										278058,
										278062
									],
									[
										278252,
										278256
									],
									[
										278497,
										278501
									],
									[
										278693,
										278697
									],
									[
										278942,
										278946
									],
									[
										279135,
										279139
									],
									[
										279459,
										279463
									],
									[
										279570,
										279574
									],
									[
										279625,
										279629
									],
									[
										279814,
										279818
									],
									[
										280004,
										280008
									],
									[
										280125,
										280129
									],
									[
										280190,
										280194
									],
									[
										280384,
										280388
									],
									[
										280629,
										280633
									],
									[
										280825,
										280829
									],
									[
										281074,
										281078
									],
									[
										281267,
										281271
									],
									[
										281563,
										281567
									],
									[
										281600,
										281604
									],
									[
										281652,
										281656
									],
									[
										281672,
										281676
									],
									[
										281744,
										281748
									],
									[
										281796,
										281800
									],
									[
										281883,
										281887
									],
									[
										281927,
										281931
									],
									[
										282108,
										282112
									],
									[
										282221,
										282225
									],
									[
										282280,
										282284
									],
									[
										282464,
										282468
									],
									[
										282511,
										282515
									],
									[
										282573,
										282577
									],
									[
										282603,
										282607
									],
									[
										282767,
										282771
									],
									[
										282981,
										282985
									],
									[
										283104,
										283108
									],
									[
										283173,
										283177
									],
									[
										283288,
										283292
									],
									[
										283406,
										283410
									],
									[
										283606,
										283610
									],
									[
										283715,
										283719
									],
									[
										283770,
										283774
									],
									[
										283942,
										283946
									],
									[
										284129,
										284133
									],
									[
										284248,
										284252
									],
									[
										284313,
										284317
									],
									[
										284500,
										284504
									],
									[
										284744,
										284748
									],
									[
										284933,
										284937
									],
									[
										285180,
										285184
									],
									[
										285366,
										285370
									],
									[
										285686,
										285690
									],
									[
										285795,
										285799
									],
									[
										285850,
										285854
									],
									[
										286022,
										286026
									],
									[
										286209,
										286213
									],
									[
										286328,
										286332
									],
									[
										286393,
										286397
									],
									[
										286580,
										286584
									],
									[
										286824,
										286828
									],
									[
										287013,
										287017
									],
									[
										287260,
										287264
									],
									[
										287446,
										287450
									],
									[
										287766,
										287770
									],
									[
										287875,
										287879
									],
									[
										287930,
										287934
									],
									[
										288102,
										288106
									],
									[
										288289,
										288293
									],
									[
										288408,
										288412
									],
									[
										288473,
										288477
									],
									[
										288660,
										288664
									],
									[
										288904,
										288908
									],
									[
										289093,
										289097
									],
									[
										289340,
										289344
									],
									[
										289526,
										289530
									],
									[
										289826,
										289830
									],
									[
										289869,
										289873
									],
									[
										289927,
										289931
									],
									[
										289953,
										289957
									],
									[
										290050,
										290054
									],
									[
										290143,
										290147
									],
									[
										290237,
										290241
									],
									[
										290451,
										290455
									],
									[
										290570,
										290574
									],
									[
										290768,
										290772
									],
									[
										291041,
										291045
									],
									[
										291318,
										291322
									],
									[
										291595,
										291599
									],
									[
										291766,
										291770
									],
									[
										291888,
										291892
									],
									[
										292071,
										292075
									],
									[
										292109,
										292113
									],
									[
										292162,
										292166
									],
									[
										292183,
										292187
									],
									[
										292256,
										292260
									],
									[
										292308,
										292312
									],
									[
										292396,
										292400
									],
									[
										292439,
										292443
									],
									[
										292621,
										292625
									],
									[
										292735,
										292739
									],
									[
										292795,
										292799
									],
									[
										292991,
										292995
									],
									[
										293039,
										293043
									],
									[
										293102,
										293106
									],
									[
										293133,
										293137
									],
									[
										293298,
										293302
									],
									[
										293513,
										293517
									],
									[
										293637,
										293641
									],
									[
										293707,
										293711
									],
									[
										293775,
										293779
									],
									[
										293889,
										293893
									],
									[
										293957,
										293961
									],
									[
										294074,
										294078
									],
									[
										294142,
										294146
									],
									[
										294342,
										294346
									],
									[
										294452,
										294456
									],
									[
										294507,
										294511
									],
									[
										294681,
										294685
									],
									[
										294878,
										294882
									],
									[
										294998,
										295002
									],
									[
										295063,
										295067
									],
									[
										295252,
										295256
									],
									[
										295505,
										295509
									],
									[
										295696,
										295700
									],
									[
										295952,
										295956
									],
									[
										296140,
										296144
									],
									[
										296470,
										296474
									],
									[
										296580,
										296584
									],
									[
										296635,
										296639
									],
									[
										296809,
										296813
									],
									[
										297006,
										297010
									],
									[
										297126,
										297130
									],
									[
										297191,
										297195
									],
									[
										297380,
										297384
									],
									[
										297633,
										297637
									],
									[
										297824,
										297828
									],
									[
										298080,
										298084
									],
									[
										298268,
										298272
									],
									[
										298598,
										298602
									],
									[
										298708,
										298712
									],
									[
										298763,
										298767
									],
									[
										298937,
										298941
									],
									[
										299134,
										299138
									],
									[
										299254,
										299258
									],
									[
										299319,
										299323
									],
									[
										299508,
										299512
									],
									[
										299761,
										299765
									],
									[
										299952,
										299956
									],
									[
										300208,
										300212
									],
									[
										300396,
										300400
									],
									[
										300724,
										300728
									],
									[
										300863,
										300867
									],
									[
										301001,
										301005
									],
									[
										301140,
										301144
									],
									[
										301333,
										301337
									],
									[
										301344,
										301348
									],
									[
										301617,
										301621
									],
									[
										301873,
										301877
									],
									[
										302124,
										302128
									],
									[
										302319,
										302323
									],
									[
										302604,
										302608
									],
									[
										302852,
										302856
									],
									[
										303002,
										303006
									],
									[
										303223,
										303227
									],
									[
										303370,
										303374
									],
									[
										303491,
										303495
									],
									[
										303603,
										303607
									],
									[
										303775,
										303779
									],
									[
										303782,
										303786
									],
									[
										303817,
										303821
									],
									[
										303977,
										303981
									],
									[
										303994,
										303998
									],
									[
										304062,
										304066
									],
									[
										304319,
										304323
									],
									[
										304559,
										304563
									],
									[
										304784,
										304788
									],
									[
										305126,
										305130
									],
									[
										305467,
										305471
									],
									[
										305730,
										305734
									],
									[
										305993,
										305997
									],
									[
										306308,
										306312
									],
									[
										306478,
										306482
									],
									[
										306719,
										306723
									],
									[
										306783,
										306787
									],
									[
										306847,
										306851
									],
									[
										306911,
										306915
									],
									[
										306975,
										306979
									],
									[
										307039,
										307043
									],
									[
										307103,
										307107
									],
									[
										307167,
										307171
									],
									[
										307231,
										307235
									],
									[
										307295,
										307299
									],
									[
										307359,
										307363
									],
									[
										307423,
										307427
									],
									[
										307487,
										307491
									],
									[
										307551,
										307555
									],
									[
										307615,
										307619
									],
									[
										307679,
										307683
									],
									[
										307743,
										307747
									],
									[
										307807,
										307811
									],
									[
										307871,
										307875
									],
									[
										308004,
										308008
									],
									[
										308028,
										308032
									],
									[
										308052,
										308056
									],
									[
										308104,
										308108
									],
									[
										308128,
										308132
									],
									[
										308152,
										308156
									],
									[
										308204,
										308208
									],
									[
										308228,
										308232
									],
									[
										308252,
										308256
									],
									[
										308304,
										308308
									],
									[
										308328,
										308332
									],
									[
										308352,
										308356
									],
									[
										308412,
										308416
									],
									[
										308436,
										308440
									],
									[
										308460,
										308464
									],
									[
										308512,
										308516
									],
									[
										308536,
										308540
									],
									[
										308560,
										308564
									],
									[
										308612,
										308616
									],
									[
										308636,
										308640
									],
									[
										308660,
										308664
									],
									[
										308712,
										308716
									],
									[
										308736,
										308740
									],
									[
										308760,
										308764
									],
									[
										308820,
										308824
									],
									[
										308844,
										308848
									],
									[
										308868,
										308872
									],
									[
										308920,
										308924
									],
									[
										308944,
										308948
									],
									[
										308968,
										308972
									],
									[
										309020,
										309024
									],
									[
										309044,
										309048
									],
									[
										309068,
										309072
									],
									[
										309120,
										309124
									],
									[
										309144,
										309148
									],
									[
										309168,
										309172
									],
									[
										309228,
										309232
									],
									[
										309252,
										309256
									],
									[
										309276,
										309280
									],
									[
										309328,
										309332
									],
									[
										309352,
										309356
									],
									[
										309376,
										309380
									],
									[
										309428,
										309432
									],
									[
										309452,
										309456
									],
									[
										309476,
										309480
									],
									[
										309528,
										309532
									],
									[
										309552,
										309556
									],
									[
										309576,
										309580
									],
									[
										309766,
										309770
									],
									[
										310018,
										310022
									],
									[
										310413,
										310417
									],
									[
										310629,
										310633
									],
									[
										310908,
										310912
									],
									[
										311301,
										311305
									],
									[
										311532,
										311536
									],
									[
										311813,
										311817
									],
									[
										312205,
										312209
									],
									[
										312425,
										312429
									],
									[
										312706,
										312710
									],
									[
										313096,
										313100
									],
									[
										313330,
										313334
									],
									[
										313675,
										313679
									],
									[
										313881,
										313885
									],
									[
										314161,
										314165
									],
									[
										314471,
										314475
									],
									[
										314807,
										314811
									],
									[
										315014,
										315018
									],
									[
										315339,
										315343
									],
									[
										315687,
										315691
									],
									[
										315896,
										315900
									],
									[
										316223,
										316227
									],
									[
										316491,
										316495
									],
									[
										316879,
										316883
									],
									[
										317124,
										317128
									],
									[
										317391,
										317395
									],
									[
										317779,
										317783
									],
									[
										318021,
										318025
									],
									[
										318309,
										318313
									],
									[
										318758,
										318762
									],
									[
										318826,
										318830
									],
									[
										319114,
										319118
									],
									[
										319563,
										319567
									],
									[
										319631,
										319635
									],
									[
										319903,
										319907
									],
									[
										319968,
										319972
									],
									[
										320088,
										320092
									],
									[
										320365,
										320369
									],
									[
										320426,
										320430
									],
									[
										320558,
										320562
									],
									[
										320841,
										320845
									],
									[
										320906,
										320910
									],
									[
										321026,
										321030
									],
									[
										321310,
										321314
									],
									[
										321371,
										321375
									],
									[
										321503,
										321507
									],
									[
										321820,
										321824
									],
									[
										322064,
										322068
									],
									[
										322281,
										322285
									],
									[
										322522,
										322526
									],
									[
										322738,
										322742
									],
									[
										322955,
										322959
									],
									[
										323138,
										323142
									],
									[
										323356,
										323360
									],
									[
										323540,
										323544
									],
									[
										323766,
										323770
									],
									[
										323958,
										323962
									],
									[
										324180,
										324184
									],
									[
										324368,
										324372
									],
									[
										324589,
										324593
									],
									[
										324711,
										324715
									],
									[
										324915,
										324919
									],
									[
										325081,
										325085
									],
									[
										325287,
										325291
									],
									[
										325455,
										325459
									],
									[
										325659,
										325663
									],
									[
										325825,
										325829
									],
									[
										326031,
										326035
									],
									[
										326199,
										326203
									],
									[
										326403,
										326407
									],
									[
										326569,
										326573
									],
									[
										326775,
										326779
									],
									[
										326943,
										326947
									],
									[
										327149,
										327153
									],
									[
										327317,
										327321
									],
									[
										327525,
										327529
									],
									[
										327695,
										327699
									],
									[
										327901,
										327905
									],
									[
										328069,
										328073
									],
									[
										328277,
										328281
									],
									[
										328466,
										328470
									],
									[
										328654,
										328658
									],
									[
										328879,
										328883
									],
									[
										329004,
										329008
									],
									[
										329138,
										329142
									],
									[
										329263,
										329267
									],
									[
										329431,
										329435
									],
									[
										329563,
										329567
									],
									[
										329738,
										329742
									],
									[
										329866,
										329870
									],
									[
										330063,
										330067
									],
									[
										330190,
										330194
									],
									[
										330362,
										330366
									],
									[
										330561,
										330565
									],
									[
										330800,
										330804
									],
									[
										331101,
										331105
									],
									[
										331404,
										331408
									],
									[
										331724,
										331728
									],
									[
										331957,
										331961
									],
									[
										332191,
										332195
									],
									[
										332434,
										332438
									],
									[
										332772,
										332776
									],
									[
										333024,
										333028
									],
									[
										333201,
										333205
									],
									[
										333376,
										333380
									],
									[
										333563,
										333567
									],
									[
										333750,
										333754
									],
									[
										333937,
										333941
									],
									[
										334106,
										334110
									],
									[
										334277,
										334281
									],
									[
										334449,
										334453
									],
									[
										334636,
										334640
									],
									[
										334823,
										334827
									],
									[
										335010,
										335014
									],
									[
										335273,
										335277
									],
									[
										335478,
										335482
									],
									[
										335683,
										335687
									],
									[
										335889,
										335893
									],
									[
										336096,
										336100
									],
									[
										336303,
										336307
									],
									[
										336510,
										336514
									],
									[
										336717,
										336721
									],
									[
										336924,
										336928
									],
									[
										337132,
										337136
									],
									[
										337341,
										337345
									],
									[
										337550,
										337554
									],
									[
										337793,
										337797
									],
									[
										337828,
										337832
									],
									[
										338078,
										338082
									],
									[
										338341,
										338345
									],
									[
										338606,
										338610
									],
									[
										338918,
										338922
									],
									[
										339209,
										339213
									],
									[
										339500,
										339504
									],
									[
										339744,
										339748
									],
									[
										339990,
										339994
									],
									[
										340233,
										340237
									],
									[
										340478,
										340482
									],
									[
										340721,
										340725
									],
									[
										340966,
										340970
									],
									[
										341340,
										341344
									],
									[
										341614,
										341618
									],
									[
										341788,
										341792
									],
									[
										341978,
										341982
									],
									[
										342200,
										342204
									],
									[
										342432,
										342436
									],
									[
										342665,
										342669
									],
									[
										342979,
										342983
									],
									[
										343095,
										343099
									],
									[
										343309,
										343313
									],
									[
										343529,
										343533
									],
									[
										343741,
										343745
									],
									[
										343957,
										343961
									],
									[
										344179,
										344183
									],
									[
										344392,
										344396
									],
									[
										344541,
										344545
									],
									[
										344693,
										344697
									],
									[
										344840,
										344844
									],
									[
										344992,
										344996
									],
									[
										345147,
										345151
									],
									[
										345297,
										345301
									],
									[
										345436,
										345440
									],
									[
										345578,
										345582
									],
									[
										345715,
										345719
									],
									[
										345935,
										345939
									],
									[
										346160,
										346164
									],
									[
										346377,
										346381
									],
									[
										346598,
										346602
									],
									[
										346825,
										346829
									],
									[
										347044,
										347048
									],
									[
										347198,
										347202
									],
									[
										347356,
										347360
									],
									[
										347508,
										347512
									],
									[
										347665,
										347669
									],
									[
										347825,
										347829
									],
									[
										347980,
										347984
									],
									[
										348124,
										348128
									],
									[
										348271,
										348275
									],
									[
										348445,
										348449
									],
									[
										348660,
										348664
									],
									[
										348881,
										348885
									],
									[
										349094,
										349098
									],
									[
										349311,
										349315
									],
									[
										349534,
										349538
									],
									[
										349748,
										349752
									],
									[
										349898,
										349902
									],
									[
										350051,
										350055
									],
									[
										350199,
										350203
									],
									[
										350352,
										350356
									],
									[
										350508,
										350512
									],
									[
										350659,
										350663
									],
									[
										350799,
										350803
									],
									[
										350942,
										350946
									],
									[
										351080,
										351084
									],
									[
										351301,
										351305
									],
									[
										351527,
										351531
									],
									[
										351745,
										351749
									],
									[
										351967,
										351971
									],
									[
										352195,
										352199
									],
									[
										352415,
										352419
									],
									[
										352570,
										352574
									],
									[
										352729,
										352733
									],
									[
										352882,
										352886
									],
									[
										353040,
										353044
									],
									[
										353201,
										353205
									],
									[
										353357,
										353361
									],
									[
										353502,
										353506
									],
									[
										353650,
										353654
									],
									[
										353824,
										353828
									],
									[
										354039,
										354043
									],
									[
										354260,
										354264
									],
									[
										354473,
										354477
									],
									[
										354690,
										354694
									],
									[
										354913,
										354917
									],
									[
										355127,
										355131
									],
									[
										355277,
										355281
									],
									[
										355430,
										355434
									],
									[
										355578,
										355582
									],
									[
										355731,
										355735
									],
									[
										355887,
										355891
									],
									[
										356038,
										356042
									],
									[
										356178,
										356182
									],
									[
										356321,
										356325
									],
									[
										356459,
										356463
									],
									[
										356680,
										356684
									],
									[
										356906,
										356910
									],
									[
										357124,
										357128
									],
									[
										357346,
										357350
									],
									[
										357574,
										357578
									],
									[
										357794,
										357798
									],
									[
										357949,
										357953
									],
									[
										358108,
										358112
									],
									[
										358261,
										358265
									],
									[
										358419,
										358423
									],
									[
										358580,
										358584
									],
									[
										358736,
										358740
									],
									[
										358881,
										358885
									],
									[
										359029,
										359033
									],
									[
										359203,
										359207
									],
									[
										359418,
										359422
									],
									[
										359639,
										359643
									],
									[
										359852,
										359856
									],
									[
										360069,
										360073
									],
									[
										360292,
										360296
									],
									[
										360506,
										360510
									],
									[
										360656,
										360660
									],
									[
										360809,
										360813
									],
									[
										360957,
										360961
									],
									[
										361110,
										361114
									],
									[
										361266,
										361270
									],
									[
										361417,
										361421
									],
									[
										361557,
										361561
									],
									[
										361700,
										361704
									],
									[
										361838,
										361842
									],
									[
										362059,
										362063
									],
									[
										362285,
										362289
									],
									[
										362503,
										362507
									],
									[
										362725,
										362729
									],
									[
										362953,
										362957
									],
									[
										363173,
										363177
									],
									[
										363328,
										363332
									],
									[
										363487,
										363491
									],
									[
										363640,
										363644
									],
									[
										363798,
										363802
									],
									[
										363959,
										363963
									],
									[
										364115,
										364119
									],
									[
										364260,
										364264
									],
									[
										364408,
										364412
									],
									[
										364660,
										364664
									],
									[
										364813,
										364817
									],
									[
										364966,
										364970
									],
									[
										365119,
										365123
									],
									[
										365272,
										365276
									],
									[
										365430,
										365434
									],
									[
										365588,
										365592
									],
									[
										365746,
										365750
									],
									[
										366016,
										366020
									],
									[
										366171,
										366175
									],
									[
										366326,
										366330
									],
									[
										366481,
										366485
									],
									[
										366635,
										366639
									],
									[
										366795,
										366799
									],
									[
										366955,
										366959
									],
									[
										367115,
										367119
									],
									[
										367382,
										367386
									],
									[
										367520,
										367524
									],
									[
										367658,
										367662
									],
									[
										367796,
										367800
									],
									[
										367933,
										367937
									],
									[
										368076,
										368080
									],
									[
										368219,
										368223
									],
									[
										368362,
										368366
									],
									[
										368634,
										368638
									],
									[
										368774,
										368778
									],
									[
										368914,
										368918
									],
									[
										369054,
										369058
									],
									[
										369193,
										369197
									],
									[
										369338,
										369342
									],
									[
										369483,
										369487
									],
									[
										369628,
										369632
									],
									[
										369902,
										369906
									],
									[
										370029,
										370033
									],
									[
										370156,
										370160
									],
									[
										370283,
										370287
									],
									[
										370410,
										370414
									],
									[
										370542,
										370546
									],
									[
										370674,
										370678
									],
									[
										370806,
										370810
									],
									[
										371069,
										371073
									],
									[
										371240,
										371244
									],
									[
										371406,
										371410
									],
									[
										371572,
										371576
									],
									[
										371799,
										371803
									],
									[
										371974,
										371978
									],
									[
										372149,
										372153
									],
									[
										372376,
										372380
									],
									[
										372545,
										372549
									],
									[
										372714,
										372718
									],
									[
										372919,
										372923
									],
									[
										373070,
										373074
									],
									[
										373221,
										373225
									],
									[
										373442,
										373446
									],
									[
										373612,
										373616
									],
									[
										373782,
										373786
									],
									[
										374016,
										374020
									],
									[
										374195,
										374199
									],
									[
										374374,
										374378
									],
									[
										374608,
										374612
									],
									[
										374781,
										374785
									],
									[
										374954,
										374958
									],
									[
										375165,
										375169
									],
									[
										375319,
										375323
									],
									[
										375473,
										375477
									],
									[
										375696,
										375700
									],
									[
										375866,
										375870
									],
									[
										376036,
										376040
									],
									[
										376270,
										376274
									],
									[
										376449,
										376453
									],
									[
										376628,
										376632
									],
									[
										376862,
										376866
									],
									[
										377035,
										377039
									],
									[
										377208,
										377212
									],
									[
										377419,
										377423
									],
									[
										377573,
										377577
									],
									[
										377727,
										377731
									],
									[
										377950,
										377954
									],
									[
										378120,
										378124
									],
									[
										378290,
										378294
									],
									[
										378524,
										378528
									],
									[
										378703,
										378707
									],
									[
										378882,
										378886
									],
									[
										379116,
										379120
									],
									[
										379289,
										379293
									],
									[
										379462,
										379466
									],
									[
										379673,
										379677
									],
									[
										379827,
										379831
									],
									[
										379981,
										379985
									],
									[
										380169,
										380173
									],
									[
										380307,
										380311
									],
									[
										380461,
										380465
									],
									[
										380624,
										380628
									],
									[
										380788,
										380792
									],
									[
										380952,
										380956
									],
									[
										381127,
										381131
									],
									[
										381299,
										381303
									],
									[
										381472,
										381476
									],
									[
										381645,
										381649
									],
									[
										381824,
										381828
									],
									[
										381990,
										381994
									],
									[
										382153,
										382157
									],
									[
										382316,
										382320
									],
									[
										382486,
										382490
									],
									[
										382649,
										382653
									],
									[
										382809,
										382813
									],
									[
										382969,
										382973
									],
									[
										383132,
										383136
									],
									[
										383304,
										383308
									],
									[
										383473,
										383477
									],
									[
										383642,
										383646
									],
									[
										383809,
										383813
									],
									[
										383975,
										383979
									],
									[
										384142,
										384146
									],
									[
										384309,
										384313
									],
									[
										384483,
										384487
									],
									[
										384646,
										384650
									],
									[
										384810,
										384814
									],
									[
										384974,
										384978
									],
									[
										385141,
										385145
									],
									[
										385313,
										385317
									],
									[
										385486,
										385490
									],
									[
										385659,
										385663
									],
									[
										385830,
										385834
									],
									[
										385996,
										386000
									],
									[
										386163,
										386167
									],
									[
										386330,
										386334
									],
									[
										386549,
										386553
									],
									[
										386717,
										386721
									],
									[
										386885,
										386889
									],
									[
										387114,
										387118
									],
									[
										387291,
										387295
									],
									[
										387468,
										387472
									],
									[
										387697,
										387701
									],
									[
										387868,
										387872
									],
									[
										388039,
										388043
									],
									[
										388264,
										388268
									],
									[
										388435,
										388439
									],
									[
										388606,
										388610
									],
									[
										388829,
										388833
									],
									[
										389001,
										389005
									],
									[
										389173,
										389177
									],
									[
										389409,
										389413
									],
									[
										389590,
										389594
									],
									[
										389771,
										389775
									],
									[
										390007,
										390011
									],
									[
										390182,
										390186
									],
									[
										390357,
										390361
									],
									[
										390588,
										390592
									],
									[
										390762,
										390766
									],
									[
										390936,
										390940
									],
									[
										391161,
										391165
									],
									[
										391333,
										391337
									],
									[
										391505,
										391509
									],
									[
										391741,
										391745
									],
									[
										391922,
										391926
									],
									[
										392103,
										392107
									],
									[
										392339,
										392343
									],
									[
										392514,
										392518
									],
									[
										392689,
										392693
									],
									[
										392920,
										392924
									],
									[
										393094,
										393098
									],
									[
										393268,
										393272
									],
									[
										393493,
										393497
									],
									[
										393665,
										393669
									],
									[
										393837,
										393841
									],
									[
										394073,
										394077
									],
									[
										394254,
										394258
									],
									[
										394435,
										394439
									],
									[
										394671,
										394675
									],
									[
										394846,
										394850
									],
									[
										395021,
										395025
									],
									[
										395252,
										395256
									],
									[
										395426,
										395430
									],
									[
										395600,
										395604
									],
									[
										395774,
										395778
									],
									[
										395950,
										395954
									],
									[
										396108,
										396112
									],
									[
										396267,
										396271
									],
									[
										396426,
										396430
									],
									[
										396593,
										396597
									],
									[
										396751,
										396755
									],
									[
										396910,
										396914
									],
									[
										397069,
										397073
									],
									[
										397267,
										397271
									],
									[
										397428,
										397432
									],
									[
										397590,
										397594
									],
									[
										397752,
										397756
									],
									[
										398071,
										398075
									],
									[
										398271,
										398275
									],
									[
										398386,
										398390
									],
									[
										398628,
										398632
									],
									[
										398821,
										398825
									],
									[
										399014,
										399018
									],
									[
										399207,
										399211
									],
									[
										399400,
										399404
									],
									[
										399593,
										399597
									],
									[
										399786,
										399790
									],
									[
										399979,
										399983
									],
									[
										400172,
										400176
									],
									[
										400365,
										400369
									],
									[
										400558,
										400562
									],
									[
										400751,
										400755
									],
									[
										400944,
										400948
									],
									[
										401137,
										401141
									],
									[
										401330,
										401334
									],
									[
										401523,
										401527
									],
									[
										401716,
										401720
									],
									[
										401900,
										401904
									],
									[
										402084,
										402088
									],
									[
										402309,
										402313
									],
									[
										402552,
										402556
									],
									[
										402740,
										402744
									],
									[
										402782,
										402786
									],
									[
										402834,
										402838
									],
									[
										402877,
										402881
									],
									[
										402930,
										402934
									],
									[
										402974,
										402978
									],
									[
										403028,
										403032
									],
									[
										403069,
										403073
									],
									[
										403120,
										403124
									],
									[
										403162,
										403166
									],
									[
										403437,
										403441
									],
									[
										403626,
										403630
									],
									[
										403815,
										403819
									],
									[
										404005,
										404009
									],
									[
										404197,
										404201
									],
									[
										404408,
										404412
									],
									[
										404516,
										404520
									],
									[
										404602,
										404606
									],
									[
										404752,
										404756
									],
									[
										404860,
										404864
									],
									[
										404946,
										404950
									],
									[
										405120,
										405124
									],
									[
										405206,
										405210
									],
									[
										405227,
										405231
									],
									[
										405419,
										405423
									],
									[
										405665,
										405669
									],
									[
										405903,
										405907
									],
									[
										406130,
										406134
									],
									[
										406279,
										406283
									],
									[
										406516,
										406520
									],
									[
										406745,
										406749
									],
									[
										406894,
										406898
									],
									[
										407292,
										407296
									],
									[
										408415,
										408419
									],
									[
										408791,
										408795
									],
									[
										409167,
										409171
									],
									[
										410051,
										410055
									],
									[
										410273,
										410277
									],
									[
										410495,
										410499
									],
									[
										410717,
										410721
									],
									[
										410939,
										410943
									],
									[
										411336,
										411340
									],
									[
										411465,
										411469
									],
									[
										411595,
										411599
									],
									[
										411725,
										411729
									],
									[
										412151,
										412155
									],
									[
										412307,
										412311
									],
									[
										412464,
										412468
									],
									[
										412621,
										412625
									],
									[
										413101,
										413105
									],
									[
										413258,
										413262
									],
									[
										413416,
										413420
									],
									[
										413574,
										413578
									],
									[
										413917,
										413921
									],
									[
										413946,
										413950
									],
									[
										414231,
										414235
									],
									[
										414252,
										414256
									],
									[
										414514,
										414518
									],
									[
										414724,
										414728
									],
									[
										414959,
										414963
									],
									[
										415185,
										415189
									],
									[
										415460,
										415464
									],
									[
										415664,
										415668
									],
									[
										415893,
										415897
									],
									[
										416076,
										416080
									],
									[
										416212,
										416216
									],
									[
										416328,
										416332
									],
									[
										416674,
										416678
									],
									[
										416948,
										416952
									],
									[
										417237,
										417241
									],
									[
										417562,
										417566
									],
									[
										417928,
										417932
									],
									[
										418211,
										418215
									],
									[
										418416,
										418420
									],
									[
										418589,
										418593
									],
									[
										418794,
										418798
									],
									[
										419029,
										419033
									],
									[
										419203,
										419207
									],
									[
										419378,
										419382
									],
									[
										419554,
										419558
									],
									[
										419810,
										419814
									],
									[
										420050,
										420054
									],
									[
										420245,
										420249
									],
									[
										420421,
										420425
									],
									[
										420595,
										420599
									],
									[
										420769,
										420773
									],
									[
										420944,
										420948
									],
									[
										421120,
										421124
									],
									[
										421319,
										421323
									],
									[
										421495,
										421499
									],
									[
										421802,
										421806
									],
									[
										422025,
										422029
									],
									[
										422186,
										422190
									],
									[
										422347,
										422351
									],
									[
										422451,
										422455
									],
									[
										422612,
										422616
									],
									[
										422705,
										422709
									],
									[
										422731,
										422735
									],
									[
										422848,
										422852
									],
									[
										422941,
										422945
									],
									[
										422967,
										422971
									],
									[
										422993,
										422997
									],
									[
										423110,
										423114
									],
									[
										423203,
										423207
									],
									[
										423229,
										423233
									],
									[
										423255,
										423259
									],
									[
										423281,
										423285
									],
									[
										423481,
										423485
									],
									[
										423659,
										423663
									],
									[
										423863,
										423867
									],
									[
										424185,
										424189
									],
									[
										424492,
										424496
									],
									[
										424697,
										424701
									],
									[
										424902,
										424906
									],
									[
										425107,
										425111
									],
									[
										425312,
										425316
									],
									[
										425551,
										425555
									],
									[
										425747,
										425751
									],
									[
										425947,
										425951
									],
									[
										426139,
										426143
									],
									[
										426498,
										426502
									],
									[
										426719,
										426723
									],
									[
										426765,
										426769
									],
									[
										426871,
										426875
									],
									[
										426900,
										426904
									],
									[
										426984,
										426988
									],
									[
										427077,
										427081
									],
									[
										427227,
										427231
									],
									[
										427523,
										427527
									],
									[
										427766,
										427770
									],
									[
										427919,
										427923
									],
									[
										428047,
										428051
									],
									[
										428315,
										428319
									],
									[
										428512,
										428516
									],
									[
										428881,
										428885
									],
									[
										429141,
										429145
									],
									[
										429396,
										429400
									],
									[
										429672,
										429676
									],
									[
										429947,
										429951
									],
									[
										430075,
										430079
									],
									[
										430261,
										430265
									],
									[
										430465,
										430469
									],
									[
										430669,
										430673
									],
									[
										430879,
										430883
									],
									[
										431089,
										431093
									],
									[
										431299,
										431303
									],
									[
										431617,
										431621
									],
									[
										431785,
										431789
									],
									[
										431962,
										431966
									],
									[
										432170,
										432174
									],
									[
										432329,
										432333
									],
									[
										432521,
										432525
									],
									[
										432674,
										432678
									],
									[
										432892,
										432896
									],
									[
										433111,
										433115
									],
									[
										433406,
										433410
									],
									[
										433510,
										433514
									],
									[
										433818,
										433822
									],
									[
										434051,
										434055
									],
									[
										434281,
										434285
									],
									[
										434409,
										434413
									],
									[
										434752,
										434756
									],
									[
										434987,
										434991
									],
									[
										435219,
										435223
									],
									[
										435364,
										435368
									],
									[
										435514,
										435518
									],
									[
										435664,
										435668
									],
									[
										435813,
										435817
									],
									[
										435845,
										435849
									],
									[
										435899,
										435903
									],
									[
										436138,
										436142
									],
									[
										436481,
										436485
									],
									[
										436830,
										436834
									],
									[
										437038,
										437042
									],
									[
										437237,
										437241
									],
									[
										437276,
										437280
									],
									[
										437418,
										437422
									],
									[
										437440,
										437444
									],
									[
										437517,
										437521
									],
									[
										437620,
										437624
									],
									[
										437761,
										437765
									],
									[
										437896,
										437900
									],
									[
										438185,
										438189
									],
									[
										438300,
										438304
									],
									[
										438386,
										438390
									],
									[
										438435,
										438439
									],
									[
										438472,
										438476
									],
									[
										438514,
										438518
									],
									[
										438616,
										438620
									],
									[
										438780,
										438784
									],
									[
										438820,
										438824
									],
									[
										439002,
										439006
									],
									[
										439057,
										439061
									],
									[
										439250,
										439254
									],
									[
										439305,
										439309
									],
									[
										439499,
										439503
									],
									[
										439557,
										439561
									],
									[
										439740,
										439744
									],
									[
										439798,
										439802
									],
									[
										439981,
										439985
									],
									[
										440039,
										440043
									],
									[
										440221,
										440225
									],
									[
										440279,
										440283
									],
									[
										440461,
										440465
									],
									[
										440519,
										440523
									],
									[
										440701,
										440705
									],
									[
										440759,
										440763
									],
									[
										440962,
										440966
									],
									[
										441002,
										441006
									],
									[
										441175,
										441179
									],
									[
										441289,
										441293
									],
									[
										441391,
										441395
									],
									[
										441547,
										441551
									],
									[
										441752,
										441756
									],
									[
										441985,
										441989
									],
									[
										442093,
										442097
									],
									[
										442255,
										442259
									],
									[
										442418,
										442422
									],
									[
										442583,
										442587
									],
									[
										442747,
										442751
									],
									[
										442911,
										442915
									],
									[
										443076,
										443080
									],
									[
										443243,
										443247
									],
									[
										443516,
										443520
									],
									[
										443856,
										443860
									],
									[
										444156,
										444160
									],
									[
										444507,
										444511
									],
									[
										444569,
										444573
									],
									[
										444780,
										444784
									],
									[
										444970,
										444974
									],
									[
										445155,
										445159
									],
									[
										445341,
										445345
									],
									[
										445588,
										445592
									],
									[
										445774,
										445778
									],
									[
										445960,
										445964
									],
									[
										446211,
										446215
									],
									[
										446400,
										446404
									],
									[
										446589,
										446593
									],
									[
										446842,
										446846
									],
									[
										447031,
										447035
									],
									[
										447221,
										447225
									],
									[
										447475,
										447479
									],
									[
										447665,
										447669
									],
									[
										447855,
										447859
									],
									[
										448053,
										448057
									],
									[
										448274,
										448278
									],
									[
										448461,
										448465
									],
									[
										448649,
										448653
									],
									[
										448898,
										448902
									],
									[
										449086,
										449090
									],
									[
										449274,
										449278
									],
									[
										449527,
										449531
									],
									[
										449718,
										449722
									],
									[
										449909,
										449913
									],
									[
										450164,
										450168
									],
									[
										450355,
										450359
									],
									[
										450547,
										450551
									],
									[
										450803,
										450807
									],
									[
										450995,
										450999
									],
									[
										451187,
										451191
									],
									[
										451371,
										451375
									],
									[
										451533,
										451537
									],
									[
										451702,
										451706
									],
									[
										451872,
										451876
									],
									[
										452043,
										452047
									],
									[
										452222,
										452226
									],
									[
										452393,
										452397
									],
									[
										452565,
										452569
									],
									[
										452738,
										452742
									],
									[
										452919,
										452923
									],
									[
										453094,
										453098
									],
									[
										453270,
										453274
									],
									[
										453447,
										453451
									],
									[
										453632,
										453636
									],
									[
										453803,
										453807
									],
									[
										453976,
										453980
									],
									[
										454149,
										454153
									],
									[
										454366,
										454370
									],
									[
										454541,
										454545
									],
									[
										454718,
										454722
									],
									[
										454895,
										454899
									],
									[
										455098,
										455102
									],
									[
										455136,
										455140
									],
									[
										455281,
										455285
									],
									[
										455302,
										455306
									],
									[
										455378,
										455382
									],
									[
										455479,
										455483
									],
									[
										455629,
										455633
									],
									[
										455717,
										455721
									],
									[
										456005,
										456009
									],
									[
										456119,
										456123
									],
									[
										456206,
										456210
									],
									[
										456282,
										456286
									],
									[
										456499,
										456503
									],
									[
										456575,
										456579
									],
									[
										456788,
										456792
									],
									[
										456892,
										456896
									],
									[
										457124,
										457128
									],
									[
										457236,
										457240
									],
									[
										457364,
										457368
									],
									[
										457402,
										457406
									],
									[
										457500,
										457504
									],
									[
										457521,
										457525
									],
									[
										457597,
										457601
									],
									[
										457698,
										457702
									],
									[
										457821,
										457825
									],
									[
										458109,
										458113
									],
									[
										458223,
										458227
									],
									[
										458289,
										458293
									],
									[
										458334,
										458338
									],
									[
										458558,
										458562
									],
									[
										458604,
										458608
									],
									[
										458827,
										458831
									],
									[
										458870,
										458874
									],
									[
										459067,
										459071
									],
									[
										459104,
										459108
									],
									[
										459315,
										459319
									],
									[
										459352,
										459356
									],
									[
										459560,
										459564
									],
									[
										459606,
										459610
									],
									[
										459850,
										459854
									],
									[
										459962,
										459966
									],
									[
										460151,
										460155
									],
									[
										460366,
										460370
									],
									[
										460692,
										460696
									],
									[
										461000,
										461004
									],
									[
										461312,
										461316
									],
									[
										461596,
										461600
									],
									[
										461820,
										461824
									],
									[
										461887,
										461891
									],
									[
										462223,
										462227
									],
									[
										462290,
										462294
									],
									[
										462612,
										462616
									],
									[
										462947,
										462951
									],
									[
										463014,
										463018
									],
									[
										463313,
										463317
									],
									[
										463590,
										463594
									],
									[
										463896,
										463900
									],
									[
										463951,
										463955
									],
									[
										464141,
										464145
									],
									[
										464182,
										464186
									],
									[
										464224,
										464228
									],
									[
										464389,
										464393
									],
									[
										464664,
										464668
									],
									[
										464935,
										464939
									],
									[
										465207,
										465211
									],
									[
										465673,
										465677
									],
									[
										465892,
										465896
									],
									[
										466365,
										466369
									],
									[
										466599,
										466603
									],
									[
										467072,
										467076
									],
									[
										467288,
										467292
									],
									[
										467761,
										467765
									],
									[
										467992,
										467996
									],
									[
										468381,
										468385
									],
									[
										468652,
										468656
									],
									[
										468779,
										468783
									],
									[
										469106,
										469110
									],
									[
										469314,
										469318
									],
									[
										469592,
										469596
									],
									[
										469907,
										469911
									],
									[
										470177,
										470181
									],
									[
										470250,
										470254
									],
									[
										470323,
										470327
									],
									[
										470396,
										470400
									],
									[
										470593,
										470597
									],
									[
										470666,
										470670
									],
									[
										470739,
										470743
									],
									[
										470812,
										470816
									],
									[
										471009,
										471013
									],
									[
										471082,
										471086
									],
									[
										471155,
										471159
									],
									[
										471228,
										471232
									],
									[
										471425,
										471429
									],
									[
										471498,
										471502
									],
									[
										471571,
										471575
									],
									[
										471644,
										471648
									],
									[
										471841,
										471845
									],
									[
										471914,
										471918
									],
									[
										471987,
										471991
									],
									[
										472060,
										472064
									],
									[
										472257,
										472261
									],
									[
										472330,
										472334
									],
									[
										472403,
										472407
									],
									[
										472476,
										472480
									],
									[
										472706,
										472710
									],
									[
										472771,
										472775
									],
									[
										472836,
										472840
									],
									[
										472901,
										472905
									],
									[
										472966,
										472970
									],
									[
										473031,
										473035
									],
									[
										473188,
										473192
									],
									[
										473212,
										473216
									],
									[
										473236,
										473240
									],
									[
										473274,
										473278
									],
									[
										473298,
										473302
									],
									[
										473322,
										473326
									],
									[
										473360,
										473364
									],
									[
										473384,
										473388
									],
									[
										473408,
										473412
									],
									[
										473446,
										473450
									],
									[
										473470,
										473474
									],
									[
										473494,
										473498
									],
									[
										473722,
										473726
									],
									[
										473787,
										473791
									],
									[
										473852,
										473856
									],
									[
										473917,
										473921
									],
									[
										473982,
										473986
									],
									[
										474047,
										474051
									],
									[
										474204,
										474208
									],
									[
										474228,
										474232
									],
									[
										474252,
										474256
									],
									[
										474290,
										474294
									],
									[
										474314,
										474318
									],
									[
										474338,
										474342
									],
									[
										474376,
										474380
									],
									[
										474400,
										474404
									],
									[
										474424,
										474428
									],
									[
										474462,
										474466
									],
									[
										474486,
										474490
									],
									[
										474510,
										474514
									],
									[
										474668,
										474672
									],
									[
										474741,
										474745
									],
									[
										474814,
										474818
									],
									[
										474887,
										474891
									],
									[
										475084,
										475088
									],
									[
										475157,
										475161
									],
									[
										475230,
										475234
									],
									[
										475303,
										475307
									],
									[
										475500,
										475504
									],
									[
										475573,
										475577
									],
									[
										475646,
										475650
									],
									[
										475719,
										475723
									],
									[
										475916,
										475920
									],
									[
										475989,
										475993
									],
									[
										476062,
										476066
									],
									[
										476135,
										476139
									],
									[
										476332,
										476336
									],
									[
										476405,
										476409
									],
									[
										476478,
										476482
									],
									[
										476551,
										476555
									],
									[
										476748,
										476752
									],
									[
										476821,
										476825
									],
									[
										476894,
										476898
									],
									[
										476967,
										476971
									],
									[
										477164,
										477168
									],
									[
										477237,
										477241
									],
									[
										477310,
										477314
									],
									[
										477383,
										477387
									],
									[
										477580,
										477584
									],
									[
										477653,
										477657
									],
									[
										477726,
										477730
									],
									[
										477799,
										477803
									],
									[
										477996,
										478000
									],
									[
										478069,
										478073
									],
									[
										478142,
										478146
									],
									[
										478215,
										478219
									],
									[
										478412,
										478416
									],
									[
										478485,
										478489
									],
									[
										478558,
										478562
									],
									[
										478631,
										478635
									],
									[
										478828,
										478832
									],
									[
										478901,
										478905
									],
									[
										478974,
										478978
									],
									[
										479047,
										479051
									],
									[
										479244,
										479248
									],
									[
										479317,
										479321
									],
									[
										479390,
										479394
									],
									[
										479463,
										479467
									],
									[
										479717,
										479721
									],
									[
										479930,
										479934
									],
									[
										480150,
										480154
									],
									[
										480426,
										480430
									],
									[
										480712,
										480716
									],
									[
										480998,
										481002
									],
									[
										481267,
										481271
									],
									[
										481525,
										481529
									],
									[
										481783,
										481787
									],
									[
										482030,
										482034
									],
									[
										482318,
										482322
									],
									[
										482603,
										482607
									],
									[
										482890,
										482894
									],
									[
										483181,
										483185
									],
									[
										483455,
										483459
									],
									[
										483720,
										483724
									],
									[
										483982,
										483986
									],
									[
										484192,
										484196
									],
									[
										484233,
										484237
									],
									[
										484284,
										484288
									],
									[
										484326,
										484330
									],
									[
										484378,
										484382
									],
									[
										484421,
										484425
									],
									[
										484474,
										484478
									],
									[
										484514,
										484518
									],
									[
										484564,
										484568
									],
									[
										484605,
										484609
									],
									[
										484746,
										484750
									],
									[
										484787,
										484791
									],
									[
										484838,
										484842
									],
									[
										484880,
										484884
									],
									[
										484932,
										484936
									],
									[
										484975,
										484979
									],
									[
										485028,
										485032
									],
									[
										485068,
										485072
									],
									[
										485118,
										485122
									],
									[
										485159,
										485163
									],
									[
										485300,
										485304
									],
									[
										485341,
										485345
									],
									[
										485392,
										485396
									],
									[
										485434,
										485438
									],
									[
										485486,
										485490
									],
									[
										485529,
										485533
									],
									[
										485582,
										485586
									],
									[
										485622,
										485626
									],
									[
										485672,
										485676
									],
									[
										485713,
										485717
									],
									[
										485866,
										485870
									],
									[
										486022,
										486026
									],
									[
										486096,
										486100
									],
									[
										486114,
										486118
									],
									[
										486331,
										486335
									],
									[
										486470,
										486474
									],
									[
										486560,
										486564
									],
									[
										486642,
										486646
									],
									[
										486758,
										486762
									],
									[
										486970,
										486974
									],
									[
										487289,
										487293
									],
									[
										487661,
										487665
									],
									[
										487990,
										487994
									],
									[
										488366,
										488370
									],
									[
										488691,
										488695
									],
									[
										489066,
										489070
									],
									[
										489401,
										489405
									],
									[
										489781,
										489785
									],
									[
										490100,
										490104
									],
									[
										490469,
										490473
									],
									[
										490794,
										490798
									],
									[
										491154,
										491158
									],
									[
										491400,
										491404
									],
									[
										491714,
										491718
									],
									[
										491960,
										491964
									],
									[
										492339,
										492343
									],
									[
										492585,
										492589
									],
									[
										492810,
										492814
									],
									[
										493007,
										493011
									],
									[
										493270,
										493274
									],
									[
										493356,
										493360
									],
									[
										493632,
										493636
									],
									[
										493756,
										493760
									],
									[
										493834,
										493838
									],
									[
										494175,
										494179
									],
									[
										494192,
										494196
									],
									[
										494371,
										494375
									],
									[
										494573,
										494577
									],
									[
										494665,
										494669
									],
									[
										494877,
										494881
									],
									[
										495200,
										495204
									],
									[
										495216,
										495220
									],
									[
										495505,
										495509
									],
									[
										495750,
										495754
									],
									[
										496105,
										496109
									],
									[
										496456,
										496460
									],
									[
										496745,
										496749
									],
									[
										497109,
										497113
									],
									[
										497319,
										497323
									],
									[
										497668,
										497672
									],
									[
										497901,
										497905
									],
									[
										498185,
										498189
									],
									[
										498511,
										498515
									],
									[
										498836,
										498840
									],
									[
										498948,
										498952
									],
									[
										499180,
										499184
									],
									[
										499465,
										499469
									],
									[
										499658,
										499662
									],
									[
										499897,
										499901
									],
									[
										500211,
										500215
									],
									[
										500404,
										500408
									],
									[
										500553,
										500557
									],
									[
										500824,
										500828
									],
									[
										500878,
										500882
									],
									[
										500996,
										501000
									],
									[
										501199,
										501203
									],
									[
										501533,
										501537
									],
									[
										501899,
										501903
									],
									[
										502200,
										502204
									],
									[
										502472,
										502476
									],
									[
										502684,
										502688
									],
									[
										502781,
										502785
									],
									[
										502950,
										502954
									],
									[
										503117,
										503121
									],
									[
										503237,
										503241
									],
									[
										503377,
										503381
									],
									[
										503528,
										503532
									],
									[
										503839,
										503843
									],
									[
										503902,
										503906
									],
									[
										503939,
										503943
									],
									[
										504004,
										504008
									],
									[
										504317,
										504321
									],
									[
										504354,
										504358
									],
									[
										504367,
										504371
									],
									[
										504421,
										504425
									],
									[
										504442,
										504446
									],
									[
										504458,
										504462
									],
									[
										504467,
										504471
									],
									[
										504693,
										504697
									],
									[
										504861,
										504865
									],
									[
										505078,
										505082
									],
									[
										505138,
										505142
									],
									[
										505174,
										505178
									],
									[
										505384,
										505388
									],
									[
										505649,
										505653
									],
									[
										506162,
										506166
									],
									[
										506388,
										506392
									],
									[
										506729,
										506733
									],
									[
										506933,
										506937
									],
									[
										507183,
										507187
									],
									[
										507342,
										507346
									],
									[
										507683,
										507687
									],
									[
										508107,
										508111
									],
									[
										508199,
										508203
									],
									[
										508264,
										508268
									],
									[
										508395,
										508399
									],
									[
										508566,
										508570
									],
									[
										509035,
										509039
									],
									[
										509377,
										509381
									],
									[
										509800,
										509804
									],
									[
										509817,
										509821
									],
									[
										510020,
										510024
									],
									[
										510031,
										510035
									],
									[
										510307,
										510311
									],
									[
										510544,
										510548
									],
									[
										510555,
										510559
									],
									[
										510616,
										510620
									],
									[
										510906,
										510910
									],
									[
										511075,
										511079
									],
									[
										511117,
										511121
									],
									[
										511167,
										511171
									],
									[
										511280,
										511284
									],
									[
										511610,
										511614
									],
									[
										512037,
										512041
									],
									[
										512243,
										512247
									],
									[
										512532,
										512536
									],
									[
										512693,
										512697
									],
									[
										513038,
										513042
									],
									[
										513483,
										513487
									],
									[
										513728,
										513732
									],
									[
										514137,
										514141
									],
									[
										514441,
										514445
									],
									[
										514785,
										514789
									],
									[
										514827,
										514831
									],
									[
										515064,
										515068
									],
									[
										515411,
										515415
									],
									[
										515527,
										515531
									],
									[
										515803,
										515807
									],
									[
										516123,
										516127
									],
									[
										516280,
										516284
									],
									[
										516343,
										516347
									],
									[
										516424,
										516428
									],
									[
										516451,
										516455
									],
									[
										516653,
										516657
									],
									[
										516748,
										516752
									],
									[
										516760,
										516764
									],
									[
										516870,
										516874
									],
									[
										517091,
										517095
									],
									[
										517414,
										517418
									],
									[
										517609,
										517613
									],
									[
										517839,
										517843
									],
									[
										518005,
										518009
									],
									[
										518205,
										518209
									],
									[
										518254,
										518258
									],
									[
										518444,
										518448
									],
									[
										518490,
										518494
									],
									[
										518650,
										518654
									],
									[
										518931,
										518935
									],
									[
										519208,
										519212
									],
									[
										519356,
										519360
									],
									[
										519457,
										519461
									],
									[
										519606,
										519610
									],
									[
										519761,
										519765
									],
									[
										519940,
										519944
									],
									[
										520190,
										520194
									],
									[
										520306,
										520310
									],
									[
										520382,
										520386
									],
									[
										520551,
										520555
									],
									[
										520629,
										520633
									],
									[
										520890,
										520894
									],
									[
										521090,
										521094
									],
									[
										521150,
										521154
									],
									[
										521423,
										521427
									],
									[
										521807,
										521811
									],
									[
										522065,
										522069
									],
									[
										522292,
										522296
									],
									[
										522512,
										522516
									],
									[
										522557,
										522561
									],
									[
										522980,
										522984
									],
									[
										523202,
										523206
									],
									[
										523448,
										523452
									],
									[
										523502,
										523506
									],
									[
										523711,
										523715
									],
									[
										523873,
										523877
									],
									[
										524032,
										524036
									],
									[
										524235,
										524239
									],
									[
										524514,
										524518
									],
									[
										524743,
										524747
									],
									[
										524911,
										524915
									],
									[
										524943,
										524947
									],
									[
										525019,
										525023
									],
									[
										525099,
										525103
									],
									[
										525341,
										525345
									],
									[
										525373,
										525377
									],
									[
										525449,
										525453
									],
									[
										525495,
										525499
									],
									[
										525678,
										525682
									],
									[
										526094,
										526098
									],
									[
										526214,
										526218
									],
									[
										526269,
										526273
									],
									[
										526334,
										526338
									],
									[
										526618,
										526622
									],
									[
										526771,
										526775
									],
									[
										527096,
										527100
									],
									[
										527240,
										527244
									],
									[
										527471,
										527475
									],
									[
										527902,
										527906
									],
									[
										528275,
										528279
									],
									[
										528670,
										528674
									],
									[
										529076,
										529080
									],
									[
										529358,
										529362
									],
									[
										529461,
										529465
									],
									[
										529679,
										529683
									],
									[
										529781,
										529785
									],
									[
										530007,
										530011
									],
									[
										530361,
										530365
									],
									[
										530818,
										530822
									],
									[
										530942,
										530946
									],
									[
										531271,
										531275
									],
									[
										531427,
										531431
									],
									[
										531722,
										531726
									],
									[
										532101,
										532105
									],
									[
										532360,
										532364
									],
									[
										532545,
										532549
									],
									[
										532788,
										532792
									],
									[
										533029,
										533033
									],
									[
										533078,
										533082
									],
									[
										533274,
										533278
									],
									[
										533588,
										533592
									],
									[
										533865,
										533869
									],
									[
										534146,
										534150
									],
									[
										534295,
										534299
									],
									[
										534457,
										534461
									],
									[
										534681,
										534685
									],
									[
										534894,
										534898
									],
									[
										535143,
										535147
									],
									[
										535464,
										535468
									],
									[
										535514,
										535518
									],
									[
										535582,
										535586
									],
									[
										535594,
										535598
									],
									[
										535860,
										535864
									],
									[
										536053,
										536057
									],
									[
										536113,
										536117
									],
									[
										536125,
										536129
									],
									[
										536294,
										536298
									],
									[
										536603,
										536607
									],
									[
										536947,
										536951
									],
									[
										537330,
										537334
									],
									[
										537426,
										537430
									],
									[
										537630,
										537634
									],
									[
										537908,
										537912
									],
									[
										538221,
										538225
									],
									[
										538380,
										538384
									],
									[
										538724,
										538728
									],
									[
										538964,
										538968
									],
									[
										539344,
										539348
									],
									[
										539641,
										539645
									],
									[
										540149,
										540153
									],
									[
										540306,
										540310
									],
									[
										540764,
										540768
									],
									[
										541049,
										541053
									],
									[
										541404,
										541408
									],
									[
										541709,
										541713
									],
									[
										541816,
										541820
									],
									[
										542134,
										542138
									],
									[
										542451,
										542455
									],
									[
										542748,
										542752
									],
									[
										543038,
										543042
									],
									[
										543391,
										543395
									],
									[
										543559,
										543563
									],
									[
										543869,
										543873
									],
									[
										544211,
										544215
									],
									[
										544366,
										544370
									],
									[
										544535,
										544539
									],
									[
										544625,
										544629
									],
									[
										544910,
										544914
									],
									[
										545138,
										545142
									],
									[
										545277,
										545281
									],
									[
										545294,
										545298
									],
									[
										545605,
										545609
									],
									[
										545735,
										545739
									],
									[
										546085,
										546089
									],
									[
										546104,
										546108
									],
									[
										546169,
										546173
									],
									[
										546188,
										546192
									],
									[
										546326,
										546330
									],
									[
										546345,
										546349
									],
									[
										546412,
										546416
									],
									[
										546431,
										546435
									],
									[
										546690,
										546694
									],
									[
										547070,
										547074
									],
									[
										547193,
										547197
									],
									[
										547452,
										547456
									],
									[
										547709,
										547713
									],
									[
										547722,
										547726
									],
									[
										547830,
										547834
									],
									[
										547908,
										547912
									],
									[
										548163,
										548167
									],
									[
										548435,
										548439
									],
									[
										548680,
										548684
									],
									[
										548754,
										548758
									],
									[
										548950,
										548954
									],
									[
										549019,
										549023
									],
									[
										549085,
										549089
									],
									[
										549148,
										549152
									],
									[
										549340,
										549344
									],
									[
										549490,
										549494
									],
									[
										550036,
										550040
									],
									[
										550707,
										550711
									],
									[
										550998,
										551002
									],
									[
										551317,
										551321
									],
									[
										551559,
										551563
									],
									[
										551804,
										551808
									],
									[
										552101,
										552105
									],
									[
										552348,
										552352
									],
									[
										552605,
										552609
									],
									[
										552720,
										552724
									],
									[
										552964,
										552968
									],
									[
										553191,
										553195
									],
									[
										553479,
										553483
									],
									[
										553618,
										553622
									],
									[
										553800,
										553804
									],
									[
										553839,
										553843
									],
									[
										553888,
										553892
									],
									[
										553941,
										553945
									],
									[
										554234,
										554238
									],
									[
										554391,
										554395
									],
									[
										554512,
										554516
									],
									[
										554837,
										554841
									],
									[
										554926,
										554930
									],
									[
										554939,
										554943
									],
									[
										555008,
										555012
									],
									[
										555305,
										555309
									],
									[
										555532,
										555536
									],
									[
										555571,
										555575
									],
									[
										555620,
										555624
									],
									[
										555673,
										555677
									],
									[
										555961,
										555965
									],
									[
										556143,
										556147
									],
									[
										556182,
										556186
									],
									[
										556231,
										556235
									],
									[
										556284,
										556288
									],
									[
										556618,
										556622
									],
									[
										556795,
										556799
									],
									[
										556983,
										556987
									],
									[
										557273,
										557277
									],
									[
										557449,
										557453
									],
									[
										557678,
										557682
									],
									[
										557820,
										557824
									],
									[
										558048,
										558052
									],
									[
										558087,
										558091
									],
									[
										558136,
										558140
									],
									[
										558189,
										558193
									],
									[
										558470,
										558474
									],
									[
										558761,
										558765
									],
									[
										559105,
										559109
									],
									[
										559342,
										559346
									],
									[
										559454,
										559458
									],
									[
										559545,
										559549
									],
									[
										559816,
										559820
									],
									[
										559979,
										559983
									],
									[
										560106,
										560110
									],
									[
										560372,
										560376
									],
									[
										560461,
										560465
									],
									[
										560474,
										560478
									],
									[
										560543,
										560547
									],
									[
										560831,
										560835
									],
									[
										561086,
										561090
									],
									[
										561331,
										561335
									],
									[
										561613,
										561617
									],
									[
										561627,
										561631
									],
									[
										561833,
										561837
									],
									[
										561908,
										561912
									],
									[
										562049,
										562053
									],
									[
										562125,
										562129
									],
									[
										562469,
										562473
									],
									[
										562754,
										562758
									],
									[
										562788,
										562792
									],
									[
										562883,
										562887
									],
									[
										562962,
										562966
									],
									[
										563100,
										563104
									],
									[
										563414,
										563418
									],
									[
										563608,
										563612
									],
									[
										563983,
										563987
									],
									[
										564066,
										564070
									],
									[
										564100,
										564104
									],
									[
										564459,
										564463
									],
									[
										564766,
										564770
									],
									[
										565063,
										565067
									],
									[
										565360,
										565364
									],
									[
										565591,
										565595
									],
									[
										565616,
										565620
									],
									[
										565696,
										565700
									],
									[
										565839,
										565843
									],
									[
										566062,
										566066
									],
									[
										566330,
										566334
									],
									[
										566517,
										566521
									],
									[
										566808,
										566812
									],
									[
										567046,
										567050
									],
									[
										567448,
										567452
									],
									[
										567770,
										567774
									],
									[
										567926,
										567930
									],
									[
										568142,
										568146
									],
									[
										568182,
										568186
									],
									[
										568338,
										568342
									],
									[
										568624,
										568628
									],
									[
										568881,
										568885
									],
									[
										568965,
										568969
									],
									[
										568989,
										568993
									],
									[
										569195,
										569199
									],
									[
										569298,
										569302
									],
									[
										569579,
										569583
									],
									[
										569770,
										569774
									],
									[
										569933,
										569937
									],
									[
										570042,
										570046
									],
									[
										570279,
										570283
									],
									[
										570445,
										570449
									],
									[
										570514,
										570518
									],
									[
										570645,
										570649
									],
									[
										570776,
										570780
									],
									[
										571124,
										571128
									],
									[
										571270,
										571274
									],
									[
										571689,
										571693
									],
									[
										571888,
										571892
									],
									[
										572076,
										572080
									],
									[
										572253,
										572257
									],
									[
										572527,
										572531
									],
									[
										572585,
										572589
									],
									[
										572627,
										572631
									],
									[
										572771,
										572775
									],
									[
										572993,
										572997
									],
									[
										573128,
										573132
									],
									[
										573315,
										573319
									],
									[
										573468,
										573472
									],
									[
										573590,
										573594
									],
									[
										573712,
										573716
									],
									[
										573983,
										573987
									],
									[
										574239,
										574243
									],
									[
										574432,
										574436
									],
									[
										574620,
										574624
									],
									[
										574940,
										574944
									],
									[
										575067,
										575071
									],
									[
										575273,
										575277
									],
									[
										575311,
										575315
									],
									[
										575341,
										575345
									],
									[
										575374,
										575378
									],
									[
										575697,
										575701
									],
									[
										575759,
										575763
									],
									[
										575791,
										575795
									],
									[
										575835,
										575839
									],
									[
										576025,
										576029
									],
									[
										576105,
										576109
									],
									[
										576129,
										576133
									],
									[
										576176,
										576180
									],
									[
										576205,
										576209
									],
									[
										576235,
										576239
									],
									[
										576275,
										576279
									],
									[
										576311,
										576315
									],
									[
										576341,
										576345
									],
									[
										576374,
										576378
									],
									[
										576469,
										576473
									],
									[
										576528,
										576532
									],
									[
										576560,
										576564
									],
									[
										576604,
										576608
									],
									[
										576662,
										576666
									],
									[
										576684,
										576688
									],
									[
										576731,
										576735
									],
									[
										576755,
										576759
									],
									[
										576854,
										576858
									],
									[
										576889,
										576893
									],
									[
										576990,
										576994
									],
									[
										577025,
										577029
									],
									[
										577275,
										577279
									],
									[
										577294,
										577298
									],
									[
										577385,
										577389
									],
									[
										577432,
										577436
									],
									[
										577459,
										577463
									],
									[
										577487,
										577491
									],
									[
										577526,
										577530
									],
									[
										577556,
										577560
									],
									[
										577599,
										577603
									],
									[
										577648,
										577652
									],
									[
										577714,
										577718
									],
									[
										577740,
										577744
									],
									[
										577772,
										577776
									],
									[
										577813,
										577817
									],
									[
										577893,
										577897
									],
									[
										577965,
										577969
									],
									[
										577991,
										577995
									],
									[
										578042,
										578046
									],
									[
										578083,
										578087
									],
									[
										578177,
										578181
									],
									[
										578408,
										578412
									],
									[
										578578,
										578582
									],
									[
										578610,
										578614
									],
									[
										578655,
										578659
									],
									[
										578713,
										578717
									],
									[
										578820,
										578824
									],
									[
										579054,
										579058
									],
									[
										579276,
										579280
									],
									[
										579437,
										579441
									],
									[
										579638,
										579642
									],
									[
										579969,
										579973
									],
									[
										580244,
										580248
									],
									[
										580548,
										580552
									],
									[
										580601,
										580605
									],
									[
										580783,
										580787
									],
									[
										581098,
										581102
									],
									[
										581424,
										581428
									],
									[
										581629,
										581633
									],
									[
										581689,
										581693
									],
									[
										581909,
										581913
									],
									[
										582018,
										582022
									],
									[
										582065,
										582069
									],
									[
										582097,
										582101
									],
									[
										582221,
										582225
									],
									[
										582285,
										582289
									],
									[
										582373,
										582377
									],
									[
										582554,
										582558
									],
									[
										582806,
										582810
									],
									[
										583035,
										583039
									],
									[
										583107,
										583111
									],
									[
										583160,
										583164
									],
									[
										583229,
										583233
									],
									[
										583499,
										583503
									],
									[
										583678,
										583682
									],
									[
										583735,
										583739
									],
									[
										583968,
										583972
									],
									[
										584030,
										584034
									],
									[
										584097,
										584101
									],
									[
										584257,
										584261
									],
									[
										584310,
										584314
									],
									[
										584404,
										584408
									],
									[
										584421,
										584425
									],
									[
										584514,
										584518
									],
									[
										584571,
										584575
									],
									[
										584635,
										584639
									],
									[
										584866,
										584870
									],
									[
										584913,
										584917
									],
									[
										584943,
										584947
									],
									[
										585011,
										585015
									],
									[
										585082,
										585086
									],
									[
										585134,
										585138
									],
									[
										585165,
										585169
									],
									[
										585215,
										585219
									],
									[
										585302,
										585306
									],
									[
										585344,
										585348
									],
									[
										585385,
										585389
									],
									[
										585438,
										585442
									],
									[
										585702,
										585706
									],
									[
										585716,
										585720
									],
									[
										585916,
										585920
									],
									[
										586129,
										586133
									],
									[
										586345,
										586349
									],
									[
										586420,
										586424
									],
									[
										586463,
										586467
									],
									[
										586518,
										586522
									],
									[
										586767,
										586771
									],
									[
										586869,
										586873
									],
									[
										587133,
										587137
									],
									[
										587301,
										587305
									],
									[
										587541,
										587545
									],
									[
										587706,
										587710
									],
									[
										587915,
										587919
									],
									[
										587990,
										587994
									],
									[
										588170,
										588174
									],
									[
										588343,
										588347
									],
									[
										588424,
										588428
									],
									[
										588569,
										588573
									],
									[
										588702,
										588706
									],
									[
										588790,
										588794
									],
									[
										588923,
										588927
									],
									[
										589099,
										589103
									],
									[
										589153,
										589157
									],
									[
										589201,
										589205
									],
									[
										589340,
										589344
									],
									[
										589586,
										589590
									],
									[
										589747,
										589751
									],
									[
										589782,
										589786
									],
									[
										589809,
										589813
									],
									[
										589870,
										589874
									],
									[
										590081,
										590085
									],
									[
										590322,
										590326
									],
									[
										590425,
										590429
									],
									[
										590678,
										590682
									],
									[
										590961,
										590965
									],
									[
										591160,
										591164
									],
									[
										591339,
										591343
									],
									[
										591690,
										591694
									],
									[
										591740,
										591744
									],
									[
										591818,
										591822
									],
									[
										591985,
										591989
									],
									[
										592297,
										592301
									],
									[
										592656,
										592660
									],
									[
										592779,
										592783
									],
									[
										592961,
										592965
									],
									[
										593013,
										593017
									],
									[
										593245,
										593249
									],
									[
										593324,
										593328
									],
									[
										593459,
										593463
									],
									[
										593605,
										593609
									],
									[
										593857,
										593861
									],
									[
										593915,
										593919
									],
									[
										594121,
										594125
									],
									[
										594346,
										594350
									],
									[
										594443,
										594447
									],
									[
										594625,
										594629
									],
									[
										594897,
										594901
									],
									[
										595039,
										595043
									],
									[
										595052,
										595056
									],
									[
										595185,
										595189
									],
									[
										595362,
										595366
									],
									[
										595544,
										595548
									],
									[
										595789,
										595793
									],
									[
										595901,
										595905
									],
									[
										596042,
										596046
									],
									[
										596240,
										596244
									],
									[
										596334,
										596338
									],
									[
										596643,
										596647
									],
									[
										596677,
										596681
									],
									[
										596918,
										596922
									],
									[
										596963,
										596967
									],
									[
										597016,
										597020
									],
									[
										597262,
										597266
									],
									[
										597312,
										597316
									],
									[
										597600,
										597604
									],
									[
										597726,
										597730
									],
									[
										597936,
										597940
									],
									[
										598035,
										598039
									],
									[
										598206,
										598210
									],
									[
										598488,
										598492
									],
									[
										598779,
										598783
									],
									[
										599103,
										599107
									],
									[
										599284,
										599288
									],
									[
										599359,
										599363
									],
									[
										599616,
										599620
									],
									[
										599952,
										599956
									],
									[
										600358,
										600362
									],
									[
										600800,
										600804
									],
									[
										600828,
										600832
									],
									[
										600887,
										600891
									],
									[
										601022,
										601026
									],
									[
										601049,
										601053
									],
									[
										601219,
										601223
									],
									[
										601278,
										601282
									],
									[
										601520,
										601524
									],
									[
										601747,
										601751
									],
									[
										602083,
										602087
									],
									[
										602111,
										602115
									],
									[
										602170,
										602174
									],
									[
										602290,
										602294
									],
									[
										602306,
										602310
									],
									[
										602545,
										602549
									],
									[
										602665,
										602669
									],
									[
										602896,
										602900
									],
									[
										603106,
										603110
									],
									[
										603314,
										603318
									],
									[
										603498,
										603502
									],
									[
										603624,
										603628
									],
									[
										603878,
										603882
									],
									[
										604068,
										604072
									],
									[
										604128,
										604132
									],
									[
										604325,
										604329
									],
									[
										604607,
										604611
									],
									[
										604837,
										604841
									],
									[
										604892,
										604896
									],
									[
										604905,
										604909
									],
									[
										604948,
										604952
									],
									[
										605123,
										605127
									],
									[
										605362,
										605366
									],
									[
										605567,
										605571
									],
									[
										605763,
										605767
									],
									[
										605871,
										605875
									],
									[
										606118,
										606122
									],
									[
										606361,
										606365
									],
									[
										606605,
										606609
									],
									[
										606885,
										606889
									],
									[
										607192,
										607196
									],
									[
										607418,
										607422
									],
									[
										607657,
										607661
									],
									[
										607929,
										607933
									],
									[
										608250,
										608254
									],
									[
										608289,
										608293
									],
									[
										608397,
										608401
									],
									[
										608424,
										608428
									],
									[
										608686,
										608690
									],
									[
										608834,
										608838
									],
									[
										608969,
										608973
									],
									[
										609315,
										609319
									],
									[
										609507,
										609511
									],
									[
										609749,
										609753
									],
									[
										609936,
										609940
									],
									[
										610166,
										610170
									],
									[
										610353,
										610357
									],
									[
										610512,
										610516
									],
									[
										610698,
										610702
									],
									[
										610944,
										610948
									],
									[
										611225,
										611229
									],
									[
										611587,
										611591
									],
									[
										611630,
										611634
									],
									[
										611676,
										611680
									],
									[
										611742,
										611746
									],
									[
										611797,
										611801
									],
									[
										611810,
										611814
									],
									[
										612044,
										612048
									],
									[
										612287,
										612291
									],
									[
										612330,
										612334
									],
									[
										612376,
										612380
									],
									[
										612442,
										612446
									],
									[
										612497,
										612501
									],
									[
										612510,
										612514
									],
									[
										612697,
										612701
									],
									[
										612895,
										612899
									],
									[
										613108,
										613112
									],
									[
										613293,
										613297
									],
									[
										613523,
										613527
									],
									[
										613727,
										613731
									],
									[
										613935,
										613939
									],
									[
										614172,
										614176
									],
									[
										614377,
										614381
									],
									[
										614638,
										614642
									],
									[
										614893,
										614897
									],
									[
										615150,
										615154
									],
									[
										615209,
										615213
									],
									[
										615379,
										615383
									],
									[
										615546,
										615550
									],
									[
										615574,
										615578
									],
									[
										615633,
										615637
									],
									[
										615798,
										615802
									],
									[
										616188,
										616192
									],
									[
										616216,
										616220
									],
									[
										616275,
										616279
									],
									[
										616491,
										616495
									],
									[
										616617,
										616621
									],
									[
										616897,
										616901
									],
									[
										616950,
										616954
									],
									[
										616984,
										616988
									],
									[
										617042,
										617046
									],
									[
										617053,
										617057
									],
									[
										617100,
										617104
									],
									[
										617234,
										617238
									],
									[
										617474,
										617478
									],
									[
										617508,
										617512
									],
									[
										617717,
										617721
									],
									[
										617750,
										617754
									],
									[
										617872,
										617876
									],
									[
										617961,
										617965
									],
									[
										618167,
										618171
									],
									[
										618331,
										618335
									],
									[
										618364,
										618368
									],
									[
										618485,
										618489
									],
									[
										618573,
										618577
									],
									[
										618778,
										618782
									],
									[
										618924,
										618928
									],
									[
										618959,
										618963
									],
									[
										619238,
										619242
									],
									[
										619336,
										619340
									],
									[
										619671,
										619675
									],
									[
										619947,
										619951
									],
									[
										620232,
										620236
									],
									[
										620325,
										620329
									],
									[
										620663,
										620667
									],
									[
										620846,
										620850
									],
									[
										620954,
										620958
									],
									[
										621057,
										621061
									],
									[
										621159,
										621163
									],
									[
										621193,
										621197
									],
									[
										621523,
										621527
									],
									[
										621855,
										621859
									],
									[
										622129,
										622133
									],
									[
										622320,
										622324
									],
									[
										622419,
										622423
									],
									[
										622753,
										622757
									],
									[
										622971,
										622975
									],
									[
										623074,
										623078
									],
									[
										623346,
										623350
									],
									[
										623380,
										623384
									],
									[
										623717,
										623721
									],
									[
										624040,
										624044
									],
									[
										624278,
										624282
									],
									[
										624558,
										624562
									],
									[
										624588,
										624592
									],
									[
										624765,
										624769
									],
									[
										624797,
										624801
									],
									[
										625035,
										625039
									],
									[
										625337,
										625341
									],
									[
										625403,
										625407
									],
									[
										625481,
										625485
									],
									[
										625683,
										625687
									],
									[
										625766,
										625770
									],
									[
										625799,
										625803
									],
									[
										625905,
										625909
									],
									[
										626095,
										626099
									],
									[
										626314,
										626318
									],
									[
										626381,
										626385
									],
									[
										626466,
										626470
									],
									[
										626640,
										626644
									],
									[
										626924,
										626928
									],
									[
										627126,
										627130
									],
									[
										627246,
										627250
									],
									[
										627530,
										627534
									],
									[
										627730,
										627734
									],
									[
										627973,
										627977
									],
									[
										628157,
										628161
									],
									[
										628168,
										628172
									],
									[
										628392,
										628396
									],
									[
										628585,
										628589
									],
									[
										628852,
										628856
									],
									[
										629131,
										629135
									],
									[
										629232,
										629236
									],
									[
										629337,
										629341
									],
									[
										629404,
										629408
									],
									[
										629417,
										629421
									],
									[
										629635,
										629639
									],
									[
										629864,
										629868
									],
									[
										630168,
										630172
									],
									[
										630412,
										630416
									],
									[
										630441,
										630445
									],
									[
										630727,
										630731
									],
									[
										630963,
										630967
									],
									[
										631175,
										631179
									],
									[
										631204,
										631208
									],
									[
										631225,
										631229
									],
									[
										631509,
										631513
									],
									[
										631618,
										631622
									],
									[
										631860,
										631864
									],
									[
										632009,
										632013
									],
									[
										632300,
										632304
									],
									[
										632712,
										632716
									],
									[
										633140,
										633144
									],
									[
										633330,
										633334
									],
									[
										633620,
										633624
									],
									[
										633816,
										633820
									],
									[
										633842,
										633846
									],
									[
										633874,
										633878
									],
									[
										633899,
										633903
									],
									[
										634013,
										634017
									],
									[
										634296,
										634300
									],
									[
										634622,
										634626
									],
									[
										634951,
										634955
									],
									[
										635227,
										635231
									],
									[
										635540,
										635544
									],
									[
										635899,
										635903
									],
									[
										636149,
										636153
									],
									[
										636379,
										636383
									],
									[
										636605,
										636609
									],
									[
										636650,
										636654
									],
									[
										636750,
										636754
									],
									[
										636805,
										636809
									],
									[
										636992,
										636996
									],
									[
										637214,
										637218
									],
									[
										637966,
										637970
									],
									[
										638061,
										638065
									],
									[
										638321,
										638325
									],
									[
										638417,
										638421
									],
									[
										638673,
										638677
									],
									[
										639091,
										639095
									],
									[
										639309,
										639313
									],
									[
										639683,
										639687
									],
									[
										639930,
										639934
									],
									[
										640250,
										640254
									],
									[
										640357,
										640361
									],
									[
										640470,
										640474
									],
									[
										640597,
										640601
									],
									[
										641022,
										641026
									],
									[
										641296,
										641300
									],
									[
										641363,
										641367
									],
									[
										642009,
										642013
									],
									[
										642282,
										642286
									],
									[
										642569,
										642573
									],
									[
										642666,
										642670
									],
									[
										643077,
										643081
									],
									[
										643460,
										643464
									],
									[
										643718,
										643722
									],
									[
										643777,
										643781
									],
									[
										644099,
										644103
									],
									[
										644397,
										644401
									],
									[
										644456,
										644460
									],
									[
										644859,
										644863
									],
									[
										645250,
										645254
									],
									[
										645651,
										645655
									],
									[
										645744,
										645748
									],
									[
										645990,
										645994
									],
									[
										646129,
										646133
									],
									[
										646833,
										646837
									],
									[
										647335,
										647339
									],
									[
										647514,
										647518
									],
									[
										647910,
										647914
									],
									[
										648214,
										648218
									],
									[
										648636,
										648640
									],
									[
										648820,
										648824
									],
									[
										649115,
										649119
									],
									[
										649433,
										649437
									],
									[
										649643,
										649647
									],
									[
										649956,
										649960
									],
									[
										650562,
										650566
									],
									[
										650805,
										650809
									],
									[
										651105,
										651109
									],
									[
										651467,
										651471
									],
									[
										651647,
										651651
									],
									[
										651968,
										651972
									],
									[
										652236,
										652240
									],
									[
										652344,
										652348
									],
									[
										652396,
										652400
									],
									[
										652413,
										652417
									],
									[
										652466,
										652470
									],
									[
										652520,
										652524
									],
									[
										652586,
										652590
									],
									[
										652848,
										652852
									],
									[
										653093,
										653097
									],
									[
										653270,
										653274
									],
									[
										653462,
										653466
									],
									[
										653632,
										653636
									],
									[
										654089,
										654093
									],
									[
										654299,
										654303
									],
									[
										654738,
										654742
									],
									[
										654928,
										654932
									],
									[
										655295,
										655299
									],
									[
										655615,
										655619
									],
									[
										656003,
										656007
									],
									[
										656088,
										656092
									],
									[
										656338,
										656342
									],
									[
										656484,
										656488
									],
									[
										656805,
										656809
									],
									[
										657024,
										657028
									],
									[
										657106,
										657110
									],
									[
										657289,
										657293
									],
									[
										657722,
										657726
									],
									[
										658209,
										658213
									],
									[
										658644,
										658648
									],
									[
										658896,
										658900
									],
									[
										659139,
										659143
									],
									[
										659568,
										659572
									],
									[
										659883,
										659887
									],
									[
										660151,
										660155
									],
									[
										660388,
										660392
									],
									[
										660708,
										660712
									],
									[
										661009,
										661013
									],
									[
										661419,
										661423
									],
									[
										661437,
										661441
									],
									[
										661524,
										661528
									],
									[
										661542,
										661546
									],
									[
										661762,
										661766
									],
									[
										661791,
										661795
									],
									[
										662010,
										662014
									],
									[
										662025,
										662029
									],
									[
										662317,
										662321
									],
									[
										662366,
										662370
									],
									[
										662692,
										662696
									],
									[
										663266,
										663270
									],
									[
										663297,
										663301
									],
									[
										663659,
										663663
									],
									[
										664254,
										664258
									],
									[
										664285,
										664289
									],
									[
										664939,
										664943
									],
									[
										665477,
										665481
									],
									[
										666076,
										666080
									],
									[
										666375,
										666379
									],
									[
										666941,
										666945
									],
									[
										667584,
										667588
									],
									[
										668183,
										668187
									],
									[
										668482,
										668486
									],
									[
										669048,
										669052
									],
									[
										669446,
										669450
									],
									[
										669491,
										669495
									],
									[
										669920,
										669924
									],
									[
										670519,
										670523
									],
									[
										670823,
										670827
									],
									[
										671389,
										671393
									],
									[
										671757,
										671761
									],
									[
										671788,
										671792
									],
									[
										671819,
										671823
									],
									[
										672276,
										672280
									],
									[
										672875,
										672879
									],
									[
										673179,
										673183
									],
									[
										673745,
										673749
									],
									[
										674113,
										674117
									],
									[
										674158,
										674162
									],
									[
										674415,
										674419
									],
									[
										674680,
										674684
									],
									[
										674778,
										674782
									],
									[
										674929,
										674933
									],
									[
										675207,
										675211
									],
									[
										675269,
										675273
									],
									[
										675329,
										675333
									],
									[
										675557,
										675561
									],
									[
										675660,
										675664
									],
									[
										675920,
										675924
									],
									[
										676129,
										676133
									],
									[
										676162,
										676166
									],
									[
										676380,
										676384
									],
									[
										676663,
										676667
									],
									[
										676903,
										676907
									],
									[
										677103,
										677107
									],
									[
										677117,
										677121
									],
									[
										677278,
										677282
									],
									[
										677317,
										677321
									],
									[
										677353,
										677357
									],
									[
										677753,
										677757
									],
									[
										677777,
										677781
									],
									[
										678282,
										678286
									],
									[
										678488,
										678492
									],
									[
										678502,
										678506
									],
									[
										678692,
										678696
									],
									[
										678708,
										678712
									],
									[
										678893,
										678897
									],
									[
										678909,
										678913
									],
									[
										679029,
										679033
									],
									[
										679123,
										679127
									],
									[
										679220,
										679224
									],
									[
										679362,
										679366
									],
									[
										679420,
										679424
									],
									[
										679642,
										679646
									],
									[
										679658,
										679662
									],
									[
										679992,
										679996
									],
									[
										680149,
										680153
									],
									[
										680357,
										680361
									],
									[
										680592,
										680596
									],
									[
										680923,
										680927
									],
									[
										681354,
										681358
									],
									[
										681526,
										681530
									],
									[
										681784,
										681788
									],
									[
										681867,
										681871
									],
									[
										681890,
										681894
									],
									[
										682101,
										682105
									],
									[
										682384,
										682388
									],
									[
										682463,
										682467
									],
									[
										682591,
										682595
									],
									[
										682976,
										682980
									],
									[
										683289,
										683293
									],
									[
										683476,
										683480
									],
									[
										683757,
										683761
									],
									[
										683981,
										683985
									],
									[
										684198,
										684202
									],
									[
										684292,
										684296
									],
									[
										684583,
										684587
									],
									[
										684896,
										684900
									],
									[
										684968,
										684972
									],
									[
										685071,
										685075
									],
									[
										685116,
										685120
									],
									[
										685305,
										685309
									],
									[
										685510,
										685514
									],
									[
										685763,
										685767
									],
									[
										686099,
										686103
									],
									[
										686139,
										686143
									],
									[
										686413,
										686417
									],
									[
										686605,
										686609
									],
									[
										686763,
										686767
									],
									[
										687134,
										687138
									],
									[
										687206,
										687210
									],
									[
										687579,
										687583
									],
									[
										687961,
										687965
									],
									[
										688245,
										688249
									],
									[
										688640,
										688644
									],
									[
										688911,
										688915
									],
									[
										689183,
										689187
									],
									[
										689491,
										689495
									],
									[
										689592,
										689596
									],
									[
										689976,
										689980
									],
									[
										690346,
										690350
									],
									[
										690736,
										690740
									],
									[
										690774,
										690778
									],
									[
										691045,
										691049
									],
									[
										691091,
										691095
									],
									[
										691296,
										691300
									],
									[
										691357,
										691361
									],
									[
										691570,
										691574
									],
									[
										691892,
										691896
									],
									[
										692059,
										692063
									],
									[
										692380,
										692384
									],
									[
										692671,
										692675
									],
									[
										692891,
										692895
									],
									[
										693010,
										693014
									],
									[
										693170,
										693174
									],
									[
										693250,
										693254
									],
									[
										693503,
										693507
									],
									[
										693742,
										693746
									],
									[
										693872,
										693876
									],
									[
										694120,
										694124
									],
									[
										694336,
										694340
									],
									[
										694620,
										694624
									],
									[
										695075,
										695079
									],
									[
										695361,
										695365
									],
									[
										695623,
										695627
									],
									[
										695901,
										695905
									],
									[
										696117,
										696121
									],
									[
										696407,
										696411
									],
									[
										696688,
										696692
									],
									[
										696905,
										696909
									],
									[
										697271,
										697275
									],
									[
										697372,
										697376
									],
									[
										697591,
										697595
									],
									[
										697848,
										697852
									],
									[
										698144,
										698148
									],
									[
										698372,
										698376
									],
									[
										698560,
										698564
									],
									[
										698864,
										698868
									],
									[
										698996,
										699000
									],
									[
										699223,
										699227
									],
									[
										699508,
										699512
									],
									[
										699760,
										699764
									],
									[
										700074,
										700078
									],
									[
										700361,
										700365
									],
									[
										700679,
										700683
									],
									[
										700701,
										700705
									],
									[
										700798,
										700802
									],
									[
										700928,
										700932
									],
									[
										701127,
										701131
									],
									[
										701324,
										701328
									],
									[
										701852,
										701856
									],
									[
										701906,
										701910
									],
									[
										701970,
										701974
									],
									[
										702029,
										702033
									],
									[
										702363,
										702367
									],
									[
										702753,
										702757
									],
									[
										702914,
										702918
									],
									[
										702988,
										702992
									],
									[
										703069,
										703073
									],
									[
										703199,
										703203
									],
									[
										703470,
										703474
									],
									[
										703661,
										703665
									],
									[
										703886,
										703890
									],
									[
										704054,
										704058
									],
									[
										704357,
										704361
									],
									[
										704402,
										704406
									],
									[
										704752,
										704756
									],
									[
										704797,
										704801
									],
									[
										705036,
										705040
									],
									[
										705097,
										705101
									],
									[
										705457,
										705461
									],
									[
										705831,
										705835
									],
									[
										705845,
										705849
									],
									[
										705911,
										705915
									],
									[
										705925,
										705929
									],
									[
										706089,
										706093
									],
									[
										706134,
										706138
									],
									[
										706318,
										706322
									],
									[
										706580,
										706584
									],
									[
										706625,
										706629
									],
									[
										706797,
										706801
									],
									[
										707011,
										707015
									],
									[
										707065,
										707069
									],
									[
										707120,
										707124
									],
									[
										707187,
										707191
									],
									[
										707377,
										707381
									],
									[
										707434,
										707438
									],
									[
										707584,
										707588
									],
									[
										707645,
										707649
									],
									[
										707994,
										707998
									],
									[
										708299,
										708303
									],
									[
										708661,
										708665
									],
									[
										709001,
										709005
									],
									[
										709083,
										709087
									],
									[
										709362,
										709366
									],
									[
										709384,
										709388
									],
									[
										709601,
										709605
									],
									[
										709661,
										709665
									],
									[
										709923,
										709927
									],
									[
										709974,
										709978
									],
									[
										710319,
										710323
									],
									[
										710533,
										710537
									],
									[
										710891,
										710895
									],
									[
										710904,
										710908
									],
									[
										711097,
										711101
									],
									[
										711305,
										711309
									],
									[
										711542,
										711546
									],
									[
										711765,
										711769
									],
									[
										711967,
										711971
									],
									[
										712216,
										712220
									],
									[
										712440,
										712444
									],
									[
										712955,
										712959
									],
									[
										713321,
										713325
									],
									[
										713377,
										713381
									],
									[
										713587,
										713591
									],
									[
										713640,
										713644
									],
									[
										713968,
										713972
									],
									[
										714438,
										714442
									],
									[
										714502,
										714506
									],
									[
										714514,
										714518
									],
									[
										714706,
										714710
									],
									[
										714914,
										714918
									],
									[
										715177,
										715181
									],
									[
										715338,
										715342
									],
									[
										715772,
										715776
									],
									[
										716049,
										716053
									],
									[
										716089,
										716093
									],
									[
										716152,
										716156
									],
									[
										716339,
										716343
									],
									[
										716602,
										716606
									],
									[
										716834,
										716838
									],
									[
										716864,
										716868
									],
									[
										717301,
										717305
									],
									[
										717434,
										717438
									],
									[
										717485,
										717489
									],
									[
										717776,
										717780
									],
									[
										718191,
										718195
									],
									[
										718506,
										718510
									],
									[
										718611,
										718615
									],
									[
										718672,
										718676
									],
									[
										718734,
										718738
									],
									[
										718896,
										718900
									],
									[
										718906,
										718910
									],
									[
										719069,
										719073
									],
									[
										719079,
										719083
									],
									[
										719290,
										719294
									],
									[
										719744,
										719748
									],
									[
										719944,
										719948
									],
									[
										720243,
										720247
									],
									[
										720438,
										720442
									],
									[
										720467,
										720471
									],
									[
										720775,
										720779
									],
									[
										721002,
										721006
									],
									[
										721115,
										721119
									],
									[
										721359,
										721363
									],
									[
										721485,
										721489
									],
									[
										721704,
										721708
									],
									[
										722027,
										722031
									],
									[
										722170,
										722174
									],
									[
										722341,
										722345
									],
									[
										722524,
										722528
									],
									[
										722716,
										722720
									],
									[
										722890,
										722894
									],
									[
										723163,
										723167
									],
									[
										723381,
										723385
									],
									[
										723599,
										723603
									],
									[
										723896,
										723900
									],
									[
										724171,
										724175
									],
									[
										724291,
										724295
									],
									[
										724473,
										724477
									],
									[
										724703,
										724707
									],
									[
										724786,
										724790
									],
									[
										724927,
										724931
									],
									[
										725050,
										725054
									],
									[
										725372,
										725376
									],
									[
										725485,
										725489
									],
									[
										725530,
										725534
									],
									[
										725869,
										725873
									],
									[
										726098,
										726102
									],
									[
										726325,
										726329
									],
									[
										726617,
										726621
									],
									[
										726813,
										726817
									],
									[
										727180,
										727184
									],
									[
										727280,
										727284
									],
									[
										727383,
										727387
									],
									[
										727475,
										727479
									],
									[
										727582,
										727586
									],
									[
										727793,
										727797
									],
									[
										728135,
										728139
									],
									[
										728303,
										728307
									],
									[
										728323,
										728327
									],
									[
										728373,
										728377
									],
									[
										728390,
										728394
									],
									[
										728476,
										728480
									],
									[
										728491,
										728495
									],
									[
										728623,
										728627
									],
									[
										728636,
										728640
									],
									[
										728690,
										728694
									],
									[
										728700,
										728704
									],
									[
										728758,
										728762
									],
									[
										728767,
										728771
									],
									[
										728997,
										729001
									],
									[
										729287,
										729291
									],
									[
										729597,
										729601
									],
									[
										729628,
										729632
									],
									[
										729658,
										729662
									],
									[
										730039,
										730043
									],
									[
										730095,
										730099
									],
									[
										730108,
										730112
									],
									[
										730298,
										730302
									],
									[
										730355,
										730359
									],
									[
										730393,
										730397
									],
									[
										730872,
										730876
									],
									[
										730927,
										730931
									],
									[
										731282,
										731286
									],
									[
										731564,
										731568
									],
									[
										731804,
										731808
									],
									[
										732178,
										732182
									],
									[
										732472,
										732476
									],
									[
										732785,
										732789
									],
									[
										732914,
										732918
									],
									[
										733038,
										733042
									],
									[
										733222,
										733226
									],
									[
										733482,
										733486
									],
									[
										733819,
										733823
									],
									[
										734016,
										734020
									],
									[
										734221,
										734225
									],
									[
										734748,
										734752
									],
									[
										734980,
										734984
									],
									[
										735246,
										735250
									],
									[
										735513,
										735517
									],
									[
										735740,
										735744
									],
									[
										735916,
										735920
									],
									[
										736062,
										736066
									],
									[
										736528,
										736532
									],
									[
										736540,
										736544
									],
									[
										736892,
										736896
									],
									[
										737292,
										737296
									],
									[
										737544,
										737548
									],
									[
										737877,
										737881
									],
									[
										738140,
										738144
									],
									[
										738535,
										738539
									],
									[
										739091,
										739095
									],
									[
										739466,
										739470
									],
									[
										739771,
										739775
									],
									[
										739923,
										739927
									],
									[
										739963,
										739967
									],
									[
										740065,
										740069
									],
									[
										740174,
										740178
									],
									[
										740333,
										740337
									],
									[
										740525,
										740529
									],
									[
										740622,
										740626
									],
									[
										740971,
										740975
									],
									[
										741093,
										741097
									],
									[
										741105,
										741109
									],
									[
										741335,
										741339
									],
									[
										741647,
										741651
									],
									[
										741794,
										741798
									],
									[
										742080,
										742084
									],
									[
										742438,
										742442
									],
									[
										742698,
										742702
									],
									[
										743156,
										743160
									],
									[
										743340,
										743344
									],
									[
										743901,
										743905
									],
									[
										744129,
										744133
									],
									[
										744322,
										744326
									],
									[
										744627,
										744631
									],
									[
										745072,
										745076
									],
									[
										745471,
										745475
									],
									[
										745659,
										745663
									],
									[
										745706,
										745710
									],
									[
										745864,
										745868
									],
									[
										745924,
										745928
									],
									[
										746067,
										746071
									],
									[
										746113,
										746117
									],
									[
										746176,
										746180
									],
									[
										746285,
										746289
									],
									[
										746340,
										746344
									],
									[
										746456,
										746460
									],
									[
										746642,
										746646
									],
									[
										746925,
										746929
									],
									[
										747078,
										747082
									],
									[
										747118,
										747122
									],
									[
										747345,
										747349
									],
									[
										747701,
										747705
									],
									[
										747854,
										747858
									],
									[
										748261,
										748265
									],
									[
										748396,
										748400
									],
									[
										748602,
										748606
									],
									[
										748742,
										748746
									],
									[
										748975,
										748979
									],
									[
										749255,
										749259
									],
									[
										749464,
										749468
									],
									[
										749704,
										749708
									],
									[
										749937,
										749941
									],
									[
										750038,
										750042
									],
									[
										750208,
										750212
									],
									[
										750372,
										750376
									],
									[
										750514,
										750518
									],
									[
										750822,
										750826
									],
									[
										751095,
										751099
									],
									[
										751548,
										751552
									],
									[
										751632,
										751636
									],
									[
										751695,
										751699
									],
									[
										751982,
										751986
									],
									[
										752367,
										752371
									],
									[
										752664,
										752668
									],
									[
										752835,
										752839
									],
									[
										753107,
										753111
									],
									[
										753439,
										753443
									],
									[
										753638,
										753642
									],
									[
										753695,
										753699
									],
									[
										753851,
										753855
									],
									[
										754203,
										754207
									],
									[
										754415,
										754419
									],
									[
										754519,
										754523
									],
									[
										754700,
										754704
									],
									[
										754941,
										754945
									],
									[
										755088,
										755092
									],
									[
										755435,
										755439
									],
									[
										755522,
										755526
									],
									[
										755607,
										755611
									],
									[
										755791,
										755795
									],
									[
										755940,
										755944
									],
									[
										756251,
										756255
									],
									[
										756642,
										756646
									],
									[
										756715,
										756719
									],
									[
										756964,
										756968
									],
									[
										757124,
										757128
									],
									[
										757312,
										757316
									],
									[
										757530,
										757534
									],
									[
										757611,
										757615
									],
									[
										757827,
										757831
									],
									[
										758065,
										758069
									],
									[
										758167,
										758171
									],
									[
										758411,
										758415
									],
									[
										758557,
										758561
									],
									[
										758641,
										758645
									],
									[
										758830,
										758834
									],
									[
										759048,
										759052
									],
									[
										759395,
										759399
									],
									[
										759510,
										759514
									],
									[
										759903,
										759907
									],
									[
										760197,
										760201
									],
									[
										760451,
										760455
									],
									[
										760532,
										760536
									],
									[
										760691,
										760695
									],
									[
										760824,
										760828
									],
									[
										761217,
										761221
									],
									[
										761368,
										761372
									],
									[
										761688,
										761692
									],
									[
										762035,
										762039
									],
									[
										762192,
										762196
									],
									[
										762216,
										762220
									],
									[
										762338,
										762342
									],
									[
										762354,
										762358
									],
									[
										762799,
										762803
									],
									[
										762856,
										762860
									],
									[
										762992,
										762996
									],
									[
										763016,
										763020
									],
									[
										763067,
										763071
									],
									[
										763083,
										763087
									],
									[
										763456,
										763460
									],
									[
										763603,
										763607
									],
									[
										763875,
										763879
									],
									[
										764021,
										764025
									],
									[
										764307,
										764311
									],
									[
										764591,
										764595
									],
									[
										764906,
										764910
									],
									[
										765227,
										765231
									],
									[
										765475,
										765479
									],
									[
										765816,
										765820
									],
									[
										765867,
										765871
									],
									[
										766322,
										766326
									],
									[
										766611,
										766615
									],
									[
										766863,
										766867
									],
									[
										767023,
										767027
									],
									[
										767543,
										767547
									],
									[
										767859,
										767863
									],
									[
										768085,
										768089
									],
									[
										768257,
										768261
									],
									[
										768463,
										768467
									],
									[
										768661,
										768665
									],
									[
										768833,
										768837
									],
									[
										769037,
										769041
									],
									[
										769087,
										769091
									],
									[
										769139,
										769143
									],
									[
										769208,
										769212
									],
									[
										769388,
										769392
									],
									[
										769439,
										769443
									],
									[
										769479,
										769483
									],
									[
										769704,
										769708
									],
									[
										770011,
										770015
									],
									[
										770379,
										770383
									],
									[
										770793,
										770797
									],
									[
										770944,
										770948
									],
									[
										770983,
										770987
									],
									[
										771272,
										771276
									],
									[
										771775,
										771779
									],
									[
										771981,
										771985
									],
									[
										772086,
										772090
									],
									[
										772391,
										772395
									],
									[
										772593,
										772597
									],
									[
										772938,
										772942
									],
									[
										773144,
										773148
									],
									[
										773208,
										773212
									],
									[
										773542,
										773546
									],
									[
										773780,
										773784
									],
									[
										774104,
										774108
									],
									[
										774409,
										774413
									],
									[
										774475,
										774479
									],
									[
										774536,
										774540
									],
									[
										774610,
										774614
									],
									[
										774673,
										774677
									],
									[
										774685,
										774689
									],
									[
										775046,
										775050
									],
									[
										775361,
										775365
									],
									[
										775935,
										775939
									],
									[
										776057,
										776061
									],
									[
										776246,
										776250
									],
									[
										776663,
										776667
									],
									[
										777050,
										777054
									],
									[
										777466,
										777470
									],
									[
										777701,
										777705
									],
									[
										777881,
										777885
									],
									[
										777908,
										777912
									],
									[
										778197,
										778201
									],
									[
										778393,
										778397
									],
									[
										778849,
										778853
									],
									[
										779042,
										779046
									],
									[
										779283,
										779287
									],
									[
										779592,
										779596
									],
									[
										779833,
										779837
									],
									[
										780205,
										780209
									],
									[
										780412,
										780416
									],
									[
										780460,
										780464
									],
									[
										780692,
										780696
									],
									[
										780899,
										780903
									],
									[
										781028,
										781032
									],
									[
										781093,
										781097
									],
									[
										781392,
										781396
									],
									[
										781646,
										781650
									],
									[
										781752,
										781756
									],
									[
										782004,
										782008
									],
									[
										782138,
										782142
									],
									[
										782369,
										782373
									],
									[
										782678,
										782682
									],
									[
										782888,
										782892
									],
									[
										782994,
										782998
									],
									[
										783328,
										783332
									],
									[
										783608,
										783612
									],
									[
										783725,
										783729
									],
									[
										783966,
										783970
									],
									[
										784287,
										784291
									],
									[
										784589,
										784593
									],
									[
										784879,
										784883
									],
									[
										784998,
										785002
									],
									[
										785398,
										785402
									],
									[
										785650,
										785654
									],
									[
										785782,
										785786
									],
									[
										786274,
										786278
									],
									[
										786312,
										786316
									],
									[
										786507,
										786511
									],
									[
										786579,
										786583
									],
									[
										786593,
										786597
									],
									[
										786822,
										786826
									],
									[
										787139,
										787143
									],
									[
										787331,
										787335
									],
									[
										787499,
										787503
									],
									[
										787991,
										787995
									],
									[
										788209,
										788213
									],
									[
										788247,
										788251
									],
									[
										788507,
										788511
									],
									[
										788687,
										788691
									],
									[
										788939,
										788943
									],
									[
										789160,
										789164
									],
									[
										789395,
										789399
									],
									[
										789787,
										789791
									],
									[
										790054,
										790058
									],
									[
										790481,
										790485
									],
									[
										790964,
										790968
									],
									[
										791002,
										791006
									],
									[
										791285,
										791289
									],
									[
										791362,
										791366
									],
									[
										791452,
										791456
									],
									[
										791658,
										791662
									],
									[
										791803,
										791807
									],
									[
										792042,
										792046
									],
									[
										792080,
										792084
									],
									[
										792473,
										792477
									],
									[
										792925,
										792929
									],
									[
										793362,
										793366
									],
									[
										793753,
										793757
									],
									[
										794030,
										794034
									],
									[
										794091,
										794095
									],
									[
										794443,
										794447
									],
									[
										794938,
										794942
									],
									[
										795540,
										795544
									],
									[
										795670,
										795674
									],
									[
										795925,
										795929
									],
									[
										796113,
										796117
									],
									[
										796325,
										796329
									],
									[
										796467,
										796471
									],
									[
										796679,
										796683
									],
									[
										796967,
										796971
									],
									[
										797151,
										797155
									],
									[
										797361,
										797365
									],
									[
										797719,
										797723
									],
									[
										798035,
										798039
									],
									[
										798358,
										798362
									],
									[
										798665,
										798669
									],
									[
										798831,
										798835
									],
									[
										799078,
										799082
									],
									[
										799165,
										799169
									],
									[
										799360,
										799364
									],
									[
										799616,
										799620
									],
									[
										799891,
										799895
									],
									[
										800166,
										800170
									],
									[
										800551,
										800555
									],
									[
										800578,
										800582
									],
									[
										800951,
										800955
									],
									[
										800988,
										800992
									],
									[
										801367,
										801371
									],
									[
										801396,
										801400
									],
									[
										801737,
										801741
									],
									[
										801765,
										801769
									],
									[
										802085,
										802089
									],
									[
										802115,
										802119
									],
									[
										802394,
										802398
									],
									[
										802431,
										802435
									],
									[
										802820,
										802824
									],
									[
										802893,
										802897
									],
									[
										803077,
										803081
									],
									[
										803333,
										803337
									],
									[
										803631,
										803635
									],
									[
										803921,
										803925
									],
									[
										803944,
										803948
									],
									[
										803961,
										803965
									],
									[
										803984,
										803988
									],
									[
										804171,
										804175
									],
									[
										804257,
										804261
									],
									[
										804511,
										804515
									],
									[
										804710,
										804714
									],
									[
										805093,
										805097
									],
									[
										805402,
										805406
									],
									[
										805626,
										805630
									],
									[
										805824,
										805828
									],
									[
										805957,
										805961
									],
									[
										806011,
										806015
									],
									[
										806172,
										806176
									],
									[
										806411,
										806415
									],
									[
										806576,
										806580
									],
									[
										806709,
										806713
									],
									[
										806943,
										806947
									],
									[
										807018,
										807022
									],
									[
										807043,
										807047
									],
									[
										807068,
										807072
									],
									[
										807346,
										807350
									],
									[
										807640,
										807644
									],
									[
										807720,
										807724
									],
									[
										807966,
										807970
									],
									[
										807977,
										807981
									],
									[
										808266,
										808270
									],
									[
										808383,
										808387
									],
									[
										808506,
										808510
									],
									[
										808623,
										808627
									],
									[
										808757,
										808761
									],
									[
										808920,
										808924
									],
									[
										809141,
										809145
									],
									[
										809204,
										809208
									],
									[
										809449,
										809453
									],
									[
										809570,
										809574
									],
									[
										809671,
										809675
									],
									[
										809929,
										809933
									],
									[
										810246,
										810250
									],
									[
										810508,
										810512
									],
									[
										810596,
										810600
									],
									[
										810679,
										810683
									],
									[
										810759,
										810763
									],
									[
										810960,
										810964
									],
									[
										811123,
										811127
									],
									[
										811258,
										811262
									],
									[
										811311,
										811315
									],
									[
										811365,
										811369
									],
									[
										811421,
										811425
									],
									[
										811482,
										811486
									],
									[
										811538,
										811542
									],
									[
										811687,
										811691
									],
									[
										811837,
										811841
									],
									[
										811964,
										811968
									],
									[
										812133,
										812137
									],
									[
										812294,
										812298
									],
									[
										812449,
										812453
									],
									[
										812603,
										812607
									],
									[
										812789,
										812793
									],
									[
										813013,
										813017
									],
									[
										813077,
										813081
									],
									[
										813326,
										813330
									],
									[
										813573,
										813577
									],
									[
										813894,
										813898
									],
									[
										814234,
										814238
									],
									[
										814378,
										814382
									],
									[
										814672,
										814676
									],
									[
										814868,
										814872
									],
									[
										814992,
										814996
									],
									[
										815223,
										815227
									],
									[
										815494,
										815498
									],
									[
										815655,
										815659
									],
									[
										815790,
										815794
									],
									[
										815843,
										815847
									],
									[
										815905,
										815909
									],
									[
										815961,
										815965
									],
									[
										816110,
										816114
									],
									[
										816279,
										816283
									],
									[
										816456,
										816460
									],
									[
										816657,
										816661
									],
									[
										816834,
										816838
									],
									[
										817030,
										817034
									],
									[
										817207,
										817211
									],
									[
										817243,
										817247
									],
									[
										817392,
										817396
									],
									[
										817575,
										817579
									],
									[
										817693,
										817697
									],
									[
										817948,
										817952
									],
									[
										818144,
										818148
									],
									[
										818211,
										818215
									],
									[
										818244,
										818248
									],
									[
										818430,
										818434
									],
									[
										818550,
										818554
									],
									[
										818733,
										818737
									],
									[
										818807,
										818811
									],
									[
										818980,
										818984
									],
									[
										819124,
										819128
									],
									[
										819136,
										819140
									],
									[
										819148,
										819152
									],
									[
										819363,
										819367
									],
									[
										819556,
										819560
									],
									[
										819737,
										819741
									],
									[
										819811,
										819815
									],
									[
										819967,
										819971
									],
									[
										820027,
										820031
									],
									[
										820312,
										820316
									],
									[
										820452,
										820456
									],
									[
										820550,
										820554
									],
									[
										820613,
										820617
									],
									[
										820660,
										820664
									],
									[
										820707,
										820711
									],
									[
										820763,
										820767
									],
									[
										820781,
										820785
									],
									[
										820817,
										820821
									],
									[
										820835,
										820839
									],
									[
										820870,
										820874
									],
									[
										820888,
										820892
									],
									[
										820924,
										820928
									],
									[
										820977,
										820981
									],
									[
										821067,
										821071
									],
									[
										821076,
										821080
									],
									[
										821085,
										821089
									],
									[
										821238,
										821242
									],
									[
										821375,
										821379
									],
									[
										821508,
										821512
									],
									[
										821642,
										821646
									],
									[
										821800,
										821804
									],
									[
										822029,
										822033
									],
									[
										822061,
										822065
									],
									[
										822272,
										822276
									],
									[
										822304,
										822308
									],
									[
										822515,
										822519
									],
									[
										822547,
										822551
									],
									[
										822763,
										822767
									],
									[
										823060,
										823064
									],
									[
										823119,
										823123
									],
									[
										823178,
										823182
									],
									[
										823371,
										823375
									],
									[
										823622,
										823626
									],
									[
										823674,
										823678
									],
									[
										823726,
										823730
									],
									[
										823882,
										823886
									],
									[
										824012,
										824016
									],
									[
										824142,
										824146
									],
									[
										824316,
										824320
									],
									[
										824326,
										824330
									],
									[
										824341,
										824345
									],
									[
										824352,
										824356
									],
									[
										824384,
										824388
									],
									[
										824459,
										824463
									],
									[
										824502,
										824506
									],
									[
										824512,
										824516
									],
									[
										824527,
										824531
									],
									[
										824538,
										824542
									],
									[
										824570,
										824574
									],
									[
										824645,
										824649
									],
									[
										824688,
										824692
									],
									[
										824698,
										824702
									],
									[
										824713,
										824717
									],
									[
										824724,
										824728
									],
									[
										824756,
										824760
									],
									[
										824831,
										824835
									],
									[
										825064,
										825068
									],
									[
										825074,
										825078
									],
									[
										825084,
										825088
									],
									[
										825330,
										825334
									],
									[
										825547,
										825551
									],
									[
										825847,
										825851
									],
									[
										825904,
										825908
									],
									[
										825961,
										825965
									],
									[
										826261,
										826265
									],
									[
										826407,
										826411
									],
									[
										826507,
										826511
									],
									[
										826607,
										826611
									],
									[
										826727,
										826731
									],
									[
										826844,
										826848
									],
									[
										827083,
										827087
									],
									[
										827212,
										827216
									],
									[
										827445,
										827449
									],
									[
										827668,
										827672
									],
									[
										827834,
										827838
									],
									[
										827862,
										827866
									],
									[
										828011,
										828015
									],
									[
										828197,
										828201
									],
									[
										828491,
										828495
									],
									[
										828698,
										828702
									],
									[
										828768,
										828772
									],
									[
										828801,
										828805
									],
									[
										829054,
										829058
									],
									[
										829129,
										829133
									],
									[
										829154,
										829158
									],
									[
										829179,
										829183
									],
									[
										829457,
										829461
									],
									[
										829751,
										829755
									],
									[
										829831,
										829835
									],
									[
										830077,
										830081
									],
									[
										830088,
										830092
									],
									[
										830496,
										830500
									],
									[
										830931,
										830935
									],
									[
										831113,
										831117
									],
									[
										831350,
										831354
									],
									[
										831368,
										831372
									],
									[
										831547,
										831551
									],
									[
										831657,
										831661
									],
									[
										831938,
										831942
									],
									[
										832088,
										832092
									],
									[
										832389,
										832393
									],
									[
										832839,
										832843
									],
									[
										832974,
										832978
									],
									[
										833141,
										833145
									],
									[
										833325,
										833329
									],
									[
										833539,
										833543
									],
									[
										833802,
										833806
									],
									[
										833977,
										833981
									],
									[
										833989,
										833993
									],
									[
										834159,
										834163
									],
									[
										834177,
										834181
									],
									[
										834354,
										834358
									],
									[
										834450,
										834454
									],
									[
										834544,
										834548
									],
									[
										834753,
										834757
									],
									[
										834765,
										834769
									],
									[
										834945,
										834949
									],
									[
										835178,
										835182
									],
									[
										835422,
										835426
									],
									[
										835467,
										835471
									],
									[
										835614,
										835618
									],
									[
										835878,
										835882
									],
									[
										836176,
										836180
									],
									[
										836449,
										836453
									],
									[
										836760,
										836764
									],
									[
										836916,
										836920
									],
									[
										837045,
										837049
									],
									[
										837140,
										837144
									],
									[
										837347,
										837351
									],
									[
										837455,
										837459
									],
									[
										837573,
										837577
									],
									[
										837625,
										837629
									],
									[
										837767,
										837771
									],
									[
										837904,
										837908
									],
									[
										838014,
										838018
									],
									[
										838193,
										838197
									],
									[
										838629,
										838633
									],
									[
										838933,
										838937
									],
									[
										839180,
										839184
									],
									[
										839323,
										839327
									],
									[
										839398,
										839402
									],
									[
										839594,
										839598
									],
									[
										839708,
										839712
									],
									[
										839916,
										839920
									],
									[
										839953,
										839957
									],
									[
										840333,
										840337
									],
									[
										840668,
										840672
									],
									[
										840749,
										840753
									],
									[
										840999,
										841003
									],
									[
										841219,
										841223
									],
									[
										841310,
										841314
									],
									[
										841656,
										841660
									],
									[
										841991,
										841995
									],
									[
										842200,
										842204
									],
									[
										842312,
										842316
									],
									[
										842330,
										842334
									],
									[
										842540,
										842544
									],
									[
										842862,
										842866
									],
									[
										843081,
										843085
									],
									[
										843306,
										843310
									],
									[
										843615,
										843619
									],
									[
										843717,
										843721
									],
									[
										844059,
										844063
									],
									[
										844494,
										844498
									],
									[
										844676,
										844680
									],
									[
										844995,
										844999
									],
									[
										845222,
										845226
									],
									[
										845369,
										845373
									],
									[
										845561,
										845565
									],
									[
										845618,
										845622
									],
									[
										845861,
										845865
									],
									[
										846225,
										846229
									],
									[
										846453,
										846457
									],
									[
										846685,
										846689
									],
									[
										846747,
										846751
									],
									[
										846970,
										846974
									],
									[
										847437,
										847441
									],
									[
										847580,
										847584
									],
									[
										847712,
										847716
									],
									[
										847786,
										847790
									],
									[
										848068,
										848072
									],
									[
										848356,
										848360
									],
									[
										848546,
										848550
									],
									[
										848678,
										848682
									],
									[
										848752,
										848756
									],
									[
										849034,
										849038
									],
									[
										849310,
										849314
									],
									[
										849637,
										849641
									],
									[
										849807,
										849811
									],
									[
										850145,
										850149
									],
									[
										850496,
										850500
									],
									[
										850741,
										850745
									],
									[
										850960,
										850964
									],
									[
										851151,
										851155
									],
									[
										851326,
										851330
									],
									[
										851683,
										851687
									],
									[
										851826,
										851830
									],
									[
										852015,
										852019
									],
									[
										852173,
										852177
									],
									[
										852357,
										852361
									],
									[
										852552,
										852556
									],
									[
										852725,
										852729
									],
									[
										852883,
										852887
									],
									[
										853047,
										853051
									],
									[
										853110,
										853114
									],
									[
										853336,
										853340
									],
									[
										853669,
										853673
									],
									[
										853864,
										853868
									],
									[
										854053,
										854057
									],
									[
										854281,
										854285
									],
									[
										854451,
										854455
									],
									[
										854620,
										854624
									],
									[
										854823,
										854827
									],
									[
										855100,
										855104
									],
									[
										855226,
										855230
									],
									[
										855322,
										855326
									],
									[
										855392,
										855396
									],
									[
										855527,
										855531
									],
									[
										855662,
										855666
									],
									[
										855948,
										855952
									],
									[
										856021,
										856025
									],
									[
										856094,
										856098
									],
									[
										856352,
										856356
									],
									[
										856534,
										856538
									],
									[
										856595,
										856599
									],
									[
										856656,
										856660
									],
									[
										856877,
										856881
									],
									[
										857308,
										857312
									],
									[
										857484,
										857488
									],
									[
										857816,
										857820
									],
									[
										858051,
										858055
									],
									[
										858759,
										858763
									],
									[
										858965,
										858969
									],
									[
										858987,
										858991
									],
									[
										859121,
										859125
									],
									[
										859374,
										859378
									],
									[
										859585,
										859589
									],
									[
										859839,
										859843
									],
									[
										860163,
										860167
									],
									[
										860185,
										860189
									],
									[
										860245,
										860249
									],
									[
										860318,
										860322
									],
									[
										860591,
										860595
									],
									[
										860938,
										860942
									],
									[
										861082,
										861086
									],
									[
										861451,
										861455
									],
									[
										861877,
										861881
									],
									[
										861907,
										861911
									],
									[
										861972,
										861976
									],
									[
										862046,
										862050
									],
									[
										862323,
										862327
									],
									[
										862534,
										862538
									],
									[
										862811,
										862815
									],
									[
										863177,
										863181
									],
									[
										863417,
										863421
									],
									[
										863923,
										863927
									],
									[
										864065,
										864069
									],
									[
										864275,
										864279
									],
									[
										864490,
										864494
									],
									[
										864797,
										864801
									],
									[
										865028,
										865032
									],
									[
										865295,
										865299
									],
									[
										865528,
										865532
									],
									[
										865812,
										865816
									],
									[
										865834,
										865838
									],
									[
										866218,
										866222
									],
									[
										866429,
										866433
									],
									[
										866654,
										866658
									],
									[
										866844,
										866848
									],
									[
										866894,
										866898
									],
									[
										866986,
										866990
									],
									[
										867273,
										867277
									],
									[
										867546,
										867550
									],
									[
										867568,
										867572
									],
									[
										867716,
										867720
									],
									[
										867959,
										867963
									],
									[
										868196,
										868200
									],
									[
										868218,
										868222
									],
									[
										868291,
										868295
									],
									[
										868433,
										868437
									],
									[
										868655,
										868659
									],
									[
										868767,
										868771
									],
									[
										869207,
										869211
									],
									[
										869403,
										869407
									],
									[
										869433,
										869437
									],
									[
										869671,
										869675
									],
									[
										869829,
										869833
									],
									[
										869896,
										869900
									],
									[
										870124,
										870128
									],
									[
										870390,
										870394
									],
									[
										870441,
										870445
									],
									[
										870549,
										870553
									],
									[
										870771,
										870775
									],
									[
										871023,
										871027
									],
									[
										871384,
										871388
									],
									[
										871464,
										871468
									],
									[
										871546,
										871550
									],
									[
										871661,
										871665
									],
									[
										871872,
										871876
									],
									[
										872267,
										872271
									],
									[
										872482,
										872486
									],
									[
										872633,
										872637
									],
									[
										872672,
										872676
									],
									[
										872964,
										872968
									],
									[
										873113,
										873117
									],
									[
										873142,
										873146
									],
									[
										873493,
										873497
									],
									[
										873516,
										873520
									],
									[
										874018,
										874022
									],
									[
										874113,
										874117
									],
									[
										874455,
										874459
									],
									[
										874552,
										874556
									],
									[
										874651,
										874655
									],
									[
										874945,
										874949
									],
									[
										874965,
										874969
									],
									[
										875509,
										875513
									],
									[
										875599,
										875603
									],
									[
										875661,
										875665
									],
									[
										875722,
										875726
									],
									[
										875921,
										875925
									],
									[
										876062,
										876066
									],
									[
										876101,
										876105
									],
									[
										876421,
										876425
									],
									[
										876570,
										876574
									],
									[
										876599,
										876603
									],
									[
										876856,
										876860
									],
									[
										876886,
										876890
									],
									[
										877024,
										877028
									],
									[
										877214,
										877218
									],
									[
										877432,
										877436
									],
									[
										877462,
										877466
									],
									[
										877616,
										877620
									],
									[
										877835,
										877839
									],
									[
										877857,
										877861
									],
									[
										877925,
										877929
									],
									[
										878054,
										878058
									],
									[
										878344,
										878348
									],
									[
										878687,
										878691
									],
									[
										879069,
										879073
									],
									[
										879167,
										879171
									],
									[
										879227,
										879231
									],
									[
										879282,
										879286
									],
									[
										879479,
										879483
									],
									[
										879678,
										879682
									],
									[
										880167,
										880171
									],
									[
										880191,
										880195
									],
									[
										880232,
										880236
									],
									[
										880277,
										880281
									],
									[
										880506,
										880510
									],
									[
										880679,
										880683
									],
									[
										881130,
										881134
									],
									[
										881446,
										881450
									],
									[
										881485,
										881489
									],
									[
										881693,
										881697
									],
									[
										881739,
										881743
									],
									[
										881756,
										881760
									],
									[
										881877,
										881881
									],
									[
										881896,
										881900
									],
									[
										882004,
										882008
									],
									[
										882034,
										882038
									],
									[
										882150,
										882154
									],
									[
										882221,
										882225
									],
									[
										882241,
										882245
									],
									[
										882506,
										882510
									],
									[
										882662,
										882666
									],
									[
										882842,
										882846
									],
									[
										882980,
										882984
									],
									[
										883060,
										883064
									],
									[
										883234,
										883238
									],
									[
										883279,
										883283
									],
									[
										883704,
										883708
									],
									[
										883757,
										883761
									],
									[
										883900,
										883904
									],
									[
										884035,
										884039
									],
									[
										884405,
										884409
									],
									[
										884449,
										884453
									],
									[
										884797,
										884801
									],
									[
										885004,
										885008
									],
									[
										885156,
										885160
									],
									[
										885515,
										885519
									],
									[
										885599,
										885603
									],
									[
										885682,
										885686
									],
									[
										885788,
										885792
									],
									[
										886096,
										886100
									],
									[
										886240,
										886244
									],
									[
										886456,
										886460
									],
									[
										886557,
										886561
									],
									[
										886708,
										886712
									],
									[
										886770,
										886774
									],
									[
										887169,
										887173
									],
									[
										887231,
										887235
									],
									[
										887334,
										887338
									],
									[
										887435,
										887439
									],
									[
										887796,
										887800
									],
									[
										887983,
										887987
									],
									[
										888005,
										888009
									],
									[
										888117,
										888121
									],
									[
										888292,
										888296
									],
									[
										888490,
										888494
									],
									[
										888512,
										888516
									],
									[
										888569,
										888573
									],
									[
										888650,
										888654
									],
									[
										888705,
										888709
									],
									[
										888835,
										888839
									],
									[
										888894,
										888898
									],
									[
										889018,
										889022
									],
									[
										889186,
										889190
									],
									[
										889263,
										889267
									],
									[
										889533,
										889537
									],
									[
										889730,
										889734
									],
									[
										889760,
										889764
									],
									[
										889821,
										889825
									],
									[
										889880,
										889884
									],
									[
										889945,
										889949
									],
									[
										890021,
										890025
									],
									[
										890093,
										890097
									],
									[
										890177,
										890181
									],
									[
										890240,
										890244
									],
									[
										890274,
										890278
									],
									[
										890290,
										890294
									],
									[
										890323,
										890327
									],
									[
										890604,
										890608
									],
									[
										890868,
										890872
									],
									[
										891127,
										891131
									],
									[
										891256,
										891260
									],
									[
										891528,
										891532
									],
									[
										891573,
										891577
									],
									[
										891936,
										891940
									],
									[
										892345,
										892349
									],
									[
										892658,
										892662
									],
									[
										893121,
										893125
									],
									[
										893610,
										893614
									],
									[
										893641,
										893645
									],
									[
										893672,
										893676
									],
									[
										894028,
										894032
									],
									[
										894059,
										894063
									],
									[
										894090,
										894094
									],
									[
										894404,
										894408
									],
									[
										894426,
										894430
									],
									[
										894496,
										894500
									],
									[
										894668,
										894672
									],
									[
										894887,
										894891
									],
									[
										894909,
										894913
									],
									[
										895005,
										895009
									],
									[
										895101,
										895105
									],
									[
										895286,
										895290
									],
									[
										895514,
										895518
									],
									[
										895680,
										895684
									],
									[
										895763,
										895767
									],
									[
										895880,
										895884
									],
									[
										895950,
										895954
									],
									[
										896032,
										896036
									],
									[
										896152,
										896156
									],
									[
										896455,
										896459
									],
									[
										896505,
										896509
									],
									[
										896565,
										896569
									],
									[
										896620,
										896624
									],
									[
										896773,
										896777
									],
									[
										897016,
										897020
									],
									[
										897068,
										897072
									],
									[
										897099,
										897103
									],
									[
										897185,
										897189
									],
									[
										897237,
										897241
									],
									[
										897268,
										897272
									],
									[
										897604,
										897608
									],
									[
										897680,
										897684
									],
									[
										897711,
										897715
									],
									[
										897932,
										897936
									],
									[
										898008,
										898012
									],
									[
										898039,
										898043
									],
									[
										898235,
										898239
									],
									[
										898533,
										898537
									],
									[
										898804,
										898808
									],
									[
										899022,
										899026
									],
									[
										899141,
										899145
									],
									[
										899402,
										899406
									],
									[
										899752,
										899756
									],
									[
										900176,
										900180
									],
									[
										900589,
										900593
									],
									[
										900844,
										900848
									],
									[
										901160,
										901164
									],
									[
										901467,
										901471
									],
									[
										901698,
										901702
									],
									[
										901977,
										901981
									],
									[
										902297,
										902301
									],
									[
										902617,
										902621
									],
									[
										902945,
										902949
									],
									[
										903212,
										903216
									],
									[
										903508,
										903512
									],
									[
										903711,
										903715
									],
									[
										903929,
										903933
									],
									[
										904144,
										904148
									],
									[
										904444,
										904448
									],
									[
										904861,
										904865
									],
									[
										904907,
										904911
									],
									[
										904940,
										904944
									],
									[
										905031,
										905035
									],
									[
										905178,
										905182
									],
									[
										905539,
										905543
									],
									[
										905904,
										905908
									],
									[
										906107,
										906111
									],
									[
										906303,
										906307
									],
									[
										906499,
										906503
									],
									[
										906754,
										906758
									],
									[
										907029,
										907033
									],
									[
										907082,
										907086
									],
									[
										907362,
										907366
									],
									[
										907503,
										907507
									],
									[
										907759,
										907763
									],
									[
										907817,
										907821
									],
									[
										907872,
										907876
									],
									[
										907922,
										907926
									],
									[
										907977,
										907981
									],
									[
										908190,
										908194
									],
									[
										908391,
										908395
									],
									[
										908712,
										908716
									],
									[
										908768,
										908772
									],
									[
										908912,
										908916
									],
									[
										909017,
										909021
									],
									[
										909249,
										909253
									],
									[
										909473,
										909477
									],
									[
										909695,
										909699
									],
									[
										909811,
										909815
									],
									[
										910011,
										910015
									],
									[
										910167,
										910171
									],
									[
										910211,
										910215
									],
									[
										910359,
										910363
									],
									[
										910551,
										910555
									],
									[
										910899,
										910903
									],
									[
										911264,
										911268
									],
									[
										911499,
										911503
									],
									[
										911792,
										911796
									],
									[
										912051,
										912055
									],
									[
										912217,
										912221
									],
									[
										912262,
										912266
									],
									[
										912454,
										912458
									],
									[
										912620,
										912624
									],
									[
										912851,
										912855
									],
									[
										912878,
										912882
									],
									[
										912992,
										912996
									],
									[
										913074,
										913078
									],
									[
										913216,
										913220
									],
									[
										913314,
										913318
									],
									[
										913530,
										913534
									],
									[
										913762,
										913766
									],
									[
										914011,
										914015
									],
									[
										914234,
										914238
									],
									[
										914532,
										914536
									],
									[
										914841,
										914845
									],
									[
										915007,
										915011
									],
									[
										915264,
										915268
									],
									[
										915393,
										915397
									],
									[
										915649,
										915653
									],
									[
										916045,
										916049
									],
									[
										916382,
										916386
									],
									[
										916444,
										916448
									],
									[
										916769,
										916773
									],
									[
										917048,
										917052
									],
									[
										917279,
										917283
									],
									[
										917572,
										917576
									],
									[
										917704,
										917708
									],
									[
										917727,
										917731
									],
									[
										918035,
										918039
									],
									[
										918123,
										918127
									],
									[
										918429,
										918433
									],
									[
										918620,
										918624
									],
									[
										918909,
										918913
									],
									[
										918963,
										918967
									],
									[
										919246,
										919250
									],
									[
										919328,
										919332
									],
									[
										919419,
										919423
									],
									[
										919657,
										919661
									],
									[
										919952,
										919956
									],
									[
										920105,
										920109
									],
									[
										920259,
										920263
									],
									[
										920504,
										920508
									],
									[
										920737,
										920741
									],
									[
										921055,
										921059
									],
									[
										921165,
										921169
									],
									[
										921406,
										921410
									],
									[
										921648,
										921652
									],
									[
										921962,
										921966
									],
									[
										922054,
										922058
									],
									[
										922292,
										922296
									],
									[
										922461,
										922465
									],
									[
										922727,
										922731
									],
									[
										922873,
										922877
									],
									[
										922994,
										922998
									],
									[
										923186,
										923190
									],
									[
										923358,
										923362
									],
									[
										923637,
										923641
									],
									[
										923846,
										923850
									],
									[
										924007,
										924011
									],
									[
										924097,
										924101
									],
									[
										924326,
										924330
									],
									[
										924516,
										924520
									],
									[
										924842,
										924846
									],
									[
										925029,
										925033
									],
									[
										925312,
										925316
									],
									[
										925437,
										925441
									],
									[
										925610,
										925614
									],
									[
										925699,
										925703
									],
									[
										925873,
										925877
									],
									[
										925923,
										925927
									],
									[
										926124,
										926128
									],
									[
										926482,
										926486
									],
									[
										926629,
										926633
									],
									[
										926837,
										926841
									],
									[
										926946,
										926950
									],
									[
										927239,
										927243
									],
									[
										927436,
										927440
									],
									[
										927526,
										927530
									],
									[
										927655,
										927659
									],
									[
										927869,
										927873
									],
									[
										928072,
										928076
									],
									[
										928255,
										928259
									],
									[
										928442,
										928446
									],
									[
										928811,
										928815
									],
									[
										929195,
										929199
									],
									[
										929398,
										929402
									],
									[
										929855,
										929859
									],
									[
										930265,
										930269
									],
									[
										930493,
										930497
									],
									[
										930738,
										930742
									],
									[
										930941,
										930945
									],
									[
										931171,
										931175
									],
									[
										931495,
										931499
									],
									[
										931840,
										931844
									],
									[
										932089,
										932093
									],
									[
										932367,
										932371
									],
									[
										932550,
										932554
									],
									[
										932714,
										932718
									],
									[
										932970,
										932974
									],
									[
										933290,
										933294
									],
									[
										933495,
										933499
									],
									[
										933675,
										933679
									],
									[
										933879,
										933883
									],
									[
										934184,
										934188
									],
									[
										934424,
										934428
									],
									[
										934707,
										934711
									],
									[
										934973,
										934977
									],
									[
										935250,
										935254
									],
									[
										935443,
										935447
									],
									[
										935706,
										935710
									],
									[
										935983,
										935987
									],
									[
										936206,
										936210
									],
									[
										936488,
										936492
									],
									[
										936824,
										936828
									],
									[
										937088,
										937092
									],
									[
										937374,
										937378
									],
									[
										937754,
										937758
									],
									[
										937950,
										937954
									],
									[
										938218,
										938222
									],
									[
										938457,
										938461
									],
									[
										938815,
										938819
									],
									[
										939092,
										939096
									],
									[
										939358,
										939362
									],
									[
										939694,
										939698
									],
									[
										940009,
										940013
									],
									[
										940389,
										940393
									],
									[
										940585,
										940589
									],
									[
										940870,
										940874
									],
									[
										940977,
										940981
									],
									[
										941311,
										941315
									],
									[
										941391,
										941395
									],
									[
										941422,
										941426
									],
									[
										941646,
										941650
									],
									[
										941726,
										941730
									],
									[
										941757,
										941761
									],
									[
										941974,
										941978
									],
									[
										942248,
										942252
									],
									[
										942584,
										942588
									],
									[
										942609,
										942613
									],
									[
										942753,
										942757
									],
									[
										942778,
										942782
									],
									[
										942831,
										942835
									],
									[
										942860,
										942864
									],
									[
										943068,
										943072
									],
									[
										943346,
										943350
									],
									[
										943464,
										943468
									],
									[
										943521,
										943525
									],
									[
										943888,
										943893
									],
									[
										943934,
										943939
									],
									[
										944094,
										944099
									],
									[
										944375,
										944380
									],
									[
										944680,
										944685
									],
									[
										944752,
										944757
									],
									[
										944855,
										944860
									],
									[
										944900,
										944905
									],
									[
										945089,
										945094
									],
									[
										945294,
										945299
									]
								],
								"scope": ""
							}
						},
						"selection":
						[
							[
								943702,
								943702
							]
						],
						"settings":
						{
							"detect_indentation": false,
							"line_numbers": false,
							"output_tag": 14,
							"result_base_dir": "",
							"result_file_regex": "^([^ \t].*):$",
							"result_line_regex": "^ +([0-9]+):",
							"scroll_past_end": true,
							"syntax": "Packages/Default/Find Results.hidden-tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 353056.0,
						"zoom_level": 1.0
					},
					"stack_index": 18,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "src/Falcor/RenderGraph/RenderPassStandardFlags.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2479,
						"regions":
						{
						},
						"selection":
						[
							[
								2215,
								2215
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 160.0,
						"zoom_level": 1.0
					},
					"stack_index": 24,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "src/Falcor/Core/API/Vulkan/VKTexture.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7857,
						"regions":
						{
						},
						"selection":
						[
							[
								1889,
								1889
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 255.0,
						"zoom_level": 1.0
					},
					"stack_index": 30,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "src/Falcor/Core/Platform/OS.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8922,
						"regions":
						{
						},
						"selection":
						[
							[
								5955,
								5955
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2421.0,
						"zoom_level": 1.0
					},
					"stack_index": 39,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "src/Falcor/Core/Platform/OS.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15995,
						"regions":
						{
						},
						"selection":
						[
							[
								9532,
								9532
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3534.0,
						"zoom_level": 1.0
					},
					"stack_index": 41,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "src/Falcor/Core/Platform/Linux/Linux.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15074,
						"regions":
						{
						},
						"selection":
						[
							[
								7478,
								7478
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3162.0,
						"zoom_level": 1.0
					},
					"stack_index": 40,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "src/Falcor/Core/Program/ProgramVersion.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8172,
						"regions":
						{
						},
						"selection":
						[
							[
								8120,
								8120
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2693.0,
						"zoom_level": 1.0
					},
					"stack_index": 38,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "src/Falcor/Core/Program/Program.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 34652,
						"regions":
						{
						},
						"selection":
						[
							[
								31930,
								31930
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 13013.0,
						"zoom_level": 1.0
					},
					"stack_index": 36,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "src/Falcor/Utils/UI/Gui.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 57140,
						"regions":
						{
						},
						"selection":
						[
							[
								41072,
								41072
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 12862.0,
						"zoom_level": 1.0
					},
					"stack_index": 15,
					"type": "text"
				},
				{
					"buffer": 10,
					"file": "third_party/slang/slang.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 132132,
						"regions":
						{
						},
						"selection":
						[
							[
								22600,
								22600
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 11686.0,
						"zoom_level": 1.0
					},
					"stack_index": 37,
					"type": "text"
				},
				{
					"buffer": 11,
					"file": "src/Falcor/Core/Sample.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 25381,
						"regions":
						{
						},
						"selection":
						[
							[
								11181,
								11181
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 8160.0,
						"zoom_level": 1.0
					},
					"stack_index": 16,
					"type": "text"
				},
				{
					"buffer": 12,
					"file": "src/Falcor/Core/API/FBO.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13546,
						"regions":
						{
						},
						"selection":
						[
							[
								10599,
								10599
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3084.0,
						"zoom_level": 1.0
					},
					"stack_index": 35,
					"type": "text"
				},
				{
					"buffer": 13,
					"file": "src/Falcor/Core/API/FBO.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 18222,
						"regions":
						{
						},
						"selection":
						[
							[
								9617,
								9617
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3381.0,
						"zoom_level": 1.0
					},
					"stack_index": 26,
					"type": "text"
				},
				{
					"buffer": 14,
					"file": "src/Falcor/Core/API/Vulkan/VKFbo.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5790,
						"regions":
						{
						},
						"selection":
						[
							[
								4966,
								4966
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 789.0,
						"zoom_level": 1.0
					},
					"stack_index": 25,
					"type": "text"
				},
				{
					"buffer": 15,
					"file": "src/Falcor/Core/API/Texture.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 16621,
						"regions":
						{
						},
						"selection":
						[
							[
								10897,
								10897
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2873.0,
						"zoom_level": 1.0
					},
					"stack_index": 32,
					"type": "text"
				},
				{
					"buffer": 16,
					"file": "src/Falcor/Core/API/ResourceViews.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9621,
						"regions":
						{
						},
						"selection":
						[
							[
								8152,
								8152
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2271.0,
						"zoom_level": 1.0
					},
					"stack_index": 33,
					"type": "text"
				},
				{
					"buffer": 17,
					"file": "src/Falcor/Core/API/Vulkan/VKResourceViews.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13548,
						"regions":
						{
						},
						"selection":
						[
							[
								6809,
								6809
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2227.0,
						"zoom_level": 1.0
					},
					"stack_index": 31,
					"type": "text"
				},
				{
					"buffer": 18,
					"file": "src/Falcor/Core/API/ResourceViews.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5611,
						"regions":
						{
						},
						"selection":
						[
							[
								2490,
								2490
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 333.0,
						"zoom_level": 1.0
					},
					"stack_index": 34,
					"type": "text"
				},
				{
					"buffer": 19,
					"file": "src/Falcor/Core/API/Device.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 18398,
						"regions":
						{
						},
						"selection":
						[
							[
								7714,
								7714
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 6130.0,
						"zoom_level": 1.0
					},
					"stack_index": 20,
					"type": "text"
				},
				{
					"buffer": 20,
					"file": "src/Falcor/Core/API/Vulkan/VKDevice.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 30042,
						"regions":
						{
						},
						"selection":
						[
							[
								5538,
								5538
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1902.0,
						"zoom_level": 1.0
					},
					"stack_index": 27,
					"type": "text"
				},
				{
					"buffer": 21,
					"file": "src/Falcor/Core/API/Formats.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13822,
						"regions":
						{
						},
						"selection":
						[
							[
								3523,
								3523
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1316.0,
						"zoom_level": 1.0
					},
					"stack_index": 28,
					"type": "text"
				},
				{
					"buffer": 22,
					"file": "src/Falcor/Core/API/Vulkan/VKBuffer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6579,
						"regions":
						{
						},
						"selection":
						[
							[
								2495,
								2495
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 58.0,
						"zoom_level": 1.0
					},
					"stack_index": 29,
					"type": "text"
				},
				{
					"buffer": 23,
					"file": "src/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 491,
						"regions":
						{
						},
						"selection":
						[
							[
								445,
								445
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 43,
					"type": "text"
				},
				{
					"buffer": 24,
					"file": "src/Mogwai/Mogwai.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 25155,
						"regions":
						{
						},
						"selection":
						[
							[
								19298,
								19298
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 5600.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 25,
					"file": "src/Falcor/Utils/Scripting/Scripting.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5902,
						"regions":
						{
						},
						"selection":
						[
							[
								5453,
								5453
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 194.0,
						"zoom_level": 1.0
					},
					"stack_index": 22,
					"type": "text"
				},
				{
					"buffer": 26,
					"file": "src/Falcor/RenderGraph/RenderGraphExe.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4072,
						"regions":
						{
						},
						"selection":
						[
							[
								1991,
								1991
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 143.0,
						"zoom_level": 1.0
					},
					"stack_index": 23,
					"type": "text"
				},
				{
					"buffer": 27,
					"file": "src/Falcor/Core/Renderer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7238,
						"regions":
						{
						},
						"selection":
						[
							[
								7168,
								7168
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2642.0,
						"zoom_level": 1.0
					},
					"stack_index": 19,
					"type": "text"
				},
				{
					"buffer": 28,
					"file": "src/Mogwai/Mogwai.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8364,
						"regions":
						{
						},
						"selection":
						[
							[
								1851,
								1851
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2550.0,
						"zoom_level": 1.0
					},
					"stack_index": 17,
					"type": "text"
				},
				{
					"buffer": 29,
					"file": "src/Falcor/Core/API/Device.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11497,
						"regions":
						{
						},
						"selection":
						[
							[
								7350,
								7350
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2259.0,
						"zoom_level": 1.0
					},
					"stack_index": 21,
					"type": "text"
				},
				{
					"buffer": 30,
					"file": "src/lava_lib/renderer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10319,
						"regions":
						{
						},
						"selection":
						[
							[
								948,
								948
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 51.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 31,
					"file": "src/lava_cmd/conf/default.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1458,
						"regions":
						{
						},
						"selection":
						[
							[
								1412,
								1412
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 32,
					"file": "src/lava_lib/renderer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4559,
						"regions":
						{
						},
						"selection":
						[
							[
								948,
								948
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 612.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 33,
					"file": "src/lava_lib/renderer_scripting.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4793,
						"regions":
						{
						},
						"selection":
						[
							[
								2464,
								2464
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 571.0,
						"zoom_level": 1.0
					},
					"stack_index": 14,
					"type": "text"
				},
				{
					"buffer": 34,
					"file": "src/lava_lib/scene_reader_base.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1301,
						"regions":
						{
						},
						"selection":
						[
							[
								564,
								564
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 11,
					"type": "text"
				},
				{
					"buffer": 35,
					"file": "src/lava_lib/scene_reader_base.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1003,
						"regions":
						{
						},
						"selection":
						[
							[
								165,
								165
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 36,
					"file": "src/lava_lib/renderer_iface.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 899,
						"regions":
						{
						},
						"selection":
						[
							[
								370,
								370
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 12,
					"type": "text"
				},
				{
					"buffer": 37,
					"file": "src/lava_lib/renderer_iface.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1344,
						"regions":
						{
						},
						"selection":
						[
							[
								235,
								235
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 38,
					"file": "src/lava_lib/readers/lsd_visitor.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1855,
						"regions":
						{
						},
						"selection":
						[
							[
								474,
								474
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				},
				{
					"buffer": 39,
					"file": "src/lava_lib/readers/renderer_iface_lsd.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 801,
						"regions":
						{
						},
						"selection":
						[
							[
								267,
								267
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 10,
					"type": "text"
				},
				{
					"buffer": 40,
					"file": "src/lava_lib/readers/renderer_iface_lsd.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2379,
						"regions":
						{
						},
						"selection":
						[
							[
								2282,
								2282
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 714.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 41,
					"file": "src/lava_lib/readers/reader_lsd.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2997,
						"regions":
						{
						},
						"selection":
						[
							[
								455,
								455
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 42,
					"file": "src/lava_lib/readers/grammar_lsd.h",
					"semi_transient": true,
					"settings":
					{
						"buffer_size": 25150,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 5814.0,
						"zoom_level": 1.0
					},
					"stack_index": 13,
					"type": "text"
				},
				{
					"buffer": 43,
					"file": "src/lava_lib/readers/reader_lsd.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1537,
						"regions":
						{
						},
						"selection":
						[
							[
								589,
								589
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 38.0
	},
	"input":
	{
		"height": 40.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.SublimeLinter":
	{
		"height": 0.0
	},
	"output.find_results":
	{
		"height": 120.0
	},
	"output.unsaved_changes":
	{
		"height": 120.0
	},
	"pinned_build_system": "Packages/Makefile/Make.sublime-build",
	"project": "falcor.sublime-project",
	"replace":
	{
		"height": 70.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 362.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
