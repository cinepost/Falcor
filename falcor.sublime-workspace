{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"array",
				"array_t"
			],
			[
				"value",
				"value_t"
			],
			[
				"valu",
				"value_t"
			],
			[
				"num",
				"number_t"
			],
			[
				"std",
				"stdin"
			],
			[
				"as",
				"assign_array_value"
			],
			[
				"arr",
				"array"
			],
			[
				"va",
				"variant"
			],
			[
				"re",
				"return"
			],
			[
				"pars",
				"parser_ok"
			],
			[
				"parse",
				"parser_fail"
			],
			[
				"in",
				"input"
			],
			[
				"vec",
				"vector2"
			],
			[
				"vectr",
				"vector4"
			],
			[
				"assign",
				"assign_prop_value"
			],
			[
				"pro",
				"prop_name"
			],
			[
				"Re",
				"RendererIfaceBase"
			],
			[
				"str",
				"string"
			],
			[
				"q",
				"quoted_string"
			],
			[
				"vect",
				"vector\tstd::vector"
			],
			[
				"vector",
				"vector2"
			],
			[
				"Vec",
				"Vector4"
			],
			[
				"Ve",
				"Vector4"
			],
			[
				"ass",
				"assign_prop_value"
			],
			[
				"pa",
				"parsed_percent"
			],
			[
				"ve",
				"vector\tstd::vector"
			],
			[
				"V",
				"Vector2"
			],
			[
				"tep",
				"typedef"
			],
			[
				"any",
				"any_string"
			],
			[
				"o",
				"object"
			],
			[
				"an",
				"any_string"
			],
			[
				"stat",
				"static_vector"
			],
			[
				"ge",
				"geometry_object"
			],
			[
				"min",
				"minor"
			],
			[
				"assi",
				"assign_time"
			],
			[
				"T",
				"T"
			],
			[
				"file",
				"filename"
			],
			[
				"ma",
				"matrix"
			],
			[
				"cmd_",
				"cmd_transform"
			],
			[
				"cmd",
				"cmd_transform"
			],
			[
				"GE",
				"GEOMERTY"
			],
			[
				"G",
				"GEO"
			],
			[
				"Com",
				"commands"
			],
			[
				"BOO",
				"BOOST_FUSION_ADAPT_STRUCT"
			],
			[
				"comm",
				"comment"
			],
			[
				"s",
				"struct\tstruct"
			],
			[
				"en",
				"env_variable"
			],
			[
				"set",
				"setenv"
			],
			[
				"cmd_r",
				"cmd_raytrace"
			],
			[
				"cm",
				"cmd_time"
			],
			[
				"li",
				"lineCommentRule1"
			],
			[
				"get",
				"getBufferStartIndex"
			],
			[
				"siz",
				"size"
			],
			[
				"size",
				"size_t"
			],
			[
				"last",
				"_lastChar"
			],
			[
				"U",
				"UnbufferedCharStream"
			],
			[
				"fa",
				"false"
			],
			[
				"Reade",
				"ReaderBase"
			],
			[
				"lava",
				"lava_lib"
			],
			[
				"beg",
				"begin"
			],
			[
				"pri",
				"private"
			],
			[
				"P",
				"ParserLSD"
			],
			[
				"dri",
				"driver_name"
			],
			[
				"dr",
				"driver_name"
			],
			[
				"D",
				"Display"
			],
			[
				"Ds",
				"DspyImageClose"
			],
			[
				"l",
				"lib_handle"
			],
			[
				"ech",
				"echo"
			],
			[
				"op",
				"optarg"
			],
			[
				"read",
				"read_stdin"
			],
			[
				"light",
				"lightlist"
			],
			[
				"obj",
				"objlist"
			],
			[
				"vi",
				"virtual"
			],
			[
				"sc",
				"sceneFileDefault"
			],
			[
				"sce",
				"sceneFileName"
			],
			[
				"Di",
				"DisplayRenderBuffer"
			],
			[
				"fr",
				"frameBufferDirty"
			],
			[
				"run",
				"runScript"
			],
			[
				"SC",
				"SCRIPT_BINDING"
			],
			[
				"HdL",
				"HdLavaRenderPass"
			],
			[
				"la",
				"lastErrorMessageSize"
			],
			[
				"cstd",
				"cstddef\tstandard header"
			],
			[
				"ret",
				"return"
			],
			[
				"cre",
				"create2D"
			],
			[
				"pO",
				"pOutTex"
			],
			[
				"uint",
				"uint32_t"
			],
			[
				"ui",
				"uint32_t"
			],
			[
				"pT",
				"pTargetFbo"
			],
			[
				"mpDe",
				"mpDevice"
			],
			[
				"res",
				"resourceFormat"
			],
			[
				"tex",
				"textureData"
			],
			[
				"ar",
				"arraySlice"
			],
			[
				"mi",
				"mipLevel"
			],
			[
				"ren",
				"renderFrame"
			],
			[
				"dev",
				"device"
			],
			[
				"pC",
				"pContext"
			],
			[
				"getRe",
				"getRenderContext"
			],
			[
				"DE",
				"Device"
			],
			[
				"pr",
				"printf\tprintf â€¦"
			],
			[
				"de",
				"device"
			],
			[
				"inc",
				"include"
			],
			[
				"mp",
				"mpWindow"
			],
			[
				"Device",
				"DeviceManager"
			],
			[
				"Devi",
				"DeviceManger"
			],
			[
				"p",
				"pDevice"
			],
			[
				"Dev",
				"DeviceID"
			],
			[
				"De",
				"DeviceID"
			],
			[
				"name",
				"namespace"
			],
			[
				"crea",
				"createInstance"
			],
			[
				"un",
				"unordered_map\tstandard header (since c++11)"
			],
			[
				"i",
				"instance"
			],
			[
				"_",
				"_gpDevice"
			],
			[
				"R",
				"RenderGraph"
			],
			[
				"Rend",
				"RenderGraph"
			],
			[
				"def",
				"default"
			],
			[
				"LOG",
				"LOG_WARN"
			],
			[
				"sha",
				"shared_from_this"
			],
			[
				"swap",
				"swapchain"
			],
			[
				"LO",
				"LOG_ERR"
			],
			[
				"VK",
				"VkResource"
			],
			[
				"gN",
				"gNullBufferViews"
			],
			[
				"flat",
				"flatIndex"
			],
			[
				"GBu",
				"GBufferBase"
			],
			[
				"Render",
				"RenderPasses"
			],
			[
				"Ren",
				"RenderPasses"
			],
			[
				"uin",
				"uint8_t"
			],
			[
				"pRe",
				"pRenderContext"
			],
			[
				"c",
				"ctx"
			]
		]
	},
	"buffers":
	[
		{
			"file": "src/Falcor/Core/API/D3D12/D3D12ResourceViews.cpp",
			"settings":
			{
				"buffer_size": 18914,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "Searching 1339 files for \"Can't add new modules after the interpreter has been initialized\" (case sensitive)\n\n0 matches\n\nSearching 1339 files for \"Scripting::start\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/Sample.cpp:\n  607  \n  608      void Sample::startScripting() {\n  609:         Scripting::start();\n  610          auto bindFunc = [this](ScriptBindings::Module& m) { this->registerScriptBindings(m); };\n  611          ScriptBindings::registerBinding(bindFunc);\n\n/home/max/dev/Falcor/src/Falcor/Utils/Scripting/Scripting.cpp:\n   82  }\n   83  \n   84: bool Scripting::start() {\n   85:     LOG_DBG(\"Scripting::start()\");\n   86      if (!sRunning) {\n   87          sRunning = true;\n   ..\n   99          }\n  100      }\n  101:     LOG_DBG(\"Scripting::start() done!\");\n  102      return true;\n  103  }\n\n4 matches across 2 files\n\n\nSearching 50606 files for \"Can't add new modules after the interpreter has been initialized\" (case sensitive)\n\n/opt/USD/lib/libassimp.so.5:\n    File too large, skipping\n\n/opt/USD/lib/libassimp.so.5.0.0:\n    File too large, skipping\n\n/opt/USD/src/boost_1_61_0.tar.gz:\n    File too large, skipping\n\n0 matches\n\nSearching 458 files for \"initialize_interpreter\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Utils/Scripting/Scripting.cpp:\n   93  \n   94          try {\n   95:             pybind11::initialize_interpreter();\n   96              pybind11::exec(\"from falcor import *\");\n   97          } catch (const std::exception& e) {\n\n1 match in 1 file\n\n\nSearching 458 files for \"pybind11\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Device.cpp:\n  383      graphClass.func_(\"getPass\", &RenderGraph::getPass, \"name\"_a);\n  384      graphClass.func_(\"getOutput\", ScriptBindings::overload_cast<const std::string&>(&RenderGraph::getOutput), \"name\"_a);\n  385:     auto printGraph = [](RenderGraph::SharedPtr pGraph) { pybind11::print(RenderGraphExporter::getIR(pGraph)); };\n  386      graphClass.func_(\"print\", printGraph);\n  387  \n  ...\n  390  \n  391      // RenderPassLibrary\n  392:     const auto& createRenderPass = [](std::shared_ptr<Device> device, const std::string& passName, pybind11::dict d = {}) {\n  393          auto pPass = RenderPassLibrary::instance().createPass(device->getRenderContext(), passName.c_str(), Dictionary(d));\n  394          if (!pPass) { \n  ...\n  397          return pPass;\n  398      };\n  399:     passClass.ctor(createRenderPass, \"device\"_a, \"name\"_a, \"dict\"_a = pybind11::dict());\n  400  \n  401      const auto& loadPassLibrary = [](const std::string& library) {\n  ...\n  405      m.func_(RenderGraphIR::kLoadPassLibrary, loadPassLibrary, \"name\"_a);\n  406  \n  407:     const auto& updateRenderPass = [](std::shared_ptr<Device> device, const RenderGraph::SharedPtr& pGraph, const std::string& passName, pybind11::dict d) {\n  408          pGraph->updatePass(device->getRenderContext(), passName, Dictionary(d));\n  409      };\n\n/home/max/dev/Falcor/src/Falcor/Core/API/DeviceManager.cpp:\n   26   # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n   27   **************************************************************************/\n   28: #include <pybind11/pybind11.h>\n   29  \n   30  #include \"Falcor/stdafx.h\"\n   ..\n   34  \n   35  \n   36: namespace py = pybind11;\n   37  \n   38  namespace Falcor {\n\n/home/max/dev/Falcor/src/Falcor/dependencies.xml:\n   41          <package name=\"python\" version=\"3.7.0-windows-x64\" platforms=\"win\" />\n   42      </dependency>\n   43:     <dependency name=\"pybind11\" linkPath=\"../Externals/.packman/pybind11\">\n   44:         <package name=\"pybind11\" version=\"2.2.4\" />\n   45      </dependency>\n   46  </project>\n\n/home/max/dev/Falcor/src/Falcor/Falcor.props:\n   15        <WarningLevel>Level3</WarningLevel>\n   16        <TreatWarningAsError>true</TreatWarningAsError>\n   17:       <AdditionalIncludeDirectories>$(FALCOR_CORE_DIRECTORY)\\Falcor;$(FALCOR_CORE_DIRECTORY)\\Externals\\.packman\\nvapi;$(FALCOR_CORE_DIRECTORY)\\Externals\\.packman\\GLM;$(FALCOR_CORE_DIRECTORY)\\Externals\\.packman\\VulkanSDK\\Include;$(FALCOR_CORE_DIRECTORY)\\Externals\\.packman\\RapidJson\\include;$(FALCOR_CORE_DIRECTORY)\\Externals\\.packman\\pybind11\\include;$(FALCOR_CORE_DIRECTORY)\\Externals\\.packman\\Python\\include;$(FALCOR_CORE_DIRECTORY)\\Externals\\.packman\\WinPixEventRuntime\\Include\\WinPixEventRuntime;$(FALCOR_CORE_DIRECTORY)\\Externals;$(FALCOR_CORE_DIRECTORY)\\Externals\\.packman;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n   18        <PreprocessorDefinitions>_$(OutputType);_CRT_SECURE_NO_WARNINGS;_SCL_SECURE_NO_WARNINGS;GLM_FORCE_DEPTH_ZERO_TO_ONE;$(FALCOR_BACKEND);_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n   19        <LanguageStandard>stdcpp17</LanguageStandard>\n\n/home/max/dev/Falcor/src/Falcor/Falcor.vcxproj:\n  778        <Optimization>Disabled</Optimization>\n  779        <PreprocessorDefinitions>FALCOR_DLL;IMGUI_API=__declspec(dllexport);_PROJECT_DIR_=R\"($(ProjectDir))\";_SCL_SECURE_NO_WARNINGS;_CRT_SECURE_NO_WARNINGS;FALCOR_D3D12;WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions);GLM_FORCE_DEPTH_ZERO_TO_ONE;_$(OutputType)</PreprocessorDefinitions>\n  780:       <AdditionalIncludeDirectories>$(ProjectDir);$(ProjectDir)\\..\\Externals\\.packman\\GLM;$(ProjectDir)\\..\\Externals\\.packman\\GLFW\\include;$(ProjectDir)\\..\\Externals\\.packman\\FreeImage;$(ProjectDir)\\..\\Externals\\.packman\\ASSIMP\\include;$(ProjectDir)\\..\\Externals\\.packman\\FFMpeg\\include;$(ProjectDir)\\..\\Externals\\.packman\\RapidJson\\include;$(ProjectDir)\\..\\Externals\\.packman\\VulkanSDK\\Include;$(ProjectDir)\\..\\Externals\\.packman\\Python\\Include;$(ProjectDir)\\..\\Externals\\.packman\\pybind11\\include;$(ProjectDir)\\..\\Externals\\;$(ProjectDir)\\..\\Externals\\.packman\\nvapi;$(ProjectDir)\\..\\Externals\\.packman</AdditionalIncludeDirectories>\n  781        <TreatWarningAsError>true</TreatWarningAsError>\n  782        <MultiProcessorCompilation>true</MultiProcessorCompilation>\n  ...\n  816        <Optimization>Disabled</Optimization>\n  817        <PreprocessorDefinitions>FALCOR_DLL;IMGUI_API=__declspec(dllexport);_PROJECT_DIR_=R\"($(ProjectDir))\";_SCL_SECURE_NO_WARNINGS;_CRT_SECURE_NO_WARNINGS;FALCOR_VK;WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions);GLM_FORCE_DEPTH_ZERO_TO_ONE</PreprocessorDefinitions>\n  818:       <AdditionalIncludeDirectories>$(ProjectDir);$(ProjectDir)\\..\\Externals\\.packman\\GLM;$(ProjectDir)\\..\\Externals\\.packman\\GLFW\\include;$(ProjectDir)\\..\\Externals\\.packman\\FreeImage;$(ProjectDir)\\..\\Externals\\.packman\\ASSIMP\\include;$(ProjectDir)\\..\\Externals\\.packman\\FFMpeg\\include;$(ProjectDir)\\..\\Externals\\.packman\\RapidJson\\include;$(ProjectDir)\\..\\Externals\\.packman\\VulkanSDK\\Include;$(ProjectDir)\\..\\Externals\\.packman\\Python\\Include;$(ProjectDir)\\..\\Externals\\.packman\\pybind11\\include;$(ProjectDir)\\..\\Externals\\;$(ProjectDir)\\..\\Externals\\.packman\\nvapi;$(ProjectDir)\\..\\Externals\\.packman</AdditionalIncludeDirectories>\n  819        <TreatWarningAsError>true</TreatWarningAsError>\n  820        <MultiProcessorCompilation>true</MultiProcessorCompilation>\n  ...\n  857        <IntrinsicFunctions>true</IntrinsicFunctions>\n  858        <PreprocessorDefinitions>FALCOR_DLL;IMGUI_API=__declspec(dllexport);_PROJECT_DIR_=R\"($(ProjectDir))\";_SCL_SECURE_NO_WARNINGS;_CRT_SECURE_NO_WARNINGS;FALCOR_D3D12;WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions);GLM_FORCE_DEPTH_ZERO_TO_ONE</PreprocessorDefinitions>\n  859:       <AdditionalIncludeDirectories>$(ProjectDir);$(ProjectDir)\\..\\Externals\\.packman\\GLM;$(ProjectDir)\\..\\Externals\\.packman\\GLFW\\include;$(ProjectDir)\\..\\Externals\\.packman\\FreeImage;$(ProjectDir)\\..\\Externals\\.packman\\ASSIMP\\include;$(ProjectDir)\\..\\Externals\\.packman\\FFMpeg\\include;$(ProjectDir)\\..\\Externals\\.packman\\RapidJson\\include;$(ProjectDir)\\..\\Externals\\.packman\\VulkanSDK\\Include;$(ProjectDir)\\..\\Externals\\.packman\\Python\\Include;$(ProjectDir)\\..\\Externals\\.packman\\pybind11\\include;$(ProjectDir)\\..\\Externals\\;$(ProjectDir)\\..\\Externals\\.packman\\nvapi;$(ProjectDir)\\..\\Externals\\.packman</AdditionalIncludeDirectories>\n  860        <TreatWarningAsError>true</TreatWarningAsError>\n  861        <MultiProcessorCompilation>true</MultiProcessorCompilation>\n  ...\n  899        <IntrinsicFunctions>true</IntrinsicFunctions>\n  900        <PreprocessorDefinitions>FALCOR_DLL;IMGUI_API=__declspec(dllexport);_PROJECT_DIR_=R\"($(ProjectDir))\";_SCL_SECURE_NO_WARNINGS;_CRT_SECURE_NO_WARNINGS;FALCOR_VK;WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions);GLM_FORCE_DEPTH_ZERO_TO_ONE</PreprocessorDefinitions>\n  901:       <AdditionalIncludeDirectories>$(ProjectDir);$(ProjectDir)\\..\\Externals\\.packman\\GLM;$(ProjectDir)\\..\\Externals\\.packman\\GLFW\\include;$(ProjectDir)\\..\\Externals\\.packman\\FreeImage;$(ProjectDir)\\..\\Externals\\.packman\\ASSIMP\\include;$(ProjectDir)\\..\\Externals\\.packman\\FFMpeg\\include;$(ProjectDir)\\..\\Externals\\.packman\\RapidJson\\include;$(ProjectDir)\\..\\Externals\\.packman\\VulkanSDK\\Include;$(ProjectDir)\\..\\Externals\\.packman\\Python\\Include;$(ProjectDir)\\..\\Externals\\.packman\\pybind11\\include;$(ProjectDir)\\..\\Externals\\;$(ProjectDir)\\..\\Externals\\.packman\\nvapi;$(ProjectDir)\\..\\Externals\\.packman</AdditionalIncludeDirectories>\n  902        <TreatWarningAsError>true</TreatWarningAsError>\n  903        <MultiProcessorCompilation>true</MultiProcessorCompilation>\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraph.cpp:\n  675      graphClass.func_(\"getPass\", &RenderGraph::getPass, \"name\"_a);\n  676      graphClass.func_(\"getOutput\", ScriptBindings::overload_cast<const std::string&>(&RenderGraph::getOutput), \"name\"_a);\n  677:     auto printGraph = [](RenderGraph::SharedPtr pGraph) { pybind11::print(RenderGraphExporter::getIR(pGraph)); };\n  678      graphClass.func_(\"print\", printGraph);\n  679  \n  ...\n  683      // RenderPassLibrary with specified device\n  684      \n  685:     const auto& createRenderPass = [](std::shared_ptr<Device> pDevice, const std::string& passName, pybind11::dict d = {}) {\n  686          auto pPass = RenderPassLibrary::instance(pDevice).createPass(pDevice->getRenderContext(), passName.c_str(), Dictionary(d));\n  687          if (!pPass) { \n  ...\n  690          return pPass;\n  691      };\n  692:     passClass.ctor(createRenderPass, \"device\"_a, \"name\"_a, \"dict\"_a = pybind11::dict());\n  693  \n  694      // RenderPassLibrary with default device\n  695      /*\n  696:     const auto& createRenderPassDefault = [](const std::string& passName, pybind11::dict d = {}) {\n  697          auto pDevice = _gpDevice;\n  698          auto pPass = RenderPassLibrary::instance(pDevice).createPass(pDevice->getRenderContext(), passName.c_str(), Dictionary(d));\n  ...\n  702          return pPass;\n  703      };\n  704:     passClass.ctor(createRenderPassDefault, \"name\"_a, \"dict\"_a = pybind11::dict());\n  705      */\n  706  \n  ...\n  720      m.func_(RenderGraphIR::kLoadPassLibrary, loadPassLibraryDefault, \"name\"_a);\n  721  \n  722:     const auto& updateRenderPass = [](std::shared_ptr<Device> pDevice, const RenderGraph::SharedPtr& pGraph, const std::string& passName, pybind11::dict d) {\n  723          pGraph->updatePass(pDevice->getRenderContext(), passName, Dictionary(d));\n  724      };\n\n/home/max/dev/Falcor/src/Falcor/Utils/Scripting/Dictionary.h:\n   31  #include <memory>\n   32  #include <string>\n   33: #include <pybind11/pybind11.h>\n   34  \n   35  namespace Falcor {\n   ..\n   37  class __attribute__((visibility(\"default\"))) Dictionary {\n   38   public:\n   39:     using Container = pybind11::dict;\n   40      using SharedPtr = std::shared_ptr<Dictionary>;\n   41  \n   ..\n   62      class IteratorT {\n   63       public:\n   64:         IteratorT(ContainerType* pContainer, const pybind11::detail::dict_iterator& it) : mIt(it), mpContainer(pContainer) {}\n   65  \n   66          bool operator==(const IteratorT& other) const { return other.mIt == mIt; }\n   ..\n   73          Value val() const { return Value(*mpContainer, key()); }\n   74       private:\n   75:         pybind11::detail::dict_iterator mIt;\n   76          ContainerType* mpContainer;\n   77      };\n   ..\n  101  \n  102      std::string toString() const  {\n  103:         return pybind11::str(static_cast<pybind11::dict>(mMap));\n  104      }\n  105   private:\n\n/home/max/dev/Falcor/src/Falcor/Utils/Scripting/ScriptBindings.cpp:\n   30  #include \"Falcor/stdafx.h\"\n   31  #include \"ScriptBindings.h\"\n   32: #include \"pybind11/embed.h\"\n   33  \n   34  \n   ..\n   52              try\n   53              {\n   54:                 auto pymod = pybind11::module::import(\"falcor\");\n   55                  Module m(pymod);\n   56                  f(m);\n   57                  // Re-import falcor\n   58:                 pybind11::exec(\"from falcor import *\");\n   59              }\n   60              catch (const std::exception& e)\n   ..\n   79  \n   80      template<typename VecT, typename...Args>\n   81:     void addVecType(pybind11::module& m, const std::string name)\n   82      {\n   83          auto ctor = [](Args...components) { return makeVec<VecT>(components...); };\n   ..\n   92              return vec;\n   93          };\n   94:         pybind11::class_<VecT>(m, name.c_str())\n   95:             .def(pybind11::init(ctor))\n   96              .def(\"__repr__\", repr)\n   97              .def(\"__str__\", vecStr);\n\n/home/max/dev/Falcor/src/Falcor/Utils/Scripting/ScriptBindings.h:\n   31  #include <functional>\n   32  \n   33: #include <pybind11/stl.h>\n   34  \n   35  #include \"Falcor/Core/Framework.h\"\n   ..\n   55  \n   56      struct __attribute__((visibility(\"default\"))) Funcs {\n   57:         std::function<void(void*, pybind11::handle)> setF;\n   58          std::function<std::string(const void*)> printF;\n   59      };\n   ..\n   94      template<typename D, typename... Extra>\n   95      Class& rwField(const char* name, D std::remove_pointer_t<T>::* pm, const Extra&... extra) {\n   96:         auto setF = [pm](void* pObj, pybind11::handle h) { static_cast<T*>(pObj)->*pm = h.cast<D>(); };\n   97          std::string nameStr(name);\n   98          auto printF = [pm, nameStr](const void* pObj) {\n   ..\n  128      template <typename Func, typename... Extra>\n  129      Class& ctor(Func&& f, const Extra&... extra) {\n  130:         pyclass.def(pybind11::init(f), extra...);\n  131          return *this;\n  132      }\n  ...\n  140      friend Module;\n  141  \n  142:     Class(const char* name, pybind11::module& m) : pyclass(m, name) {\n  143          if constexpr(std::is_default_constructible_v<T> && std::is_copy_constructible_v<T>) {\n  144              sClasses[typeid(T)] = ClassDesc(name);\n  145:             auto initFunc = [](const pybind11::kwargs& args) {\n  146                  T t;\n  147                  const auto& classBindings = sClasses.at(typeid(T)).funcs;\n  ...\n  149                  return t;\n  150              };\n  151:             pyclass.def(pybind11::init(initFunc)).def(pybind11::init<>());\n  152              if constexpr(std::is_base_of_v<enable_to_string, T>) pyclass.def(\"__repr__\", to_string<T>);\n  153          }\n  154      }\n  155:     pybind11::class_<T, Options...> pyclass;\n  156  };\n  157  \n  ...\n  173   private:\n  174      friend Module;\n  175:     Enum(const char* name, pybind11::module& m) : pyenum(m, name) { sEnumNames[typeid(T)] = name; }\n  176:     pybind11::enum_<T> pyenum;\n  177  };\n  178  \n  ...\n  207      }\n  208  \n  209:     Module(pybind11::module& m) : mModule(m) {}\n  210  \n  211      template<typename T>\n  212      bool classExists() const {\n  213          try {\n  214:             pybind11::dict d;\n  215              d[\"test\"] = (T*)nullptr;\n  216              return true;\n  ...\n  219      }\n  220  private:\n  221:     pybind11::module& mModule;\n  222  };\n  223  \n  224: using pybind11::overload_cast;\n  225: using pybind11::const_;\n  226  \n  227  /************************************************************************/\n\n/home/max/dev/Falcor/src/Falcor/Utils/Scripting/Scripting.cpp:\n   40  #include \"Scripting.h\"\n   41  \n   42: #include <pybind11/embed.h>\n   43  \n   44  namespace Falcor {\n   ..\n   48  \n   49  template<typename CppType>\n   50: static bool insertNewValue(const std::pair<pybind11::handle, pybind11::handle>& pyVar, Dictionary& falcorDict) {\n   51      try {\n   52          CppType cppVal = pyVar.second.cast<CppType>();\n   ..\n   59  }\n   60  \n   61: static bool insertNewFloatVec(const std::pair<pybind11::handle, pybind11::handle>& pyVar, Dictionary& falcorDict) {\n   62      try {\n   63          std::vector<float> floatVec = pyVar.second.cast<std::vector<float>>();\n   ..\n   93  \n   94          try {\n   95:             pybind11::initialize_interpreter();\n   96:             pybind11::exec(\"from falcor import *\");\n   97          } catch (const std::exception& e) {\n   98              logError(\"Can't start the python interpreter. Exception says \" + std::string(e.what()));\n   ..\n  108      if (sRunning) {\n  109          sRunning = false;\n  110:         pybind11::finalize_interpreter();\n  111          ScriptBindings::sClasses.clear();\n  112      }\n  ...\n  116   public:\n  117      RedirectStdout() {\n  118:         auto m = pybind11::module::import(\"sys\");\n  119          mOrigOut = m.attr(\"stdout\");\n  120:         mBuffer = pybind11::module::import(\"io\").attr(\"StringIO\")();\n  121          m.attr(\"stdout\") = mBuffer;\n  122      }\n  123  \n  124      ~RedirectStdout() {\n  125:         pybind11::module::import(\"sys\").attr(\"stdout\") = mOrigOut;\n  126      }\n  127  \n  128      operator std::string() const {\n  129          mBuffer.attr(\"seek\")(0);\n  130:         return pybind11::str(mBuffer.attr(\"read\")());\n  131      }\n  132  \n  133   private:\n  134:     pybind11::object mOrigOut;\n  135:     pybind11::object mBuffer;\n  136  };\n  137  \n  138: static std::string runScript(const std::string& script, pybind11::dict& locals) {\n  139      RedirectStdout rs;\n  140:     pybind11::exec(script.c_str(), pybind11::globals(), locals);\n  141      return rs;\n  142  }\n  143  \n  144  std::string Scripting::runScript(const std::string& script) {\n  145:     auto ref = pybind11::globals();\n  146      return Falcor::runScript(script, ref);\n  147  }\n  ...\n  153  Scripting::Context Scripting::getGlobalContext() {\n  154      Context c;\n  155:     c.mLocals = pybind11::globals();\n  156      return c;\n  157  }\n\n/home/max/dev/Falcor/src/Falcor/Utils/Scripting/Scripting.h:\n   36  #include \"Falcor/Core/Framework.h\"\n   37  \n   38: using namespace pybind11::literals;\n   39  \n   40  namespace Falcor {\n   ..\n   80          private:\n   81              friend class Scripting;\n   82:             pybind11::dict mLocals;\n   83          };\n   84  \n\n71 matches across 11 files\n\n\nSearching 458 files for \"pybind11::module\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Utils/Scripting/ScriptBindings.cpp:\n   50          if(Scripting::isRunning()) {\n   51              try {\n   52:                 auto pymod = pybind11::module::import(\"falcor\");\n   53                  Module m(pymod);\n   54                  f(m);\n   ..\n   75  \n   76      template<typename VecT, typename...Args>\n   77:     void addVecType(pybind11::module& m, const std::string name) {\n   78          auto ctor = [](Args...components) { return makeVec<VecT>(components...); };\n   79          auto repr = [](const VecT& v) { return to_string(v); };\n\n/home/max/dev/Falcor/src/Falcor/Utils/Scripting/ScriptBindings.h:\n  141      friend Module;\n  142  \n  143:     Class(const char* name, pybind11::module& m) : pyclass(m, name) {\n  144          if constexpr(std::is_default_constructible_v<T> && std::is_copy_constructible_v<T>) {\n  145              sClasses[typeid(T)] = ClassDesc(name);\n  ...\n  174   private:\n  175      friend Module;\n  176:     Enum(const char* name, pybind11::module& m) : pyenum(m, name) { sEnumNames[typeid(T)] = name; }\n  177      pybind11::enum_<T> pyenum;\n  178  };\n  ...\n  208      }\n  209  \n  210:     Module(pybind11::module& m) : mModule(m) {}\n  211  \n  212      template<typename T>\n  ...\n  220      }\n  221  private:\n  222:     pybind11::module& mModule;\n  223  };\n  224  \n\n/home/max/dev/Falcor/src/Falcor/Utils/Scripting/Scripting.cpp:\n  116   public:\n  117      RedirectStdout() {\n  118:         auto m = pybind11::module::import(\"sys\");\n  119          mOrigOut = m.attr(\"stdout\");\n  120:         mBuffer = pybind11::module::import(\"io\").attr(\"StringIO\")();\n  121          m.attr(\"stdout\") = mBuffer;\n  122      }\n  123  \n  124      ~RedirectStdout() {\n  125:         pybind11::module::import(\"sys\").attr(\"stdout\") = mOrigOut;\n  126      }\n  127  \n\n9 matches across 3 files\n\n\nSearching 458 files for \"PYBIND11_EMBEDDED_MODULE\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Utils/Scripting/ScriptBindings.cpp:\n   92      }\n   93  \n   94:     PYBIND11_EMBEDDED_MODULE(falcor, m) {\n   95          // bool2, bool3, bool4\n   96          addVecType<bool2, bool, bool>(m, \"bool2\");\n\n1 match in 1 file\n\n\nSearching 1339 files for \"HdLavaRenderBuffer\" (case sensitive)\n\n/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/lavaApi.cpp.old:\n 1570                      continue;\n 1571                  }\n 1572:                 auto rprRenderBuffer = static_cast<HdLavaRenderBuffer*>(aovBinding.renderBuffer);\n 1573                  rprRenderBuffer->SetStatus(registerAovBinding(aovBinding));\n 1574              }\n ....\n 1761  \n 1762          for (auto& outRb : m_outputRenderBuffers) {\n 1763:             if (auto rb = static_cast<HdLavaRenderBuffer*>(outRb.aovBinding->renderBuffer)) {\n 1764                  if (rb->GetWidth() != m_viewportSize[0] || rb->GetHeight() != m_viewportSize[1]) {\n 1765                      TF_RUNTIME_ERROR(\"%s renderBuffer has inconsistent render buffer size: %ux%u. Expected: %dx%d\",\n ....\n 1804  \n 1805          for (auto& aovBinding : m_aovBindings) {\n 1806:             if (auto rb = static_cast<HdLavaRenderBuffer*>(aovBinding.renderBuffer)) {\n 1807                  rb->Unmap();\n 1808              }\n ....\n 1822  \n 1823          for (auto& aovBinding : m_aovBindings) {\n 1824:             if (auto rb = static_cast<HdLavaRenderBuffer*>(aovBinding.renderBuffer)) {\n 1825                  rb->SetConverged(true);\n 1826              }\n\n/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/renderBuffer.cpp:\n   22  PXR_NAMESPACE_OPEN_SCOPE\n   23  \n   24: HdLavaRenderBuffer::HdLavaRenderBuffer(SdfPath const& id)\n   25      : HdRenderBuffer(id)\n   26      , m_numMappers(0)\n   ..\n   29  }\n   30  \n   31: void HdLavaRenderBuffer::Sync(HdSceneDelegate* sceneDelegate, HdRenderParam* renderParam, HdDirtyBits* dirtyBits) {\n   32      if (*dirtyBits & DirtyDescription) {\n   33          // hdRpr has the background thread write directly into render buffers,\n   ..\n   39  }\n   40  \n   41: void HdLavaRenderBuffer::Finalize(HdRenderParam* renderParam) {\n   42      // hdRpr has the background thread write directly into render buffers,\n   43      // so we need to stop the render thread before reallocating them.\n   ..\n   47  }\n   48  \n   49: bool HdLavaRenderBuffer::Allocate(GfVec3i const& dimensions, HdFormat format, bool multiSampled) {\n   50      TF_UNUSED(multiSampled);\n   51  \n   52      if (dimensions[2] != 1) {\n   53:         TF_WARN(\"HdLavaRenderBuffer supports 2D buffers only\");\n   54          return false;\n   55      }\n   ..\n   59      m_width = dimensions[0];\n   60      m_height = dimensions[1];\n   61:     LOG_DBG(\"HdLavaRenderBuffer::Allocate %u %u\", m_width, m_height);\n   62      m_format = format;\n   63      size_t dataByteSize = m_width * m_height * HdDataSizeOfFormat(m_format);\n   ..\n   67  }\n   68  \n   69: void HdLavaRenderBuffer::_Deallocate() {\n   70      m_width = 0u;\n   71      m_height = 0u;\n   ..\n   76  }\n   77  \n   78: void* HdLavaRenderBuffer::Map() {\n   79      if (!m_isValid) return nullptr;\n   80  \n   ..\n   83  }\n   84  \n   85: void HdLavaRenderBuffer::Unmap() {\n   86      if (!m_isValid) return;\n   87  \n   ..\n   94  }\n   95  \n   96: bool HdLavaRenderBuffer::IsMapped() const {\n   97      return m_numMappers.load() != 0;\n   98  }\n   99  \n  100: void HdLavaRenderBuffer::Resolve() {\n  101      // no-op\n  102  }\n  103  \n  104: bool HdLavaRenderBuffer::IsConverged() const {\n  105      return m_isConverged.load();\n  106  }\n  107  \n  108: void HdLavaRenderBuffer::SetConverged(bool converged) {\n  109      return m_isConverged.store(converged);\n  110  }\n  111  \n  112: void HdLavaRenderBuffer::SetStatus(bool isValid) {\n  113      m_isValid = isValid;\n  114  }\n\n/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/renderBuffer.h:\n   19  PXR_NAMESPACE_OPEN_SCOPE\n   20  \n   21: class HdLavaRenderBuffer final : public HdRenderBuffer {\n   22  public:\n   23:     HdLavaRenderBuffer(SdfPath const& id);\n   24:     ~HdLavaRenderBuffer() override = default;\n   25  \n   26      void Sync(HdSceneDelegate* sceneDelegate, HdRenderParam* renderParam, HdDirtyBits* dirtyBits) override;\n\n/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/renderDelegate.cpp:\n  313  HdBprim* HdLavaDelegate::CreateBprim(TfToken const& typeId, SdfPath const& bprimId) {\n  314      if (typeId == HdPrimTypeTokens->renderBuffer) {\n  315:         return new HdLavaRenderBuffer(bprimId);\n  316      }\n  317  #ifdef USE_VOLUME\n\n/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/renderPass.cpp:\n   61      //    for (auto& aovBinding : renderPassState->GetAovBindings()) {\n   62      //        if (aovBinding.renderBuffer) {\n   63:     //            auto rprRenderBuffer = static_cast<HdLavaRenderBuffer*>(aovBinding.renderBuffer);\n   64      //            rprRenderBuffer->SetConverged(false);\n   65      //        }\n\n/home/max/dev/Falcor/src/USD/hdLava/renderDelegate.cpp:\n  304                                      SdfPath const& bprimId) {\n  305      if (typeId == HdPrimTypeTokens->renderBuffer) {\n  306:         return new HdLavaRenderBuffer(bprimId);\n  307      }\n  308  #ifdef USE_VOLUME\n\n/home/max/dev/Falcor/src/USD/hdLava/renderPass.cpp:\n   61          for (auto& aovBinding : renderPassState->GetAovBindings()) {\n   62              if (aovBinding.renderBuffer) {\n   63:                 auto rprRenderBuffer = static_cast<HdLavaRenderBuffer*>(aovBinding.renderBuffer);\n   64                  rprRenderBuffer->SetConverged(false);\n   65              }\n\n26 matches across 7 files\n\n\nSearching 1339 files for \"_Execute\" (case sensitive)\n\n/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/renderPass.cpp:\n   24  }\n   25  \n   26: void HdLavaRenderPass::_Execute(HdRenderPassStateSharedPtr const& renderPassState, TfTokenVector const& renderTags) {\n   27      // To avoid potential deadlock:\n   28      //   main thread locks config instance and requests render stop and\n\n/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/renderPass.h:\n   21      bool IsConverged() const override;\n   22  \n   23:     void _Execute(HdRenderPassStateSharedPtr const& renderPassState,\n   24                    TfTokenVector const& renderTags) override;\n   25  \n\n/home/max/dev/Falcor/src/USD/hdLava/renderPass.cpp:\n   19  }\n   20  \n   21: void HdLavaRenderPass::_Execute(HdRenderPassStateSharedPtr const& renderPassState, TfTokenVector const& renderTags) {\n   22      // To avoid potential deadlock:\n   23      //   main thread locks config instance and requests render stop and\n\n/home/max/dev/Falcor/src/USD/hdLava/renderPass.h:\n   20      bool IsConverged() const override;\n   21  \n   22:     void _Execute(HdRenderPassStateSharedPtr const& renderPassState,\n   23                    TfTokenVector const& renderTags) override;\n   24  \n\n4 matches across 4 files\n\n\nSearching 18 files for \"LSDapilavatext\" (case sensitive)\n\n/home/max/dev/Falcor/contrib/houdini/soho/LSDapi.py:\n  304  \n  305  def selectAPI(choice):\n  306:     import LSDapilavatext\n  307:     api = LSDapilavatext\n  308      switchAPI(api)\n  309  \n\n2 matches in 1 file\n\n\nSearching 18 files for \"Unable to find:\" (case sensitive)\n\n/home/max/dev/Falcor/contrib/houdini/soho/LSDsettings.py:\n  969      file = findPyFile(targetfile)\n  970      if file == None:\n  971:         print \"# WARNING: Unable to find: %s\\n\" % ( targetfile )\n  972      else:\n  973          SettingDefs.append(file)\n\n1 match in 1 file\n\n\nSearching 18 files for \"ri_device\" (case sensitive)\n\n/home/max/dev/Falcor/contrib/houdini/soho/LSDframe.py:\n  276  cameraDisplayParms = {\n  277      'ri_display'  : SohoParm('ri_display', 'string', ['ip'], False),\n  278:     'ri_device'   : SohoParm('ri_device',  'string', ['framebuffer'], False),\n  279      'ri_channels' : SohoParm('ri_channels', 'string', ['rgba'], False),\n  280      'ri_quantize' : SohoParm('ri_quantize', 'real', [255, 0, 255, 0.5], False),\n  ...\n  367      if not name:\n  368          return False\n  369:     device  = light.wrangleString(wrangler, 'ri_device', now, ['shadow'])[0]\n  370      channel = light.wrangleString(wrangler, 'ri_channels', now, ['z'])[0]\n  371  \n  ...\n  388      plist    = cam.wrangle(wrangler, cameraDisplayParms, now)\n  389      name     = plist['ri_display'].Value[0]\n  390:     device   = plist['ri_device'].Value[0]\n  391      channels = plist['ri_channels'].Value[0]\n  392      flipbook = cam.wrangleInt(wrangler, 'flipbook_output', now, [0])[0]\n  ...\n  719      plist    = cam.wrangle(wrangler, cameraDisplayParms, now)\n  720      name     = plist['ri_display'].Value[0]\n  721:     device   = plist['ri_device'].Value[0]\n  722      channels = plist['ri_channels'].Value[0]\n  723  \n\n5 matches in 1 file\n\n\nSearching 11 files for \"vm_display\" (case sensitive)\n\n0 matches\n\nSearching 11 files for \"vm_device\" (case sensitive)\n\n/home/max/dev/Falcor/contrib/houdini/soho/LSDframe.py:\n  144  \n  145  displayParms = {\n  146:     'vm_device'  :SohoParm('vm_device',   'string',     [''], False),\n  147      'vm_foptions':SohoParm('vm_foptions', 'string',     [''], False),\n  148      'vm_numaux'  :SohoParm('vm_numaux',   'int',        [0], False),\n  ...\n  392      filename = cam.wrangleString(wrangler, 'vm_picture', now, ['ip'])[0]\n  393      plist       = cam.wrangle(wrangler, displayParms, now)\n  394:     device      = plist['vm_device'].Value[0]\n  395      foptions    = plist['vm_foptions'].Value[0]\n  396      numaux      = plist['vm_numaux'].Value[0]\n\n3 matches in 1 file\n\n\nSearching 11 files for \"vm_device\" (case sensitive)\n\n/home/max/dev/Falcor/contrib/houdini/soho/LSDframe.py:\n  392      filename = cam.wrangleString(wrangler, 'vm_picture', now, ['ip'])[0]\n  393      plist       = cam.wrangle(wrangler, displayParms, now)\n  394:     device      = plist['vm_device'].Value[0]\n  395      foptions    = plist['vm_foptions'].Value[0]\n  396      numaux      = plist['vm_numaux'].Value[0]\n\n1 match in 1 file\n\n\nSearching 11 files for \"vm_picture\" (case sensitive)\n\n/home/max/dev/Falcor/contrib/houdini/soho/LSDframe.py:\n   46          self.Object = obj\n   47          self.Face = -1\n   48:         self.BasePath = obj.getDefaultedString('vm_picture', now, [''])[0]\n   49  \n   50      def setFace(self, dir):\n   ..\n  179  \n  180      # Some parameters for backward compatibility with H9.0\n  181:     'h9channel' : SohoParm('vm_picture_plane%d', 'string', [''], False,\n  182                                  key='h9channel'),\n  183  }\n  ...\n  245          # The hook has output the light display for us\n  246          return True\n  247:     filename = light.wrangleString(wrangler, 'vm_picture', now, [''])[0]\n  248      if not filename:\n  249          return False\n\n3 matches in 1 file\n\n\nSearching 11 files for \"vm_picture\" (case sensitive)\n\n/home/max/dev/Falcor/contrib/houdini/soho/LSDframe.py:\n  179  \n  180      # Some parameters for backward compatibility with H9.0\n  181:     'h9channel' : SohoParm('vm_picture_plane%d', 'string', [''], False,\n  182                                  key='h9channel'),\n  183  }\n  ...\n  245          # The hook has output the light display for us\n  246          return True\n  247:     filename = light.wrangleString(wrangler, 'vm_picture', now, [''])[0]\n  248      if not filename:\n  249          return False\n\n2 matches in 1 file\n\n\nSearching 11 files for \"vm_picture\" (case sensitive)\n\n/home/max/dev/Falcor/contrib/houdini/soho/LSDframe.py:\n  245          # The hook has output the light display for us\n  246          return True\n  247:     filename = light.wrangleString(wrangler, 'vm_picture', now, [''])[0]\n  248      if not filename:\n  249          return False\n\n1 match in 1 file\n\n\nSearching 11 files for \"lv_samples\" (case sensitive)\n\n/home/max/dev/Falcor/contrib/houdini/soho/LSDmantra.py:\n  145      Image(\"image\", \"resolution\", \"int\", \"lv_uvunwrapres\")\n  146      Image(\"image\", \"samplelock\", \"bool\", \"lv_samplelock\")\n  147:     Image(\"image\", \"samples\", \"int\", \"lv_samples\", skipdefault=False)\n  148      Image(\"image\", \"saveoptions\", \"string\", \"lv_saveoptions\")\n  149      Image(\"image\", \"setexrdatawindow\", \"bool\", \"lv_setexrdatawindow\")\n\n1 match in 1 file\n\n\nSearching 11 files for \"samples\" (case sensitive)\n\n/home/max/dev/Falcor/contrib/houdini/otls/lava.hda:\n    <binary>\n\n/home/max/dev/Falcor/contrib/houdini/soho/LSDframe.py:\n  608          window_bounds = SOHOcommon.getObjectScreenBoundsFull(\n  609              now, wrangler, cam, windowmask,\n  610:             LSDgeo.getObjectBounds, LSDmisc.xform_mbsamples)\n  611  \n  612          if window_bounds is not None:\n  ...\n  701                      fromlight, forphoton, cubemap):\n  702          return True\n  703:     times = LSDmisc.xform_mbsamples(cam, now)\n  704      if fromlight:\n  705          wrangler = LSDsettings.getWrangler(cam, now, 'light_wrangler')\n  ...\n  934          crop_bounds = SOHOcommon.getObjectScreenBoundsFull(\n  935              now, wrangler, cam, cropmask,\n  936:             LSDgeo.getObjectBounds, LSDmisc.xform_mbsamples, window=window)\n  937  \n  938          if crop_bounds is not None:\n  ...\n 1006          return\n 1007  \n 1008:     times = LSDmisc.xform_mbsamples(light, now)\n 1009  \n 1010      cmd_start('light')\n ....\n 1043          window_bounds = SOHOcommon.getObjectScreenBoundsFull(\n 1044              now, wrangler, light, windowmask,\n 1045:             LSDgeo.getObjectBounds, LSDmisc.xform_mbsamples)\n 1046  \n 1047          if window_bounds is not None:\n ....\n 1059      if LSDhooks.call('pre_outputFog', fog, now):\n 1060          return\n 1061:     times = LSDmisc.xform_mbsamples(fog, now)\n 1062      cmd_start('fog')\n 1063      objectTransform('space:world', fog, times)\n ....\n 1266  \n 1267      cmd_start('object')\n 1268:     times = LSDmisc.xform_mbsamples(obj, now)\n 1269      objectTransform('space:world', obj, times)\n 1270      # TODO Shader space transform\n ....\n 1354  \n 1355      cmd_start( 'object' )\n 1356:     times = LSDmisc.xform_mbsamples(obj, now)\n 1357      objectTransform('space:world', obj, times)\n 1358  \n ....\n 1428      if LSDhooks.call('pre_outputSpace', obj, now):\n 1429          return\n 1430:     times = LSDmisc.xform_mbsamples(obj, now)\n 1431      cmd_start('object')\n 1432      cmd_property('object', 'name', [obj.getName()])\n ....\n 1507                  inst_obj = soho.getObject( inst_path )\n 1508                  if inst_obj:\n 1509:                     mbinfo = LSDmisc.geo_mbsamples(inst_obj, now)\n 1510                      LSDgeo.saveRetained(inst_obj, now, mbinfo[0], mbinfo[1], mbinfo[2], mbinfo[3])\n 1511  \n 1512:         mbinfo = LSDmisc.geo_mbsamples(obj, now)\n 1513          LSDgeo.saveRetained(obj, now, mbinfo[0], mbinfo[1], mbinfo[2], mbinfo[3])\n 1514      for light in lightlist:\n 1515          wrangler = LSDsettings.getWrangler(light, now, 'light_wrangler')\n 1516          if isGeoLight(light, wrangler, now):\n 1517:             mbinfo = LSDmisc.geo_mbsamples(light, now)\n 1518              LSDgeo.saveRetained(light, now, mbinfo[0], mbinfo[1], mbinfo[2], mbinfo[3])\n 1519      cmd_comment(None)\n\n/home/max/dev/Falcor/contrib/houdini/soho/LSDgeo.py:\n  581      for obj_path in obj_paths:\n  582          obj = soho.getObject(obj_path)\n  583:         mbinfo = LSDmisc.geo_mbsamples(obj, now)\n  584          saveRetained(obj, now, mbinfo[0], mbinfo[1], mbinfo[2], mbinfo[3])\n  585  \n  ...\n  840      details = data\n  841  \n  842:     mbinfo = LSDmisc.geo_mbsamples(obj, now)\n  843      if len(mbinfo[0]) == 1:\n  844          details = [ details[0] ]\n  ...\n  925  # Returns the full bounds of an object over the entire shutter range\n  926  def getObjectBounds(obj, now):\n  927:     (times, velblur, accel_attrib, mbsegments) = LSDmisc.geo_mbsamples(obj, now)\n  928      proc = getProcedural(obj, times[0])\n  929      if proc:\n\n/home/max/dev/Falcor/contrib/houdini/soho/LSDmantra.py:\n   53      Renderer(\"renderer\", \"imageblur\", \"bool\", \"lv_imageblur\")\n   54      Renderer(\"renderer\", \"iprfakerelight\", \"bool\", \"lv_iprfakerelight\")\n   55:     Renderer(\"renderer\", \"iprfixsamples\", \"bool\", \"lv_iprfixsamples\")\n   56:     Renderer(\"renderer\", \"iprpasssamples\", \"float\", \"lv_iprpasssamples\")\n   57      Renderer(\"renderer\", \"kdmemfactor\", \"float\", \"lv_kdmemfactor\")\n   58      Renderer(\"renderer\", \"logcolors\", \"int\", \"lv_logcolors\", skipdefault=False)\n   ..\n  145      Image(\"image\", \"resolution\", \"int\", \"lv_uvunwrapres\")\n  146      Image(\"image\", \"samplelock\", \"bool\", \"lv_samplelock\")\n  147:     Image(\"image\", \"samples\", \"int\", \"lv_samples\", skipdefault=False)\n  148      Image(\"image\", \"saveoptions\", \"string\", \"lv_saveoptions\")\n  149      Image(\"image\", \"setexrdatawindow\", \"bool\", \"lv_setexrdatawindow\")\n  150      Image(\"image\", \"subpixel\", \"bool\", \"lv_subpixel\")\n  151      Image(\"image\", \"transparent\", \"bool\", \"lv_transparent\")\n  152:     Image(\"image\", \"transparentsamples\", \"int\", \"lv_transparentsamples\")\n  153      Image(\"image\", \"writecheckpoint\", \"bool\", \"lv_writecheckpoint\")\n  154  \n  ...\n  203      Object(\"lpetag\", \"string\", \"lv_lpetag\")\n  204      Object(\"matte\", \"bool\", \"lv_matte\")\n  205:     Object(\"maxindirectraysamples\", \"int\", \"lv_maxindirectraysamples\")\n  206:     Object(\"maxraysamples\", \"int\", \"lv_maxraysamples\")\n  207      Object(\"metavolume\", \"bool\", \"lv_metavolume\")\n  208:     Object(\"minindirectraysamples\", \"int\", \"lv_minindirectraysamples\")\n  209:     Object(\"minraysamples\", \"int\", \"lv_minraysamples\")\n  210      Object(\"motionfactor\", \"float\", \"lv_motionfactor\")\n  211      Object(\"osd_fvarinterp\", \"int\", \"lv_osd_fvarinterp\")\n  ...\n  266      Object(\"volumenormal\", \"bool\", \"lv_volumenormal\")\n  267      Object(\"volumequality\", \"float\", \"lv_volumequality\")\n  268:     Object(\"volumesamples\", \"int\", \"lv_volumesamples\")\n  269      Object(\"volumesamplingchannel\", \"string\", \"lv_volumesamplingchannel\")\n  270      Object(\"volumeshadowsteprate\", \"float\", \"lv_volumeshadowsteprate\")\n\n/home/max/dev/Falcor/contrib/houdini/soho/LSDmisc.py:\n   68  \n   69  objXformMotion = [\n   70:     SohoParm('xform_motionsamples',     'int', [2], False),\n   71  ]\n   72  \n   73  objGeoMotion = [\n   74:     SohoParm('geo_motionsamples',       'int', [1], False),\n   75      SohoParm('geo_velocityblur',        'int', [0], False),\n   76  \tSohoParm('geo_accelattribute',\t\t'string', [\"accel\"], False),\n   ..\n  305  def ouputMotionBlurInfo(obj,now,required=False):\n  306      motionInfo = {\n  307:         'xform' : SohoParm('xform_motionsamples', 'int', [2], not required, key='xform'),\n  308:         'geo'   : SohoParm('geo_motionsamples',   'int', [1], not required, key='geo')\n  309      }\n  310      \n  311:     # Write out the number of transform and geometry motion samples\n  312      # if motion blur is enabled.\n  313      if CameraBlur:\n  ...\n  317          nseg = xform.Value[0] if xform else 1\n  318          if nseg > 1:\n  319:             cmd_property('object', 'xformsamples', [nseg])\n  320          nseg = geo.Value[0] if geo else 1\n  321          if nseg > 1:\n  322:             cmd_property('object', 'geosamples', [nseg])\n  323  \n  324  def setCameraBlur(cam, now):\n  ...\n  343      return times\n  344  \n  345: def xform_mbsamples(obj, now):\n  346      times = [now]\n  347      if CameraBlur:\n  ...\n  370      return times\n  371  \n  372: def geo_mbsamples(obj, now):\n  373      times = [now]\n  374      vblur = False\n\n/home/max/dev/Falcor/contrib/houdini/soho/LSDsettings.py:\n  281  bakingParms = {\n  282      'bake_layerexport'             :SohoParm('lv_bake_layerexport',             'int',    [0],          key='bake_layerexport'),\n  283:     'bake_samples'                 :SohoParm('lv_bake_samples',                 'int',    [16],        key='bake_samples'),\n  284      'bake_tangentnormalflipx'      :SohoParm('lv_bake_tangentnormalflipx',      'int',    [0],          key='bake_tangentnormalflipx'),\n  285      'bake_tangentnormalflipy'      :SohoParm('lv_bake_tangentnormalflipy',      'int',    [0],          key='bake_tangentnormalflipy'),\n  ...\n  604      # For velocity motion blur, we need to have access to the velocity\n  605      # scale in the instance as well for volume rendering.\n  606:     mbinfo = LSDmisc.geo_mbsamples(obj, now)\n  607      if mbinfo[1] and len(mbinfo[0]) == 2:\n  608          times = mbinfo[0]\n\n47 matches across 6 files\n\n\nSearching 11 files for \"vm_samples\" (case sensitive)\n\n0 matches\n\nSearching 11 files for \"lv_samplesx\" (case sensitive)\n\n0 matches\n\nSearching 11 files for \"lv_samples\" (case sensitive)\n\n/home/max/dev/Falcor/contrib/houdini/soho/LSDmantra.py:\n  145      Image(\"image\", \"resolution\", \"int\", \"lv_uvunwrapres\")\n  146      Image(\"image\", \"samplelock\", \"bool\", \"lv_samplelock\")\n  147:     Image(\"image\", \"samples\", \"int\", \"lv_samples\", skipdefault=False)\n  148      Image(\"image\", \"saveoptions\", \"string\", \"lv_saveoptions\")\n  149      Image(\"image\", \"setexrdatawindow\", \"bool\", \"lv_setexrdatawindow\")\n\n1 match in 1 file\n\n\nSearching 30500 files for \"ExternalProject_Add_Step\" (case sensitive)\n\n/home/max/dev/Falcor/build/.cmake/api/v1/reply/target-antlr4_runtime-build_shared-DEBUG-a28a0119ebf965e3b1fc.json:\n    6  \t\t[\n    7  \t\t\t\"add_custom_target\",\n    8: \t\t\t\"ExternalProject_Add_StepTargets\",\n    9  \t\t\t\"include\"\n   10  \t\t],\n\n/home/max/dev/Falcor/build/.cmake/api/v1/reply/target-antlr4_runtime-build_static-DEBUG-a0c7aa13c6358651a723.json:\n    6  \t\t[\n    7  \t\t\t\"add_custom_target\",\n    8: \t\t\t\"ExternalProject_Add_StepTargets\",\n    9  \t\t\t\"include\"\n   10  \t\t],\n\n/home/max/dev/Falcor/build/debug/lib/libassimp.so.5:\n    File too large, skipping\n\n/home/max/dev/Falcor/build/debug/lib/libassimp.so.5.0.0:\n    File too large, skipping\n\n/home/max/dev/Falcor/build/src/lava_lib/antlr4_runtime/src/antlr4_runtime/runtime/Cpp/cmake/ExternalAntlr4Cpp.cmake:\n  116  endif()\n  117  \n  118: ExternalProject_Add_Step(\n  119      antlr4_runtime\n  120      build_static\n  ...\n  126      EXCLUDE_FROM_MAIN 1\n  127      WORKING_DIRECTORY ${ANTLR4_BUILD_DIR})\n  128: ExternalProject_Add_StepTargets(antlr4_runtime build_static)\n  129  \n  130  add_library(antlr4_static STATIC IMPORTED)\n  ...\n  133                        IMPORTED_LOCATION ${ANTLR4_STATIC_LIBRARIES})\n  134  \n  135: ExternalProject_Add_Step(\n  136      antlr4_runtime\n  137      build_shared\n  ...\n  143      EXCLUDE_FROM_MAIN 1\n  144      WORKING_DIRECTORY ${ANTLR4_BUILD_DIR})\n  145: ExternalProject_Add_StepTargets(antlr4_runtime build_shared)\n  146  \n  147  add_library(antlr4_shared SHARED IMPORTED)\n\n/home/max/dev/Falcor/cmake/Antlr4Cpp.cmake:\n   76  endif()\n   77  \n   78: ExternalProject_Add_Step(\n   79      antlr4_runtime\n   80      build_static\n   ..\n   86      EXCLUDE_FROM_MAIN 1\n   87      WORKING_DIRECTORY ${ANTLR4_BUILD_DIR})\n   88: ExternalProject_Add_StepTargets(antlr4_runtime build_static)\n   89  \n   90  add_library(antlr4_static STATIC IMPORTED)\n   ..\n   93                        IMPORTED_LOCATION ${ANTLR4_STATIC_LIBRARIES})\n   94  \n   95: ExternalProject_Add_Step(\n   96      antlr4_runtime\n   97      build_shared\n   ..\n  103      EXCLUDE_FROM_MAIN 1\n  104      WORKING_DIRECTORY ${ANTLR4_BUILD_DIR})\n  105: ExternalProject_Add_StepTargets(antlr4_runtime build_shared)\n  106  \n  107  add_library(antlr4_shared SHARED IMPORTED)\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/cmake/ExternalAntlr4Cpp.cmake:\n  116  endif()\n  117  \n  118: ExternalProject_Add_Step(\n  119      antlr4_runtime\n  120      build_static\n  ...\n  126      EXCLUDE_FROM_MAIN 1\n  127      WORKING_DIRECTORY ${ANTLR4_BUILD_DIR})\n  128: ExternalProject_Add_StepTargets(antlr4_runtime build_static)\n  129  \n  130  add_library(antlr4_static STATIC IMPORTED)\n  ...\n  133                        IMPORTED_LOCATION ${ANTLR4_STATIC_LIBRARIES})\n  134  \n  135: ExternalProject_Add_Step(\n  136      antlr4_runtime\n  137      build_shared\n  ...\n  143      EXCLUDE_FROM_MAIN 1\n  144      WORKING_DIRECTORY ${ANTLR4_BUILD_DIR})\n  145: ExternalProject_Add_StepTargets(antlr4_runtime build_shared)\n  146  \n  147  add_library(antlr4_shared SHARED IMPORTED)\n\n/home/max/dev/Falcor/venv/lib/python3.7/site-packages/PySide2/Qt/lib/libQt5WebEngineCore.so.5:\n    File too large, skipping\n\n14 matches across 5 files\n\n\nSearching 308 files for \"getText\" (case sensitive)\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/ANTLRInputStream.cpp:\n  119  }\n  120  \n  121: std::string ANTLRInputStream::getText(const Interval &interval) {\n  122    if (interval.a < 0 || interval.b < 0) {\n  123      return \"\";\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/ANTLRInputStream.h:\n   59      /// </summary>\n   60      virtual void seek(size_t index) override;\n   61:     virtual std::string getText(const misc::Interval &interval) override;\n   62      virtual std::string getSourceName() const override;\n   63      virtual std::string toString() const override;\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/atn/LexerATNSimulator.cpp:\n  582  }\n  583  \n  584: std::string LexerATNSimulator::getText(CharStream *input) {\n  585    // index is first lookahead char, don't include.\n  586:   return input->getText(misc::Interval(_startIndex, input->index() - 1));\n  587  }\n  588  \n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/atn/LexerATNSimulator.h:\n  163      /// <seealso cref=\"#consume\"/> for the matched character. This method should call\n  164      /// <seealso cref=\"#consume\"/> before evaluating the predicate to ensure position\n  165:     /// sensitive values, including <seealso cref=\"Lexer#getText\"/>, <seealso cref=\"Lexer#getLine\"/>,\n  166      /// and <seealso cref=\"Lexer#getCharPositionInLine\"/>, properly reflect the current\n  167      /// lexer state. This method should restore {@code input} and the simulator\n  ...\n  195  \n  196      /// Get the text matched so far for the current token.\n  197:     virtual std::string getText(CharStream *input);\n  198      virtual size_t getLine() const;\n  199      virtual void setLine(size_t line);\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/atn/LexerCustomAction.h:\n   62      /// <para>Custom actions are position-dependent since they may represent a\n   63      /// user-defined embedded action which makes calls to methods like\n   64:     /// <seealso cref=\"Lexer#getText\"/>.</para>\n   65      /// </summary>\n   66      /// <returns> This method returns {@code true}. </returns>\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/atn/ParserATNSimulator.cpp:\n 1305  #if DEBUG_DFA == 1 || RETRY_DEBUG == 1\n 1306      misc::Interval interval = misc::Interval((int)startIndex, (int)stopIndex);\n 1307:     std::cout << \"reportAttemptingFullContext decision=\" << dfa.decision << \":\" << configs << \", input=\" << parser->getTokenStream()->getText(interval) << std::endl;\n 1308  #endif\n 1309  \n ....\n 1317  #if DEBUG_DFA == 1 || RETRY_DEBUG == 1\n 1318      misc::Interval interval = misc::Interval(startIndex, stopIndex);\n 1319:     std::cout << \"reportContextSensitivity decision=\" << dfa.decision << \":\" << configs << \", input=\" << parser->getTokenStream()->getText(interval) << std::endl;\n 1320  #endif\n 1321  \n ....\n 1329  #if DEBUG_DFA == 1 || RETRY_DEBUG == 1\n 1330      misc::Interval interval = misc::Interval((int)startIndex, (int)stopIndex);\n 1331:     std::cout << \"reportAmbiguity \" << ambigAlts << \":\" << configs << \", input=\" << parser->getTokenStream()->getText(interval) << std::endl;\n 1332  #endif\n 1333  \n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/BufferedTokenStream.cpp:\n  358  }\n  359  \n  360: std::string BufferedTokenStream::getText() {\n  361    fill();\n  362:   return getText(misc::Interval(0U, size() - 1));\n  363  }\n  364  \n  365: std::string BufferedTokenStream::getText(const misc::Interval &interval) {\n  366    lazyInit();\n  367    size_t start = interval.a;\n  ...\n  381        break;\n  382      }\n  383:     ss << t->getText();\n  384    }\n  385    return ss.str();\n  386  }\n  387  \n  388: std::string BufferedTokenStream::getText(RuleContext *ctx) {\n  389:   return getText(ctx->getSourceInterval());\n  390  }\n  391  \n  392: std::string BufferedTokenStream::getText(Token *start, Token *stop) {\n  393    if (start != nullptr && stop != nullptr) {\n  394:     return getText(misc::Interval(start->getTokenIndex(), stop->getTokenIndex()));\n  395    }\n  396  \n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/BufferedTokenStream.h:\n   87  \n   88      virtual std::string getSourceName() const override;\n   89:     virtual std::string getText() override;\n   90:     virtual std::string getText(const misc::Interval &interval) override;\n   91:     virtual std::string getText(RuleContext *ctx) override;\n   92:     virtual std::string getText(Token *start, Token *stop) override;\n   93  \n   94      /// Get all tokens from lexer until EOF.\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/CharStream.h:\n   30      /// <exception cref=\"UnsupportedOperationException\"> if the stream does not support\n   31      /// getting the text of the specified interval </exception>\n   32:     virtual std::string getText(const misc::Interval &interval) = 0;\n   33  \n   34      virtual std::string toString() const = 0;\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/CommonToken.cpp:\n   63      _source = (static_cast<CommonToken *>(oldToken))->_source;\n   64    } else {\n   65:     _text = oldToken->getText();\n   66      _source = { oldToken->getTokenSource(), oldToken->getInputStream() };\n   67    }\n   ..\n   76  }\n   77  \n   78: std::string CommonToken::getText() const {\n   79    if (!_text.empty()) {\n   80      return _text;\n   ..\n   87    size_t n = input->size();\n   88    if (_start < n && _stop < n) {\n   89:     return input->getText(misc::Interval(_start, _stop));\n   90    } else {\n   91      return \"<EOF>\";\n   ..\n  164      channelStr = \",channel=\" + std::to_string(_channel);\n  165    }\n  166:   std::string txt = getText();\n  167    if (!txt.empty()) {\n  168      antlrcpp::replaceAll(txt, \"\\n\", \"\\\\n\");\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/CommonToken.h:\n   54  \n   55      /**\n   56:      * This is the backing field for {@link #getText} when the token text is\n   57       * explicitly set in the constructor or via {@link #setText}.\n   58       *\n   59:      * @see #getText()\n   60       */\n   61      std::string _text;\n   ..\n  104       * constructed token will share a reference to the {@link #text} field and\n  105       * the {@link Pair} stored in {@link #source}. Otherwise, {@link #text} will\n  106:      * be assigned the result of calling {@link #getText}, and {@link #source}\n  107       * will be constructed from the result of {@link Token#getTokenSource} and\n  108       * {@link Token#getInputStream}.</p>\n  ...\n  116      /**\n  117       * Explicitly set the text for this token. If {code text} is not\n  118:      * {@code null}, then {@link #getText} will return this value rather than\n  119       * extracting the text from the input.\n  120       *\n  ...\n  124       */\n  125      virtual void setText(const std::string &text) override;\n  126:     virtual std::string getText() const override;\n  127  \n  128      virtual void setLine(size_t line) override;\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/CommonTokenFactory.cpp:\n   29      t->setText(text);\n   30    } else if (copyText && source.second != nullptr) {\n   31:     t->setText(source.second->getText(misc::Interval(start, stop)));\n   32    }\n   33  \n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/CommonTokenFactory.h:\n   31       * where the input stream might not be able to provide arbitrary substrings\n   32       * of text from the input after the lexer creates a token (e.g. the\n   33:      * implementation of {@link CharStream#getText} in\n   34       * {@link UnbufferedCharStream} throws an\n   35       * {@link UnsupportedOperationException}). Explicitly setting the token text\n   36:      * allows {@link Token#getText} to be called at any time regardless of the\n   37       * input stream implementation.\n   38       *\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/CommonTokenStream.h:\n   17     * <p>\n   18     * This token stream provides access to all tokens by index or when calling\n   19:    * methods like {@link #getText}. The channel filtering is only used for code\n   20     * accessing tokens via the lookahead methods {@link #LA}, {@link #LT}, and\n   21     * {@link #LB}.</p>\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/DefaultErrorStrategy.cpp:\n  140        input = \"<EOF>\";\n  141      } else {\n  142:       input = tokens->getText(e.getStartToken(), e.getOffendingToken());\n  143      }\n  144    } else {\n  ...\n  285  \n  286  std::string DefaultErrorStrategy::getSymbolText(Token *symbol) {\n  287:   return symbol->getText();\n  288  }\n  289  \n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/DiagnosticErrorListener.cpp:\n   29    std::string decision = getDecisionDescription(recognizer, dfa);\n   30    antlrcpp::BitSet conflictingAlts = getConflictingAlts(ambigAlts, configs);\n   31:   std::string text = recognizer->getTokenStream()->getText(misc::Interval(startIndex, stopIndex));\n   32    std::string message = \"reportAmbiguity d=\" + decision + \": ambigAlts=\" + conflictingAlts.toString() +\n   33      \", input='\" + text + \"'\";\n   ..\n   39    size_t stopIndex, const antlrcpp::BitSet &/*conflictingAlts*/, atn::ATNConfigSet * /*configs*/) {\n   40    std::string decision = getDecisionDescription(recognizer, dfa);\n   41:   std::string text = recognizer->getTokenStream()->getText(misc::Interval(startIndex, stopIndex));\n   42    std::string message = \"reportAttemptingFullContext d=\" + decision + \", input='\" + text + \"'\";\n   43    recognizer->notifyErrorListeners(message);\n   ..\n   47    size_t stopIndex, size_t /*prediction*/, atn::ATNConfigSet * /*configs*/) {\n   48    std::string decision = getDecisionDescription(recognizer, dfa);\n   49:   std::string text = recognizer->getTokenStream()->getText(misc::Interval(startIndex, stopIndex));\n   50    std::string message = \"reportContextSensitivity d=\" + decision + \", input='\" + text + \"'\";\n   51    recognizer->notifyErrorListeners(message);\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/Lexer.cpp:\n  191  }\n  192  \n  193: std::string Lexer::getText() {\n  194    if (!_text.empty()) {\n  195      return _text;\n  196    }\n  197:   return getInterpreter<atn::LexerATNSimulator>()->getText(_input);\n  198  }\n  199  \n  ...\n  245  void Lexer::notifyListeners(const LexerNoViableAltException & /*e*/) {\n  246    ++_syntaxErrors;\n  247:   std::string text = _input->getText(misc::Interval(tokenStartCharIndex, _input->index()));\n  248    std::string msg = std::string(\"token recognition error at: '\") + getErrorDisplay(text) + std::string(\"'\");\n  249  \n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/Lexer.h:\n  138      /// Return the text matched so far for the current token or any\n  139      /// text override.\n  140:     virtual std::string getText();\n  141  \n  142      /// Set the complete text of this token; it wipes any previous\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/LexerNoViableAltException.cpp:\n   29    std::string symbol;\n   30    if (_startIndex < getInputStream()->size()) {\n   31:     symbol = static_cast<CharStream *>(getInputStream())->getText(misc::Interval(_startIndex, _startIndex));\n   32      symbol = antlrcpp::escapeWhitespace(symbol, false);\n   33    }\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/Parser.cpp:\n   42  void Parser::TraceListener::enterEveryRule(ParserRuleContext *ctx) {\n   43    std::cout << \"enter   \" << outerInstance->getRuleNames()[ctx->getRuleIndex()]\n   44:     << \", LT(1)=\" << outerInstance->_input->LT(1)->getText() << std::endl;\n   45  }\n   46  \n   ..\n   55  void Parser::TraceListener::exitEveryRule(ParserRuleContext *ctx) {\n   56    std::cout << \"exit    \" << outerInstance->getRuleNames()[ctx->getRuleIndex()]\n   57:     << \", LT(1)=\" << outerInstance->_input->LT(1)->getText() << std::endl;\n   58  }\n   59  \n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/ParserInterpreter.cpp:\n  288        size_t expectedTokenType = ime.getExpectedTokens().getMinElement(); // get any element\n  289        _errorToken = getTokenFactory()->create({ tok->getTokenSource(), tok->getTokenSource()->getInputStream() },\n  290:         expectedTokenType, tok->getText(), Token::DEFAULT_CHANNEL, INVALID_INDEX, INVALID_INDEX, // invalid start/stop\n  291          tok->getLine(), tok->getCharPositionInLine());\n  292        _ctx->addChild(createErrorNode(_errorToken.get()));\n  ...\n  295        Token *tok = e.getOffendingToken();\n  296        _errorToken = getTokenFactory()->create({ tok->getTokenSource(), tok->getTokenSource()->getInputStream() },\n  297:         Token::INVALID_TYPE, tok->getText(), Token::DEFAULT_CHANNEL, INVALID_INDEX, INVALID_INDEX, // invalid start/stop\n  298          tok->getLine(), tok->getCharPositionInLine());\n  299        _ctx->addChild(createErrorNode(_errorToken.get()));\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/Recognizer.cpp:\n  110      return \"<no Token>\";\n  111    }\n  112:   std::string s = t->getText();\n  113    if (s == \"\") {\n  114      if (t->getType() == EOF) {\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/RuleContext.cpp:\n   46  }\n   47  \n   48: std::string RuleContext::getText() {\n   49    if (children.empty()) {\n   50      return \"\";\n   ..\n   55      ParseTree *tree = children[i];\n   56      if (tree != nullptr)\n   57:       ss << tree->getText();\n   58    }\n   59  \n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/RuleContext.h:\n   79      virtual misc::Interval getSourceInterval() override;\n   80  \n   81:     virtual std::string getText() override;\n   82  \n   83      virtual size_t getRuleIndex() const;\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/Token.h:\n   48  \n   49      /// Get the text of the token.\n   50:     virtual std::string getText() const = 0;\n   51  \n   52      /// Get the token type of the token\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/TokenStream.h:\n   59      /// String text = \"\";\n   60      /// for (int i = interval.a; i <= interval.b; i++) {\n   61:     ///   text += stream.get(i).getText();\n   62      /// }\n   63      /// </pre>\n   ..\n   69      /// </returns>\n   70      /// <exception cref=\"NullPointerException\"> if {@code interval} is {@code null} </exception>\n   71:     virtual std::string getText(const misc::Interval &interval) = 0;\n   72  \n   73      /// <summary>\n   74      /// Return the text of all tokens in the stream. This method behaves like the\n   75      /// following code, including potential exceptions from the calls to\n   76:     /// <seealso cref=\"IntStream#size\"/> and <seealso cref=\"#getText(Interval)\"/>, but may be\n   77      /// optimized by the specific implementation.\n   78      ///\n   79      /// <pre>\n   80      /// TokenStream stream = ...;\n   81:     /// String text = stream.getText(new Interval(0, stream.size()));\n   82      /// </pre>\n   83      /// </summary>\n   84      /// <returns> The text of all tokens in the stream. </returns>\n   85:     virtual std::string getText() = 0;\n   86  \n   87      /// <summary>\n   88      /// Return the text of all tokens in the source interval of the specified\n   89      /// context. This method behaves like the following code, including potential\n   90:     /// exceptions from the call to <seealso cref=\"#getText(Interval)\"/>, but may be\n   91      /// optimized by the specific implementation.\n   92      /// </p>\n   ..\n   96      /// <pre>\n   97      /// TokenStream stream = ...;\n   98:     /// String text = stream.getText(ctx.getSourceInterval());\n   99      /// </pre>\n  100      /// </summary>\n  ...\n  102      /// text for. </param>\n  103      /// <returns> The text of all tokens within the source interval of {@code ctx}. </returns>\n  104:     virtual std::string getText(RuleContext *ctx) = 0;\n  105  \n  106      /// <summary>\n  ...\n  121      /// String text = \"\";\n  122      /// for (int i = start.getTokenIndex(); i <= stop.getTokenIndex(); i++) {\n  123:     ///   text += stream.get(i).getText();\n  124      /// }\n  125      /// </pre>\n  ...\n  132      /// <exception cref=\"UnsupportedOperationException\"> if this stream does not support\n  133      /// this method for the specified tokens </exception>\n  134:     virtual std::string getText(Token *start, Token *stop) = 0;\n  135    };\n  136  \n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/TokenStreamRewriter.cpp:\n   42    size_t dollarIndex = opName.find('$');\n   43    opName = opName.substr(dollarIndex + 1, opName.length() - (dollarIndex + 1));\n   44:   return \"<\" + opName + \"@\" + outerInstance->tokens->get(dollarIndex)->getText() + \":\\\"\" + text + \"\\\">\";\n   45  }\n   46  \n   ..\n   57    buf->append(text);\n   58    if (outerInstance->tokens->get(index)->getType() != Token::EOF) {\n   59:     buf->append(outerInstance->tokens->get(index)->getText());\n   60    }\n   61    return index + 1;\n   ..\n   76  std::string TokenStreamRewriter::ReplaceOp::toString() {\n   77    if (text.empty()) {\n   78:     return \"<DeleteOp@\" + outerInstance->tokens->get(index)->getText() + \"..\" + outerInstance->tokens->get(lastIndex)->getText() + \">\";\n   79    }\n   80:   return \"<ReplaceOp@\" + outerInstance->tokens->get(index)->getText() + \"..\" + outerInstance->tokens->get(lastIndex)->getText() + \":\\\"\" + text + \"\\\">\";\n   81  }\n   82  \n   ..\n  245  }\n  246  \n  247: std::string TokenStreamRewriter::getText() {\n  248:   return getText(DEFAULT_PROGRAM_NAME, Interval(0UL, tokens->size() - 1));\n  249  }\n  250  \n  251: std::string TokenStreamRewriter::getText(std::string programName) {\n  252:   return getText(programName, Interval(0UL, tokens->size() - 1));\n  253  }\n  254  \n  255: std::string TokenStreamRewriter::getText(const Interval &interval) {\n  256:   return getText(DEFAULT_PROGRAM_NAME, interval);\n  257  }\n  258  \n  259: std::string TokenStreamRewriter::getText(const std::string &programName, const Interval &interval) {\n  260    std::vector<TokenStreamRewriter::RewriteOperation*> &rewrites = _programs[programName];\n  261    size_t start = interval.a;\n  ...\n  271  \n  272    if (rewrites.empty() || rewrites.empty()) {\n  273:     return tokens->getText(interval); // no instructions to execute\n  274    }\n  275    std::string buf;\n  ...\n  287        // no operation at that index, just dump token\n  288        if (t->getType() != Token::EOF) {\n  289:         buf.append(t->getText());\n  290        }\n  291        i++; // move to next token\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/TokenStreamRewriter.h:\n   15     * You can insert stuff, replace, and delete chunks. Note that the operations\n   16     * are done lazily--only if you convert the buffer to a {@link String} with\n   17:    * {@link TokenStream#getText()}. This is very efficient because you are not\n   18     * moving data around all the time. As the buffer of tokens is converted to\n   19:    * strings, the {@link #getText()} method(s) scan the input token stream and\n   20     * check to see if there is an operation at the current index. If so, the\n   21     * operation is done and then normal {@link String} rendering continues on the\n   ..\n   27     * stream to fill itself up nor does it advance the input cursor. The token\n   28     * stream {@link TokenStream#index()} will return the same value before and\n   29:    * after any {@link #getText()} call.</p>\n   30     *\n   31     * <p>\n   32     * The rewriter only works on tokens that you have in the buffer and ignores the\n   33     * current input cursor. If you are buffering tokens on-demand, calling\n   34:    * {@link #getText()} halfway through the input will only do rewrites for those\n   35     * tokens in the first half of the file.</p>\n   36     *\n   37     * <p>\n   38:    * Since the operations are done lazily at {@link #getText}-time, operations do\n   39     * not screw up the token index values. That is, an insert operation at token\n   40     * index {@code i} does not change the index values for tokens\n   ..\n   64     * rewriter.insertAfter(t, \"text to put after t\");}\n   65     * rewriter.insertAfter(u, \"text after u\");}\n   66:    * System.out.println(rewriter.getText());\n   67     * </pre>\n   68     *\n   ..\n   76     * rewriter.insertAfter(\"pass1\", t, \"text to put after t\");}\n   77     * rewriter.insertAfter(\"pass2\", u, \"text after u\");}\n   78:    * System.out.println(rewriter.getText(\"pass1\"));\n   79:    * System.out.println(rewriter.getText(\"pass2\"));\n   80     * </pre>\n   81     *\n   ..\n  134      /// Return the text from the original tokens altered per the\n  135      /// instructions given to this rewriter.\n  136:     virtual std::string getText();\n  137  \n  138      /** Return the text from the original tokens altered per the\n  139       *  instructions given to this rewriter in programName.\n  140       */\n  141:     std::string getText(std::string programName);\n  142  \n  143      /// Return the text associated with the tokens in the interval from the\n  ...\n  149      /// insertBefore on the first token, you would get that insertion.\n  150      /// The same is true if you do an insertAfter the stop token.\n  151:     virtual std::string getText(const misc::Interval &interval);\n  152  \n  153:     virtual std::string getText(const std::string &programName, const misc::Interval &interval);\n  154  \n  155    protected:\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/tree/ParseTree.h:\n   56      /// off-channel tokens (if any) so won't return whitespace and\n   57      /// comments if they are sent to parser on hidden channel.\n   58:     virtual std::string getText() = 0;\n   59  \n   60      /**\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/tree/pattern/ParseTreePatternMatcher.cpp:\n  156            labels[tokenTagToken->getLabel()].push_back(tree);\n  157          }\n  158:       } else if (t1->getText() == t2->getText()) {\n  159          // x and x\n  160        } else {\n  ...\n  259      } else {\n  260        TextChunk &textChunk = (TextChunk&)chunk;\n  261:       ANTLRInputStream input(textChunk.getText());\n  262        _lexer->setInputStream(&input);\n  263        std::unique_ptr<Token> t(_lexer->nextToken());\n  ...\n  354      if (is<TextChunk *>(&c)) {\n  355        TextChunk &tc = (TextChunk&)c;\n  356:       std::string unescaped = tc.getText();\n  357        unescaped.erase(std::remove(unescaped.begin(), unescaped.end(), '\\\\'), unescaped.end());\n  358:       if (unescaped.length() < tc.getText().length()) {\n  359          chunks[i] = TextChunk(unescaped);\n  360        }\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/tree/pattern/RuleTagToken.cpp:\n   33  }\n   34  \n   35: std::string RuleTagToken::getText() const {\n   36    if (label != \"\") {\n   37      return std::string(\"<\") + label + std::string(\":\") + ruleName + std::string(\">\");\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/tree/pattern/RuleTagToken.h:\n   82      /// delimiters.\n   83      /// </summary>\n   84:     virtual std::string getText() const override;\n   85  \n   86      /// Rule tag tokens have types assigned according to the rule bypass\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/tree/pattern/TextChunk.cpp:\n   20  }\n   21  \n   22: std::string TextChunk::getText() {\n   23    return text;\n   24  }\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/tree/pattern/TextChunk.h:\n   19    private:\n   20      /// <summary>\n   21:     /// This is the backing field for <seealso cref=\"#getText\"/>.\n   22      /// </summary>\n   23      const std::string text;\n   ..\n   36      /// </summary>\n   37      /// <returns> The text of the chunk. </returns>\n   38:     std::string getText();\n   39  \n   40      /// <summary>\n   ..\n   42      /// <p/>\n   43      /// The implementation for <seealso cref=\"TextChunk\"/> returns the result of\n   44:     /// <seealso cref=\"#getText()\"/> in single quotes.\n   45      /// </summary>\n   46      virtual std::string toString() override;\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/tree/pattern/TokenTagToken.cpp:\n   24  }\n   25  \n   26: std::string TokenTagToken::getText() const {\n   27    if (!label.empty()) {\n   28      return \"<\" + label + \":\" + tokenName + \">\";\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/tree/pattern/TokenTagToken.h:\n   65      /// formatted with {@code <} and {@code >} delimiters.\n   66      /// </summary>\n   67:     virtual std::string getText() const override;\n   68  \n   69      /// <summary>\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/tree/TerminalNodeImpl.cpp:\n   38  }\n   39  \n   40: std::string TerminalNodeImpl::getText() {\n   41:   return symbol->getText();\n   42  }\n   43  \n   ..\n   50      return \"<EOF>\";\n   51    }\n   52:   return symbol->getText();\n   53  }\n   54  \n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/tree/TerminalNodeImpl.h:\n   23      virtual antlrcpp::Any accept(ParseTreeVisitor *visitor) override;\n   24  \n   25:     virtual std::string getText() override;\n   26      virtual std::string toStringTree(Parser *parser, bool pretty = false) override;\n   27      virtual std::string toString() override;\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/tree/Trees.cpp:\n  111        Token *symbol = dynamic_cast<TerminalNode *>(t)->getSymbol();\n  112        if (symbol != nullptr) {\n  113:         std::string s = symbol->getText();\n  114          return s;\n  115        }\n  ...\n  118    // no recog for rule names\n  119    if (is<RuleContext *>(t)) {\n  120:     return dynamic_cast<RuleContext *>(t)->getText();\n  121    }\n  122  \n  123    if (is<TerminalNodeImpl *>(t)) {\n  124:     return dynamic_cast<TerminalNodeImpl *>(t)->getSymbol()->getText();\n  125    }\n  126  \n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/tree/xpath/XPath.cpp:\n   93    }\n   94  \n   95:   std::string word = wordToken->getText();\n   96    size_t ttype = _parser->getTokenType(word);\n   97    ssize_t ruleIndex = _parser->getRuleIndex(word);\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/tree/xpath/XPathLexer.cpp:\n   58    switch (actionIndex) {\n   59      case 0: \n   60:     \t\t\t\tif (isupper(getText()[0]))\n   61      \t\t\t\t  setType(TOKEN_REF);\n   62      \t\t\t\telse\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/tree/xpath/XPathLexer.g4:\n   27  ID\t\t\t:\tNameStartChar NameChar*\n   28  \t\t\t\t{\n   29: \t\t\t\tif (isupper(getText()[0]))\n   30  \t\t\t\t  setType(TOKEN_REF);\n   31  \t\t\t\telse\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/UnbufferedCharStream.cpp:\n  178  }\n  179  \n  180: std::string UnbufferedCharStream::getText(const misc::Interval &interval) {\n  181    if (interval.a < 0 || interval.b >= interval.a - 1) {\n  182      throw IllegalArgumentException(\"invalid interval\");\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/UnbufferedCharStream.h:\n   46      virtual size_t size() override;\n   47      virtual std::string getSourceName() const override;\n   48:     virtual std::string getText(const misc::Interval &interval) override;\n   49  \n   50    protected:\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/UnbufferedTokenStream.cpp:\n   70  }\n   71  \n   72: std::string UnbufferedTokenStream::getText()\n   73  {\n   74    return \"\";\n   75  }\n   76  \n   77: std::string UnbufferedTokenStream::getText(RuleContext* ctx)\n   78  {\n   79:   return getText(ctx->getSourceInterval());\n   80  }\n   81  \n   82: std::string UnbufferedTokenStream::getText(Token *start, Token *stop)\n   83  {\n   84:   return getText(misc::Interval(start->getTokenIndex(), stop->getTokenIndex()));\n   85  }\n   86  \n   ..\n  232  }\n  233  \n  234: std::string UnbufferedTokenStream::getText(const misc::Interval &interval)\n  235  {\n  236    size_t bufferStartIndex = getBufferStartIndex();\n  ...\n  252      if (i > 0)\n  253        ss << \", \";\n  254:     ss << t->getText();\n  255    }\n  256  \n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/UnbufferedTokenStream.h:\n   25      virtual TokenSource* getTokenSource() const override;\n   26  \n   27:     virtual std::string getText(const misc::Interval &interval) override;\n   28:     virtual std::string getText() override;\n   29:     virtual std::string getText(RuleContext *ctx) override;\n   30:     virtual std::string getText(Token *start, Token *stop) override;\n   31  \n   32      virtual void consume() override;\n\n129 matches across 46 files\n\n\nSearching 308 files for \"addParseListener\" (case sensitive)\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/Parser.cpp:\n  155        return;\n  156      }\n  157:     addParseListener(&TrimToSizeListener::INSTANCE);\n  158    } else {\n  159      removeParseListener(&TrimToSizeListener::INSTANCE);\n  ...\n  169  }\n  170  \n  171: void Parser::addParseListener(tree::ParseTreeListener *listener) {\n  172    if (!listener) {\n  173      throw NullPointerException(\"listener\");\n  ...\n  619        removeParseListener(_tracer); // Just in case this is triggered multiple times.\n  620      _tracer = new TraceListener(this);\n  621:     addParseListener(_tracer);\n  622    }\n  623  }\n\n/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src/Parser.h:\n  156      /// </param>\n  157      /// <exception cref=\"NullPointerException\"> if {@code} listener is {@code null} </exception>\n  158:     virtual void addParseListener(tree::ParseTreeListener *listener);\n  159  \n  160      /// <summary>\n  ...\n  164      /// listener, this method does nothing.\n  165      /// </summary>\n  166:     /// <seealso cref= #addParseListener\n  167      /// </seealso>\n  168      /// <param name=\"listener\"> the listener to remove </param>\n  ...\n  172      /// Remove all parse listeners.\n  173      /// </summary>\n  174:     /// <seealso cref= #addParseListener </seealso>\n  175      virtual void removeParseListeners();\n  176  \n  ...\n  178      /// Notify any parse listeners of an enter rule event.\n  179      /// </summary>\n  180:     /// <seealso cref= #addParseListener </seealso>\n  181      virtual void triggerEnterRuleEvent();\n  182  \n  ...\n  184      /// Notify any parse listeners of an exit rule event.\n  185      /// </summary>\n  186:     /// <seealso cref= #addParseListener </seealso>\n  187      virtual void triggerExitRuleEvent();\n  188  \n  ...\n  431      /// The list of <seealso cref=\"ParseTreeListener\"/> listeners registered to receive\n  432      /// events during the parse.\n  433:     /// <seealso cref= #addParseListener </seealso>\n  434      std::vector<tree::ParseTreeListener *> _parseListeners;\n  435  \n\n9 matches across 2 files\n",
			"settings":
			{
				"buffer_size": 75186,
				"line_ending": "Unix",
				"name": "Find Results",
				"scratch": true
			}
		},
		{
			"file": "third_party/antlr4/runtime/Cpp/runtime/src/atn/LexerATNSimulator.cpp",
			"settings":
			{
				"buffer_size": 21812,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/antlr4/runtime/Cpp/runtime/src/UnbufferedTokenStream.cpp",
			"settings":
			{
				"buffer_size": 7464,
				"encoding": "UTF-8 with BOM",
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/max/dev/RadeonProRenderUSD/deps/RPR/RadeonProRender/inc/RadeonProRender_v2.h",
			"settings":
			{
				"buffer_size": 124838,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#ifndef LAVA_LAVA_H_\n#define LAVA_LAVA_H_\n\n#include <type_traits>\n\n#include \"types.h\"\n#include \"renderer.h\"\n\n#endif  // LAVA_LAVA_H_\n",
			"file": "src/lava/lava.h",
			"file_size": 133,
			"file_write_time": 132424184340332059,
			"settings":
			{
				"buffer_size": 133,
				"line_ending": "Unix",
				"name": "#ifndef LAVA_TYPES_H_"
			}
		},
		{
			"contents": "#ifndef LAVA_TYPES_H_\n#define LAVA_TYPES_H_\n\nnamespace lava {\n\n// lava aov\ntypedef enum {\n\tLAVA_AOV_COLOR = 0x0 ,\n\tLAVA_AOV_OPACITY = 0x1 ,\n\tLAVA_AOV_WORLD_COORDINATE = 0x2 ,\n\tLAVA_AOV_UV = 0x3 ,\n\tLAVA_AOV_MATERIAL_IDX = 0x4 ,\n\tLAVA_AOV_GEOMETRIC_NORMAL = 0x5 ,\n\tLAVA_AOV_SHADING_NORMAL = 0x6 ,\n\tLAVA_AOV_DEPTH = 0x7 ,\n\tLAVA_AOV_OBJECT_ID = 0x8 ,\n\tLAVA_AOV_OBJECT_GROUP_ID = 0x9 ,\n\tLAVA_AOV_SHADOW_CATCHER = 0x0a ,\n\tLAVA_AOV_BACKGROUND = 0x0b ,\n\tLAVA_AOV_EMISSION = 0x0c ,\n\tLAVA_AOV_VELOCITY = 0x0d ,\n\tLAVA_AOV_DIRECT_ILLUMINATION = 0x0e ,\n\tLAVA_AOV_INDIRECT_ILLUMINATION = 0x0f ,\n\tLAVA_AOV_AO = 0x10 ,\n\tLAVA_AOV_DIRECT_DIFFUSE = 0x11 ,\n\tLAVA_AOV_DIRECT_REFLECT = 0x12 ,\n\tLAVA_AOV_INDIRECT_DIFFUSE = 0x13 ,\n\tLAVA_AOV_INDIRECT_REFLECT = 0x14 ,\n\tLAVA_AOV_REFRACT = 0x15 ,\n\tLAVA_AOV_VOLUME = 0x16 ,\n\tLAVA_AOV_LIGHT_GROUP0 = 0x17 ,\n\tLAVA_AOV_LIGHT_GROUP1 = 0x18 ,\n\tLAVA_AOV_LIGHT_GROUP2 = 0x19 ,\n\tLAVA_AOV_LIGHT_GROUP3 = 0x1a ,\n\tLAVA_AOV_DIFFUSE_ALBEDO = 0x1b ,\n\tLAVA_AOV_VARIANCE = 0x1c ,\n\tLAVA_AOV_VIEW_SHADING_NORMAL = 0x1d,\n\tLAVA_AOV_REFLECTION_CATCHER = 0x1e,\n\tLAVA_AOV_COLOR_RIGHT = 0x1f ,\n} Aov;\n\n// lava status\ntypedef enum {\n\tLAVA_SUCCESS = 0 ,\n\tLAVA_ERROR_COMPUTE_API_NOT_SUPPORTED = -1 ,\n\tLAVA_ERROR_OUT_OF_SYSTEM_MEMORY = -2 ,\n\tLAVA_ERROR_OUT_OF_VIDEO_MEMORY = -3 ,\n\tLAVA_ERROR_INVALID_LIGHTPATH_EXPR = -5 ,\n\tLAVA_ERROR_INVALID_IMAGE = -6 ,\n\tLAVA_ERROR_INVALID_AA_METHOD = -7 ,\n\tLAVA_ERROR_UNSUPPORTED_IMAGE_FORMAT = -8 ,\n\tLAVA_ERROR_INVALID_GL_TEXTURE = -9 ,\n\tLAVA_ERROR_INVALID_CL_IMAGE = -10 ,\n\tLAVA_ERROR_INVALID_OBJECT = -11 ,\n\tLAVA_ERROR_INVALID_PARAMETER = -12 ,\n\tLAVA_ERROR_INVALID_TAG = -13 ,\n\tLAVA_ERROR_INVALID_LIGHT = -14 ,\n\tLAVA_ERROR_INVALID_RENDERER = -15 ,\n\tLAVA_ERROR_UNIMPLEMENTED = -16 ,\n\tLAVA_ERROR_INVALID_API_VERSION = -17 ,\n\tLAVA_ERROR_INTERNAL_ERROR = -18 ,\n\tLAVA_ERROR_IO_ERROR = -19 ,\n\tLAVA_ERROR_UNSUPPORTED_SHADER_PARAMETER_TYPE = -20 ,\n\tLAVA_ERROR_MATERIAL_STACK_OVERFLOW = -21 ,\n\tLAVA_ERROR_INVALID_PARAMETER_TYPE = -22 ,\n\tLAVA_ERROR_UNSUPPORTED = -23 ,\n\tLAVA_ERROR_OPENCL_OUT_OF_HOST_MEMORY = -24 ,\n\tLAVA_ERROR_OPENGL = -25 ,\n\tLAVA_ERROR_OPENCL = -26 ,\n\tLAVA_ERROR_NULLPTR = -27 ,\n\tLAVA_ERROR_NODETYPE = -28 ,\n\tLAVA_ERROR_ABORTED = -29 ,\n} Status;\n\n// renderer info\n\ntypedef enum {\n\tLAVA_RENDERER_CREATION_FLAGS = 0x102 ,\n\tLAVA_RENDERER_CACHE_PATH = 0x103 ,\n\tLAVA_RENDERER_RENDER_STATUS = 0x104 ,\n\tLAVA_RENDERER_RENDER_STATISTICS = 0x105 ,\n\tLAVA_RENDERER_DEVICE_COUNT = 0x106 ,\n\tLAVA_RENDERER_PARAMETER_COUNT = 0x107 ,\n\tLAVA_RENDERER_ACTIVE_PLUGIN = 0x108 ,\n\tLAVA_RENDERER_SCENE = 0x109 ,\n\tLAVA_RENDERER_ITERATIONS = 0x10B ,\n\tLAVA_RENDERER_IMAGE_FILTER_TYPE = 0x10C ,\n\tLAVA_RENDERER_IMAGE_FILTER_BOX_RADIUS = 0x10D ,\n\tLAVA_RENDERER_IMAGE_FILTER_GAUSSIAN_RADIUS = 0x10E ,\n\tLAVA_RENDERER_IMAGE_FILTER_TRIANGLE_RADIUS = 0x10F ,\n\tLAVA_RENDERER_IMAGE_FILTER_MITCHELL_RADIUS = 0x110 ,\n\tLAVA_RENDERER_IMAGE_FILTER_LANCZOS_RADIUS = 0x111 ,\n\tLAVA_RENDERER_IMAGE_FILTER_BLACKMANHARRIS_RADIUS = 0x112 ,\n\tLAVA_RENDERER_TONE_MAPPING_TYPE = 0x113 ,\n\tLAVA_RENDERER_TONE_MAPPING_LINEAR_SCALE = 0x114 ,\n\tLAVA_RENDERER_TONE_MAPPING_PHOTO_LINEAR_SENSITIVITY = 0x115 ,\n\tLAVA_RENDERER_TONE_MAPPING_PHOTO_LINEAR_EXPOSURE = 0x116 ,\n\tLAVA_RENDERER_TONE_MAPPING_PHOTO_LINEAR_FSTOP = 0x117 ,\n\tLAVA_RENDERER_TONE_MAPPING_REINHARD02_PRE_SCALE = 0x118 ,\n\tLAVA_RENDERER_TONE_MAPPING_REINHARD02_POST_SCALE = 0x119 ,\n\tLAVA_RENDERER_TONE_MAPPING_REINHARD02_BURN = 0x11A ,\n\tLAVA_RENDERER_MAX_RECURSION = 0x11B ,\n\tLAVA_RENDERER_RAY_CAST_EPISLON = 0x11C ,\n\tLAVA_RENDERER_RADIANCE_CLAMP = 0x11D ,\n\tLAVA_RENDERER_X_FLIP = 0x11E ,\n\tLAVA_RENDERER_Y_FLIP = 0x11F ,\n\tLAVA_RENDERER_TEXTURE_GAMMA = 0x120 ,\n\tLAVA_RENDERER_PDF_THRESHOLD = 0x121 ,\n\tLAVA_RENDERER_RENDER_MODE = 0x122 ,\n\tLAVA_RENDERER_ROUGHNESS_CAP = 0x123 ,\n\tLAVA_RENDERER_DISPLAY_GAMMA = 0x124 ,\n\tLAVA_RENDERER_MATERIAL_STACK_SIZE = 0x125 ,\n\tLAVA_RENDERER_CLIPPING_PLANE = 0x126 ,\n\tLAVA_RENDERER_GPU0_NAME = 0x127 ,\n\tLAVA_RENDERER_GPU1_NAME = 0x128 ,\n\tLAVA_RENDERER_GPU2_NAME = 0x129 ,\n\tLAVA_RENDERER_GPU3_NAME = 0x12A ,\n\tLAVA_RENDERER_CPU_NAME = 0x12B ,\n\tLAVA_RENDERER_GPU4_NAME = 0x12C ,\n\tLAVA_RENDERER_GPU5_NAME = 0x12D ,\n\tLAVA_RENDERER_GPU6_NAME = 0x12E ,\n\tLAVA_RENDERER_GPU7_NAME = 0x12F ,\n\tLAVA_RENDERER_TONE_MAPPING_EXPONENTIAL_INTENSITY = 0x130 ,\n\tLAVA_RENDERER_FRAMECOUNT = 0x131 ,\n\tLAVA_RENDERER_TEXTURE_COMPRESSION = 0x132 ,\n\tLAVA_RENDERER_AO_RAY_LENGTH = 0x133 ,\n\tLAVA_RENDERER_OOC_TEXTURE_CACHE = 0x134 ,\n\tLAVA_RENDERER_PREVIEW = 0x135 ,\n\tLAVA_RENDERER_CPU_THREAD_LIMIT = 0x136 ,\n\tLAVA_RENDERER_LAST_ERROR_MESSAGE = 0x137 ,\n\tLAVA_RENDERER_MAX_DEPTH_DIFFUSE = 0x138 ,\n\tLAVA_RENDERER_MAX_DEPTH_GLOSSY = 0x139 ,\n\tLAVA_RENDERER_OOC_CACHE_PATH = 0x13a ,\n\tLAVA_RENDERER_MAX_DEPTH_REFRACTION = 0x13B ,\n\tLAVA_RENDERER_MAX_DEPTH_GLOSSY_REFRACTION = 0x13C ,\n\tLAVA_RENDERER_RENDER_LAYER_MASK = 0x13D ,\n\tLAVA_RENDERER_SINGLE_LEVEL_BVH_ENABLED = 0x13E ,\n\tLAVA_RENDERER_TRANSPARENT_BACKGROUND = 0x13F ,\n\tLAVA_RENDERER_MAX_DEPTH_SHADOW = 0x140 ,\n\tLAVA_RENDERER_API_VERSION = 0x141 ,\n\tLAVA_RENDERER_GPU8_NAME = 0x142 ,\n\tLAVA_RENDERER_GPU9_NAME = 0x143 ,\n\tLAVA_RENDERER_GPU10_NAME = 0x144 ,\n\tLAVA_RENDERER_GPU11_NAME = 0x145 ,\n\tLAVA_RENDERER_GPU12_NAME = 0x146 ,\n\tLAVA_RENDERER_GPU13_NAME = 0x147 ,\n\tLAVA_RENDERER_GPU14_NAME = 0x148 ,\n\tLAVA_RENDERER_GPU15_NAME = 0x149 ,\n\tLAVA_RENDERER_API_VERSION_MINOR = 0x14A ,\n\tLAVA_RENDERER_METAL_PERFORMANCE_SHADER = 0x14B ,\n\tLAVA_RENDERER_USER_TEXTURE_0 = 0x14C ,\n\tLAVA_RENDERER_USER_TEXTURE_1 = 0x14D ,\n\tLAVA_RENDERER_USER_TEXTURE_2 = 0x14E ,\n\tLAVA_RENDERER_USER_TEXTURE_3 = 0x14F ,\n\tLAVA_RENDERER_MIPMAP_LOD_OFFSET = 0x150 ,\n\tLAVA_RENDERER_AO_RAY_COUNT = 0x151 ,\n\tLAVA_RENDERER_SAMPLER_TYPE = 0x152 ,\n\tLAVA_RENDERER_ADAPTIVE_SAMPLING_TILE_SIZE = 0x153 ,\n\tLAVA_RENDERER_ADAPTIVE_SAMPLING_MIN_SPP = 0x154 ,\n\tLAVA_RENDERER_ADAPTIVE_SAMPLING_THRESHOLD = 0x155 ,\n\tLAVA_RENDERER_TILE_SIZE = 0x156 ,\n\tLAVA_RENDERER_LIST_CREATED_CAMERAS = 0x157 ,\n\tLAVA_RENDERER_LIST_CREATED_MATERIALNODES = 0x158 ,\n\tLAVA_RENDERER_LIST_CREATED_LIGHTS = 0x159 ,\n\tLAVA_RENDERER_LIST_CREATED_SHAPES = 0x15A ,\n\tLAVA_RENDERER_LIST_CREATED_POSTEFFECTS = 0x15B ,\n\tLAVA_RENDERER_LIST_CREATED_HETEROVOLUMES = 0x15C ,\n\tLAVA_RENDERER_LIST_CREATED_GRIDS = 0x15D ,\n\tLAVA_RENDERER_LIST_CREATED_BUFFERS = 0x15E ,\n\tLAVA_RENDERER_LIST_CREATED_IMAGES = 0x15F ,\n\tLAVA_RENDERER_LIST_CREATED_FRAMEBUFFERS = 0x160 ,\n\tLAVA_RENDERER_LIST_CREATED_SCENES = 0x161 ,\n\tLAVA_RENDERER_LIST_CREATED_CURVES = 0x162 ,\n\tLAVA_RENDERER_LIST_CREATED_MATERIALSYSTEM = 0x163 ,\n\tLAVA_RENDERER_LIST_CREATED_COMPOSITE = 0x164 ,\n\tLAVA_RENDERER_LIST_CREATED_LUT = 0x165 ,\n\tLAVA_RENDERER_AA_ENABLED = 0x166 ,\n\tLAVA_RENDERER_ACTIVE_PIXEL_COUNT = 0x167 ,\n\tLAVA_RENDERER_TRACING_ENABLED = 0x168 ,\n\tLAVA_RENDERER_TRACING_PATH = 0x169 ,\n\tLAVA_RENDERER_TILE_RECT = 0x16A ,\n\tLAVA_RENDERER_PLUGIN_VERSION = 0x16B ,\n\tLAVA_RENDERER_RUSSIAN_ROULETTE_DEPTH = 0x16C ,\n\t//LAVA_RENDERER_NAME = LAVA_OBJECT_NAME,\n\t//LAVA_RENDERER_UNIQUE_ID = LAVA_OBJECT_UNIQUE_ID,\n\t//LAVA_RENDERER_CUSTOM_PTR = LAVA_OBJECT_CUSTOM_PTR,\n} RendererInfo ;\n\n}  // namespace Lava\n\n#endif  // LAVA_TYPES_H_\n",
			"file": "src/lava/types.h",
			"file_size": 6995,
			"file_write_time": 132424136045496068,
			"settings":
			{
				"buffer_size": 6995,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/max/dev/RadeonProRenderUSD/deps/RPR/RadeonProRender/inc/RadeonProRender.cs",
			"settings":
			{
				"buffer_size": 143659,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/max/dev/RadeonProRenderUSD/pxr/imaging/plugin/hdRpr/python/generateRenderSettingFiles.py",
			"settings":
			{
				"buffer_size": 24851,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/USD/cmake/macros/Private.cmake",
			"settings":
			{
				"buffer_size": 50720,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/D3D12/D3D12NvApiExDesc.h",
			"settings":
			{
				"buffer_size": 4956,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VkResource.cpp",
			"settings":
			{
				"buffer_size": 1884,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/Data/ForwardRenderer.py",
			"settings":
			{
				"buffer_size": 1872,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/Data/BSDFViewer.py",
			"settings":
			{
				"buffer_size": 634,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/glslang/glslang/Include/BaseTypes.h",
			"settings":
			{
				"buffer_size": 18643,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/glslang/glslang/MachineIndependent/Initialize.cpp",
			"settings":
			{
				"buffer_size": 477356,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Raster.slang",
			"settings":
			{
				"buffer_size": 4526,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/GBuffer/GBufferRaster.3d.slang",
			"settings":
			{
				"buffer_size": 7187,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/ShadingData.slang",
			"settings":
			{
				"buffer_size": 15181,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/Antialiasing/TAA/TAA.ps.slang",
			"settings":
			{
				"buffer_size": 5743,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Experimental/Scene/Lights/LightBVH.cpp",
			"settings":
			{
				"buffer_size": 18635,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Experimental/Scene/Lights/LightBVHBuilder.h",
			"settings":
			{
				"buffer_size": 11295,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Experimental/Scene/Lights/LightBVHBuilder.cpp",
			"settings":
			{
				"buffer_size": 41661,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Experimental/Scene/Lights/LightBVH.h",
			"settings":
			{
				"buffer_size": 12420,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Algorithm/ParallelReduction.ps.slang",
			"settings":
			{
				"buffer_size": 4191,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/BSDFViewer/BSDFViewerParams.slang",
			"settings":
			{
				"buffer_size": 6511,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/glslang/glslang/MachineIndependent/ParseHelper.cpp",
			"settings":
			{
				"buffer_size": 364782,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/glslang/SPIRV/SpvBuilder.cpp",
			"settings":
			{
				"buffer_size": 105150,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/source/slang/slang-ir.cpp",
			"settings":
			{
				"buffer_size": 150177,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/glslang/SPIRV/SpvBuilder.h",
			"settings":
			{
				"buffer_size": 35460,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/source/slang-glslang/slang-glslang.cpp",
			"settings":
			{
				"buffer_size": 18679,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/spirv-tools/source/spirv_target_env.cpp",
			"settings":
			{
				"buffer_size": 10524,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/spirv-tools/CHANGES",
			"settings":
			{
				"buffer_size": 47890,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/SceneBuilder.cpp",
			"settings":
			{
				"buffer_size": 23587,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/SceneTypes.slang",
			"settings":
			{
				"buffer_size": 5249,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/source/slang/slang-type-layout.cpp",
			"settings":
			{
				"buffer_size": 149248,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/source/slang/slang-type-layout.h",
			"settings":
			{
				"buffer_size": 34158,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/slang.h",
			"settings":
			{
				"buffer_size": 132132,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/glm/test/core/core_type_aligned.cpp",
			"settings":
			{
				"buffer_size": 5440,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Formats.cpp",
			"settings":
			{
				"buffer_size": 19719,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/glm/glm/gtx/compatibility.hpp",
			"settings":
			{
				"buffer_size": 14979,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKFormats.cpp",
			"settings":
			{
				"buffer_size": 10446,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/glslang/glslang/Include/intermediate.h",
			"settings":
			{
				"buffer_size": 54763,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/docs/language-reference/04-types.md",
			"settings":
			{
				"buffer_size": 14365,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/glslang/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 4705,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/glslang/SPIRV/GlslangToSpv.cpp",
			"settings":
			{
				"buffer_size": 339007,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/glslang/Test/100.frag",
			"settings":
			{
				"buffer_size": 4744,
				"line_ending": "Windows"
			}
		},
		{
			"file": "third_party/slang/external/glext.h",
			"settings":
			{
				"buffer_size": 811328,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/docs/wave-intrinsics.md",
			"settings":
			{
				"buffer_size": 13145,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/DebugPasses/InvalidPixelDetectionPass/InvalidPixelDetectionPass.cpp",
			"settings":
			{
				"buffer_size": 4322,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Core/RootBufferParamBlockTests.cpp",
			"settings":
			{
				"buffer_size": 8904,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Core/RootBufferParamBlockTests.cs.slang",
			"settings":
			{
				"buffer_size": 3086,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Core/ParamBlockDefinition.slang",
			"settings":
			{
				"buffer_size": 2225,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/ProgramVersion.cpp",
			"settings":
			{
				"buffer_size": 8252,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderGraphIR.cpp",
			"settings":
			{
				"buffer_size": 5845,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderGraphIR.h",
			"settings":
			{
				"buffer_size": 3409,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Importers/AssimpImporter.cpp",
			"settings":
			{
				"buffer_size": 44987,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Importers/AssimpImporter.h",
			"settings":
			{
				"buffer_size": 2484,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Importers/PythonImporter.h",
			"settings":
			{
				"buffer_size": 2145,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Camera/Camera.h",
			"settings":
			{
				"buffer_size": 11607,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Sampling/SampleGenerator.h",
			"settings":
			{
				"buffer_size": 4312,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/SampleGenerators/StratifiedSamplePattern.h",
			"settings":
			{
				"buffer_size": 3466,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/SampleGenerators/HaltonSamplePattern.h",
			"settings":
			{
				"buffer_size": 3159,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/SampleGenerators/CPUSampleGenerator.h",
			"settings":
			{
				"buffer_size": 2791,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/GraphicsStateObject.h",
			"settings":
			{
				"buffer_size": 6433,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/GraphicsStateObject.cpp",
			"settings":
			{
				"buffer_size": 4274,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKFbo.cpp",
			"settings":
			{
				"buffer_size": 5380,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/ComputeStateObject.h",
			"settings":
			{
				"buffer_size": 3496,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Experimental/Scene/Lights/EnvProbe.cpp",
			"settings":
			{
				"buffer_size": 6616,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/ComputeContext.h",
			"settings":
			{
				"buffer_size": 3969,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/GpuTimer.h",
			"settings":
			{
				"buffer_size": 3787,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/LowLevelContextData.h",
			"settings":
			{
				"buffer_size": 3656,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Timing/Profiler.h",
			"settings":
			{
				"buffer_size": 8484,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Platform/Windows/Windows.cpp",
			"settings":
			{
				"buffer_size": 26025,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/tools/gfx/d3d12/render-d3d12.cpp",
			"settings":
			{
				"buffer_size": 139342,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/tools/gfx/vulkan/render-vk.cpp",
			"settings":
			{
				"buffer_size": 99401,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Raytracing/RtProgramVarsHelper.cpp",
			"settings":
			{
				"buffer_size": 6214,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/D3D12/FalcorD3D12.h",
			"settings":
			{
				"buffer_size": 9709,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Platform/OS.cpp",
			"settings":
			{
				"buffer_size": 8771,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/SkyBox/SkyBox.slang",
			"settings":
			{
				"buffer_size": 2520,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/CSM/VisibilityPass.ps.slang",
			"settings":
			{
				"buffer_size": 2953,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/ToneMapper/ToneMapping.ps.slang",
			"settings":
			{
				"buffer_size": 5616,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/ToneMapper/Luminance.ps.slang",
			"settings":
			{
				"buffer_size": 2106,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Importers/PythonImporter.cpp",
			"settings":
			{
				"buffer_size": 3931,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Importers/SceneImporter.cpp",
			"settings":
			{
				"buffer_size": 36435,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Importers/SceneImporter.h",
			"settings":
			{
				"buffer_size": 2157,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/Program.h",
			"settings":
			{
				"buffer_size": 12423,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/GraphicsProgram.h",
			"settings":
			{
				"buffer_size": 3809,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/ComputeProgram.h",
			"settings":
			{
				"buffer_size": 3818,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/GraphicsProgram.cpp",
			"settings":
			{
				"buffer_size": 2616,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Camera/Camera.slang",
			"settings":
			{
				"buffer_size": 5388,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/ArgList.h",
			"settings":
			{
				"buffer_size": 4051,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/Mogwai.cpp",
			"settings":
			{
				"buffer_size": 25052,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/stdafx.h",
			"settings":
			{
				"buffer_size": 1851,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Renderer.h",
			"settings":
			{
				"buffer_size": 7238,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderPassLibrary.cpp",
			"settings":
			{
				"buffer_size": 11374,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderPassLibrary.h",
			"settings":
			{
				"buffer_size": 5360,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/UserInput.h",
			"settings":
			{
				"buffer_size": 7116,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Externals/GLM/glm/gtx/compatibility.hpp",
			"settings":
			{
				"buffer_size": 14969,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Sample.h",
			"settings":
			{
				"buffer_size": 7395,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/Gui.h",
			"settings":
			{
				"buffer_size": 26357,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Window.cpp",
			"settings":
			{
				"buffer_size": 17937,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Window.h",
			"settings":
			{
				"buffer_size": 5627,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/ArgList.cpp",
			"settings":
			{
				"buffer_size": 6269,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/AlignedAllocator.h",
			"settings":
			{
				"buffer_size": 6544,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Resource.h",
			"settings":
			{
				"buffer_size": 7622,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Core/BufferTests.cpp",
			"settings":
			{
				"buffer_size": 6996,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/DebugPasses/InvalidPixelDetectionTests.cpp",
			"settings":
			{
				"buffer_size": 3746,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/ShadingUtils/ShadingUtilsTests.cpp",
			"settings":
			{
				"buffer_size": 12331,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Testing/UnitTest.h",
			"settings":
			{
				"buffer_size": 18208,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Testing/UnitTest.cpp",
			"settings":
			{
				"buffer_size": 11972,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/ComputeProgram.cpp",
			"settings":
			{
				"buffer_size": 2634,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Core/BufferAccessTests.cpp",
			"settings":
			{
				"buffer_size": 6233,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Core/BufferAccessTests.cs.slang",
			"settings":
			{
				"buffer_size": 1913,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Resource.cpp",
			"settings":
			{
				"buffer_size": 5154,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/RenderContext.h",
			"settings":
			{
				"buffer_size": 11441,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/RenderContext.cpp",
			"settings":
			{
				"buffer_size": 5362,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/RasterizerState.h",
			"settings":
			{
				"buffer_size": 7490,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/RasterizerState.cpp",
			"settings":
			{
				"buffer_size": 2247,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKRasterizerState.cpp",
			"settings":
			{
				"buffer_size": 2034,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/QueryHeap.h",
			"settings":
			{
				"buffer_size": 3579,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Formats.h",
			"settings":
			{
				"buffer_size": 13822,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Buffer.h",
			"settings":
			{
				"buffer_size": 19243,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Experimental/Scene/Lights/EnvProbe.h",
			"settings":
			{
				"buffer_size": 3717,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 1908,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/Extensions/Capture/CaptureTrigger.cpp",
			"settings":
			{
				"buffer_size": 7579,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/Extensions/Capture/VideoCapture.cpp",
			"settings":
			{
				"buffer_size": 9661,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/Extensions/Capture/FrameCapture.cpp",
			"settings":
			{
				"buffer_size": 6569,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/Extensions/Capture/FrameCapture.h",
			"settings":
			{
				"buffer_size": 2710,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/RenderGraphEditor/RenderGraphEditor.cpp",
			"settings":
			{
				"buffer_size": 20776,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Externals/dear_imgui_addons/imguinodegrapheditor/imguinodegrapheditor.h",
			"settings":
			{
				"buffer_size": 47853,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/ImageCompare/ImageCompare.cpp",
			"settings":
			{
				"buffer_size": 14050,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/Mogwai.h",
			"settings":
			{
				"buffer_size": 8364,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderGraphImportExport.cpp",
			"settings":
			{
				"buffer_size": 6264,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/ResourceCache.cpp",
			"settings":
			{
				"buffer_size": 8382,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Animation/AnimationController.cpp",
			"settings":
			{
				"buffer_size": 13034,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderPassReflection.cpp",
			"settings":
			{
				"buffer_size": 12090,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderPass.cpp",
			"settings":
			{
				"buffer_size": 2471,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderPasses/ResolvePass.h",
			"settings":
			{
				"buffer_size": 2717,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderPasses/ResolvePass.cpp",
			"settings":
			{
				"buffer_size": 3142,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "file( GLOB SOURCES\n    ./*.cpp\n)\n\n# Python\nfind_package( PythonLibs 3.7 REQUIRED )\ninclude_directories( ${PYTHON_INCLUDE_DIRS} )\n\n# FreeImage\nfind_package(FreeImage REQUIRED)\ninclude_directories( ${FREEIMAGE_INCLUDE_DIRS} )\n\n# Find Boost libs\nfind_package( Boost COMPONENTS system filesystem REQUIRED )\ninclude_directories( ${Boost_INCLUDE_DIRS} )\n\n# We use Boost static libs\nadd_definitions( -DBOOST_LOG_DYN_LINK )\n\n\nadd_library( lava_lib SHARED ${SOURCES} ${HEADERS} )\n\ntarget_link_libraries(\n    lava_lib\n    falcor_lib\n)\n\n\nif(APPLE)\n    if( COPPER_BUILD_LIBS_AS_FRAMEWORKS )\n\t#falcor_config_framework( lava_lib )\n\n    # Framework is called 'Falcor'\n    set_target_properties( lava_lib PROPERTIES OUTPUT_NAME \"Falcor\" )\n    install( TARGETS lava_lib DESTINATION \"Frameworks\" )\n  else()\n    install( TARGETS lava_lib DESTINATION \"lib\" )\n  endif()\n\nelseif(UNIX)\n    install( TARGETS lava_lib DESTINATION lib )\nendif()\n",
			"file": "src/lava/CMakeLists.txt",
			"file_size": 919,
			"file_write_time": 132424978511987052,
			"settings":
			{
				"buffer_size": 919,
				"line_ending": "Unix",
				"name": "file( GLOB SOURCES"
			}
		},
		{
			"file": "src/Falcor/Scene/ParticleSystem/ParticleSystem.h",
			"settings":
			{
				"buffer_size": 10438,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/ParticleSystem/ParticleSystem.cpp",
			"settings":
			{
				"buffer_size": 16405,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/HitInfo.h",
			"settings":
			{
				"buffer_size": 3622,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Samples/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 1201,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/RenderGraphEditor/RenderGraphEditor.h",
			"settings":
			{
				"buffer_size": 3325,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/DebugPasses/DebugPasses.cpp",
			"settings":
			{
				"buffer_size": 2422,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/DebugPasses/SplitScreenPass/SplitScreenPass.h",
			"settings":
			{
				"buffer_size": 3241,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/DebugPasses/SplitScreenPass/SplitScreenPass.cpp",
			"settings":
			{
				"buffer_size": 6309,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/DebugPasses/SideBySidePass/SideBySidePass.h",
			"settings":
			{
				"buffer_size": 2670,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/DebugPasses/SideBySidePass/SideBySidePass.cpp",
			"settings":
			{
				"buffer_size": 3143,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/DebugPasses/InvalidPixelDetectionPass/InvalidPixelDetectionPass.h",
			"settings":
			{
				"buffer_size": 2841,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/CSM/CSM.h",
			"settings":
			{
				"buffer_size": 9053,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/CSM/CSM.cpp",
			"settings":
			{
				"buffer_size": 35619,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/Gui.slang",
			"settings":
			{
				"buffer_size": 2501,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/TextRenderer.slang",
			"settings":
			{
				"buffer_size": 2282,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/ErrorMeasurePass/ErrorMeasurePass.cpp",
			"settings":
			{
				"buffer_size": 16583,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/VBuffer/VBufferRaster.h",
			"settings":
			{
				"buffer_size": 3145,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/ErrorMeasurePass/ErrorMeasurePass.h",
			"settings":
			{
				"buffer_size": 4985,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/PixelInspectorPass/PixelInspectorPass.h",
			"settings":
			{
				"buffer_size": 3691,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderPass.h",
			"settings":
			{
				"buffer_size": 7147,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/PixelInspectorPass/PixelInspectorPass.cpp",
			"settings":
			{
				"buffer_size": 15137,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/SSAO/SSAO.h",
			"settings":
			{
				"buffer_size": 4594,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/SkyBox/SkyBox.h",
			"settings":
			{
				"buffer_size": 3515,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/SkyBox/SkyBox.cpp",
			"settings":
			{
				"buffer_size": 8117,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/Antialiasing/FXAA/FXAA.h",
			"settings":
			{
				"buffer_size": 3484,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/Antialiasing/TAA/TAA.h",
			"settings":
			{
				"buffer_size": 3271,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/Antialiasing/TAA/TAA.cpp",
			"settings":
			{
				"buffer_size": 5491,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/Antialiasing/FXAA/FXAA.cpp",
			"settings":
			{
				"buffer_size": 4663,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/SkyBox/Data/cube.obj",
			"settings":
			{
				"buffer_size": 401,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/ForwardLightingPass/ForwardLightingPass.h",
			"settings":
			{
				"buffer_size": 4770,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/ForwardLightingPass/ForwardLightingPass.cpp",
			"settings":
			{
				"buffer_size": 9795,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/ImageLoader/ImageLoader.h",
			"settings":
			{
				"buffer_size": 3059,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/ImageLoader/ImageLoader.cpp",
			"settings":
			{
				"buffer_size": 5146,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/ToneMapper/ToneMapper.h",
			"settings":
			{
				"buffer_size": 5743,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/ToneMapper/ToneMapper.cpp",
			"settings":
			{
				"buffer_size": 16343,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/AccumulatePass/AccumulatePass.cpp",
			"settings":
			{
				"buffer_size": 10962,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/GBufferBase.h",
			"settings":
			{
				"buffer_size": 3832,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/GBufferBase.cpp",
			"settings":
			{
				"buffer_size": 6981,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/SampleGenerators/HaltonSamplePattern.cpp",
			"settings":
			{
				"buffer_size": 2647,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/VBuffer/VBufferRT.h",
			"settings":
			{
				"buffer_size": 2997,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/GBuffer/GBufferRaster.cpp",
			"settings":
			{
				"buffer_size": 10032,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/GBuffer/GBufferRaster.h",
			"settings":
			{
				"buffer_size": 3272,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/GBuffer/GBuffer.h",
			"settings":
			{
				"buffer_size": 3324,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/GBuffer/GBuffer.cpp",
			"settings":
			{
				"buffer_size": 5817,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/DepthPass/DepthPass.cpp",
			"settings":
			{
				"buffer_size": 5276,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/Utils/GaussianBlur/GaussianBlur.cpp",
			"settings":
			{
				"buffer_size": 8197,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/SSAO/SSAO.cpp",
			"settings":
			{
				"buffer_size": 11813,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/Utils/GaussianBlur/GaussianBlur.h",
			"settings":
			{
				"buffer_size": 3739,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/Utils/Composite/Composite.cpp",
			"settings":
			{
				"buffer_size": 4310,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/TemporalDelayPass/TemporalDelayPass.h",
			"settings":
			{
				"buffer_size": 2910,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/Utils/Composite/Composite.h",
			"settings":
			{
				"buffer_size": 3098,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/DepthPass/DepthPass.h",
			"settings":
			{
				"buffer_size": 3513,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/GBuffer/GBufferRT.h",
			"settings":
			{
				"buffer_size": 3771,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/VBuffer/VBufferRT.cpp",
			"settings":
			{
				"buffer_size": 5767,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/VBuffer/VBufferRaster.cpp",
			"settings":
			{
				"buffer_size": 5672,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/GBuffer/GBufferRT.cpp",
			"settings":
			{
				"buffer_size": 9623,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/Antialiasing/Antialiasing.cpp",
			"settings":
			{
				"buffer_size": 2797,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/BlitPass/BlitPass.cpp",
			"settings":
			{
				"buffer_size": 3995,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/BSDFViewer/BSDFViewer.h",
			"settings":
			{
				"buffer_size": 4475,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/SVGFPass/SVGFPass.cpp",
			"settings":
			{
				"buffer_size": 19004,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/TemporalDelayPass/TemporalDelayPass.cpp",
			"settings":
			{
				"buffer_size": 6201,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/SVGFPass/SVGFPass.h",
			"settings":
			{
				"buffer_size": 4664,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/BSDFViewer/BSDFViewer.cpp",
			"settings":
			{
				"buffer_size": 18949,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/DebugPasses/ComparisonPass.h",
			"settings":
			{
				"buffer_size": 3286,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/DebugPasses/ComparisonPass.cpp",
			"settings":
			{
				"buffer_size": 5212,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/BlitPass/BlitPass.h",
			"settings":
			{
				"buffer_size": 2955,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/AccumulatePass/AccumulatePass.h",
			"settings":
			{
				"buffer_size": 5448,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "CMakeLists.txt",
			"settings":
			{
				"buffer_size": 4659,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/antlr4/runtime/Cpp/cmake/ExternalAntlr4Cpp.cmake",
			"settings":
			{
				"buffer_size": 5189,
				"line_ending": "Unix"
			}
		},
		{
			"file": "contrib/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 425,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "contrib/houdini/soho/LSD.py",
			"settings":
			{
				"buffer_size": 22594,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "contrib/houdini/soho/LSDapi.py",
			"settings":
			{
				"buffer_size": 8206,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "contrib/houdini/soho/LSDframe.py",
			"settings":
			{
				"buffer_size": 64676,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "contrib/houdini/soho/LSDgeo.py",
			"settings":
			{
				"buffer_size": 40221,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "contrib/houdini/soho/LSDhooks.py",
			"settings":
			{
				"buffer_size": 1873,
				"line_ending": "Unix"
			}
		},
		{
			"file": "contrib/houdini/soho/LSDmisc.py",
			"settings":
			{
				"buffer_size": 15491,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "contrib/houdini/soho/LSDmantra.py",
			"settings":
			{
				"buffer_size": 21971,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#\n# PROPRIETARY INFORMATION.  This software is proprietary to\n# Side Effects Software Inc., and is not to be reproduced,\n# transmitted, or disclosed in any way without written permission.\n#\n# Produced by:\n#       Side Effects Software Inc\n#       123 Front Street West, Suite 1401\n#       Toronto, Ontario\n#       Canada   M5J 2M2\n#       416-504-9876\n#\n# NAME: LSDsoho.py ( Python )\n#\n# COMMENTS:     A generalized wrapper for parameter lists for LSD.\n#               The parameter lists may be defined as SOHO parameter\n#               lists, or by other means.\n#\n\nimport sys, shlex\nimport soho\nimport sohog\nimport LSDapi\nRi = LSDapi\n\n_theGlobalSizes = {\n    \"Cs\":3,     \"Os\":3,\n    \"P\":3,      \"dPdu\":3, \"dPdv\":3, \"E\":3, \"I\":3,\n    \"N\":3,      \"Ng\":3,\n    \"u\":3,      \"v\":3, \"du\":3, \"dv\":3, \"s\":3, \"t\":3,\n    \"L\":3,      \"Cl\":3,\n    \"time\":3,   \"dtime\":3, \"dPdtime\":3,\n    \"Ci\":3,     \"Oi\":3,\n    \"ncomps\":3,\n}\n\ndef houdiniTypeFromRiType(ritype):\n    if ritype:\n        if ritype.find(\"string\") >= 0:  return \"string\"\n        if ritype.find(\"int\") >= 0:     return \"int\"\n        if ritype.find(\"bool\") >= 0:    return \"int\"\n    return \"real\"\n\ndef riGuessSize(ritoken):\n    return _theGlobalSizes.get(ritoken, 3)\n\ndef riTypeSize(ritype, ritoken):\n    # Compute the size of an ritype.  This might be something like\n    # \"uniform color [3]\"\n    if not ritype:\n        return riGuessSize(ritoken)\n    asize = 1\n    obrack = ritype.rfind('[')\n    if obrack > 0:\n        cbrack = ritype.find(']', obrack)\n        if cbrack > obrack + 1:\n            try:\n                asize = int(ritype[obrack+1:cbrack])\n            except:\n                asize = 1\n\n    if ritype.find(\"color\") >= 0:       return 3*asize\n    if ritype.find(\"hpoint\") > 0:       return 4*asize\n    if ritype.find(\"mpoint\") > 0:       return 16*asize\n    if ritype.find(\"point\") > 0:        return 3*asize\n    if ritype.find(\"normal\") > 0:       return 3*asize\n    if ritype.find(\"vector\") > 0:       return 3*asize\n    if ritoken == 'P':                  return 3*asize\n    if ritoken == 'Pw':                 return 4*asize\n    return asize                # string or float\n\ndef padValue(value, n):\n    last = value[-1]\n    for i in xrange(n):\n        value.append(last)\n\ndef _trimSpace(str, n):\n    s = 0\n    while s < n and str[s] == ' ':\n        s = s+1\n    e = n-1\n    while e > 0 and str[e] == ' ':\n        e = e-1\n    return str[s:(e+1)],e-s+1\n\ndef _splitUnquotedShader(str):\n    \"\"\"_splitUnquotedShader(str) -> arg0,rest_of_string\n    \n    When a shader is built by Houdini, it contains the shader name\n    bundled with the parameter values.  However, for some entities\n    (like light-sources), we need to 'split' the shader name off of\n    the parameter list.  This function splits the first token off and\n    returns a tuple of the (name, arguments).  This is very similar to\n    splitQuotedShader, but doesn't expect the first argument to be\n    quoted.\n\n    # Example:  DelayedReadArchive [ \"sodacan.rib\" ]\n\n    \"\"\"\n    n = len(str)\n    if n > 0 and (str[0] == ' ' or str[-1] == ' '):\n        str,n = _trimSpace(str, n)\n    if n < 1:\n        return (None, None)\n\n    space = str.find(' ')\n    if space < 0:\n        space = n\n    name = str[0:space]\n    if space < n:\n        args = str[(space+1):n]\n    else:\n        args = None\n    return (name, args)\n\ndef _splitQuotedShader(str):\n    \"\"\"_splitQuotedShader(str) -> arg0,rest_of_string\n\n    When a shader is built by Houdini, it contains the shader name\n    bundled with the parameter values.  However, for some entities\n    (like light-sources), we need to 'split' the shader name off of\n    the parameter list.  This function splits the first token off and\n    returns a tuple of the (name, arguments).  This is very similar to\n    splitUnquotedShader, but expects the first argument to be quoted.\n\n    Example: \"spatter\" \"uniform float Ka\" [ 1]\n\n    \"\"\"\n\n    n = len(str)\n    if n > 0 and (str[0] == ' ' or str[-1] == ' '):\n        str,n = _trimSpace(str, n)\n    if n < 2 or str[0] != '\"':\n        return (None, None)\n\n    space = str.find('\"', 1)\n    if space < 0:               # An unbalanced quote?\n        space = n\n    name = str[1:space] # Trim quotes off leading string\n    if space < n:\n        args = str[(space+2):n]\n    else:\n        args = None\n    return (name, args)\n\ndef _extractToken(shader):\n    ''' Used by _shaderStringToDict() to extract the parameter name '''\n    if len(shader) > 0 and shader[0] == '\"':\n        close = shader.find('\"', 1)\n        if close > 0:\n            return shader[close+2:], shader[1:close]\n    return None, ''\n\ndef _extractValue(shader):\n    ''' Used by _shaderStringToDict() to extract the value list '''\n    # This can be trickier since there may be [] characters in quoted strings\n    n = len(shader)\n    i = 0\n    while i < n:\n        if shader[i] == '\\\\':\n            i += 2      # Next character is a literal\n            continue\n        if shader[i] == ']':\n            break\n        if shader[i] == '\"':\n            i += 1\n            while i < n:\n                if shader[i] == '\\\\':\n                    i += 2\n                elif shader[i] == '\"':\n                    break\n                i += 1\n        i += 1\n    if i < n and shader[i] == ']':\n        return shader[i+2:], shlex.split(shader[1:i])\n    return None, ''\n\ndef _makeNumbers(values, allow_references=False):\n    ''' Used by _shaderStringToDict() to convert string values to numeric '''\n    result = []\n    for v in values:\n        try:\n            result.append( float(v) )\n        except:\n            # Failed to convert to float, so assume v is a string reference.\n            result.append( v if allow_references else 0 )\n    return result\n\ndef _shaderStringToDict(shader, convert_string=True, allow_references=False):\n    '''\n        Convert a string of shader arguments to a dictionary of token/value\n        pairs.  Example input might be a string containing:\n            \"uniform string[2] foo\" [\"one[0]\" \"two[1]\"]\n            \"uniform float Ks\" [0.3]\n            \"uniform color specularcolor\" [0.4 1 1]\n    '''\n    d = {}\n    while True:\n        shader, token = _extractToken(shader)\n        if not shader:\n            break\n        shader, value = _extractValue(shader)\n        if convert_string and token.find('string') < 0:\n            value = _makeNumbers(value, allow_references)\n        if value:\n            d[token] = value\n        #print token, value\n    return d\n            \n# Convert a shader dictionary from RIParm's asDict() to string\ndef shaderDictToString(shaderName, d):\n    s = '\"'+shaderName+'\"'\n    for token in d:\n        s += ' \"' + str(token) + '\" '+ str(d[token]) + ' '\n    s = s.replace('\\'','\"')\n    s = s.replace(',',' ')\n    return s\n\ndef dictConvertString(d):\n    for k in d.keys():\n        if k.find('string') < 0 and k.find('reference') < 0:\n           d[k] = _makeNumbers(d[k])\n\ndef elementValueGenerator(gdp, elist, attrib, start, end, pad, Pw, attribsize):\n    if pad > 0:\n        for e in elist:\n            v = gdp.value(attrib, e)\n            if attribsize == 4 and len(v) == 3:\n                if Pw >= 0:\n                    v.extend(gdp.value(Pw, e))\n                else:\n                    v.append(1.0)\n            v = v[start:]\n            padValue(v, pad)\n            yield v\n    else:\n        for e in elist:\n            v = gdp.value(attrib, e)\n            if attribsize == 4 and len(v) == 3:\n                if Pw >= 0:\n                    v.extend(gdp.value(Pw, e))\n                else:\n                    v.append(1.0)\n            v = v[start:end]\n            yield v\n\ndef elementHValueGenerator(gdp, elist, attrib, Pw, attribsize):\n    # Homogenize the 4-tuple\n    for e in elist:\n        v = gdp.value(attrib, e)\n        if attribsize == 4 and len(v) == 3:\n            if Pw >= 0:\n                v.extend(gdp.value(Pw, e))\n            else:\n                v.append(1.0)\n        w = v[3]\n        v[0] *= w\n        v[1] *= w\n        v[2] *= w\n        yield v\n\ndef elementHVelocityGenerator(gdp, elist, P, V, tscale, Pw, attribsize):\n    for e in elist:\n        pval = gdp.value(P, e)\n        vval = gdp.value(V, e)\n        if attribsize == 4 and len(pval) == 3:\n            if Pw >= 0:\n                pval.extend(gdp.value(Pw, e))\n            else:\n                pval.append(1.0)\n        w = pval[3]\n        pval[0] = (pval[0] - vval[0]*tscale)*w\n        pval[1] = (pval[1] - vval[1]*tscale)*w\n        pval[2] = (pval[2] - vval[2]*tscale)*w\n        yield pval\n\ndef elementVelocityGenerator(gdp, elist, P, V, tscale):\n    for e in elist:\n        pval = gdp.value(P, e)\n        vval = gdp.value(V, e)\n        vval[0] = pval[0] - vval[0] * tscale\n        vval[1] = pval[1] - vval[1] * tscale\n        vval[2] = pval[2] - vval[2] * tscale\n        yield vval\n\ndef elementNegValueGenerator(gdp, elist, attrib, start, end, pad, Pw, attribsize):\n    if pad > 0:\n        for e in elist:\n            v = gdp.value(attrib, e)\n            if attribsize == 4 and len(v) == 3:\n                if Pw >= 0:\n                    v.extend(gdp.value(Pw, e))\n                else:\n                    v.append(1.0)\n            v = v[start:]\n            for i in xrange(len(v)):\n                v[i] = -v[i]\n            padValue(v, pad)\n            yield v\n    else:\n        for e in elist:\n            v = gdp.value(attrib, e)\n            if attribsize == 4 and len(v) == 3:\n                if Pw >= 0:\n                    v.extend(gdp.value(Pw, e))\n                else:\n                    v.append(1.0)\n            v = v[start:end]\n            for i in xrange(len(v)):\n                v[i] = -v[i]\n            yield v\n\ndef elementStringValueGenerator(elist, attrib):\n    for e in elist:\n        yield e.attribValue(attrib)\n\ndef flattenArray(v):\n    # Flatten an array of tuples into an array of scalars\n    # i.e. [ [1,2,3], [4,5,6] ] -> [1,2,3,4,5,6]\n    for i in v:\n        if type(i) == str:\n            yield i\n        else:\n            try:\n                for t in i:\n                    yield t\n            except:\n                yield i\n\nclass RiParm(soho.SohoParm):\n    def __init__(self, riclass, ritoken, ritype, houdiniparm, skipdefault):\n        # When creating the soho parameter, choose a key set to riclass.ritoken \n        soho.SohoParm.__init__(self, houdiniparm, houdiniTypeFromRiType(ritype),\n                          None, skipdefault)\n        self.RiClass = riclass\n        self.RiToken = ritoken\n        self.RiType  = ritype\n        self.Negate = False\n\n    def getGeometryName(self):\n        if self.RiType:\n            return ' '.join([self.RiType, self.RiToken])\n        else:\n            return self.RiToken\n\n    def getAttributeName(self):\n        return '\"%s\" \"%s\"' % ( self.RiClass, self.RiToken )\n\n    def getGeometryValue(self):\n        if self.VelocityAttrib >= 0:\n            if self.Homogenize:\n                return elementHVelocityGenerator(self.Geometry,\n                        self.ElementList, self.Attribute,\n                        self.VelocityAttrib, self.VelocityScale,\n                        self.PwAttribute, self.AttribSize)\n            return elementVelocityGenerator(self.Geometry,\n                        self.ElementList, self.Attribute,\n                        self.VelocityAttrib, self.VelocityScale)\n        elif self.Homogenize:\n            return elementHValueGenerator(self.Geometry,\n                    self.ElementList, self.Attribute,\n                    self.PwAttribute, self.AttribSize)\n        elif self.Negate:\n            return elementNegValueGenerator(self.Geometry,\n                    self.ElementList, self.Attribute,\n                    self.Start, self.End, self.Pad,\n                    self.PwAttribute, self.AttribSize)\n        else:\n            return elementValueGenerator(self.Geometry,\n                    self.ElementList, self.Attribute,\n                    self.Start, self.End, self.Pad,\n                    self.PwAttribute, self.AttribSize)\n\n    def ribSohoGeoPrint(self):\n        soho.printArray(' [', self.getGeometryValue(), ']\\n')\n\nclass RiParmList:\n    def __init__(self, shader=None, quoted=True):\n        if not shader:\n            self.Parms = []\n            self.Name, self.String = None, None\n        else:\n            self.Parms = []\n            if quoted:\n                (self.Name, self.String) = _splitQuotedShader(shader)\n            else:\n                (self.Name, self.String) = _splitUnquotedShader(shader)\n\n    def clear(self):\n        self.Parms = []\n        self.Name, self.String = None, None\n\n    def shaderName(self):\n        return self.Name\n\n    def asDict(self, expand_list=True, convert_string=True, allow_references=False):\n        d = {}\n        if self.String:\n            # This happens for a shader string which has been pre-processed\n            # and made into a string.  Not much we can do about it right now.\n            return _shaderStringToDict(self.String, convert_string, allow_references)\n        else:\n            for p in self.Parms:\n                d[p.getGeometryName()] = p.Value\n        return d\n\n\n    def addParmValue(self, name, type, value):\n        parm = RiParm(\"\", name, type, None, True)\n        parm.Value = value\n        self.Parms.append(parm)\n\n    def instanceId(self, objname, style):\n        parm = RiParm('', '__instanceid', 'uniform string', None, True)\n        parm.Value = [ ''.join([ objname, ':', style]) ]\n        self.Parms.append(parm)\n\n    def ribPrint(self, newline=True):\n        if self.String:\n            sys.stdout.write(' ')\n            sys.stdout.write(self.String)\n        # There may be parameters added to the string (i.e. instanceid)\n        for parm in self.Parms:\n            if parm.RiType:\n                sys.stdout.write(' \"%s %s\"' % (parm.RiType, parm.RiToken))\n            else:\n                sys.stdout.write(' \"%s\"' % (parm.RiToken))\n            soho.printArray(' [', parm.Value, ']')\n        if newline:\n            sys.stdout.write('\\n')\n\n    def ribString(self):\n        result = ''\n        if self.String:\n            result = self.String\n        # There may be parameters added to the string (i.e. instanceid)\n        for parm in self.Parms:\n            if parm.RiType:\n                result = ' '.join([result,\n                                ' \"%s %s\"' % (parm.RiType, parm.RiToken),\n                                soho.arrayToString(' [', parm.Value, ']') ] )\n            else:\n                result = ' '.join([result,\n                                ' \"%s\"' % (parm.RiToken),\n                                soho.arrayToString(' [', parm.Value, ']') ] )\n        return result\n\n    def __str__(self):\n        return self.ribString()\n\n    def setIndex(self, idx):\n        for parm in self.Parms:\n            parm.setIndex(idx)\n\nclass RiGeoParmList:\n    def __init__(self):\n        self.clear()\n\n    def clear(self):\n        self.Parms = []\n        self.Name = None\n\n    # Create a generic geometry parameter.  There are two separate\n    # parameter interfaces for parameters:\n    #   Soho - Using a simpler but faster interface\n    def createParm(self, ritoken, ritype, attrib, elist, offset, attribsize,\n                        homogenize, velattrib, tscale, Pwattrib=-1):\n        parm = RiParm(None, ritoken, ritype, None, False)\n        parm.Attribute = attrib\n        parm.PwAttribute = Pwattrib;\n        parm.AttribSize = attribsize;\n        parm.ElementList = elist\n\n        # Houdini computes opposed normals to what LSD expects.\n        # However, this is handled by calling ReverseOrientation() in\n        # the primitives.\n        #if ritype and ritype.find('normal') >= 0:\n        #    parm.Negate = True\n\n        # Now, check to see if we need to pad the LSD value with extra\n        # values.\n        ribsize = riTypeSize(ritype, ritoken)\n        offset = min(offset, attribsize-1)\n        parm.Pad        = max((ribsize + offset) - attribsize, 0)\n        parm.Start      = offset\n        parm.End        = offset + ribsize - parm.Pad\n        if tscale == 0:\n            parm.VelocityAttrib = -1\n            parm.VelocityScale = 0\n        else:\n            parm.VelocityAttrib = velattrib\n            parm.VelocityScale = tscale\n        if homogenize and (parm.Pad == 0) \\\n                      and (attribsize == 4) \\\n                      and (offset == 0):\n            parm.Homogenize = True\n        else:\n            parm.Homogenize = False\n        self.Parms.append(parm)\n        return parm\n\n    # Note, in many cases, the element list passed in is an iteration\n    # generator (using yield), and thus, you only have one chance to\n    # go through the elements.  Be aware of this when using the\n    # geometry parm list.\n    def addSohoParm(self, ritoken, ritype, gdp, attrib, elist,\n                        offset=0, homogenize=False):\n        if offset < 0:\n            offset = 0\n        attribsize = gdp.attribProperty(attrib, 'geo:vectorsize')[0]\n        parm = self.createParm(ritoken, ritype, attrib, elist, offset,\n                            attribsize, homogenize, -1, 0)\n        parm.Geometry = gdp\n\n    def addP(self, ritoken, ritype, gdp, elist, P, V, vscale, homogenize=False, Pw=-1):\n        attribsize = gdp.attribProperty(P, 'geo:vectorsize')[0]\n        if ritoken == 'Pw':\n            attribsize = 4\n        parm = self.createParm(ritoken, ritype, P, elist, 0,\n                            attribsize, homogenize, V, vscale, Pw)\n        parm.Geometry = gdp\n\n    def asDict(self, expand_list=True):\n        d = {}\n        if expand_list:\n            # prman for python doesn't handle generators.\n            # On top of which, it doesn't handle lists of tuples/lists.\n            # Therefore, the contents needs to be \"expanded\" into a flat array.\n            for p in self.Parms:\n                d[p.getGeometryName()] = tuple(flattenArray(p.getGeometryValue()))\n        else:\n            for p in self.Parms:\n                d[p.getGeometryName()] = p.getGeometryValue()\n        return d\n\n    def ribPrint(self):\n        for parm in self.Parms:\n            soho.indent()\n            if parm.RiType:\n                sys.stdout.write('\"%s %s\"' % ( parm.RiType, parm.RiToken ))\n            else:\n                sys.stdout.write('\"%s\"' % parm.RiToken)\n            parm.ribSohoGeoPrint()\n",
			"file": "contrib/houdini/soho/LSDparm.py",
			"file_size": 18230,
			"file_write_time": 132434583451656602,
			"settings":
			{
				"buffer_size": 18230,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "# -*- coding: utf-8 -*-\n#\n# PROPRIETARY INFORMATION.  This software is proprietary to\n# Side Effects Software Inc., and is not to be reproduced,\n# transmitted, or disclosed in any way without written permission.\n#\n# Produced by:\n#       Side Effects Software Inc\n#       123 Front Street West, Suite 1401\n#       Toronto, Ontario\n#       Canada   M5J 2M2\n#       416-504-9876\n#\n# NAME: LSDptinst.py ( Python )\n#\n# COMMENTS:\n#\n\nimport LSDapi\nimport LSDframe\nimport LSDgeo\nimport LSDhooks\nimport LSDmisc\nimport LSDsettings\nimport soho\nimport hou\nfrom soho import SohoParm\nfrom sohog import SohoGeometry\n\nRi = LSDapi\n\ntheOverrideFormatStr='*#%s#*'\n\ndef isObjectFastPointInstancer(obj, now):\n    plist = obj.evaluate( [ SohoParm('ptinstance', 'int', [0], False ) ], now )\n    return plist[0].Value[0] == 2\n\ndef getInstancerAttributes(obj, now):\n    attribs = [\n        'geo:pointxform',               # Required\n        'v',\n        'instance',\n        'shop_materialpath',\n        'material_override',\n        'shop_surfacepath',\n        'shop_displacepath',\n        'shop_fogpath',\n        'shop_interiorpath'\n    ]\n\n    sop_path = []\n    if not obj.evalString('object:soppath', now, sop_path):\n        return          # No geometry associated with this object\n\n    geo = SohoGeometry(sop_path[0], now)\n    if geo.Handle < 0:  # No geometry data available\n        return\n\n    npts = geo.globalValue('geo:pointcount')[0]\n    if not npts:\n        return\n\n    attrib_map = {}\n\n    for attrib in attribs:\n        handle = geo.attribute('geo:point', attrib)\n        if handle >= 0:\n            attrib_map[attrib] = handle\n\n    return (geo, npts, attrib_map)\n\ndef getInstantiatedObjects(obj, now):\n    (geo, npts, attrib_map) = getInstancerAttributes(obj, now)\n    if not geo or not npts:\n        return []\n\n    inst_path = []\n    obj.evalString('instancepath', now, inst_path)\n\n    # See if there's a per-point instance assignment\n    if 'instance' not in attrib_map:\n        return inst_path\n\n    unique_inst = set()\n    if inst_path[0]:\n        unique_inst.add(inst_path[0])\n    for pt in xrange(npts):\n        unique_inst.add(geo.value(attrib_map['instance'], pt)[0])\n\n    return list(unique_inst)\n\n# This class emulates a function call, but instead of doing something\n# functional, simply stores the arguments to the call for later use.\nclass copyingRiCall(object):\n    def __init__(self): self.call_params = []\n    def __call__(self, name, params): self.call_params = [name, params]\n\ndef getPointInstanceSHOPHash( geo, pt, attrib_handle, override_handle ):\n    shop_path_hash = geo.value(attrib_handle, pt)[0]\n    if shop_path_hash is None or \\\n       len(shop_path_hash) == 0 or \\\n       override_handle is None:\n        return (shop_path_hash,None)\n\n    overrides_str = geo.value(override_handle, pt)[0]\n    overrides = eval(overrides_str) if overrides_str != '' else None\n    if overrides is None or len(overrides) == 0:\n        return (shop_path_hash,None)\n\n    return (shop_path_hash + '-' + '-'.join( overrides.keys() ), overrides)\n\ndef getPointInstanceSHOPs(pt_shaders, now, geo, attrib_name, npts, shader_type = None, override = None ):\n    if shader_type is None:\n        shader_type = attrib_name\n\n    attrib_handle = geo.attribute('geo:point', attrib_name)\n    if attrib_handle < 0:\n        return\n\n    override_handle = geo.attribute( 'geo:point', override ) if override is not None else None\n    if override_handle < 0:\n        override_handle = None\n\n    # Collect unique SHOPs from the point attribute\n    unique_shops = set()\n    for pt in xrange(npts):\n        (shop_hash,overrides) = getPointInstanceSHOPHash(geo, pt, attrib_handle, override_handle)\n        if shop_hash:\n            unique_shops.add( shop_hash )\n\n    # Evaluate all the unique SHOPs to get the RI call parameters required to\n    # instantiate it in the LSD stream\n    for shop_hash in unique_shops:\n        pt_shaders[shop_hash] = []\n        shlist = pt_shaders[shop_hash]\n\n        shop_id = shop_hash.split( '-' )\n        shop_path = shop_id.pop(0)\n        shop_obj = soho.getObject( shop_path )\n\n        # Walk through all BxDF ancestors so as to emit data for each of those\n        # \"co-shaders\" first. The data for each coshader/shader goes into\n        # shlist==pt_shaders as before, but instead of it being a single list\n        # with 2 entries (dsoname,parmlist) as it was before, it is now a list \n        # of tuples, where each tuple contains (ricall,handle,dsoname,parmlist)\n        shop_node = hou.node(shop_path)\n        if(shop_node):\n            for n in reversed(shop_node.inputAncestors()):\n                cosh_obj = soho.getObject(n.path())\n                shader = []\n                shop_type = []\n                if cosh_obj.evalShaderAndType(shader_type, now, shader, shop_type):\n                    ricallClosure = copyingRiCall()\n                    LSDsettings.outputShaderString(shader[0], ricallClosure, shoptype=shop_type[0])\n                    if len( ricallClosure.call_params ) > 0:\n                        shlist.append((Ri.Pattern,n.path())+tuple(ricallClosure.call_params))\n\n        odict = {}\n        if len(shop_id)>0:\n            for override in shop_id:\n                odict[override] = theOverrideFormatStr % override\n        over = soho.PropertyOverride(odict)\n        # fetch the terminal (BxDF) node\n        shader = []\n        shop_type = []\n        if shop_obj.evalShaderAndType(shader_type, now, shader, shop_type):\n            ricallClosure = copyingRiCall()\n            LSDsettings.outputShaderString(shader[0], ricallClosure, shoptype=shop_type[0])\n            if len( ricallClosure.call_params ) > 0:\n                shlist.append((Ri.Bxdf,shop_path,)+tuple(ricallClosure.call_params))\n\n\ndef outputPointInstanceShaders( pt, pt_shaders, geo, attrib_handle, riCall, override_handle=None ):\n    if attrib_handle is None:\n        return\n    shop_hash = getPointInstanceSHOPHash(geo, pt, attrib_handle, override_handle)\n    shop_path = geo.value(attrib_handle, pt)[0]\n    base_handle = shop_path\n    overrides = None\n    if override_handle is not None:\n        overrides_str = geo.value(override_handle, pt)[0]\n        if overrides_str != '':\n            overrides = eval(overrides_str)\n        if overrides is not None and len(overrides) == 0:\n            overrides = None\n        if overrides is not None:\n            shop_path = shop_path + '-' + '-'.join( overrides.keys() )\n\n    # The data in pt_shaders has now changed: it is a list of tuples with the\n    # following data: (ricall,handle,dsoname,parmlist). This loop has therefore\n    # changed accordingly, updating not just the handles of each call but also\n    # all references to them in the parm lists of each shader\n    handles = set([])\n    if shop_path in pt_shaders:\n        for shcall,shpath,shdso,shparms in pt_shaders[shop_path]:\n            handle = shpath + '_' + str(pt)\n            oldstr = shparms.String\n\n            # Rewrite the overridden params\n            if overrides is not None:\n                for override in overrides.items():\n                    shparms.String = shparms.String.replace( ('\"'+theOverrideFormatStr+'\"') % override[0], str( override[1] ) )\n\n            # change all references in the parms\n            for h in handles:\n                hnew = '%s_%d'%(h,pt)\n                shparms.String = shparms.String.replace(h,hnew)\n\n            shcall( shdso, handle, shparms )\n            shparms.String = oldstr\n            handles.add(shpath)\n\n\ndef outputPointInstance(obj, now, concat=False, archive=None):\n\n    if LSDhooks.call(\"pre_outputPointInstance\", obj, now, concat, archive):\n        return\n\n    # Grab the SOP to instance\n    def_inst_path = []\n    obj.evalString('instancepath', now, def_inst_path)\n\n    # Grab the geometry and output the points\n    (geo, npts, attrib_map) = getInstancerAttributes(obj, now)\n    if geo is None or npts is None:\n        LSDhooks.call(\"post_outputPointInstance\", obj, now, concat, archive)\n        return\n\n    # No point xform attribute? Treat as an empty object.\n    if 'geo:pointxform' not in attrib_map:\n        LSDhooks.call(\"post_outputPointInstance\", obj, now, concat, archive)\n        return\n\n    # No objects associated with this instance\n    if not def_inst_path[0] and 'instance' not in attrib_map:\n        soho.warning('No instance master and no instance attribute on %s. '\n                     'Object will not be rendered' % \n                     obj.getName())\n        LSDhooks.call(\"post_outputPointInstance\", obj, now, concat, archive)\n        return\n\n    # Motion data\n    (blocks, times) = LSDmisc.xform_mbsamples(obj, now)\n    (blocks2, times2) = LSDmisc.xform_mbsamples(obj, now, 2)       # Only two samples for velocity\n\n    shutter_open = -LSDmisc.CameraDelta\n    shutter_close = (LSDmisc.CameraShutter - LSDmisc.CameraDelta)\n    \n    Ri.Comment('Point instance object %s' % obj.getName() )\n    Ri.AttributeBegin()\n\n    # insert the attributes of the instances object itself\n    # attribs of individual instances will override\n    LSDsettings.outputAttributes(obj, now)\n    \n    if LSDsettings.getFeature('RiObjectInstance'):\n        inst_paths = getInstantiatedObjects(obj, now)\n        for inst_path in inst_paths:\n            inst_obj = soho.getObject( inst_path )\n            if inst_obj:\n                handle = LSDmisc.objecthandle(inst_obj)\n                Ri.Comment('Object Instance %s' % inst_obj.getName() )\n                Ri.ObjectBegin(handle)\n                Ri.ReadArchive(handle)\n                Ri.ObjectEnd()\n    \n    # Define the transform space so that it's defined for shaders as\n    # well as the geometry.\n    LSDframe.objectTransform('space:world', obj, times, concat=concat, blocks=blocks)\n\n    # If the instance attribute is present, partition the\n    # points into instance usage.\n    pt_partitions = {}\n    if 'instance' in attrib_map:\n        for pt in xrange(npts):\n            inst_path = geo.value(attrib_map['instance'], pt)[0]\n            if not inst_path:\n                inst_path = def_inst_path[0]\n            pt_partitions.setdefault(inst_path,[]).append( pt )\n    else:\n        pt_partitions[def_inst_path[0]] = xrange(npts)\n\n    # If any of the applicable the shop_*path attributes is present,\n    # collect the unique set of shaders and evaluate them before output.\n    pt_material_shaders = {}\n    pt_surface_shaders = {}\n    pt_displace_shaders = {}\n    pt_fog_shaders = {}\n    pt_interior_shaders = {}\n    if not obj.getDefaultedInt('shop_disable_surface_shader', now, [0])[0]:\n        if 'shop_materialpath' in attrib_map:\n            getPointInstanceSHOPs(pt_material_shaders, now, geo, 'shop_materialpath', npts, shader_type='shop:string', override='material_override' )\n        else:\n            getPointInstanceSHOPs(pt_surface_shaders, now, geo, 'shop_bsdfshaderpath', npts, shader_type='shop:string' )\n    if not obj.getDefaultedInt('shop_disable_displace_shader', now, [0])[0]:\n        getPointInstanceSHOPs(pt_displace_shaders, now, geo, 'shop_displacepath', npts )\n    if not obj.getDefaultedInt('shop_disable_fog_shader', now, [0])[0]:\n        getPointInstanceSHOPs(pt_fog_shaders, now, geo, 'shop_fogpath', npts )\n    # NOTE: There's no disable setting for interior shaders\n    getPointInstanceSHOPs(pt_interior_shaders, now, geo, 'shop_interiorpath', npts )\n\n    for pt_inst in pt_partitions:\n        Ri.AttributeBegin()\n        Ri.Comment('Instance %s' % pt_inst )\n        inst_obj = soho.getObject( pt_inst )\n        inst_xfodata = {}\n        LSDframe.getObjectTransform( inst_xfodata, 'space:world', inst_obj, times, blocks=blocks )\n\n        # Now output settings, shaders and light masks for the instance\n        LSDsettings.outputAttributes(inst_obj, now)\n\n        for pt in pt_partitions[pt_inst]:\n            Ri.AttributeBegin()\n\n            Ri.Comment('Point %d' % pt )\n\n            # Set the point transform\n            pt_xform = geo.value(attrib_map['geo:pointxform'], pt)\n\n            if len(times) > 1 and 'v' in attrib_map:\n                # Deal with motion blur on the particle\n                pt_v = geo.value(attrib_map['v'], pt)\n\n                LSDmisc.MotionBegin(blocks2)\n                shutter_open_xform = LSDmisc.translate4( pt_xform, pt_v[0] * shutter_open, pt_v[1] * shutter_open, pt_v[2] * shutter_open )\n                shutter_close_xform = LSDmisc.translate4( pt_xform, pt_v[0] * shutter_close, pt_v[1] * shutter_close, pt_v[2] * shutter_close )\n\n                Ri.ConcatTransform( shutter_open_xform )\n                Ri.ConcatTransform( shutter_close_xform )\n                Ri.MotionEnd()\n            else:\n                Ri.ConcatTransform( pt_xform )\n\n            # Concatenate the transform of the instantiated object\n            LSDframe.outputTransform(inst_xfodata, concat=True)\n\n            # There's a per-point SHOP assignment, take care of it here. We've\n            # already evaluated and generated the SLO from the shop, so we can\n            # just recycle the Ri.xxx commands for the same parameters.\n            if 'shop_materialpath' in attrib_map:\n                outputPointInstanceShaders( pt, pt_material_shaders, geo, attrib_map.get('shop_materialpath'), Ri.Bxdf, override_handle=attrib_map.get('material_override') )\n            else:\n                outputPointInstanceShaders( pt, pt_surface_shaders, geo, attrib_map.get('shop_bsdfshaderpath'), Ri.Bxdf )\n\n            disp_ricall = Ri.Displace if LSDsettings.getFeature('RiDisplace') else Ri.Displacement\n            outputPointInstanceShaders( pt, pt_displace_shaders, geo, attrib_map.get('shop_displacepath'), disp_ricall)\n\n            outputPointInstanceShaders( pt, pt_fog_shaders, geo, attrib_map.get('shop_fogpath'), Ri.Atmosphere )\n            outputPointInstanceShaders( pt, pt_interior_shaders, geo, attrib_map.get('shop_interiorpath'), Ri.Interior )\n\n            mbinfo = LSDmisc.geo_mbsamples(inst_obj, now)\n            if LSDsettings.getFeature('RiObjectInstance'):\n                style = \"instance\"\n            else:\n                style = \"delayed\"\n            \n            LSDgeo.instanceGeometry(inst_obj, now, mbinfo[0], mbinfo[1], archive, style=style)\n            Ri.AttributeEnd()\n\n        Ri.AttributeEnd()\n\n    Ri.AttributeEnd()\n\n    LSDhooks.call(\"post_outputPointInstance\", obj, now, concat, archive)\n",
			"file": "contrib/houdini/soho/LSDptinst.py",
			"file_size": 14292,
			"file_write_time": 132434583547090483,
			"settings":
			{
				"buffer_size": 14292,
				"line_ending": "Unix"
			}
		},
		{
			"file": "contrib/houdini/soho/LSDsettings.py",
			"settings":
			{
				"buffer_size": 31540,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "# -*- coding: utf-8 -*-\n#\n# PROPRIETARY INFORMATION.  This software is proprietary to\n# Side Effects Software Inc., and is not to be reproduced,\n# transmitted, or disclosed in any way without written permission.\n#\n# Produced by:\n#       Side Effects Software Inc\n#       123 Front Street West, Suite 1401\n#       Toronto, Ontario\n#       Canada   M5J 2M2\n#       416-504-9876\n#\n# NAME: LSDhgeo.py ( Python )\n#\n# COMMENTS:     Convert houdini geometry to LSD\n#\n\nimport os, sys, shlex\nimport hou, soho, sohog\nimport metaexpr                 # Metaball expressions\nimport LSDapi\nimport LSDmisc\nimport LSDsettings\nfrom LSDparm import RiGeoParmList\nfrom LSDparm import RiParmList\nfrom sohog import SohoGeometry\nfrom collections import defaultdict\n\nRi = LSDapi\n\n# Alembic prman procedural\ndef getAlembicProc():\n    path = os.path.expandvars('$RMANTREE')\n    path = os.path.join(path, 'etc')\n    for ext in ['.so', '.dll']:\n        proc = os.path.join(path, 'AlembicProcPrim' + ext)\n        if os.path.exists(proc):\n            return proc\n    return 'AlembicProcPrim.so'\n\nAlembicProcedural = getAlembicProc()\n\n# OpenVDB prman procedural\ndef getOpenVDBProc():\n    rmt = os.path.expandvars('$RMANTREE')\n    path = os.path.join(rmt, 'etc')\n    for ext in ['.so', '.dll']:\n        proc = os.path.join(path, 'impl_openvdb' + ext)\n        if os.path.exists(proc):\n            return 'blobbydso:' + proc\n    return 'blobbydso:' + os.path.join(rmt, 'lib', 'plugins', 'impl_openvdb')\n\nOpenVDBProcedural = getOpenVDBProc()\n\n# The type information (varying vs. vertex) for the \"P\" attribute are\n# handled differently by different renderers.  Rather than fully\n# qualifying the \"P\" attribute, we instead leave the types as None\n# (leaving the renderer to choose what they will).\n#\n# __P_varying_type = 'varying point'\n# __P_vertex_type = 'vertex point'\n#\n__P_varying_type = None\n__P_vertex_type = None\n\nclass metaProgram(object):\n    def __init__(self, geo, volume):\n        if volume:\n            self.Code = [8]\n        else:\n            self.Code = []\n        self.OpCount = 0\n        self.LeafCount = 0\n        self.PrimList = []\n\n        # Get the metaball expression for the geometry\n        code = geo.globalValue('intrinsic:metaexpr_code')\n        expr = metaexpr.build(code)\n\n        # Extract list of primitives referenced by the expression\n        def extractPrimitives(node, primlist):\n            ''' Extract the list of primitives referenced by the expression '''\n            for k in node.Kids:\n                if not isinstance(k, metaexpr.expr):\n                    primlist.append(k)\n                else:\n                    extractPrimitives(k, primlist)\n        extractPrimitives(expr, self.PrimList)\n\n        # Now, make the list of primitives unique (we don't need to output leaf\n        # nodes multiple times).\n        self.PrimList = list(set(self.PrimList))\n        # And sort the list for nicer output\n        self.PrimList.sort()\n\n        # Add the primtives to the code segment.  Since the Houdini primitives\n        # may not be in order (i.e. they could be mixed with other primitive\n        # types), we need build a map between the Houdini primitive number\n        # and the code offset in the LSD primitive.\n        ribFromHoudini = {}\n        for prim in self.PrimList:\n            self.addPrim(ribFromHoudini, prim)\n\n        # After the primitives have been generated, generate expressions to\n        # combine them.\n        def buildRibExpression(me, expr, primmap):\n            ''' Traverse expression tree, creating the LSD expressions '''\n            operands = []\n            # Map between Houdini's operations and LSD opcodes.\n            rib_opcode = {  metaexpr.OP_SUM: 0,\n                            metaexpr.OP_MAX: 2,\n                            metaexpr.OP_MIN: 3 }[expr.Op]\n            for k in expr.Kids:\n                if isinstance(k, metaexpr.expr):\n                    operands.append(buildRibExpression(me, k, primmap))\n                else:\n                    operands.append(primmap[k])\n            return me.addExpr(rib_opcode, operands)\n        buildRibExpression(self, expr, ribFromHoudini)\n\n    def addPrim(self, ribFromHoudini, pnum):\n        # Store the mapping between the Houdini primitive number and the\n        # location of the opcode so that we can resolve the metaball in the\n        # output.  We store the OpCount+2 to get the result of scaling by the\n        # weight.\n        ribFromHoudini[pnum] = self.OpCount + 2\n\n        # In the data segment, we store only 17 floats per primitive.  (a\n        # transform and a weight).\n        off = self.LeafCount / 2 * 17   # Offset into floats for current prim\n        self.Code.append(1001)          # Define ellipse\n        self.Code.append(off)           # Offset of transform in floats\n        self.Code.append(1000)          # Constant (weight)\n        self.Code.append(off+16)        # Offset of weights in float\n        self.Code.append(1)             # Multiply opcode\n        self.Code.append(2)             # 2 entries\n        self.Code.append(self.OpCount)  # Multiply ellipsoid by weight\n        self.Code.append(self.OpCount+1)\n        self.OpCount += 3\n        self.LeafCount += 2\n\n    def addExpr(self, opcode, list):\n        addr = self.OpCount\n        self.Code.append(opcode)\n        self.Code.append(len(list))\n        self.Code.extend(list)\n        self.OpCount += 1\n        return addr\n\ndef _volumeAttrib(geo, pnum, attrib):\n    a = geo.attribute('geo:prim', attrib)\n    if a >= 0:\n        return geo.value(a, pnum)\n    return None\n\ndef _genColor(nvoxels, v0, v1, v2):\n    # Generator to interleave voxel arrays into a 3-tuple\n    for v in xrange(nvoxels):\n        yield v0[v]\n        yield v1[v]\n        yield v2[v]\n\ndef outputQTransform(geo, pnum, attribs, control):\n    xform = geo.value(attribs.a_primxform, pnum)\n    if control.VelocityAttrib >= 0:\n        tscale = attribs.a_time - control.VelocityTime\n        ptnum = geo.vertex(attribs.a_pointref, pnum, 0)[0]\n        v = geo.value(control.VelocityAttrib, ptnum)\n        xform = LSDmisc.translate4(xform, v[0]*tscale, v[1]*tscale, v[2]*tscale)\n\n    if geo.value(attribs.a_primtype, pnum)[0] == attribs.tubetype:\n        # Tubes in Houdini are defined along the Y axis.  So, we need to\n        # pre-rotate the transform by PI/2 in the x-axis.  Fortunately, we\n        # have this matrix defined above.\n        hxform = _tubePreTransform * hou.Matrix4(xform)\n        xform = hxform.asTuple()\n    Ri.ConcatTransform(xform)\n\ndef _volumeExpandColor(geo, nvoxels, plist, voxelattrib):\n    v0 = geo.value(voxelattrib, plist[0])       # Get array of voxels for prim0\n    v1 = geo.value(voxelattrib, plist[1])       # Get array of voxels for prim1\n    v2 = geo.value(voxelattrib, plist[2])       # Get array of voxels for prim2\n    # Return a generator that interleaves the 3 voxel arrays\n    return _genColor(nvoxels, v0, v1, v2)\n\ndef _volumeExpandScalar(geo, nvoxels, prim, voxelattrib):\n    # Return the voxels for the primitive\n    return geo.value(voxelattrib, prim)\n\nclass volumePrimitive(object):\n    def __init__(self, geo, prim, attribs):\n        self.geo = geo\n        self.density = prim\n        self.vertex = (prim, 0)\n        self.point = geo.vertex(attribs.a_pointref, prim, 0)\n        self.channels = { 'density' : [prim] }\n        self.voxattrib = geo.attribute('geo:prim', 'geo:voxeldata')\n        self.res = _volumeAttrib(geo, prim, 'geo:volumeresolution')\n        self.bounds = (1, 1, 1)\n        self.nvoxels = self.res[0] * self.res[1] * self.res[2]\n        # Other properties we might be interested in\n        #voxels = _volumeAttrib(geo, prim, \"geo:voxeldata\")\n        #vborder = _volumeAttrib(geo, prim, \"geo:volumebordermode\")\n        #vcompresstol = _volumeAttrib(geo, prim, \"geo:volumecompressiontol\")\n        #vminval = _volumeAttrib(geo, prim, \"geo:volumeminvalue\")\n        #vmaxval = _volumeAttrib(geo, prim, \"geo:volumemaxvalue\")\n        #vavgval = _volumeAttrib(geo, prim, \"geo:volumeavgvalue\")\n        #vvisualmode = _volumeAttrib(geo, prim, \"geo:volumevisualmode\")\n        #vvisualiso = _volumeAttrib(geo, prim, \"geo:volumevisualiso\")\n        #vvisualdensity = _volumeAttrib(geo, prim, \"geo:volumevisualdensity\")\n\n    def addChannel(self, pnum, name):\n        ''' Try to add a channel. '''\n        if name.find('.') > 0:\n            # We have a component of a tuple\n            chname, comp = name.split('.')\n            comp = { 'x':0, 'y':1, 'z':2, 'r':0, 'g':1, 'b':2}.get(comp, 0)\n            l = self.channels.get(chname, [])\n            while len(l) <= comp:\n                l.append(-1)\n            l[comp] = pnum\n            self.channels[chname] = l\n        else:\n            self.channels[name] = [pnum]\n\n    def parmList(self, rixlate):\n        # First, go through and build up the uniform/constant attributes\n        geolist = RiGeoParmList()\n        prim = self.density\n        for x in rixlate:\n            ritype = ' '.join(x[1])\n            if x[1][0] == 'varying' or x[1][0] == 'vertex':\n                if x[2] == 'geo:point':\n                    pt = self.point\n                else:\n                    pt = self.vertex\n                # Re-map to uniform attribute\n                geolist.addSohoParm(x[0], ritype, geo, x[3], [pt], x[4])\n            else:\n                geolist.addSohoParm(x[0], ritype, geo, x[3], [prim], x[4])\n        # Now, since we want to use a simpler RiParmList for voxel data, we\n        # extract the geometry attributes into a standard parm list.\n        parmlist = RiParmList()\n        parmdict = geolist.asDict(expand_list=True)\n        for x in parmdict:\n            name = x.split(' ')\n            ritype = ' '.join(name[:-1])\n            riname = name[-1]\n            parmlist.addParmValue(riname, ritype, parmdict[x])\n\n        # Now, add the voxel channels\n        for ch in self.channels:\n            # We add the channels as \"varying\" attributes.  This causes\n            # tri-linear interpolation which is not as smooth as \"vertex\"\n            # attributes, but is:\n            #   - Faster\n            #   - Doesn't have the attributes go out of bounds\n            primlist = self.channels[ch]\n            ritype = 'varying float'\n            if len(primlist) == 3:\n                if -1 in primlist:\n                    continue        # We had 2 components, but not a third\n                ritype = 'varying color'        # Send as a color for now\n                ridata = _volumeExpandColor(self.geo, self.nvoxels,\n                                primlist, self.voxattrib)\n            else:\n                ridata = _volumeExpandScalar(self.geo, self.nvoxels,\n                                primlist[0], self.voxattrib)\n            parmlist.addParmValue(ch, ritype, ridata)\n        return parmlist\n\n    def save(self, glist, blocks, times, attribs, rixlate, control):\n        nsegs = len(times)\n        Ri.TransformBegin()\n        if nsegs > 1:\n            LSDmisc.MotionBegin(blocks)\n            for x in xrange(nsegs):\n                # Save transform\n                for seg in xrange(nsegs):\n                    outputQTransform(glist[i], self.density,attribs[i], control)\n            Ri.MotionEnd()\n        else:\n            outputQTransform(glist[0], self.density, attribs[0], control)\n        # Now output the volume primitive\n        bx = self.bounds[0]\n        by = self.bounds[1]\n        bz = self.bounds[2]\n        Ri.Volume(\"box\", [-bx,bx, -by,by, -bz,bz],\n                self.res, self.parmList(rixlate[0]))\n        Ri.TransformEnd()\n\nclass vdbFogPrimitive(object):\n    def __init__(self):\n        self.primnames = []\n        self.primtypes = []\n        self.filename = ''\n        self.densityname = ''\n        self.dimension = [0, 0, 0]\n\n    def addFilename(self, filename):\n        ''' add filename. '''\n        self.filename = filename\n\n    def addPrims(self, pname, ptype):\n        ''' add prim name and type. '''\n        if pname.find('density') >= 0:\n            self.densityname = pname\n        self.primnames.append(pname)\n        self.primtypes.append(ptype)\n\n    def addBounds(self, bounds):\n        ''' add vdb bounding box. '''\n        self.bounds = bounds\n\n    def parmList(self):\n        parmlist = RiParmList()\n        parmlist.addParmValue(\"blobbydso:stringargs\", \"constant string[2]\", [self.filename, self.densityname])\n        for i in range(0, len(self.primnames)):\n            parmlist.addParmValue(self.primnames[i], 'varying '+self.primtypes[i], [])\n        return parmlist\n\n    def save(self):\n        # Volume \"blobbydso:impl_openvdb\" [-19 19 -7 80 -18 80] [0 0 0] \n        # \"constant string[2] blobbydso:stringargs\" [\"/home/test/houdini/vdb/smoke.vdb\" \"density\"] \n        # \"varying float density\" []\n        # \"varying vector velocity\" []\n        Ri.Volume(OpenVDBProcedural, self.bounds, [0,0,0], self.parmList())\n\nclass vdbSdfPrimitive(object):\n    def __init__(self):\n        self.primnames = []\n        self.primtypes = []\n        self.filename = ''\n        self.surfacename = ''\n        self.dimension = [0, 0, 0]\n\n    def addFilename(self, filename):\n        ''' add filename. '''\n        self.filename = filename\n\n    def addPrims(self, pname, ptype):\n        ''' add prim name and type. '''\n        if pname.find('surface') >= 0:\n            self.surfacename = pname\n        else:\n            self.primnames.append(pname)\n            self.primtypes.append(ptype)\n\n    def addBounds(self, bounds):\n        ''' add vdb bounding box. '''\n        self.bounds = bounds\n\n    def stringList(self):\n        strings = list()\n        strings.append('${RMANTREE}/lib/plugins/impl_openvdb') # strings[0]\n        strings.append(self.filename) # strings[1]\n        strings.append(self.surfacename) # strings[2]\n        for i in xrange(0, len(self.primnames)):\n            aType = 'levelset'\n            if self.primtypes[i] == 'vector':\n                aType = 'fogvolume'\n            strings.append('%s:%s' % (self.primnames[i], aType))\n        return strings\n\n    def parmList(self):\n        parmlist = RiParmList()\n        for i in range(0, len(self.primnames)):\n            parmlist.addParmValue(self.primnames[i], 'varying ' + self.primtypes[i], [])\n        return parmlist\n\n    def save(self):\n        Ri.Blobby(\n            1, # nleaf\n            6, # ncodes\n            [\n                1004,                     # code (plugin)\n                0,                        # index of plugin string\n                0,                        # number of float args\n                0,                        # index of float args\n                len(self.primnames) + 2,  # number of string args\n                1],                       # index of string args\n            0, # nfloats\n            [], # floats\n            len(self.stringList()), # nstrings\n            self.stringList(), #strings\n            self.parmList()) #params\n\n#-------------------------------------------------------------------------------\nclass F3DCollection(object):\n    def __init__(self):\n        self.filenameToFieldMap = defaultdict(list)\n\n    def addField(self, filename, fieldname):\n        self.filenameToFieldMap[filename].append(fieldname)\n\n    def save(self):\n        for filename, fields in self.filenameToFieldMap.items(): \n            Ri.AttributeBegin()\n            Ri.Comment('Field3D: %s' % filename)\n            Ri.DynamicLoad('F3DProcPrim', \\\n                '{' + filename + '} {' + ' '.join(fields) + '}', \\\n                [-1,1,-1,1,-1,1])\n\n            Ri.AttributeEnd()\n\ndef traversePackedF3D(glist, blocks, times, control):\n    nsegments = len(times)\n    if len(glist) != nsegments:\n        return\n\n    primCount = glist[0].globalValue('geo:primcount')[0]\n    filenameAttr = glist[0].attribute('geo:prim', 'intrinsic:fileName')\n    f3dAttributeAttr = glist[0].attribute('geo:prim', 'intrinsic:f3dattribute')\n    f3dNameAttr = glist[0].attribute('geo:prim', 'intrinsic:f3dname')\n    f3dIndexAttr = glist[0].attribute('geo:prim', 'intrinsic:f3dindex')\n\n    f3dCollect = F3DCollection()\n    for primIdx in xrange(primCount):\n        filename = glist[0].value(filenameAttr, primIdx)[0].strip()\n        f3dAttribute = glist[0].value(f3dAttributeAttr, primIdx)[0].strip()\n        f3dCollect.addField(filename, f3dAttribute)\n\n    f3dCollect.save()\n\nclass f3dPrimitive(object):\n    def __init__(self):\n        self.fields = []\n        self.filename = ''\n\n    def addFilename(self, filename):\n        ''' add filename. '''\n        self.filename = filename\n\n    def addField(self, field):\n        ''' add prim name and type. '''\n        self.fields.append(field)\n\n    def addBounds(self, bounds):\n        ''' add f3d bounding box. '''\n        self.bounds = bounds\n\n    def save(self):\n        Ri.DynamicLoad('F3DProcPrim', '{%s} {%s}' % (self.filename, ' '.join(self.fields)), self.bounds)\n\ndef traverseF3D(glist, blocks, times, control):\n    nsegments = len(times)\n    if len(glist) != nsegments:\n        return\n   \n    # Get prim count.  E.g. if there are density and velocity, then primcount = 2\n    primcount = glist[0].globalValue('geo:primcount')[0]\n    if primcount <= 0:\n        return\n\n    primname_attrib = glist[0].attribute('geo:prim', 'name')\n    if primname_attrib < 0:\n        return\n\n    # F3D file name\n    soppath_attrib = glist[0].attribute('geo:prim', 'geo:soppath')\n    soppath = glist[0].value(soppath_attrib, 0)[0]\n    if not soppath:\n        sys.stderr.write('Unable to find geometry path %s\\n' % soppath)\n        return\n\n    f3dfileparm = hou.parm(soppath+'/file')\n    if not f3dfileparm:\n        # When using convertF3D SOP, there could be no input .f3d file, \n        # so we want to write out a f3d file first.\n\n        # Create a unique filename for the temporary f3d output\n        sessionid = LSDmisc.ExternalSessionId\n        path = '%s_%s' % (sessionid, glist[0].globalValue('geo:sopid')[0])\n        path += '.f3d'\n\n        rootpath = LSDmisc.getSharedStoragePath()\n        f3dfile = '/'.join([rootpath, path])\n        saved = glist[0].save(f3dfile)\n    else:\n        f3dfile = f3dfileparm.eval()\n        if not f3dfile:\n            sys.stderr.write('No F3D file found. \\n')\n            return\n\n    # F3D bounding box\n    bounds = [-1, 1, -1, 1, -1, 1]\n    bounds_attrib = glist[0].attribute('geo:prim', 'intrinsic:bounds')\n    if bounds_attrib >= 0:\n        bounds = glist[0].value(bounds_attrib, 0)\n\n    f3dprim = f3dPrimitive()\n    f3dprim.addFilename(f3dfile)\n    f3dprim.addBounds(bounds)\n\n    for prim in xrange(primcount):\n        primname = glist[0].value(primname_attrib, prim)[0].strip()\n        if not primname:\n            return\n        f3dprim.addField(primname)\n\n    f3dprim.save()\n\n#-------------------------------------------------------------------------------\n\nclass usefulAttributes(object):\n    def __init__(self, geo):\n        # Global attributes\n        self.pointcount = geo.globalValue('geo:pointcount')[0]\n        self.primcount  = geo.globalValue('geo:primcount')[0]\n        self.a_blobbystrings = geo.attribute('geo:global', 'RiBlobby_Strings')\n\n        #  Primitive attributes\n        self.a_primtype    = geo.attribute('geo:prim', 'geo:primtype')\n        self.a_primname    = geo.attribute('geo:prim', 'geo:primname')\n        self.a_vertexcount = geo.attribute('geo:prim', 'geo:vertexcount')\n        self.a_primrowcol  = geo.attribute('geo:prim', 'geo:primrowcol')\n        self.a_primclose   = geo.attribute('geo:prim', 'geo:primclose')\n        self.a_primxform   = geo.attribute('geo:prim', 'geo:primtransform')\n        self.a_tubetaper   = geo.attribute('geo:prim', 'geo:tubetaper')\n        self.a_metakernel  = geo.attribute('geo:prim', 'geo:metakernel')\n        # NURBS basis information\n        self.a_primorder    = geo.attribute('geo:prim', 'geo:primorder')\n        self.a_primuorder   = geo.attribute('geo:prim', 'geo:primuorder')\n        self.a_primvorder   = geo.attribute('geo:prim', 'geo:primvorder')\n        self.a_ubasisknots  = geo.attribute('geo:prim', 'geo:ubasisknots')\n        self.a_vbasisknots  = geo.attribute('geo:prim', 'geo:vbasisknots')\n        self.a_ubasisextent = geo.attribute('geo:prim', 'geo:ubasisextent')\n        self.a_vbasisextent = geo.attribute('geo:prim', 'geo:vbasisextent')\n        self.a_trimncurves  = geo.attribute('geo:prim', 'geo:trimcurvecount')\n        self.a_time         = 0\n\n        # Vertex attribute\n        self.a_pointref    = geo.attribute('geo:vertex', 'geo:pointref')\n        self.P             = geo.attribute('geo:point',  'P')\n        self.Pw            = geo.attribute('geo:point',  'Pw')\n\n        # Primitive type id's\n        self.polytype   = sohog.PrimTypes['Polygon']\n        self.meshtype   = sohog.PrimTypes['Mesh']\n        self.spheretype = sohog.PrimTypes['Sphere']\n        self.circletype = sohog.PrimTypes['Circle']\n        self.tubetype   = sohog.PrimTypes['Tube']\n        self.NURBSsurftype  = sohog.PrimTypes['NURBSSurface']\n        self.NURBScurvetype = sohog.PrimTypes['NURBSCurve']\n        self.vdbtype = sohog.PrimTypes['VDB']\n\n        self.hasUniform  = True\n        self.hasVarying  = True\n        self.hasVertex   = LSDsettings.getFeature('vertex_classtype')\n        self.hasConstant = LSDsettings.getFeature('constant_classtype')\n        self.hasFaceVarying = LSDsettings.getFeature('facevarying_classtype')\n        self.hasNuCurves = LSDsettings.getFeature('RiNuCurves')\n\n    def dump(self, title=\"\"):\n        print \"#Attributes for\", title\n        print \"#  self.pointcount\", self.pointcount\n        print \"#  self.primcount\", self.primcount\n        print \"#  self.a_primtype\", self.a_primtype\n        print \"#  self.a_vertexcount\", self.a_vertexcount\n        print \"#  self.a_primrowcol\", self.a_primrowcol\n        print \"#  self.a_primclose\", self.a_primclose\n        print \"#  self.a_primxform\", self.a_primxform\n        print \"#  self.a_primorder\", self.a_primorder\n        print \"#  self.a_primuorder\", self.a_primuorder\n        print \"#  self.a_primvorder\", self.a_primvorder\n        print \"#  self.a_ubasisknots\", self.a_ubasisknots\n        print \"#  self.a_vbasisknots\", self.a_vbasisknots\n        print \"#  self.a_ubasisextent\", self.a_ubasisextent\n        print \"#  self.a_vbasisextent\", self.a_vbasisextent\n        print \"#  self.a_trimncurves\", self.a_trimncurves\n        print \"#  self.a_pointref\", self.a_pointref\n        print \"#  self.P\", self.P\n        print \"#  self.polytype\", self.polytype\n        print \"#  self.meshtype\", self.meshtype\n        print \"#  self.spheretype\", self.spheretype\n        print \"#  self.circletype\", self.circletype\n        print \"#  self.tubetype\", self.tubetype\n        print \"#  self.NURBSsurftype\", self.NURBSsurftype\n        print \"#  self.hasUniform\", self.hasUniform\n        print \"#  self.hasVarying\", self.hasVarying\n        print \"#  self.hasVertex\", self.hasVertex\n        print \"#  self.hasConstant\", self.hasConstant\n        print \"#  self.hasNuCurves\", self.hasNuCurves\n\n# Tubes have to be rotated by PI/2 around the X axis\n#_tubePreTransform = [1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1]\n_tubePreTransform = hou.Matrix4([1,0,0,0, 0,0,1,0, 0,-1,0,0, 0,0,0,1])\n\n#\n#  Generator functions.  These functions are used to iterate over\n#  lists without necessarily having to physically create the lists.\n#\ndef _List_one(n):\n    for x in xrange(n):\n        yield 1\n\nmetaopcodes = [-1]*4\nmetaopcodes[sohog.META_OPADD] = 0\nmetaopcodes[sohog.META_OPMAX] = 2\nmetaopcodes[sohog.META_OPMIN] = 3\n\ndef cpolyPointList(polypoints):\n    n = len(polypoints)\n    for pnum in xrange(n):\n        if polypoints[pnum] >= 0:\n            yield pnum\n\ndef cpolyVertexList(geo, attribs):\n    for pnum in xrange(attribs.primcount):\n        nv = geo.value(attribs.a_vertexcount, pnum)[0]\n        for v in xrange(nv):\n            yield (pnum, v)\n\ndef cblobPointList(geo, attribs, primlist):\n    # Output 2x the attributes since we also output the weight as a leaf\n    for pnum in primlist:\n        ptnum = geo.vertex(attribs.a_pointref, pnum, 0)[0]\n        yield ptnum\n        yield ptnum\n\ndef cblobVertexList(primlist):\n    # Output 2x the attributes since we also output the weight as a leaf\n    for pnum in primlist:\n        yield (pnum, 0)\n        yield (pnum, 0)\n\ndef cblobPrimList(primlist):\n    # Output 2x the attributes since we also output the weight as a leaf\n    for pnum in primlist:\n        yield pnum\n        yield pnum\n\ndef hBlobbyFloats(code, geo, attribs, control):\n    # Output the transform for each metaball primitive, along with the\n    # weight of the metaball.  This is 17*nleaf floats\n    a_metaweight = geo.attribute('geo:prim', 'geo:metaweight')\n    for pnum in code.PrimList:\n        xform = geo.value(attribs.a_primxform, pnum)\n        if control.VelocityAttrib >= 0:\n            tscale = attribs.a_time - control.VelocityTime\n            ptnum = geo.vertex(attribs.a_pointref, pnum, 0)[0]\n            v = geo.value(control.VelocityAttrib, ptnum)\n            xform = LSDmisc.translate4(xform, v[0]*tscale, v[1]*tscale, v[2]*tscale)\n        for i in xform:\n            yield i\n        weight = geo.value(a_metaweight, pnum)[0]*.5\n        yield weight\n\ndef hBlobbyStrings(geo, attribs, control):\n    # Evaluate the 'RiBlobby_Strings' attribute to \n    if attribs.a_blobbystrings >= 0:\n        strings = geo.value(attribs.a_blobbystrings, 0)[0]\n        return shlex.split(strings)\n    return []\n\ndef cpolyVertexArrayToPoint(vlist, polypoints):\n    for v in vlist:\n        yield polypoints[v]\n\ndef opolyVertexCount(geo, attribs):\n    for pnum in xrange(attribs.primcount):\n        yield geo.value(attribs.a_vertexcount, pnum)[0]\n\ndef opolyVertexValue(geo, attribs):\n    for pnum in xrange(attribs.primcount):\n        nv = geo.value(attribs.a_vertexcount, pnum)[0]\n        for v in xrange(nv):\n            yield (pnum, v)\n\ndef opolyUniformValue(geo, attribs):\n    # Last time I checked, AppNote #22 lied about uniform values.\n    # According to AppNote #19 (and other sources), there should be\n    # one uniform value per curve\n    for pnum in xrange(attribs.primcount):\n        yield pnum\n\ndef opolyVaryingValue(geo, attribs, interp, step):\n    # Varying values are tricky\n    if interp == 'linear':\n        for pnum in xrange(attribs.primcount):\n            nv = geo.value(attribs.a_vertexcount, pnum)[0]\n            for v in xrange(nv):\n                yield(pnum, v)\n    else:\n        # cubic interpolation\n        for pnum in xrange(attribs.primcount):\n            nv = geo.value(attribs.a_vertexcount, pnum)[0]\n            nsegments = (nv - 4)/step + 2\n            for seg in xrange(nsegments):\n                if seg == nsegments-1:\n                    v = (nv - 1)*step + 3\n                else:\n                    v = seg * step\n                yield (pnum, v)\n\ndef primPointList(geo, pnum, nv, a_pointref):\n    # Iterate over each of the vertices in the primitive, returning\n    # the point number.  This is used to extract point attributes when\n    # converting Houdini to LSD\n    for v in xrange(nv):\n        yield geo.vertex(a_pointref, pnum, v)[0]\n\ndef primVertexList(pnum, nv):\n    # Iterate over each of the vertices in the primitive, returning\n    # the primitive/vertex pair.  This is used to extract vertex\n    # attributes when converting Houdini to LSD\n    for v in xrange(nv):\n        yield (pnum, v)\n\ndef soupVertexList(pnum, vertexmap):\n    # A polysoup can have shared vertices.  However, LSD wants an expanded\n    # vertex list, so we need to repeat vertex numbers for the shared vertices.\n    for v in vertexmap:\n        yield (pnum, v)\n\ndef primRepeatValue(n, value):\n    for x in xrange(n):\n        yield value\n\n\n#\n# This is a map of the attribute types output by the Attribute SOP\n# into their LSD equivalents.\n#\nglobalAttribTypeMap = {\n    # AtrToken    Storage Hint  Type\n    \"vtx_float\":  ( \"vertex\",   \"float\" ),\n    \"vtx_color\":  ( \"vertex\",   \"color\" ),\n    \"vtx_point\":  ( \"vertex\",   \"point\" ),\n    \"vtx_vector\": ( \"vertex\",   \"vector\"),\n    \"vtx_normal\": ( \"vertex\",   \"normal\"),\n    \"vtx_mpoint\": ( \"vertex\",   \"mpoint\"),\n    \"v_float\":    ( \"varying\",  \"float\" ),\n    \"v_color\":    ( \"varying\",  \"color\" ),\n    \"v_point\":    ( \"varying\",  \"point\" ),\n    \"v_vector\":   ( \"varying\",  \"vector\"),\n    \"v_normal\":   ( \"varying\",  \"normal\"),\n    \"v_mpoint\":   ( \"varying\",  \"mpoint\"),\n    \"u_float\":    ( \"uniform\",  \"float\" ),\n    \"u_color\":    ( \"uniform\",  \"color\" ),\n    \"u_point\":    ( \"uniform\",  \"point\" ),\n    \"u_vector\":   ( \"uniform\",  \"vector\"),\n    \"u_normal\":   ( \"uniform\",  \"normal\"),\n    \"u_string\":   ( \"uniform\",  \"string\"),\n    \"c_float\":    ( \"constant\", \"float\" ),\n    \"c_color\":    ( \"constant\", \"color\" ),\n    \"c_point\":    ( \"constant\", \"point\" ),\n    \"c_vector\":   ( \"constant\", \"vector\"),\n    \"c_normal\":   ( \"constant\", \"normal\"),\n    \"c_string\":   ( \"constant\", \"string\"),\n}\n\ndef buildRixlateList(geo):\n    rixlate = geo.attribute('geo:global', 'rixlate')\n    if rixlate >= 0:\n        rixlate = geo.attribProperty(rixlate, 'geo:allstrings')\n    else:\n        rixlate = [ \"pt:Cd:Cs:vtx_color\",\n                    \"pt:Alpha:Os:v_color\",\n                    \"pt:N:N:v_normal\",\n                    \"pt:uv:s:v_float:0\",\n                    \"pt:uv:t:v_float:1\",\n                    \"pt:rest:__Pref:vtx_point\",\n                    \"pt:pscale:width:v_float\" ]\n    l = []\n    for a in rixlate:\n        f = a.split(':')\n        if len(f) < 4:\n            continue\n        atr = None\n        if f[0] == 'pt' or f[0] == 'vtx':\n            type = 'geo:point'\n            atr = geo.attribute(type, f[1])\n            if atr < 0:\n                type = 'geo:vertex'\n                atr = geo.attribute(type, f[1])\n        else:\n            type = 'geo:prim'\n            atr = geo.attribute(type, f[1])\n            if atr < 0:\n                type = 'geo:global'\n                atr = geo.attribute(type, f[1])\n        if atr < 0:\n            continue\n        ritype = globalAttribTypeMap[f[3]]\n        offset = 0\n        if len(f) > 4:\n            try:        offset = int(f[4])\n            except:     offset = 0\n        l.append( (f[2], ritype, type, atr, offset) )\n    return l\n\n# RiPatchMesh() translation\ndef hMesh(geo, pnum, rixlate, attribs, control):\n    rowcol = geo.value(attribs.a_primrowcol, pnum)\n    closed = geo.value(attribs.a_primclose, pnum)\n    wrap = ['nonperiodic', 'nonperiodic']\n    if closed[0]: wrap[0] = 'periodic'\n    if closed[1]: wrap[1] = 'periodic'\n    nv = geo.value(attribs.a_vertexcount, pnum)[0]\n\n    # Create the parameter list for the mesh\n    parmlist = RiGeoParmList()\n    parmlist.addP('P', __P_varying_type, geo,\n                        primPointList(geo, pnum, nv, attribs.a_pointref),\n                        attribs.P, control.VelocityAttrib,\n                        control.VelocityTime - attribs.a_time)\n    foundN = False\n    for x in rixlate:\n        if x[2] == 'geo:point':\n            if x[1][0] == 'vertex':\n                ritype = ' '.join(['vertex', x[1][1]])\n            else:\n                ritype = ' '.join(['varying', x[1][1]])\n            if x[0] == 'N':\n                foundN = True\n            parmlist.addSohoParm(x[0], ritype, geo, x[3],\n                        primPointList(geo, pnum, nv, attribs.a_pointref), x[4])\n        elif x[2] == 'geo:vertex':\n            if x[1][0] == 'vertex':\n                ritype = ' '.join(['vertex', x[1][1]])\n            else:\n                ritype = ' '.join(['varying', x[1][1]])\n            parmlist.addSohoParm(x[0], ritype, geo, x[3],\n                        primVertexList(pnum, nv), x[4])\n        elif x[2] == 'geo:prim' or x[2] == 'geo:global':\n            if attribs.hasConstant:\n                ritype = ' '.join(['constant', x[1][1]])\n                parmlist.addSohoParm(x[0], ritype, geo, x[3], [pnum], x[4])\n            else:\n                ritype = ' '.join(['uniform', x[1][1]])\n                if closed[0]:   nfaces = rowcol[0]\n                else:           nfaces = rowcol[0]-1\n                if closed[1]:   nfaces *= rowcol[1]\n                else:           nfaces *= rowcol[1]-1\n                parmlist.addSohoParm(x[0], ritype, geo, x[3],\n                        primRepeatValue(nfaces, pnum), x[4])\n\n    if not foundN and control.ComputeN:\n        parmlist.addSohoParm('N', 'varying normal', geo, geo.normal(),\n                        primPointList(geo, pnum, nv, attribs.a_pointref), 0)\n    Ri.PatchMesh('bilinear', rowcol[1], wrap[0],\n                             rowcol[0], wrap[1], parmlist)\n\ndef hTrimCurves(geo, pnum, attribs):\n    ncurves = geo.value(attribs.a_trimncurves, pnum)\n    if len(ncurves) == 0:\n        return False\n    a_order  = geo.attribute('geo:prim', 'geo:trimorder')\n    a_ncvs   = geo.attribute('geo:prim', 'geo:trimvertexcount')\n    a_knots  = geo.attribute('geo:prim', 'geo:trimknots')\n    a_min    = geo.attribute('geo:prim', 'geo:trimknotmin')\n    a_max    = geo.attribute('geo:prim', 'geo:trimknotmax')\n    a_u      = geo.attribute('geo:prim', 'geo:trimU')\n    a_v      = geo.attribute('geo:prim', 'geo:trimV')\n    a_w      = geo.attribute('geo:prim', 'geo:trimW')\n    order = geo.value(a_order, pnum)\n    if len(order) == 0:\n        return\n    knots = geo.value(a_knots, pnum)\n    min = geo.value(a_min, pnum)\n    max = geo.value(a_max, pnum)\n    n = geo.value(a_ncvs, pnum)\n    u = geo.value(a_u, pnum)\n    v = geo.value(a_v, pnum)\n    w = geo.value(a_w, pnum)\n    Ri.AttributeBegin()\n    Ri.TrimCurve(len(ncurves), ncurves, order, knots, min, max, n, u, v, w)\n    return True\n\ndef hNURBSsurf(geo, pnum, rixlate, attribs, control):\n    rowcol = geo.value(attribs.a_primrowcol, pnum)\n    nv = geo.value(attribs.a_vertexcount, pnum)[0]\n    order = geo.value(attribs.a_primorder, pnum)\n    uknots = geo.value(attribs.a_ubasisknots, pnum)\n    vknots = geo.value(attribs.a_vbasisknots, pnum)\n    uextent = geo.value(attribs.a_ubasisextent, pnum)\n    vextent = geo.value(attribs.a_vbasisextent, pnum)\n\n    parmlist = RiGeoParmList()\n    parmlist.addP('Pw', 'vertex hpoint', geo,\n                    primPointList(geo, pnum, nv, attribs.a_pointref),\n                    attribs.P, control.VelocityAttrib,\n                    control.VelocityTime - attribs.a_time, True, attribs.Pw)\n    for x in rixlate:\n        if x[2] == 'geo:point':\n            ritype = ' '.join(['vertex', x[1][1]])\n            parmlist.addSohoParm(x[0], ritype, geo, x[3],\n                        primPointList(geo, pnum, nv, attribs.a_pointref), x[4])\n        elif x[2] == 'geo:vertex':\n            if attribs.hasVertex:\n                ritype = ' '.join(['vertex', x[1][1]])\n                parmlist.addSohoParm(x[0], ritype, geo, x[3],\n                        primVertexList(pnum, nv), x[4])\n        elif attribs.hasConstant:\n            ritype = ' '.join(['constant', x[1][1]])\n            if x[2] == 'geo:prim':\n                parmlist.addSohoParm(x[0], ritype, geo, x[3], [pnum], x[4])\n            elif x[2] == 'geo:global':\n                parmlist.addSohoParm(x[0], ritype, geo, x[3], [0], x[4])\n    Ri.NuPatch( rowcol[1], order[0], uknots, uextent[0], uextent[1],\n                rowcol[0], order[1], vknots, vextent[0], vextent[1],\n                parmlist )\n\ndef hNURBScurve(geo, pnum, rixlate, attribs, control):\n    nv = geo.value(attribs.a_vertexcount, pnum)[0]\n    order = geo.value(attribs.a_primorder, pnum)\n    knots = geo.value(attribs.a_ubasisknots, pnum)\n    extent = geo.value(attribs.a_ubasisextent, pnum)\n    parmlist = RiGeoParmList()\n    parmlist.addP('Pw', 'vertex hpoint', geo,\n                        primPointList(geo, pnum, nv, attribs.a_pointref),\n                        attribs.P, control.VelocityAttrib,\n                        control.VelocityTime - attribs.a_time, True, attribs.Pw)\n    for x in rixlate:\n        if x[2] == 'geo:point' or x[2] == 'geo:vertex':\n            ritype = ' '.join(['varying', x[1][1]])\n            if x[2] == 'geo:point':\n                parmlist.addSohoParm(x[0], ritype, geo, x[3],\n                    primPointList(geo, pnum, nv, attribs.a_pointref), x[4])\n            else:\n                parmlist.addSohoParm(x[0], ritype, geo, x[3],\n                    primVertexList(pnum, nv), x[4])\n        elif attribs.hasConstant:\n            ritype = ' '.join(['constant', x[1][1]])\n            if x[2] == 'geo:prim':\n                parmlist.addSohoParm(x[0], ritype, geo, x[3], [pnum], x[4])\n            elif x[2] == 'geo:global':\n                parmlist.addSohoParm(x[0], ritype, geo, x[3], [0], x[4])\n    Ri.NuCurves(nv, order[0], knots, extent[0], extent[1], parmlist)\n\ndef hQuadricParmList(geo, pnum, ptlist, rixlate):\n    parmlist = RiGeoParmList()\n    for x in rixlate:\n        ritype = ' '.join(x[1])\n        if x[1][0] == 'varying' or x[1][0] == 'vertex':\n            if x[2] == 'geo:point':\n                pt = ptlist[0]\n            else:\n                pt = (pnum, 0)\n            parmlist.addSohoParm(x[0], ritype, geo, x[3], [pt,pt,pt,pt], x[4])\n        elif x[1][0] == 'uniform' or x[1][0] == 'constant':\n            parmlist.addSohoParm(x[0], ritype, geo, x[3], [pnum], x[4])\n    return parmlist\n\ndef hGeometry(name):\n    parmlist = RiGeoParmList()\n    Ri.Geometry(name, parmlist)\n\ndef hSphere(geo, pnum, rixlate, attribs, control):\n    ptlist = geo.vertex(attribs.a_pointref, pnum, 0)\n    parmlist = hQuadricParmList(geo, pnum, ptlist, rixlate)\n    Ri.Sphere(1, -1, 1, 360, parmlist)\n\ndef hCircle(geo, pnum, rixlate, attribs, control):\n    ptlist = geo.vertex(attribs.a_pointref, pnum, 0)\n    Ri.Disk(0, 1, 360, hQuadricParmList(geo, pnum, ptlist, rixlate))\n\ndef hTube(geo, pnum, rixlate, attribs, control):\n    ptlist = geo.vertex(attribs.a_pointref, pnum, 0)\n    taper = geo.value(attribs.a_tubetaper, pnum)[0]\n    endcaps = geo.value(attribs.a_primclose, pnum)[0]\n    plist = hQuadricParmList(geo, pnum, ptlist, rixlate)\n    Ri.Hyperboloid([1, 0, 0.5], [taper, 0, -.5], 360, plist)\n    if endcaps:\n        Ri.Disk(-.5, taper, 360, plist)\n        Ri.Disk( .5, 1, 360, plist)\n\ndef defaultedGlobalValue(geo, attribname, defvalue):\n    handle = geo.attribute('geo:global', attribname)\n    if handle >= 0:\n        return geo.value(handle, 0)\n    return defvalue\n\ndef getCurveStep(geo, control, interp, basis):\n    if interp is 'linear':\n        return 1\n    step = defaultedGlobalValue(geo, 'ri_curvestep', control.CurveStep)\n    if step > 0:\n        return step\n    if basis == 'bezier':       return 3\n    if basis == 'b-spline':     return 1\n    if basis == 'bspline':      return 1\n    if basis == 'catmull-rom':  return 1\n    if basis == 'hermite':      return 2\n    if basis == 'power':        return 4\n    return 3\n\ndef hOpenCurveBasis(geo, control):\n    # Check to see if there are attributes to specify the basis for\n    # the curves.\n    # TODO:  We should be able to split the curves into different sets\n    # based on curve interpolation (or even curve basis).  To do this, we would\n    # have to partition the curves based on the (interp, basis, step).\n    interp = defaultedGlobalValue(geo, 'ri_curveinterpolation',\n                            control.CurveInterpolation)\n    basis  = defaultedGlobalValue(geo, 'ri_curvebasis',\n                            control.CurveBasis)\n    step = getCurveStep(geo, control, interp, basis)\n    return (interp, basis, step)\n\ndef hOpenCurves(geo, control, rixlate, attribs):\n    interp, basis, step = hOpenCurveBasis(geo, control)\n    parmlist = RiGeoParmList()\n    if LSDsettings.getFeature('prman12.5-RiCurveP-Bug'):\n        # prman12.5 had a bug which caused the fully qualified 'P' to\n        # be misinterpreted.  We would prefer to fully qualify the\n        # variables though.\n        ritype = None\n    else:\n        ritype = __P_vertex_type\n    parmlist.addP('P', ritype, geo, opolyVertexValue(geo, attribs),\n                attribs.P, control.VelocityAttrib,\n                control.VelocityTime - attribs.a_time)\n    for x in rixlate:\n        ritype = ' '.join(x[1])\n        if x[1][0] == 'vertex' and attribs.hasVertex:\n            parmlist.addSohoParm(x[0], ritype, geo, x[3],\n                        opolyVertexValue(geo, attribs), x[4])\n        elif x[1][0] == 'varying' or x[1][0] == 'vertex':\n            parmlist.addSohoParm(x[0], ritype, geo, x[3],\n                        opolyVaryingValue(geo, attribs, interp, step), x[4])\n        elif x[1][0] == 'uniform':\n            parmlist.addSohoParm(x[0], ritype, geo, x[3],\n                        opolyUniformValue(geo, attribs), x[4])\n        elif x[1][0] == 'constant':\n            parmlist.addSohoParm(x[0], ritype, geo, x[3], [0], x[4])\n\n    Ri.Curves(interp, attribs.primcount,\n                opolyVertexCount(geo, attribs), 'nonperiodic', parmlist)\n\ndef extractPolyInfo(geo, attribs):\n    npts = attribs.pointcount\n    polypoints = [-1]*npts\n    vcountlist = []\n    vlist = []\n    for pnum in xrange(attribs.primcount):\n        nv = geo.value(attribs.a_vertexcount, pnum)[0]\n        vcountlist.append(nv)\n        for v in xrange(nv):\n            pt = geo.vertex(attribs.a_pointref, pnum, v)[0]\n            vlist.append(pt)\n            polypoints[pt] = 1\n    if len(vcountlist):\n        count = 0\n        for i in xrange(npts):\n            if polypoints[i] > 0:\n                polypoints[i] = count\n                count += 1\n    return vcountlist, vlist, polypoints\n\ndef extractPointList(geo, attribs):\n    npts = attribs.pointcount\n    if not hasattr(geo, 'PartitionInfo'):\n        # We're dealing with a full geometry which hasn't been\n        # partitioned.  So, we output all the points\n        return xrange(npts)\n    # Otherwise, we have to figure out which points are being used by\n    # the primitives in the geo.\n    usedpoints = [-1]*npts\n    for pnum in xrange(attribs.primcount):\n        nv = geo.value(attribs.a_vertexcount, pnum)[0]\n        for v in xrange(nv):\n            pt = geo.vertex(attribs.a_pointref, pnum, v)[0]\n            usedpoints[pt] = 1\n    ptlist = []\n    for i in xrange(npts):\n        if usedpoints[i] > 0:\n            ptlist.append(i)\n    return ptlist\n\ndef buildPolyParmList(geo, rixlate, attribs, polypoints, control):\n    parmlist = RiGeoParmList()\n    parmlist.addP('P', __P_varying_type, geo,\n            cpolyPointList(polypoints),\n            attribs.P, control.VelocityAttrib,\n            control.VelocityTime - attribs.a_time)\n\n    foundN = False\n    for x in rixlate:\n        if x[2] == 'geo:point':\n            if x[1][0] == 'vertex':\n                ritype = ' '.join(['vertex', x[1][1]])\n            else:\n                ritype = ' '.join(['varying', x[1][1]])\n            if x[0] == 'N':\n                foundN = True\n            parmlist.addSohoParm(x[0], ritype, geo, x[3],\n                        cpolyPointList(polypoints), x[4])\n        elif x[2] == 'geo:vertex':\n            if attribs.hasFaceVarying:\n                if x[0] == 'N':\n                    foundN = True\n                ritype = ' '.join(['facevarying', x[1][1]])\n                parmlist.addSohoParm(x[0], ritype, geo, x[3],\n                        cpolyVertexList(geo, attribs), x[4])\n        elif x[2] == 'geo:prim':\n            if attribs.hasConstant and x[1][0] == 'constant':\n                if x[0] == 'N':\n                    foundN = True\n                ritype = ' '.join(['constant', x[1][1]])\n                parmlist.addSohoParm(x[0], ritype, geo, x[3], [0], x[4])\n            else:\n                ritype = ' '.join(['uniform', x[1][1]])\n                parmlist.addSohoParm(x[0], ritype, geo, x[3],\n                                     xrange(attribs.primcount), x[4])\n        elif attribs.hasConstant and x[2] == 'geo:global':\n            ritype = ' '.join(['constant', x[1][1]])\n            parmlist.addSohoParm(x[0], ritype, geo, x[3], [0], x[4])\n\n    if not foundN and control.ComputeN:\n        parmlist.addSohoParm('N', 'varying normal', geo, geo.normal(),\n                        cpolyPointList(polypoints), 0)\n    return parmlist\n\ndef buildBlobbyParmList(geo, rixlate, attribs, primlist):\n    parmlist = RiGeoParmList()\n    for x in rixlate:\n        if x[2] == 'geo:point':\n            ritype = ' '.join(['varying', x[1][1]])\n            parmlist.addSohoParm(x[0], ritype, geo, x[3],\n                        cblobPointList(geo, attribs, primlist), x[4])\n        elif x[2] == 'geo:vertex':\n            ritype = ' '.join(['varying', x[1][1]])\n            parmlist.addSohoParm(x[0], ritype, geo, x[3],\n                        cblobVertexList(primlist), x[4])\n        elif x[2] == 'geo:prim':\n            if x[1][1] != 'string':\n                ritype = ' '.join(['varying', x[1][1]])\n                parmlist.addSohoParm(x[0], ritype, geo, x[3],\n                            cblobPrimList(primlist), x[4])\n        elif x[2] == 'geo:global':\n            ritype = ' '.join(['uniform', x[1][1]])\n            parmlist.addSohoParm(x[0], ritype, geo, x[3], [0], x[4])\n    return parmlist\n\ndef buildPointParmList(geo, rixlate, attribs, ptlist, control):\n    parmlist = RiGeoParmList()\n    if LSDsettings.getFeature('prman12.5-RiCurveP-Bug'):\n        # prman12.5 had a bug which caused the fully qualified 'P' to\n        # be misinterpreted.  We would prefer to fully qualify the\n        # variables though.\n        ritype = None\n    else:\n        ritype = __P_varying_type\n    parmlist.addP('P', ritype, geo, ptlist,\n                attribs.P, control.VelocityAttrib,\n                control.VelocityTime - attribs.a_time)\n\n    for x in rixlate:\n        if x[2] == 'geo:point':\n            ritype = ' '.join(['varying', x[1][1]])\n            parmlist.addSohoParm(x[0], ritype, geo, x[3], ptlist, x[4])\n        elif attribs.hasConstant and x[2] == 'geo:global':\n            ritype = ' '.join(['constant', x[1][1]])\n            parmlist.addSohoParm(x[0], ritype, geo, x[3], [0], x[4])\n    return parmlist\n\ndef hClosedPolys(geo, control, rixlate, attribs):\n    vcountlist, vlist, polypoints = extractPolyInfo(geo, attribs)\n    npolys = len(vcountlist)\n    if not npolys:\n        return\n    parmlist = buildPolyParmList(geo, rixlate, attribs, polypoints, control)\n    Ri.PointsGeneralPolygons(npolys, _List_one(npolys), vcountlist,\n                        cpolyVertexArrayToPoint(vlist, polypoints), parmlist)\n\ndef hPoints(geo, control, rixlate, attribs):\n    ptlist = extractPointList(geo, attribs)\n    npts = len(ptlist)\n    if not npts:\n        return\n    parmlist = buildPointParmList(geo, rixlate, attribs, ptlist, control)\n    Ri.Points(npts, parmlist)\n\ndef startSubDTag(name, tags, tagcounts, tagsize=2):\n    tags.append(name)\n    tagcounts.append([0]*tagsize)\n\ndef subDIntTag(value, itags, tagcounts):\n    counts = tagcounts[-1]\n    counts[0] += 1\n    itags.append(value)\n\ndef subDFloatTag(value, ftags, tagcounts):\n    counts = tagcounts[-1]\n    counts[1] += 1\n    ftags.append(value)\n\ndef subDStringTag(value, stags, tagcounts):\n    counts = tagcounts[-1]\n    counts[2] += 1\n    stags.append(value)\n\ndef subDTagCountGenerator(tagcounts):\n    for x in tagcounts:\n        for t in x:\n            yield t\n\ndef getInterpolateBoundary(geo, name, defval):\n    # First, we check for attributes on the geometry\n    a_interpolateboundary = geo.attribute('geo:prim', name)\n    if a_interpolateboundary >= 0:\n        primcount = geo.globalValue('geo:primcount')[0]\n        for pnum in xrange(primcount):\n            interpolate = geo.value(a_interpolateboundary, pnum)\n            return interpolate[0]\n    else:\n        interpolate = geo.globalValue(name)\n        if interpolate is not None:\n            return interpolate[0]\n\n    # If there was no attribute found, use the value in the control\n    return defval\n\ndef subdMaterials(attribs, itags, stags, tags, tagcounts):\n    try:\n        materials = attribs.materials\n    except:\n        return\n    if len(materials):\n        for mname in materials:\n            mat = materials[mname]\n            startSubDTag('faceedit', tags, tagcounts, 3)\n            for prim in mat.Prims:\n                subDIntTag(1, itags, tagcounts)    # 1st level of subdivision\n                subDIntTag(prim, itags, tagcounts) # Face primitive number\n            subDStringTag(\"attributes\", stags, tagcounts)\n            subDStringTag(mname, stags, tagcounts)\n            subDStringTag(\"shading\", stags, tagcounts)\n\ndef subdInterpolateBoundary(geo, control, itags, tags, tagcounts, tagsize):\n    # Check for the iterpolateboundary tag\n    interpolate = getInterpolateBoundary(geo, 'interpolateboundary',\n                                        control.InterpBoundary)\n    if interpolate is not None:\n        startSubDTag('interpolateboundary', tags, tagcounts, tagsize)\n        subDIntTag(int(interpolate), itags, tagcounts)\n\n    # Check for a facevaryinginterpolateboundary detail control\n    interpolate = getInterpolateBoundary(geo, 'facevaryinginterpolateboundary',\n                                        control.FaceVaryingInterpBoundary)\n    if interpolate is not None:\n        startSubDTag('facevaryinginterpolateboundary', tags, tagcounts, tagsize)\n        subDIntTag(int(interpolate), itags, tagcounts)\n\ndef subdCreaseWeight(geo, polypoints, attribs, itags, ftags, tags, tagcounts, tagsize):\n    primcount = attribs.primcount\n    a_vertexcount = attribs.a_vertexcount\n    a_pointref = attribs.a_pointref\n    v_creaseweight = geo.attribute('geo:vertex', 'creaseweight')\n    p_creaseweight = geo.attribute('geo:prim',   'creaseweight')\n    edgelist = {}\n    if v_creaseweight >= 0:\n        # Per vertex crease weights\n        for pnum in xrange(primcount):\n            nv = geo.value(a_vertexcount, pnum)[0]\n            prev = nv-1\n            ppt = polypoints[geo.vertex(a_pointref, pnum, nv-1)[0]]\n            for v in xrange(nv):\n                # The edge weight is defined as the weight\n                # associated with the leading vertex\n                weight = geo.vertex(v_creaseweight, pnum, prev)[0]\n                pt = polypoints[geo.vertex(a_pointref, pnum, v)[0]]\n                if pt < ppt:    edge = (pt, ppt)\n                else:           edge = (ppt, pt)\n                if edgelist.has_key(edge):\n                    edgelist[edge][0] += weight\n                    edgelist[edge][1] += 1\n                else:\n                    edgelist[edge] = [weight, 1]\n                prev = v\n                ppt = pt\n    elif p_creaseweight >= 0:\n        # Per primitive crease weights\n        for pnum in xrange(primcount):\n            weight = geo.value(p_creaseweight, pnum)[0]\n            nv = geo.value(a_vertexcount, pnum)[0]\n            prev = nv-1\n            ppt = polypoints[geo.vertex(a_pointref, pnum, nv-1)[0]]\n            for v in xrange(nv):\n                pt = polypoints[geo.vertex(a_pointref, pnum, v)[0]]\n                if pt < ppt:    edge = (pt, ppt)\n                else:           edge = (ppt, pt)\n                if edgelist.has_key(edge):\n                    edgelist[edge][0] += weight\n                    edgelist[edge][1] += 1\n                else:\n                    edgelist[edge] = [weight, 1]\n                prev = v\n                ppt = pt\n\n    if len(edgelist):\n        for key in edgelist:\n            startSubDTag(\"crease\", tags, tagcounts, tagsize)\n            subDIntTag(key[0], itags, tagcounts)\n            subDIntTag(key[1], itags, tagcounts)\n            edge = edgelist[key]\n            subDFloatTag(edge[0] / float(edge[1]), ftags, tagcounts)\n\n\ndef hHierarchicalSubdivisionMesh(geo, control, rixlate, attribs):\n    vcountlist, vlist, polypoints = extractPolyInfo(geo, attribs)\n    npolys = len(vcountlist)\n    if not npolys:\n        return\n\n    parmlist = buildPolyParmList(geo, rixlate, attribs, polypoints, control)\n\n    tags = []\n    itags = []\n    ftags = []\n    stags = []\n    tagcounts = []\n\n    scheme = defaultedGlobalValue(geo, 'ri_subdivscheme',\n                                        control.SubDScheme)\n\n    # Process faceedits\n    subdMaterials(attribs, itags, stags, tags, tagcounts)\n    # Process interpolate boundary\n    subdInterpolateBoundary(geo, control, itags, tags, tagcounts, 3)\n    # Process crease weights\n    subdCreaseWeight(geo, polypoints, attribs, itags, ftags, tags, tagcounts, 3)\n\n    # Now, output the h-subd mesh\n    Ri.HierarchicalSubdivisionMesh(scheme, npolys, vcountlist,\n                    cpolyVertexArrayToPoint(vlist, polypoints),\n                    len(tags), tags, subDTagCountGenerator(tagcounts),\n                    itags, ftags, stags, parmlist)\n\ndef hSubdivisionMesh(geo, control, rixlate, attribs):\n    vcountlist, vlist, polypoints = extractPolyInfo(geo, attribs)\n    npolys = len(vcountlist)\n    if not npolys:\n        return\n\n    parmlist = buildPolyParmList(geo, rixlate, attribs, polypoints, control)\n\n    tags = []\n    itags = []\n    ftags = []\n    tagcounts = []\n\n    scheme = defaultedGlobalValue(geo, 'ri_subdivscheme',\n                                        control.SubDScheme)\n\n    # Process interpolate boundary\n    subdInterpolateBoundary(geo, control, itags, tags, tagcounts, 2)\n    # Process crease weights\n    subdCreaseWeight(geo, polypoints, attribs, itags, ftags, tags, tagcounts, 2)\n\n    # TODO:  Some LSD renderers don't support multiple disconnected\n    # sub-division meshes within a single SubDivision surface.\n    # However, this requires knowledge of the connectedness of poly meshes\n    # and is not currently supported.\n    Ri.SubdivisionMesh(scheme, npolys, vcountlist,\n                    cpolyVertexArrayToPoint(vlist, polypoints),\n                    len(tags), tags, subDTagCountGenerator(tagcounts),\n                    itags, ftags, parmlist)\n\ndef outputSoup(g, pnum, rixlate, attribs, control):\n    # We can extract the soup information using primitive intrinsic attributes\n    # \"intrinsic:facecounts\" - vertices per face (len is the number of faces)\n    # \"intrinsic:expandedvertexmap\" - vertex point references\n    a_facecounts = g.attribute('geo:prim', 'intrinsic:facecounts')\n    a_vertexmap  = g.attribute('geo:prim', 'intrinsic:expandedvertexmap')\n    facecounts = g.value(a_facecounts, pnum)\n    nfaces = len(facecounts)\n    vertexmap = g.value(a_vertexmap, pnum)\n    nv = g.value(attribs.a_vertexcount, pnum)[0]\n    parmlist = RiGeoParmList()\n    parmlist.addP('P', __P_varying_type, g,\n                        primPointList(g, pnum, nv, attribs.a_pointref),\n                        attribs.P, control.VelocityAttrib,\n                        control.VelocityTime - attribs.a_time)\n    foundN = False\n    for x in rixlate:\n        if x[2] == 'geo:point':\n            ritype = ' '.join(['varying', x[1][1]])\n            if x[0] == 'N':\n                foundN = True\n            parmlist.addSohoParm(x[0], ritype, g, x[3],\n                    primPointList(g, pnum, nv, attribs.a_pointref), x[4])\n        elif x[2] == 'geo:vertex':\n            ritype = ' '.join(['vertex', x[1][1]])\n            parmlist.addSohoParm(x[0], ritype, g, x[3],\n                    soupVertexList(pnum, vertexmap), x[4])\n        elif x[3] == 'geo:prim' or x[2] == 'geo:global':\n            ritype = ' '.join(['constant', x[1][1]])\n            parmlist.addSohoParm(x[0], ritype, g, x[3], [pnum], x[4])\n    if control.RenderHSubD:\n        scheme = defaultedGlobalValue(g, 'ri_subdivscheme', control.SubDScheme)\n        tags = []\n        itags = []\n        ftags = []\n        stags = []\n        tagcounts = []\n        Ri.HierarchicalSubdivisionMesh(scheme, _List_one(nfaces), facecounts,\n                    vertexmap,\n                    len(tags), tags, subDTagCountGenerator(tagcounts),\n                    itags, ftags, stags, parmlist)\n    else:\n        if not foundN and control.ComputeN:\n            parmlist.addSohoParm('N', 'varying normal', g, g.normal(),\n                        primPointList(g, pnum, nv, attribs.a_pointref), 0)\n        Ri.PointsGeneralPolygons(nfaces, _List_one(nfaces), facecounts,\n                    vertexmap, parmlist)\n\ndef outputPatch(geo, pnum, primtype, rixlate, attribs, control):\n    if primtype == attribs.meshtype:\n        hMesh(geo, pnum, rixlate, attribs, control)\n    elif primtype == attribs.NURBSsurftype:\n        hNURBSsurf(geo, pnum, rixlate, attribs, control)\n    elif primtype == attribs.NURBScurvetype and attribs.hasNuCurves:\n        hNURBScurve(geo, pnum, rixlate, attribs, control)\n\ndef outputQuadric(geo, pnum, rixlate, attribs, control):\n    primtype = geo.value(attribs.a_primtype, pnum)[0]\n    if primtype == attribs.spheretype:\n        hSphere(geo, pnum, rixlate, attribs, control)\n    elif primtype == attribs.tubetype:\n        hTube(geo, pnum, rixlate, attribs, control)\n    elif primtype == attribs.circletype:\n        hCircle(geo, pnum, rixlate, attribs, control)\n\ndef evalNuCurvePrim(geo, attribs, which):\n    # Iterate over the primitives, yielding the attribute\n    for pnum in xrange(attribs.primcount):\n        yield geo.value(which, pnum)[0]\n\ndef evalNuCurveBasis(geo, attribs):\n    # Iterate over the primitives, yielding the attribute vector\n    # (rather than the scalar)\n    for pnum in xrange(attribs.primcount):\n        basis = geo.value(attribs.a_ubasisknots, pnum)\n        for t in basis:\n            yield t\n\ndef evalNuCurveMinMax(geo, attribs, idx):\n    # Yield either the min or the max extent for the NuCurve basis\n    for pnum in xrange(attribs.primcount):\n        yield geo.value(attribs.a_ubasisextent, pnum)[idx]\n\ndef nuCurvePoints(geo, attribs):\n    # Iterate over all the vertices of all NuCurve, yielding the geo point\n    # associated with the vertex\n    for pnum in xrange(attribs.primcount):\n        nvtx = geo.value(attribs.a_vertexcount, pnum)[0]\n        for v in xrange(nvtx):\n            yield geo.value(attribs.a_pointref, (pnum, v))[0]\n\ndef nuCurveVertices(geo, attribs):\n    # Iterate over all vertices of all NuCurves, yielding a tuple of\n    # the prim/vertex\n    for pnum in xrange(attribs.primcount):\n        nvtx = geo.value(attribs.a_vertexcount, pnum)[0]\n        for v in xrange(nvtx):\n            yield (pnum, v)\n\ndef outputNuCurves(geo, rixlate, attribs, control):\n    parmlist = RiGeoParmList()\n    parmlist.addP('Pw', 'vertex hpoint', geo,\n                        nuCurvePoints(geo, attribs),\n                        attribs.P, control.VelocityAttrib,\n                        control.VelocityTime - attribs.a_time, True, attribs.Pw)\n    for x in rixlate:\n        if x[2] == 'geo:point':\n            ritype = ' '.join(['vertex', x[1][1]])\n            parmlist.addSohoParm(x[0], ritype, geo, x[3],\n                                nuCurvePoints(geo, attribs))\n        elif x[2] == 'geo:vertex':\n            ritype = ' '.join(['vertex', x[1][1]])\n            parmlist.addSohoParm(x[0], ritype, geo, x[3],\n                                nuCurveVertices(geo, attribs))\n        elif x[2] == 'geo:global':\n            ritype = ' '.join(['constant', x[1][1]])\n            parmlist.addSohoParm(x[0], ritype, geo, x[3], [0], x[4])\n        else:\n            # Per-curve attribute\n            ritype = ' '.join(['uniform', x[1][1]])\n            parmlist.addSohoParm(x[0], ritype, geo, x[3],\n                                xrange(attribs.primcount), x[4])\n\n    Ri.NuCurves(\n        evalNuCurvePrim(geo, attribs, attribs.a_vertexcount),\n        evalNuCurvePrim(geo, attribs, attribs.a_primorder),\n        evalNuCurveBasis(geo, attribs),\n        evalNuCurveMinMax(geo, attribs, 0),\n        evalNuCurveMinMax(geo, attribs, 1),\n        parmlist)\n\n\ndef traverseNuCurves(glist, blocks, times, control):\n    nsegments = len(times)\n    if len(glist) != nsegments:\n        return\n\n    attribs = []\n    rixlate = []\n    for geo in glist:\n        alist = usefulAttributes(geo)\n        attribs.append(alist)\n        if alist.primcount != attribs[0].primcount:\n            return\n        rixlate.append(buildRixlateList(geo))\n\n    primcount = attribs[0].primcount\n    if nsegments > 1:\n        # Motion blur -- set up times outside the primitive loop\n        for i in xrange(nsegments):\n            attribs[i].a_time = times[i]\n        LSDmisc.MotionBegin(blocks)\n        for i in xrange(nsegments):\n            outputNuCurves(glist[i], rixlate[i], attribs[i], control)\n        Ri.MotionEnd()\n    else:\n        attribs[0].a_time = times[0]\n        outputNuCurves(glist[0], rixlate[0], attribs[0], control)\n\ndef traverseSoups(glist, blocks, times, control):\n    nsegments = len(times)\n    if len(glist) != nsegments:\n        return          # In theory, this should have been caught earlier\n\n    attribs = []\n    rixlate = []\n    for geo in glist:\n        alist = usefulAttributes(geo)\n        attribs.append(alist)\n        # Verify that the topology \"might\" match\n        if alist.primcount != attribs[0].primcount:\n            return\n        rixlate.append(buildRixlateList(geo))\n\n    primcount = attribs[0].primcount\n    if nsegments > 1:\n        # Motion blur -- set up times outside the primitive loop\n        for i in xrange(nsegments):\n            attribs[i].a_time = times[i]\n        for pnum in xrange(primcount):\n            LSDmisc.MotionBegin(blocks)\n            for i in xrange(nsegments):\n                outputSoup(glist[i], pnum, rixlate[i], attribs[i], control)\n            Ri.MotionEnd()\n    else:\n        attribs[0].a_time = times[0]\n        for pnum in xrange(primcount):\n            outputSoup(glist[0], pnum, rixlate[0], attribs[0], control)\n\ndef traversePatches(glist, blocks, times, control):\n    nsegments = len(times)\n    if len(glist) != nsegments:\n        return          # In theory, this should have been caught earlier\n\n    attribs = []\n    rixlate = []\n    for geo in glist:\n        alist = usefulAttributes(geo)\n        attribs.append(alist)\n        # Verify that the topology \"might\" match\n        if alist.primcount != attribs[0].primcount:\n            return\n        rixlate.append(buildRixlateList(geo))\n\n    primcount = attribs[0].primcount\n    if nsegments > 1:\n        # Motion blur -- set up times outside the primitive loop\n        for i in xrange(nsegments):\n            attribs[i].a_time = times[i]\n        dotrim = False\n        for pnum in xrange(primcount):\n            primtype = glist[0].value(attribs[0].a_primtype, pnum)[0]\n            if primtype == attribs[0].NURBSsurftype:\n                dotrim = hTrimCurves(glist[0], pnum, attribs[0])\n            LSDmisc.MotionBegin(blocks)\n            for i in xrange(nsegments):\n                outputPatch(glist[i], pnum, primtype,\n                                rixlate[i], attribs[i], control)\n            Ri.MotionEnd()\n            if dotrim:\n                Ri.AttributeEnd()\n                dotrim = False\n    else:\n        attribs[0].a_time = times[0]\n        dotrim = False\n        for pnum in xrange(primcount):\n            primtype = glist[0].value(attribs[0].a_primtype, pnum)[0]\n            if primtype == attribs[0].NURBSsurftype:\n                dotrim = hTrimCurves(glist[0], pnum, attribs[0])\n            outputPatch(glist[0], pnum, primtype,\n                                rixlate[0], attribs[0], control)\n            if dotrim:\n                Ri.AttributeEnd()\n                dotrim = False\n\n\nclass abcAttributes(object):\n    def __init__(self, glist):\n        def intrinsic(g, name):\n            return g.attribute('geo:prim', 'intrinsic:' + name)\n\n        self.abcfilename = []\n        self.abcobjectpath = []\n        self.abcframe = []\n        self.abctransform = []\n        self.abctypename = []\n        self.abcbounds = []\n        for g in glist:\n            self.abcfilename.append(intrinsic(g, 'abcfilename'))\n            self.abcobjectpath.append(intrinsic(g, 'abcobjectpath'))\n            self.abcframe.append(intrinsic(g, 'abcframe'))\n            self.abctypename.append(intrinsic(g, 'abctypename'))\n            self.abctransform.append(intrinsic(g, 'packedfulltransform'))\n            self.abcbounds.append(intrinsic(g, 'packedrenderbounds'))\n\n    def filename(self, glist, prim, segment):\n        return glist[segment].value(self.abcfilename[segment], prim)[0]\n    def objectpath(self, glist, prim, segment):\n        return glist[segment].value(self.abcobjectpath[segment], prim)[0]\n    def frame(self, glist, prim, segment):\n        return glist[segment].value(self.abcframe[segment], prim)[0]\n    def typename(self, glist, prim, segment):\n        return glist[segment].value(self.abctypename[segment], prim)[0]\n    def transform(self, glist, prim, segment):\n        return glist[segment].value(self.abctransform[segment], prim)\n    def bounds(self, glist, prim, segment):\n        return glist[segment].value(self.abcbounds[segment], prim)\n\ndef traverseAlembic(glist, blocks, times, control):\n    # Handle custom Alembic primitive\n    # We want to output primitive using the Alembic procedural\n    #  Procedural \"DynamicLoad\" [ \"AlembicProcedural.so\" \"arguments\" ]\n    # Sadly, LSD doesn't allow multiple procedurals inside a single motion\n    # block, so we have to use intrinsics to extract the information to pass as\n    # procedural arguments.\n    #   \"intrinsic:abcfilename\"         -filename\n    #   \"intrinsic:abcobjectpath\"       -objectpath\n    #   \"intrinsic:abcframe\"            - Alembic time\n    #   \"intrinsic:abctypename\"         Used to skip \"Xform\" nodes if they exit\n    #   \"intrinsic:bounds\"              Acquire bounds for primitives\n    #   \"intrinsic:transform\"           Used for transform block\n    nsegments = len(times)\n    if len(glist) != nsegments:\n        return\n\n    abc = abcAttributes(glist)\n    nprim = glist[0].globalValue('geo:primcount')[0]\n    segments = range(nsegments)\n    parmlist = RiParmList()\n    fps = soho.getDefaultedFloat(\"state:fps\", [24])[0]\n    for prim in xrange(nprim):\n        typename = abc.typename(glist, prim, 0)\n        if typename == 'Xform':\n            continue    # Skip transform nodes\n        filename = abc.filename(glist, prim, 0)\n        objectpath = abc.objectpath(glist, prim, 0)\n        bounds = abc.bounds(glist, prim, 0)\n        xforms = []\n        minframe =  1e17\n        maxframe = -1e17\n        for seg in segments:\n            xforms.append(abc.transform(glist, prim, seg))\n            frame = abc.frame(glist, prim, seg)\n            minframe = min(minframe, frame)\n            maxframe = max(maxframe, frame)\n\n        # does not support multi segment motion blur\n        motionbegin = 0\n        motionend = 0\n        if len(blocks) > 0:\n            motiontimes = blocks[:] # copy times\n            LSDmisc.TransformMotion(motiontimes)\n            motionbegin = motiontimes[0]\n            motionend = motiontimes[-1]\n\n        Ri.AttributeBegin()\n        Ri.Comment('Alembic Shape: %s' % (typename))\n        if len(xforms) > 1:\n            LSDmisc.MotionBegin(blocks)\n        for x in xforms:\n            Ri.ConcatTransform(x)\n        if len(xforms) > 1:\n            Ri.MotionEnd()\n\n        # The procedural uses the shutter arguments to offset the Alembic\n        # frame, so we need to set the shutter close to grab the \"last\"\n        # geometry in the segments.\n        arguments = [\n            '-filename', filename,\n            '-objectpath', objectpath,\n            '-frame', '%g' % (minframe*fps),\n            '-fps', '%g' % fps,\n            '-shutteropen', '0',\n            '-shutterclose', '%g' % ((maxframe - minframe)*fps),\n            '-motionbegin', '%g' % motionbegin,\n            '-motionend', '%g' % motionend,\n            '-excludeXform', \"1\"\n        ]\n\n        if control.AlembicFlipV:\n            arguments.append('-flipv')\n\n        Ri.DynamicLoad(AlembicProcedural, ' '.join(arguments), bounds)\n        Ri.AttributeEnd()\n\ndef traverseVolumes(glist, blocks, times, control):\n    nsegments = len(times)\n    if len(glist) != nsegments:\n        return\n\n    attribs = []\n    rixlate = []\n    nameattrib = glist[0].attribute('geo:prim', 'name')\n    for geo in glist:\n        alist = usefulAttributes(geo)\n        attribs.append(alist)\n        if alist.primcount != attribs[0].primcount:\n            return\n        rixlate.append(buildRixlateList(geo))\n    vprim = None\n    primcount = attribs[0].primcount\n    if primcount > 0:\n        for i in xrange(nsegments):\n            attribs[i].a_time = times[i]\n        for prim in xrange(primcount):\n            ch = 'density'\n            if nameattrib >= 0:\n                ch = glist[0].value(nameattrib, prim)[0].strip()\n                if not ch:\n                    ch = 'density'\n            if ch == 'density':\n                if vprim:\n                    # Save previous primitive\n                    vprim.save(glist, blocks, times, attribs, rixlate, control)\n                vprim = volumePrimitive(glist[0], prim, attribs[0])\n            else:\n                if vprim:\n                    vprim.addChannel(prim, ch)\n    if vprim:\n        vprim.save(glist, blocks, times, attribs, rixlate, control)\n\ndef traverseVDB(glist, blocks, times, control):\n    # Handle VDB primitive\n    # Output primitive using the impl_openvdb procedural\n\n    nsegments = len(times)\n    if len(glist) != nsegments:\n        return\n   \n    # Get prim count.  E.g. if there are density and velocity, then primcount = 2\n    primcount = glist[0].globalValue('geo:primcount')[0]\n    if primcount <= 0:\n        return\n\n    primname_attrib = glist[0].attribute('geo:prim', 'name')\n    if primname_attrib < 0:\n        return\n\n    # VDB file name\n    soppath_attrib = glist[0].attribute('geo:prim', 'geo:soppath')\n    soppath = glist[0].value(soppath_attrib, 0)[0]\n    if not soppath:\n        sys.stderr.write('Unable to find geometry path %s\\n' % soppath)\n        return\n\n    vdbfileparm = hou.parm(soppath+'/file')\n    if not vdbfileparm:\n        # When using convertVDB SOP, there could be no input .vdb file, \n        # so we want to write out a vdb file first.\n\n        # Create a unique filename for the temporary vdb output\n        sessionid = LSDmisc.ExternalSessionId\n        path = '%s_%s' % (sessionid, glist[0].globalValue('geo:sopid')[0])\n        path += '.vdb'\n\n        rootpath = LSDmisc.getSharedStoragePath()\n        vdbfile = '/'.join([rootpath, path])\n        saved = glist[0].save(vdbfile)\n    else:\n        vdbfile = vdbfileparm.eval()\n        if not vdbfile:\n            sys.stderr.write('No VDB file found. \\n')\n            return\n\n    # VDB bounding box\n    bounds = [-1, 1, -1, 1, -1, 1]\n    bounds_attrib = glist[0].attribute('geo:prim', 'intrinsic:bounds')\n    if bounds_attrib >= 0:\n        bounds = glist[0].value(bounds_attrib, 0)\n\n    vdbIsSSurface = False\n    for prim in xrange(primcount):\n        primname = glist[0].value(primname_attrib, prim)[0].strip()\n        if(primname == 'surface'):\n            vdbIsSSurface = True\n            break\n\n    if vdbIsSSurface:\n        vdbprim = vdbSdfPrimitive()\n    else:\n        vdbprim = vdbFogPrimitive()\n    vdbprim.addFilename(vdbfile)\n    vdbprim.addBounds(bounds)\n\n    primtype_attrib = glist[0].attribute('geo:prim', 'intrinsic:vdb_value_type')\n    \n    for prim in xrange(primcount):\n        primname = glist[0].value(primname_attrib, prim)[0].strip()\n        if not primname:\n            return\n        primtype = glist[0].value(primtype_attrib, prim)[0]\n        primtype = primtype.replace('vec3s', 'vector')\n        vdbprim.addPrims(primname, primtype)\n\n    vdbprim.save()\n\ndef traverseQuadrics(glist, blocks, times, control):\n    nsegments = len(times)\n    if len(glist) != nsegments:\n        return          # In theory, this should have been caught earlier\n\n    attribs = []\n    rixlate = []\n    for geo in glist:\n        alist = usefulAttributes(geo)\n        attribs.append(alist)\n        # Verify that the topology \"might\" match\n        if alist.primcount != attribs[0].primcount:\n            return\n        rixlate.append(buildRixlateList(geo))\n\n    primcount = attribs[0].primcount\n    if nsegments > 1 and primcount > 0:\n        for i in xrange(nsegments):\n            attribs[i].a_time = times[i]\n        for pnum in xrange(primcount):\n            Ri.TransformBegin()\n            LSDmisc.MotionBegin(blocks)\n            for i in xrange(nsegments):\n                outputQTransform(glist[i], pnum, attribs[i], control)\n            Ri.MotionEnd()\n            outputQuadric(glist[0], pnum, rixlate[0], attribs[0], control)\n            Ri.TransformEnd()\n    else:\n        attribs[0].a_time = times[0]\n        for pnum in xrange(primcount):\n            Ri.TransformBegin()\n            outputQTransform(glist[0], pnum, attribs[0], control)\n            outputQuadric(glist[0], pnum, rixlate[0], attribs[0], control)\n            Ri.TransformEnd()\n\ndef hSoupList(glist, blocks, times, control, method):\n    # Output multiple Houdini primitives into a single LSD primitive.\n    # Examples of this are closed polygons, open polygons,\n    # sub-division meshes\n    nsegments = len(times)\n    if nsegments > 1:\n        LSDmisc.MotionBegin(blocks)\n    for segment in xrange(nsegments):\n        geo = glist[segment]\n        alist = usefulAttributes(geo)\n        alist.a_time = times[segment]\n        method(geo, control, buildRixlateList(geo), alist)\n    if nsegments > 1:\n        Ri.MotionEnd()\n\ndef hBlobbies(glist, blocks, times, control):\n    nsegments = len(times)\n    if len(glist) != nsegments:\n        return          # In theory, this should have been caught ealier \n\n    attribs = []\n    rixlate = []\n    for geo in glist:\n        alist = usefulAttributes(geo)\n        attribs.append(alist)\n        # Verify that the number of metaballs is the same\n        if alist.primcount != attribs[0].primcount:\n            return\n        rixlate.append(buildRixlateList(geo))\n\n    primcount = attribs[0].primcount\n    for seg in xrange(nsegments):\n        attribs[seg].a_time = times[seg]\n    if nsegments > 1:\n        LSDmisc.MotionBegin(blocks)\n    volume = control.BlobbyVolume and LSDsettings.getFeature('RiBlobbyVolume')\n    for seg in xrange(nsegments):\n        code = metaProgram(glist[seg], volume)\n        plist = buildBlobbyParmList(glist[seg], rixlate[seg], attribs[seg],\n                                code.PrimList)\n        stringlist = hBlobbyStrings(glist[seg], attribs[seg], control)\n        Ri.Blobby(code.LeafCount,\n                len(code.Code), code.Code,\n                17*len(code.PrimList),\n                hBlobbyFloats(code, glist[seg], attribs[seg], control),\n                len(stringlist), stringlist, plist)\n    if nsegments > 1:\n        Ri.MotionEnd()\n\ndef ginfo(geo):\n    nprims = geo.globalValue('geo:primcount')\n    print '  #Prims: ', nprims\n    print '  #Points: ', geo.globalValue('geo:pointcount')\n    number = geo.attribute('geo:prim', 'geo:number')\n    vertexcount = geo.attribute('geo:prim', 'geo:vertexcount')\n    primname = geo.attribute('geo:prim', 'geo:primname')\n    tmap = geo.attribute('geo:prim', 'ogl_shop')\n    for prim in xrange(nprims[0]):\n        print '\\t', prim, geo.value(primname, prim), \\\n                        'Number:', geo.value(number, prim), \\\n                        '#Vtx:', geo.value(vertexcount, prim), \\\n                        'TMap:', geo.value(tmap, prim)\n\ndef groupPolygons(geo):\n    polytype  = sohog.PrimTypes['Polygon']\n    a_primtype  = geo.attribute('geo:prim', 'geo:primtype')\n    a_primclose = geo.attribute('geo:prim', 'geo:primclose')\n    a_vertexcount = geo.attribute('geo:prim', 'geo:vertexcount')\n    primcount = geo.globalValue('geo:primcount')[0]\n    for pnum in xrange(primcount):\n        if ( geo.value(a_primtype, pnum)[0] == polytype and\n             geo.value(a_vertexcount, pnum)[0] > 2 and\n             geo.value(a_primclose, pnum)[0] ):\n            yield 'ClosedPoly'\n        else:\n            yield 'NonPoly'\n\ndef groupPrimitives(geo):\n    a_primtype  = geo.attribute('geo:prim', 'geo:primtype')\n    a_primclose = geo.attribute('geo:prim', 'geo:primclose')\n    a_vertexcount = geo.attribute('geo:prim', 'geo:vertexcount')\n    a_primname = geo.attribute('geo:prim', 'geo:primname')\n    polytype    = sohog.PrimTypes['Polygon']\n    meshtype    = sohog.PrimTypes['Mesh']\n    nurbsmesh   = sohog.PrimTypes['NURBSSurface']\n    metaball    = sohog.PrimTypes['Metaball']\n    metasquad   = sohog.PrimTypes['MetaSuperQuad']\n    particle    = sohog.PrimTypes['Particle']\n    volume      = sohog.PrimTypes['Volume']\n    vdbtype     = sohog.PrimTypes['VDB']\n    alembic     = sohog.PrimTypes['AlembicRef']\n    souptype    = sohog.PrimTypes['PolySoup']\n    quadric     = (1 << sohog.PrimTypes['Sphere']) | \\\n                  (1 << sohog.PrimTypes['Circle']) | \\\n                  (1 << sohog.PrimTypes['Tube'])\n    nucurve = sohog.PrimTypes['NURBSCurve']\n    bezcurve = sohog.PrimTypes['BezierCurve']\n    hasnucurve = LSDsettings.getFeature('RiNuCurves')\n    primcount = geo.globalValue('geo:primcount')[0]\n    for pnum in xrange(primcount):\n        primtype = geo.value(a_primtype, pnum)[0]\n        if primtype == souptype:\n            yield 'Soup'\n        elif primtype == polytype:\n            if geo.value(a_primclose, pnum)[0]:\n                if geo.value(a_vertexcount, pnum)[0] > 2:\n                    yield 'ClosedPoly'\n                else:\n                    yield 'Degenerate'\n            else:\n                yield 'OpenPoly'\n        elif primtype == meshtype or primtype == nurbsmesh:\n            yield 'Patch'\n        elif primtype == particle:\n            yield 'Particle'\n        elif (1 << primtype) & quadric:\n            yield 'Quadric'\n        elif primtype == metaball or primtype == metasquad:\n            yield 'Meta'\n        elif (primtype == nucurve or primtype == bezcurve):\n            if not geo.value(a_primclose, pnum)[0]:\n                if hasnucurve:\n                    yield 'NuCurve'\n                else:\n                    yield 'OpenPoly'\n            else:\n                yield 'ClosedCurve'\n        elif primtype == volume:\n            yield 'Volume'\n        elif primtype == alembic:\n            yield 'Alembic'\n        elif primtype == vdbtype:\n            yield 'VDB'\n        else:\n            yield 'Tesselate'   # tesselate the primitive\n\ndef enlargeSubDHull(glist):\n    # Here, the user has specified that they want to \"enlarge\" the\n    # sub-d hull to include neighbouring polygons.  This is useful\n    # when partitioning a single sub-d mesh into multiple\n    # sub-primitives as continuity will be maintained.\n    #\n    # However, there are quite a few cases where this approach doesn't\n    # work.  It should be used with care.\n    for g in glist:\n        g.enlarge()\n\nclass HSubdMaterial(object):\n    def __init__(self, shop):\n        self.Shop = shop\n        self.Prims = []\n\ndef getMaterialList(geo, now, attribs, control):\n    '''\n        Given a geometry, attributes and a material handle, build the list of\n        materials and the primitives which reference them\n    '''\n    h_material = geo.attribute('geo:prim', 'shop_materialpath')\n    materials = {}\n    if h_material >= 0:\n        shops = geo.attribProperty(h_material, 'geo:allstrings')\n        for s in shops:\n            materials[s] = HSubdMaterial(s)\n        if len(materials):\n            npolys = attribs.primcount\n            for pnum in xrange(npolys):\n                # For each primitive, add the pri\n                mname = geo.value(h_material, pnum)[0]\n                mat = materials.get(mname, None)\n                if mat:\n                    mat.Prims.append(pnum)\n    clear = []\n    for mname in materials:\n        mat = materials[mname]\n        if mname and len(mat.Prims):\n            mat.Resource = createResource(mat.Shop, now, control, None)\n            if not mat.Resource:\n                # No SHOP, so no material\n                clear.append(mname)\n        else:\n            clear.append(mname)\n    for mname in clear:\n        # Prune out empty SHOP references\n        del materials[mname]\n    return materials\n\ndef outputHierarchicalSubd(polys, blocks, times, control):\n    # Output multiple Houdini polygons into a single LSD subd mesh.\n    # TODO: We need to handle overrides... Right now, that's an O(N*N)\n    # operation though, requiring iterating over all primitives.\n\n    # Build a dictionary of materials and all the primitives which reference\n    # them\n    materials = getMaterialList(polys[0], times[0],\n                                usefulAttributes(polys[0]), control)\n\n    Ri.Sides(control.Sides)\n    if control.Orient:\n        Ri.ReverseOrientation()\n    nsegments = len(times)\n    if nsegments > 1:\n        LSDmisc.MotionBegin(blocks)\n    for segment in xrange(nsegments):\n        geo = polys[segment]\n        alist = usefulAttributes(geo)\n        alist.a_time = times[segment]\n        alist.materials = materials\n        hHierarchicalSubdivisionMesh(geo, control, buildRixlateList(geo), alist)\n    if nsegments > 1:\n        Ri.MotionEnd()\n    if control.Orient:\n        Ri.ReverseOrientation()\n\ndef _saveRiPrimitives(glist, blocks, times, control):\n    '''\n        Save Ri geometry and return the primitives we were unable to output, by\n        splitting geometries into different sections (which are handled\n        separately in output)\n    '''\n    splits = {}\n    for geo in glist:\n        parts = geo.partition('geo:partlist', groupPrimitives(geo))\n        for key in parts:\n            if not splits.has_key(key):\n                splits[key] = [parts[key]]\n            else:\n                splits[key].append(parts[key])\n\n    #---------------------------------------------------------------------------\n\n    if splits.has_key('PackedF3D'):\n        traversePackedF3D(splits['PackedF3D'], blocks, times, control) \n    if splits.has_key('F3D'):\n        traverseF3D(splits['F3D'], blocks, times, control) \n\n    #---------------------------------------------------------------------------\n\n    if splits.has_key('Patch'):\n        if control.Orient:\n            Ri.ReverseOrientation()\n        traversePatches(splits['Patch'], blocks, times, control)\n        if control.Orient:\n            Ri.ReverseOrientation()\n\n    if splits.has_key('Soup'):\n        if control.Orient:\n            Ri.ReverseOrientation()\n        traverseSoups(splits['Soup'], blocks, times, control)\n        if control.Orient:\n            Ri.ReverseOrientation()\n\n    if splits.has_key('NuCurve'):\n        traverseNuCurves(splits['NuCurve'], blocks, times, control)\n\n    if splits.has_key('Quadric'):\n        traverseQuadrics(splits['Quadric'], blocks, times, control)\n\n    if splits.has_key('Particle'):\n        hSoupList(splits['Particle'], blocks, times, control, hPoints)\n\n    if splits.has_key('Volume'):\n        traverseVolumes(splits['Volume'], blocks, times, control)\n\n    if splits.has_key('VDB'):\n        traverseVDB(splits['VDB'], blocks, times, control)\n\n    if splits.has_key('Alembic'):\n        traverseAlembic(splits['Alembic'], blocks, times, control)\n\n    if splits.has_key('ClosedPoly'):\n        if control.Orient:\n            Ri.ReverseOrientation()\n        if control.RenderSubD:\n            if control.EnlargeSubD:\n                enlargeSubDHull(splits['ClosedPoly'])\n            hSoupList(splits['ClosedPoly'], blocks, times, control, hSubdivisionMesh)\n        else:\n            hSoupList(splits['ClosedPoly'], blocks, times, control, hClosedPolys)\n        if control.Orient:\n            Ri.ReverseOrientation()\n\n    if splits.has_key('OpenPoly') and LSDsettings.getFeature('RiCurves'):\n        curves = splits['OpenPoly']\n        interp, basis, step = hOpenCurveBasis(curves[0], control)\n        if interp != 'linear':\n            Ri.Basis(Ri.LookupBasis(basis), step, Ri.LookupBasis(basis), step)\n        hSoupList(curves, blocks, times, control, hOpenCurves)\n        if interp != 'linear':\n            Ri.Comment('Restore basis to Bezier')\n            Ri.Basis(Ri.LookupBasis('bezier'), 3, Ri.LookupBasis('bezier'), 3)\n\n    if splits.has_key('Meta'):\n        hBlobbies(splits['Meta'], blocks, times, control)\n\n    return splits.get('Tesselate', None)\n\ndef savePrimitives(glist, blocks, times, control):\n    if control.RenderPoints:\n        hSoupList(glist, blocks, times, control, hPoints)\n        return\n\n    Ri.Sides(control.Sides)\n\n    # Tesselate any primitives which aren't handled natively\n    unsaved = glist\n    i = 0\n    while unsaved and i < 3:\n        unsaved = _saveRiPrimitives(glist, blocks, times, control)\n        if unsaved:\n            # Tesselate geometry and render them\n            Ri.Comment('Tesselating %d primitives (pass: %d)' %\n                        (unsaved[0].globalValue('geo:primcount')[0], i+1));\n            glist = []\n            for g in unsaved:\n                t = g.tesselate({})\n                if not t:\n                    return\n                glist.append(t)\n            unsaved = _saveRiPrimitives(glist, blocks, times, control)\n            i += 1\n\ndef outputAttributes(shoppath, now, control, overrides):\n    shop = soho.getObject(control.getShopPath(shoppath))\n    if shop:\n        over = soho.PropertyOverride(overrides)\n        # Output a user attribute for identifier rather than using the\n        # name of the SHOP as the identifier.  The identifier is the\n        # name of the object (which has the SOP)\n        LSDsettings.outputAttributes(shop, now, name_class='user')\n        control.setParameters(shop, now)\n\ndef createResource(shoppath, now, control, overrides):\n    shop = soho.getObject(control.getShopPath(shoppath))\n    name = None\n    if shop:\n        saveparms = RiParmList()\n        saveparms.addParmValue(\"operation\", \"string\", [\"save\"])\n        over = soho.PropertyOverride(overrides)\n        Ri.AttributeBegin()\n        LSDsettings.outputAttributes(shop, now, name_class='user')\n        name = shop.getName()\n        Ri.Resource(name, \"attributes\", saveparms)\n        Ri.AttributeEnd()\n    return name\n\ndef partitionHierarchicalSubD(glist):\n    # Split the list of geometries into a dictionary which contains two lists\n    #   { 'ClosedPoly' : [], 'NonPoly' : [] }\n    # Where the 'ClosedPoly' contains polygons and the non-poly contains\n    # everything else.\n    splits = {}\n    for geo in glist:\n        parts = geo.partition('geo:partlist', groupPolygons(geo))\n        for key in parts:\n            list = splits.get(key, None)\n            if not list:\n                # This is the first time we've seen the key, so,\n                # this must be the first segment.  We create a\n                # list of the geometry.\n                splits[key] = [parts[key]]\n            else:\n                list.append(parts[key])\n    return splits\n\ndef partitionMaterial(glist, attrib_name):\n    # Given a list of geometries (one for each motion segment) and an\n    # attribute name.  Return a dictionary of geometry lists, each\n    # list which has the same string value.\n    #\n    # This is used to partition the geometry by material attributes\n    # into groups of primitives which fit into an individual attribute\n    # block.\n    #\n    attr = glist[0].attribute('geo:prim', attrib_name)\n    if attr >= 0:\n        splits = {}\n        for geo in glist:\n            # For each motion segment, partition the geometry based on\n            # the string attribute value.\n            # This returns a dictionary, each key is the attribute\n            # value, each entry has the geometry which has that\n            # string value assigned.\n            parts = geo.partition('geo:partattrib', attrib_name)\n            for key in parts:\n                list = splits.get(key, None)\n                if not list:\n                    # This is the first time we've seen the key, so,\n                    # this must be the first segment.  We create a\n                    # list of the geometry.\n                    splits[key] = [parts[key]]\n                else:\n                    # Add the next motion segment to the list\n                    list.append(parts[key])\n    else:\n        splits = { \"\":glist }\n    return splits\n\ndef saveGeometry(glist, blocks, times, src_control):\n    if src_control.RenderHSubD and LSDsettings.getFeature('HierarchicalSubdivisionMesh'):\n        # When we are able to use HierarchicalSubdivisionMesh primitives, we\n        # can properly handle material changes over the sub-d mesh by using\n        # resources and face edits.\n        splits = partitionHierarchicalSubD(glist)\n        polys = splits.get('ClosedPoly', None)\n        others = splits.get('NonPoly', None)\n        if polys:\n            outputHierarchicalSubd(polys, blocks, times, src_control)\n        if not others:\n            return\n        # Replace glist with the other primitives\n        glist = others\n\n    # Check for properties bound to the detail\n    detailprop = glist[0].attribute('geo:global', 'shop_materialpath')\n    primprop = glist[0].attribute('geo:prim', 'shop_materialpath')\n\n    # Split the primitives into material groups\n    mgroups = partitionMaterial(glist, 'shop_materialpath')\n    if detailprop >= 0 or len(mgroups) > 1:\n        Ri.AttributeBegin()\n        Ri.AttributeIdentifier(src_control.HouObject.path())\n    control = src_control.copy()\n    if detailprop >= 0:\n        proppath = glist[0].attribProperty(detailprop, 'geo:allstrings')\n        if len(proppath) > 0:\n            detailover = glist[0].attribute('geo:global', 'material_override')\n            odict = None\n            if detailover >= 0:\n                ogeo = glist[0].attribProperty(detailover, 'geo:allstrings')\n                if len(ogeo) > 0:\n                    odict = eval(ogeo[0])\n            Ri.AttributeBegin()\n            outputAttributes(proppath[0], times[0], control, odict)\n        else:\n            detailprop = -1\n\n    for matname in mgroups:\n        mgeo = mgroups[matname] # All primitives that have the material assigned\n        # Now, partition based on the material_override\n        ogroups = partitionMaterial(mgeo, 'material_override')\n        for over in ogroups:\n            # Find all the common overrides\n            ogeo = ogroups[over]\n            if matname:\n                try:\n                    overdict = eval(over)\n                except:\n                    overdict = None\n                Ri.AttributeBegin()\n                primcontrol = control.copy()\n                outputAttributes(matname, times[0], primcontrol, overdict)\n                savePrimitives(ogeo, blocks, times, primcontrol)\n                Ri.AttributeEnd()\n            else:\n                # No attribute block -- inherit the object attributes\n                savePrimitives(ogeo, blocks, times, control)\n    if detailprop >= 0:\n        Ri.AttributeEnd()\n    if detailprop >= 0 or len(mgroups) > 1:\n        Ri.AttributeEnd()\n",
			"file": "contrib/houdini/soho/LSDsohogeo.py",
			"file_size": 90040,
			"file_write_time": 132434583714599804,
			"settings":
			{
				"buffer_size": 90040,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/lava_cmd/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 1270,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/lava_cmd/bin/lava",
			"settings":
			{
				"buffer_size": 335,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/lava_cmd/bin/app_init.sh",
			"settings":
			{
				"buffer_size": 274,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/houdini/ropLava/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 464,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "#project( My_HDK_Project )"
			}
		},
		{
			"file": "src/houdini/soho/LSD.py",
			"settings":
			{
				"buffer_size": 22594,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/houdini/soho/LSDapi.py",
			"settings":
			{
				"buffer_size": 8206,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/houdini/soho/LSDframe.py",
			"settings":
			{
				"buffer_size": 64676,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/houdini/soho/LSDmisc.py",
			"settings":
			{
				"buffer_size": 15491,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/houdini/soho/LSDsettings.py",
			"settings":
			{
				"buffer_size": 31540,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/houdini/soho/LSDgeo.py",
			"settings":
			{
				"buffer_size": 40221,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/houdini/soho/LSDhooks.py",
			"settings":
			{
				"buffer_size": 1873,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "/opt/hfs17.5.460/houdini/soho/python2.7/IFD.py",
			"settings":
			{
				"buffer_size": 22594,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/opt/hfs17.5.460/houdini/soho/python2.7/IFDmisc.py",
			"settings":
			{
				"buffer_size": 15491,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/houdini/soho/LSDmantra.py",
			"settings":
			{
				"buffer_size": 21971,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "/opt/hfs17.5.460/houdini/soho/python2.7/IFDapi.py",
			"settings":
			{
				"buffer_size": 8206,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/opt/hfs17.5.460/houdini/soho/python2.7/IFDframe.py",
			"settings":
			{
				"buffer_size": 64638,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/opt/hfs17.5.460/houdini/soho/python2.7/IFDsettings.py",
			"settings":
			{
				"buffer_size": 31540,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/houdini/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 355,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 457,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/houdini/ropLava/ROP_Lava.h",
			"settings":
			{
				"buffer_size": 3542,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "#ifndef __ROP_Xenon_h__"
			}
		},
		{
			"file": "src/houdini/ropLava/ROP_Lava.cpp",
			"settings":
			{
				"buffer_size": 14145,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "#include \"ROP_Xenon.h\""
			}
		},
		{
			"file": "src/lava_lib/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 3754,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/lava_lib/readers/reader_lsd.cpp",
			"settings":
			{
				"buffer_size": 1743,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/lava_lib/readers/grammar_bgeo.h",
			"settings":
			{
				"buffer_size": 6414,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/lava_lib/readers/grammar_lsd.h",
			"settings":
			{
				"buffer_size": 21928,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/lava_lib/readers/backtracking.h",
			"settings":
			{
				"buffer_size": 1000,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "/opt/lava/test/simple_inline_ascii.lsd",
			"settings":
			{
				"buffer_size": 201,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "/opt/lava/test/test_ascii.lsd",
			"settings":
			{
				"buffer_size": 3912,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/opt/lava/test/lava.lsd",
			"settings":
			{
				"buffer_size": 3518,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "/opt/lava/test/test_inline_binary.lsd",
			"settings":
			{
				"buffer_size": 25330,
				"encoding": "Western (Windows 1252)",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/lava_lib/LSD.g4",
			"settings":
			{
				"buffer_size": 2123,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#include \"renderer_iface_lsd.h\"\n\n\nnamespace lava {\n\nRendererIfaceLSD::SharedPtr RendererIfaceLSD::create() {\n\treturn RendererIfaceLSD::SharedPtr( new RendererIfaceLSD());\n}\n\nRendererIfaceLSD::RendererIfaceLSD() {\n\n}\n\n}  // namespace lava",
			"file": "src/lava_lib/loaders/renderer_iface_lsd.cpp",
			"file_size": 237,
			"file_write_time": 132434766636936686,
			"settings":
			{
				"buffer_size": 237,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#ifndef SRC_LAVA_LIB_LOADER_BASE_H_\n#define SRC_LAVA_LIB_LOADER_BASE_H_\n\n#include <cstddef>\n#include <string>\n#include <vector>\n#include <memory>\n#include <iostream>\n\nnamespace lava {\n\nclass LoaderBase: public std::enable_shared_from_this<LoaderBase> {\n public:\n \tusing SharedPtr = std::shared_ptr<LoaderBase>;\n\n \tLoaderBase() {};\n \tvoid read(const std::string& filename, bool echo=false); // read from file\n \tvoid read(bool echo=false); // read from stdin\n\n private:\n \tvirtual void parseLine(const std::string& line) = 0;\n\n};\n\n}  // namespace lava\n\n#endif  // SRC_LAVA_LIB_LOADER_BASE_H_\n",
			"file": "src/lava_lib/loaders/loader_base.h",
			"file_size": 589,
			"file_write_time": 132434753687832102,
			"settings":
			{
				"buffer_size": 589,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#include <vector>\n#include <fstream>\n\n#include \"loader_base.h\"\n\n\nnamespace lava {\n\nvoid LoaderBase::read(const std::string& filename, bool echo) {\n\tstd::ifstream infile(filename);\n\tif (!infile) {\n\t\tstd::cerr << \"Unable to read scene file: \" << filename << std::endl;\n\t\treturn;\n\t}\n\n\tstd::string line;\n\twhile (std::getline(infile, line))\t{\n    \tif (echo) std::cout << line << std::endl;\n    \tparseLine(line);\n    }\n}\n\nvoid LoaderBase::read(bool echo) {\n\tstd::string line;\n\n\twhile(std::getline(std::cin, line)) {\n\t\tif (echo) std::cout << line << std::endl;\n    \tparseLine(line);\n    }\n}\n\n}  // namespace lava",
			"file": "src/lava_lib/loaders/loader_base.cpp",
			"file_size": 605,
			"file_write_time": 132434724153487614,
			"settings":
			{
				"buffer_size": 605,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/ri_display/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 681,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "set (SOURCES"
			}
		},
		{
			"file": "src/lava_cmd/lava_cmd.cpp",
			"settings":
			{
				"buffer_size": 6608,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "#include <fstream>"
			}
		},
		{
			"contents": "#ifndef SRC_LAVA_LIB_READER_LSD_H_\n#define SRC_LAVA_LIB_READER_LSD_H_\n\n#include <string>\n#include <vector>\n#include <iostream>\n#include <fstream>\n\n#include <boost/spirit.hpp>\n\n#include \"../scene_reader_base.h\"\n\n\nnamespace lava {}\n\nstatic std::vector<std::string> _lsd_extensions = {\".lsd\",\".lsd.gz\",\".lsd.zip\"};\n\nclass ReaderLSD : public ReaderBase {\n  public:\n    ReaderLSD();\n    ~ReaderLSD();\n\n    const char*\t\t\tformatName() const;\n    int                 checkExtension(const char *name);\n\n    void                getFileExtensions(std::vector<std::string> &extensions) const;\n\n    // Method to check if the given magic number matches the magic number. Return true on a match.\n    int                 checkMagicNumber(unsigned magic);\n\n    SCN_Scene::IOStatus fileLoad(SCN_Scene &scn, std::istream &in, bool ate_magic) override;\n\n public:\n \t// factory methods\n    static ReaderBase* \t\t\t\t\tmyConstructor();\n    static std::vector<std::string>*\tmyExtensions();\n};\n\n}  // namespace lava\n\n#endif  // SRC_LAVA_LIB_READER_LSD_H_",
			"file": "src/lava_lib/loaders/reader_lsd.h",
			"file_size": 1025,
			"file_write_time": 132435542861571741,
			"settings":
			{
				"buffer_size": 1025,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#include <boost/log/core.hpp>\n#include <boost/log/trivial.hpp>\n#include <boost/log/expressions.hpp>\n\n#include <string>\n#include <iostream>\n#include <sstream>\n\n#include <locale>\n#include <codecvt>\n\n#include \"antlr4-runtime.h\"\n#include \"readers/generated/LSDLexer.h\"\n#include \"readers/generated/LSDParser.h\"\n#include \"readers/generated/LSDBaseListener.h\"\n#include \"readers/generated/LSDBaseVisitor.h\"\n\n#include \"BinaryAntlrInputStream.h\"\n#include \"reader_lsd.h\"\n\nusing namespace shout;\nusing namespace antlr4;\n\n\nnamespace lava {\n\nclass LSDFileVisitor : public LSDBaseVisitor {\npublic:\n  virtual antlrcpp::Any visitSetenv(IFDParser::SetenvContext *ctx) override {\n    std::cout << \"visitSetenv: \" << ctx->VAR_NAME()->getText() << std::endl;\n    return visitChildren(ctx);\n  }\n\n  virtual antlrcpp::Any visitVersion(IFDParser::VersionContext *ctx) override {\n    std::cout << \"visitVersion\" << std::endl;\n    return visitChildren(ctx);\n  }\n\n  virtual antlrcpp::Any visitDetail(IFDParser::DetailContext *ctx) override {\n    std::cout << \"visitDetail\" << std::endl;\n    return visitChildren(ctx);\n  }\n\n  virtual antlrcpp::Any visitImage(IFDParser::ImageContext *ctx) override {\n    std::cout << \"visitImage\" << std::endl;\n    return visitChildren(ctx);\n  }\n\n  virtual antlrcpp::Any visitDeclare(IFDParser::DeclareContext *ctx) override {\n    std::cout << \"visitDeclare\" << std::endl;\n    return visitChildren(ctx);\n  }\n\n  virtual antlrcpp::Any visitStart(IFDParser::StartContext *ctx) override {\n    std::cout << \"visitStart\" << std::endl;\n    return visitChildren(ctx);\n  }\n\n  virtual antlrcpp::Any visitEnd(IFDParser::EndContext *ctx) override {\n    std::cout << \"visitEnd\" << std::endl;\n    return visitChildren(ctx);\n  }\n\n  virtual antlrcpp::Any visitBgeo(IFDParser::BgeoContext *ctx) override {\n    std::cout << \"visitBgeo:\" << ctx->getText() << std::endl;\n    return visitChildren(ctx);\n  }\n\n  virtual antlrcpp::Any visitTime(IFDParser::TimeContext *ctx) override {\n    std::cout << \"visitTime\" << std::endl;\n    return visitChildren(ctx);\n  }\n};\n\nReaderLSD::ReaderLSD() {\n  BOOST_LOG_TRIVIAL(debug) << \"LSD file reader constructed!\";\n}\n\n\nReaderLSD::~ReaderLSD() {\n  BOOST_LOG_TRIVIAL(debug) << \"LSD file reader destructed!\";\n}\n\n\nconst char *ReaderLSD::formatName() const{\n    return \"Lava LSD\";\n}\n\n\nbool ReaderLSD::checkExtension(const char *name) {\n    if (strcmp(name, \".lsd\")) return true;\n    return false;\n}\n\n\nvoid ReaderLSD::getFileExtensions(std::vector<std::string> &extensions) const{\n    extensions.insert(extensions.end(), _ifd_extensions.begin(), _ifd_extensions.end());\n}\n\n\nint ReaderLSD::checkMagicNumber(unsigned magic) {\n    return 0;\n}\n\n\nSCN_Scene::IOStatus ReaderLSD::fileLoad(SCN_Scene &scn, std::istream &in, bool ate_magic) {\n  //BinaryANTLRInputStream input(in);\n  antlr4::ANTLRInputStream input(in);\n  std::cout << \"stream yes\\n\";\n\n  IFDLexer lexer(&input);\n  std::cout << \"lexer yes\\n\";\n\n  antlr4::CommonTokenStream tokens(&lexer);\n\n  IFDParser parser(&tokens);\n\n  std::cout << \"ReaderLSD::fileLoad.. parser.file()\" << std::endl;\n  //antlr4::tree::ParseTree* tree  = parser.file();\n  IFDParser::FileContext* tree = parser.file();\n\n  //IFDFileListener listener;\n  //std::cout << \"ReaderLSD::fileLoad.. DEFAULT.walk()\" << std::endl;\n  //antlr4::tree::ParseTreeWalker::DEFAULT.walk(&listener, tree);\n\n  IFDFileVisitor visitor;\n  std::cout << \"ReaderLSD::fileLoad.. visitor.visitFile(tree)\" << std::endl;\n  visitor.visitFile(tree);\n\n  return true;\n}\n\n\n// factory methods\n\nstd::vector<std::string> *ReaderLSD::myExtensions() {\n    return &_ifd_extensions;\n}\n\n\n\nReaderBase::SharedPtr *ReaderLSD::myConstructor() {\n    return ReaderBase::SharedPtr(new ReaderLSD());\n}\n}  // namespace lava",
			"file": "src/lava_lib/loaders/reader_lsd.cpp",
			"file_size": 3705,
			"file_write_time": 132435544699225987,
			"settings":
			{
				"buffer_size": 3705,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/ri_display/d_houdini.C",
			"settings":
			{
				"buffer_size": 32420,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/lava_lib/scene_readers_registry.h",
			"settings":
			{
				"buffer_size": 909,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/lava_lib/scene_reader_base.h",
			"settings":
			{
				"buffer_size": 1036,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "#ifndef __SCN_IOTranslator_h__"
			}
		},
		{
			"file": "src/lava_lib/readers/reader_lsd.h",
			"settings":
			{
				"buffer_size": 1252,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n#pragma once\n\n#include \"antlr4-runtime.h\"\n\nnamespace lava {\n\n  /// Do not buffer up the entire char stream. It does keep a small buffer\n  /// for efficiency and also buffers while a mark exists (set by the\n  /// lookahead prediction in parser). \"Unbuffered\" here refers to fact\n  /// that it doesn't buffer all data, not that's it's on demand loading of char.\n  class  InputStream : public antlr4::CharStream {\n  public:\n    /// The name or source of this char stream.\n    std::string name;\n\n    InputStream(std::wistream &input);\n\n    virtual void consume() override;\n    virtual size_t LA(ssize_t i) override;\n\n    /// <summary>\n    /// Return a marker that we can release later.\n    /// <p/>\n    /// The specific marker value used for this class allows for some level of\n    /// protection against misuse where {@code seek()} is called on a mark or\n    /// {@code release()} is called in the wrong order.\n    /// </summary>\n    virtual ssize_t mark() override;\n\n    /// <summary>\n    /// Decrement number of markers, resetting buffer if we hit 0. </summary>\n    /// <param name=\"marker\"> </param>\n    virtual void release(ssize_t marker) override;\n    virtual size_t index() override;\n\n    /// <summary>\n    /// Seek to absolute character index, which might not be in the current\n    ///  sliding window.  Move {@code p} to {@code index-bufferStartIndex}.\n    /// </summary>\n    virtual void seek(size_t index) override;\n    virtual size_t size() override;\n    virtual std::string getSourceName() const override;\n    virtual std::string getText(const antlr4::misc::Interval &interval) override;\n\n  protected:\n    /// A moving window buffer of the data being scanned. While there's a marker,\n    /// we keep adding to buffer. Otherwise, <seealso cref=\"#consume consume()\"/> resets so\n    /// we start filling at index 0 again.\n    // UTF-32 encoded.\n#if defined(_MSC_VER) && _MSC_VER == 1900\n    i32string _data; // Custom type for VS 2015.\n    typedef __int32 storage_type;\n#else\n    std::u32string _data;\n    typedef char32_t storage_type;\n#endif\n\n    /// <summary>\n    /// 0..n-1 index into <seealso cref=\"#data data\"/> of next character.\n    /// <p/>\n    /// The {@code LA(1)} character is {@code data[p]}. If {@code p == n}, we are\n    /// out of buffered characters.\n    /// </summary>\n    size_t _p;\n\n    // real data pointer. points to latest character read from input\n    size_t _rp;\n\n    /// <summary>\n    /// Count up with <seealso cref=\"#mark mark()\"/> and down with\n    /// <seealso cref=\"#release release()\"/>. When we {@code release()} the last mark,\n    /// {@code numMarkers} reaches 0 and we reset the buffer. Copy\n    /// {@code data[p]..data[n-1]} to {@code data[0]..data[(n-1)-p]}.\n    /// </summary>\n    size_t _numMarkers;\n\n    /// This is the {@code LA(-1)} character for the current position.\n    size_t _lastChar; // UTF-32\n\n    /// <summary>\n    /// When {@code numMarkers > 0}, this is the {@code LA(-1)} character for the\n    /// first character in <seealso cref=\"#data data\"/>. Otherwise, this is unspecified.\n    /// </summary>\n    size_t _lastCharBufferStart; // UTF-32\n\n    /// <summary>\n    /// Absolute character index. It's the index of the character about to be\n    /// read via {@code LA(1)}. Goes from 0 to the number of characters in the\n    /// entire stream, although the stream size is unknown before the end is\n    /// reached.\n    /// </summary>\n    size_t _currentCharIndex;\n\n    std::wistream &_input;\n\n    /// <summary>\n    /// Make sure we have 'want' elements from current position <seealso cref=\"#p p\"/>.\n    /// Last valid {@code p} index is {@code data.length-1}. {@code p+need-1} is\n    /// the char index 'need' elements ahead. If we need 1 element,\n    /// {@code (p+1-1)==p} must be less than {@code data.length}.\n    /// </summary>\n    virtual void sync(size_t want);\n\n    /// <summary>\n    /// Add {@code n} characters to the buffer. Returns the number of characters\n    /// actually added to the buffer. If the return value is less than {@code n},\n    /// then EOF was reached before {@code n} characters could be added.\n    /// </summary>\n    virtual size_t fill(size_t n);\n\n    /// Override to provide different source of characters than\n    /// <seealso cref=\"#input input\"/>.\n    virtual char32_t nextChar();\n    virtual void add(char32_t c);\n    size_t getBufferStartIndex() const;\n\n    virtual std::string toString() const override;\n\n    size_t _size;\n\n  private:\n    void InitializeInstanceFields();\n  };\n\n} // namespace antlr4",
			"file": "src/lava_lib/readers/input_stream.h.bak",
			"file_size": 4694,
			"file_write_time": 132438107075305532,
			"settings":
			{
				"buffer_size": 4694,
				"line_ending": "Unix",
				"name": "/* Copyright (c) 2012-2017 The ANTLR Project. All"
			}
		},
		{
			"contents": "/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n//#include \"misc/Interval.h\"\n//#include \"Exceptions.h\"\n//#include \"support/StringUtils.h\"\n\n#include \"input_stream.h\"\n\nusing namespace antlrcpp;\nusing namespace antlr4;\nusing namespace antlr4::misc;\n\nnamespace lava {\n\nInputStream::InputStream(std::wistream &input) : _input(input), _size(0) {\n  InitializeInstanceFields();\n\n  // The vector's size is what used to be n in Java code.\n  fill(1); // prime\n}\n\nvoid InputStream::consume() {\n  std::cout << \"consume at:\" << _p << \" _lastChar:\" << antlrcpp::utf32_to_utf8(_data[_p]) << \"\\n\";\n  if (LA(1) == EOF) {\n    throw IllegalStateException(\"cannot consume EOF\");\n  }\n\n  // buf always has at least data[p==0] in this method due to ctor\n  _lastChar = _data[_p]; // track last char for LA(-1)\n\n  if (_p == _data.size() - 1 && _numMarkers == 0) {\n    size_t capacity = _data.capacity();\n    _data.clear();\n    _data.reserve(capacity);\n\n    _p = 0;\n    _lastCharBufferStart = _lastChar;\n  } else {\n    _p++;\n  }\n\n  _currentCharIndex++;\n  sync(1);\n}\n\nvoid InputStream::sync(size_t want) {\n  std::cout << \"sync: \" << want << \"\\n\";\n  if (_p + want <= _data.size()) // Already enough data loaded?\n    //std::cout << \"sync abort: _p: \" << _p << \" data.size: \" << _data.size() << \"\\n\";\n    std::cout << \"sync force: _p: \" << _p << \" data.size: \" << _data.size() << \"\\n\";\n    fill(want);\n    return;\n\n  fill(_p + want - _data.size());\n  //fill(want);\n}\n\nsize_t InputStream::fill(size_t n) {\n  std::cout <<\"fill: \" << n << \"\\n\";\n  for (size_t i = 0; i < n; i++) {\n    if (_data.size() > 0 && _data.back() == 0xFFFF) {\n      return i;\n    }\n\n    //if (_data.size() > 0 && _data.back() == 0) {\n    //  return i;\n    //}\n    if(_input.eof())\n      return 0;\n\n    try {\n      char c = nextChar();\n      add(c);\n#if defined(_MSC_FULL_VER) && _MSC_FULL_VER < 190023026\n    } catch (IOException &ioe) {\n      // throw_with_nested is not available before VS 2015.\n      throw ioe;\n#else\n    } catch (IOException & /*ioe*/) {\n      std::throw_with_nested(RuntimeException());\n#endif\n    }\n  }\n\n  return n;\n}\n\nchar32_t InputStream::nextChar()  {\n  wchar_t result = 0;\n  _input >> result;\n  _size++;\n  std::wcout << \"---\\n\" << result << \"\\n---\\n\";\n  return result;\n}\n\nvoid InputStream::add(char32_t c) {\n  _data += c;\n}\n\nsize_t InputStream::LA(ssize_t i) {\n  if (i == -1) { // special case\n    std::cout << \"LA: \" << i << \"\\n\";\n    return _lastChar;\n  }\n\n  // We can look back only as many chars as we have buffered.\n  ssize_t index = static_cast<ssize_t>(_p) + i - 1;\n  std::cout << \"LA: \" << i << \"index: \" << index <<\"\\n\";\n  if (index < 0) {\n    throw IndexOutOfBoundsException();\n  }\n\n  if (i > 0) {\n    sync(static_cast<size_t>(i)); // No need to sync if we look back.\n  }\n\n  if (static_cast<size_t>(index) >= _data.size()) {\n    return EOF;\n  }\n\n  if (_data[static_cast<size_t>(index)] == 0xFFFF) {\n    return EOF;\n  }\n\n  //if (_data[static_cast<size_t>(index)] == 0) {\n  // return EOF;\n  //}\n  std::cout << \"LA _data: \" << antlrcpp::utf32_to_utf8(_data[static_cast<size_t>(index)]) << \"\\n\";\n  return _data[static_cast<size_t>(index)];\n}\n\nssize_t InputStream::mark() {\n  if (_numMarkers == 0) {\n    _lastCharBufferStart = _lastChar;\n  }\n\n  ssize_t mark = -static_cast<ssize_t>(_numMarkers) - 1;\n  _numMarkers++;\n  std::cout << \"mark: \" << mark << \"\\n\";\n  return mark;\n}\n\nvoid InputStream::release(ssize_t marker) {\n  std::cout << \"release: \" << marker << \"\\n\";\n  ssize_t expectedMark = -static_cast<ssize_t>(_numMarkers);\n  if (marker != expectedMark) {\n    throw IllegalStateException(\"release() called with an invalid marker.\");\n  }\n\n  _numMarkers--;\n  if (_numMarkers == 0 && _p > 0) {\n    _data.erase(0, _p);\n    _p = 0;\n    _lastCharBufferStart = _lastChar;\n  }\n}\n\nsize_t InputStream::index() {\n  return _currentCharIndex;\n}\n\nvoid InputStream::seek(size_t index) {\n  std::cout << \"\\nseek: \" << index << \"\\n\";\n  if (index == _currentCharIndex) {\n    return;\n  }\n\n  if (index > _currentCharIndex) {\n    sync(index - _currentCharIndex);\n    index = std::min(index, getBufferStartIndex() + _data.size() - 1);\n  }\n\n  // index == to bufferStartIndex should set p to 0\n  ssize_t i = static_cast<ssize_t>(index) - static_cast<ssize_t>(getBufferStartIndex());\n  if (i < 0) {\n    throw IllegalArgumentException(std::string(\"cannot seek to negative index \") + std::to_string(index));\n  } else if (i >= static_cast<ssize_t>(_data.size())) {\n    throw UnsupportedOperationException(\"Seek to index outside buffer: \" + std::to_string(index) +\n                                        \" not in \" + std::to_string(getBufferStartIndex()) + \"..\" +\n                                        std::to_string(getBufferStartIndex() + _data.size()));\n  }\n\n  _p = static_cast<size_t>(i);\n  _currentCharIndex = index;\n  if (_p == 0) {\n    _lastChar = _lastCharBufferStart;\n  } else {\n    _lastChar = _data[_p - 1];\n  }\n}\n\nsize_t InputStream::size() {\n  //throw UnsupportedOperationException(\"Unbuffered stream cannot know its size\");\n  std::cout << \"\\nsize: \" << _size << \"\\n\";\n  return _size;\n}\n\nstd::string InputStream::getSourceName() const {\n  if (name.empty()) {\n    return UNKNOWN_SOURCE_NAME;\n  }\n\n  return name;\n}\n\nstd::string InputStream::getText(const misc::Interval &interval) {\n  std::cout << \"getText: \" << interval.a << \" \" << interval.b << \"\\n\";\n  if (interval.a < 0 || interval.b >= interval.a - 1) {\n    throw IllegalArgumentException(\"invalid interval\");\n  }\n\n  size_t bufferStartIndex = getBufferStartIndex();\n  if (!_data.empty() && _data.back() == 0xFFFF) {\n    if (interval.a + interval.length() > bufferStartIndex + _data.size()) {\n      throw IllegalArgumentException(\"the interval extends past the end of the stream\");\n    }\n  }\n\n  if (interval.a < static_cast<ssize_t>(bufferStartIndex) || interval.b >= ssize_t(bufferStartIndex + _data.size())) {\n    throw UnsupportedOperationException(\"interval \" + interval.toString() + \" outside buffer: \" +\n      std::to_string(bufferStartIndex) + \"..\" + std::to_string(bufferStartIndex + _data.size() - 1));\n  }\n  // convert from absolute to local index\n  size_t i = interval.a - bufferStartIndex;\n  return utf32_to_utf8(_data.substr(i, interval.length()));\n}\n\nsize_t InputStream::getBufferStartIndex() const {\n  return _currentCharIndex - _p;\n}\n\nstd::string InputStream::toString() const {\n  return antlrcpp::utf32_to_utf8(_data);\n}\n\nvoid InputStream::InitializeInstanceFields() {\n  _p = 0;\n  _rp = 0;\n  _numMarkers = 0;\n  _lastChar = 0;\n  _lastCharBufferStart = 0;\n  _currentCharIndex = 0;\n}\n\n}  // namespace lava",
			"file": "src/lava_lib/readers/input_stream.cpp.bak",
			"file_size": 6683,
			"file_write_time": 132438107190903628,
			"settings":
			{
				"buffer_size": 6683,
				"line_ending": "Unix",
				"name": "/* Copyright (c) 2012-2017 The ANTLR Project. All"
			}
		},
		{
			"contents": "/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n//#include \"misc/Interval.h\"\n//#include \"Exceptions.h\"\n//#include \"support/StringUtils.h\"\n\n#include \"input_stream.h\"\n\nusing namespace antlrcpp;\nusing namespace antlr4;\nusing namespace antlr4::misc;\n\nnamespace lava {\n\nInputStream::InputStream(std::wistream &input) : _input(input), _size(0) {\n  InitializeInstanceFields();\n\n  // The vector's size is what used to be n in Java code.\n  fill(1); // prime\n}\n\nvoid InputStream::consume() {\n  if (LA(1) == EOF) {\n    throw IllegalStateException(\"cannot consume EOF\");\n  }\n\n  // buf always has at least data[p==0] in this method due to ctor\n  _lastChar = _data[_p]; // track last char for LA(-1)\n\n  if (_p == _data.size() - 1 && _numMarkers == 0) {\n    size_t capacity = _data.capacity();\n    _data.clear();\n    _data.reserve(capacity);\n\n    _p = 0;\n    _lastCharBufferStart = _lastChar;\n  } else {\n    _p++;\n  }\n\n  _currentCharIndex++;\n  sync(1);\n}\n\nvoid InputStream::sync(size_t want) {\n  if (_p + want <= _data.size()) // Already enough data loaded?\n    //fill(want);\n    return;\n\n  fill(_p + want - _data.size());\n  //fill(want);\n}\n\nsize_t InputStream::fill(size_t n) {\n  for (size_t i = 0; i < n; i++) {\n    if (_data.size() > 0 && _data.back() == 0xFFFF) {\n      return i;\n    }\n\n    try {\n      char c = nextChar();\n      add(c);\n#if defined(_MSC_FULL_VER) && _MSC_FULL_VER < 190023026\n    } catch (IOException &ioe) {\n      // throw_with_nested is not available before VS 2015.\n      throw ioe;\n#else\n    } catch (IOException & /*ioe*/) {\n      std::throw_with_nested(RuntimeException());\n#endif\n    }\n  }\n\n  return n;\n}\n\nchar32_t InputStream::nextChar()  {\n  wchar_t result = 0;\n  //_input >> result;\n  try {\n    result = _input.get();\n  } catch (std::wistream::failure e) {\n    //if (_input.eof()){\n    //  std::cout << \"E_O_F\\n\";\n    //}\n    return EOF;\n  }\n\n  _size++;\n  return result;\n}\n\nvoid InputStream::add(char32_t c) {\n  _data += c;\n}\n\nsize_t InputStream::LA(ssize_t i) {\n  if (i == -1) { // special case\n    return _lastChar;\n  }\n\n  // We can look back only as many chars as we have buffered.\n  ssize_t index = static_cast<ssize_t>(_p) + i - 1;\n  if (index < 0) {\n    throw IndexOutOfBoundsException();\n  }\n\n  if (i > 0) {\n    sync(static_cast<size_t>(i)); // No need to sync if we look back.\n  }\n\n  if (static_cast<size_t>(index) >= _data.size()) {\n    return EOF;\n  }\n\n  if (_data[static_cast<size_t>(index)] == 0xFFFF) {\n    return EOF;\n  }\n\n  if (_data[static_cast<size_t>(index)] == -1) {\n    return EOF;\n  }\n\n  return _data[static_cast<size_t>(index)];\n}\n\nssize_t InputStream::mark() {\n  if (_numMarkers == 0) {\n    _lastCharBufferStart = _lastChar;\n  }\n\n  ssize_t mark = -static_cast<ssize_t>(_numMarkers) - 1;\n  _numMarkers++;\n  return mark;\n}\n\nvoid InputStream::release(ssize_t marker) {\n  ssize_t expectedMark = -static_cast<ssize_t>(_numMarkers);\n  if (marker != expectedMark) {\n    throw IllegalStateException(\"release() called with an invalid marker.\");\n  }\n\n  _numMarkers--;\n  if (_numMarkers == 0 && _p > 0) {\n    _data.erase(0, _p);\n    _p = 0;\n    _lastCharBufferStart = _lastChar;\n  }\n}\n\nsize_t InputStream::index() {\n  return _currentCharIndex;\n}\n\nvoid InputStream::seek(size_t index) {\n  if (index == _currentCharIndex) {\n    return;\n  }\n\n  if (index > _currentCharIndex) {\n    sync(index - _currentCharIndex);\n    index = std::min(index, getBufferStartIndex() + _data.size() - 1);\n  }\n\n  // index == to bufferStartIndex should set p to 0\n  ssize_t i = static_cast<ssize_t>(index) - static_cast<ssize_t>(getBufferStartIndex());\n  if (i < 0) {\n    throw IllegalArgumentException(std::string(\"cannot seek to negative index \") + std::to_string(index));\n  } else if (i >= static_cast<ssize_t>(_data.size())) {\n    throw UnsupportedOperationException(\"Seek to index outside buffer: \" + std::to_string(index) +\n                                        \" not in \" + std::to_string(getBufferStartIndex()) + \"..\" +\n                                        std::to_string(getBufferStartIndex() + _data.size()));\n  }\n\n  _p = static_cast<size_t>(i);\n  _currentCharIndex = index;\n  if (_p == 0) {\n    _lastChar = _lastCharBufferStart;\n  } else {\n    _lastChar = _data[_p - 1];\n  }\n}\n\nsize_t InputStream::size() {\n  //throw UnsupportedOperationException(\"Unbuffered stream cannot know its size\");\n  return _size;\n}\n\nstd::string InputStream::getSourceName() const {\n  if (name.empty()) {\n    return UNKNOWN_SOURCE_NAME;\n  }\n\n  return name;\n}\n\nstd::string InputStream::getText(const misc::Interval &interval) {\n  //if (interval.a < 0 || interval.b >= interval.a - 1) {\n  if (interval.a < 0 || interval.b <= interval.a - 1) {\n    throw IllegalArgumentException(\"invalid interval\");\n  }\n\n  size_t bufferStartIndex = getBufferStartIndex();\n  if (!_data.empty() && _data.back() == 0xFFFF) {\n    if (interval.a + interval.length() > bufferStartIndex + _data.size()) {\n      throw IllegalArgumentException(\"the interval extends past the end of the stream\");\n    }\n  }\n\n  if (interval.a < static_cast<ssize_t>(bufferStartIndex) || interval.b >= ssize_t(bufferStartIndex + _data.size())) {\n    throw UnsupportedOperationException(\"interval \" + interval.toString() + \" outside buffer: \" +\n      std::to_string(bufferStartIndex) + \"..\" + std::to_string(bufferStartIndex + _data.size() - 1));\n  }\n  // convert from absolute to local index\n  size_t i = interval.a - bufferStartIndex;\n  std::cout << \"i: \" << i << \"\\n\";\n  //if (interval.a == interval.b)\n  //  return utf32_to_utf8(_data[i]);\n  return utf32_to_utf8(_data.substr(i, interval.length()));\n}\n\nsize_t InputStream::getBufferStartIndex() const {\n  return _p - _data.size();\n}\n\nstd::string InputStream::toString() const {\n  return antlrcpp::utf32_to_utf8(_data);\n}\n\nvoid InputStream::InitializeInstanceFields() {\n  _p = 0;\n  _numMarkers = 0;\n  _lastChar = 0;\n  _lastCharBufferStart = 0;\n  _currentCharIndex = 0;\n}\n\n}  // namespace lava",
			"file": "src/lava_lib/readers/input_stream.cpp",
			"file_size": 6041,
			"file_write_time": 132438264153971367,
			"settings":
			{
				"buffer_size": 6041,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n#pragma once\n\n#include \"antlr4-runtime.h\"\n\nnamespace lava {\n\n  /// Do not buffer up the entire char stream. It does keep a small buffer\n  /// for efficiency and also buffers while a mark exists (set by the\n  /// lookahead prediction in parser). \"Unbuffered\" here refers to fact\n  /// that it doesn't buffer all data, not that's it's on demand loading of char.\n  class  InputStream : public antlr4::CharStream {\n  public:\n    /// The name or source of this char stream.\n    std::string name;\n\n    InputStream(std::wistream &input);\n\n    virtual void consume() override;\n    virtual size_t LA(ssize_t i) override;\n\n    /// <summary>\n    /// Return a marker that we can release later.\n    /// <p/>\n    /// The specific marker value used for this class allows for some level of\n    /// protection against misuse where {@code seek()} is called on a mark or\n    /// {@code release()} is called in the wrong order.\n    /// </summary>\n    virtual ssize_t mark() override;\n\n    /// <summary>\n    /// Decrement number of markers, resetting buffer if we hit 0. </summary>\n    /// <param name=\"marker\"> </param>\n    virtual void release(ssize_t marker) override;\n    virtual size_t index() override;\n\n    /// <summary>\n    /// Seek to absolute character index, which might not be in the current\n    ///  sliding window.  Move {@code p} to {@code index-bufferStartIndex}.\n    /// </summary>\n    virtual void seek(size_t index) override;\n    virtual size_t size() override;\n    virtual std::string getSourceName() const override;\n    virtual std::string getText(const antlr4::misc::Interval &interval) override;\n\n  protected:\n    /// A moving window buffer of the data being scanned. While there's a marker,\n    /// we keep adding to buffer. Otherwise, <seealso cref=\"#consume consume()\"/> resets so\n    /// we start filling at index 0 again.\n    // UTF-32 encoded.\n#if defined(_MSC_VER) && _MSC_VER == 1900\n    i32string _data; // Custom type for VS 2015.\n    typedef __int32 storage_type;\n#else\n    std::u32string _data;\n    typedef char32_t storage_type;\n#endif\n\n    /// <summary>\n    /// 0..n-1 index into <seealso cref=\"#data data\"/> of next character.\n    /// <p/>\n    /// The {@code LA(1)} character is {@code data[p]}. If {@code p == n}, we are\n    /// out of buffered characters.\n    /// </summary>\n    size_t _p;\n\n    /// <summary>\n    /// Count up with <seealso cref=\"#mark mark()\"/> and down with\n    /// <seealso cref=\"#release release()\"/>. When we {@code release()} the last mark,\n    /// {@code numMarkers} reaches 0 and we reset the buffer. Copy\n    /// {@code data[p]..data[n-1]} to {@code data[0]..data[(n-1)-p]}.\n    /// </summary>\n    size_t _numMarkers;\n\n    /// This is the {@code LA(-1)} character for the current position.\n    size_t _lastChar; // UTF-32\n\n    /// <summary>\n    /// When {@code numMarkers > 0}, this is the {@code LA(-1)} character for the\n    /// first character in <seealso cref=\"#data data\"/>. Otherwise, this is unspecified.\n    /// </summary>\n    size_t _lastCharBufferStart; // UTF-32\n\n    /// <summary>\n    /// Absolute character index. It's the index of the character about to be\n    /// read via {@code LA(1)}. Goes from 0 to the number of characters in the\n    /// entire stream, although the stream size is unknown before the end is\n    /// reached.\n    /// </summary>\n    size_t _currentCharIndex;\n\n    std::wistream &_input;\n\n    /// <summary>\n    /// Make sure we have 'want' elements from current position <seealso cref=\"#p p\"/>.\n    /// Last valid {@code p} index is {@code data.length-1}. {@code p+need-1} is\n    /// the char index 'need' elements ahead. If we need 1 element,\n    /// {@code (p+1-1)==p} must be less than {@code data.length}.\n    /// </summary>\n    virtual void sync(size_t want);\n\n    /// <summary>\n    /// Add {@code n} characters to the buffer. Returns the number of characters\n    /// actually added to the buffer. If the return value is less than {@code n},\n    /// then EOF was reached before {@code n} characters could be added.\n    /// </summary>\n    virtual size_t fill(size_t n);\n\n    /// Override to provide different source of characters than\n    /// <seealso cref=\"#input input\"/>.\n    virtual char32_t nextChar();\n    virtual void add(char32_t c);\n    size_t getBufferStartIndex() const;\n\n    virtual std::string toString() const override;\n\n    size_t _size;\n\n  private:\n    void InitializeInstanceFields();\n  };\n\n} // namespace antlr4",
			"file": "src/lava_lib/readers/input_stream.h",
			"file_size": 4608,
			"file_write_time": 132438123896383113,
			"settings":
			{
				"buffer_size": 4608,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/lava_lib/readers/reader_lsd.cpp",
			"settings":
			{
				"buffer_size": 1743,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/lava_lib/_bak/syntax_lsd.h",
			"settings":
			{
				"buffer_size": 5510,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/max/lava.lsd",
			"settings":
			{
				"buffer_size": 29,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/lava_lib/renderer_iface_base.cpp",
			"settings":
			{
				"buffer_size": 543,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/lava_lib/renderer.cpp",
			"settings":
			{
				"buffer_size": 586,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/lava_lib/renderer_iface_base.h",
			"settings":
			{
				"buffer_size": 663,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/lava_lib/scene_reader_base.cpp",
			"settings":
			{
				"buffer_size": 502,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "#include \"SCN_IOTranslator.h\""
			}
		},
		{
			"file": "src/lava_lib/scene_readers_registry.cpp",
			"settings":
			{
				"buffer_size": 939,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/lava_lib/types.h",
			"settings":
			{
				"buffer_size": 7007,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/lava_lib/pymodule/pymodule.cpp",
			"settings":
			{
				"buffer_size": 694,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/lava_lib/display.h",
			"settings":
			{
				"buffer_size": 923,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "#ifndef SRC_LAVA_LIB_H_"
			}
		},
		{
			"file": "src/lava_utils_lib/string.cpp",
			"settings":
			{
				"buffer_size": 548,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "#ifndef LAVA_UTILS_LOGGING_H_"
			}
		},
		{
			"file": "src/lava_utils_lib/string.h",
			"settings":
			{
				"buffer_size": 308,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/lava_utils_lib/logging.cpp",
			"settings":
			{
				"buffer_size": 2672,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "#include <fstream>"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 1655,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/renderBuffer.h",
			"settings":
			{
				"buffer_size": 2211,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "/*************************************************"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/renderBuffer.cpp",
			"settings":
			{
				"buffer_size": 3578,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "/*************************************************"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/renderThread.cpp",
			"settings":
			{
				"buffer_size": 4673,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/pxr/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 526,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "cmake/modules/FindTBB.cmake",
			"settings":
			{
				"buffer_size": 12566,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "cmake/defaults/Packages.cmake",
			"settings":
			{
				"buffer_size": 7991,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/renderDelegate.h",
			"settings":
			{
				"buffer_size": 3434,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/rendererPlugin.cpp",
			"settings":
			{
				"buffer_size": 975,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#line 1 \"/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/renderDelegate.h\"\n#ifndef HDLAVA_RENDER_DELEGATE_H_\n#define HDLAVA_RENDER_DELEGATE_H_\n\n#include \"api.h\"\n#include \"renderThread.h\"\n\n#include \"pxr/imaging/hd/renderDelegate.h\"\n\nPXR_NAMESPACE_OPEN_SCOPE\n\nclass HdLavaDiagnosticMgrDelegate;\nclass HdLavaRenderParam;\nclass HdLavaApi;\n\nclass HdLavaDelegate final : public HdRenderDelegate {\npublic:\n\n    HdLavaDelegate();\n    ~HdLavaDelegate() override;\n\n    HdLavaDelegate(const HdLavaDelegate&) = delete;\n    HdLavaDelegate& operator =(const HdLavaDelegate&) = delete;\n\n    const TfTokenVector& GetSupportedRprimTypes() const override;\n    const TfTokenVector& GetSupportedSprimTypes() const override;\n    const TfTokenVector& GetSupportedBprimTypes() const override;\n\n    HdRenderParam* GetRenderParam() const override;\n    HdResourceRegistrySharedPtr GetResourceRegistry() const override;\n\n    HdRenderPassSharedPtr CreateRenderPass(HdRenderIndex* index, HdRprimCollection const& collection) override;\n\n    HdInstancer* CreateInstancer(HdSceneDelegate* delegate, SdfPath const& id, SdfPath const& instancerId) override;\n    void DestroyInstancer(HdInstancer* instancer) override;\n\n    HdRprim* CreateRprim(TfToken const& typeId, SdfPath const& rprimId, SdfPath const& instancerId) override;\n    void DestroyRprim(HdRprim* rPrim) override;\n\n    HdSprim* CreateSprim(TfToken const& typeId, SdfPath const& sprimId) override;\n    HdSprim* CreateFallbackSprim(TfToken const& typeId) override;\n    void DestroySprim(HdSprim* sprim) override;\n\n    HdBprim* CreateBprim(TfToken const& typeId,\n                         SdfPath const& bprimId) override;\n    HdBprim* CreateFallbackBprim(TfToken const& typeId) override;\n    void DestroyBprim(HdBprim* bprim) override;\n\n    void CommitResources(HdChangeTracker* tracker) override;\n\n    TfToken GetMaterialBindingPurpose() const override { return HdTokens->full; }\n    TfToken GetMaterialNetworkSelector() const override;\n\n    HdAovDescriptor GetDefaultAovDescriptor(TfToken const& name) const override;\n\n    HdRenderSettingDescriptorList GetRenderSettingDescriptors() const override;\n\n    VtDictionary GetRenderStats() const override;\n\n    bool IsPauseSupported() const override;\n    bool Pause() override;\n    bool Resume() override;\n\n#if PXR_VERSION >= 2005\n    bool IsStopSupported() const override;\n    bool Stop() override;\n    bool Restart() override;\n#endif // PXR_VERSION >= 2005\n\n    bool IsBatch() const { return m_isBatch; }\n    bool IsProgressive() const { return m_isProgressive; }\n\nprivate:\n    static const TfTokenVector SUPPORTED_RPRIM_TYPES;\n    static const TfTokenVector SUPPORTED_SPRIM_TYPES;\n    static const TfTokenVector SUPPORTED_BPRIM_TYPES;\n\n    bool m_isBatch;\n    bool m_isProgressive;\n\n    std::unique_ptr<HdLavaApi> m_rprApi;\n    std::unique_ptr<HdLavaRenderParam> m_renderParam;\n    HdRenderSettingDescriptorList m_settingDescriptors;\n    HdLavaRenderThread m_renderThread;\n\n    using DiagnostMgrDelegatePtr = std::unique_ptr<HdLavaDiagnosticMgrDelegate, std::function<void (HdLavaDiagnosticMgrDelegate*)>>;\n    DiagnostMgrDelegatePtr m_diagnosticMgrDelegate;\n};\n\nTfToken const& HdLavaUtilsGetCameraDepthName();\n\nPXR_NAMESPACE_CLOSE_SCOPE\n\nextern \"C\" {\n\nHDLAVA_API void SetHdLavaRenderDevice(int renderDevice);\n\nHDLAVA_API void SetHdLavaRenderQuality(int quality);\n\nHDLAVA_API int GetHdLavaRenderQuality();\n\nHDLAVA_API int HdLavaExportRprSceneOnNextRender(const char* exportPath);\n\n} // extern \"C\"\n\n#endif // HDLAVA_RENDER_DELEGATE_H_\n",
			"file": "build/include/src/pxr/imaging/plugin/hdLava/renderDelegate.h",
			"file_size": 3512,
			"file_write_time": 132423972950336010,
			"settings":
			{
				"buffer_size": 3512,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/renderParam.h",
			"settings":
			{
				"buffer_size": 1740,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/renderPass.cpp",
			"settings":
			{
				"buffer_size": 4716,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/camera.h",
			"settings":
			{
				"buffer_size": 2562,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "/*************************************************"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/camera.cpp",
			"settings":
			{
				"buffer_size": 6546,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "/*************************************************"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/renderParam.cpp",
			"settings":
			{
				"buffer_size": 1800,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/renderDelegate.cpp",
			"settings":
			{
				"buffer_size": 14452,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#line 1 \"/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/renderBuffer.h\"\n/************************************************************************\nCopyright 2020 Advanced Micro Devices, Inc\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n************************************************************************/\n\n#ifndef HDLAVA_RENDER_BUFFER_H_\n#define HDLAVA_RENDER_BUFFER_H_\n\n#include \"pxr/imaging/hd/renderBuffer.h\"\n\nPXR_NAMESPACE_OPEN_SCOPE\n\nclass HdLavaRenderBuffer final : public HdRenderBuffer {\npublic:\n    HdLavaRenderBuffer(SdfPath const& id);\n    ~HdLavaRenderBuffer() override = default;\n\n    void Sync(HdSceneDelegate* sceneDelegate, HdRenderParam* renderParam, HdDirtyBits* dirtyBits) override;\n\n    void Finalize(HdRenderParam* renderParam) override;\n\n    bool Allocate(GfVec3i const& dimensions,\n                  HdFormat format,\n                  bool multiSampled) override;\n\n    unsigned int GetWidth() const override { return m_width; }\n\n    unsigned int GetHeight() const override { return m_height; }\n\n    unsigned int GetDepth() const override { return 1u; }\n\n    HdFormat GetFormat() const override { return m_format; }\n\n    bool IsMultiSampled() const override { return false; }\n\n    void* Map() override;\n\n    void Unmap() override;\n\n    bool IsMapped() const override;\n\n    void Resolve() override;\n\n    bool IsConverged() const override;\n\n    void SetConverged(bool converged);\n\n    void SetStatus(bool isValid);\n\nprotected:\n    void _Deallocate() override;\n\nprivate:\n    uint32_t m_width = 0u;\n    uint32_t m_height = 0u;\n    HdFormat m_format = HdFormat::HdFormatInvalid;\n\n    std::vector<uint8_t> m_mappedBuffer;\n    std::atomic<int> m_numMappers;\n    std::atomic<bool> m_isConverged;\n\n    bool m_isValid = true;\n};\n\nPXR_NAMESPACE_CLOSE_SCOPE\n\n#endif // HDLAVA_RENDER_BUFFER_H_\n",
			"file": "build/include/src/pxr/imaging/plugin/hdLava/renderBuffer.h",
			"file_size": 2287,
			"file_write_time": 132425093115984658,
			"settings":
			{
				"buffer_size": 2287,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/rendererPlugin.h",
			"settings":
			{
				"buffer_size": 1864,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/lavaApiAov.h",
			"settings":
			{
				"buffer_size": 6577,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "/*************************************************"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/lavaApiAov.cpp",
			"settings":
			{
				"buffer_size": 20630,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "/*************************************************"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/lavaApiFramebuffer.cpp",
			"settings":
			{
				"buffer_size": 4795,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "/*************************************************"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/aovDescriptor.h",
			"settings":
			{
				"buffer_size": 3408,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "/*************************************************"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/aovDescriptor.cpp",
			"settings":
			{
				"buffer_size": 9187,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "/*************************************************"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/error.h",
			"settings":
			{
				"buffer_size": 4955,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "/*************************************************"
			}
		},
		{
			"contents": "#include \"renderer.h\"\n\n#include \"Falcor/Utils/Scripting/Scripting.h\"\n#include \"Falcor/Utils/Debug/debug.h\"\n\nnamespace lava {\n\nRenderer::UniquePtr Renderer::create() {\n\treturn UniquePtr(new Renderer());\n}\n\nRenderer::Renderer() {\n\tLOG_DBG(\"Renderer::Renderer\");\n\t//Falcor::Scripting::start();\n\n\tFalcor::Device::Desc device_desc;\n    device_desc.width = 1280;\n    device_desc.height = 720;\n\n\tmpDevice = Falcor::DeviceManager::instance().createRenderingDevice(0, device_desc);\n}\n\nRenderer::~Renderer() {\n\tLOG_DBG(\"Renderer::~Renderer\");\n\t//Falcor::Scripting::shutdown();\n}\n\n}  // namespace lava",
			"file": "src/lava/renderer.cpp",
			"file_size": 590,
			"file_write_time": 132425230878715144,
			"settings":
			{
				"buffer_size": 590,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#ifndef LAVA_RENDERER_H_\n#define LAVA_RENDERER_H_\n\n#include <cstddef>\n#include <string>\n#include <vector>\n#include <memory>\n\n#include \"types.h\"\n\n#include \"Falcor/Core/API/Device.h\"\n#include \"Falcor/Core/API/DeviceManager.h\"\n\nnamespace lava {\n\nclass Renderer {\n public:\n \t~Renderer();\n \tusing UniquePtr = std::unique_ptr<Renderer>;\n\n public:\n \tstatic UniquePtr create();\n\n private:\n \tRenderer();\n \tstd::vector<std::string> \tmErrorMessages;\n \tFalcor::Device::SharedPtr \tmpDevice;\n\n};\n\n}  // namespace Lava\n\n#endif  // LAVA_RENDERER_H_\n",
			"file": "src/lava/renderer.h",
			"file_size": 533,
			"file_write_time": 132425063691592061,
			"settings":
			{
				"buffer_size": 533,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/debugCodes.cpp",
			"settings":
			{
				"buffer_size": 1141,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "/*************************************************"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/debugCodes.h",
			"settings":
			{
				"buffer_size": 1010,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "/*************************************************"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/lavaApiFramebuffer.h",
			"settings":
			{
				"buffer_size": 2080,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "/*************************************************"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/config.cpp",
			"settings":
			{
				"buffer_size": 26047,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "//"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/config.h",
			"settings":
			{
				"buffer_size": 7104,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "//"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/renderPass.h",
			"settings":
			{
				"buffer_size": 852,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/lavaApi.h.old",
			"settings":
			{
				"buffer_size": 6854,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "/*************************************************"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/lavaApi.cpp.old",
			"settings":
			{
				"buffer_size": 113965,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "/*************************************************"
			}
		},
		{
			"file": "third_party/USD/pxr/base/tf/diagnosticLite.h",
			"settings":
			{
				"buffer_size": 6024,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/lavaApi.h",
			"settings":
			{
				"buffer_size": 2703,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/lavaApi.cpp",
			"settings":
			{
				"buffer_size": 5811,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/StringUtils.h",
			"settings":
			{
				"buffer_size": 12635,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Samples/ModelViewer/ModelViewer.cpp",
			"settings":
			{
				"buffer_size": 9979,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Samples/ModelViewer/ModelViewer.ps.slang.bak",
			"settings":
			{
				"buffer_size": 2408,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Samples/ModelViewer/ModelViewer.ps.slang",
			"settings":
			{
				"buffer_size": 2391,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Lights/LightProbeIntegration.ps.slang",
			"settings":
			{
				"buffer_size": 7921,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 1429,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Samples/ShaderToy/ShaderToy.cpp",
			"settings":
			{
				"buffer_size": 4229,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/BasePasses/FullScreenPass.cpp",
			"settings":
			{
				"buffer_size": 5700,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/BasePasses/ComputePass.h",
			"settings":
			{
				"buffer_size": 6377,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/BasePasses/FullScreenPass.h",
			"settings":
			{
				"buffer_size": 4028,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/BasePasses/ComputePass.cpp",
			"settings":
			{
				"buffer_size": 4043,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/BasePasses/BaseGraphicsPass.cpp",
			"settings":
			{
				"buffer_size": 2824,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Timing/FrameRate.h",
			"settings":
			{
				"buffer_size": 3811,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Timing/FrameRate.cpp",
			"settings":
			{
				"buffer_size": 2265,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Experimental/Scene/Lights/LightBVHSampler.h",
			"settings":
			{
				"buffer_size": 6356,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Experimental/Scene/Lights/LightBVHSampler.cpp",
			"settings":
			{
				"buffer_size": 7714,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Experimental/Scene/Lights/LightCollection.cpp",
			"settings":
			{
				"buffer_size": 29489,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/BasePasses/BaseGraphicsPass.h",
			"settings":
			{
				"buffer_size": 3726,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Experimental/Scene/Lights/LightCollection.h",
			"settings":
			{
				"buffer_size": 12783,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/BufferTypes/ParameterBlock.cpp",
			"settings":
			{
				"buffer_size": 67261,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/BSDFViewer/BSDFViewer.cs.slang",
			"settings":
			{
				"buffer_size": 15202,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Core/BufferTests.cs.slang",
			"settings":
			{
				"buffer_size": 2850,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/ShaderVar.cpp",
			"settings":
			{
				"buffer_size": 15515,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Lights/LightProbe.cpp",
			"settings":
			{
				"buffer_size": 11503,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Lights/LightProbe.h",
			"settings":
			{
				"buffer_size": 7813,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/BasePasses/RasterScenePass.cpp",
			"settings":
			{
				"buffer_size": 3402,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderGraphCompiler.cpp",
			"settings":
			{
				"buffer_size": 18153,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderGraph.cpp",
			"settings":
			{
				"buffer_size": 30158,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderGraphExe.cpp",
			"settings":
			{
				"buffer_size": 4177,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderGraphExe.h",
			"settings":
			{
				"buffer_size": 4072,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Scripting/Dictionary.h",
			"settings":
			{
				"buffer_size": 4523,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderGraphUI.cpp",
			"settings":
			{
				"buffer_size": 64727,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Debug/PixelDebug.cpp",
			"settings":
			{
				"buffer_size": 9625,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Algorithm/ParallelReduction.cpp",
			"settings":
			{
				"buffer_size": 6148,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Utils/ParallelReductionTests.cpp",
			"settings":
			{
				"buffer_size": 11656,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Utils/PrefixSumTests.cpp",
			"settings":
			{
				"buffer_size": 4850,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Algorithm/PrefixSum.cpp",
			"settings":
			{
				"buffer_size": 7112,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Algorithm/BitonicSort.cpp",
			"settings":
			{
				"buffer_size": 4470,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Algorithm/ComputeParallelReduction.h",
			"settings":
			{
				"buffer_size": 4901,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Algorithm/ParallelReduction.h",
			"settings":
			{
				"buffer_size": 3575,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Algorithm/BitonicSort.h",
			"settings":
			{
				"buffer_size": 4169,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Algorithm/PrefixSum.h",
			"settings":
			{
				"buffer_size": 4191,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Algorithm/ComputeParallelReduction.cpp",
			"settings":
			{
				"buffer_size": 9541,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Scripting/Console.cpp",
			"settings":
			{
				"buffer_size": 4108,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Scripting/ScriptBindings.cpp",
			"settings":
			{
				"buffer_size": 4913,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 5206,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Sampling/SampleGenerator.cpp",
			"settings":
			{
				"buffer_size": 3452,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Timing/Clock.cpp",
			"settings":
			{
				"buffer_size": 9831,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Timing/Clock.h",
			"settings":
			{
				"buffer_size": 8564,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/TextureLoader.cpp",
			"settings":
			{
				"buffer_size": 24304,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/assimp/include/assimp/Bitmap.h",
			"settings":
			{
				"buffer_size": 4295,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/VAO.h",
			"settings":
			{
				"buffer_size": 5144,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Logger.h",
			"settings":
			{
				"buffer_size": 5549,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Logger.cpp",
			"settings":
			{
				"buffer_size": 5968,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/BinaryFileStream.h",
			"settings":
			{
				"buffer_size": 5898,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Scripting/Scripting.cpp",
			"settings":
			{
				"buffer_size": 5902,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Timing/Profiler.cpp",
			"settings":
			{
				"buffer_size": 10754,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/Gui.cpp",
			"settings":
			{
				"buffer_size": 56184,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/PixelZoom.cpp",
			"settings":
			{
				"buffer_size": 5190,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/TextRenderer.cpp",
			"settings":
			{
				"buffer_size": 7231,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/TextRenderer.h",
			"settings":
			{
				"buffer_size": 3353,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/PixelZoom.h",
			"settings":
			{
				"buffer_size": 3368,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/DebugDrawer.h",
			"settings":
			{
				"buffer_size": 4027,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/DebugDrawer.cpp",
			"settings":
			{
				"buffer_size": 8927,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/Font.h",
			"settings":
			{
				"buffer_size": 4060,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/tools/render-test/bind-location.h",
			"settings":
			{
				"buffer_size": 19257,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/Font.cpp",
			"settings":
			{
				"buffer_size": 5156,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/ProgramReflection.cpp",
			"settings":
			{
				"buffer_size": 85087,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKGraphicsStateObject.cpp",
			"settings":
			{
				"buffer_size": 5776,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/source/slang/slang-reflection.cpp",
			"settings":
			{
				"buffer_size": 50216,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/source/slang/slang-compiler.h",
			"settings":
			{
				"buffer_size": 90183,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/source/slang/slang-name.cpp",
			"settings":
			{
				"buffer_size": 800,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/source/core/slang-dictionary.h",
			"settings":
			{
				"buffer_size": 13988,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/ProgramVars.cpp",
			"settings":
			{
				"buffer_size": 14440,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Raytracing/RtProgramVarsHelper.h",
			"settings":
			{
				"buffer_size": 14339,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/ProgramVars.h",
			"settings":
			{
				"buffer_size": 6798,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/ShaderVar.h",
			"settings":
			{
				"buffer_size": 17036,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/ProgramReflection.h",
			"settings":
			{
				"buffer_size": 54816,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/Program.cpp",
			"settings":
			{
				"buffer_size": 34062,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Buffer.cpp",
			"settings":
			{
				"buffer_size": 13450,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/FBO.cpp",
			"settings":
			{
				"buffer_size": 18040,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/BlendState.h",
			"settings":
			{
				"buffer_size": 9346,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/BlendState.cpp",
			"settings":
			{
				"buffer_size": 3664,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/FBO.h",
			"settings":
			{
				"buffer_size": 13546,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#include \"rendererPlugin.h\"\n#include \"renderDelegate.h\"\n\n#include \"pxr/imaging/hd/rendererPluginRegistry.h\"\n\nPXR_NAMESPACE_OPEN_SCOPE\n\nTF_REGISTRY_FUNCTION(TfType) {\n    HdRendererPluginRegistry::Define<HdLavaPlugin>();\n}\n\nHdRenderDelegate* HdLavaPlugin::CreateRenderDelegate() {\n    return new HdLavaDelegate();\n}\n\nHdRenderDelegate* HdLavaPlugin::CreateRenderDelegate(HdRenderSettingsMap const& settingsMap) {\n    auto renderDelegate = new HdLavaDelegate();\n    for (auto& entry : settingsMap) {\n        renderDelegate->SetRenderSetting(entry.first, entry.second);\n    }\n    return renderDelegate;\n}\n\nvoid HdLavaPlugin::DeleteRenderDelegate(HdRenderDelegate* renderDelegate) {\n    delete renderDelegate;\n}\n\nPXR_NAMESPACE_CLOSE_SCOPE\n",
			"file": "src/USD/hdLava/rendererPlugin.cpp",
			"file_size": 734,
			"file_write_time": 132422386559573478,
			"settings":
			{
				"buffer_size": 734,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#ifndef HDLAVA_RENDER_DELEGATE_H_\n#define HDLAVA_RENDER_DELEGATE_H_\n\n#include \"api.h\"\n#include \"renderThread.h\"\n\n#include \"pxr/imaging/hd/renderDelegate.h\"\n\nPXR_NAMESPACE_OPEN_SCOPE\n\nclass HdLavaDiagnosticMgrDelegate;\nclass HdLavaRenderParam;\nclass HdLavaApi;\n\nclass HdLavaDelegate final : public HdRenderDelegate {\npublic:\n\n    HdLavaDelegate();\n    ~HdLavaDelegate() override;\n\n    HdLavaDelegate(const HdLavaDelegate&) = delete;\n    HdLavaDelegate& operator =(const HdLavaDelegate&) = delete;\n\n    const TfTokenVector& GetSupportedRprimTypes() const override;\n    const TfTokenVector& GetSupportedSprimTypes() const override;\n    const TfTokenVector& GetSupportedBprimTypes() const override;\n\n    HdRenderParam* GetRenderParam() const override;\n    HdResourceRegistrySharedPtr GetResourceRegistry() const override;\n\n    HdRenderPassSharedPtr CreateRenderPass(HdRenderIndex* index,\n                                           HdLavaimCollection const& collection) override;\n\n    HdInstancer* CreateInstancer(HdSceneDelegate* delegate,\n                                 SdfPath const& id,\n                                 SdfPath const& instancerId) override;\n    void DestroyInstancer(HdInstancer* instancer) override;\n\n    HdLavaim* CreateRprim(TfToken const& typeId,\n                         SdfPath const& rprimId,\n                         SdfPath const& instancerId) override;\n    void DestroyRprim(HdLavaim* rPrim) override;\n\n    HdSprim* CreateSprim(TfToken const& typeId,\n                         SdfPath const& sprimId) override;\n    HdSprim* CreateFallbackSprim(TfToken const& typeId) override;\n    void DestroySprim(HdSprim* sprim) override;\n\n    HdBprim* CreateBprim(TfToken const& typeId,\n                         SdfPath const& bprimId) override;\n    HdBprim* CreateFallbackBprim(TfToken const& typeId) override;\n    void DestroyBprim(HdBprim* bprim) override;\n\n    void CommitResources(HdChangeTracker* tracker) override;\n\n    TfToken GetMaterialBindingPurpose() const override { return HdTokens->full; }\n    TfToken GetMaterialNetworkSelector() const override;\n\n    HdAovDescriptor GetDefaultAovDescriptor(TfToken const& name) const override;\n\n    HdRenderSettingDescriptorList GetRenderSettingDescriptors() const override;\n\n    VtDictionary GetRenderStats() const override;\n\n    bool IsPauseSupported() const override;\n    bool Pause() override;\n    bool Resume() override;\n\n#if PXR_VERSION >= 2005\n    bool IsStopSupported() const override;\n    bool Stop() override;\n    bool Restart() override;\n#endif // PXR_VERSION >= 2005\n\nprivate:\n    static const TfTokenVector SUPPORTED_RPRIM_TYPES;\n    static const TfTokenVector SUPPORTED_SPRIM_TYPES;\n    static const TfTokenVector SUPPORTED_BPRIM_TYPES;\n\n    std::unique_ptr<HdLavaApi> m_rprApi;\n    std::unique_ptr<HdLavaRenderParam> m_renderParam;\n    HdRenderSettingDescriptorList m_settingDescriptors;\n    HdLavaRenderThread m_renderThread;\n\n    using DiagnostMgrDelegatePtr = std::unique_ptr<HdLavaDiagnosticMgrDelegate, std::function<void (HdLavaDiagnosticMgrDelegate*)>>;\n    DiagnostMgrDelegatePtr m_diagnosticMgrDelegate;\n};\n\nTfToken const& HdLavaUtilsGetCameraDepthName();\n\nPXR_NAMESPACE_CLOSE_SCOPE\n\nextern \"C\" {\n\nHDRPR_API void SetHdLavaRenderDevice(int renderDevice);\n\nHDRPR_API void SetHdLavaRenderQuality(int quality);\n\nHDRPR_API int GetHdLavaRenderQuality();\n\nHDRPR_API int HdLavaExportRprSceneOnNextRender(const char* exportPath);\n\n} // extern \"C\"\n\n#endif // HDLAVA_RENDER_DELEGATE_H_\n",
			"file": "src/USD/hdLava/renderDelegate.h",
			"file_size": 3463,
			"file_write_time": 132421706354522441,
			"settings":
			{
				"buffer_size": 3463,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "/************************************************************************\nCopyright 2020 Advanced Micro Devices, Inc\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n************************************************************************/\n\n#include \"renderDelegate.h\"\n\n#include\"pxr/imaging/hd/extComputation.h\"\n\n#include \"pxr/base/tf/diagnosticMgr.h\"\n#include \"pxr/base/tf/getenv.h\"\n\n#include \"camera.h\"\n#include \"config.h\"\n#include \"renderPass.h\"\n#include \"renderParam.h\"\n#include \"mesh.h\"\n#include \"instancer.h\"\n#include \"domeLight.h\"\n#include \"distantLight.h\"\n#include \"light.h\"\n#include \"material.h\"\n#include \"renderBuffer.h\"\n#include \"basisCurves.h\"\n#include \"points.h\"\n\n#ifdef USE_VOLUME\n#include \"volume.h\"\n#include \"field.h\"\n#endif\n\n#include <ctime>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n\nPXR_NAMESPACE_OPEN_SCOPE\n\nstatic HdLavaApi* g_rprApi = nullptr;\n\nclass HdLavaDiagnosticMgrDelegate : public TfDiagnosticMgr::Delegate {\npublic:\n    explicit HdLavaDiagnosticMgrDelegate(std::string const& logFile) : m_outputFile(nullptr) {\n        if (logFile == \"stderr\") {\n            m_output = stderr;\n        } else if (logFile == \"stdout\") {\n            m_output = stdout;\n        } else {\n            m_outputFile = fopen(logFile.c_str(), \"a+\");\n            if (!m_outputFile) {\n                TF_RUNTIME_ERROR(\"Failed to open error output file: \\\"%s\\\". Defaults to stderr\\n\", logFile.c_str());\n                m_output = stderr;\n            } else {\n                m_output = m_outputFile;\n            }\n        }\n    }\n    ~HdLavaDiagnosticMgrDelegate() override {\n        if (m_outputFile) {\n            fclose(m_outputFile);\n        }\n    }\n\n    void IssueError(TfError const &err) override {\n        IssueDiagnosticBase(err);\n    };\n    void IssueFatalError(TfCallContext const &context, std::string const &msg) override {\n        std::string message = TfStringPrintf(\n            \"[FATAL ERROR] %s -- in %s at line %zu of %s\",\n            msg.c_str(),\n            context.GetFunction(),\n            context.GetLine(),\n            context.GetFile());\n        IssueMessage(msg);\n    };\n    void IssueStatus(TfStatus const &status) override {\n        IssueDiagnosticBase(status);\n    };\n    void IssueWarning(TfWarning const &warning) override {\n        IssueDiagnosticBase(warning);\n    };\n\nprivate:\n    void IssueDiagnosticBase(TfDiagnosticBase const& d) {\n        std::string msg = TfStringPrintf(\n            \"%s -- %s in %s at line %zu of %s\",\n            d.GetCommentary().c_str(),\n            TfDiagnosticMgr::GetCodeName(d.GetDiagnosticCode()).c_str(),\n            d.GetContext().GetFunction(),\n            d.GetContext().GetLine(),\n            d.GetContext().GetFile());\n        IssueMessage(msg);\n    }\n\n    void IssueMessage(std::string const& message) {\n        std::time_t t = std::time(nullptr);\n        std::stringstream ss;\n        ss << \"[\" << std::put_time(std::gmtime(&t), \"%T%z %F\") << \"] \" << message;\n        auto str = ss.str();\n\n        fprintf(m_output, \"%s\\n\", str.c_str());\n    }\n\nprivate:\n    FILE* m_output;\n    FILE* m_outputFile;\n};\n\nTF_DEFINE_PRIVATE_TOKENS(_tokens,\n    (openvdbAsset) \\\n    (percentDone)\n);\n\nconst TfTokenVector HdLavaDelegate::SUPPORTED_RPRIM_TYPES = {\n    HdPrimTypeTokens->mesh,\n    HdPrimTypeTokens->basisCurves,\n    HdPrimTypeTokens->points,\n#ifdef USE_VOLUME\n    HdPrimTypeTokens->volume,\n#endif\n};\n\nconst TfTokenVector HdLavaDelegate::SUPPORTED_SPRIM_TYPES = {\n    HdPrimTypeTokens->camera,\n    HdPrimTypeTokens->material,\n    HdPrimTypeTokens->rectLight,\n    HdPrimTypeTokens->sphereLight,\n    HdPrimTypeTokens->cylinderLight,\n    HdPrimTypeTokens->domeLight,\n    HdPrimTypeTokens->diskLight,\n    HdPrimTypeTokens->distantLight,\n    HdPrimTypeTokens->extComputation\n};\n\nconst TfTokenVector HdLavaDelegate::SUPPORTED_BPRIM_TYPES = {\n#ifdef USE_VOLUME\n    _tokens->openvdbAsset,\n#endif\n    HdPrimTypeTokens->renderBuffer\n};\n\nHdLavaDelegate::HdLavaDelegate() {\n    m_rprApi.reset(new HdLavaApi(this));\n    g_rprApi = m_rprApi.get();\n\n    m_renderParam.reset(new HdLavaRenderParam(m_rprApi.get(), &m_renderThread));\n\n    m_settingDescriptors = HdLavaConfig::GetRenderSettingDescriptors();\n    _PopulateDefaultSettings(m_settingDescriptors);\n\n    m_renderThread.SetRenderCallback([this]() {\n        m_rprApi->Render(&m_renderThread);\n    });\n    m_renderThread.SetStopCallback([this]() {\n        m_rprApi->AbortRender();\n    });\n    m_renderThread.StartThread();\n\n    auto errorOutputFile = TfGetenv(\"HD_RPR_ERROR_OUTPUT_FILE\");\n    if (!errorOutputFile.empty()) {\n        m_diagnosticMgrDelegate = DiagnostMgrDelegatePtr(\n            new HdLavaDiagnosticMgrDelegate(errorOutputFile),\n            [](HdLavaDiagnosticMgrDelegate* delegate) {\n                TfDiagnosticMgr::GetInstance().RemoveDelegate(delegate);\n                delete delegate;\n            });\n        TfDiagnosticMgr::GetInstance().AddDelegate(m_diagnosticMgrDelegate.get());\n    }\n}\n\nHdLavaDelegate::~HdLavaDelegate() {\n    g_rprApi = nullptr;\n}\n\nHdRenderParam* HdLavaDelegate::GetRenderParam() const {\n    return m_renderParam.get();\n}\n\nvoid HdLavaDelegate::CommitResources(HdChangeTracker* tracker) {\n    // CommitResources() is called after prim sync has finished, but before any\n    // tasks (such as draw tasks) have run.\n\n}\n\nTfToken HdLavaDelegate::GetMaterialNetworkSelector() const {\n    return m_renderParam->GetMaterialNetworkSelector();\n}\n\nTfTokenVector const& HdLavaDelegate::GetSupportedRprimTypes() const {\n    return SUPPORTED_RPRIM_TYPES;\n}\n\nTfTokenVector const& HdLavaDelegate::GetSupportedSprimTypes() const {\n    return SUPPORTED_SPRIM_TYPES;\n}\n\nTfTokenVector const& HdLavaDelegate::GetSupportedBprimTypes() const {\n    return SUPPORTED_BPRIM_TYPES;\n}\n\nHdResourceRegistrySharedPtr HdLavaDelegate::GetResourceRegistry() const {\n    return HdResourceRegistrySharedPtr(new HdResourceRegistry());\n}\n\nHdRenderPassSharedPtr HdLavaDelegate::CreateRenderPass(HdRenderIndex* index,\n                                                      HdLavaimCollection const& collection) {\n    return HdRenderPassSharedPtr(new HdLavaRenderPass(index, collection, m_renderParam.get()));\n}\n\nHdInstancer* HdLavaDelegate::CreateInstancer(HdSceneDelegate* delegate,\n                                            SdfPath const& id,\n                                            SdfPath const& instancerId) {\n    return new HdLavaInstancer(delegate, id, instancerId);\n}\n\nvoid HdLavaDelegate::DestroyInstancer(HdInstancer* instancer) {\n    delete instancer;\n}\n\nHdLavaim* HdLavaDelegate::CreateRprim(TfToken const& typeId,\n                                    SdfPath const& rprimId,\n                                    SdfPath const& instancerId) {\n    if (typeId == HdPrimTypeTokens->mesh) {\n        return new HdLavaMesh(rprimId, instancerId);\n    } else if (typeId == HdPrimTypeTokens->basisCurves) {\n        return new HdLavaBasisCurves(rprimId, instancerId);\n    } else if (typeId == HdPrimTypeTokens->points) {\n        return new HdLavaPoints(rprimId, instancerId);\n    }\n#ifdef USE_VOLUME\n    else if (typeId == HdPrimTypeTokens->volume) {\n        return new HdLavaVolume(rprimId);\n    }\n#endif\n\n    TF_CODING_ERROR(\"Unknown Rprim Type %s\", typeId.GetText());\n    return nullptr;\n}\n\nvoid HdLavaDelegate::DestroyRprim(HdLavaim* rPrim) {\n    delete rPrim;\n}\n\nHdSprim* HdLavaDelegate::CreateSprim(TfToken const& typeId,\n                                    SdfPath const& sprimId) {\n    if (typeId == HdPrimTypeTokens->camera) {\n        return new HdLavaCamera(sprimId);\n    } else if (typeId == HdPrimTypeTokens->domeLight) {\n        return new HdLavaDomeLight(sprimId);\n    } else if (typeId == HdPrimTypeTokens->distantLight) {\n        return new HdLavaDistantLight(sprimId);\n    } else if (typeId == HdPrimTypeTokens->rectLight ||\n        typeId == HdPrimTypeTokens->sphereLight ||\n        typeId == HdPrimTypeTokens->cylinderLight ||\n        typeId == HdPrimTypeTokens->diskLight) {\n        return new HdLavaLight(sprimId, typeId);\n    } else if (typeId == HdPrimTypeTokens->material) {\n        return new HdLavaMaterial(sprimId);\n    } else if (typeId == HdPrimTypeTokens->extComputation) {\n        return new HdExtComputation(sprimId);\n    }\n\n    TF_CODING_ERROR(\"Unknown Sprim Type %s\", typeId.GetText());\n    return nullptr;\n}\n\nHdSprim* HdLavaDelegate::CreateFallbackSprim(TfToken const& typeId) {\n    // For fallback sprims, create objects with an empty scene path.\n    // They'll use default values and won't be updated by a scene delegate.\n    if (typeId == HdPrimTypeTokens->camera) {\n        return new HdLavaCamera(SdfPath::EmptyPath());\n    } else if (typeId == HdPrimTypeTokens->domeLight) {\n        return new HdLavaDomeLight(SdfPath::EmptyPath());\n    } else if (typeId == HdPrimTypeTokens->rectLight ||\n        typeId == HdPrimTypeTokens->sphereLight ||\n        typeId == HdPrimTypeTokens->cylinderLight ||\n        typeId == HdPrimTypeTokens->diskLight) {\n        return new HdLavaLight(SdfPath::EmptyPath(), typeId);\n    } else if (typeId == HdPrimTypeTokens->distantLight) {\n        return new HdLavaDistantLight(SdfPath::EmptyPath());\n    } else if (typeId == HdPrimTypeTokens->material) {\n        return new HdLavaMaterial(SdfPath::EmptyPath());\n    } else if (typeId == HdPrimTypeTokens->extComputation) {\n        return new HdExtComputation(SdfPath::EmptyPath());\n    }\n\n    TF_CODING_ERROR(\"Unknown Sprim Type %s\", typeId.GetText());\n    return nullptr;\n}\n\nvoid HdLavaDelegate::DestroySprim(HdSprim* sPrim) {\n    delete sPrim;\n}\n\nHdBprim* HdLavaDelegate::CreateBprim(TfToken const& typeId,\n                                    SdfPath const& bprimId) {\n    if (typeId == HdPrimTypeTokens->renderBuffer) {\n        return new HdLavaRenderBuffer(bprimId);\n    }\n#ifdef USE_VOLUME\n    else if (typeId == _tokens->openvdbAsset) {\n        return new HdLavaField(bprimId);\n    }\n#endif\n\n    TF_CODING_ERROR(\"Unknown Bprim Type %s\", typeId.GetText());\n    return nullptr;\n}\n\nHdBprim* HdLavaDelegate::CreateFallbackBprim(TfToken const& typeId) {\n    return nullptr;\n}\n\nvoid HdLavaDelegate::DestroyBprim(HdBprim* bPrim) {\n    delete bPrim;\n}\n\nHdAovDescriptor HdLavaDelegate::GetDefaultAovDescriptor(TfToken const& name) const {\n    HdParsedAovToken aovId(name);\n    if (name != HdAovTokens->color &&\n        name != HdAovTokens->normal &&\n        name != HdAovTokens->primId &&\n        name != HdAovTokens->depth &&\n        name != HdLavaUtilsGetCameraDepthName() &&\n        !(aovId.isPrimvar && aovId.name == \"st\")) {\n        // TODO: implement support for instanceId and elementId aov\n        return HdAovDescriptor();\n    }\n\n    if (!m_rprApi->IsAovFormatConversionAvailable()) {\n        if (name == HdAovTokens->primId) {\n            // Integer images required, no way to support it\n            return HdAovDescriptor();\n        }\n        // Only native RPR format can be used for AOVs when there is no support for AOV format conversion\n        return HdAovDescriptor(HdFormatFloat32Vec4, false, VtValue(GfVec4f(0.0f)));\n    }\n\n    HdFormat format = HdFormatInvalid;\n\n    float clearColorValue = 0.0f;\n    if (name == HdAovTokens->depth ||\n        name == HdLavaUtilsGetCameraDepthName()) {\n        clearColorValue = name == HdLavaUtilsGetCameraDepthName() ? 0.0f : 1.0f;\n        format = HdFormatFloat32;\n    } else if (name == HdAovTokens->color) {\n        format = HdFormatFloat32Vec4;\n    } else if (name == HdAovTokens->primId) {\n        format = HdFormatInt32;\n    } else {\n        format = HdFormatFloat32Vec3;\n    }\n\n    return HdAovDescriptor(format, false, VtValue(GfVec4f(clearColorValue)));\n}\n\nHdRenderSettingDescriptorList HdLavaDelegate::GetRenderSettingDescriptors() const {\n    return m_settingDescriptors;\n}\n\nVtDictionary HdLavaDelegate::GetRenderStats() const {\n    VtDictionary stats;\n    int numCompletedSamples = m_rprApi->GetNumCompletedSamples();\n    stats[HdPerfTokens->numCompletedSamples.GetString()] = numCompletedSamples;\n\n    double percentDone = 0.0;\n    {\n        HdLavaConfig* config;\n        auto configInstanceLock = HdLavaConfig::GetInstance(&config);\n        percentDone = double(numCompletedSamples) / config->GetMaxSamples();\n    }\n    int numActivePixels = m_rprApi->GetNumActivePixels();\n    if (numActivePixels != -1) {\n        auto size = m_rprApi->GetViewportSize();\n        int numPixels = size[0] * size[1];\n        percentDone = std::max(percentDone, double(numPixels - numActivePixels) / numPixels);\n    }\n    stats[_tokens->percentDone.GetString()] = 100.0 * percentDone;\n    return stats;\n}\n\nbool HdLavaDelegate::IsPauseSupported() const {\n    return true;\n}\n\nbool HdLavaDelegate::Pause() {\n    m_renderThread.PauseRender();\n    return true;\n}\n\nbool HdLavaDelegate::Resume() {\n    m_renderThread.ResumeRender();\n    return true;\n}\n\n#if PXR_VERSION >= 2005\n\nbool HdLavaDelegate::IsStopSupported() const {\n    return true;\n}\n\nbool HdLavaDelegate::Stop() {\n    m_renderThread.StopRender();\n    return true;\n}\n\nbool HdLavaDelegate::Restart() {\n    m_renderParam->RestartRender();\n    m_renderThread.StartRender();\n    return true;\n}\n\n#endif // PXR_VERSION >= 2005\n\nTfToken const& HdLavaUtilsGetCameraDepthName() {\n#if PXR_VERSION < 2002\n    return HdAovTokens->linearDepth;\n#else\n    return HdAovTokens->cameraDepth;\n#endif\n}\n\nPXR_NAMESPACE_CLOSE_SCOPE\n\nvoid SetHdLavaRenderDevice(int renderDevice) {\n    PXR_INTERNAL_NS::HdLavaConfig* config;\n    auto configInstanceLock = PXR_INTERNAL_NS::HdLavaConfig::GetInstance(&config);\n    config->SetRenderDevice(renderDevice);\n}\n\nvoid SetHdLavaRenderQuality(int quality) {\n    PXR_INTERNAL_NS::HdLavaConfig* config;\n    auto configInstanceLock = PXR_INTERNAL_NS::HdLavaConfig::GetInstance(&config);\n    config->SetRenderQuality(quality);\n}\n\nint GetHdLavaRenderQuality() {\n    if (!PXR_INTERNAL_NS::g_rprApi) {\n        return -1;\n    }\n    return PXR_INTERNAL_NS::g_rprApi->GetCurrentRenderQuality();\n}\n\nint HdLavaExportRprSceneOnNextRender(const char* exportPath) {\n    if (!PXR_INTERNAL_NS::g_rprApi) {\n        return -1;\n    }\n    PXR_INTERNAL_NS::g_rprApi->ExportRprSceneOnNextRender(exportPath);\n    return 0;\n}\n",
			"file": "src/USD/hdLava/renderDelegate.cpp",
			"file_size": 14534,
			"file_write_time": 132421707033510981,
			"settings":
			{
				"buffer_size": 14534,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "/************************************************************************\nCopyright 2020 Advanced Micro Devices, Inc\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n************************************************************************/\n\n#ifndef HDLAVA_RENDER_THREAD_H_\n#define HDLAVA_RENDER_THREAD_H_\n\n#include \"pxr/pxr.h\"\n\n#include <condition_variable>\n#include <functional>\n#include <atomic>\n#include <thread>\n#include <mutex>\n\nPXR_NAMESPACE_OPEN_SCOPE\n\nclass HdLavaRenderThread {\npublic:\n    HdLavaRenderThread();\n    ~HdLavaRenderThread();\n\n    void SetStopCallback(std::function<void()> stopCallback);\n    void SetRenderCallback(std::function<void()> renderCallback);\n    void SetShutdownCallback(std::function<void()> shutdownCallback);\n\n    void StartThread();\n    void StopThread();\n    bool IsThreadRunning();\n\n    void StartRender();\n    void StopRender();\n    bool IsStopRequested();\n    bool IsRendering();\n\n    void PauseRender();\n    void ResumeRender();\n\n    void WaitUntilPaused();\n\nprivate:\n    void RenderLoop();\n\n    std::function<void()> m_stopCallback;\n    std::function<void()> m_renderCallback;\n    std::function<void()> m_shutdownCallback;\n\n    enum State {\n        StateInitial,\n        StateIdle,\n        StateRendering,\n        StateTerminated,\n    };\n\n    State m_requestedState;\n    std::mutex m_requestedStateMutex;\n    std::condition_variable m_requestedStateCV;\n\n    std::mutex m_pauseWaitMutex;\n    std::condition_variable m_pauseWaitCV;\n    bool m_pauseRender;\n\n    std::atomic_flag m_enableRender;\n    bool m_stopRequested;\n\n    std::atomic<bool> m_rendering;\n    std::thread m_renderThread;\n};\n\nPXR_NAMESPACE_CLOSE_SCOPE\n\n#endif // HDLAVA_RENDER_THREAD_H_\n",
			"file": "src/USD/hdLava/renderThread.h",
			"file_size": 2169,
			"file_write_time": 132421707778938502,
			"settings":
			{
				"buffer_size": 2169,
				"line_ending": "Unix",
				"name": "/*************************************************"
			}
		},
		{
			"contents": "/************************************************************************\nCopyright 2020 Advanced Micro Devices, Inc\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n************************************************************************/\n\n#include \"renderThread.h\"\n\n#include \"pxr/base/tf/diagnostic.h\"\n\nPXR_NAMESPACE_OPEN_SCOPE\n\nHdLavaRenderThread::HdLavaRenderThread()\n    : m_stopCallback([]() {})\n    , m_renderCallback([]() { TF_CODING_ERROR(\"StartThread() called without a render callback set\"); })\n    , m_shutdownCallback([]() {})\n    , m_requestedState(StateInitial)\n    , m_stopRequested(false)\n    , m_pauseRender(false)\n    , m_rendering(false) {\n\n}\n\nHdLavaRenderThread::~HdLavaRenderThread() {\n    StopThread();\n}\n\nvoid HdLavaRenderThread::SetRenderCallback(std::function<void()> renderCallback) {\n    if (renderCallback) {\n        m_renderCallback = renderCallback;\n    }\n}\n\nvoid HdLavaRenderThread::SetStopCallback(std::function<void()> stopCallback) {\n    if (stopCallback) {\n        m_stopCallback = stopCallback;\n    }\n}\n\nvoid HdLavaRenderThread::SetShutdownCallback(std::function<void()> shutdownCallback) {\n    if (shutdownCallback) {\n        m_shutdownCallback = shutdownCallback;\n    }\n}\n\nvoid HdLavaRenderThread::StartThread() {\n    if (m_renderThread.joinable()) {\n        TF_CODING_ERROR(\"StartThread() called while render thread is already running\");\n        return;\n    }\n\n    m_requestedState = StateIdle;\n    m_renderThread = std::thread(&HdLavaRenderThread::RenderLoop, this);\n}\n\nvoid HdLavaRenderThread::StopThread() {\n    if (!m_renderThread.joinable()) {\n        return;\n    }\n\n    {\n        m_enableRender.clear();\n        std::unique_lock<std::mutex> lock(m_requestedStateMutex);\n        m_requestedState = StateTerminated;\n        m_requestedStateCV.notify_one();\n    }\n    m_renderThread.join();\n}\n\nbool HdLavaRenderThread::IsThreadRunning() {\n    return m_renderThread.joinable();\n}\n\nvoid HdLavaRenderThread::StartRender() {\n    if (!IsRendering()) {\n        std::unique_lock<std::mutex> lock(m_requestedStateMutex);\n        m_enableRender.test_and_set();\n        m_requestedState = StateRendering;\n        m_rendering.store(true);\n        m_requestedStateCV.notify_one();\n    }\n}\n\nvoid HdLavaRenderThread::StopRender() {\n    if (IsRendering()) {\n        m_enableRender.clear();\n        if (m_pauseRender) {\n            // In case rendering thread was blocked by WaitUntilPaused, notify that stop is requested\n            m_pauseWaitCV.notify_one();\n        }\n        // In case rendering thread currently inside of some sort of rendering task that could be stopped call stopCallback to speed up return from renderCallback\n        m_stopCallback();\n        std::unique_lock<std::mutex> lock(m_requestedStateMutex);\n        m_requestedState = StateIdle;\n        m_rendering.store(false);\n    }\n}\n\nbool HdLavaRenderThread::IsRendering() {\n    return m_rendering.load();\n}\n\nbool HdLavaRenderThread::IsStopRequested() {\n    if (!m_enableRender.test_and_set()) {\n        m_stopRequested = true;\n    }\n\n    return m_stopRequested;\n}\n\nvoid HdLavaRenderThread::PauseRender() {\n    std::unique_lock<std::mutex> lock(m_pauseWaitMutex);\n    m_pauseRender = true;\n}\n\nvoid HdLavaRenderThread::ResumeRender() {\n    std::unique_lock<std::mutex> lock(m_pauseWaitMutex);\n    m_pauseRender = false;\n    m_pauseWaitCV.notify_one();\n}\n\nvoid HdLavaRenderThread::WaitUntilPaused() {\n    if (!m_pauseRender || IsStopRequested()) {\n        return;\n    }\n\n    std::unique_lock<std::mutex> lock(m_pauseWaitMutex);\n    while (m_pauseRender && !IsStopRequested()) {\n        m_pauseWaitCV.wait(lock);\n    }\n}\n\nvoid HdLavaRenderThread::RenderLoop() {\n    while (1) {\n        std::unique_lock<std::mutex> lock(m_requestedStateMutex);\n        m_requestedStateCV.wait(lock, [this]() {\n            return m_requestedState != StateIdle;\n        });\n        if (m_requestedState == StateRendering) {\n            m_renderCallback();\n            m_stopRequested = false;\n            m_rendering.store(false);\n            m_requestedState = StateIdle;\n        } else if (m_requestedState == StateTerminated) {\n            break;\n        }\n    }\n    m_shutdownCallback();\n}\n\nPXR_NAMESPACE_CLOSE_SCOPE\n",
			"file": "src/USD/hdLava/renderThread.cpp",
			"file_size": 4673,
			"file_write_time": 132421708306889721,
			"settings":
			{
				"buffer_size": 4673,
				"line_ending": "Unix",
				"name": "/*************************************************"
			}
		},
		{
			"contents": "//\n// Copyright 2018 Intel\n//\n// Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n// with the following modification; you may not use this file except in\n// compliance with the Apache License and the following modification to it:\n// Section 6. Trademarks. is deleted and replaced with:\n//\n// 6. Trademarks. This License does not grant permission to use the trade\n//    names, trademarks, service marks, or product names of the Licensor\n//    and its affiliates, except as required to comply with Section 4(c) of\n//    the License and to reproduce the content of the NOTICE file.\n//\n// You may obtain a copy of the Apache License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the Apache License with the above modification is\n// distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied. See the Apache License for the specific\n// language governing permissions and limitations under the Apache License.\n//\n#ifndef HDLAVA_RENDERER_PLUGIN_H_\n#define HDLAVA_RENDERER_PLUGIN_H_\n\n#include \"pxr/imaging/hd/rendererPlugin.h\"\n\nPXR_NAMESPACE_OPEN_SCOPE\n\nclass HdLavaPlugin final : public HdRendererPlugin {\npublic:\n    HdLavaPlugin() = default;\n    ~HdLavaPlugin() override = default;\n\n    HdLavaPlugin(const HdLavaPlugin&) = delete;\n    HdLavaPlugin& operator =(const HdLavaPlugin&) = delete;\n\n    HdRenderDelegate* CreateRenderDelegate() override;\n\n    HdRenderDelegate* CreateRenderDelegate(HdRenderSettingsMap const& settingsMap) override;\n\n    void DeleteRenderDelegate(HdRenderDelegate* renderDelegate) override;\n\n    bool IsSupported() const override { return true; }\n};\n\nPXR_NAMESPACE_CLOSE_SCOPE\n\n#endif // HDLAVA_RENDERER_PLUGIN_H_\n",
			"file": "src/USD/hdLava/rendererPlugin.h",
			"file_size": 1809,
			"file_write_time": 132421704975706043,
			"settings":
			{
				"buffer_size": 1809,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Texture.h",
			"settings":
			{
				"buffer_size": 15518,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/ShadingUtils/RaytracingTests.cpp",
			"settings":
			{
				"buffer_size": 4882,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Slang/SlangTests.cpp",
			"settings":
			{
				"buffer_size": 8055,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Slang/SlangTests.cs.slang",
			"settings":
			{
				"buffer_size": 6527,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Slang/SlangShared.slang",
			"settings":
			{
				"buffer_size": 2435,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Slang/ShaderModel.cpp",
			"settings":
			{
				"buffer_size": 3182,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Slang/Int64Tests.cpp",
			"settings":
			{
				"buffer_size": 3694,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Slang/TraceRayFlags.cpp",
			"settings":
			{
				"buffer_size": 3163,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Slang/TraceRayInline.cpp",
			"settings":
			{
				"buffer_size": 2113,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Slang/WaveOps.cpp",
			"settings":
			{
				"buffer_size": 6067,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Utils/AABBTests.cpp",
			"settings":
			{
				"buffer_size": 7752,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/prelude/slang-cpp-types.h",
			"settings":
			{
				"buffer_size": 28997,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/FalcorTest.h",
			"settings":
			{
				"buffer_size": 2143,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/FalcorTest.cpp",
			"settings":
			{
				"buffer_size": 3605,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Sampling/SampleGeneratorTests.cpp",
			"settings":
			{
				"buffer_size": 7287,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Core/RootBufferTests.cpp",
			"settings":
			{
				"buffer_size": 8005,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Core/RootBufferStructTests.cpp",
			"settings":
			{
				"buffer_size": 5631,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VkGpuMemoryHeap.cpp",
			"settings":
			{
				"buffer_size": 2413,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Platform/Linux/Linux.cpp",
			"settings":
			{
				"buffer_size": 15074,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Platform/Windows/ProgressBarWin.cpp",
			"settings":
			{
				"buffer_size": 4513,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Platform/OS.h",
			"settings":
			{
				"buffer_size": 15995,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKState.h",
			"settings":
			{
				"buffer_size": 3960,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Texture.cpp",
			"settings":
			{
				"buffer_size": 16435,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#add_subdirectory( hgiVk ) # usd vulkan backend\n\nset(PXR_ENABLE_PTEX_SUPPORT OFF)\nset(PXR_ENABLE_PYSIDE_SUPPORT OFF)\n\nlist(APPEND CMAKE_MODULE_PATH \n\t${CMAKE_SOURCE_DIR}/third_party/USD/cmake\n\t${CMAKE_SOURCE_DIR}/third_party/USD/cmake/defaults\n\t${CMAKE_SOURCE_DIR}/third_party/USD/cmake/modules\n\t${CMAKE_SOURCE_DIR}/third_party/USD/cmake/macros\n)\n\ninclude(Options)\n\ninclude(ProjectDefaults)\ninclude(Packages)\n\ninclude(CXXDefaults)\nadd_definitions(${_PXR_CXX_DEFINITIONS})\nset(CMAKE_CXX_FLAGS \"${_PXR_CXX_FLAGS} ${CMAKE_CXX_FLAGS}\")\n\ninclude(Public)\n\n#set(CMAKE_CXX_STANDARD 14)\n\nadd_subdirectory( hdLava ) # usdview hydra renderer plugin\n",
			"file": "src/USD/CMakeLists.txt",
			"file_size": 638,
			"file_write_time": 132422395509769717,
			"settings":
			{
				"buffer_size": 638,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "set(PXR_PREFIX pxr/imaging)\nset(PXR_PACKAGE hdLava)\nadd_custom_target(shared_libs)\n\ninclude_directories(/opt/USD/include)\nlink_directories(/opt/USD/lib)\n#include_directories(${RPR_INCLUDE_DIR})\n#link_directories(${RPR_LIBRARY_DIR})\n\n#find_package(OpenImageIO 1.8.9 REQUIRED)\n\npxr_plugin(hdLava\n  PUBLIC_CLASSES\n    #config\n    #instancer\n    #mesh\n    #material\n    rendererPlugin\n    renderParam\n    #renderDelegate\n    #renderPass\n    #sampler\n    #texture\n    #lights/light\n    #lights/diskLight\n    #lights/distantLight\n    #lights/domeLight\n    #lights/rectLight\n    #lights/sphereLight\n    #lights/simpleLight\n\n  #PUBLIC_HEADERS\n    #context.h\n    #renderParam.h\n\n  PRIVATE_HEADERS\n    boostIncludePath.h\n    api.h\n\n  RESOURCE_FILES\n    plugInfo.json\n)\n\n#find_package(ospray 2.2.0 REQUIRED)\n#find_package(rkcommon 1.4.2 REQUIRED)\n\ntarget_link_libraries(hdLava\n  PUBLIC\n    plug\n    tf\n    vt\n    gf\n    work\n    hf\n    hd\n    hdx\n    falcor_lib\n    #rkcommon::rkcommon\n    #ospray::ospray\n    #ospray::ospray_sdk\n    #${OIIO_LIBRARIES}\n)\n\n#target_include_directories(hdLava PUBLIC ${OIIO_INCLUDE_DIRS})\n\n\n#if(UNIX)\n#    install( TARGETS hdLava DESTINATION \"lib\" )\n#endif()\n",
			"file": "src/USD/hdLava/CMakeLists.txt",
			"file_size": 1179,
			"file_write_time": 132422397085363503,
			"settings":
			{
				"buffer_size": 1179,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#ifndef HDLAVA_API_H_\n#define HDLAVA_API_H_\n\n#include \"pxr/base/arch/export.h\"\n\n#if defined(PXR_STATIC)\n#   define HDLAVA_API\n#   define HDLAVA_API_TEMPLATE_CLASS(...)\n#   define HDLAVA_API_TEMPLATE_STRUCT(...)\n#   define HDLAVA_LOCAL\n#else\n#   if defined(HDLAVA_EXPORTS)\n#       define HDLAVA_API ARCH_EXPORT\n#       define HDLAVA_API_TEMPLATE_CLASS(...) ARCH_EXPORT_TEMPLATE(class, __VA_ARGS__)\n#       define HDLAVA_API_TEMPLATE_STRUCT(...) ARCH_EXPORT_TEMPLATE(struct, __VA_ARGS__)\n#   else\n#       define HDLAVA_API ARCH_IMPORT\n#       define HDLAVA_API_TEMPLATE_CLASS(...) ARCH_IMPORT_TEMPLATE(class, __VA_ARGS__)\n#       define HDLAVA_API_TEMPLATE_STRUCT(...) ARCH_IMPORT_TEMPLATE(struct, __VA_ARGS__)\n#   endif\n#   define HDLAVA_LOCAL ARCH_HIDDEN\n#endif\n\n\n#endif // HDLAVA_API_H_\n",
			"file": "src/USD/hdLava/api.h",
			"file_size": 788,
			"file_write_time": 132421709400671659,
			"settings":
			{
				"buffer_size": 788,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "/************************************************************************\nCopyright 2020 Advanced Micro Devices, Inc\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n************************************************************************/\n\n//\n// Copyright 2017 Pixar\n//\n// Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n// with the following modification; you may not use this file except in\n// compliance with the Apache License and the following modification to it:\n// Section 6. Trademarks. is deleted and replaced with:\n//\n// 6. Trademarks. This License does not grant permission to use the trade\n//    names, trademarks, service marks, or product names of the Licensor\n//    and its affiliates, except as required to comply with Section 4(c) of\n//    the License and to reproduce the content of the NOTICE file.\n//\n// You may obtain a copy of the Apache License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the Apache License with the above modification is\n// distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied. See the Apache License for the specific\n// language governing permissions and limitations under the Apache License.\n//\n// WARNING: THIS FILE IS GENERATED.  DO NOT EDIT.\n//\n\n#define TF_MAX_ARITY 7\n#include \"pxr/pxr.h\"\n#include \"pxr/base/arch/defines.h\"\n#include \"boostIncludePath.h\"\n\n#if defined(ARCH_OS_WINDOWS)\n# ifndef WIN32_LEAN_AND_MEAN\n#  define WIN32_LEAN_AND_MEAN\n# endif\n\n# include BOOST_INCLUDE_PATH(preprocessor/variadic/size.hpp)\n# include BOOST_INCLUDE_PATH(vmd/is_empty.hpp)\n# include BOOST_INCLUDE_PATH(vmd/is_tuple.hpp)\n\n#endif // defined(ARCH_OS_WINDOWS)\n\n#include BOOST_INCLUDE_PATH(any.hpp)\n#include BOOST_INCLUDE_PATH(call_traits.hpp)\n#include BOOST_INCLUDE_PATH(function.hpp)\n#include BOOST_INCLUDE_PATH(functional/hash_fwd.hpp)\n#include BOOST_INCLUDE_PATH(intrusive_ptr.hpp)\n#include BOOST_INCLUDE_PATH(mpl/empty.hpp)\n#include BOOST_INCLUDE_PATH(mpl/front.hpp)\n#include BOOST_INCLUDE_PATH(mpl/if.hpp)\n#include BOOST_INCLUDE_PATH(mpl/pop_front.hpp)\n#include BOOST_INCLUDE_PATH(mpl/remove.hpp)\n#include BOOST_INCLUDE_PATH(mpl/vector.hpp)\n#include BOOST_INCLUDE_PATH(noncopyable.hpp)\n#include BOOST_INCLUDE_PATH(operators.hpp)\n#include BOOST_INCLUDE_PATH(optional.hpp)\n#include BOOST_INCLUDE_PATH(preprocessor/arithmetic/add.hpp)\n#include BOOST_INCLUDE_PATH(preprocessor/arithmetic/inc.hpp)\n#include BOOST_INCLUDE_PATH(preprocessor/arithmetic/sub.hpp)\n#include BOOST_INCLUDE_PATH(preprocessor/cat.hpp)\n#include BOOST_INCLUDE_PATH(preprocessor/comparison/equal.hpp)\n#include BOOST_INCLUDE_PATH(preprocessor/control/expr_iif.hpp)\n#include BOOST_INCLUDE_PATH(preprocessor/control/iif.hpp)\n#include BOOST_INCLUDE_PATH(preprocessor/facilities/expand.hpp)\n#include BOOST_INCLUDE_PATH(preprocessor/logical/and.hpp)\n#include BOOST_INCLUDE_PATH(preprocessor/logical/not.hpp)\n#include BOOST_INCLUDE_PATH(preprocessor/punctuation/comma.hpp)\n#include BOOST_INCLUDE_PATH(preprocessor/punctuation/comma_if.hpp)\n#include BOOST_INCLUDE_PATH(preprocessor/punctuation/paren.hpp)\n#include BOOST_INCLUDE_PATH(preprocessor/repetition/repeat.hpp)\n#include BOOST_INCLUDE_PATH(preprocessor/seq/filter.hpp)\n#include BOOST_INCLUDE_PATH(preprocessor/seq/for_each.hpp)\n#include BOOST_INCLUDE_PATH(preprocessor/seq/for_each_i.hpp)\n#include BOOST_INCLUDE_PATH(preprocessor/seq/push_back.hpp)\n#include BOOST_INCLUDE_PATH(preprocessor/seq/size.hpp)\n#include BOOST_INCLUDE_PATH(preprocessor/stringize.hpp)\n#include BOOST_INCLUDE_PATH(preprocessor/tuple/eat.hpp)\n#include BOOST_INCLUDE_PATH(preprocessor/tuple/elem.hpp)\n#include BOOST_INCLUDE_PATH(preprocessor/tuple/to_list.hpp)\n#include BOOST_INCLUDE_PATH(preprocessor/tuple/to_seq.hpp)\n#include BOOST_INCLUDE_PATH(scoped_ptr.hpp)\n#include BOOST_INCLUDE_PATH(shared_ptr.hpp)\n#include BOOST_INCLUDE_PATH(type_traits/is_base_of.hpp)\n#include BOOST_INCLUDE_PATH(type_traits/is_const.hpp)\n#include BOOST_INCLUDE_PATH(type_traits/is_convertible.hpp)\n#include BOOST_INCLUDE_PATH(type_traits/is_enum.hpp)\n#include BOOST_INCLUDE_PATH(type_traits/is_same.hpp)\n#include BOOST_INCLUDE_PATH(unordered_map.hpp)\n#include BOOST_INCLUDE_PATH(utility/enable_if.hpp)\n#include BOOST_INCLUDE_PATH(weak_ptr.hpp)\n\n#include <algorithm>\n#include <atomic>\n#include <cmath>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <inttypes.h>\n#include <iosfwd>\n#include <iterator>\n#include <list>\n#include <map>\n#include <math.h>\n#include <memory>\n#include <mutex>\n#include <set>\n#include <sstream>\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <string>\n#include <sys/types.h>\n#include <type_traits>\n#include <typeindex>\n#include <typeinfo>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n#include <tbb/atomic.h>",
			"file": "src/USD/hdLava/pch.h",
			"file_size": 5431,
			"file_write_time": 132421710116339922,
			"settings":
			{
				"buffer_size": 5431,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "/************************************************************************\nCopyright 2020 Advanced Micro Devices, Inc\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n************************************************************************/\n\n#ifndef BOOST_INCLUDE_PATH_H\n#define BOOST_INCLUDE_PATH_H\n\n#define __STRINGIZE_PATHX(x) #x\n#define __STRINGIZE_PATH(x) __STRINGIZE_PATHX(x)\n\n#ifdef BUILD_AS_HOUDINI_PLUGIN\n# define BOOST_NS hboost\n# define BOOST_INCLUDE_PATH(suffix) __STRINGIZE_PATH(hboost/suffix)\n#else\n# define BOOST_NS boost\n# define BOOST_INCLUDE_PATH(suffix) __STRINGIZE_PATH(boost/suffix)\n#endif\n\n#endif // BOOST_INCLUDE_PATH_H",
			"file": "src/USD/hdLava/boostIncludePath.h",
			"file_size": 1114,
			"file_write_time": 132421710441614606,
			"settings":
			{
				"buffer_size": 1114,
				"line_ending": "Unix",
				"name": "/*************************************************"
			}
		},
		{
			"contents": "{\n    \"Plugins\": [\n        {\n            \"Info\": {\n                \"Types\": {\n                    \"HdLavaRendererPlugin\": {\n                        \"bases\": [\n                            \"HdRendererPlugin\"\n                        ],\n                        \"displayName\": \"Lava\",\n                        \"priority\": 99\n                    }\n                }\n            },\n            \"LibraryPath\": \"@PLUG_INFO_LIBRARY_PATH@\",\n            \"Name\": \"hdLava\",\n            \"ResourcePath\": \"@PLUG_INFO_RESOURCE_PATH@\",\n            \"Root\": \"@PLUG_INFO_ROOT@\",\n            \"Type\": \"library\"\n        }\n    ]\n}\n",
			"file": "src/USD/hdLava/plugInfo.json",
			"file_size": 604,
			"file_write_time": 132419139651865547,
			"settings":
			{
				"buffer_size": 604,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#ifndef HDLAVA_RENDER_PASS_H_\n#define HDLAVA_RENDER_PASS_H_\n\n#include \"pxr/imaging/hd/renderPass.h\"\n\n#include \"rprApi.h\"\n\nPXR_NAMESPACE_OPEN_SCOPE\n\nclass HdLavaRenderParam;\n\nclass HdLavaRenderPass final : public HdRenderPass {\npublic:\n    HdLavaRenderPass(HdRenderIndex* index,\n                    HdLavaimCollection const& collection,\n                    HdLavaRenderParam* renderParam);\n\n    ~HdLavaRenderPass() override = default;\n\n    bool IsConverged() const override;\n\n    void _Execute(HdRenderPassStateSharedPtr const& renderPassState,\n                  TfTokenVector const& renderTags) override;\n\nprivate:\n    HdLavaRenderParam* m_renderParam;\n};\n\nPXR_NAMESPACE_CLOSE_SCOPE\n#endif // HDLAVA_RENDER_PASS_H_\n",
			"file": "src/USD/hdLava/renderPass.h",
			"file_size": 715,
			"file_write_time": 132421713177530251,
			"settings":
			{
				"buffer_size": 715,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#include \"renderPass.h\"\n#include \"renderDelegate.h\"\n#include \"config.h\"\n#include \"rprApi.h\"\n#include \"renderBuffer.h\"\n#include \"renderParam.h\"\n\n#include \"pxr/imaging/hd/renderPassState.h\"\n#include \"pxr/imaging/hd/renderIndex.h\"\n\n#include <GL/glew.h>\n\nPXR_NAMESPACE_OPEN_SCOPE\n\nHdLavaRenderPass::HdLavaRenderPass(HdRenderIndex* index, HdLavaimCollection const& collection, HdLavaRenderParam* renderParam)\n    : HdRenderPass(index, collection)\n    , m_renderParam(renderParam) {\n\n}\n\nvoid HdLavaRenderPass::_Execute(HdRenderPassStateSharedPtr const& renderPassState, TfTokenVector const& renderTags) {\n    // To avoid potential deadlock:\n    //   main thread locks config instance and requests render stop and\n    //   in the same time render thread trying to lock config instance to update its settings.\n    // We should release config instance lock before requesting render thread to stop.\n    // It could be solved in another way by using shared_mutex and\n    // marking current write-lock as read-only after successful config->Sync\n    // in such a way main and render threads would have read-only-locks that could coexist\n    bool stopRender = false;\n    {\n        HdLavaConfig* config;\n        auto configInstanceLock = HdLavaConfig::GetInstance(&config);\n        config->Sync(GetRenderIndex()->GetRenderDelegate());\n        if (config->IsDirty(HdLavaConfig::DirtyAll)) {\n            stopRender = true;\n        }\n    }\n    if (stopRender) {\n        m_renderParam->GetRenderThread()->StopRender();\n    }\n\n    auto rprApiConst = m_renderParam->GetRprApi();\n\n    auto& vp = renderPassState->GetViewport();\n    GfVec2i newViewportSize(static_cast<int>(vp[2]), static_cast<int>(vp[3]));\n    auto oldViewportSize = rprApiConst->GetViewportSize();\n    if (oldViewportSize != newViewportSize) {\n        m_renderParam->AcquireRprApiForEdit()->SetViewportSize(newViewportSize);\n    }\n\n    if (rprApiConst->GetAovBindings() != renderPassState->GetAovBindings()) {\n        m_renderParam->AcquireRprApiForEdit()->SetAovBindings(renderPassState->GetAovBindings());\n    }\n\n    if (rprApiConst->GetCamera() != renderPassState->GetCamera()) {\n        m_renderParam->AcquireRprApiForEdit()->SetCamera(renderPassState->GetCamera());\n    }\n\n    if (rprApiConst->IsChanged() ||\n        m_renderParam->IsRenderShouldBeRestarted()) {\n        for (auto& aovBinding : renderPassState->GetAovBindings()) {\n            if (aovBinding.renderBuffer) {\n                auto rprRenderBuffer = static_cast<HdLavaRenderBuffer*>(aovBinding.renderBuffer);\n                rprRenderBuffer->SetConverged(false);\n            }\n        }\n        m_renderParam->GetRenderThread()->StartRender();\n    }\n}\n\nbool HdLavaRenderPass::IsConverged() const {\n    for (auto& aovBinding : m_renderParam->GetRprApi()->GetAovBindings()) {\n        if (aovBinding.renderBuffer &&\n            !aovBinding.renderBuffer->IsConverged()) {\n            return false;\n        }\n    }\n    return true;\n}\n\nPXR_NAMESPACE_CLOSE_SCOPE",
			"file": "src/USD/hdLava/renderPass.cpp",
			"file_size": 2970,
			"file_write_time": 132421719418630456,
			"settings":
			{
				"buffer_size": 2970,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#ifndef HDLAVA_RENDER_PARAM_H_\n#define HDLAVA_RENDER_PARAM_H_\n\n#include \"renderThread.h\"\n\n#include \"pxr/imaging/hd/renderDelegate.h\"\n\nPXR_NAMESPACE_OPEN_SCOPE\n\n#define HDLAVA_MATERIAL_NETWORK_SELECTOR_TOKENS \\\n    (rpr) \\\n    (karma)\n\nTF_DECLARE_PUBLIC_TOKENS(HdLavaMaterialNetworkSelectorTokens, HDLAVA_MATERIAL_NETWORK_SELECTOR_TOKENS);\n\nclass HdLavaApi;\nclass HdLavaVolume;\n\nusing HdLavaVolumeFieldSubscription = std::shared_ptr<HdLavaVolume>;\nusing HdLavaVolumeFieldSubscriptionHandle = std::weak_ptr<HdLavaVolume>;\n\nclass HdLavaRenderParam final : public HdRenderParam {\npublic:\n    HdLavaRenderParam(HdLavaApi* rprApi, HdLavaRenderThread* renderThread)\n        : m_rprApi(rprApi)\n        , m_renderThread(renderThread) {\n        m_numLights.store(0);\n        InitializeEnvParameters();\n    }\n    ~HdLavaRenderParam() override = default;\n\n    HdLavaApi const* GetRprApi() const { return m_rprApi; }\n    HdLavaApi* AcquireRprApiForEdit() {\n        m_renderThread->StopRender();\n        return m_rprApi;\n    }\n\n    HdLavaRenderThread* GetRenderThread() { return m_renderThread; }\n\n    void AddLight() { ++m_numLights; }\n    void RemoveLight() { --m_numLights; }\n    bool HasLights() const { return m_numLights != 0; }\n\n    TfToken const& GetMaterialNetworkSelector() const { return m_materialNetworkSelector; }\n\n    // Hydra does not mark HdVolume as changed if HdField used by it is changed\n    // We implement this volume-to-field dependency by ourself until it's implemented in Hydra\n    // More info: https://groups.google.com/forum/#!topic/usd-interest/pabUE0B_5X4\n    \n    //HdLavaVolumeFieldSubscription SubscribeVolumeForFieldUpdates(HdLavaVolume* volume, SdfPath const& fieldId);\n    //void NotifyVolumesAboutFieldChange(HdSceneDelegate* sceneDelegate, SdfPath const& fieldId);\n\n    void RestartRender() { m_restartRender.store(true); }\n    bool IsRenderShouldBeRestarted() { return m_restartRender.exchange(false); }\n\nprivate:\n    void InitializeEnvParameters();\n\n    HdLavaApi* m_rprApi;\n    HdLavaRenderThread* m_renderThread;\n\n    std::atomic<uint32_t> m_numLights;\n\n    TfToken m_materialNetworkSelector;\n\n    std::mutex m_subscribedVolumesMutex;\n    std::map<SdfPath, std::vector<HdLavaVolumeFieldSubscriptionHandle>> m_subscribedVolumes;\n\n    std::atomic<bool> m_restartRender;\n};\n\nPXR_NAMESPACE_CLOSE_SCOPE\n\n#endif // HDLAVA_RENDER_PARAM_H_\n",
			"file": "src/USD/hdLava/renderParam.h",
			"file_size": 2361,
			"file_write_time": 132422376645230261,
			"settings":
			{
				"buffer_size": 2361,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#include \"renderParam.h\"\n//#include \"volume.h\"\n\n#include \"pxr/base/tf/envSetting.h\"\n\n#include \"pxr/imaging/hd/sceneDelegate.h\"\n\nPXR_NAMESPACE_OPEN_SCOPE\n\nTF_DEFINE_PUBLIC_TOKENS(HdLavaMaterialNetworkSelectorTokens, HDLAVA_MATERIAL_NETWORK_SELECTOR_TOKENS);\n\nTF_DEFINE_ENV_SETTING(HDLAVA_MATERIAL_NETWORK_SELECTOR, HDLAVA_DEFAULT_MATERIAL_NETWORK_SELECTOR,\n        \"Material network selector to be used in hdRpr\");\n\n/*\nvoid HdLavaRenderParam::InitializeEnvParameters() {\n    m_materialNetworkSelector = TfToken(TfGetEnvSetting(HDLAVA_MATERIAL_NETWORK_SELECTOR));\n}\n\nHdLavaVolumeFieldSubscription HdLavaRenderParam::SubscribeVolumeForFieldUpdates(\n    HdLavaVolume* volume, SdfPath const& fieldId) {\n    auto sub = HdLavaVolumeFieldSubscription(volume, [](HdLavaVolume* volume) {});\n    {\n        std::lock_guard<std::mutex> lock(m_subscribedVolumesMutex);\n        m_subscribedVolumes[fieldId].push_back(std::move(sub));\n    }\n    return sub;\n}\n*/\n\nvoid HdLavaRenderParam::NotifyVolumesAboutFieldChange(HdSceneDelegate* sceneDelegate, SdfPath const& fieldId) {\n    std::lock_guard<std::mutex> lock(m_subscribedVolumesMutex);\n    for (auto subscriptionsIt = m_subscribedVolumes.begin();\n         subscriptionsIt != m_subscribedVolumes.end();) {\n        auto& subscriptions = subscriptionsIt->second;\n        for (size_t i = 0; i < subscriptions.size(); ++i) {\n            if (auto volume = subscriptions[i].lock()) {\n                // Force HdVolume Sync\n                sceneDelegate->GetRenderIndex().GetChangeTracker().MarkRprimDirty(volume->GetId(), HdChangeTracker::DirtyTopology);\n\n                // Possible Optimization: notify volume about exact changed field\n                // Does not make sense right now because Hydra removes and creates\n                // from scratch all HdFields whenever one of them is changed (e.g added/removed/edited primvar)\n                // (USD 20.02)\n            } else {\n                std::swap(subscriptions[i], subscriptions.back());\n                subscriptions.pop_back();\n            }\n        }\n        if (subscriptions.empty()) {\n            subscriptionsIt = m_subscribedVolumes.erase(subscriptionsIt);\n        } else {\n            ++subscriptionsIt;\n        }\n    }\n}\n\nPXR_NAMESPACE_CLOSE_SCOPE",
			"file": "src/USD/hdLava/renderParam.cpp",
			"file_size": 2251,
			"file_write_time": 132422386375376008,
			"settings":
			{
				"buffer_size": 2251,
				"line_ending": "Unix",
				"name": "/*************************************************"
			}
		},
		{
			"contents": "#include <string>\n\n#include \"pxr/base/tf/diagnostic.h\"\n#include \"pxr/imaging/hgi/graphicsEncoderDesc.h\"\n\n#include \"USD/hgiVk/commandBuffer.h\"\n#include \"USD/hgiVk/commandPool.h\"\n#include \"USD/hgiVk/blitEncoder.h\"\n#include \"USD/hgiVk/device.h\"\n#include \"USD/hgiVk/diagnostic.h\"\n#include \"USD/hgiVk/graphicsEncoder.h\"\n#include \"USD/hgiVk/hgi.h\"\n#include \"USD/hgiVk/renderPass.h\"\n#include \"USD/hgiVk/texture.h\"\n#include \"USD/hgiVk/vulkan.h\"\n\n\nPXR_NAMESPACE_OPEN_SCOPE\n\n\nHgiVkCommandBuffer::HgiVkCommandBuffer(\n    HgiVkDevice* device,\n    HgiVkCommandPool* commandPool,\n    HgiVkCommandBufferUsage usage)\n    : _device(device)\n    , _commandPool(commandPool)\n    , _usage(usage)\n    , _isRecording(false)\n    , _vkCommandBuffer(nullptr)\n    , _vkTimeStampQueryPool(nullptr)\n    , _timeQueriesReset(false)\n{\n    //\n    // Create command buffer\n    //\n    VkCommandBufferAllocateInfo allocateInfo =\n        {VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO};\n\n    allocateInfo.commandBufferCount = 1;\n    allocateInfo.commandPool = _commandPool->GetVulkanCommandPool();\n    allocateInfo.level = _usage==HgiVkCommandBufferUsagePrimary ?\n        VK_COMMAND_BUFFER_LEVEL_PRIMARY :\n        VK_COMMAND_BUFFER_LEVEL_SECONDARY;\n\n    TF_VERIFY(\n        vkAllocateCommandBuffers(\n            device->GetVulkanDevice(),\n            &allocateInfo,\n            &_vkCommandBuffer) == VK_SUCCESS\n    );\n\n    //\n    // TimeStamp query pool\n    //\n    if (_device->GetDeviceSupportTimeStamps()) {\n        _timeQueries.reserve(HGIVK_MAX_TIMESTAMPS/2);\n\n        VkQueryPoolCreateInfo queryPoolInfo =\n            {VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO};\n\n        queryPoolInfo.queryType = VK_QUERY_TYPE_TIMESTAMP;\n        queryPoolInfo.queryCount = HGIVK_MAX_TIMESTAMPS;\n        TF_VERIFY(\n            vkCreateQueryPool(\n                _device->GetVulkanDevice(),\n                &queryPoolInfo,\n                HgiVkAllocator(),\n                &_vkTimeStampQueryPool) == VK_SUCCESS\n        );\n    }\n}\n\nHgiVkCommandBuffer::~HgiVkCommandBuffer()\n{\n    // Prevent vulkan validation from warning that we are destroying a\n    // command buffer that is being recorded into.\n    EndRecording();\n\n    if (_vkTimeStampQueryPool) {\n       vkDestroyQueryPool(\n            _device->GetVulkanDevice(),\n            _vkTimeStampQueryPool,\n            HgiVkAllocator());\n    }\n\n    vkFreeCommandBuffers(\n        _device->GetVulkanDevice(),\n        _commandPool->GetVulkanCommandPool(),\n        1, // command buffer cnt\n        &_vkCommandBuffer);\n}\n\nvoid\nHgiVkCommandBuffer::SetRenderPass(HgiVkRenderPass* rp)\n{\n    _vkInheritanceInfo =\n        {VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO};\n    _vkInheritanceInfo.renderPass = rp->GetVulkanRenderPass();\n    _vkInheritanceInfo.framebuffer = rp->GetVulkanFramebuffer();\n}\n\nvoid\nHgiVkCommandBuffer::EndRecording()\n{\n    if (_isRecording) {\n        TF_VERIFY(\n            vkEndCommandBuffer(_vkCommandBuffer) == VK_SUCCESS\n        );\n\n        // Next frame this command buffer may be used by an entirely different\n        // encoder, so clear the render pass info for secondary command buffers.\n        _vkInheritanceInfo.renderPass = nullptr;\n        _vkInheritanceInfo.framebuffer = nullptr;\n\n        _isRecording = false;\n        _timeQueriesReset = false;\n    }\n}\n\nbool\nHgiVkCommandBuffer::IsRecording() const\n{\n    return _isRecording;\n}\n\nVkCommandBuffer\nHgiVkCommandBuffer::GetCommandBufferForRecoding()\n{\n    _BeginRecording();\n    return _vkCommandBuffer;\n}\n\nVkCommandBuffer\nHgiVkCommandBuffer::GetVulkanCommandBuffer() const\n{\n    return _vkCommandBuffer;\n}\n\nvoid\nHgiVkCommandBuffer::SetDebugName(const char* name)\n{\n    std::string debugLabel = \"Command Buffer \" + std::string(name);\n    HgiVkSetDebugName(\n        _device,\n        (uint64_t)_vkCommandBuffer,\n        VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT,\n        debugLabel.c_str());\n\n    if (_vkTimeStampQueryPool) {\n        debugLabel = \"Query Pool \" + std::string(name);\n        HgiVkSetDebugName(\n            _device,\n            (uint64_t)_vkTimeStampQueryPool,\n            VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT,\n            debugLabel.c_str());\n    }\n}\n\nvoid\nHgiVkCommandBuffer::PushTimeQuery(const char* name)\n{\n    if (!_vkTimeStampQueryPool || !_timeQueriesReset) return;\n\n    if (!TF_VERIFY(_timeQueries.size() < HGIVK_MAX_TIMESTAMPS/2,\n                   \"TimeStamp overflow\")) {\n        return;\n   }\n\n   _BeginRecording();\n\n    // Reserve two time stamps, one for start, one for end.\n    HgiTimeQuery query;\n    query.beginStamp = _timeQueries.size() * 2;\n    query.endStamp = 0; // zero until stamp is ended!\n    query.name = name;\n\n    // XXX to more precisely measure the performance of e.g. a compute shader it\n    // could be interesting to use COMPUTE_SHADER_BIT here or other shader bits.\n    // PopTimeQuery would also use COMPUTE_SHADER_BIT.\n\n    vkCmdWriteTimestamp(\n        _vkCommandBuffer,\n        VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,\n        _vkTimeStampQueryPool,\n        query.beginStamp);\n\n    _timeQueries.emplace_back(std::move(query));\n}\n\nvoid\nHgiVkCommandBuffer::PopTimeQuery()\n{\n    if (!_vkTimeStampQueryPool || !_timeQueriesReset) return;\n\n    if (!TF_VERIFY(!_timeQueries.empty(), \"Timestamp stack invalid\")) return;\n\n    // Find the last pushed, but not popped stamp.\n    // We know a query not popped yet if its 'endStamp' is set to zero.\n    HgiTimeQuery* query = nullptr;\n\n    for (size_t i=_timeQueries.size(); i-- > 0;) {\n        if (_timeQueries[i].endStamp == 0) {\n            query = &_timeQueries[i];\n            break;\n        }\n    }\n\n    if (TF_VERIFY(query)) {\n        // flag this time query as 'popped'\n        query->endStamp = query->beginStamp + 1;\n\n        vkCmdWriteTimestamp(\n            _vkCommandBuffer,\n            VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,\n            _vkTimeStampQueryPool,\n            query->endStamp);\n    }\n}\n\nHgiTimeQueryVector const&\nHgiVkCommandBuffer::GetTimeQueries()\n{\n    if (!_vkTimeStampQueryPool) return _timeQueries;\n\n    VkPhysicalDeviceProperties const& p =\n        _device->GetVulkanPhysicalDeviceProperties();\n    float toNanoSec = p.limits.timestampPeriod;\n\n    uint32_t data[2] = {};\n\n    // XXX On APPLE (MoltenVk) I believe the time queries happen at cmd buf\n    // boundaries. This means both our begin and end stamps will have the\n    // same value, which will produces 0.0.\n    // https://github.com/KhronosGroup/MoltenVK/issues/520\n\n    for (HgiTimeQuery& query : _timeQueries) {\n        vkGetQueryPoolResults(\n            _device->GetVulkanDevice(),\n            _vkTimeStampQueryPool,\n            query.beginStamp,\n            2,\n            sizeof(uint32_t) * 2,\n            data,\n            sizeof(uint32_t),\n            VK_QUERY_RESULT_WAIT_BIT);\n\n        uint32_t diff = data[1] - data[0];\n        query.nanoSeconds = diff * p.limits.timestampPeriod;\n    }\n\n    return _timeQueries;\n}\n\nvoid\nHgiVkCommandBuffer::ResetTimeQueries(HgiVkCommandBuffer* cb)\n{\n    if (!_vkTimeStampQueryPool) return;\n\n    // Reset time stamps - Timestamps must be reset before they can be used.\n    // In vulkan 1.0 this must be recorded in a command buffer (how fun!).\n    // We use the provided (primary) command buffer, because we don't want to\n    // start each command buffer (incl secondary cmd bufs) if they aren't needed\n    // by a thread. So we record all resets into one single command buffer.\n\n    // XXX VK_KHR_performance_query can do it on a device level, which would fit\n    // our design much better. But, for now, it is not that well supported.\n\n    vkCmdResetQueryPool(\n        cb->GetCommandBufferForRecoding(), // Don't use internal cmd buf!\n        _vkTimeStampQueryPool,\n        0, // first time stamp\n        HGIVK_MAX_TIMESTAMPS);\n\n    _timeQueries.clear();\n    _timeQueriesReset = true;\n}\n\nvoid\nHgiVkCommandBuffer::_BeginRecording()\n{\n    if (!_isRecording) {\n\n        VkCommandBufferBeginInfo beginInfo =\n            {VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO};\n        beginInfo.flags |= VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;\n\n        if (_usage == HgiVkCommandBufferUsageSecondaryRenderPass) {\n            beginInfo.flags |= VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT;\n            beginInfo.pInheritanceInfo = &_vkInheritanceInfo;\n        }\n\n        // Begin recording\n        TF_VERIFY(\n            vkBeginCommandBuffer(_vkCommandBuffer, &beginInfo) == VK_SUCCESS\n        );\n\n        _isRecording = true;\n    }\n}\n\nPXR_NAMESPACE_CLOSE_SCOPE\n",
			"file": "src/USD/hgiVk/commandBuffer.cpp",
			"file_size": 8461,
			"file_write_time": 132398945182576787,
			"settings":
			{
				"buffer_size": 8461,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#include \"pxr/base/tf/diagnostic.h\"\n#include \"USD/hgiVk/commandBufferManager.h\"\n#include \"USD/hgiVk/device.h\"\n#include \"USD/hgiVk/diagnostic.h\"\n#include \"USD/hgiVk/hgi.h\"\n#include \"USD/hgiVk/vulkan.h\"\n\n\nPXR_NAMESPACE_OPEN_SCOPE\n\nthread_local uint16_t _HgiVkcmdBufThreadLocalIndex = 0;\nthread_local uint64_t _HgiVkcmdBufThreadLocalFrame = ~0ull;\n\n\nHgiVkCommandBufferManager::HgiVkCommandBufferManager(HgiVkDevice* device)\n    : _device(device)\n    , _frame(~0ull)\n    , _nextAvailableIndex(0)\n    , _parallelEncoderCounter(0)\n    , _vkSemaphore(nullptr)\n{\n    //\n    // Create semaphore for gpu-gpu synchronization\n    //\n    VkSemaphoreCreateInfo semaCreateInfo =\n        {VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO};\n\n    TF_VERIFY(\n        vkCreateSemaphore(\n            _device->GetVulkanDevice(),\n            &semaCreateInfo,\n            HgiVkAllocator(),\n            &_vkSemaphore) == VK_SUCCESS\n    );\n}\n\nHgiVkCommandBufferManager::~HgiVkCommandBufferManager()\n{\n    // Destroy command buffers\n    auto deleteCmdBufsFn = [](HgiVkCommandBufferVector& v) -> void {\n        for (HgiVkCommandBuffer* cb : v) {\n            delete cb;\n        }\n    };\n\n    deleteCmdBufsFn(_resourceCommandBuffers);\n    deleteCmdBufsFn(_drawCommandBuffers);\n    deleteCmdBufsFn(_secondaryDrawCommandBuffers);\n\n    for (HgiVkCommandPool* cp : _commandPools) {\n        delete cp;\n    }\n\n    vkDestroySemaphore(\n        _device->GetVulkanDevice(),\n        _vkSemaphore, HgiVkAllocator());\n}\n\nvoid\nHgiVkCommandBufferManager::BeginFrame(uint64_t frame)\n{\n    // Change the frame counter. This will let each thread know that they\n    // must re-initializes themselves the next time the thread wants to use\n    // the command buffers. They know this by comparing the frame they stored\n    // thread-locally with _frame. If the number does not match the threads re-\n    // acquire the thread's command buffer.\n    _frame = frame;\n\n    // Collect all time queries from previous run before resetting.\n    _timeQueries.clear();\n\n    auto mergeQueriesFn = [this](HgiVkCommandBufferVector const& v) -> void {\n        for (HgiVkCommandBuffer* cb : v) {\n            if (!cb) continue;\n            HgiTimeQueryVector const& q = cb->GetTimeQueries();\n            _timeQueries.insert(_timeQueries.end(), q.begin(), q.end());\n        }\n    };\n\n    mergeQueriesFn(_resourceCommandBuffers);\n    mergeQueriesFn(_drawCommandBuffers);\n    mergeQueriesFn(_secondaryDrawCommandBuffers);\n\n\n    // Reset all command pools of the frame to re-use the command buffers.\n    for (HgiVkCommandPool* cp : _commandPools) {\n        cp->ResetCommandPool();\n    }\n\n    // Make sure there are enough command buffers and pools. One per thread.\n    _CreatePoolsAndBuffers();\n\n    // Reset all time queries for all available command buffers.\n    // We do this here instead of in HgiVkCommandBuffer::_BeginRecording,\n    // because this reset must happen before any render pass is started.\n    // Secondary command buffers are created on-demand so they may not be ready\n    // yet. As a consequence they will not be able to record time stamps until\n    // a few frames after they have been created.\n    HgiVkCommandBuffer* primaryCB = GetResourceCommandBuffer();\n\n    auto resetQueriesFn = [this, primaryCB](HgiVkCommandBufferVector const& v) {\n        for (HgiVkCommandBuffer* cb : v) {\n            if (!cb) continue;\n            cb->ResetTimeQueries(primaryCB);\n        }\n    };\n\n    resetQueriesFn(_resourceCommandBuffers);\n    resetQueriesFn(_drawCommandBuffers);\n    resetQueriesFn(_secondaryDrawCommandBuffers);\n}\n\nvoid\nHgiVkCommandBufferManager::EndFrame(VkFence fence)\n{\n    // Build a list of all resource command buffers to submit.\n    std::vector<VkCommandBuffer> resourceCmds;\n    resourceCmds.reserve(_resourceCommandBuffers.size());\n\n    for (HgiVkCommandBuffer* cb : _resourceCommandBuffers) {\n        if (cb->IsRecording()) {\n            cb->EndRecording();\n            resourceCmds.push_back(cb->GetVulkanCommandBuffer());\n        }\n    }\n\n    // Build a list of all draw command buffers to submit.\n    std::vector<VkCommandBuffer> drawCmds;\n    drawCmds.reserve(_drawCommandBuffers.size());\n\n    for (HgiVkCommandBuffer* cb : _drawCommandBuffers) {\n        if (cb->IsRecording()) {\n            cb->EndRecording();\n            drawCmds.push_back(cb->GetVulkanCommandBuffer());\n        }\n    }\n\n    // We submit resource cmds followed by draw cmds.\n    // The draw cmds wait for the resource cmds to signal a semaphore so that\n    // all resources are in the correct state before draw cmds use them.\n    std::vector<VkSubmitInfo> submitInfos;\n\n    if (!resourceCmds.empty()) {\n        VkSubmitInfo resourceInfo = {VK_STRUCTURE_TYPE_SUBMIT_INFO};\n        resourceInfo.commandBufferCount = (uint32_t) resourceCmds.size();\n        resourceInfo.pCommandBuffers = resourceCmds.data();\n        if (!drawCmds.empty()) {\n            resourceInfo.signalSemaphoreCount = 1;\n            resourceInfo.pSignalSemaphores = &_vkSemaphore;\n        }\n        submitInfos.emplace_back(std::move(resourceInfo));\n    }\n\n    if (!drawCmds.empty()) {\n        VkSubmitInfo drawInfo = {VK_STRUCTURE_TYPE_SUBMIT_INFO};\n        drawInfo.commandBufferCount = (uint32_t) drawCmds.size();\n        drawInfo.pCommandBuffers = drawCmds.data();\n        if (!resourceCmds.empty()) {\n            drawInfo.waitSemaphoreCount = 1;\n            drawInfo.pWaitSemaphores = &_vkSemaphore;\n            VkPipelineStageFlags waitMask = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;\n            drawInfo.pWaitDstStageMask = &waitMask;\n        }\n        submitInfos.emplace_back(std::move(drawInfo));\n    }\n\n    // Commit all recorded resource and draw commands from all threads.\n    _device->SubmitToQueue(submitInfos, fence);\n\n    // Next frame's threads must re-acquire a command buffer, so reset index.\n    // (Same applies to parallel encoders)\n    _nextAvailableIndex.store(0);\n    _parallelEncoderCounter = 0;\n}\n\nHgiVkCommandBuffer*\nHgiVkCommandBufferManager::GetResourceCommandBuffer()\n{\n    /* MULTI-THREAD CALL*/\n\n    // First ensure this thread has an unique index into the cmd buffer vector.\n    _UpdateThreadLocalIndex();\n\n    if (_HgiVkcmdBufThreadLocalIndex >= _resourceCommandBuffers.size()) {\n        TF_CODING_ERROR(\"cmdBuf numThreads > HgiVk::GetThreadCount\");\n        _HgiVkcmdBufThreadLocalIndex = 0;\n    }\n\n    return _resourceCommandBuffers[_HgiVkcmdBufThreadLocalIndex];\n}\n\nHgiVkCommandBuffer*\nHgiVkCommandBufferManager::GetDrawCommandBuffer()\n{\n    /* MULTI-THREAD CALL*/\n\n    // First ensure this thread has an unique index into the cmd buffer vector.\n    _UpdateThreadLocalIndex();\n\n    if (_HgiVkcmdBufThreadLocalIndex >= _drawCommandBuffers.size()) {\n        TF_CODING_ERROR(\"cmdBuf numThreads > HgiVk::GetThreadCount\");\n        _HgiVkcmdBufThreadLocalIndex = 0;\n    }\n\n    return _drawCommandBuffers[_HgiVkcmdBufThreadLocalIndex];\n}\n\nsize_t\nHgiVkCommandBufferManager::ReserveSecondaryDrawBuffersForParallelEncoder()\n{\n    size_t index = _parallelEncoderCounter;\n    _parallelEncoderCounter++;\n\n    unsigned numThreads = HgiVk::GetThreadCount();\n    size_t currentSize = _secondaryDrawCommandBuffers.size();\n    size_t requiredSize = _parallelEncoderCounter*numThreads;\n\n    if (requiredSize > currentSize) {\n        // Important! We only make room for the extra command buffers, but we do\n        // not allocate them until GetSecondaryDrawCommandBuffer().\n        // We need to wait until we can be sure the thread has exclusive access\n        // to the command pool that will allocate the new command buffer!\n        // We can't be fully sure of that here. There may be another thread that\n        // is currently doing rendering work (e.g. UI thread).\n        // So why make room now? Because the parallel encoder calls this\n        // before any threading has started, so we can safely resize the vector.\n        // During GetSecondaryDrawCommandBuffer we will be wide and shouldn't\n        // change the size of the vector.\n        _secondaryDrawCommandBuffers.resize(requiredSize, nullptr);\n    }\n\n    return index;\n}\n\nHgiVkCommandBuffer*\nHgiVkCommandBufferManager::GetSecondaryDrawCommandBuffer(size_t id)\n{\n    /* MULTI-THREAD CALL*/\n\n    // First ensure this thread has an unique index into the cmd buffer vector.\n    _UpdateThreadLocalIndex();\n\n    if (_HgiVkcmdBufThreadLocalIndex >= _secondaryDrawCommandBuffers.size()) {\n        TF_CODING_ERROR(\"cmdBuf numThreads > HgiVk::GetThreadCount\");\n        _HgiVkcmdBufThreadLocalIndex = 0;\n    }\n\n    unsigned numThreads = HgiVk::GetThreadCount();\n    size_t offset = (id * numThreads) + _HgiVkcmdBufThreadLocalIndex;\n    TF_VERIFY(offset < _secondaryDrawCommandBuffers.size());\n\n    // If we didn't make the secondary command buffer yet, do so now.\n    if (!_secondaryDrawCommandBuffers[offset]) {\n\n        // Important! make sure we always use the same command pool at the\n        // same vector index as resource and draw primary command buffers.\n        // A threadpool cannot be used by two different threads at the same\n        // time. So if a draw command buffer is used by thread-N that same\n        // thread-N can only use secondary command buffers that were also\n        // created by that same thread pool.\n        HgiVkCommandPool* cp = _commandPools[_HgiVkcmdBufThreadLocalIndex];\n\n        HgiVkCommandBuffer* cb = new HgiVkCommandBuffer(\n            _device,\n            cp,\n            HgiVkCommandBufferUsageSecondaryRenderPass);\n\n        std::string debugLabel = \"Secondary \" + _debugName;\n        cb->SetDebugName(debugLabel.c_str());\n\n        _secondaryDrawCommandBuffers[offset] = cb;\n    }\n\n    return _secondaryDrawCommandBuffers[offset];\n}\n\nvoid\nHgiVkCommandBufferManager::ExecuteSecondaryCommandBuffers(\n    size_t id,\n    HgiVkCommandBuffer* primaryCommandBuffer)\n{\n    unsigned numThreads = HgiVk::GetThreadCount();\n    size_t begin = id * numThreads;\n    size_t end = begin + numThreads;\n\n    size_t vecSize = _secondaryDrawCommandBuffers.size();\n\n    if (!TF_VERIFY(primaryCommandBuffer && end <= vecSize)) {\n        return;\n    }\n\n    std::vector<VkCommandBuffer> cbs;\n    cbs.reserve(end-begin);\n\n    // End recording on all secondary command buffers.\n    for (size_t i=begin; i<end; i++) {\n        HgiVkCommandBuffer* cb = _secondaryDrawCommandBuffers[i];\n        if (cb && cb->IsRecording()) {\n            cb->EndRecording();\n            cbs.push_back(cb->GetVulkanCommandBuffer());\n        }\n    }\n\n    // Submit secondary command buffers into primary command buffer.\n    if (!cbs.empty()) {\n        vkCmdExecuteCommands(\n            primaryCommandBuffer->GetVulkanCommandBuffer(),\n            (uint32_t) cbs.size(),\n            cbs.data());\n    }\n}\n\nvoid\nHgiVkCommandBufferManager::SetDebugName(std::string const& name)\n{\n    _debugName = name;\n\n    std::string debugLabel = \"Semaphore \" + name;\n    HgiVkSetDebugName(\n        _device,\n        (uint64_t)_vkSemaphore,\n        VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT,\n        debugLabel.c_str());\n\n    for (HgiVkCommandPool* pool : _commandPools) {\n        pool->SetDebugName(name);\n    }\n\n    auto setDebugNameFn = [name](HgiVkCommandBufferVector const& v) {\n        for (HgiVkCommandBuffer* cb : v) {\n            if (!cb) continue;\n            cb->SetDebugName(name.c_str());\n        }\n    };\n\n    setDebugNameFn(_resourceCommandBuffers);\n    setDebugNameFn(_drawCommandBuffers);\n    setDebugNameFn(_secondaryDrawCommandBuffers);\n}\n\nHgiTimeQueryVector const &\nHgiVkCommandBufferManager::GetTimeQueries() const\n{\n    return _timeQueries;\n}\n\nvoid\nHgiVkCommandBufferManager::_CreatePoolsAndBuffers()\n{\n    unsigned numThreads = HgiVk::GetThreadCount();\n\n    // Unlikely, but the max number of threads may have changed between frames.\n    // If that happens, we grow the primary command buffers and pools.\n    size_t currentSize = _resourceCommandBuffers.size();\n\n    for (size_t i=currentSize; i<numThreads; i++) {\n        HgiVkCommandPool* cp = new HgiVkCommandPool(_device);\n        _commandPools.push_back(cp);\n\n        _resourceCommandBuffers.push_back(\n            new HgiVkCommandBuffer(\n                _device,\n                cp,\n                HgiVkCommandBufferUsagePrimary)\n        );\n\n        _drawCommandBuffers.push_back(\n            new HgiVkCommandBuffer(\n                _device,\n                cp,\n                HgiVkCommandBufferUsagePrimary)\n        );\n\n        // Last loop\n        if (i==numThreads-1) {\n            // Update debug names on all new pools and buffers\n            SetDebugName(_debugName);\n        }\n    }\n}\n\nvoid\nHgiVkCommandBufferManager::_UpdateThreadLocalIndex()\n{\n    /* MULTI-THREAD CALL*/\n\n    // Hydra will spawn multiple threads when syncing prims.\n    // We want each mesh, curve, etc to be able to record vulkan commands into\n    // a command buffer for parallel recording.\n\n    // When such a prim asks for a command buffer we determine what buffer to\n    // return based on _HgiVkcmdBufThreadLocalIndex.\n    // This ensures each thread has an unique command buffer.\n\n    // When the next frame has started, each thread must re-acquire its\n    // _HgiVkcmdBufThreadLocalIndex. This protects against threads being\n    // created, destroyed or the number of threads changing between frames.\n\n    if (_HgiVkcmdBufThreadLocalFrame != _frame) {\n        _HgiVkcmdBufThreadLocalFrame = _frame;\n        _HgiVkcmdBufThreadLocalIndex = _nextAvailableIndex.fetch_add(1);\n    }\n}\n\nPXR_NAMESPACE_CLOSE_SCOPE\n",
			"file": "src/USD/hgiVk/commandBufferManager.cpp",
			"file_size": 13416,
			"file_write_time": 132398938533875537,
			"settings":
			{
				"buffer_size": 13416,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#include \"pxr/base/tf/diagnostic.h\"\n#include \"USD/hgiVk/commandPool.h\"\n#include \"USD/hgiVk/device.h\"\n#include \"USD/hgiVk/diagnostic.h\"\n\n\nPXR_NAMESPACE_OPEN_SCOPE\n\n\nHgiVkCommandPool::HgiVkCommandPool(HgiVkDevice* device)\n    : _device(device)\n    , _vkCommandPool(nullptr)\n{\n    VkCommandPoolCreateInfo poolCreateInfo =\n        {VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO};\n    poolCreateInfo.flags = VK_COMMAND_POOL_CREATE_TRANSIENT_BIT;\n\n    // XXX If Graphics and Compute were to come from different queue families we\n    // would need to use a different commandpool/buffer for gfx and compute.\n    poolCreateInfo.queueFamilyIndex = device->GetVulkanDeviceQueueFamilyIndex();\n\n    TF_VERIFY(\n        vkCreateCommandPool(\n            device->GetVulkanDevice(),\n            &poolCreateInfo,\n            HgiVkAllocator(),\n            &_vkCommandPool) == VK_SUCCESS\n    );\n}\n\nHgiVkCommandPool::~HgiVkCommandPool()\n{\n    vkDestroyCommandPool(\n        _device->GetVulkanDevice(),\n        _vkCommandPool,\n        HgiVkAllocator());\n}\n\nvoid\nHgiVkCommandPool::ResetCommandPool()\n{\n    TF_VERIFY(\n        vkResetCommandPool(\n            _device->GetVulkanDevice(),\n            _vkCommandPool,\n            0 /*flags*/) == VK_SUCCESS\n    );\n}\n\nVkCommandPool\nHgiVkCommandPool::GetVulkanCommandPool() const\n{\n    return _vkCommandPool;\n}\n\nvoid\nHgiVkCommandPool::SetDebugName(std::string const& name)\n{\n    std::string debugLabel = \"Command Pool \" + name;\n    HgiVkSetDebugName(\n        _device,\n        (uint64_t)_vkCommandPool,\n        VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT,\n        debugLabel.c_str());\n}\n\nPXR_NAMESPACE_CLOSE_SCOPE\n",
			"file": "src/USD/hgiVk/commandPool.cpp",
			"file_size": 1629,
			"file_write_time": 132398938647874608,
			"settings":
			{
				"buffer_size": 1629,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#include \"USD/hgiVk/computeEncoder.h\"\n\n#include \"USD/hgiVk/device.h\"\n#include \"USD/hgiVk/diagnostic.h\"\n#include \"USD/hgiVk/pipeline.h\"\n#include \"USD/hgiVk/renderPass.h\"\n#include \"USD/hgiVk/resourceBindings.h\"\n#include \"USD/hgiVk/vulkan.h\"\n\nPXR_NAMESPACE_OPEN_SCOPE\n\nHgiVkComputeEncoder::HgiVkComputeEncoder(\n    HgiVkDevice* device,\n    HgiVkCommandBuffer* cb)\n    : HgiComputeEncoder()\n    , _device(device)\n    , _commandBuffer(_commandBuffer)\n    , _isRecording(true)\n{\n}\n\nHgiVkComputeEncoder::~HgiVkComputeEncoder()\n{\n    if (_isRecording) {\n        TF_WARN(\"ComputeEncoder: [%x] is missing an EndEncodig() call.\", this);\n        EndEncoding();\n    }\n}\n\nvoid\nHgiVkComputeEncoder::EndEncoding()\n{\n    _commandBuffer = nullptr;\n    _isRecording = false;\n}\n\nvoid\nHgiVkComputeEncoder::BindPipeline(HgiPipelineHandle pipeline)\n{\n    if (HgiVkPipeline* p = static_cast<HgiVkPipeline*>(pipeline)) {\n        p->BindPipeline(_commandBuffer, /*renderpass*/ nullptr);\n    }\n}\n\nvoid\nHgiVkComputeEncoder::BindResources(HgiResourceBindingsHandle res)\n{\n    if (HgiVkResourceBindings* r = static_cast<HgiVkResourceBindings*>(res)) {\n        r->BindResources(_commandBuffer);\n    }\n}\n\nvoid\nHgiVkComputeEncoder::Dispatch(\n    uint32_t threadGrpCntX,\n    uint32_t threadGrpCntY,\n    uint32_t threadGrpCntZ)\n{\n    vkCmdDispatch(\n        _commandBuffer->GetCommandBufferForRecoding(),\n        threadGrpCntX,\n        threadGrpCntY,\n        threadGrpCntZ);\n}\n\nvoid\nHgiVkComputeEncoder::PushDebugGroup(const char* label)\n{\n    if (!TF_VERIFY(_isRecording && _commandBuffer)) return;\n    HgiVkBeginDebugMarker(_commandBuffer, label);\n}\n\nvoid\nHgiVkComputeEncoder::PopDebugGroup()\n{\n    if (!TF_VERIFY(_isRecording && _commandBuffer)) return;\n    HgiVkEndDebugMarker(_commandBuffer);\n}\n\nPXR_NAMESPACE_CLOSE_SCOPE\n",
			"file": "src/USD/hgiVk/computeEncoder.cpp",
			"file_size": 1791,
			"file_write_time": 132398938861632866,
			"settings":
			{
				"buffer_size": 1791,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#include \"pxr/base/tf/diagnostic.h\"\n#include \"pxr/imaging/hgi/enums.h\"\n#include \"pxr/imaging/hgi/types.h\"\n\n#include \"USD/hgiVk/vulkan.h\"\n#include \"USD/hgiVk/conversions.h\"\n\nPXR_NAMESPACE_OPEN_SCOPE\n\n\nstatic const uint32_t\n_LoadOpTable[][2] =\n{\n    {HgiAttachmentLoadOpDontCare, VK_ATTACHMENT_LOAD_OP_DONT_CARE},\n    {HgiAttachmentLoadOpClear,    VK_ATTACHMENT_LOAD_OP_CLEAR},\n    {HgiAttachmentLoadOpLoad,     VK_ATTACHMENT_LOAD_OP_LOAD}\n};\n\nstatic const uint32_t\n_StoreOpTable[][2] =\n{\n    {HgiAttachmentStoreOpDontCare, VK_ATTACHMENT_STORE_OP_DONT_CARE},\n    {HgiAttachmentStoreOpStore,    VK_ATTACHMENT_STORE_OP_STORE}\n};\n\nstatic const uint32_t\n_FormatTable[HgiFormatCount][3] =\n{\n    // HGI FORMAT              VK FORMAT                     NUM BYTES\n    {HgiFormatUNorm8,      VK_FORMAT_R8_UNORM,            sizeof(uint8_t)*1 },\n    {HgiFormatUNorm8Vec2,  VK_FORMAT_R8G8_UNORM,          sizeof(uint8_t)*2 },\n    {HgiFormatUNorm8Vec3,  VK_FORMAT_R8G8B8_UNORM,        sizeof(uint8_t)*3 },\n    {HgiFormatUNorm8Vec4,  VK_FORMAT_R8G8B8A8_UNORM,      sizeof(uint8_t)*4 },\n    {HgiFormatSNorm8,      VK_FORMAT_R8_SNORM,            sizeof(int8_t)*1 },\n    {HgiFormatSNorm8Vec2,  VK_FORMAT_R8G8_SNORM,          sizeof(int8_t)*2 },\n    {HgiFormatSNorm8Vec3,  VK_FORMAT_R8G8B8_SNORM,        sizeof(int8_t)*3 },\n    {HgiFormatSNorm8Vec4,  VK_FORMAT_R8G8B8A8_SNORM,      sizeof(int8_t)*4 },\n    {HgiFormatFloat16,     VK_FORMAT_R16_SFLOAT,          sizeof(uint16_t)*1 },\n    {HgiFormatFloat16Vec2, VK_FORMAT_R16G16_SFLOAT,       sizeof(uint16_t)*2 },\n    {HgiFormatFloat16Vec3, VK_FORMAT_R16G16B16_SFLOAT,    sizeof(uint16_t)*3 },\n    {HgiFormatFloat16Vec4, VK_FORMAT_R16G16B16A16_SFLOAT, sizeof(uint16_t)*4 },\n    {HgiFormatFloat32,     VK_FORMAT_R32_SFLOAT,          sizeof(float)*1 },\n    {HgiFormatFloat32Vec2, VK_FORMAT_R32G32_SFLOAT,       sizeof(float)*2 },\n    {HgiFormatFloat32Vec3, VK_FORMAT_R32G32B32_SFLOAT,    sizeof(float)*3 },\n    {HgiFormatFloat32Vec4, VK_FORMAT_R32G32B32A32_SFLOAT, sizeof(float)*4 },\n    {HgiFormatInt32,       VK_FORMAT_R32_SINT,            sizeof(int32_t)*1 },\n    {HgiFormatInt32Vec2,   VK_FORMAT_R32G32_SINT,         sizeof(int32_t)*2 },\n    {HgiFormatInt32Vec3,   VK_FORMAT_R32G32B32_SINT,      sizeof(int32_t)*3 },\n    {HgiFormatInt32Vec4,   VK_FORMAT_R32G32B32A32_SINT,   sizeof(int32_t)*4 }\n};\n\nstatic const uint32_t\n_SampleCountTable[][2] =\n{\n    {HgiSampleCount1,  VK_SAMPLE_COUNT_1_BIT},\n    {HgiSampleCount4,  VK_SAMPLE_COUNT_4_BIT},\n    {HgiSampleCount16, VK_SAMPLE_COUNT_16_BIT}\n};\n\nstatic const uint32_t\n_ShaderStageTable[][2] =\n{\n    {HgiShaderStageVertex,   VK_SHADER_STAGE_VERTEX_BIT},\n    {HgiShaderStageFragment, VK_SHADER_STAGE_FRAGMENT_BIT},\n    {HgiShaderStageCompute,  VK_SHADER_STAGE_COMPUTE_BIT}\n};\n\nstatic const uint32_t\n_TextureUsageTable[][2] =\n{\n    {HgiTextureUsageBitsColorTarget, VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT},\n    {HgiTextureUsageBitsDepthTarget, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT},\n    {HgiTextureUsageBitsShaderRead,  VK_IMAGE_USAGE_SAMPLED_BIT},\n    {HgiTextureUsageBitsShaderWrite, VK_IMAGE_USAGE_STORAGE_BIT},\n    {HgiTextureUsageBitsTransferDst, VK_IMAGE_USAGE_TRANSFER_DST_BIT},\n    {HgiTextureUsageBitsTransferSrc, VK_IMAGE_USAGE_TRANSFER_SRC_BIT},\n};\n\nstatic const uint32_t\n_FormatFeatureTable[][2] =\n{\n    {HgiTextureUsageBitsColorTarget, VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT},\n    {HgiTextureUsageBitsDepthTarget, VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT},\n    {HgiTextureUsageBitsShaderRead,  VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT},\n    {HgiTextureUsageBitsShaderWrite, VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT},\n    {HgiTextureUsageBitsTransferDst, VK_FORMAT_FEATURE_TRANSFER_DST_BIT},\n    {HgiTextureUsageBitsTransferSrc, VK_FORMAT_FEATURE_TRANSFER_SRC_BIT},\n};\n\nstatic const uint32_t\n_BufferUsageTable[][2] =\n{\n    {HgiBufferUsageUniform,     VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT},\n    {HgiBufferUsageIndex16,     VK_BUFFER_USAGE_INDEX_BUFFER_BIT},\n    {HgiBufferUsageIndex32,     VK_BUFFER_USAGE_INDEX_BUFFER_BIT},\n    {HgiBufferUsageVertex,      VK_BUFFER_USAGE_VERTEX_BUFFER_BIT},\n    {HgiBufferUsageStorage,     VK_BUFFER_USAGE_STORAGE_BUFFER_BIT},\n    {HgiBufferUsageTransferSrc, VK_BUFFER_USAGE_TRANSFER_SRC_BIT},\n    {HgiBufferUsageTransferDst, VK_BUFFER_USAGE_TRANSFER_DST_BIT},\n};\n\nstatic const uint32_t\n_CullModeTable[HgiCullModeCount][2] =\n{\n    {HgiCullModeNone,         VK_CULL_MODE_NONE},\n    {HgiCullModeFront,        VK_CULL_MODE_FRONT_BIT},\n    {HgiCullModeBack,         VK_CULL_MODE_BACK_BIT},\n    {HgiCullModeFrontAndBack, VK_CULL_MODE_FRONT_AND_BACK}\n};\n\nstatic const uint32_t\n_PolygonModeTable[HgiPolygonModeCount][2] =\n{\n    {HgiPolygonModeFill,  VK_POLYGON_MODE_FILL},\n    {HgiPolygonModeLine,  VK_POLYGON_MODE_LINE},\n    {HgiPolygonModePoint, VK_POLYGON_MODE_POINT}\n};\n\nstatic const uint32_t\n_WindingTable[HgiWindingCount][2] =\n{\n    {HgiWindingClockwise,        VK_FRONT_FACE_CLOCKWISE},\n    {HgiWindingCounterClockwise, VK_FRONT_FACE_COUNTER_CLOCKWISE}\n};\n\nstatic const uint32_t\n_CompareOpTable[HgiCompareCount][2] =\n{\n    {HgiCompareOpNever,          VK_COMPARE_OP_NEVER},\n    {HgiCompareOpLess,           VK_COMPARE_OP_LESS},\n    {HgiCompareOpEqual,          VK_COMPARE_OP_EQUAL},\n    {HgiCompareOpLessOrEqual,    VK_COMPARE_OP_LESS_OR_EQUAL},\n    {HgiCompareOpGreater,        VK_COMPARE_OP_GREATER},\n    {HgiCompareOpNotEqual,       VK_COMPARE_OP_NOT_EQUAL},\n    {HgiCompareOpGreaterOrEqual, VK_COMPARE_OP_GREATER_OR_EQUAL},\n    {HgiCompareOpAlways,         VK_COMPARE_OP_ALWAYS}\n};\n\nstatic const uint32_t\n_BindResourceTypeTable[HgiBindResourceTypeCount][2] =\n{\n    {HgiBindResourceTypeSampler,              VK_DESCRIPTOR_TYPE_SAMPLER},\n    {HgiBindResourceTypeCombinedImageSampler, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER},\n    {HgiBindResourceTypeSamplerImage,         VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE},\n    {HgiBindResourceTypeStorageImage,         VK_DESCRIPTOR_TYPE_STORAGE_IMAGE},\n    {HgiBindResourceTypeUniformBuffer,        VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER},\n    {HgiBindResourceTypeStorageBuffer,        VK_DESCRIPTOR_TYPE_STORAGE_BUFFER}\n};\n\nVkFormat\nHgiVkConversions::GetFormat(HgiFormat inFormat)\n{\n    if (!TF_VERIFY(inFormat!=HgiFormatInvalid)) return VK_FORMAT_UNDEFINED;\n    return VkFormat(_FormatTable[inFormat][1]);\n}\n\nHgiFormat\nHgiVkConversions::GetFormat(VkFormat inFormat)\n{\n    if (!TF_VERIFY(inFormat!=VK_FORMAT_UNDEFINED)) return HgiFormatInvalid;\n\n    // While HdFormat/HgiFormat do not support BGRA channel ordering it may\n    // be used for the native window swapchain on some platforms.\n    if (inFormat == VK_FORMAT_B8G8R8A8_UNORM) return HgiFormatUNorm8Vec4;\n\n    for (auto const& f : _FormatTable) {\n        if (f[1] == inFormat) return HgiFormat(f[0]);\n    }\n\n    TF_CODING_ERROR(\"Missing format table entry\");\n    return HgiFormatInvalid;\n}\n\nuint32_t\nHgiVkConversions::GetBytesPerPixel(HgiFormat inFormat)\n{\n    if (!TF_VERIFY(inFormat!=HgiFormatInvalid)) return 0;\n    return VkFormat(_FormatTable[inFormat][2]);\n}\n\nVkImageAspectFlags\nHgiVkConversions::GetImageAspectFlag(HgiTextureUsage usage)\n{\n    if (usage & HgiTextureUsageBitsDepthTarget) {\n        return VK_IMAGE_ASPECT_DEPTH_BIT;\n    }\n    // XXX support for VK_IMAGE_ASPECT_STENCIL_BIT\n\n    return VK_IMAGE_ASPECT_COLOR_BIT;\n}\n\nVkImageUsageFlags\nHgiVkConversions::GetTextureUsage(HgiTextureUsage tu)\n{\n    VkImageUsageFlags vkFlags = 0;\n    for (const auto& f : _TextureUsageTable) {\n        if (tu & f[0]) vkFlags |= f[1];\n    }\n\n    if (vkFlags==0) {\n        TF_CODING_ERROR(\"Missing texture usage table entry\");\n    }\n    return vkFlags;\n}\n\nVkFormatFeatureFlags\nHgiVkConversions::GetFormatFeature(HgiTextureUsage tu)\n{\n    VkFormatFeatureFlags vkFlags = 0;\n    for (const auto& f : _FormatFeatureTable) {\n        if (tu & f[0]) vkFlags |= f[1];\n    }\n\n    if (vkFlags==0) {\n        TF_CODING_ERROR(\"Missing texture usage table entry\");\n    }\n    return vkFlags;\n}\n\nVkAttachmentLoadOp\nHgiVkConversions::GetLoadOp(HgiAttachmentLoadOp op)\n{\n    TF_VERIFY(op < HgiVkArraySize(_LoadOpTable));\n    return VkAttachmentLoadOp(_LoadOpTable[op][1]);\n}\n\nVkAttachmentStoreOp\nHgiVkConversions::GetStoreOp(HgiAttachmentStoreOp op)\n{\n    TF_VERIFY(op < HgiVkArraySize(_StoreOpTable));\n    return VkAttachmentStoreOp(_StoreOpTable[op][1]);\n}\n\nVkSampleCountFlagBits\nHgiVkConversions::GetSampleCount(HgiSampleCount sc)\n{\n    for (auto const& s : _SampleCountTable) {\n        if (s[0] == sc) return VkSampleCountFlagBits(s[1]);\n    }\n\n    TF_CODING_ERROR(\"Missing Sample table entry\");\n    return VK_SAMPLE_COUNT_1_BIT;\n}\n\nVkShaderStageFlags\nHgiVkConversions::GetShaderStages(HgiShaderStage ss)\n{\n    VkShaderStageFlags vkFlags = 0;\n    for (const auto& f : _ShaderStageTable) {\n        if (ss & f[0]) vkFlags |= f[1];\n    }\n\n    if (vkFlags==0) {\n        TF_CODING_ERROR(\"Missing shader stage table entry\");\n    }\n    return vkFlags;\n}\n\nVkBufferUsageFlags\nHgiVkConversions::GetBufferUsage(HgiBufferUsage bu)\n{\n    VkBufferUsageFlags vkFlags = 0;\n    for (const auto& f : _BufferUsageTable) {\n        if (bu & f[0]) vkFlags |= f[1];\n    }\n\n    if (vkFlags==0) {\n        TF_CODING_ERROR(\"Missing buffer usage table entry\");\n    }\n    return vkFlags;\n}\n\nVkCullModeFlags\nHgiVkConversions::GetCullMode(HgiCullMode cm)\n{\n    return VkCullModeFlags(_CullModeTable[cm][1]);\n}\n\nVkPolygonMode\nHgiVkConversions::GetPolygonMode(HgiPolygonMode pm)\n{\n    return VkPolygonMode(_PolygonModeTable[pm][1]);\n}\n\nVkFrontFace\nHgiVkConversions::GetWinding(HgiWinding wd)\n{\n    return VkFrontFace(_WindingTable[wd][1]);\n}\n\nVkCompareOp\nHgiVkConversions::GetCompareOp(HgiCompareOp co)\n{\n    return VkCompareOp(_CompareOpTable[co][1]);\n}\n\nVkDescriptorType\nHgiVkConversions::GetDescriptorType(HgiBindResourceType rt)\n{\n    return VkDescriptorType(_BindResourceTypeTable[rt][1]);\n}\n\nPXR_NAMESPACE_CLOSE_SCOPE\n",
			"file": "src/USD/hgiVk/conversions.cpp",
			"file_size": 9785,
			"file_write_time": 132398938960912058,
			"settings":
			{
				"buffer_size": 9785,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#include \"pxr/base/tf/diagnostic.h\"\n#include \"pxr/base/tf/envSetting.h\"\n\n#include \"USD/hgiVk/device.h\"\n#include \"USD/hgiVk/diagnostic.h\"\n#include \"USD/hgiVk/hgi.h\"\n#include \"USD/hgiVk/instance.h\"\n#include \"USD/hgiVk/renderPass.h\"\n\nPXR_NAMESPACE_OPEN_SCOPE\n\n\nstatic uint32_t\n_GetGraphicsFamilyIndex(\n    VkPhysicalDevice physicalDevice,\n    bool* supportsTimeStamps)\n{\n    uint32_t queueCount = 0;\n    vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, &queueCount, 0);\n\n    std::vector<VkQueueFamilyProperties> queues(queueCount);\n    vkGetPhysicalDeviceQueueFamilyProperties(\n        physicalDevice,\n        &queueCount,\n        queues.data());\n\n    for (uint32_t i = 0; i < queueCount; i++)\n        if (queues[i].queueFlags & VK_QUEUE_GRAPHICS_BIT) {\n            *supportsTimeStamps = (queues[i].timestampValidBits > 0);\n            return i;\n        }\n\n    return VK_QUEUE_FAMILY_IGNORED;\n}\n\nstatic bool\n_SupportsPresentation(\n    VkPhysicalDevice physicalDevice,\n    uint32_t familyIndex)\n{\n    #if defined(VK_USE_PLATFORM_WIN32_KHR)\n        return vkGetPhysicalDeviceWin32PresentationSupportKHR(\n                    physicalDevice, familyIndex);\n    #elif defined(VK_USE_PLATFORM_XLIB_KHR)\n        Display* dsp = XOpenDisplay(nullptr);\n        VisualID visualID = XVisualIDFromVisual(\n            DefaultVisual(dsp, DefaultScreen(dsp)));\n        return vkGetPhysicalDeviceXlibPresentationSupportKHR(\n                    physicalDevice, familyIndex, dsp, visualID);\n    #elif defined(VK_USE_PLATFORM_MACOS_MVK)\n        // If we need to we can query metal features, but presentation is\n        // currently always supported.\n        //     MVKPhysicalDeviceMetalFeatures features;\n        //     size_t featuresSize = 0;\n        //     vkGetPhysicalDeviceMetalFeaturesMVK(\n        //          physicalDevice, &features, &featuresSize);\n        return true;\n    #else\n        #error Unsupported Platform\n        return true;\n    #endif\n}\n\nHgiVkDevice::HgiVkDevice(\n    HgiVkInstance* instance,\n    HgiVkDeviceSettings deviceType)\n    : _vmaAllocator(nullptr)\n    , _vkPhysicalDevice(nullptr)\n    , _indexingFeatures{}\n    , _vkDevice(nullptr)\n    , _vkQueueFamilyIndex(0)\n    , _vkQueue(nullptr)\n    , _vkPipelineCache(nullptr)\n    , _supportsDebugMarkers(false)\n    , _supportsTimeStamps(false)\n    , _frame(~0ull)\n    , _frameStarted(false)\n    , _ringBufferIndex(-1)\n{\n    //\n    // Determine physical device\n    //\n\n    const uint32_t maxDevices = 64;\n    VkPhysicalDevice physicalDevices[maxDevices];\n    uint32_t physicalDeviceCount = maxDevices;\n    TF_VERIFY(\n        vkEnumeratePhysicalDevices(\n            instance->GetVulkanInstance(),\n            &physicalDeviceCount,\n            physicalDevices) == VK_SUCCESS\n    );\n\n    VkPhysicalDevice discrete = nullptr;\n    VkPhysicalDevice fallback = nullptr;\n    bool discreteTimeStamps = false;\n    bool fallbackTimeStamps = false;\n    uint32_t familyIndex = 0;\n\n    for (uint32_t i = 0; i < physicalDeviceCount; i++) {\n        VkPhysicalDeviceProperties props;\n        vkGetPhysicalDeviceProperties(physicalDevices[i], &props);\n\n        bool timeStamps = false;\n        familyIndex = _GetGraphicsFamilyIndex(physicalDevices[i], &timeStamps);\n        if (familyIndex == VK_QUEUE_FAMILY_IGNORED) continue;\n\n        if (deviceType == HgiVkPresentationType) {\n            if (!_SupportsPresentation(physicalDevices[i], familyIndex)) {\n                continue;\n            }\n        } else {\n            TF_CODING_ERROR(\"VULKAN_ERROR: Unknown device type requested\");\n        }\n\n        if (props.apiVersion < VK_API_VERSION_1_0) continue;\n\n        if (!discrete && props.deviceType==VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU){\n            discrete = physicalDevices[i];\n            discreteTimeStamps = timeStamps;\n        } else if (!fallback) {\n            fallback = physicalDevices[i];\n            fallbackTimeStamps = timeStamps;\n        }\n    }\n\n    _vkPhysicalDevice = discrete ? discrete : fallback;\n    _supportsTimeStamps = discrete ? discreteTimeStamps : fallbackTimeStamps;\n\n    if (_vkPhysicalDevice) {\n        vkGetPhysicalDeviceProperties(\n            _vkPhysicalDevice,\n            &_vkDeviceProperties);\n\n        vkGetPhysicalDeviceFeatures(\n            _vkPhysicalDevice,\n            &_vkDeviceFeatures);\n\n        vkGetPhysicalDeviceMemoryProperties(\n            _vkPhysicalDevice,\n            &_vkMemoryProperties);\n\n        #if defined(_DEBUG)\n            TF_WARN(\"Selected GPU %s\", _vkDeviceProperties.deviceName);\n        #endif\n    } else {\n        TF_CODING_ERROR(\"VULKAN_ERROR: Unable to determine physical device\");\n        return;\n    }\n\n    //\n    // Query supported extensions for device\n    //\n\n    uint32_t extensionCount = 0;\n\tTF_VERIFY(\n        vkEnumerateDeviceExtensionProperties(\n            _vkPhysicalDevice,\n            nullptr,\n            &extensionCount,\n            nullptr) == VK_SUCCESS\n    );\n\n    _extensions.resize(extensionCount);\n\n    TF_VERIFY(\n        vkEnumerateDeviceExtensionProperties(\n            _vkPhysicalDevice,\n            nullptr,\n            &extensionCount,\n            _extensions.data()) == VK_SUCCESS\n    );\n\n    //\n    // Create Device\n    //\n\n    VkDeviceQueueCreateInfo queueInfo =\n        {VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO};\n    float queuePriorities[] = {1.0f};\n    queueInfo.queueFamilyIndex = familyIndex;\n    queueInfo.queueCount = 1;\n    queueInfo.pQueuePriorities = queuePriorities;\n\n    std::vector<const char*> extensions = {\n        VK_KHR_SWAPCHAIN_EXTENSION_NAME\n    };\n\n    _supportsDebugMarkers =\n        _IsSupportedExtension(VK_EXT_DEBUG_MARKER_EXTENSION_NAME);\n\n    if (_supportsDebugMarkers && HgiVkIsDebugEnabled()) {\n        extensions.push_back(VK_EXT_DEBUG_MARKER_EXTENSION_NAME);\n    }\n\n    // Allow certain buffers/images to have dedicated memory allocations to\n    // improve performance on some GPUs.\n    // https://gpuopen-librariesandsdks.github.io/\n    // VulkanMemoryAllocator/html/usage_patterns.html\n    bool dedicatedAllocations = false;\n    if (_IsSupportedExtension(VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME) &&\n        _IsSupportedExtension(VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME)) {\n        dedicatedAllocations = true;\n        extensions.push_back(VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME);\n        extensions.push_back(VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME);\n    }\n\n    // Memory budget query extension\n    bool supportsMemExtension = false;\n    if (_IsSupportedExtension(VK_EXT_MEMORY_BUDGET_EXTENSION_NAME)) {\n        supportsMemExtension = true;\n        extensions.push_back(VK_EXT_MEMORY_BUDGET_EXTENSION_NAME);\n    }\n\n    // Resolve depth during render pass resolve\n    if (_IsSupportedExtension(VK_KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME)) {\n        extensions.push_back(VK_KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME);\n        extensions.push_back(VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME);\n        extensions.push_back(VK_KHR_MULTIVIEW_EXTENSION_NAME);\n    } else {\n        #if !defined(__APPLE__)\n            TF_WARN(\"Unsupported VK_KHR_depth_stencil_resolve (update drivers?)\");\n        #endif\n    }\n\n    // Allows shader to dynamic index into descriptor sets. (bindless textures)\n    if (_IsSupportedExtension(VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME)) {\n        extensions.push_back(VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME);\n    } else {\n        #if !defined(__APPLE__)\n            TF_WARN(\"Unsupported VK_EXT_descriptor_indexing (update drivers?)\");\n        #endif\n    }\n\n    // Allows shaders to use pointers to gpu buffers (bindless buffers)\n    if (_IsSupportedExtension(VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME)) {\n        extensions.push_back(VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME);\n    } else {\n        #if !defined(__APPLE__)\n            TF_WARN(\"Unsupported VK_EXT_buffer_device_address (update drivers?)\");\n        #endif\n    }\n\n    // Allows the same layout in structs between c++ and glsl (share structs)\n    if (_IsSupportedExtension(VK_EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME)) {\n        extensions.push_back(VK_EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME);\n    } else {\n        #if !defined(__APPLE__)\n            TF_WARN(\"Unsupported VK_EXT_scalar_block_layout (update drivers?)\");\n        #endif\n    }\n\n    // This extension is needed to allow the viewport to be flipped in Y so that\n    // shaders and vertex data can remain the same between opengl and vulkan.\n    // See GraphicsEncoder::SetViewport. This extension is core as of 1.1.\n    extensions.push_back(VK_KHR_MAINTENANCE1_EXTENSION_NAME);\n\n    // Query device features2.\n    // We want to query for descriptor indexing features, but this is unstable\n    // on MoltenVk 1. So we skip it (we already know they are not supported).\n    _indexingFeatures.sType =\n        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT;\n    VkPhysicalDeviceBufferDeviceAddressFeaturesEXT bufferAddressFeature =\n        {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT};\n\n    VkPhysicalDeviceFeatures2 features =\n        {VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2};\n    #if !defined(__APPLE__)\n        features.pNext = &_indexingFeatures;\n        _indexingFeatures.pNext = &bufferAddressFeature;\n    #endif\n    vkGetPhysicalDeviceFeatures2(_vkPhysicalDevice, &features);\n\n    // XXX Force override indexing features on some devices since they turned\n    // out to work or not work even though feature query claimed otherwise.\n    #if defined(__linux__)\n        // Unbuntu 18.10 Intel UHD 620 does not render with partiallyBound true.\n        if (strstr(_vkDeviceProperties.deviceName, \"UHD Graphics 620\")) {\n            _indexingFeatures.descriptorBindingVariableDescriptorCount=VK_TRUE;\n            _indexingFeatures.descriptorBindingPartiallyBound=VK_FALSE;\n        }\n    #endif\n\n    VkDeviceCreateInfo createInfo = {VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO};\n    createInfo.queueCreateInfoCount = 1;\n    createInfo.pQueueCreateInfos = &queueInfo;\n    createInfo.ppEnabledExtensionNames = extensions.data();\n    createInfo.enabledExtensionCount = (uint32_t)extensions.size();\n    createInfo.pNext = &features;\n\n    TF_VERIFY(\n        vkCreateDevice(\n            _vkPhysicalDevice,\n            &createInfo,\n            HgiVkAllocator(),\n            &_vkDevice) == VK_SUCCESS\n    );\n\n    //\n    // Extension functions\n    //\n\n    vkCreateRenderPass2KHR = (PFN_vkCreateRenderPass2KHR)\n    vkGetDeviceProcAddr(_vkDevice, \"vkCreateRenderPass2KHR\");\n    vkGetBufferDeviceAddressEXT = (PFN_vkGetBufferDeviceAddressEXT)\n    vkGetDeviceProcAddr(_vkDevice, \"vkGetBufferDeviceAddressEXT\");\n\n    HgiVkInitializeDeviceDebug(this);\n\n    //\n    // Memory allocator\n    //\n\n    VmaAllocatorCreateInfo allocatorInfo = {};\n    allocatorInfo.instance = instance->GetVulkanInstance();\n    allocatorInfo.physicalDevice = _vkPhysicalDevice;\n    allocatorInfo.device = _vkDevice;\n    if (dedicatedAllocations) {\n        allocatorInfo.flags |=VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT;\n    }\n\n    if (supportsMemExtension) {\n        allocatorInfo.flags |= VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT;\n    }\n\n    TF_VERIFY(\n        vmaCreateAllocator(&allocatorInfo, &_vmaAllocator) == VK_SUCCESS\n    );\n\n    //\n    // Device Queue\n    //\n\n    // todo For async compute we need to grab a second queue that supports\n    // compute. Dispatch the compute work there and use a fence to verify when\n    // the async compute work is done. If it's a different queue family index we\n    // also need different commandpool/bufs. (See HgiVkCommandPool constructor)\n\n    const uint32_t queueIndex = 0;\n    vkGetDeviceQueue(_vkDevice, _vkQueueFamilyIndex, queueIndex, &_vkQueue);\n\n    // Create the ring-buffer render frames.\n    for (size_t i=0; i< HgiVkRingBufferSize; i++) {\n        HgiVkRenderFrame* frame = new HgiVkRenderFrame(this);\n        std::string debugLabel = \"Frame \" + std::to_string(i);\n        frame->SetDebugName(debugLabel);\n        _frames.push_back(frame);\n    }\n\n    //\n    // Hgi device features\n    //\n    _hgiDeviceFeatures.maxSamplers =\n        _vkDeviceProperties.limits.maxPerStageDescriptorSamplers;\n    _hgiDeviceFeatures.resourceBindingsVariableArraySize =\n        (bool) _indexingFeatures.descriptorBindingVariableDescriptorCount;\n    _hgiDeviceFeatures.bufferAddress = bufferAddressFeature.bufferDeviceAddress;\n    _hgiDeviceFeatures.shader64int = _vkDeviceFeatures.shaderInt64;\n\n}\n\nHgiVkDevice::~HgiVkDevice()\n{\n    // Make sure device is done consuming all frames before destroying objects.\n    TF_VERIFY(vkDeviceWaitIdle(_vkDevice) == VK_SUCCESS);\n\n    // Destroy render passes in cache before clearing the frame, because the\n    // to-be-destroyed render passes will go into the frame garbage collecter.\n    // Then on clearing the frames, the garbage collector destroys them.\n    _renderPassPipelineCache.Clear();\n\n    // Destroy vulkan objects in the frames before destroying this device.\n    for (HgiVkRenderFrame* frame : _frames) {\n        delete frame;\n    }\n    _frames.clear();\n\n    vmaDestroyAllocator(_vmaAllocator);\n    vkDestroyDevice(_vkDevice, HgiVkAllocator());\n}\n\nvoid\nHgiVkDevice::BeginFrame()\n{\n    if (_frameStarted) return;\n    _frameStarted = true;\n\n    // Increment the frame counter.\n    _frame++;\n\n    // Each new frame we reset what command buffers are used and switch to the\n    // next index in the 'ring buffer'. This ensures last frames command buffers\n    // are fully consumed by the gpu before we re-use them.\n    _ringBufferIndex = (_ringBufferIndex+1) % HgiVkRingBufferSize;\n    HgiVkRenderFrame* frame = _frames[_ringBufferIndex];\n    frame->BeginFrame(_frame);\n\n    // Ensure render pass and pipeline cache is configured for a new frame.\n    _renderPassPipelineCache.BeginFrame(_frame);\n}\n\nvoid\nHgiVkDevice::EndFrame()\n{\n    HgiVkRenderFrame* frame = _frames[_ringBufferIndex];\n    frame->EndFrame();\n\n    // Store all thread_local, newly created render passes.\n    _renderPassPipelineCache.EndFrame();\n\n    _frameStarted = false;\n}\n\nHgiVkCommandBufferManager*\nHgiVkDevice::GetCommandBufferManager()\n{\n    HgiVkRenderFrame* frame = _frames[_ringBufferIndex];\n    return frame->GetCommandBufferManager();\n}\n\nvoid\nHgiVkDevice::SubmitToQueue(\n    std::vector<VkSubmitInfo> const& submitInfos,\n    VkFence fence)\n{\n    /* MULTI-THREAD CALL*/\n\n    if (submitInfos.empty()) return;\n\n    // The vkQueue must be externally synchronized. We can have another\n    // thread submitting to the queue, such as a blitEncoder copy cmd or a\n    // compute command that must be immediately submitted for CPU read back.\n\n    std::lock_guard<std::mutex> lock(_queuelock);\n\n    // Commit provided command buffers to queue.\n    // Record and submission order does not guarantee execution order.\n    // Vulkan docs: \"Execution Model\" and \"Implicit Synchronization Guarantees\".\n\n    TF_VERIFY(\n        vkQueueSubmit(\n            _vkQueue,\n            (uint32_t) submitInfos.size(),\n            submitInfos.data(),\n            fence) == VK_SUCCESS\n    );\n}\n\nVkDevice\nHgiVkDevice::GetVulkanDevice() const\n{\n    return _vkDevice;\n}\n\nVkPhysicalDevice\nHgiVkDevice::GetVulkanPhysicalDevice() const\n{\n    return _vkPhysicalDevice;\n}\n\nVkPhysicalDeviceProperties const&\nHgiVkDevice::GetVulkanPhysicalDeviceProperties() const\n{\n    return _vkDeviceProperties;\n}\n\nVkPhysicalDeviceFeatures const&\nHgiVkDevice::GetVulkanPhysicalDeviceFeatures() const\n{\n    return _vkDeviceFeatures;\n}\n\nVkPhysicalDeviceDescriptorIndexingFeaturesEXT const&\nHgiVkDevice::GetVulkanPhysicalDeviceIndexingFeatures() const\n{\n    return _indexingFeatures;\n}\n\nVmaAllocator\nHgiVkDevice::GetVulkanMemoryAllocator() const\n{\n    return _vmaAllocator;\n}\n\nHgiVkRenderPass*\nHgiVkDevice::AcquireRenderPass(HgiGraphicsEncoderDesc const& desc)\n{\n    return _renderPassPipelineCache.AcquireRenderPass(this, desc);\n}\n\nvoid\nHgiVkDevice::ReleaseRenderPass(HgiVkRenderPass* rp)\n{\n    rp->ReleaseRenderPass();\n}\n\nVkQueue\nHgiVkDevice::GetVulkanDeviceQueue() const\n{\n    return _vkQueue;\n}\n\nuint32_t\nHgiVkDevice::GetVulkanDeviceQueueFamilyIndex() const\n{\n    return _vkQueueFamilyIndex;\n}\n\nVkPipelineCache\nHgiVkDevice::GetVulkanPipelineCache() const\n{\n    return _vkPipelineCache;\n}\n\nHgiVkShaderCompiler*\nHgiVkDevice::GetShaderCompiler()\n{\n    return &_shaderCompiler;\n}\n\nvoid\nHgiVkDevice::DestroyObject(HgiVkObject const& object)\n{\n    HgiVkRenderFrame* frame = _frames[_ringBufferIndex];\n    frame->GetGarbageCollector()->ScheduleObjectDestruction(object);\n}\n\nvoid\nHgiVkDevice::WaitForIdle()\n{\n    TF_VERIFY(\n        vkDeviceWaitIdle(_vkDevice) == VK_SUCCESS\n    );\n}\n\nuint64_t\nHgiVkDevice::GetCurrentFrame() const\n{\n    return _frame;\n}\n\nvoid\nHgiVkDevice::GetDeviceMemoryInfo(size_t* used, size_t* unused) const\n{\n    VmaBudget budget[VK_MAX_MEMORY_HEAPS] = {};\n    vmaGetBudget(_vmaAllocator, budget);\n\n    size_t memUsed = 0;\n    size_t memTotal = 0;\n\n    for (size_t i=0; i<VK_MAX_MEMORY_HEAPS; i++) {\n        memUsed += budget[i].usage;\n        memTotal += budget[i].budget;\n    }\n\n    if (used) *used = memUsed;\n    if (unused) *unused = memTotal - memUsed;\n}\n\nbool\nHgiVkDevice::GetDeviceSupportDebugMarkers() const\n{\n    return _supportsDebugMarkers;\n}\n\nbool\nHgiVkDevice::GetDeviceSupportTimeStamps() const\n{\n    return _supportsTimeStamps;\n}\n\nHgiTimeQueryVector const &\nHgiVkDevice::GetTimeQueries() const\n{\n    HgiVkRenderFrame* frame = _frames[_ringBufferIndex];\n    return frame->GetTimeQueries();\n}\n\nHgiDeviceFeatures const&\nHgiVkDevice::GetDeviceFeatures() const\n{\n    return _hgiDeviceFeatures;\n}\n\nbool\nHgiVkDevice::_IsSupportedExtension(const char* extensionName) const\n{\n    for (VkExtensionProperties const& ext : _extensions) {\n        if (!strcmp(extensionName, ext.extensionName)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n\nPXR_NAMESPACE_CLOSE_SCOPE\n",
			"file": "src/USD/hgiVk/device.cpp",
			"file_size": 17769,
			"file_write_time": 132398939118070779,
			"settings":
			{
				"buffer_size": 17769,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#include <cstring>\n\n#include \"pxr/base/tf/diagnostic.h\"\n#include \"pxr/base/tf/envSetting.h\"\n\n#include \"USD/hgiVk/commandBuffer.h\"\n#include \"USD/hgiVk/device.h\"\n#include \"USD/hgiVk/diagnostic.h\"\n#include \"USD/hgiVk/instance.h\"\n#include \"USD/hgiVk/vulkan.h\"\n\n\nPXR_NAMESPACE_OPEN_SCOPE\n\n#if defined(_DEBUG)\n    TF_DEFINE_ENV_SETTING(HGIVK_DEBUG, 1, \"Enable debugging for HgiVk\");\n#else\n    TF_DEFINE_ENV_SETTING(HGIVK_DEBUG, 0, \"Enable debugging for HgiVk\");\n#endif\n\n// XXX Make HgiVkDebug class and move all function, including below in there.\n// We may have multiple devices where one supports the marker extension and\n// one does not.\nstatic PFN_vkCmdDebugMarkerBeginEXT _vkCmdDebugMarkerBeginEXT = 0;\nstatic PFN_vkCmdDebugMarkerEndEXT _vkCmdDebugMarkerEndEXT = 0;\nstatic PFN_vkDebugMarkerSetObjectNameEXT _vkDebugMarkerSetObjectNameEXT = 0;\n\nbool\nHgiVkIsDebugEnabled()\n{\n    static bool _v = TfGetEnvSetting(HGIVK_DEBUG) == 1;\n    return _v;\n}\n\nstatic VKAPI_ATTR VkBool32 VKAPI_CALL\n_VulkanDebugCallback(\n    VkDebugReportFlagsEXT flags,\n    VkDebugReportObjectTypeEXT /*objectType*/,\n    uint64_t /*object*/,\n    size_t /*location*/,\n    int32_t /*messageCode*/,\n    const char* /*pLayerPrefix*/,\n    const char* pMessage,\n    void* /*pUserData*/)\n{\n    // XXX Validation layers don't correctly detect NonWriteable declarations\n    // for storage buffers:\n    // https://github.com/KhronosGroup/Vulkan-ValidationLayers/issues/73\n    if (strstr(pMessage, \"Shader requires vertexPipelineStoresAndAtomics but is\"\n                         \" not enabled on the device\")) {\n        return VK_FALSE;\n    }\n\n    // XXX We are using VulkanMemoryAllocator and it allocates large blocks of\n    // memory where buffers and images end up in the same memory block.\n    // This may trigger a validation warning, that VMA itself also ignores.\n    // https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator\n    // /blob/master/src/VulkanSample.cpp#L215\n    if(strstr(pMessage, \"Mapping an image with layout\") != nullptr &&\n       strstr(pMessage, \"can result in undefined behavior if this memory is \"\n                        \"used by the device\") != nullptr) {\n        return VK_FALSE;\n    }\n\n    // XXX We are using dedicated memory allocations\n    // https://gpuopen-librariesandsdks.github.io/\n    // VulkanMemoryAllocator/html/usage_patterns.html\n    if(strstr(pMessage, \"Binding memory to buffer\") != nullptr &&\n       strstr(pMessage, \"but vkGetBufferMemoryRequirements() has not been \"\n                        \"called on that buffer\") != nullptr){\n        return VK_FALSE;\n    }\n\n    const char* type =\n        (flags & VK_DEBUG_REPORT_ERROR_BIT_EXT) ?\n            \"VULKAN_ERROR\" :\n        (flags & (VK_DEBUG_REPORT_WARNING_BIT_EXT |\n                  VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT)) ?\n            \"VULKAN_WARNING\" :\n        \"VULKAN_INFO\";\n\n    TF_WARN(\"%s: %s\\n\", type, pMessage);\n\n    return VK_FALSE;\n}\n\nvoid\nHgiVkCreateDebug(HgiVkInstance* instance)\n{\n    if (!HgiVkIsDebugEnabled()) return;\n\n    VkInstance vkInstance = instance->GetVulkanInstance();\n\n    instance->vkCreateDebugCallbackEXT = (PFN_vkCreateDebugReportCallbackEXT)\n        vkGetInstanceProcAddr(vkInstance,\"vkCreateDebugReportCallbackEXT\");\n\n    instance->vkDestroyDebugCallbackEXT = (PFN_vkDestroyDebugReportCallbackEXT)\n        vkGetInstanceProcAddr(vkInstance,\"vkDestroyDebugReportCallbackEXT\");\n\n    if (!TF_VERIFY(instance->vkCreateDebugCallbackEXT)) return;\n    if (!TF_VERIFY(instance->vkDestroyDebugCallbackEXT)) return;\n\n    VkDebugReportCallbackCreateInfoEXT debugReportCallbackCInfo;\n    debugReportCallbackCInfo.sType =\n        VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT;\n\n    debugReportCallbackCInfo.pNext = nullptr;\n    debugReportCallbackCInfo.flags =\n        VK_DEBUG_REPORT_WARNING_BIT_EXT |\n        VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT |\n        VK_DEBUG_REPORT_ERROR_BIT_EXT;\n    debugReportCallbackCInfo.pfnCallback = _VulkanDebugCallback;\n    debugReportCallbackCInfo.pUserData = nullptr;\n\n    TF_VERIFY(\n        instance->vkCreateDebugCallbackEXT(\n            vkInstance,\n            &debugReportCallbackCInfo,\n            HgiVkAllocator(),\n            &instance->vkDebugCallback) == VK_SUCCESS\n    );\n}\n\nvoid\nHgiVkDestroyDebug(HgiVkInstance* instance)\n{\n    if (!HgiVkIsDebugEnabled()) return;\n\n    VkInstance vkInstance = instance->GetVulkanInstance();\n\n    if (!TF_VERIFY(instance->vkDestroyDebugCallbackEXT)) return;\n\n    instance->vkDestroyDebugCallbackEXT(\n        vkInstance,\n        instance->vkDebugCallback,\n        HgiVkAllocator());\n}\n\nvoid\nHgiVkInitializeDeviceDebug(HgiVkDevice* device)\n{\n    if (!HgiVkIsDebugEnabled()) return;\n    if (!device->GetDeviceSupportDebugMarkers()) return;\n\n    _vkCmdDebugMarkerBeginEXT = (PFN_vkCmdDebugMarkerBeginEXT)\n        vkGetDeviceProcAddr(\n            device->GetVulkanDevice(),\n            \"vkCmdDebugMarkerBeginEXT\");\n\n    _vkCmdDebugMarkerEndEXT = (PFN_vkCmdDebugMarkerEndEXT)\n        vkGetDeviceProcAddr(\n            device->GetVulkanDevice(),\n            \"vkCmdDebugMarkerEndEXT\");\n\n    _vkDebugMarkerSetObjectNameEXT = (PFN_vkDebugMarkerSetObjectNameEXT)\n        vkGetDeviceProcAddr(\n            device->GetVulkanDevice(),\n            \"vkDebugMarkerSetObjectNameEXT\");\n}\n\nvoid\nHgiVkBeginDebugMarker(\n    HgiVkCommandBuffer* cb,\n    const char* name)\n{\n    if (!HgiVkIsDebugEnabled() || !_vkCmdDebugMarkerBeginEXT) return;\n\n    VkDebugMarkerMarkerInfoEXT markerBegin =\n        {VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT};\n\n    markerBegin.pMarkerName = name;\n    const float color[4] = {1,1,0,1};\n    markerBegin.color[0] = color[0];\n    markerBegin.color[1] = color[1];\n    markerBegin.color[2] = color[2];\n    markerBegin.color[3] = color[3];\n    _vkCmdDebugMarkerBeginEXT(\n        cb->GetCommandBufferForRecoding(),\n        &markerBegin);\n}\n\nvoid\nHgiVkEndDebugMarker(HgiVkCommandBuffer* cb)\n{\n    if (!HgiVkIsDebugEnabled() || !_vkCmdDebugMarkerEndEXT) return;\n    _vkCmdDebugMarkerEndEXT(cb->GetCommandBufferForRecoding());\n}\n\nvoid\nHgiVkSetDebugName(\n    HgiVkDevice* device,\n    uint64_t vulkanObject,\n    uint32_t objectType,\n    const char* name)\n{\n    if (!HgiVkIsDebugEnabled() || !_vkDebugMarkerSetObjectNameEXT) return;\n\n    VkDebugMarkerObjectNameInfoEXT debugInfo =\n        {VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT};\n    debugInfo.object = vulkanObject;\n    debugInfo.objectType = VkDebugReportObjectTypeEXT(objectType);\n    debugInfo.pObjectName = name;\n    _vkDebugMarkerSetObjectNameEXT(device->GetVulkanDevice(), &debugInfo);\n}\n\nPXR_NAMESPACE_CLOSE_SCOPE\n\n",
			"file": "src/USD/hgiVk/diagnostic.cpp",
			"file_size": 6577,
			"file_write_time": 132398939269029552,
			"settings":
			{
				"buffer_size": 6577,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#include \"pxr/base/tf/diagnostic.h\"\n#include \"USD/hgiVk/device.h\"\n#include \"USD/hgiVk/diagnostic.h\"\n#include \"USD/hgiVk/frame.h\"\n\n\nPXR_NAMESPACE_OPEN_SCOPE\n\n\nHgiVkRenderFrame::HgiVkRenderFrame(HgiVkDevice* device)\n    : _device(device)\n    , _commandBufferManager(device)\n    , _vkFence(nullptr)\n{\n    // Create fence (for cpu synchronization)\n    VkFenceCreateInfo fenceInfo = {VK_STRUCTURE_TYPE_FENCE_CREATE_INFO};\n    fenceInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;\n\n    TF_VERIFY(\n        vkCreateFence(\n            _device->GetVulkanDevice(),\n            &fenceInfo,\n            HgiVkAllocator(),\n            &_vkFence) == VK_SUCCESS\n    );\n}\n\nHgiVkRenderFrame::~HgiVkRenderFrame()\n{\n    vkDestroyFence(_device->GetVulkanDevice(), _vkFence, HgiVkAllocator());\n}\n\nvoid\nHgiVkRenderFrame::BeginFrame(uint64_t frame)\n{\n    // Wait until the command buffers we are about to re-use have been\n    // consumed by GPU. Which may result in no wait at all since we use a\n    // ring-buffer of cmd buffers. Reset fence so it may be re-used.\n    TF_VERIFY(\n        vkWaitForFences(\n            _device->GetVulkanDevice(),\n            1,\n            &_vkFence,\n            VK_TRUE,\n            100000000000) == VK_SUCCESS\n    );\n\n    TF_VERIFY(\n        vkResetFences(\n            _device->GetVulkanDevice(),\n            1,\n            &_vkFence)  == VK_SUCCESS\n    );\n\n    // Above we waited to ensure the command buffers are no longer in flight.\n    // This means we can now delete all objects that were put in the garbage\n    // collector several frames ago.\n    _garbageCollector.DestroyGarbage(frame);\n\n    // Command buffer manager should reset command pools etc\n    _commandBufferManager.BeginFrame(frame);\n}\n\nvoid\nHgiVkRenderFrame::EndFrame()\n{\n    _commandBufferManager.EndFrame(_vkFence);\n}\n\nHgiVkGarbageCollector*\nHgiVkRenderFrame::GetGarbageCollector()\n{\n    return &_garbageCollector;\n}\n\nHgiVkCommandBufferManager*\nHgiVkRenderFrame::GetCommandBufferManager()\n{\n    return &_commandBufferManager;\n}\n\nvoid\nHgiVkRenderFrame::SetDebugName(std::string const& name)\n{\n    std::string debugLabel = \"Fence \" + name;\n    HgiVkSetDebugName(\n        _device,\n        (uint64_t)_vkFence,\n        VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT,\n        debugLabel.c_str());\n\n    _commandBufferManager.SetDebugName(name);\n}\n\nHgiTimeQueryVector const &\nHgiVkRenderFrame::GetTimeQueries() const\n{\n    return _commandBufferManager.GetTimeQueries();\n}\n\nPXR_NAMESPACE_CLOSE_SCOPE\n",
			"file": "src/USD/hgiVk/frame.cpp",
			"file_size": 2455,
			"file_write_time": 132398939395228526,
			"settings":
			{
				"buffer_size": 2455,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#include \"pxr/base/tf/diagnostic.h\"\n\n#include \"USD/hgiVk/buffer.h\"\n#include \"USD/hgiVk/garbageCollector.h\"\n#include \"USD/hgiVk/hgi.h\"\n#include \"USD/hgiVk/pipeline.h\"\n#include \"USD/hgiVk/renderPass.h\"\n#include \"USD/hgiVk/resourceBindings.h\"\n#include \"USD/hgiVk/shaderFunction.h\"\n#include \"USD/hgiVk/shaderProgram.h\"\n#include \"USD/hgiVk/surface.h\"\n#include \"USD/hgiVk/swapchain.h\"\n#include \"USD/hgiVk/texture.h\"\n#include \"USD/hgiVk/vulkan.h\"\n\nPXR_NAMESPACE_OPEN_SCOPE\n\nthread_local uint16_t _HgiVkgcThreadLocalIndex = 0;\nthread_local uint64_t _HgiVkgcThreadLocalFrame = ~0ull;\n\n\nHgiVkGarbageCollector::HgiVkGarbageCollector()\n    : _numUsedExpired(0)\n    , _frame(~0ull)\n    , _frameStarted(false)\n{\n}\n\nHgiVkGarbageCollector::~HgiVkGarbageCollector()\n{\n    DestroyGarbage(~0ull);\n}\n\nvoid\nHgiVkGarbageCollector::ScheduleObjectDestruction(\n    HgiVkObject const& obj)\n{\n    // First time thread is used in new frame, reserve index into vector.\n    if (_HgiVkgcThreadLocalFrame != _frame) {\n        _HgiVkgcThreadLocalFrame = _frame;\n        _HgiVkgcThreadLocalIndex = _numUsedExpired.fetch_add(1);\n    }\n\n    if (_HgiVkgcThreadLocalIndex >= _expiredVulkanObjects.size()) {\n        TF_CODING_ERROR(\"GC numThreads > HgiVk::GetThreadCount\");\n        _HgiVkgcThreadLocalIndex = 0;\n    }\n\n    _expiredVulkanObjects[_HgiVkgcThreadLocalIndex].emplace_back(obj);\n}\n\nvoid\nHgiVkGarbageCollector::DestroyGarbage(uint64_t frame)\n{\n    // Change the frame counter. This will let each thread know that they\n    // must re-initializes themselves the next time the thread wants to schedule\n    // an object for destruction.\n    _frame = frame;\n\n    // Loop the expired objects for each thread\n    for (VkObjectVector const& vec : _expiredVulkanObjects) {\n        // Loop each object and destroy it\n        for (HgiVkObject const& obj : vec) {\n            switch(obj.type) {\n                default: TF_CODING_ERROR(\"Missing destroy for hgiVk object\");\n\n                case HgiVkObjectTypeTexture: {\n                    HgiVkTexture* t = obj.texture;\n                    delete t;\n                    break;\n                }\n                case HgiVkObjectTypeBuffer: {\n                    HgiVkBuffer* b = obj.buffer;\n                    delete b;\n                    break;\n                }\n                case HgiVkObjectTypeRenderPass: {\n                    HgiVkRenderPass* r = obj.renderPass;\n                    delete r;\n                    break;\n                }\n                case HgiVkObjectTypePipeline: {\n                    HgiVkPipeline* p = obj.pipeline;\n                    delete p;\n                    break;\n                }\n                case HgiVkObjectTypeResourceBindings: {\n                    HgiVkResourceBindings* r = obj.resourceBindings;\n                    delete r;\n                    break;\n                }\n                case HgiVkObjectTypeShaderFunction: {\n                    HgiVkShaderFunction* s = obj.shaderFunction;\n                    delete s;\n                    break;\n                }\n                case HgiVkObjectTypeShaderProgram: {\n                    HgiVkShaderProgram* s = obj.shaderProgram;\n                    delete s;\n                    break;\n                }\n               case HgiVkObjectTypeSurface: {\n                    HgiVkSurface* s = obj.surface;\n                    delete s;\n                    break;\n                }\n               case HgiVkObjectTypeSwapchain: {\n                    HgiVkSwapchain* s = obj.swapchain;\n                    delete s;\n                    break;\n                }\n            }\n        }\n    }\n\n    _expiredVulkanObjects.clear();\n    _expiredVulkanObjects.shrink_to_fit();\n    _numUsedExpired.store(0);\n\n    // Make sure we have enough room for each thread, just in case the thread\n    // count has changed since last frame.\n    uint32_t numThreads = HgiVk::GetThreadCount();\n    _expiredVulkanObjects.resize(numThreads);\n}\n\n\nPXR_NAMESPACE_CLOSE_SCOPE\n",
			"file": "src/USD/hgiVk/garbageCollector.cpp",
			"file_size": 3957,
			"file_write_time": 132398939744505690,
			"settings":
			{
				"buffer_size": 3957,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#include \"pxr/imaging/hgi/graphicsEncoderDesc.h\"\n\n#include \"USD/hgiVk/buffer.h\"\n#include \"USD/hgiVk/commandBuffer.h\"\n#include \"USD/hgiVk/conversions.h\"\n#include \"USD/hgiVk/device.h\"\n#include \"USD/hgiVk/diagnostic.h\"\n#include \"USD/hgiVk/graphicsEncoder.h\"\n#include \"USD/hgiVk/pipeline.h\"\n#include \"USD/hgiVk/renderPass.h\"\n#include \"USD/hgiVk/resourceBindings.h\"\n#include \"USD/hgiVk/texture.h\"\n#include \"USD/hgiVk/vulkan.h\"\n\nPXR_NAMESPACE_OPEN_SCOPE\n\nHgiVkGraphicsEncoder::HgiVkGraphicsEncoder(\n    HgiVkDevice* device,\n    HgiVkCommandBuffer* cb,\n    HgiGraphicsEncoderDesc const& desc)\n    : HgiGraphicsEncoder()\n    , _device(device)\n    , _commandBuffer(cb)\n    , _renderPass(nullptr)\n    , _isParallelEncoder(false)\n    , _isRecording(true)\n{\n    _renderPass = device->AcquireRenderPass(desc);\n    _renderPass->BeginRenderPass(_commandBuffer, _isParallelEncoder);\n}\n\nHgiVkGraphicsEncoder::HgiVkGraphicsEncoder(\n    HgiVkDevice* device,\n    HgiVkCommandBuffer* cb,\n    HgiVkRenderPass* renderPass)\n    : HgiGraphicsEncoder()\n    , _device(device)\n    , _commandBuffer(cb)\n    , _renderPass(renderPass)\n    , _isParallelEncoder(true)\n    , _isRecording(true)\n{\n    // If this encoder is created via ParallelGraphicsEncoder we do not want to\n    // begin the render pass. The parallel encoder will start and end the pass.\n}\n\nHgiVkGraphicsEncoder::~HgiVkGraphicsEncoder()\n{\n    if (_isRecording) {\n        TF_WARN(\"GraphicsEncoder: [%x] is missing an EndEncodig() call.\", this);\n        EndEncoding();\n    }\n}\n\nvoid\nHgiVkGraphicsEncoder::EndEncoding()\n{\n    if (!_isParallelEncoder) {\n        _renderPass->EndRenderPass(_commandBuffer);\n        _device->ReleaseRenderPass(_renderPass);\n    }\n\n    _commandBuffer = nullptr;\n    _isRecording = false;\n}\n\nvoid\nHgiVkGraphicsEncoder::SetViewport(GfVec4i const& vp)\n{\n    if (!TF_VERIFY(_isRecording && _commandBuffer)) return;\n\n    float offsetX = (float) vp[0];\n    float offsetY = (float) vp[1];\n    float width = (float) vp[2];\n    float height = (float) vp[3];\n\n    // Flip viewport in Y-axis, because the vertex.y position is flipped\n    // between opengl and vulkan. This also moves origin to bottom-left.\n    // Requires VK_KHR_maintenance1 extension.\n\n    // Alternatives are:\n    // 1. Multiply projection by 'inverted Y and half Z' matrix:\n    //    const GfMatrix4d clip(\n    //        1.0,  0.0, 0.0, 0.0,\n    //        0.0, -1.0, 0.0, 0.0,\n    //        0.0,  0.0, 0.5, 0.0,\n    //        0.0,  0.0, 0.5, 1.0);\n    //    projection = /*clip **/ projection;\n    //\n    // 2. Adjust vertex position:\n    //    gl_Position.z = (gl_Position.z + gl_Position.w) / 2.0;\n\n    VkViewport viewport;\n    viewport.x = offsetX;\n    viewport.y = height - offsetY;\n    viewport.width = width;\n    viewport.height = -height;\n    viewport.minDepth = 0.0f;\n    viewport.maxDepth = 1.0f;\n\n    vkCmdSetViewport(\n        _commandBuffer->GetCommandBufferForRecoding(),\n        0,\n        1,\n        &viewport);\n}\n\nvoid\nHgiVkGraphicsEncoder::SetScissor(GfVec4i const& s)\n{\n    uint32_t w(s[2]);\n    uint32_t h(s[3]);\n    VkRect2D scissor = {{s[0], s[1]}, {w, h}};\n    vkCmdSetScissor(\n        _commandBuffer->GetCommandBufferForRecoding(),\n        0,\n        1,\n        &scissor);\n}\n\nvoid\nHgiVkGraphicsEncoder::BindPipeline(HgiPipelineHandle pipeline)\n{\n    if (HgiVkPipeline* p = static_cast<HgiVkPipeline*>(pipeline)) {\n        p->BindPipeline(_commandBuffer, _renderPass);\n    }\n}\n\nvoid\nHgiVkGraphicsEncoder::BindResources(HgiResourceBindingsHandle res)\n{\n    if (HgiVkResourceBindings* r = static_cast<HgiVkResourceBindings*>(res)) {\n        r->BindResources(_commandBuffer);\n    }\n}\n\nvoid\nHgiVkGraphicsEncoder::BindVertexBuffers(\n    HgiBufferHandleVector const& vertexBuffers)\n{\n    std::vector<VkBuffer> buffers;\n    std::vector<VkDeviceSize> bufferOffsets;\n\n    for (HgiBufferHandle bufHandle : vertexBuffers) {\n        HgiVkBuffer* buf = static_cast<HgiVkBuffer*>(bufHandle);\n        VkBuffer vkBuf = buf->GetBuffer();\n        if (vkBuf) {\n            buffers.push_back(vkBuf);\n            bufferOffsets.push_back(0);\n        }\n    }\n\n    vkCmdBindVertexBuffers(\n        _commandBuffer->GetCommandBufferForRecoding(),\n        0, // first bindings\n        buffers.size(),\n        buffers.data(),\n        bufferOffsets.data());\n}\n\nvoid\nHgiVkGraphicsEncoder::SetConstantValues(\n    HgiResourceBindingsHandle res,\n    HgiShaderStage stages,\n    uint32_t byteOffset,\n    uint32_t byteSize,\n    const void* data)\n{\n    HgiVkResourceBindings* r = static_cast<HgiVkResourceBindings*>(res);\n    if (!TF_VERIFY(r)) return;\n\n    vkCmdPushConstants(\n        _commandBuffer->GetCommandBufferForRecoding(),\n        r->GetPipelineLayout(),\n        HgiVkConversions::GetShaderStages(stages),\n        byteOffset,\n        byteSize,\n        data);\n}\n\nvoid\nHgiVkGraphicsEncoder::DrawIndexed(\n    HgiBufferHandle const& indexBuffer,\n    uint32_t indexCount,\n    uint32_t indexBufferByteOffset,\n    uint32_t firstIndex,\n    uint32_t vertexOffset,\n    uint32_t instanceCount,\n    uint32_t firstInstance)\n{\n    TF_VERIFY(instanceCount>0);\n\n    HgiVkBuffer* vkIndexBuf = static_cast<HgiVkBuffer*>(indexBuffer);\n    HgiBufferDesc const& indexDesc = vkIndexBuf->GetDescriptor();\n\n    VkIndexType indexType = (indexDesc.usage & HgiBufferUsageIndex16) ?\n        VK_INDEX_TYPE_UINT16 : VK_INDEX_TYPE_UINT32;\n\n    vkCmdBindIndexBuffer(\n        _commandBuffer->GetCommandBufferForRecoding(),\n        vkIndexBuf->GetBuffer(),\n        indexBufferByteOffset,\n        indexType);\n\n    vkCmdDrawIndexed(\n        _commandBuffer->GetCommandBufferForRecoding(),\n        indexCount,\n        instanceCount,\n        firstIndex,\n        vertexOffset,\n        firstInstance);\n}\n\n// XXX Draw calls could also be build up in a buffer and submitted to gpu, see:\n// vkCmdDrawIndexedIndirect and vkCmdDrawIndexedIndirectCount\n\nvoid\nHgiVkGraphicsEncoder::PushDebugGroup(const char* label)\n{\n    if (!TF_VERIFY(_isRecording && _commandBuffer)) return;\n    HgiVkBeginDebugMarker(_commandBuffer, label);\n}\n\nvoid\nHgiVkGraphicsEncoder::PopDebugGroup()\n{\n    if (!TF_VERIFY(_isRecording && _commandBuffer)) return;\n    HgiVkEndDebugMarker(_commandBuffer);\n}\n\nvoid\nHgiVkGraphicsEncoder::PushTimeQuery(const char* name)\n{\n    if (!TF_VERIFY(_isRecording && _commandBuffer)) return;\n    _commandBuffer->PushTimeQuery(name);\n}\n\nvoid\nHgiVkGraphicsEncoder::PopTimeQuery()\n{\n    if (!TF_VERIFY(_isRecording && _commandBuffer)) return;\n    _commandBuffer->PopTimeQuery();\n}\n\nPXR_NAMESPACE_CLOSE_SCOPE\n",
			"file": "src/USD/hgiVk/graphicsEncoder.cpp",
			"file_size": 6479,
			"file_write_time": 132398940016943481,
			"settings":
			{
				"buffer_size": 6479,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#if defined(__linux__)\n    #include <X11/Xlib.h>\n#endif\n\n#include \"USD/hgiVk/vulkan.h\"\n\n#define VMA_IMPLEMENTATION\n    #include \"vulkanMemoryAllocator/vk_mem_alloc.h\"\n#undef VMA_IMPLEMENTATION\n\n#include \"pxr/base/tf/diagnostic.h\"\n#include \"pxr/base/work/threadLimits.h\"\n\n// XXX See if we can wrap tbb::global_control::active_value inside libWork\n#define TBB_PREVIEW_GLOBAL_CONTROL 1\n#include \"tbb/global_control.h\"\n\n#include \"USD/hgiVk/blitEncoder.h\"\n#include \"USD/hgiVk/buffer.h\"\n#include \"USD/hgiVk/commandBuffer.h\"\n#include \"USD/hgiVk/commandBufferManager.h\"\n#include \"USD/hgiVk/device.h\"\n#include \"USD/hgiVk/hgi.h\"\n#include \"USD/hgiVk/instance.h\"\n#include \"USD/hgiVk/graphicsEncoder.h\"\n#include \"USD/hgiVk/parallelGraphicsEncoder.h\"\n#include \"USD/hgiVk/pipeline.h\"\n#include \"USD/hgiVk/resourceBindings.h\"\n#include \"USD/hgiVk/shaderFunction.h\"\n#include \"USD/hgiVk/shaderProgram.h\"\n#include \"USD/hgiVk/surface.h\"\n#include \"USD/hgiVk/swapchain.h\"\n#include \"USD/hgiVk/texture.h\"\n\n\nPXR_NAMESPACE_OPEN_SCOPE\n\n\n// XXX using a static, globally available HgiVK allows us to share textures\n// between the UI and hydra renderer, but feels like a bad idea once you have\n// multiple hydra viewports...\nHgiVk*\nHgiVkGetHydraGraphicsInterface() {\n    static HgiVk hgiVk;\n    return &hgiVk;\n}\n\nstatic bool\n_ValidateGraphicsEncoderDescriptor(\n    HgiGraphicsEncoderDesc const& desc)\n{\n    if (!desc.HasAttachments()) {\n        TF_WARN(\"Encoder descriptor not complete\");\n        return false;\n    }\n\n    const size_t maxColorAttachments = 8;\n    if (!TF_VERIFY(desc.colorAttachments.size() <= maxColorAttachments,\n            \"Too many color attachments in descriptor\")) {\n        return false;\n    }\n\n    if (!TF_VERIFY(desc.width>0 && desc.height>0,\n         \"Graphics encoder descriptor widht and height cannot be 0\")) {\n        return false;\n    }\n\n    return true;\n}\n\nHgiVk::HgiVk()\n    : _instance(nullptr)\n    , _frameStarted(false)\n{\n    _instance = new HgiVkInstance();\n\n    // Create \"primary device\" at front of vector.\n    HgiVkDevice* dev = new HgiVkDevice(_instance, HgiVkPresentationType);\n    TF_VERIFY(dev);\n    _devices.push_back(dev);\n\n    // Make sure HgiVk is ready to modify resources or record commands.\n    _BeginFrame();\n}\n\nHgiVk::~HgiVk()\n{\n    DestroyHgiVk();\n}\n\nvoid\nHgiVk::_BeginFrame()\n{\n    if (_frameStarted) return;\n    _frameStarted = true;\n\n    for (HgiVkDevice* d : _devices) {\n        d->BeginFrame();\n    }\n}\n\nvoid\nHgiVk::EndFrame()\n{\n    // Submit the command buffer to GPU.\n    for (HgiVkDevice* d : _devices) {\n        d->EndFrame();\n    }\n\n    _frameStarted = false;\n\n    // todo Defrag the AMD VulkanMemoryAllocator device->vmaAllocator\n    //      You need to destroy/recreate vk buffers and update descriptorSets.\n    //      See VMA header: defragmentation\n    //      https://gpuopen-librariesandsdks.github.io/\n    //      VulkanMemoryAllocator/html/defragmentation.html\n    // XXX Keep in mind that persistent mapped buffers need to be remapped.\n    // Additional notes:\n    //      https://developer.nvidia.com/vulkan-memory-management\n    //      https://ourmachinery.com/post/device-memory-management/\n\n    // Hydra currently does not call BeginFrame() and even if it did during\n    // Engine::Execute that would not be sufficient. HgiVk may be called via eg\n    // sceneDelegate -> renderIndex -> DeletePrim -> HdRenderBuffer::Deallocate.\n    // That call happens entirely outside of the Engine:Execute loop and we must\n    // be ready to modify resources or record commands at any time.\n    // So we prepare the next frame immediately after ending the last.\n    // This is less efficient, because the gpu has less time to process the\n    // command buffers we are about to re-use. By using a ringbuffer of size 3\n    // we reduce the likelyhood of having to wait on the command buffers, but\n    // introduces 2-frame latency for gpu to be fully up to date.\n    _BeginFrame();\n}\n\nHgiGraphicsEncoderUniquePtr\nHgiVk::CreateGraphicsEncoder(\n    HgiGraphicsEncoderDesc const& desc)\n{\n    if (!_ValidateGraphicsEncoderDescriptor(desc)) return nullptr;\n\n    HgiVkDevice* device = GetPrimaryDevice();\n    HgiVkCommandBufferManager* cbm = device->GetCommandBufferManager();\n    HgiVkCommandBuffer* cb = cbm->GetDrawCommandBuffer();\n    HgiVkGraphicsEncoder* enc = new HgiVkGraphicsEncoder(device, cb, desc);\n\n    return HgiGraphicsEncoderUniquePtr(enc);\n}\n\nHgiParallelGraphicsEncoderUniquePtr\nHgiVk::CreateParallelGraphicsEncoder(\n    HgiGraphicsEncoderDesc const& desc,\n    HgiPipelineHandle pipeline,\n    const char* debugName)\n{\n    if (!_ValidateGraphicsEncoderDescriptor(desc)) return nullptr;\n\n    HgiVkDevice* device = GetPrimaryDevice();\n    HgiVkCommandBufferManager* cbm = device->GetCommandBufferManager();\n    HgiVkCommandBuffer* cb = cbm->GetDrawCommandBuffer();\n    HgiVkParallelGraphicsEncoder* enc =\n        new HgiVkParallelGraphicsEncoder(debugName, device, cb, desc, pipeline);\n\n    return HgiParallelGraphicsEncoderUniquePtr(enc);\n}\n\nHgiBlitEncoderUniquePtr\nHgiVk::CreateBlitEncoder()\n{\n    HgiVkDevice* device = GetPrimaryDevice();\n    HgiVkCommandBufferManager* cbm = device->GetCommandBufferManager();\n    HgiVkCommandBuffer* cb = cbm->GetResourceCommandBuffer();\n    return HgiBlitEncoderUniquePtr(new HgiVkBlitEncoder(device, cb));\n}\n\nHgiTextureHandle\nHgiVk::CreateTexture(HgiTextureDesc const& desc)\n{\n    HgiVkDevice* device = GetPrimaryDevice();\n    HgiVkCommandBufferManager* cbm = device->GetCommandBufferManager();\n    HgiVkCommandBuffer* cb = cbm->GetResourceCommandBuffer();\n    HgiVkTexture* tex = new HgiVkTexture(device, cb, desc);\n\n    // If caller provided data to copy into this texture we create a staging\n    // buffer to transfer this data from cpu to gpu. This allows the final gpu\n    // texture to be of a 'faster' type while we do a non-blocking copy.\n\n    if (desc.pixelData && desc.pixelsByteSize > 0) {\n        // create staging buffer for cpu to gpu copy\n        HgiBufferDesc stagingDesc;\n        stagingDesc.usage = HgiBufferUsageTransferSrc;\n        stagingDesc.byteSize = desc.pixelsByteSize;\n        stagingDesc.data = desc.pixelData;\n\n        HgiVkBuffer* stagingBuffer = new HgiVkBuffer(device, stagingDesc);\n\n        // Record the copy\n        tex->CopyTextureFrom(cb, *stagingBuffer);\n\n        // Schedule destruction of staging buffer 3 frames from now.\n        HgiVkObject stagingObject;\n        stagingObject.buffer = stagingBuffer;\n        stagingObject.type = HgiVkObjectTypeBuffer;\n        device->DestroyObject(stagingObject);\n    }\n\n    return tex;\n}\n\nvoid\nHgiVk::DestroyTexture(HgiTextureHandle* texHandle)\n{\n    if (TF_VERIFY(texHandle, \"Invalid texture\")) {\n        HgiVkDevice* device = GetPrimaryDevice();\n        HgiVkObject object;\n        object.type = HgiVkObjectTypeTexture;\n        if (object.texture = static_cast<HgiVkTexture*>(*texHandle)) {\n            device->DestroyObject(object);\n            *texHandle = nullptr;\n        }\n    }\n}\n\nHgiBufferHandle\nHgiVk::CreateBuffer(HgiBufferDesc const& desc)\n{\n    HgiVkDevice* device = GetPrimaryDevice();\n    HgiVkCommandBufferManager* cbm = device->GetCommandBufferManager();\n    HgiVkBuffer* buffer = new HgiVkBuffer(device, desc);\n\n    // If caller provided data to copy into this buffer we create a staging\n    // buffer to transfer this data from cpu to gpu. This allows the final gpu\n    // buffer to be of a 'faster' type while we do a non-blocking copy.\n\n    if (desc.data && desc.byteSize > 0) {\n        // create staging buffer for cpu to gpu copy\n        HgiBufferDesc stagingDesc;\n        stagingDesc.usage = HgiBufferUsageTransferSrc;\n        stagingDesc.byteSize = desc.byteSize;\n        stagingDesc.data = desc.data;\n\n        HgiVkBuffer* stagingBuffer = new HgiVkBuffer(device, stagingDesc);\n\n        // Record the copy\n        HgiVkCommandBuffer* cb = cbm->GetResourceCommandBuffer();\n        buffer->CopyBufferFrom(cb, *stagingBuffer);\n\n        // Schedule destruction of staging buffer 3 frames from now.\n        HgiVkObject stagingObject;\n        stagingObject.buffer = stagingBuffer;\n        stagingObject.type = HgiVkObjectTypeBuffer;\n        device->DestroyObject(stagingObject);\n    }\n\n    return buffer;\n}\n\nvoid\nHgiVk::DestroyBuffer(HgiBufferHandle* bufferHandle)\n{\n    if (TF_VERIFY(bufferHandle, \"Invalid buffer\")) {\n        HgiVkDevice* device = GetPrimaryDevice();\n        HgiVkObject object;\n        object.type = HgiVkObjectTypeBuffer;\n        if (object.buffer = static_cast<HgiVkBuffer*>(*bufferHandle)) {\n            device->DestroyObject(object);\n            *bufferHandle = nullptr;\n        }\n    }\n}\n\nHgiPipelineHandle\nHgiVk::CreatePipeline(HgiPipelineDesc const& desc)\n{\n    HgiVkDevice* device = GetPrimaryDevice();\n    return new HgiVkPipeline(device, desc);\n}\n\nvoid\nHgiVk::DestroyPipeline(HgiPipelineHandle* pipeHandle)\n{\n    if (TF_VERIFY(pipeHandle, \"Invalid pipeline\")) {\n        HgiVkDevice* device = GetPrimaryDevice();\n        HgiVkObject object;\n        object.type = HgiVkObjectTypePipeline;\n        if (object.pipeline = static_cast<HgiVkPipeline*>(*pipeHandle)) {\n            device->DestroyObject(object);\n            *pipeHandle = nullptr;\n        }\n    }\n}\n\nHgiResourceBindingsHandle\nHgiVk::CreateResourceBindings(HgiResourceBindingsDesc const& desc)\n{\n    HgiVkDevice* device = GetPrimaryDevice();\n    return new HgiVkResourceBindings(device, desc);\n}\n\nvoid\nHgiVk::DestroyResourceBindings(HgiResourceBindingsHandle* resHandle)\n{\n    if (TF_VERIFY(resHandle, \"Invalid resource bindings\")) {\n        HgiVkDevice* device = GetPrimaryDevice();\n        HgiVkObject object;\n        object.type = HgiVkObjectTypeResourceBindings;\n        if (object.resourceBindings =\n                static_cast<HgiVkResourceBindings*>(*resHandle)) {\n            device->DestroyObject(object);\n            *resHandle = nullptr;\n        }\n    }\n}\n\nHgiShaderFunctionHandle\nHgiVk::CreateShaderFunction(HgiShaderFunctionDesc const& desc)\n{\n    HgiVkDevice* device = GetPrimaryDevice();\n    return new HgiVkShaderFunction(device, desc);\n}\n\nvoid\nHgiVk::DestroyShaderFunction(HgiShaderFunctionHandle* shaderFunctionHandle)\n{\n    if (TF_VERIFY(shaderFunctionHandle, \"Invalid shader function\")) {\n        HgiVkDevice* device = GetPrimaryDevice();\n        HgiVkObject object;\n        object.type = HgiVkObjectTypeShaderFunction;\n        if (object.shaderFunction =\n                static_cast<HgiVkShaderFunction*>(*shaderFunctionHandle)) {\n            device->DestroyObject(object);\n            *shaderFunctionHandle = nullptr;\n        }\n    }\n}\n\nHgiShaderProgramHandle\nHgiVk::CreateShaderProgram(HgiShaderProgramDesc const& desc)\n{\n    return new HgiVkShaderProgram(desc);\n}\n\nvoid\nHgiVk::DestroyShaderProgram(HgiShaderProgramHandle* shaderProgramHandle)\n{\n    if (TF_VERIFY(shaderProgramHandle, \"Invalid shader program\")) {\n        HgiVkDevice* device = GetPrimaryDevice();\n        HgiVkObject object;\n        object.type = HgiVkObjectTypeShaderProgram;\n        if (object.shaderProgram =\n                static_cast<HgiVkShaderProgram*>(*shaderProgramHandle)) {\n            device->DestroyObject(object);\n            *shaderProgramHandle = nullptr;\n        }\n    }\n}\n\nvoid\nHgiVk::GetMemoryInfo(size_t* used, size_t* unused)\n{\n    // XXX for now assume they want the primary device.\n    // But note we can have multiple _devices.\n    HgiVkDevice* device = GetPrimaryDevice();\n    device->GetDeviceMemoryInfo(used, unused);\n}\n\nHgiTimeQueryVector const&\nHgiVk::GetTimeQueries()\n{\n    // XXX for now assume they want the primary device.\n    // But note we can have multiple _devices.\n    HgiVkDevice* device = GetPrimaryDevice();\n    return device->GetTimeQueries();\n}\n\nHgiDeviceFeatures const&\nHgiVk::GetDeviceFeatures()\n{\n    // XXX for now assume they want the primary device.\n    // But note we can have multiple _devices.\n    HgiVkDevice* device = GetPrimaryDevice();\n    return device->GetDeviceFeatures();\n}\n\nHgiVkInstance*\nHgiVk::GetVulkanInstance() const\n{\n    return _instance;\n}\n\nvoid*\nHgiVk::GetVkInstance()\n{\n    return (void*) _instance->GetVulkanInstance();\n}\n\nHgiVkDevice*\nHgiVk::GetPrimaryDevice() const\n{\n    if (_devices.empty()) return nullptr;\n    return _devices.front();\n}\n\nHgiVkSurfaceHandle\nHgiVk::CreateSurface(HgiVkSurfaceDesc const& desc)\n{\n    HgiVkDevice* device = GetPrimaryDevice();\n    return new HgiVkSurface(_instance, device, desc);\n}\n\nvoid\nHgiVk::DestroySurface(HgiVkSurfaceHandle* surfaceHandle)\n{\n    if (TF_VERIFY(surfaceHandle, \"Invalid surface\")) {\n        HgiVkDevice* device = GetPrimaryDevice();\n        HgiVkObject object;\n        object.type = HgiVkObjectTypeSurface;\n        if (object.surface = *surfaceHandle) {\n            device->DestroyObject(object);\n            *surfaceHandle = nullptr;\n        }\n    }\n}\n\nHgiVkSwapchainHandle\nHgiVk::CreateSwapchain(HgiVkSurfaceHandle surfaceHandle)\n{\n    HgiVkDevice* device = GetPrimaryDevice();\n    return new HgiVkSwapchain(device, surfaceHandle);\n}\n\nvoid\nHgiVk::DestroySwapchain(HgiVkSwapchainHandle* swapchainHandle)\n{\n    if (TF_VERIFY(swapchainHandle, \"Invalid swapchain\")) {\n        HgiVkDevice* device = GetPrimaryDevice();\n        HgiVkObject object;\n        object.type = HgiVkObjectTypeSwapchain;\n        if (object.swapchain = *swapchainHandle) {\n            device->DestroyObject(object);\n            *swapchainHandle = nullptr;\n        }\n    }\n}\n\nvoid\nHgiVk::DestroyHgiVk()\n{\n    for (HgiVkDevice* device : _devices) {\n        delete device;\n    }\n    _devices.clear();\n\n    delete _instance;\n    _instance = nullptr;\n}\n\nuint32_t\nHgiVk::GetThreadCount()\n{\n    // Hydra's RenderIndex uses WorkParallelForN to sync prims.\n\n    // HgiVk parallel command recording relies on thread local storage vectors\n    // that must be large enough so each thread has an index. So we must know\n    // the maximum threads the WorkParallelForN may spawn.\n\n    // While we can ask libWork what the limit is, it may not match with the\n    // limit set inside TBB (we found libWork to often be 1 smaller than tbb).\n\n    unsigned workMaxThreads = WorkGetConcurrencyLimit();\n\n    unsigned tbbMaxThreads = (unsigned) tbb::global_control::active_value(\n        tbb::global_control::max_allowed_parallelism);\n\n    // Pick the largest of the two results.\n    // +1 in case HdEngine::Execute runs on a thread and main thread also\n    // uses HgiVk. (E.g. main thread composites hydra results in viewer)\n\n    return std::max(tbbMaxThreads, workMaxThreads) + 1;\n}\n\nPXR_NAMESPACE_CLOSE_SCOPE\n",
			"file": "src/USD/hgiVk/hgi.cpp",
			"file_size": 14444,
			"file_write_time": 132398940501259559,
			"settings":
			{
				"buffer_size": 14444,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#include <vector>\n\n#include \"pxr/base/tf/diagnostic.h\"\n\n#include \"USD/hgiVk/diagnostic.h\"\n#include \"USD/hgiVk/instance.h\"\n\n\nPXR_NAMESPACE_OPEN_SCOPE\n\n\nHgiVkInstance::HgiVkInstance()\n    : vkDebugCallback(nullptr)\n    , vkCreateDebugCallbackEXT(nullptr)\n    , vkDestroyDebugCallbackEXT(nullptr)\n    , _vkInstance(nullptr)\n{\n    VkApplicationInfo appInfo = {VK_STRUCTURE_TYPE_APPLICATION_INFO};\n    appInfo.apiVersion = VK_API_VERSION_1_0;\n\n    VkInstanceCreateInfo createInfo = {VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO};\n    createInfo.pApplicationInfo = &appInfo;\n\n    std::vector<const char*> extensions = {\n        VK_KHR_SURFACE_EXTENSION_NAME,\n        #if defined(VK_USE_PLATFORM_WIN32_KHR)\n            VK_KHR_WIN32_SURFACE_EXTENSION_NAME,\n        #elif defined(VK_USE_PLATFORM_XLIB_KHR)\n            VK_KHR_XLIB_SURFACE_EXTENSION_NAME,\n        #elif defined(VK_USE_PLATFORM_MACOS_MVK)\n            VK_MVK_MACOS_SURFACE_EXTENSION_NAME,\n        #else\n            #error Unsupported Platform\n        #endif\n\n        VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME,\n    };\n\n    if (HgiVkIsDebugEnabled()) {\n        extensions.push_back(VK_EXT_DEBUG_REPORT_EXTENSION_NAME);\n\n        const char* debugLayers[] = {\n            \"VK_LAYER_LUNARG_standard_validation\"\n        };\n        createInfo.ppEnabledLayerNames = debugLayers;\n        createInfo.enabledLayerCount = HgiVkArraySize(debugLayers);\n    }\n\n    createInfo.ppEnabledExtensionNames = extensions.data();\n    createInfo.enabledExtensionCount = (uint32_t) extensions.size();\n\n    TF_VERIFY(\n        vkCreateInstance(\n            &createInfo,\n            HgiVkAllocator(),\n            &_vkInstance) == VK_SUCCESS\n    );\n\n    HgiVkCreateDebug(this);\n}\n\nHgiVkInstance::~HgiVkInstance()\n{\n    HgiVkDestroyDebug(this);\n    vkDestroyInstance(_vkInstance, HgiVkAllocator());\n}\n\nVkInstance\nHgiVkInstance::GetVulkanInstance() const\n{\n    return _vkInstance;\n}\n\n\nPXR_NAMESPACE_CLOSE_SCOPE\n",
			"file": "src/USD/hgiVk/instance.cpp",
			"file_size": 1940,
			"file_write_time": 132398940580938914,
			"settings":
			{
				"buffer_size": 1940,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#include \"pxr/imaging/hgi/graphicsEncoderDesc.h\"\n\n#include \"USD/hgiVk/commandBuffer.h\"\n#include \"USD/hgiVk/commandBufferManager.h\"\n#include \"USD/hgiVk/device.h\"\n#include \"USD/hgiVk/diagnostic.h\"\n#include \"USD/hgiVk/graphicsEncoder.h\"\n#include \"USD/hgiVk/hgi.h\"\n#include \"USD/hgiVk/parallelGraphicsEncoder.h\"\n#include \"USD/hgiVk/pipeline.h\"\n#include \"USD/hgiVk/renderPass.h\"\n#include \"USD/hgiVk/vulkan.h\"\n\nPXR_NAMESPACE_OPEN_SCOPE\n\n\nHgiVkParallelGraphicsEncoder::HgiVkParallelGraphicsEncoder(\n    const char* debugName,\n    HgiVkDevice* device,\n    HgiVkCommandBuffer* primaryCB,\n    HgiGraphicsEncoderDesc const& desc,\n    HgiPipelineHandle pipeline)\n    : HgiParallelGraphicsEncoder(debugName)\n    , _device(device)\n    , _primaryCommandBuffer(primaryCB)\n    , _renderPass(nullptr)\n    , _isRecording(true)\n    , _isDebugging(debugName!=nullptr)\n    , _cmdBufBlockId(0)\n{\n    if (_isDebugging) {\n        _primaryCommandBuffer->PushTimeQuery(debugName);\n        HgiVkBeginDebugMarker(_primaryCommandBuffer, debugName);\n    }\n\n    // Make sure there are enough secondary commmand buffer for this parallel\n    // encoder to use during CreateGraphicsEncoder().\n    HgiVkCommandBufferManager* cbm = _device->GetCommandBufferManager();\n    _cmdBufBlockId = cbm->ReserveSecondaryDrawBuffersForParallelEncoder();\n\n    // In vulkan the render pass must begin and end in one primary command\n    // buffer. So we begin it here in the parallel encoder instead of in the\n    // individual graphics encoders that are used in the threads.\n    // This will ensure the load op for each attachment happens once.\n    _renderPass = device->AcquireRenderPass(desc);\n    _renderPass->BeginRenderPass(_primaryCommandBuffer, /*use secondary*/ true);\n\n    // Client will call BindPipeline on each graphics encoder, but we must make\n    // sure that the right vkPipeline is our internal 'renderpass-pipeline'\n    // cache that lives inside HgiVkPipeline. Normally this vkPipeline is\n    // created on-the-fly during BindPipeline, but that call is not threadsafe.\n    // By calling it here, we make sure the vkPipeline is created and inside\n    // the cache for when the parallel encoders try to acquire it.\n    if (HgiVkPipeline* p = static_cast<HgiVkPipeline*>(pipeline)) {\n        p->AcquirePipeline(_renderPass);\n    }\n}\n\nHgiVkParallelGraphicsEncoder::~HgiVkParallelGraphicsEncoder()\n{\n    if (_isRecording) {\n        TF_WARN(\"Parallel Gfx Encoder: [%x] is missing an EndEncodig() call.\");\n        EndEncoding();\n    }\n}\n\nvoid\nHgiVkParallelGraphicsEncoder::EndEncoding()\n{\n    // Record secondary cmd bufs into primary cmd buf\n    HgiVkCommandBufferManager* cbm = _device->GetCommandBufferManager();\n    cbm->ExecuteSecondaryCommandBuffers(_cmdBufBlockId, _primaryCommandBuffer);\n\n    // End the render pass (perform store ops)\n    _renderPass->EndRenderPass(_primaryCommandBuffer);\n    _device->ReleaseRenderPass(_renderPass);\n\n    if (_isDebugging) {\n        HgiVkEndDebugMarker(_primaryCommandBuffer);\n        _primaryCommandBuffer->PopTimeQuery();\n    }\n\n    // No more recording allowed\n    _primaryCommandBuffer = nullptr;\n    _isRecording = false;\n}\n\nHgiGraphicsEncoderUniquePtr\nHgiVkParallelGraphicsEncoder::CreateGraphicsEncoder()\n{\n    /* MULTI-THREAD CALL*/\n\n    if (!TF_VERIFY(_isRecording, \"Parallel recording ended\")) {\n        return nullptr;\n    }\n\n    // Get thread_local secondary command buffer\n    HgiVkCommandBufferManager* cbm = _device->GetCommandBufferManager();\n    HgiVkCommandBuffer* cb = cbm->GetSecondaryDrawCommandBuffer(_cmdBufBlockId);\n\n    // The secondary command buffer needs to know what render pass it is part of\n    cb->SetRenderPass(_renderPass);\n\n    // Create the graphics encoder passing it our already started render pass.\n    HgiVkGraphicsEncoder* enc = new HgiVkGraphicsEncoder(\n        _device, cb, _renderPass);\n\n    return HgiGraphicsEncoderUniquePtr(enc);\n}\n\n\nPXR_NAMESPACE_CLOSE_SCOPE\n",
			"file": "src/USD/hgiVk/parallelGraphicsEncoder.cpp",
			"file_size": 3913,
			"file_write_time": 132398940985415644,
			"settings":
			{
				"buffer_size": 3913,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#include <vector>\n\n#include \"pxr/base/tf/diagnostic.h\"\n\n#include \"USD/hgiVk/commandBuffer.h\"\n#include \"USD/hgiVk/conversions.h\"\n#include \"USD/hgiVk/device.h\"\n#include \"USD/hgiVk/diagnostic.h\"\n#include \"USD/hgiVk/pipeline.h\"\n#include \"USD/hgiVk/renderPass.h\"\n#include \"USD/hgiVk/resourceBindings.h\"\n#include \"USD/hgiVk/shaderProgram.h\"\n#include \"USD/hgiVk/shaderFunction.h\"\n\nHgiVkPipeline::HgiVkPipeline(\n    HgiVkDevice* device,\n    HgiPipelineDesc const& desc)\n    : HgiPipeline(desc)\n    , _device(device)\n    , _descriptor(desc)\n    , _vkTopology(VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST)\n{\n    // We cannot create the vulkan pipeline here, because we need to know the\n    // render pass that will be used in combination with this pipeline.\n    // We postpone creating the pipeline until BindPipeline(), which must be\n    // called after an encoder (render pass) has been activated.\n}\n\nHgiVkPipeline::~HgiVkPipeline()\n{\n    for (_Pipeline p : _pipelines) {\n        vkDestroyPipeline(\n            _device->GetVulkanDevice(),\n            p.vkPipeline,\n            HgiVkAllocator());\n    }\n}\n\nvoid\nHgiVkPipeline::BindPipeline(\n    HgiVkCommandBuffer* cb,\n    HgiVkRenderPass* rp)\n{\n    // See constructor. Pipeline creation was delayed until now, because for\n    // Vulkan we need to know the render pass to create the pipeline.\n    VkPipeline vkPipeline = AcquirePipeline(rp);\n\n    VkPipelineBindPoint bindPoint =\n        _descriptor.pipelineType == HgiPipelineTypeCompute ?\n        VK_PIPELINE_BIND_POINT_COMPUTE :\n        VK_PIPELINE_BIND_POINT_GRAPHICS;\n\n    vkCmdBindPipeline(cb->GetCommandBufferForRecoding(), bindPoint, vkPipeline);\n}\n\nVkPipeline\nHgiVkPipeline::AcquirePipeline(HgiVkRenderPass* rp)\n{\n    // We don't want clients to have to worry about pipeline - render pass\n    // compatibility in Hgi. Clients manage pipelines independently and bind\n    // pipelines to encoders. It is therefor possible they may not create an\n    // unique pipeline for each encoder.\n    // To facilitate that we create vulkan pipelines on-demand here when we\n    // receive an incompatible graphics encoder (aka render pass).\n    // For more info see vulkan docs: renderpass-compatibility.\n\n    if (_descriptor.pipelineType==HgiPipelineTypeGraphics) {\n\n        // First check the cache if we have already created a pipeline for the\n        // provided render-pass. See note above.\n        TF_VERIFY(rp, \"RenderPass null when acquiring pipeline.\");\n        HgiGraphicsEncoderDesc const& rpDesc = rp->GetDescriptor();\n\n        for (_Pipeline p : _pipelines) {\n            if (p.desc == rpDesc) return p.vkPipeline;\n        }\n        return _AcquireGraphicsPipeline(rp);\n\n    } else if (_descriptor.pipelineType==HgiPipelineTypeCompute) {\n\n        // Compute pipelines don't use render passes, so we only ever create\n        // one pipeline. If we already have it, we can exit early.\n        if (!_pipelines.empty()) {\n            return _pipelines.front().vkPipeline;\n        }\n\n        return _AcquireComputePipeline();\n    }\n}\n\nVkPipeline\nHgiVkPipeline::_AcquireGraphicsPipeline(HgiVkRenderPass* rp)\n{\n    TF_VERIFY(_descriptor.pipelineType==HgiPipelineTypeGraphics);\n\n    VkGraphicsPipelineCreateInfo pipeCreateInfo =\n        {VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO};\n\n    HgiGraphicsEncoderDesc const& rpDesc = rp->GetDescriptor();\n\n    //\n    // Shaders\n    //\n    HgiVkShaderProgram const* shaderProgram =\n        static_cast<HgiVkShaderProgram const*>(_descriptor.shaderProgram);\n    HgiShaderFunctionHandleVector const& sfv =\n        shaderProgram->GetShaderFunctions();\n\n    std::vector<VkPipelineShaderStageCreateInfo> stages;\n    stages.reserve(sfv.size());\n\n    for (HgiShaderFunctionHandle const& sf : sfv) {\n        HgiVkShaderFunction const* s =\n            static_cast<HgiVkShaderFunction const*>(sf);\n\n        VkPipelineShaderStageCreateInfo stage =\n            {VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO};\n        stage.stage = s->GetShaderStage();\n        stage.module = s->GetShaderModule();\n        stage.pName = s->GetShaderFunctionName();\n        stage.pNext = nullptr;\n        stage.pSpecializationInfo = nullptr; // XXX allows shader optimizations\n        stage.flags = 0;\n        stages.emplace_back(std::move(stage));\n    }\n\n    pipeCreateInfo.stageCount = (uint32_t) stages.size();\n    pipeCreateInfo.pStages = stages.data();\n\n    //\n    // Vertex Input State\n    // The input state includes the format and arrangement of the vertex data.\n    //\n\n    HgiVkResourceBindings* resources =\n        static_cast<HgiVkResourceBindings*>(_descriptor.resourceBindings);\n\n    HgiVertexBufferDescVector const& vbos = resources->GetVertexBuffers();\n    std::vector<VkVertexInputBindingDescription> vertBufs;\n    std::vector<VkVertexInputAttributeDescription> vertAttrs;\n\n    for (HgiVertexBufferDesc const& vbo : vbos) {\n\n        HgiVertexAttributeDescVector const& vas = vbo.vertexAttributes;\n\n        for (size_t loc=0; loc<vas.size(); loc++) {\n            HgiVertexAttributeDesc const& va = vas[loc];\n\n            VkVertexInputAttributeDescription ad;\n            ad.binding = vbo.bindingIndex;\n            ad.location = va.shaderBindLocation;\n            ad.offset = va.offset;\n            ad.format = HgiVkConversions::GetFormat(va.format);\n            vertAttrs.emplace_back(std::move(ad));\n        }\n\n        VkVertexInputBindingDescription vib;\n        vib.binding = vbo.bindingIndex;\n        vib.stride = vbo.vertexStride;\n        vib.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;\n        vertBufs.emplace_back(std::move(vib));\n    }\n\n    VkPipelineVertexInputStateCreateInfo vertexInput =\n        {VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO};\n    vertexInput.pVertexAttributeDescriptions = vertAttrs.data();\n    vertexInput.vertexAttributeDescriptionCount = (uint32_t) vertAttrs.size();\n    vertexInput.pVertexBindingDescriptions = vertBufs.data();\n    vertexInput.vertexBindingDescriptionCount = (uint32_t) vertBufs.size();\n    pipeCreateInfo.pVertexInputState = &vertexInput;\n\n    //\n    // Input assembly state\n    // Declare how your vertices form the geometry you want to draw.\n    //\n    VkPipelineInputAssemblyStateCreateInfo inputAssembly =\n        {VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO};\n    inputAssembly.topology = _vkTopology;\n    pipeCreateInfo.pInputAssemblyState = &inputAssembly;\n\n    //\n    // Pipeline layout\n    // This was generated when the resource bindings was created.\n    //\n    pipeCreateInfo.layout = resources->GetPipelineLayout();\n\n    //\n    // Viewport and Scissor state\n    // If these are set via a command, state this in Dynamic states below.\n    //\n    VkPipelineViewportStateCreateInfo viewportState =\n        {VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO};\n    viewportState.viewportCount = 1;\n    viewportState.scissorCount = 1;\n    viewportState.pScissors = nullptr;\n    viewportState.pViewports = nullptr;\n    pipeCreateInfo.pViewportState = &viewportState;\n\n    //\n    // Rasterization state\n    // Rasterization operations.\n    //\n    HgiRasterizationState const& ras = _descriptor.rasterizationState;\n\n    VkPipelineRasterizationStateCreateInfo rasterState =\n        {VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO};\n    rasterState.lineWidth = ras.lineWidth;\n    rasterState.cullMode = HgiVkConversions::GetCullMode(ras.cullMode);\n    rasterState.polygonMode = HgiVkConversions::GetPolygonMode(ras.polygonMode);\n    rasterState.frontFace = HgiVkConversions::GetWinding(ras.winding);\n    pipeCreateInfo.pRasterizationState = &rasterState;\n\n    //\n    // Multisample state\n    //\n    HgiMultiSampleState const& ms = _descriptor.multiSampleState;\n\n    VkPipelineMultisampleStateCreateInfo multisampleState =\n        {VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO};\n    multisampleState.pSampleMask = nullptr;\n    multisampleState.rasterizationSamples =\n        HgiVkConversions::GetSampleCount(ms.rasterizationSamples);\n    multisampleState.sampleShadingEnable = ms.sampleShadingEnable;\n    multisampleState.alphaToCoverageEnable = ms.alphaToCoverageEnable;\n    multisampleState.alphaToOneEnable = VK_FALSE;\n    multisampleState.minSampleShading = ms.samplesPerFragment;\n    pipeCreateInfo.pMultisampleState = &multisampleState;\n\n    //\n    // Depth Stencil state\n    //\n    VkBool32 depthTest =\n        bool(_descriptor.depthState & HgiDepthStateBitsDepthTest);\n\n    VkBool32 depthWrite =\n        bool(_descriptor.depthState & HgiBlendStateBitsDepthWrite);\n\n    VkPipelineDepthStencilStateCreateInfo depthStencilState =\n        {VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO};\n\n    depthStencilState.depthTestEnable = depthTest;\n    depthStencilState.depthWriteEnable = depthWrite;\n    depthStencilState.depthCompareOp =\n        HgiVkConversions::GetCompareOp(_descriptor.depthCompareOp);\n    depthStencilState.depthBoundsTestEnable = VK_FALSE;\n    depthStencilState.minDepthBounds = 0;\n    depthStencilState.maxDepthBounds = 0;\n// todo expose stencil options in hgi\n    depthStencilState.stencilTestEnable = VK_FALSE;\n    depthStencilState.back.failOp = VK_STENCIL_OP_KEEP;\n    depthStencilState.back.passOp = VK_STENCIL_OP_KEEP;\n    depthStencilState.back.compareOp = VK_COMPARE_OP_ALWAYS;\n    depthStencilState.back.compareMask = 0;\n    depthStencilState.back.reference = 0;\n    depthStencilState.back.depthFailOp = VK_STENCIL_OP_KEEP;\n    depthStencilState.back.writeMask = 0;\n    depthStencilState.front = depthStencilState.back;\n    pipeCreateInfo.pDepthStencilState = &depthStencilState;\n\n    //\n    // Color blend state\n    // Per attachment configuration of how output color blends with destination.\n    //\n    std::vector<VkPipelineColorBlendAttachmentState> colorAttachState;\n    for (HgiAttachmentDesc const& attachment : rpDesc.colorAttachments) {\n        VkPipelineColorBlendAttachmentState ca =\n            {VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO};\n\n// todo get color mask from hgi\n        ca.colorWriteMask = VK_COLOR_COMPONENT_R_BIT |\n                            VK_COLOR_COMPONENT_G_BIT |\n                            VK_COLOR_COMPONENT_B_BIT |\n                            VK_COLOR_COMPONENT_A_BIT;\n\n// todo get blend mode settings from hgi\n        ca.blendEnable = VK_FALSE;\n        ca.alphaBlendOp = VK_BLEND_OP_ADD;\n        ca.colorBlendOp = VK_BLEND_OP_ADD;\n        ca.srcColorBlendFactor = VK_BLEND_FACTOR_ZERO;\n        ca.dstColorBlendFactor = VK_BLEND_FACTOR_ZERO;\n        ca.srcAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;\n        ca.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;\n\n        colorAttachState.emplace_back(std::move(ca));\n    }\n\n    VkPipelineColorBlendStateCreateInfo colorBlendState =\n        {VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO};\n    colorBlendState.attachmentCount = colorAttachState.size();\n    colorBlendState.pAttachments = colorAttachState.data();\n    colorBlendState.logicOpEnable = VK_FALSE;\n    colorBlendState.logicOp = VK_LOGIC_OP_NO_OP;\n    colorBlendState.blendConstants[0] = 1.0f;\n    colorBlendState.blendConstants[1] = 1.0f;\n    colorBlendState.blendConstants[2] = 1.0f;\n    colorBlendState.blendConstants[3] = 1.0f;\n    pipeCreateInfo.pColorBlendState = &colorBlendState;\n\n    //\n    // Dynamic States\n    // States that change during command buffer execution via a command\n    //\n    VkDynamicState dynamicStates[] = {VK_DYNAMIC_STATE_VIEWPORT,\n                                      VK_DYNAMIC_STATE_SCISSOR};\n\n    VkPipelineDynamicStateCreateInfo dynamicState =\n        {VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO};\n    dynamicState.dynamicStateCount = HgiVkArraySize(dynamicStates);\n    dynamicState.pDynamicStates = dynamicStates;\n    pipeCreateInfo.pDynamicState = &dynamicState;\n\n    //\n    // Render pass\n    //\n    HgiVkRenderPass* renderPass = _device->AcquireRenderPass(rpDesc);\n    pipeCreateInfo.renderPass = renderPass->GetVulkanRenderPass();\n\n    //\n    // Make pipeline\n    //\n    _Pipeline pipeline;\n    pipeline.desc = rpDesc;\n\n    // xxx we need to add a pipeline cache to avoid app having to keep compiling\n    // shader micro-code for every pipeline combination. We except that the\n    // spir-V shader code is not compiled for the target device until this point\n    // where we create the pipeline. So a pipeline cache can be helpful.\n    // https://zeux.io/2019/07/17/serializing-pipeline-cache/\n    TF_VERIFY(\n        vkCreateGraphicsPipelines(\n            _device->GetVulkanDevice(),\n            _device->GetVulkanPipelineCache(),\n            1,\n            &pipeCreateInfo,\n            HgiVkAllocator(),\n            &pipeline.vkPipeline) == VK_SUCCESS\n    );\n\n    _pipelines.push_back(pipeline);\n\n    // Debug label\n    if (!_descriptor.debugName.empty()) {\n        std::string debugLabel = \"Graphics Pipeline \" + _descriptor.debugName;\n        HgiVkSetDebugName(\n            _device,\n            (uint64_t)pipeline.vkPipeline,\n            VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT,\n            debugLabel.c_str());\n    }\n\n    return pipeline.vkPipeline;\n}\n\nVkPipeline\nHgiVkPipeline::_AcquireComputePipeline()\n{\n    VkComputePipelineCreateInfo pipeCreateInfo =\n        {VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO};\n\n    //\n    // Shader\n    //\n    HgiVkShaderProgram const* shaderProgram =\n        static_cast<HgiVkShaderProgram const*>(_descriptor.shaderProgram);\n    HgiShaderFunctionHandleVector const& sfv =\n        shaderProgram->GetShaderFunctions();\n\n    if (sfv.empty()) {\n        TF_CODING_ERROR(\"Missing compute shader\");\n        return nullptr;\n    }\n\n    HgiVkShaderFunction const* s =\n        static_cast<HgiVkShaderFunction const*>(sfv.front());\n\n    VkPipelineShaderStageCreateInfo stage =\n        {VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO};\n    pipeCreateInfo.stage.stage = s->GetShaderStage();\n    pipeCreateInfo.stage.module = s->GetShaderModule();\n    pipeCreateInfo.stage.pName = s->GetShaderFunctionName();\n    pipeCreateInfo.stage.pNext = nullptr;\n    pipeCreateInfo.stage.pSpecializationInfo = nullptr;\n    pipeCreateInfo.stage.flags = 0;\n\n    //\n    // Pipeline layout\n    // This was generated when the resource bindings was created.\n    //\n    HgiVkResourceBindings* resources =\n        static_cast<HgiVkResourceBindings*>(_descriptor.resourceBindings);\n\n    pipeCreateInfo.layout = resources->GetPipelineLayout();\n\n    //\n    // Make pipeline\n    //\n    _Pipeline pipeline;\n\n    TF_VERIFY(\n        vkCreateComputePipelines(\n            _device->GetVulkanDevice(),\n            _device->GetVulkanPipelineCache(),\n            1,\n            &pipeCreateInfo,\n            HgiVkAllocator(),\n            &pipeline.vkPipeline) == VK_SUCCESS\n    );\n\n    // Debug label\n    if (!_descriptor.debugName.empty()) {\n        std::string debugLabel = \"Compute Pipeline \" + _descriptor.debugName;\n        HgiVkSetDebugName(\n            _device,\n            (uint64_t)pipeline.vkPipeline,\n            VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT,\n            debugLabel.c_str());\n    }\n\n    _pipelines.push_back(pipeline);\n    return pipeline.vkPipeline;\n}\n",
			"file": "src/USD/hgiVk/pipeline.cpp",
			"file_size": 15055,
			"file_write_time": 132398941271413334,
			"settings":
			{
				"buffer_size": 15055,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#include \"pxr/imaging/hgi/graphicsEncoderDesc.h\"\n\n#include \"USD/hgiVk/commandBuffer.h\"\n#include \"USD/hgiVk/conversions.h\"\n#include \"USD/hgiVk/device.h\"\n#include \"USD/hgiVk/diagnostic.h\"\n#include \"USD/hgiVk/renderPass.h\"\n#include \"USD/hgiVk/texture.h\"\n#include \"USD/hgiVk/vulkan.h\"\n\nHgiVkRenderPass::HgiVkRenderPass(\n    HgiVkDevice* device,\n    HgiGraphicsEncoderDesc const& desc)\n    : _device(device)\n    , _descriptor(desc)\n    , _vkRenderPass(nullptr)\n    , _vkFramebuffer(nullptr)\n    , _lastUsedFrame(0)\n{\n    // https://github.com/KhronosGroup/Vulkan-Docs/wiki/Synchronization-Examples\n    // https://gpuopen.com/vulkan-barriers-explained/\n    // http://gpuopen.com/wp-content/uploads/2016/03/VulkanFastPaths.pdf\n    // https://www.jeremyong.com/ \"vulkan-synchonization-primer-part-ii\"\n\n    // XXX We should not set VK_DEPENDENCY_BY_REGION_BIT if the shader is\n    // sampling arbitrary pixels from the framebuffer.\n    // E.g. screenspace reflection\n\n    // Prevent the render pass cache from deleting this render pass.\n    _lastUsedFrame = _device->GetCurrentFrame();\n\n    //\n    // Process attachments\n    //\n\n    HgiTextureUsage usage = 0;\n\n    HgiAttachmentDescConstPtrVector attachments = GetCombinedAttachments(desc);\n    for (HgiAttachmentDesc const* attachDesc : attachments) {\n        usage |= _ProcessAttachment(*attachDesc);\n    }\n\n    bool isSwapchain = usage & HgiTextureUsageBitsSwapchain;\n\n    //\n    // SubPasses\n    //\n    // Each RenderPass can have a number of sub-passes where each subpass\n    // uses the same attachment, but in potentially different ways. One subpass\n    // may write to an attachment where another subpass reads from it.\n    // An example of a using multiple subpasses is be doing a horizontal\n    // blur followed by a vertical blur.\n    //\n\n    // color\n    VK_SUBPASS_DESC subpassDescription = {VK_SUBPASS_TYPE};\n    subpassDescription.flags = 0;\n    subpassDescription.inputAttachmentCount = 0;\n    subpassDescription.pInputAttachments = 0;\n    subpassDescription.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;\n    subpassDescription.preserveAttachmentCount = 0;\n    subpassDescription.pPreserveAttachments = 0;\n    subpassDescription.pColorAttachments = _vkReferences.data();\n    subpassDescription.colorAttachmentCount =\n        (uint32_t)desc.colorAttachments.size();\n\n    // color resolve\n    if (!_descriptor.colorResolveAttachments.empty()) {\n        VK_ATTACHMENT_REF* resolveRefs = _vkReferences.data();\n        resolveRefs += _descriptor.colorAttachments.size();\n        subpassDescription.pResolveAttachments = resolveRefs;\n    }\n\n    // depth\n    size_t depthIndex = desc.colorAttachments.size() +\n                        desc.colorResolveAttachments.size();\n    if (desc.depthAttachment.texture) {\n        VK_ATTACHMENT_REF* depthAttachment = &_vkReferences[depthIndex];\n        subpassDescription.pDepthStencilAttachment = depthAttachment;\n    }\n\n    // depth resolve\n    #if defined(VK_RENDERPASS_2)\n        subpassDescription.viewMask = 0;\n\n        VkSubpassDescriptionDepthStencilResolveKHR depthResolve =\n            {VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR};\n\n        if (desc.depthAttachment.texture && desc.depthResolveAttachment.texture)\n        {\n            VK_ATTACHMENT_REF* depthResolveAttachment =\n                &_vkReferences[depthIndex+1];\n\n            depthResolve.pDepthStencilResolveAttachment= depthResolveAttachment;\n            depthResolve.depthResolveMode = VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR;\n            depthResolve.stencilResolveMode = VK_RESOLVE_MODE_NONE_KHR;\n            subpassDescription.pNext = &depthResolve;\n        }\n    #endif\n\n    //\n    // SubPass dependencies\n    //\n    // Use subpass dependencies to transition image layouts and act as barrier\n    // to ensure the read and write operations happen when it is allowed.\n    //\n    VK_SUBPASS_DEPENDENCY dependencies[2] =\n        {{VK_SUBPASS_DEPENDENCY_TYPE}, {VK_SUBPASS_DEPENDENCY_TYPE}};\n    // Start of subpass -- ensure shader reading is completed before FB write.\n    dependencies[0].srcSubpass = VK_SUBPASS_EXTERNAL;\n    dependencies[0].dstSubpass = 0;\n    dependencies[0].dependencyFlags = VK_DEPENDENCY_BY_REGION_BIT;\n\n    dependencies[0].srcStageMask = isSwapchain ?\n        VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT :\n        VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;\n\n    dependencies[0].dstStageMask =\n        VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT |\n        VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT;\n\n    dependencies[0].srcAccessMask = isSwapchain ?\n        VK_ACCESS_MEMORY_READ_BIT :\n        HgiVkRenderPass::GetDefaultDstAccessMask();\n\n    dependencies[0].dstAccessMask =\n        VK_ACCESS_COLOR_ATTACHMENT_READ_BIT |\n        VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT |\n        VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT |\n        VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;\n\n    #if defined(VK_RENDERPASS_2)\n        dependencies[0].viewOffset = 0;\n    #endif\n\n    // End of subpass -- ensure FB write is finished before shader reads.\n    dependencies[1].srcSubpass = 0;\n    dependencies[1].dstSubpass = VK_SUBPASS_EXTERNAL;\n    dependencies[1].dependencyFlags = VK_DEPENDENCY_BY_REGION_BIT;\n\n    dependencies[1].srcStageMask =\n        VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT |\n        VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT;\n    dependencies[1].dstStageMask = isSwapchain ?\n        VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT :\n        VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;\n\n    dependencies[1].srcAccessMask =\n        VK_ACCESS_COLOR_ATTACHMENT_READ_BIT |\n        VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT |\n        VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT |\n        VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;\n\n    dependencies[1].dstAccessMask = isSwapchain ?\n        VK_ACCESS_MEMORY_READ_BIT :\n        HgiVkRenderPass::GetDefaultDstAccessMask();\n\n    #if defined(VK_RENDERPASS_2)\n        dependencies[1].viewOffset = 0;\n    #endif\n\n    //\n    // Create the renderpass\n    //\n    VK_RENDERPASS_CREATE_INFO renderPassInfo = {};\n    renderPassInfo.sType = VK_RENDERPASS_CREATE_TYPE;\n    renderPassInfo.attachmentCount = attachments.size();\n    renderPassInfo.pAttachments = _vkDescriptions.data();\n    renderPassInfo.subpassCount = 1;\n    renderPassInfo.pSubpasses = &subpassDescription;\n    renderPassInfo.dependencyCount = 2;\n    renderPassInfo.pDependencies = &dependencies[0];\n\n    TF_VERIFY(\n        VK_CREATE_RENDERPASS(\n            _device->GetVulkanDevice(),\n            &renderPassInfo,\n            HgiVkAllocator(),\n            &_vkRenderPass) == VK_SUCCESS\n    );\n\n    // Debug label\n    if (!_descriptor.debugName.empty()) {\n        std::string debugLabel = \"Render Pass \" + _descriptor.debugName;\n        HgiVkSetDebugName(\n            _device,\n            (uint64_t)_vkRenderPass,\n            VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT,\n            debugLabel.c_str());\n    }\n\n    VkFramebufferCreateInfo fbufCreateInfo =\n        {VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO};\n    fbufCreateInfo.renderPass = _vkRenderPass;\n    fbufCreateInfo.attachmentCount = attachments.size();\n    fbufCreateInfo.pAttachments = _vkImageViews.data();\n    fbufCreateInfo.width = desc.width;\n    fbufCreateInfo.height = desc.height;\n    fbufCreateInfo.layers = 1;\n\n    TF_VERIFY(\n        vkCreateFramebuffer(\n            _device->GetVulkanDevice(),\n            &fbufCreateInfo,\n            HgiVkAllocator(),\n            &_vkFramebuffer) == VK_SUCCESS\n    );\n\n    // Debug label\n    if (!_descriptor.debugName.empty()) {\n        std::string debugLabel = \"Framebuffer \" + _descriptor.debugName;\n        HgiVkSetDebugName(\n            _device,\n            (uint64_t)_vkFramebuffer,\n            VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT,\n            debugLabel.c_str());\n    }\n}\n\nHgiVkRenderPass::~HgiVkRenderPass()\n{\n    vkDestroyFramebuffer(\n        _device->GetVulkanDevice(),\n        _vkFramebuffer,\n        HgiVkAllocator());\n\n    vkDestroyRenderPass(\n        _device->GetVulkanDevice(),\n        _vkRenderPass,\n        HgiVkAllocator());\n}\n\nbool\nHgiVkRenderPass::AcquireRenderPass()\n{\n    bool inUse = _acquired.test_and_set(std::memory_order_acquire);\n    return !inUse;\n}\n\nvoid\nHgiVkRenderPass::ReleaseRenderPass()\n{\n    _acquired.clear(std::memory_order_release);\n}\n\nvoid\nHgiVkRenderPass::BeginRenderPass(\n    HgiVkCommandBuffer* cb,\n    bool usesSecondaryCommandBuffers)\n{\n    // Prevent the render pass cache from deleting this render pass\n    _lastUsedFrame = _device->GetCurrentFrame();\n\n    // Begin render pass in primary command buffer\n    VkRenderPassBeginInfo renderPassBeginInfo =\n        {VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO};\n    renderPassBeginInfo.renderPass = _vkRenderPass;\n    renderPassBeginInfo.framebuffer = _vkFramebuffer;\n    renderPassBeginInfo.renderArea.extent.width = _descriptor.width;\n    renderPassBeginInfo.renderArea.extent.height = _descriptor.height;\n    renderPassBeginInfo.clearValueCount = _vkClearValues.size();\n    renderPassBeginInfo.pClearValues = _vkClearValues.data();\n\n    VkSubpassContents contents = usesSecondaryCommandBuffers ?\n        VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS :\n        VK_SUBPASS_CONTENTS_INLINE;\n\n    vkCmdBeginRenderPass(\n        cb->GetCommandBufferForRecoding(),\n        &renderPassBeginInfo,\n        contents);\n}\n\nvoid\nHgiVkRenderPass::EndRenderPass(HgiVkCommandBuffer* cb)\n{\n    vkCmdEndRenderPass(cb->GetCommandBufferForRecoding());\n}\n\nVkRenderPass\nHgiVkRenderPass::GetVulkanRenderPass() const\n{\n    return _vkRenderPass;\n}\n\nVkFramebuffer\nHgiVkRenderPass::GetVulkanFramebuffer() const\n{\n    return _vkFramebuffer;\n}\n\nHgiGraphicsEncoderDesc const&\nHgiVkRenderPass::GetDescriptor() const\n{\n    return _descriptor;\n}\n\nstd::vector<VkImageView> const&\nHgiVkRenderPass::GetImageViews() const\n{\n    return _vkImageViews;\n}\n\nHgiAttachmentDescConstPtrVector\nHgiVkRenderPass::GetCombinedAttachments(\n    HgiGraphicsEncoderDesc const& desc)\n{\n    HgiAttachmentDescConstPtrVector vec;\n    vec.reserve(desc.colorAttachments.size()+1);\n\n    // We rely on the order in which the attachments are returned in other\n    // parts of the code. So it is important we return color, followed by\n    // color resolve, followed by depth and finally depth resolve.\n\n    for (uint8_t i=0; i<desc.colorAttachments.size(); i++) {\n        if (desc.colorAttachments[i].texture) {\n            vec.push_back(&desc.colorAttachments[i]);\n        }\n    }\n    for (uint8_t i=0; i<desc.colorResolveAttachments.size(); i++) {\n        if (desc.colorResolveAttachments[i].texture) {\n            vec.push_back(&desc.colorResolveAttachments[i]);\n        }\n    }\n\n    if (desc.depthAttachment.texture) {\n        vec.push_back(&desc.depthAttachment);\n    }\n    if (desc.depthResolveAttachment.texture) {\n        vec.push_back(&desc.depthResolveAttachment);\n    }\n    return vec;\n}\n\nVkAccessFlags\nHgiVkRenderPass::GetDefaultDstAccessMask()\n{\n    // We are currently not tracking the 'dstAccessMask' state a texture is in.\n    // So when a render pass or other command transitions the image to a\n    // different dstAccessMask for a command to operate on the texture, we want\n    // that cmd to transition the image back to this default mask.\n    // For example HgiVkBlitEncoder::CopyTextureGpuToCpu transitions an texture\n    // TRANSFER_READ_BIT to copy the texture into a buffer.\n    // It will transfer it back to SHADER_READ so the next render pass that\n    // uses the texture knows that its current mask is SHADER_READ\n\n    // XXX Performance warning:\n    // Currently we always transition back to SHADER_READ at the end of a\n    // renderpass (see HgiVkRenderPass constructor) as that is the most likely\n    // next usage of a color target. A render-graph system could perhaps\n    // give us more fine-tuned transition and shader stage information and that\n    // will likely be better for performance.\n\n    return VK_ACCESS_SHADER_READ_BIT;\n}\n\nuint64_t\nHgiVkRenderPass::GetLastUsedFrame() const\n{\n    return _lastUsedFrame;\n}\n\nHgiTextureUsage\nHgiVkRenderPass::_ProcessAttachment(HgiAttachmentDesc const& attachment)\n{\n    HgiVkTexture const* tex =\n        static_cast<HgiVkTexture const*>(attachment.texture);\n    if (!TF_VERIFY(tex)) return HgiTextureUsageBitsUndefined;\n\n    HgiTextureDesc const& texDesc = tex->GetDescriptor();\n\n    bool isDepthBuffer = texDesc.usage & HgiTextureUsageBitsDepthTarget;\n    bool isSwapchain = texDesc.usage & HgiTextureUsageBitsSwapchain;\n\n    VK_ATTACHMENT_REF ref = {VK_ATTACHMENT_REF_TYPE};\n    ref.attachment = _vkImageViews.size();\n\n    // While HdFormat/HgiFormat do not support BGRA channel ordering it may\n    // be used for the native window swapchain on some platforms.\n    VkFormat format = isDepthBuffer ? VK_FORMAT_D32_SFLOAT_S8_UINT :\n                      HgiVkConversions::GetFormat(texDesc.format);\n    if (texDesc.usage & HgiTextureUsageBitsBGRA) {\n        if (format == VK_FORMAT_R8G8B8A8_UNORM) {\n            format = VK_FORMAT_B8G8R8A8_UNORM;\n        } else {\n            TF_CODING_ERROR(\"Unknown texture format with BGRA ordering\");\n        }\n    }\n\n    VK_ATTACHMENT_DESC desc = {VK_ATTACHMENT_DESC_TYPE};\n    desc.flags = 0;\n    desc.format = format;\n    desc.samples = HgiVkConversions::GetSampleCount(texDesc.sampleCount);\n    desc.loadOp = HgiVkConversions::GetLoadOp(attachment.loadOp);\n    desc.storeOp = HgiVkConversions::GetStoreOp(attachment.storeOp);\n    desc.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;       // XXX\n    desc.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE; // XXX\n\n    // VkAttachmentDescription::initialLayout and finalLayout are specified\n    // for the entire pass. And each reference to the same attachment can\n    // transition it to another layout with VkAttachmentReference::layout.\n    //\n    // The attachment and desired layout for the subpass are set in the\n    // VkAttachmentReference array, and then the subpass dependency tells\n    // the subpass when to change the layout.\n\n    // Layout of image just before RenderPass (here we use tex layout, but could\n    // also be the finalLayout of a previous render-pass)\n    desc.initialLayout = tex->GetImageLayout();\n\n    VkClearValue clearValue;\n\n    if (isDepthBuffer) {\n        clearValue.depthStencil.depth = attachment.clearValue[0];\n        clearValue.depthStencil.stencil = uint32_t(attachment.clearValue[1]);\n\n        // The layout of the image at the end of the entire pass\n        desc.finalLayout = isSwapchain ?\n            VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL :\n            VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL;\n\n        // The desired layout for this image during a subpass\n        ref.layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;\n        #if defined(VK_RENDERPASS_2)\n            ref.aspectMask = VK_IMAGE_ASPECT_DEPTH_BIT |\n                VK_IMAGE_ASPECT_STENCIL_BIT;\n        #endif\n    } else {\n        clearValue.color.float32[0] = attachment.clearValue[0];\n        clearValue.color.float32[1] = attachment.clearValue[1];\n        clearValue.color.float32[2] = attachment.clearValue[2];\n        clearValue.color.float32[3] = attachment.clearValue[3];\n\n        // The layout of the image at the end of the entire pass\n        desc.finalLayout = isSwapchain ?\n            VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL :\n            VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;\n\n        // The desired layout for this image during a subpass\n        ref.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;\n        #if defined(VK_RENDERPASS_2)\n            ref.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;\n        #endif\n    }\n\n    _vkClearValues.emplace_back(std::move(clearValue));\n    _vkImageViews.push_back(tex->GetImageView());\n    _vkDescriptions.emplace_back(std::move(desc));\n    _vkReferences.emplace_back(std::move(ref));\n\n    return texDesc.usage;\n}\n",
			"file": "src/USD/hgiVk/renderPass.cpp",
			"file_size": 15805,
			"file_write_time": 132398941479371656,
			"settings":
			{
				"buffer_size": 15805,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#ifndef PXR_IMAGING_HGIVK_PIPELINE_H\n#define PXR_IMAGING_HGIVK_PIPELINE_H\n\n#include <vector>\n\n#include \"pxr/pxr.h\"\n#include \"pxr/imaging/hgi/graphicsEncoderDesc.h\"\n#include \"pxr/imaging/hgi/pipeline.h\"\n\n#include \"USD/hgiVk/api.h\"\n#include \"USD/hgiVk/vulkan.h\"\n\n\nPXR_NAMESPACE_OPEN_SCOPE\n\nclass HgiVkDevice;\nclass HgiVkCommandBuffer;\nclass HgiVkRenderPass;\n\n\n/// \\class HgiVkPipeline\n///\n/// Vulkan implementation of HgiPipeline.\n///\nclass HgiVkPipeline final : public HgiPipeline {\npublic:\n    HGIVK_API\n    HgiVkPipeline(\n        HgiVkDevice* device,\n        HgiPipelineDesc const& desc);\n\n    HGIVK_API\n    virtual ~HgiVkPipeline();\n\n    /// Bind this pipeline to GPU.\n    /// For a graphics pipeline, render pass must be provided.\n    /// For a compute pipeline, render pass should be null.\n    HGIVK_API\n    void BindPipeline(\n        HgiVkCommandBuffer* cb,\n        HgiVkRenderPass* rp);\n\n    // Create pipeline object for _descriptor and render pass.\n    HGIVK_API\n    VkPipeline AcquirePipeline(HgiVkRenderPass* rp);\n\nprivate:\n    HgiVkPipeline() = delete;\n    HgiVkPipeline & operator=(const HgiVkPipeline&) = delete;\n    HgiVkPipeline(const HgiVkPipeline&) = delete;\n\n    // In Vulkan pipelines require compatibility with render passes.\n    // In Hgi we use gfx encoders instead of render passes.\n    // This struct stores the gfx descriptor the pipeline was made for.\n    struct _Pipeline {\n        HgiGraphicsEncoderDesc desc;\n        VkPipeline vkPipeline;\n    };\n\n    // Create graphics pipeline.\n    VkPipeline _AcquireGraphicsPipeline(HgiVkRenderPass* rp);\n\n    // Create compute pipeline.\n    VkPipeline _AcquireComputePipeline();\n\nprivate:\n    HgiVkDevice* _device;\n    HgiPipelineDesc _descriptor;\n    std::vector<_Pipeline> _pipelines;\n    VkPrimitiveTopology _vkTopology;\n};\n\n\nPXR_NAMESPACE_CLOSE_SCOPE\n\n#endif\n",
			"file": "src/USD/hgiVk/pipeline.h",
			"file_size": 1831,
			"file_write_time": 132398944995785052,
			"settings":
			{
				"buffer_size": 1831,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#include <algorithm>\n\n#include \"pxr/base/tf/diagnostic.h\"\n\n#include \"pxr/imaging/hgi/graphicsEncoderDesc.h\"\n\n#include \"USD/hgiVk/device.h\"\n#include \"USD/hgiVk/hgi.h\"\n#include \"USD/hgiVk/object.h\"\n#include \"USD/hgiVk/pipeline.h\"\n#include \"USD/hgiVk/renderPass.h\"\n#include \"USD/hgiVk/renderPassPipelineCache.h\"\n#include \"USD/hgiVk/texture.h\"\n\n\nPXR_NAMESPACE_OPEN_SCOPE\n\nthread_local uint16_t _HgiVkrpcThreadLocalIndex = 0;\nthread_local uint64_t _HgiVkrpcThreadLocalFrame = ~0ull;\n\n\nstruct HgiVkRenderPassCacheItem {\n    ~HgiVkRenderPassCacheItem() {\n        HgiVkObject object;\n        object.type = HgiVkObjectTypeRenderPass;\n        object.renderPass = renderPass;\n        device->DestroyObject(object);\n    }\n\n    HgiVkDevice* device = nullptr;\n    HgiGraphicsEncoderDesc descriptor;\n    HgiVkRenderPass* renderPass = nullptr;\n};\n\nstruct HgiVkRenderPassSort {\n    inline bool operator() (\n        const HgiVkRenderPassCacheItem* a,\n        const HgiVkRenderPassCacheItem* b) {\n        // Note we sort biggest to smallest frame number so that the oldest\n        // items are at the back of vector for efficient pop_back.\n        return (a->renderPass->GetLastUsedFrame() >\n                b->renderPass->GetLastUsedFrame());\n    }\n};\n\nstatic HgiVkRenderPassCacheItem*\n_CreateRenderPassCacheItem(\n    HgiVkDevice* device,\n    const HgiGraphicsEncoderDesc& desc)\n{\n    HgiVkRenderPassCacheItem* rci = new HgiVkRenderPassCacheItem();\n    rci->device = device;\n    rci->descriptor = desc;\n    rci->renderPass = new HgiVkRenderPass(device, desc);\n    return rci;\n}\n\nstatic void\n_DestroyRenderPassCacheItem(HgiVkRenderPassCacheItem* rci)\n{\n    delete rci;\n}\n\nstatic bool\n_CompareHgiGraphicsEncoderDesc(\n    HgiGraphicsEncoderDesc const& newDesc,\n    HgiVkRenderPassCacheItem const& cacheItem)\n{\n    // Comparing descriptors compares the properties and texture handles between\n    // the two descriptors. However it is pretty likely that a texture handle\n    // was deleted and later we get the same texture handle (ptr) for a\n    // different, new texture. Handles are pointers and it is up to the system\n    // to decide when it re-uses heap memory. If the handles do not match, we\n    // can safely say the render pass is not a match.\n    // However, if the descriptors match, we still need to do a deeper\n    // validation by comparing the vkImage handles.\n\n    if (newDesc != cacheItem.descriptor) return false;\n\n    HgiVkRenderPass* renderPass = cacheItem.renderPass;\n    std::vector<VkImageView> const& imageViews = renderPass->GetImageViews();\n\n    // Sort the attachments the same way the render pass had sorted its.\n    // That way we can compare the imageViews of the new descriptor and the\n    // renderpass in the correct order.\n    HgiAttachmentDescConstPtrVector attachmentL =\n        HgiVkRenderPass::GetCombinedAttachments(newDesc);\n\n    for (size_t i=0; i<attachmentL.size(); i++) {\n        VkImageView renderPassView = imageViews[i];\n\n        HgiAttachmentDesc const* aL = attachmentL[i];\n        HgiVkTexture* tex = static_cast<HgiVkTexture*>(aL->texture);\n\n        if (renderPassView != tex->GetImageView()) return false;\n    }\n\n    return true;\n}\n\nHgiVkRenderPassPipelineCache::HgiVkRenderPassPipelineCache()\n    : _frame(~0ull)\n    , _frameStarted(false)\n    , _nextThreadLocalIndex(0)\n{\n}\n\nHgiVkRenderPassPipelineCache::~HgiVkRenderPassPipelineCache()\n{\n    Clear();\n}\n\nHgiVkRenderPass*\nHgiVkRenderPassPipelineCache::AcquireRenderPass(\n    HgiVkDevice* device,\n    HgiGraphicsEncoderDesc const& desc)\n{\n    // First look in read-only cache for existing matching renderpass.\n    // We cannot add new items in _renderPassReadOnlyCache, because this a\n    // multi-threaded call and the cache is not thread-safe.\n    // We don't want to slow things down with a mutex because after the first\n    // frame we will usually find the render pass in this (read-only) cache.\n\n    for (size_t i=0; i<_renderPassReadOnlyCache.size(); i++) {\n        HgiVkRenderPassCacheItem* item = _renderPassReadOnlyCache[i];\n        if (_CompareHgiGraphicsEncoderDesc(desc, *item)) {\n            // A vulkan render pass cannot span across multiple command buffers.\n            // It must begin and end in the same command buffer.\n            // By testing with AcquireRenderPass we prevent multiple threads\n            // from using the same render pass during parallel recording.\n            bool available = item->renderPass->AcquireRenderPass();\n            if (available) {\n                return item->renderPass;\n            }\n        }\n    }\n\n    // Acquire this thread's index into the thread local passes / pipelines.\n\n    if (_HgiVkrpcThreadLocalFrame != _frame) {\n        _HgiVkrpcThreadLocalIndex = _nextThreadLocalIndex.fetch_add(1);\n        _HgiVkrpcThreadLocalFrame = _frame;\n    }\n\n    // If we didn't find the render pass in the global cache, look for it in\n    // our thread_local vector to see if we already created a matching\n    // render pass this frame.\n\n    if (_HgiVkrpcThreadLocalIndex >= _threadRenderPasses.size()) {\n        TF_CODING_ERROR(\"rpc numThreads > HgiVk::GetThreadCount\");\n        _HgiVkrpcThreadLocalIndex = 0;\n    }\n\n    HgiVkRenderPassCacheVec& pv= _threadRenderPasses[_HgiVkrpcThreadLocalIndex];\n    for (size_t i=0; i<pv.size(); i++) {\n        HgiVkRenderPassCacheItem* item = pv[i];\n        if (_CompareHgiGraphicsEncoderDesc(desc, *item)) {\n            return item->renderPass;\n        }\n    }\n\n    // If we found nothing, create a new render pass in thread_local vector.\n    // This new render pass will get merged into the renderPassCache at the\n    // end of the frame.\n    HgiVkRenderPassCacheItem* pci = _CreateRenderPassCacheItem(device, desc);\n    pv.push_back(pci);\n    return pci->renderPass;\n}\n\nvoid\nHgiVkRenderPassPipelineCache::BeginFrame(uint64_t frame)\n{\n    if (_frameStarted) return;\n    _frameStarted = true;\n\n    // Change the frame counter. This will let each thread know that they\n    // must re-initializes themselves the next time a thread uses the locals.\n    _frame = frame;\n\n    // Ensure the thread_local vectors have enough room for each thread.\n    uint32_t numThreads = HgiVk::GetThreadCount();\n\n    if (_threadRenderPasses.size() != numThreads) {\n        _threadRenderPasses.resize(numThreads);\n    }\n}\n\nvoid\nHgiVkRenderPassPipelineCache::EndFrame()\n{\n    const size_t descriptorLRUsize = 32;\n\n    HgiVkRenderPassCacheVec& passCache = _renderPassReadOnlyCache;\n\n    // Merge all thread_local passes / pipelines into read-only cache.\n    // We sort to ensure the newly created items are last to exit cache.\n    //\n    // It is possible (though rare) that two threads haved created the exact\n    // same renderpass or pipeline within one frame. We make no attempt here to\n    // erase the dups, because we consider these lightweight objects\n    // (textures/render-targets are not duplicated, only their description).\n    //\n    // These dups will eventually be removed from the cache when\n    // the cache size limit is reached.\n\n    for (HgiVkRenderPassCacheVec& v : _threadRenderPasses) {\n        passCache.insert(passCache.end(), v.begin(), v.end());\n        v.clear();\n        v.shrink_to_fit();\n    }\n    std::sort(passCache.begin(), passCache.end());\n\n    // If we reached the max size of the cache remove the oldest items.\n    if (passCache.size() > descriptorLRUsize) {\n        std::sort(passCache.begin(), passCache.end(), HgiVkRenderPassSort());\n\n        while (passCache.size() > descriptorLRUsize) {\n            _DestroyRenderPassCacheItem(passCache.back());\n            passCache.pop_back();\n        }\n    }\n\n    // Next frame each thread should acquire a new index into thread_local vecs.\n    _nextThreadLocalIndex.store(0);\n    _frameStarted = false;\n}\n\nvoid\nHgiVkRenderPassPipelineCache::Clear()\n{\n    // Make sure any thread_local render passes are merged into read-only cache.\n    EndFrame();\n\n    // Destroy all render passes\n    for (HgiVkRenderPassCacheItem* rci : _renderPassReadOnlyCache) {\n        _DestroyRenderPassCacheItem(rci);\n    }\n    _renderPassReadOnlyCache.clear();\n}\n\nPXR_NAMESPACE_CLOSE_SCOPE\n",
			"file": "src/USD/hgiVk/renderPassPipelineCache.cpp",
			"file_size": 8095,
			"file_write_time": 132398941673930087,
			"settings":
			{
				"buffer_size": 8095,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#include <unordered_set>\n\n#include \"USD/hgiVk/buffer.h\"\n#include \"USD/hgiVk/commandBuffer.h\"\n#include \"USD/hgiVk/conversions.h\"\n#include \"USD/hgiVk/device.h\"\n#include \"USD/hgiVk/diagnostic.h\"\n#include \"USD/hgiVk/resourceBindings.h\"\n#include \"USD/hgiVk/texture.h\"\n#include \"USD/hgiVk/vulkan.h\"\n\nPXR_NAMESPACE_OPEN_SCOPE\n\nHgiVkResourceBindings::HgiVkResourceBindings(\n    HgiVkDevice* device,\n    HgiResourceBindingsDesc const& desc)\n    : HgiResourceBindings(desc)\n    , _device(device)\n    , _descriptor(desc)\n    , _vkDescriptorSetLayout(nullptr)\n    , _vkDescriptorSet(nullptr)\n    , _vkPipelineLayout(nullptr)\n{\n    // initialize the pool sizes for each descriptor type we support\n    std::vector<VkDescriptorPoolSize> poolSizes;\n    poolSizes.resize(HgiBindResourceTypeCount);\n\n    for (size_t i=0; i<HgiBindResourceTypeCount; i++) {\n        HgiBindResourceType bt = HgiBindResourceType(i);\n        VkDescriptorPoolSize p;\n        p.descriptorCount = 0;\n        p.type = HgiVkConversions::GetDescriptorType(bt);\n        poolSizes[i] = p;\n    }\n\n    //\n    // Create DescriptorSetLayout to describe resource bindings\n    //\n    // The descriptors are reference by shader code. E.g.\n    //   layout (set=0, binding=0) uniform sampler2D...\n    //   layout (std140, binding=1) uniform buffer{}\n    //\n    std::unordered_set<uint32_t> bindingsVisited;\n    std::vector<VkDescriptorSetLayoutBinding> bindings;\n\n    for (HgiTextureBindDesc const& t : desc.textures) {\n        VkDescriptorSetLayoutBinding d = {};\n        uint32_t bi = t.bindingIndex;\n        if (bindingsVisited.find(bi)!=bindingsVisited.end()) {\n            TF_WARN(\"Binding index must be unique in descriptor set.\");\n        }\n        d.binding = bi; // binding number in shader stage\n        bindingsVisited.insert(bi);\n        d.descriptorType = HgiVkConversions::GetDescriptorType(t.resourceType);\n        poolSizes[t.resourceType].descriptorCount++;\n        d.descriptorCount = (uint32_t) t.textures.size();\n        d.stageFlags = HgiVkConversions::GetShaderStages(t.stageUsage);\n        d.pImmutableSamplers = nullptr;\n        bindings.emplace_back(std::move(d));\n    }\n\n    for (HgiBufferBindDesc const& b : desc.buffers) {\n        VkDescriptorSetLayoutBinding d = {};\n        uint32_t bi = b.bindingIndex;\n        if (bindingsVisited.find(bi)!=bindingsVisited.end()) {\n            TF_WARN(\"Binding index must be unique in descriptor set.\");\n        }\n        d.binding = bi; // binding number in shader stage\n        bindingsVisited.insert(bi);\n        d.descriptorType = HgiVkConversions::GetDescriptorType(b.resourceType);\n        poolSizes[b.resourceType].descriptorCount++;\n        d.descriptorCount = (uint32_t) b.buffers.size();\n        d.stageFlags = HgiVkConversions::GetShaderStages(b.stageUsage);\n        d.pImmutableSamplers = nullptr;\n        bindings.emplace_back(std::move(d));\n    }\n\n    // Check descriptor indexing support.\n    VkPhysicalDeviceDescriptorIndexingFeaturesEXT indexingFeatures =\n        _device->GetVulkanPhysicalDeviceIndexingFeatures();\n    VkDescriptorBindingFlagsEXT bindFlags = 0;\n\n    // We use descriptor indexing, meaning certain arrays of textures are\n    // dynamic in size. We have to provide the 'variable' flag for those arrays.\n    if (indexingFeatures.descriptorBindingVariableDescriptorCount) {\n        bindFlags |= VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT;\n    }\n\n    // We also set the 'partially bound' flag so that the set may have invalid\n    // descriptors in it, as long as a shader is not using them.\n    if (indexingFeatures.descriptorBindingPartiallyBound) {\n        bindFlags |= VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT;\n    }\n\n    // XXX the following flags are also interesting as they give us more\n    // flexiblity to update descriptor sets. We skip them for now.\n    // VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT\n    // VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT\n\n    VkDescriptorSetLayoutBindingFlagsCreateInfoEXT setLayoutBindingFlags = {\n        VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT};\n    setLayoutBindingFlags.bindingCount = (uint32_t) bindings.size();\n    std::vector<VkDescriptorBindingFlagsEXT> descriptorBindingFlags(\n        bindings.size(), bindFlags);\n    setLayoutBindingFlags.pBindingFlags = descriptorBindingFlags.data();\n\n    // Create descriptor\n    VkDescriptorSetLayoutCreateInfo setCreateInfo =\n        {VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO};\n    setCreateInfo.bindingCount = (uint32_t) bindings.size();\n    setCreateInfo.pBindings = bindings.data();\n    setCreateInfo.pNext = bindFlags ? &setLayoutBindingFlags : nullptr;\n\n    TF_VERIFY(\n        vkCreateDescriptorSetLayout(\n            _device->GetVulkanDevice(),\n            &setCreateInfo,\n            HgiVkAllocator(),\n            &_vkDescriptorSetLayout) == VK_SUCCESS\n    );\n\n    // Debug label\n    if (!_descriptor.debugName.empty()) {\n        std::string debugLabel = \"Descriptor Set Layout \" + _descriptor.debugName;\n        HgiVkSetDebugName(\n            _device,\n            (uint64_t)_vkDescriptorSetLayout,\n            VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT,\n            debugLabel.c_str());\n    }\n\n    //\n    // Create the descriptor pool.\n    //\n    // XXX For now each resource bindings gets its own pool to allocate its\n    // descriptor set from. We can't have a global descriptor pool since we have\n    // multiple threads creating resourceBindings. On top of that, when the\n    // resourceBindings gets destroyed it must de-allocate its descriptor set\n    // in the correct descriptor pool (which is different than command buffers\n    // where the entire pool is reset at the beginning of a new frame).\n    //\n    // If having a descriptor pool per resourceBindings turns out to be too much\n    // overhead (e.g. if many resourceBindings are created/destroyed each frame)\n    // then we can consider an approach similar to thread local command buffers.\n    // We could allocate larger descriptor pools per frame and per thread.\n    //\n\n    for (size_t i=poolSizes.size(); i-- > 0;) {\n        // Remove empty descriptorPoolSize or vulkan validation will complain\n        if (poolSizes[i].descriptorCount == 0) {\n            std::iter_swap(poolSizes.begin() + i, poolSizes.end() - 1);\n            poolSizes.pop_back();\n        }\n    }\n\n    VkDescriptorPoolCreateInfo pool_info = {};\n    pool_info.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;\n    pool_info.flags = VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT;\n    pool_info.maxSets = 1; // Each resourceBinding has own pool -- read above\n    pool_info.poolSizeCount = (uint32_t) poolSizes.size();\n    pool_info.pPoolSizes = poolSizes.data();\n\n    TF_VERIFY(\n        vkCreateDescriptorPool(\n            _device->GetVulkanDevice(),\n            &pool_info,\n            HgiVkAllocator(),\n            &_vkDescriptorPool) == VK_SUCCESS\n    );\n\n    // Debug label\n    if (!_descriptor.debugName.empty()) {\n        std::string debugLabel = \"Descriptor Pool \" + _descriptor.debugName;\n        HgiVkSetDebugName(\n            _device,\n            (uint64_t)_vkDescriptorPool,\n            VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT,\n            debugLabel.c_str());\n    }\n\n    //\n    // Create Descriptor Set\n    //\n    VkDescriptorSetAllocateInfo allocateInfo =\n        {VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO};\n\n    allocateInfo.descriptorPool = _vkDescriptorPool;\n    allocateInfo.descriptorSetCount = 1;\n    allocateInfo.pSetLayouts = &_vkDescriptorSetLayout;\n\n    TF_VERIFY(\n        vkAllocateDescriptorSets(\n            _device->GetVulkanDevice(),\n            &allocateInfo,\n            &_vkDescriptorSet) == VK_SUCCESS\n    );\n\n    // Debug label\n    if (!_descriptor.debugName.empty()) {\n        std::string debugLabel = \"Descriptor Set \" + _descriptor.debugName;\n        HgiVkSetDebugName(\n            _device,\n            (uint64_t)_vkDescriptorSet,\n            VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT,\n            debugLabel.c_str());\n    }\n\n    //\n    // Setup limits for each resource type\n    //\n    VkPhysicalDeviceProperties const& devProps =\n        _device->GetVulkanPhysicalDeviceProperties();\n    VkPhysicalDeviceLimits const& limits = devProps.limits;\n\n    uint32_t bindLimits[HgiBindResourceTypeCount][2] = {\n        {HgiBindResourceTypeSampler,\n            limits.maxPerStageDescriptorSamplers},\n        {HgiBindResourceTypeCombinedImageSampler,\n            0 /*Should use SamplerImage limits below*/},\n        {HgiBindResourceTypeSamplerImage,\n            limits.maxPerStageDescriptorSampledImages},\n        {HgiBindResourceTypeStorageImage,\n            limits.maxPerStageDescriptorStorageImages},\n        {HgiBindResourceTypeUniformBuffer,\n            limits.maxPerStageDescriptorUniformBuffers},\n        {HgiBindResourceTypeStorageBuffer,\n            limits.maxPerStageDescriptorStorageBuffers}\n    };\n\n\n    //\n    // Textures\n    //\n\n    std::vector<VkWriteDescriptorSet> writeSets;\n\n    _imageInfos.clear();\n\n    for (size_t i=0; i<desc.textures.size(); i++) {\n        HgiTextureBindDesc const& texDesc = desc.textures[i];\n\n        uint32_t & limit = bindLimits[HgiBindResourceTypeSamplerImage][1];\n        if (!TF_VERIFY(limit>0, \"Maximum array-of-texture/samplers exceeded\")) {\n            break;\n        }\n        limit -= 1;\n\n        for (HgiTextureHandle const& texHandle : texDesc.textures) {\n            HgiVkTexture* tex = static_cast<HgiVkTexture*>(texHandle);\n            if (!TF_VERIFY(tex)) continue;\n            VkDescriptorImageInfo imageInfo;\n            imageInfo.sampler = tex->GetSampler();\n            imageInfo.imageLayout = tex->GetImageLayout();\n            imageInfo.imageView = tex->GetImageView();\n            _imageInfos.emplace_back(std::move(imageInfo));\n        }\n\n        // For dstBinding we must provided an index in descriptor set.\n        // Must be one of the bindings specified in VkDescriptorSetLayoutBinding\n        VkWriteDescriptorSet writeSet= {VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET};\n        writeSet.dstBinding = texDesc.bindingIndex; // index in descriptor set\n        writeSet.dstArrayElement = 0;\n        writeSet.descriptorCount = (uint32_t) texDesc.textures.size();\n        writeSet.dstSet = _vkDescriptorSet;\n        writeSet.pBufferInfo = nullptr;\n        writeSet.pImageInfo = _imageInfos.data();\n        writeSet.pTexelBufferView = nullptr;\n        writeSet.descriptorType =\n            HgiVkConversions::GetDescriptorType(texDesc.resourceType);\n        writeSets.emplace_back(std::move(writeSet));\n    }\n\n    //\n    // Buffers\n    //\n\n    _bufferInfos.clear();\n\n    for (size_t i=0; i<desc.buffers.size(); i++) {\n        HgiBufferBindDesc const& bufDesc = desc.buffers[i];\n\n        uint32_t & limit = bindLimits[bufDesc.resourceType][1];\n        if (!TF_VERIFY(limit>0, \"Maximum size array-of-buffers exceeded\")) {\n            break;\n        }\n        limit -= 1;\n\n        TF_VERIFY(bufDesc.buffers.size() == bufDesc.offsets.size());\n\n        for (HgiBufferHandle const& bufHandle : bufDesc.buffers) {\n            HgiVkBuffer* buf = static_cast<HgiVkBuffer*>(bufHandle);\n            if (!TF_VERIFY(buf)) continue;\n            VkDescriptorBufferInfo bufferInfo;\n            bufferInfo.buffer = buf->GetBuffer();\n            bufferInfo.offset = bufDesc.offsets[i];\n            bufferInfo.range = VK_WHOLE_SIZE;\n            _bufferInfos.emplace_back(std::move(bufferInfo));\n        }\n\n        VkWriteDescriptorSet writeSet= {VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET};\n        writeSet.dstBinding = bufDesc.bindingIndex; // index in descriptor set\n        writeSet.dstArrayElement = 0;\n        writeSet.descriptorCount = (uint32_t) bufDesc.buffers.size();\n        writeSet.dstSet = _vkDescriptorSet;\n        writeSet.pBufferInfo = _bufferInfos.data();\n        writeSet.pImageInfo = nullptr;\n        writeSet.pTexelBufferView = nullptr;\n        writeSet.descriptorType =\n            HgiVkConversions::GetDescriptorType(bufDesc.resourceType);\n        writeSets.emplace_back(std::move(writeSet));\n    }\n\n    // Note: this update happens immediate. It is not recorded via a command.\n    // This means we should only do this if the descriptorSet is not currently\n    // in use on GPU. With 'descriptor indexing' extension this has relaxed a\n    // little and we are allowed to use vkUpdateDescriptorSets before\n    // vkBeginCommandBuffer and after vkEndCommandBuffer, just not during the\n    // command buffer recording.\n    vkUpdateDescriptorSets(\n        _device->GetVulkanDevice(),\n        (uint32_t) writeSets.size(),\n        writeSets.data(),\n        0,        // copy count\n        nullptr); // copy_desc\n\n    //\n    // Pipeline layout contains descriptor set layouts and push constant ranges.\n    //\n\n    std::vector<VkPushConstantRange> pcRanges;\n    for (HgiPushConstantDesc const& pcDesc : desc.pushConstants) {\n        TF_VERIFY(pcDesc.byteSize % 4 == 0, \"Push constants not multipes of 4\");\n        VkPushConstantRange pushConstantRange = {};\n        pushConstantRange.offset = pcDesc.offset;\n        pushConstantRange.size = pcDesc.byteSize;\n        pushConstantRange.stageFlags =\n            HgiVkConversions::GetShaderStages(pcDesc.stageUsage);\n\n        pcRanges.emplace_back(std::move(pushConstantRange));\n    }\n\n    VkPipelineLayoutCreateInfo pipeLayCreateInfo =\n        {VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO};\n    pipeLayCreateInfo.pushConstantRangeCount = (uint32_t) pcRanges.size();\n    pipeLayCreateInfo.pPushConstantRanges = pcRanges.data();\n    pipeLayCreateInfo.setLayoutCount = 1;\n    pipeLayCreateInfo.pSetLayouts = &_vkDescriptorSetLayout;\n\n    TF_VERIFY(\n        vkCreatePipelineLayout(\n            _device->GetVulkanDevice(),\n            &pipeLayCreateInfo,\n            HgiVkAllocator(),\n            &_vkPipelineLayout) == VK_SUCCESS\n    );\n\n    // Debug label\n    if (!_descriptor.debugName.empty()) {\n        std::string debugLabel = \"Pipeline Layout \" + _descriptor.debugName;\n        HgiVkSetDebugName(\n            _device,\n            (uint64_t)_vkPipelineLayout,\n            VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT,\n            debugLabel.c_str());\n    }\n}\n\nHgiVkResourceBindings::~HgiVkResourceBindings()\n{\n    vkDestroyDescriptorSetLayout(\n        _device->GetVulkanDevice(),\n        _vkDescriptorSetLayout,\n        HgiVkAllocator());\n\n    vkDestroyPipelineLayout(\n        _device->GetVulkanDevice(),\n        _vkPipelineLayout,\n        HgiVkAllocator());\n\n    // Since we have one pool for this resourceBindings we can reset the pool\n    // instead of freeing the descriptorSet.\n    //\n    // if (_vkDescriptorSet) {\n    //     vkFreeDescriptorSets(\n    //         _device->GetVulkanDevice(),\n    //         _vkDescriptorPool,\n    //         1,\n    //         &_vkDescriptorSet);\n    // }\n    //\n    vkDestroyDescriptorPool(\n        _device->GetVulkanDevice(),\n        _vkDescriptorPool,\n        HgiVkAllocator());\n}\n\nHgiBufferBindDescVector const&\nHgiVkResourceBindings::GetBufferBindings() const\n{\n    return _descriptor.buffers;\n}\n\nHgiTextureBindDescVector const&\nHgiVkResourceBindings::GetTextureBindings() const\n{\n    return _descriptor.textures;\n}\n\nHgiVertexBufferDescVector const&\nHgiVkResourceBindings::GetVertexBuffers() const\n{\n    return _descriptor.vertexBuffers;\n}\n\nvoid\nHgiVkResourceBindings::BindResources(HgiVkCommandBuffer* cb)\n{\n    VkPipelineBindPoint bindPoint =\n        _descriptor.pipelineType == HgiPipelineTypeCompute ?\n        VK_PIPELINE_BIND_POINT_COMPUTE :\n        VK_PIPELINE_BIND_POINT_GRAPHICS;\n\n    // When binding new resources for the currently bound pipeline it may\n    // 'disturb' previously bound resources (for a previous pipeline) that\n    // are no longer compatible with the layout for the new pipeline.\n    // This essentially unbinds the old resources.\n\n    vkCmdBindDescriptorSets(\n        cb->GetCommandBufferForRecoding(),\n        bindPoint,\n        _vkPipelineLayout,\n        0, // firstSet\n        1, // descriptorSetCount -- strict limits, see maxBoundDescriptorSets\n        &_vkDescriptorSet,\n        0, // dynamicOffset\n        nullptr);\n}\n\nVkPipelineLayout\nHgiVkResourceBindings::GetPipelineLayout() const\n{\n    return _vkPipelineLayout;\n}\n\nVkDescriptorSet\nHgiVkResourceBindings::GetDescriptorSet() const\n{\n    return _vkDescriptorSet;\n}\n\nVkDescriptorImageInfoVector const&\nHgiVkResourceBindings::GetImageInfos() const\n{\n    return _imageInfos;\n}\n\nVkDescriptorBufferInfoVector const&\nHgiVkResourceBindings::GetBufferInfos() const\n{\n    return _bufferInfos;\n}\n\nPXR_NAMESPACE_CLOSE_SCOPE\n",
			"file": "src/USD/hgiVk/resourceBindings.cpp",
			"file_size": 16563,
			"file_write_time": 132398941879768427,
			"settings":
			{
				"buffer_size": 16563,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#if defined(_WIN32)\n    #include <Windows.h>\n#endif\n\n#include <string>\n#include <vector>\n\n#include \"pxr/base/tf/diagnostic.h\"\n\n#include \"USD/hgiVk/shaderCompiler.h\"\n#include \"USD/hgiVk/glslang/glslang/Public/ShaderLang.h\"\n#include \"USD/hgiVk/glslang/SPIRV/GlslangToSpv.h\"\n#include \"USD/hgiVk/glslang/OGLCompilersDLL/InitializeDll.h\"\n\nPXR_NAMESPACE_OPEN_SCOPE\n\nstatic bool _glslangInitialized = false;\n\nEShLanguage\n_GetShaderStage(HgiShaderStage stage)\n{\n    switch(stage) {\n        default: TF_CODING_ERROR(\"Unknown stage\"); return EShLangCount;\n\n        case HgiShaderStageVertex: return EShLangVertex;\n        // todo missing in Hgi\n        //case HgiShaderStageTessControl: return EShLangTessControl;\n        //case HgiShaderStageTessEval: return EShLangTessEvaluation;\n        //case HgiShaderStageGeometry: return EShLangGeometry;\n        case HgiShaderStageFragment: return EShLangFragment;\n        case HgiShaderStageCompute: return EShLangCompute;\n    }\n}\n\nHgiVkShaderCompiler::HgiVkShaderCompiler()\n{\n    // Initialize() should be called exactly once per PROCESS.\n    if (!_glslangInitialized) {\n        glslang::InitializeProcess();\n        _glslangInitialized = true;\n    }\n}\n\nHgiVkShaderCompiler::~HgiVkShaderCompiler()\n{\n    if (_glslangInitialized) {\n        glslang::FinalizeProcess();\n        _glslangInitialized = false;\n    }\n}\n\nvoid\nHgiVkShaderCompiler::AddIncludeDir(const char* dir)\n{\n    _dirStackIncluder.pushExternalLocalDirectory(dir);\n}\n\nbool\nHgiVkShaderCompiler::CompileGLSL(\n    const char* name,\n    const char* shaderCodes,\n    uint8_t numShaderCodes,\n    HgiShaderStage stage,\n    std::vector<unsigned int>* spirvOUT,\n    std::string* errors)\n{\n    // Hydra is multi-threaded so each new thread must init once.\n    glslang::InitThread();\n\n    if (numShaderCodes==0 || !spirvOUT) {\n        if (errors) {\n            errors->append(\"No shader to compile %s\", name);\n        }\n        return false;\n    }\n\n    EShLanguage shaderType = _GetShaderStage(stage);\n    glslang::TShader shader(shaderType);\n    shader.setStrings(&shaderCodes, numShaderCodes);\n\n    //\n    // Set up Vulkan/SpirV Environment\n    //\n\n    // Maps approx to #define VULKAN 100\n    int ClientInputSemanticsVersion = 100;\n\n    glslang::EShTargetClientVersion vulkanClientVersion =\n        glslang::EShTargetVulkan_1_0;\n\n    glslang::EShTargetLanguageVersion targetVersion =\n        glslang::EShTargetSpv_1_0;\n\n    shader.setEnvInput(\n        glslang::EShSourceGlsl,\n        shaderType,\n        glslang::EShClientVulkan,\n        ClientInputSemanticsVersion);\n\n    shader.setEnvClient(glslang::EShClientVulkan, vulkanClientVersion);\n    shader.setEnvTarget(glslang::EShTargetSpv, targetVersion);\n\n    //\n    // Setup compiler limits/caps\n    //\n\n    // Reference see file: StandAlone/ResourceLimits.cpp\n    // https://github.com/KhronosGroup/glslang\n    //\n    // https://github.com/KhronosGroup/glslang/blob/master/glslang/\n    // OSDependent/Web/glslang.js.cpp\n    const TBuiltInResource DefaultTBuiltInResource = {\n        /* .MaxLights = */ 32,\n        /* .MaxClipPlanes = */ 6,\n        /* .MaxTextureUnits = */ 32,\n        /* .MaxTextureCoords = */ 32,\n        /* .MaxVertexAttribs = */ 64,\n        /* .MaxVertexUniformComponents = */ 4096,\n        /* .MaxVaryingFloats = */ 64,\n        /* .MaxVertexTextureImageUnits = */ 32,\n        /* .MaxCombinedTextureImageUnits = */ 80,\n        /* .MaxTextureImageUnits = */ 32,\n        /* .MaxFragmentUniformComponents = */ 4096,\n        /* .MaxDrawBuffers = */ 32,\n        /* .MaxVertexUniformVectors = */ 128,\n        /* .MaxVaryingVectors = */ 8,\n        /* .MaxFragmentUniformVectors = */ 16,\n        /* .MaxVertexOutputVectors = */ 16,\n        /* .MaxFragmentInputVectors = */ 15,\n        /* .MinProgramTexelOffset = */ -8,\n        /* .MaxProgramTexelOffset = */ 7,\n        /* .MaxClipDistances = */ 8,\n        /* .MaxComputeWorkGroupCountX = */ 65535,\n        /* .MaxComputeWorkGroupCountY = */ 65535,\n        /* .MaxComputeWorkGroupCountZ = */ 65535,\n        /* .MaxComputeWorkGroupSizeX = */ 1024,\n        /* .MaxComputeWorkGroupSizeY = */ 1024,\n        /* .MaxComputeWorkGroupSizeZ = */ 64,\n        /* .MaxComputeUniformComponents = */ 1024,\n        /* .MaxComputeTextureImageUnits = */ 16,\n        /* .MaxComputeImageUniforms = */ 8,\n        /* .MaxComputeAtomicCounters = */ 8,\n        /* .MaxComputeAtomicCounterBuffers = */ 1,\n        /* .MaxVaryingComponents = */ 60,\n        /* .MaxVertexOutputComponents = */ 64,\n        /* .MaxGeometryInputComponents = */ 64,\n        /* .MaxGeometryOutputComponents = */ 128,\n        /* .MaxFragmentInputComponents = */ 128,\n        /* .MaxImageUnits = */ 8,\n        /* .MaxCombinedImageUnitsAndFragmentOutputs = */ 8,\n        /* .MaxCombinedShaderOutputResources = */ 8,\n        /* .MaxImageSamples = */ 0,\n        /* .MaxVertexImageUniforms = */ 0,\n        /* .MaxTessControlImageUniforms = */ 0,\n        /* .MaxTessEvaluationImageUniforms = */ 0,\n        /* .MaxGeometryImageUniforms = */ 0,\n        /* .MaxFragmentImageUniforms = */ 8,\n        /* .MaxCombinedImageUniforms = */ 8,\n        /* .MaxGeometryTextureImageUnits = */ 16,\n        /* .MaxGeometryOutputVertices = */ 256,\n        /* .MaxGeometryTotalOutputComponents = */ 1024,\n        /* .MaxGeometryUniformComponents = */ 1024,\n        /* .MaxGeometryVaryingComponents = */ 64,\n        /* .MaxTessControlInputComponents = */ 128,\n        /* .MaxTessControlOutputComponents = */ 128,\n        /* .MaxTessControlTextureImageUnits = */ 16,\n        /* .MaxTessControlUniformComponents = */ 1024,\n        /* .MaxTessControlTotalOutputComponents = */ 4096,\n        /* .MaxTessEvaluationInputComponents = */ 128,\n        /* .MaxTessEvaluationOutputComponents = */ 128,\n        /* .MaxTessEvaluationTextureImageUnits = */ 16,\n        /* .MaxTessEvaluationUniformComponents = */ 1024,\n        /* .MaxTessPatchComponents = */ 120,\n        /* .MaxPatchVertices = */ 32,\n        /* .MaxTessGenLevel = */ 64,\n        /* .MaxViewports = */ 16,\n        /* .MaxVertexAtomicCounters = */ 0,\n        /* .MaxTessControlAtomicCounters = */ 0,\n        /* .MaxTessEvaluationAtomicCounters = */ 0,\n        /* .MaxGeometryAtomicCounters = */ 0,\n        /* .MaxFragmentAtomicCounters = */ 8,\n        /* .MaxCombinedAtomicCounters = */ 8,\n        /* .MaxAtomicCounterBindings = */ 1,\n        /* .MaxVertexAtomicCounterBuffers = */ 0,\n        /* .MaxTessControlAtomicCounterBuffers = */ 0,\n        /* .MaxTessEvaluationAtomicCounterBuffers = */ 0,\n        /* .MaxGeometryAtomicCounterBuffers = */ 0,\n        /* .MaxFragmentAtomicCounterBuffers = */ 1,\n        /* .MaxCombinedAtomicCounterBuffers = */ 1,\n        /* .MaxAtomicCounterBufferSize = */ 16384,\n        /* .MaxTransformFeedbackBuffers = */ 4,\n        /* .MaxTransformFeedbackInterleavedComponents = */ 64,\n        /* .MaxCullDistances = */ 8,\n        /* .MaxCombinedClipAndCullDistances = */ 8,\n        /* .MaxSamples = */ 4,\n        /* .maxMeshOutputVerticesNV = */ 256,\n        /* .maxMeshOutputPrimitivesNV = */ 512,\n        /* .maxMeshWorkGroupSizeX_NV = */ 32,\n        /* .maxMeshWorkGroupSizeY_NV = */ 1,\n        /* .maxMeshWorkGroupSizeZ_NV = */ 1,\n        /* .maxTaskWorkGroupSizeX_NV = */ 32,\n        /* .maxTaskWorkGroupSizeY_NV = */ 1,\n        /* .maxTaskWorkGroupSizeZ_NV = */ 1,\n        /* .maxMeshViewCountNV = */ 4,\n\n        /* .limits = */ {\n            /* .nonInductiveForLoops = */ 1,\n            /* .whileLoops = */ 1,\n            /* .doWhileLoops = */ 1,\n            /* .generalUniformIndexing = */ 1,\n            /* .generalAttributeMatrixVectorIndexing = */ 1,\n            /* .generalVaryingIndexing = */ 1,\n            /* .generalSamplerIndexing = */ 1,\n            /* .generalVariableIndexing = */ 1,\n            /* .generalConstantMatrixVectorIndexing = */ 1,\n        }};\n\n    EShMessages messages = (EShMessages) (EShMsgSpvRules | EShMsgVulkanRules);\n\n    //\n    // Run PreProcess\n    //\n    const int defaultVersion = 100;\n    std::string preprocessedGLSL;\n\n    bool preProcessOK = shader.preprocess(\n            &DefaultTBuiltInResource,\n            defaultVersion,\n            ECoreProfile,\n            false,\n            false,\n            messages,\n            &preprocessedGLSL,\n            _dirStackIncluder); // Alt: glslang::TShader::ForbidIncluder\n\n    if (!preProcessOK) {\n        if (errors) {\n            errors->append(\"GLSL Preprocessing Failed for: \");\n            errors->append(name);\n            errors->append(\"\\n\");\n            errors->append(shader.getInfoLog());\n            errors->append(shader.getInfoDebugLog());\n        }\n        return false;\n    }\n\n    //\n    // Parse and link shader\n    //\n    const char* preprocessedCStr = preprocessedGLSL.c_str();\n    shader.setStrings(&preprocessedCStr, 1);\n\n    if (!shader.parse(&DefaultTBuiltInResource, 100, false, messages)) {\n        if (errors) {\n            errors->append(\"GLSL Parsing Failed for: \");\n            errors->append(name);\n            errors->append(\"\\n\");\n            errors->append(shader.getInfoLog());\n            errors->append(shader.getInfoDebugLog());\n        }\n        return false;\n    }\n\n    glslang::TProgram program;\n    program.addShader(&shader);\n\n    if(!program.link(messages)) {\n        if (errors) {\n            errors->append(\"GLSL linking failed for: \");\n            errors->append(name);\n            errors->append(\"\\n\");\n            errors->append(shader.getInfoLog());\n            errors->append(shader.getInfoDebugLog());\n        }\n        return false;\n    }\n\n    //\n    // Convert to SPIRV\n    //\n    spv::SpvBuildLogger logger;\n    glslang::SpvOptions spvOptions;\n    spvOptions.generateDebugInfo = false;\n    spvOptions.optimizeSize = false;\n    spvOptions.disassemble = false;\n    spvOptions.validate = false;\n\n    glslang::GlslangToSpv(\n        *program.getIntermediate(shaderType),\n        *spirvOUT,\n        &logger,\n        &spvOptions);\n\n    if (logger.getAllMessages().length() > 0) {\n        if (errors) {\n            errors->append(logger.getAllMessages().c_str());\n        }\n    }\n\n    // XXX glslang can output the spirv binary for us:\n    // glslang::OutputSpvBin(*spirvOUT, \"filename.spv\");\n\n    return true;\n}\n\nPXR_NAMESPACE_CLOSE_SCOPE\n",
			"file": "src/USD/hgiVk/shaderCompiler.cpp",
			"file_size": 10186,
			"file_write_time": 132398942007847395,
			"settings":
			{
				"buffer_size": 10186,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#include \"pxr/base/tf/diagnostic.h\"\n\n#include \"USD/hgiVk/conversions.h\"\n#include \"USD/hgiVk/device.h\"\n#include \"USD/hgiVk/diagnostic.h\"\n#include \"USD/hgiVk/shaderFunction.h\"\n\nPXR_NAMESPACE_OPEN_SCOPE\n\n\nHgiVkShaderFunction::HgiVkShaderFunction(\n    HgiVkDevice* device,\n    HgiShaderFunctionDesc const& desc)\n    : HgiShaderFunction(desc)\n    , _device(device)\n    , _descriptor(desc)\n    , _vkShaderModule(nullptr)\n{\n    VkShaderModuleCreateInfo shaderCreateInfo =\n        {VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO};\n\n    HgiVkShaderCompiler* shaderCompiler = device->GetShaderCompiler();\n\n    std::vector<unsigned int> spirv;\n\n    // Compile shader and capture errors\n    bool result = shaderCompiler->CompileGLSL(\n        \"no_name_provided_for_shader\",\n        desc.shaderCode.c_str(),\n        1,\n        desc.shaderStage,\n        &spirv,\n        &_errors);\n\n    // Create vulkan module if there were no errors.\n    if (result) {\n        size_t spirvByteSize = spirv.size() * sizeof(unsigned int);\n\n        shaderCreateInfo.codeSize = spirvByteSize;\n        shaderCreateInfo.pCode = (uint32_t*) spirv.data();\n\n        TF_VERIFY(\n            vkCreateShaderModule(\n                _device->GetVulkanDevice(),\n                &shaderCreateInfo,\n                HgiVkAllocator(),\n                &_vkShaderModule) == VK_SUCCESS\n        );\n\n        // Debug label\n        if (!_descriptor.debugName.empty()) {\n            std::string debugLabel = \"ShaderModule \" + _descriptor.debugName;\n            HgiVkSetDebugName(\n                _device,\n                (uint64_t)_vkShaderModule,\n                VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT,\n                debugLabel.c_str());\n        }\n    }\n}\n\nHgiVkShaderFunction::~HgiVkShaderFunction()\n{\n    if (_vkShaderModule) {\n        vkDestroyShaderModule(\n            _device->GetVulkanDevice(),\n            _vkShaderModule,\n            HgiVkAllocator());\n    }\n}\n\nVkShaderStageFlagBits\nHgiVkShaderFunction::GetShaderStage() const\n{\n    return VkShaderStageFlagBits(\n        HgiVkConversions::GetShaderStages(_descriptor.shaderStage));\n}\n\nVkShaderModule\nHgiVkShaderFunction::GetShaderModule() const\n{\n    return _vkShaderModule;\n}\n\nconst char*\nHgiVkShaderFunction::GetShaderFunctionName() const\n{\n    static const std::string entry(\"main\");\n    return entry.c_str();\n}\n\nbool\nHgiVkShaderFunction::IsValid() const\n{\n    return _errors.empty();\n}\n\nstd::string const&\nHgiVkShaderFunction::GetCompileErrors()\n{\n    return _errors;\n}\n\nPXR_NAMESPACE_CLOSE_SCOPE\n",
			"file": "src/USD/hgiVk/shaderFunction.cpp",
			"file_size": 2509,
			"file_write_time": 132398942177686027,
			"settings":
			{
				"buffer_size": 2509,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#include \"USD/hgiVk/shaderProgram.h\"\n#include \"USD/hgiVk/shaderFunction.h\"\n\nPXR_NAMESPACE_OPEN_SCOPE\n\n\nHgiVkShaderProgram::HgiVkShaderProgram(HgiShaderProgramDesc const& desc)\n    : HgiShaderProgram(desc)\n    , _descriptor(desc)\n{\n}\n\nHgiVkShaderProgram::~HgiVkShaderProgram()\n{\n}\n\nHgiShaderFunctionHandleVector const&\nHgiVkShaderProgram::GetShaderFunctions() const\n{\n    return _descriptor.shaderFunctions;\n}\n\n\nPXR_NAMESPACE_CLOSE_SCOPE\n",
			"file": "src/USD/hgiVk/shaderProgram.cpp",
			"file_size": 437,
			"file_write_time": 132398942264125331,
			"settings":
			{
				"buffer_size": 437,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#include \"pxr/base/tf/diagnostic.h\"\n\n#include \"USD/hgiVk/device.h\"\n#include \"USD/hgiVk/instance.h\"\n#include \"USD/hgiVk/surface.h\"\n\nPXR_NAMESPACE_OPEN_SCOPE\n\n#if defined(__APPLE__) && defined(__OBJC__)\n    #import <AppKit/AppKit.h>\n    #import <Metal/Metal.h>\n    #import <QuartzCore/QuartzCore.h>\n#endif\n\nstatic void\n_CreateNativeSurface(\n    VkInstance instance,\n    HGI_NATIVE_WINDOW nativeWindow,\n    HGI_NATIVE_PARENT nativeParent,\n    VkSurfaceKHR* surfaceOut)\n{\n    VkSurfaceKHR surface = 0;\n\n    #if defined(VK_USE_PLATFORM_WIN32_KHR)\n\n        VkWin32SurfaceCreateInfoKHR createInfo =\n            {VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR};\n        createInfo.hinstance = nativeParent;\n        createInfo.hwnd = nativeWindow;\n        TF_VERIFY(\n            vkCreateWin32SurfaceKHR(\n                instance,\n                &createInfo,\n                HgiVkAllocator(),\n                &surface) == VK_SUCCESS);\n\n    #elif defined(VK_USE_PLATFORM_XLIB_KHR)\n\n        VkXlibSurfaceCreateInfoKHR createInfo =\n            {VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR};\n        createInfo.dpy = nativeParent;\n        createInfo.window = nativeWindow;\n        TF_VERIFY(\n            vkCreateXlibSurfaceKHR(\n                instance,\n                &createInfo,\n                HgiVkAllocator(),\n                &surface) == VK_SUCCESS);\n\n    #elif defined(VK_USE_PLATFORM_MACOS_MVK)\n\n        #if defined(__APPLE__) && defined(__OBJC__)\n            // iOS code see: https://github.com/KhronosGroup/MoltenVK/issues/78\n            NSWindow* nsWindow = (NSWindow*) nativeWindow;\n            NSView* view = [nsWindow contentView];\n            // Need metal layer for the view. (or use: glfwCreateWindowSurface)\n            assert([view isKindOfClass:[NSView class]]);\n            if (![view.layer isKindOfClass:[CAMetalLayer class]]) {\n                [view setLayer:[CAMetalLayer layer]];\n                // [view setWantsLayer:YES];\n            }\n\n            VkMacOSSurfaceCreateInfoMVK createInfo =\n                {VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK};\n            createInfo.pNext = 0;\n            createInfo.flags = 0;\n            createInfo.pView = (void*)view;\n            TF_VERIFY(\n                vkCreateMacOSSurfaceMVK(\n                    instance,\n                    &createInfo,\n                    HgiVkAllocator(),\n                    &surface) == VK_SUCCESS);\n        #endif\n\n    #else\n        #error Unsupported platform\n    #endif\n\n    *surfaceOut = surface;\n}\n\nHgiVkSurface::HgiVkSurface(\n    HgiVkInstance* instance,\n    HgiVkDevice* device,\n    HgiVkSurfaceDesc const& desc)\n    : _instance(instance)\n    , _vkSurface(nullptr)\n{\n    _CreateNativeSurface(\n        instance->GetVulkanInstance(),\n        desc.window,\n        desc.parent,\n        &_vkSurface);\n    TF_VERIFY(_vkSurface, \"Invalid surface\");\n\n    VkBool32 presentSupported = 0;\n    TF_VERIFY(\n        vkGetPhysicalDeviceSurfaceSupportKHR(\n            device->GetVulkanPhysicalDevice(),\n            device->GetVulkanDeviceQueueFamilyIndex(),\n            _vkSurface,\n            &presentSupported) == VK_SUCCESS\n    );\n\n    TF_VERIFY(presentSupported, \"Presenting not supported on Vulkan device\");\n}\n\nHgiVkSurface::~HgiVkSurface()\n{\n    vkDestroySurfaceKHR(\n        _instance->GetVulkanInstance(),\n        _vkSurface,\n        HgiVkAllocator());\n}\n\nVkSurfaceKHR\nHgiVkSurface::GetVulkanSurface() const\n{\n    return _vkSurface;\n}\n\nHgiVkSurfaceDesc::HgiVkSurfaceDesc()\n    : window(0)\n    , parent(0)\n{\n}\n\nbool operator==(\n    const HgiVkSurfaceDesc& lhs,\n    const HgiVkSurfaceDesc& rhs)\n{\n    return lhs.window == rhs.window &&\n           lhs.parent == rhs.parent;\n}\n\nbool operator!=(\n    const HgiVkSurfaceDesc& lhs,\n    const HgiVkSurfaceDesc& rhs)\n{\n    return !(lhs == rhs);\n}\n\nPXR_NAMESPACE_CLOSE_SCOPE\n",
			"file": "src/USD/hgiVk/surface.cpp",
			"file_size": 3812,
			"file_write_time": 132398942393404290,
			"settings":
			{
				"buffer_size": 3812,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#include \"pxr/base/tf/diagnostic.h\"\n\n#include \"USD/hgiVk/commandBuffer.h\"\n#include \"USD/hgiVk/conversions.h\"\n#include \"USD/hgiVk/device.h\"\n#include \"USD/hgiVk/diagnostic.h\"\n#include \"USD/hgiVk/renderPass.h\"\n#include \"USD/hgiVk/swapchain.h\"\n#include \"USD/hgiVk/texture.h\"\n\nPXR_NAMESPACE_OPEN_SCOPE\n\nstatic VkImageMemoryBarrier\n_ImageBarrier(\n    VkImage image,\n    VkAccessFlags srcAccessMask,\n    VkAccessFlags dstAccessMask,\n    VkImageLayout oldLayout,\n    VkImageLayout newLayout)\n{\n    VkImageMemoryBarrier result = {VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER};\n    result.srcAccessMask = srcAccessMask;\n    result.dstAccessMask = dstAccessMask;\n    result.oldLayout = oldLayout;\n    result.newLayout = newLayout;\n    result.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;\n    result.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;\n    result.image = image;\n    // XXX for depth: VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT\n    result.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;\n    result.subresourceRange.levelCount = VK_REMAINING_MIP_LEVELS;\n    result.subresourceRange.layerCount = VK_REMAINING_ARRAY_LAYERS;\n    return result;\n}\n\nstatic VkFormat\n_GetSurfaceFormat(\n    HgiVkDevice* device,\n    HgiVkSurface* surface)\n{\n    uint32_t formatCount = 0;\n    TF_VERIFY(\n        vkGetPhysicalDeviceSurfaceFormatsKHR(\n            device->GetVulkanPhysicalDevice(),\n            surface->GetVulkanSurface(),\n            &formatCount,\n            nullptr) == VK_SUCCESS\n    );\n    TF_VERIFY(formatCount > 0);\n\n    std::vector<VkSurfaceFormatKHR> formats(formatCount);\n\n    TF_VERIFY(\n        vkGetPhysicalDeviceSurfaceFormatsKHR(\n            device->GetVulkanPhysicalDevice(),\n            surface->GetVulkanSurface(),\n            &formatCount,\n            formats.data()) == VK_SUCCESS\n    );\n\n    if (formatCount == 1 && formats[0].format == VK_FORMAT_UNDEFINED) {\n        return VK_FORMAT_R8G8B8A8_UNORM;\n    }\n\n    for (uint32_t i=0; i < formatCount; i++) {\n        if (formats[i].format == VK_FORMAT_R8G8B8A8_UNORM ||\n            formats[i].format == VK_FORMAT_B8G8R8A8_UNORM) {\n            return formats[i].format;\n        }\n    }\n\n    TF_WARN(\"Using not supported swapchain format\");\n    return formats[0].format;\n}\n\nstatic void\n_DestroyVulkanSwapchain(\n    HgiVkDevice* device,\n    VkSwapchainKHR vkSwapchain,\n    VkSemaphore vkAcquireSemaphore,\n    VkSemaphore vkReleaseSemaphore,\n    VkImageViewVector& vkImageViews)\n{\n    TF_VERIFY(\n        vkDeviceWaitIdle(device->GetVulkanDevice()) == VK_SUCCESS\n    );\n\n    for (uint32_t i = 0; i < vkImageViews.size(); i++) {\n        vkDestroyImageView(\n            device->GetVulkanDevice(),\n            vkImageViews[i],\n            HgiVkAllocator());\n    }\n\n    vkDestroySwapchainKHR(\n        device->GetVulkanDevice(),\n        vkSwapchain,\n        HgiVkAllocator());\n\n    vkDestroySemaphore(\n        device->GetVulkanDevice(),\n        vkReleaseSemaphore,\n        HgiVkAllocator());\n\n    vkDestroySemaphore(\n        device->GetVulkanDevice(),\n        vkAcquireSemaphore,\n        HgiVkAllocator());\n}\n\nHgiVkSwapchain::HgiVkSwapchain(\n    HgiVkDevice* device,\n    HgiVkSurfaceHandle surface)\n    : _device(device)\n    , _surface(surface)\n    , _width(0)\n    , _height(0)\n    , _imageCount(0)\n    , _nextImageIndex(0)\n    , _vkSwapchainFormat(VK_FORMAT_UNDEFINED)\n    , _vkSwapchain(nullptr)\n    , _vkAcquireSemaphore(nullptr)\n    , _vkReleaseSemaphore(nullptr)\n{\n    _CreateVulkanSwapchain();\n}\n\nHgiVkSwapchain::~HgiVkSwapchain()\n{\n    _PreDestroyVulkanSwapchain();\n    _DestroyVulkanSwapchain(\n        _device,\n        _vkSwapchain,\n        _vkAcquireSemaphore,\n        _vkReleaseSemaphore,\n        _vkImageViews);\n}\n\nvoid\nHgiVkSwapchain::BeginSwapchain(HgiVkCommandBuffer* cb)\n{\n    HgiVkBeginDebugMarker(cb, \"BeginSwapchain\");\n\n    // Not all drivers may report 'out-of-data' errors for swapchains so we\n    // first do a manual size check.\n    _ResizeSwapchainIfNecessary();\n\n    // If we fail to acquire the image because the swapchain is out of data then\n    // we must re-create the swapchain AND re-acquire the image.\n    VkResult res =  _AcquireNextImage();\n    if (res == VK_ERROR_OUT_OF_DATE_KHR || res == VK_SUBOPTIMAL_KHR) {\n        _RecreateSwapChain();\n        res = _AcquireNextImage();\n    }\n    TF_VERIFY(res == VK_SUCCESS);\n\n    uint32_t imageIndex = _nextImageIndex;\n\n    // The swapchain image must transition from UNDEFINED to COLOR_ATTACH.\n    VkImageMemoryBarrier renderBeginBarrier = _ImageBarrier(\n        _vkImageWeakPtrs[imageIndex], 0,\n        VK_ACCESS_COLOR_ATTACHMENT_READ_BIT |\n        VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,\n        VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL);\n\n    vkCmdPipelineBarrier(\n        cb->GetCommandBufferForRecoding(),\n        VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,\n        VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,\n        VK_DEPENDENCY_BY_REGION_BIT, 0, 0, 0, 0, 1, &renderBeginBarrier);\n\n    _renderPasses[imageIndex]->BeginRenderPass(cb, /*use secondary*/ false);\n}\n\nvoid\nHgiVkSwapchain::EndSwapchain(HgiVkCommandBuffer* cb)\n{\n    uint32_t imageIndex = _nextImageIndex;\n\n    _renderPasses[imageIndex]->EndRenderPass(cb);\n\n    // The swapchain image must transition from COLOR_ATTACH to PRESENT.\n    VkImageMemoryBarrier renderEndBarrier = _ImageBarrier(\n        _vkImageWeakPtrs[imageIndex],\n        VK_ACCESS_COLOR_ATTACHMENT_READ_BIT |\n        VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,\n        0, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,\n        VK_IMAGE_LAYOUT_PRESENT_SRC_KHR);\n\n    vkCmdPipelineBarrier(\n        cb->GetCommandBufferForRecoding(),\n        VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,\n        VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, VK_DEPENDENCY_BY_REGION_BIT,\n        0, 0, 0, 0, 1, &renderEndBarrier);\n\n    HgiVkEndDebugMarker(cb /*\"BeginSwapchain\"*/);\n}\n\nvoid\nHgiVkSwapchain::PresentSwapchain()\n{\n    VkPipelineStageFlags submitStageMask =\n        VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;\n\n    // See Khronos Vulkan wiki: synchronization-Examples\n    VkSubmitInfo submitInfo = {VK_STRUCTURE_TYPE_SUBMIT_INFO};\n    submitInfo.waitSemaphoreCount = 1;\n    submitInfo.pWaitSemaphores = &_vkAcquireSemaphore;\n    submitInfo.pWaitDstStageMask = &submitStageMask;\n    submitInfo.signalSemaphoreCount = 1;\n    submitInfo.pSignalSemaphores = &_vkReleaseSemaphore;\n\n    TF_VERIFY(\n        vkQueueSubmit(\n            _device->GetVulkanDeviceQueue(),\n            1,\n            &submitInfo,\n            VK_NULL_HANDLE) == VK_SUCCESS\n    );\n\n    uint32_t imageIndex = _nextImageIndex;\n\n    VkPresentInfoKHR vkPresentInfo = {VK_STRUCTURE_TYPE_PRESENT_INFO_KHR};\n    vkPresentInfo.waitSemaphoreCount = 1;\n    vkPresentInfo.pWaitSemaphores = &_vkReleaseSemaphore;\n    vkPresentInfo.swapchainCount = 1;\n    vkPresentInfo.pSwapchains = &_vkSwapchain;\n    vkPresentInfo.pImageIndices = &imageIndex;\n\n    VkResult res = vkQueuePresentKHR(\n        _device->GetVulkanDeviceQueue(),\n        &vkPresentInfo);\n\n    // If swapchain is out of date here we will catch it next BeginSwapchain.\n    TF_VERIFY(res == VK_SUCCESS ||\n              res == VK_ERROR_OUT_OF_DATE_KHR ||\n              res == VK_SUBOPTIMAL_KHR);\n}\n\nuint32_t\nHgiVkSwapchain::GetImageCount()\n{\n    return _imageCount;\n}\n\nHgiVkRenderPass*\nHgiVkSwapchain::GetRenderPass(uint32_t imageIndex)\n{\n    if (TF_VERIFY(imageIndex < _renderPasses.size())) {\n        return _renderPasses[imageIndex];\n    }\n    return nullptr;\n}\n\nvoid\nHgiVkSwapchain::_CreateVulkanSwapchain()\n{\n    // Verify old textures and render pass are taken care of.\n    // See _RecreateSwapChain() for more info.\n    TF_VERIFY(_textures.empty() &&\n              _renderPasses.empty() &&\n              _vkImageWeakPtrs.empty(),\n              \"There are undestroyed items left in swapchain\");\n\n    //\n    // Query Surface info\n    //\n    VkSurfaceCapabilitiesKHR surfaceCaps;\n    TF_VERIFY(\n        vkGetPhysicalDeviceSurfaceCapabilitiesKHR(\n            _device->GetVulkanPhysicalDevice(),\n            _surface->GetVulkanSurface(),\n            &surfaceCaps) == VK_SUCCESS\n    );\n\n    _width = surfaceCaps.currentExtent.width;\n    _height = surfaceCaps.currentExtent.height;\n    _vkSwapchainFormat = _GetSurfaceFormat(_device, _surface);\n\n    //\n    // Create Swapchain\n    //\n    VkCompositeAlphaFlagBitsKHR alphaOpaque =\n        VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;\n    VkCompositeAlphaFlagBitsKHR preMul =\n        VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR;\n    VkCompositeAlphaFlagBitsKHR postMul =\n        VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR;\n\n    VkCompositeAlphaFlagBitsKHR surfaceComposite =\n        (surfaceCaps.supportedCompositeAlpha & alphaOpaque) ?\n            VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR :\n        (surfaceCaps.supportedCompositeAlpha & preMul) ?\n            VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR :\n        (surfaceCaps.supportedCompositeAlpha & postMul) ?\n            VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR :\n        VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR;\n\n    VkSwapchainCreateInfoKHR swapCreateInfo =\n        {VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR};\n    swapCreateInfo.surface = _surface->GetVulkanSurface();\n    swapCreateInfo.minImageCount = std::max(2u, surfaceCaps.minImageCount);\n    swapCreateInfo.imageFormat = _vkSwapchainFormat;\n    swapCreateInfo.imageColorSpace = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR;\n    swapCreateInfo.imageExtent.width = _width;\n    swapCreateInfo.imageExtent.height = _height;\n    swapCreateInfo.imageArrayLayers = 1;\n    swapCreateInfo.imageUsage =\n        VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | // for rendering\n        VK_IMAGE_USAGE_TRANSFER_DST_BIT;      // for blitting\n    swapCreateInfo.queueFamilyIndexCount = 1;\n    uint32_t queueFamilyIndex = _device->GetVulkanDeviceQueueFamilyIndex();\n    swapCreateInfo.pQueueFamilyIndices = &queueFamilyIndex;\n    swapCreateInfo.preTransform = VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR;\n    swapCreateInfo.compositeAlpha = surfaceComposite;\n    swapCreateInfo.presentMode = VK_PRESENT_MODE_FIFO_KHR;\n    swapCreateInfo.oldSwapchain = _vkSwapchain;\n\n    TF_VERIFY(\n        vkCreateSwapchainKHR(\n            _device->GetVulkanDevice(),\n            &swapCreateInfo,\n            HgiVkAllocator(),\n            &_vkSwapchain) == VK_SUCCESS\n    );\n    TF_VERIFY(_vkSwapchain, \"Swapchain invalid\");\n\n    // Debug label\n    {\n        std::string debugLabel = \"Swapchain HgiVk\";\n        HgiVkSetDebugName(\n            _device,\n            (uint64_t)_vkSwapchain,\n            VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT,\n            debugLabel.c_str());\n    }\n\n    //\n    // Get swapchain images\n    //\n    uint32_t imageCount = 0;\n    TF_VERIFY(\n        vkGetSwapchainImagesKHR(\n            _device->GetVulkanDevice(),\n            _vkSwapchain,\n            &imageCount,\n            0/*images*/) == VK_SUCCESS\n    );\n\n    _imageCount = imageCount;\n    _vkImageWeakPtrs.resize(imageCount);\n    _vkImageViews.resize(imageCount);\n    _textures.resize(imageCount);\n\n    TF_VERIFY(\n        vkGetSwapchainImagesKHR(\n            _device->GetVulkanDevice(),\n            _vkSwapchain,\n            &imageCount,\n            _vkImageWeakPtrs.data()) == VK_SUCCESS\n    );\n\n    //\n    // Create semaphores for accessing swapchain images\n    //\n    VkSemaphoreCreateInfo semaCreateInfo =\n        {VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO};\n    TF_VERIFY(\n        vkCreateSemaphore(\n            _device->GetVulkanDevice(),\n            &semaCreateInfo,\n            HgiVkAllocator(),\n            &_vkAcquireSemaphore) == VK_SUCCESS\n    );\n\n    // Debug label\n    {\n        std::string debugLabel = \"Semaphore Acquire HgiVk Swapchain\";\n        HgiVkSetDebugName(\n            _device,\n            (uint64_t)_vkAcquireSemaphore,\n            VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT,\n            debugLabel.c_str());\n    }\n\n    TF_VERIFY(\n        vkCreateSemaphore(\n            _device->GetVulkanDevice(),\n            &semaCreateInfo,\n            HgiVkAllocator(),\n            &_vkReleaseSemaphore) == VK_SUCCESS\n    );\n\n    // Debug label\n    {\n        std::string debugLabel = \"Semaphore Release HgiVk Swapchain\";\n        HgiVkSetDebugName(\n            _device,\n            (uint64_t)_vkReleaseSemaphore,\n            VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT,\n            debugLabel.c_str());\n    }\n\n    //\n    // Create image views\n    //\n    for (uint32_t i = 0; i < imageCount; i++) {\n        VkImageViewCreateInfo createInfo =\n            {VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO};\n        createInfo.image = _vkImageWeakPtrs[i];\n        createInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;\n        createInfo.format = _vkSwapchainFormat;\n        createInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;\n        createInfo.subresourceRange.levelCount = 1;\n        createInfo.subresourceRange.layerCount = 1;\n\n        TF_VERIFY(\n            vkCreateImageView(\n                _device->GetVulkanDevice(),\n                &createInfo,\n                HgiVkAllocator(),\n                &_vkImageViews[i]) == VK_SUCCESS\n        );\n        TF_VERIFY(_vkImageViews[i], \"ImageView creation failed\");\n\n        // Debug label\n        {\n            std::string debugLabel = \"ImageView \" + std::to_string(i) +\n                                     \" HgiVk Swapchain\";\n            HgiVkSetDebugName(\n                _device,\n                (uint64_t)_vkImageViews[i],\n                VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT,\n                debugLabel.c_str());\n        }\n    }\n\n    //\n    // Create texture-wrapper for each image of swapchain\n    //\n    for (uint32_t i = 0; i < imageCount; i++) {\n        HgiTextureDesc texDesc;\n        texDesc.dimensions = GfVec3i(_width, _height, 1);\n        texDesc.format = HgiVkConversions::GetFormat(_vkSwapchainFormat);\n        texDesc.pixelData = nullptr;\n        texDesc.pixelsByteSize = 0;\n        texDesc.sampleCount = HgiSampleCount1; // Vulkan swapchain is never MS\n        texDesc.usage = HgiTextureUsageBitsColorTarget |\n                        HgiTextureUsageBitsSwapchain;\n\n        // While HdFormat/HgiFormat do not support BGRA channel ordering it may\n        // be used for the native window swapchain on some platforms.\n        if (_vkSwapchainFormat == VK_FORMAT_B8G8R8A8_UNORM) {\n            texDesc.usage |= HgiTextureUsageBitsBGRA;\n        }\n\n        VkDescriptorImageInfo texVkDesc;\n        texVkDesc.imageLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;\n        texVkDesc.imageView = _vkImageViews[i];\n        texVkDesc.sampler = nullptr;\n\n        HgiVkTexture* tex = new HgiVkTexture(_device, texDesc, texVkDesc);\n        _textures[i] = tex;\n    }\n\n    //\n    // Create render passes for each image of swapchain\n    //\n    for (uint32_t i = 0; i < imageCount; i++) {\n        HgiAttachmentDesc attachment;\n        attachment.clearValue = GfVec4f(0);\n        attachment.loadOp = HgiAttachmentLoadOpClear;\n        attachment.storeOp = HgiAttachmentStoreOpStore;\n        attachment.texture = _textures[i];\n\n        HgiGraphicsEncoderDesc renderPassDesc;\n        renderPassDesc.width = surfaceCaps.currentExtent.width;\n        renderPassDesc.height = surfaceCaps.currentExtent.height;\n        renderPassDesc.colorAttachments.emplace_back(std::move(attachment));\n\n        HgiVkRenderPass* rp = _device->AcquireRenderPass(renderPassDesc);\n        _renderPasses.push_back(rp);\n    }\n}\n\nvoid\nHgiVkSwapchain::_PreDestroyVulkanSwapchain()\n{\n    // We do not worry about deleting the old render pass since it is in the\n    // render pass cache and will eventually be garbage collected.\n    _renderPasses.clear();\n\n    // We must delete the textures we created when we created the swapchain.\n    // This will only delete the HgiVkTexture, not the vulkan resources since\n    // the vkImages are owned / managed internally by the native window.\n    for (HgiVkTexture* tex : _textures) {\n        delete tex;\n    }\n    _textures.clear();\n\n    // The swapchain owns the vkImages. We do not destroy them ourselves.\n    _vkImageWeakPtrs.clear();\n}\n\nvoid\nHgiVkSwapchain::_RecreateSwapChain()\n{\n    // We don't fully destroy the old swapchain until after creating the new.\n    // This allows for optimizations where the driver may be able to re-use\n    // parts of the old swapchain.\n\n    VkSwapchainKHR vkSwapchain = _vkSwapchain;\n    VkSemaphore vkAcquireSemaphore = _vkAcquireSemaphore;\n    VkSemaphore vkReleaseSemaphore = _vkReleaseSemaphore;\n    VkImageViewVector vkImageViews = _vkImageViews;\n    _vkImageViews.clear();\n\n    _PreDestroyVulkanSwapchain();\n    _CreateVulkanSwapchain();\n    _DestroyVulkanSwapchain(\n        _device,\n        vkSwapchain,\n        vkAcquireSemaphore,\n        vkReleaseSemaphore,\n        vkImageViews);\n}\n\nvoid\nHgiVkSwapchain::_ResizeSwapchainIfNecessary()\n{\n    VkSurfaceCapabilitiesKHR surfaceCaps;\n    TF_VERIFY(\n        vkGetPhysicalDeviceSurfaceCapabilitiesKHR(\n            _device->GetVulkanPhysicalDevice(),\n            _surface->GetVulkanSurface(),\n            &surfaceCaps) == VK_SUCCESS\n    );\n\n    uint32_t newWidth = surfaceCaps.currentExtent.width;\n    uint32_t newHeight = surfaceCaps.currentExtent.height;\n\n    if (_width == newWidth && _height == newHeight) {\n        return;\n    }\n\n    _RecreateSwapChain();\n}\n\nVkResult\nHgiVkSwapchain::_AcquireNextImage()\n{\n    return vkAcquireNextImageKHR(\n        _device->GetVulkanDevice(),\n        _vkSwapchain,\n        ~0ull,\n        _vkAcquireSemaphore,\n        VK_NULL_HANDLE,\n        &_nextImageIndex);\n}\n\n\nPXR_NAMESPACE_CLOSE_SCOPE\n",
			"file": "src/USD/hgiVk/swapchain.cpp",
			"file_size": 17443,
			"file_write_time": 132398942587362729,
			"settings":
			{
				"buffer_size": 17443,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#include \"USD/hgiVk/device.h\"\n#include \"USD/hgiVk/diagnostic.h\"\n#include \"USD/hgiVk/commandBuffer.h\"\n#include \"USD/hgiVk/conversions.h\"\n#include \"USD/hgiVk/renderPass.h\"\n#include \"USD/hgiVk/texture.h\"\n\nPXR_NAMESPACE_OPEN_SCOPE\n\nstatic bool\n_CheckFormatSupport(\n    VkPhysicalDevice pDevice,\n    VkFormat format,\n    VkFormatFeatureFlags flags )\n{\n    VkFormatProperties props;\n    vkGetPhysicalDeviceFormatProperties(pDevice, format, &props);\n    return (props.optimalTilingFeatures & flags) == flags;\n}\n\nHgiVkTexture::HgiVkTexture(\n    HgiVkDevice* device,\n    HgiVkCommandBuffer* cb,\n    HgiTextureDesc const & desc)\n    : HgiTexture(desc)\n    , _device(device)\n    , _descriptor(desc)\n    , _vkImage(nullptr)\n    , _vmaImageAllocation(nullptr)\n{\n    TF_VERIFY(device && cb);\n\n    VkPhysicalDeviceProperties const& vkDeviceProps =\n        device->GetVulkanPhysicalDeviceProperties();\n\n    VkPhysicalDeviceFeatures const& vkDeviceFeatures =\n        device->GetVulkanPhysicalDeviceFeatures();\n\n    GfVec3i const& dimensions = desc.dimensions;\n    bool isDepthBuffer = desc.usage & HgiTextureUsageBitsDepthTarget;\n    bool supportAnisotropy = vkDeviceFeatures.samplerAnisotropy;\n\n    //\n    // Gather image create info\n    //\n\n    VkImageCreateInfo imageCreateInfo = {VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO};\n\n    imageCreateInfo.imageType = dimensions[2] > 1 ? VK_IMAGE_TYPE_3D :\n                                dimensions[1] > 1 ? VK_IMAGE_TYPE_2D :\n                                VK_IMAGE_TYPE_1D;\n\n    imageCreateInfo.format = isDepthBuffer ? VK_FORMAT_D32_SFLOAT_S8_UINT :\n                              HgiVkConversions::GetFormat(desc.format);\n\n    imageCreateInfo.mipLevels = desc.mipLevels;\n    imageCreateInfo.arrayLayers = desc.layerCount;\n    imageCreateInfo.samples= HgiVkConversions::GetSampleCount(desc.sampleCount);\n    imageCreateInfo.tiling = VK_IMAGE_TILING_OPTIMAL;\n    imageCreateInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;\n    imageCreateInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;\n    imageCreateInfo.extent = {\n        (uint32_t) dimensions[0],\n        (uint32_t) dimensions[1],\n        (uint32_t) dimensions[2]};\n\n    imageCreateInfo.usage = HgiVkConversions::GetTextureUsage(desc.usage);\n    VkFormatFeatureFlags formatValidationFlags =\n        HgiVkConversions::GetFormatFeature(desc.usage);\n\n\n    if (!_CheckFormatSupport(\n            device->GetVulkanPhysicalDevice(),\n            imageCreateInfo.format,\n            formatValidationFlags)) {\n        TF_CODING_ERROR(\"Image format not supported on device\");\n    };\n\n    //\n    // Create image with memory allocated and bound.\n    //\n\n    // Equivalent to: vkCreateImage, vkAllocateMemory, vkBindImageMemory\n    VmaAllocationCreateInfo allocInfo = {};\n    allocInfo.usage = VMA_MEMORY_USAGE_GPU_ONLY;\n    TF_VERIFY(\n        vmaCreateImage(\n            device->GetVulkanMemoryAllocator(),\n            &imageCreateInfo,\n            &allocInfo,\n            &_vkImage,\n            &_vmaImageAllocation,\n            nullptr) == VK_SUCCESS\n    );\n\n    // Debug label\n    if (!_descriptor.debugName.empty()) {\n        std::string debugLabel = \"Image \" + _descriptor.debugName;\n        HgiVkSetDebugName(\n            _device,\n            (uint64_t)_vkImage,\n            VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT,\n            debugLabel.c_str());\n    }\n\n    //\n    // Create a texture sampler\n    //\n\n    // In Vulkan textures are accessed by samplers.\n    // This separates all the sampling information from the texture data.\n    // This means you could have multiple sampler objects for the same texture\n    // with different settings\n    // Note: Similar to the samplers available with OpenGL 3.3+\n    // XXX Hgi currently provides no sampler information so we guess.\n\n    VkSamplerCreateInfo sampler = {VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO};\n    sampler.magFilter = VK_FILTER_LINEAR;\n    sampler.minFilter = VK_FILTER_LINEAR;\n    sampler.addressModeU = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;\n    sampler.addressModeV = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;\n    sampler.addressModeW = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;\n    sampler.compareOp = VK_COMPARE_OP_NEVER;\n    sampler.borderColor = VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE;\n    sampler.mipLodBias = 0.0f;\n    sampler.mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR;\n    sampler.minLod = 0.0f;\n    sampler.maxLod = (float) desc.mipLevels;\n    sampler.maxAnisotropy = supportAnisotropy ?\n                            vkDeviceProps.limits.maxSamplerAnisotropy : 1.0f;\n    sampler.anisotropyEnable = supportAnisotropy ? VK_TRUE : VK_FALSE;\n\n    TF_VERIFY(\n        vkCreateSampler(\n            device->GetVulkanDevice(),\n            &sampler,\n            HgiVkAllocator(),\n            &_vkDescriptor.sampler) == VK_SUCCESS\n    );\n\n    // Debug label\n    if (!_descriptor.debugName.empty()) {\n        std::string debugLabel = \"Sampler \" + _descriptor.debugName;\n        HgiVkSetDebugName(\n            _device,\n            (uint64_t)_vkDescriptor.sampler,\n            VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT,\n            debugLabel.c_str());\n    }\n\n    //\n    // Create image view\n    //\n\n    // Textures are not directly accessed by the shaders and\n    // are abstracted by image views containing additional\n    // information and sub resource ranges\n    VkImageViewCreateInfo view = {VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO};\n\n    view.viewType = dimensions[2] > 1 ? VK_IMAGE_VIEW_TYPE_3D :\n                    dimensions[1] > 1 ? VK_IMAGE_VIEW_TYPE_2D :\n                    VK_IMAGE_VIEW_TYPE_1D;\n\n    view.format = imageCreateInfo.format;\n    view.components = { VK_COMPONENT_SWIZZLE_R,\n                        VK_COMPONENT_SWIZZLE_G,\n                        VK_COMPONENT_SWIZZLE_B,\n                        VK_COMPONENT_SWIZZLE_A };\n\n    // The subresource range describes the set of mip levels (and array layers)\n    // that can be accessed through this image view.\n    // It's possible to create multiple image views for a single image referring\n    // to different (and/or overlapping) ranges of the image.\n    // A 'view' must be either depth or stencil, not both, especially when used\n    // in a descriptor set. For now we assume we always want the 'depth' aspect.\n    view.subresourceRange.aspectMask = isDepthBuffer ?\n        VK_IMAGE_ASPECT_DEPTH_BIT /*| VK_IMAGE_ASPECT_STENCIL_BIT*/ :\n        VK_IMAGE_ASPECT_COLOR_BIT;\n\n    view.subresourceRange.baseMipLevel = 0;\n    view.subresourceRange.baseArrayLayer = 0;\n    view.subresourceRange.layerCount = desc.layerCount;\n\n    if (imageCreateInfo.tiling != VK_IMAGE_TILING_OPTIMAL && desc.mipLevels>1) {\n        TF_WARN(\"linear tiled images usually do not support mips\");\n    }\n\n    view.subresourceRange.levelCount = desc.mipLevels;\n\n    view.image = _vkImage;\n\n    TF_VERIFY(\n        vkCreateImageView(\n            device->GetVulkanDevice(),\n            &view,\n            HgiVkAllocator(),\n            &_vkDescriptor.imageView) == VK_SUCCESS\n    );\n\n    // Debug label\n    if (!_descriptor.debugName.empty()) {\n        std::string debugLabel = \"Image View \" + _descriptor.debugName;\n        HgiVkSetDebugName(\n            _device,\n            (uint64_t)_vkDescriptor.imageView,\n            VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT,\n            debugLabel.c_str());\n    }\n\n    //\n    // Transition image\n    //\n\n    _vkDescriptor.imageLayout = VK_IMAGE_LAYOUT_UNDEFINED;\n\n// todo Storage images should use VK_IMAGE_LAYOUT_GENERAL\n\n    VkImageLayout newLayout = isDepthBuffer ?\n        VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL :\n        VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;\n    if (imageCreateInfo.usage & VK_IMAGE_USAGE_SAMPLED_BIT) {\n        newLayout = isDepthBuffer ?\n            VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL :\n            VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;\n    }\n\n    // XXX Optimization potential: Most textures are not read in the\n    // vertex stage, so we could use VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT.\n    // However keep in mind the depth buffer can also be used in\n    // VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT.\n    // For now we are conservative and use VERTEX_SHADER.\n\n    // Transition image to SHADER_READ as our default state\n    TransitionImageBarrier(\n        cb,\n        this,\n        newLayout, // transition tex to this layout\n        HgiVkRenderPass::GetDefaultDstAccessMask(), // shader read access\n        VK_PIPELINE_STAGE_TRANSFER_BIT,             // producer stage\n        VK_PIPELINE_STAGE_VERTEX_SHADER_BIT);       // consumer stage\n\n    // Don't hold onto pixel data ptr locally. HgiTextureDesc states that:\n    // \"The application may alter or free this memory as soon as the constructor\n    //  of the HgiTexture has returned.\"\n    _descriptor.pixelData = nullptr;\n}\n\nHgiVkTexture::HgiVkTexture(\n    HgiVkDevice* device,\n    HgiTextureDesc const & desc,\n    VkDescriptorImageInfo const& vkDesc)\n    : HgiTexture(desc)\n    , _device(device)\n    , _descriptor(desc)\n    , _vkDescriptor(vkDesc)\n    , _vkImage(nullptr)\n    , _vmaImageAllocation(nullptr)\n{\n    // This constructor directly initialized the vulkan resources (_vkImage).\n    // This is useful for images that have their lifetime externally managed.\n    // Primarily used for images that are part of the swapchain.\n    TF_VERIFY(_descriptor.usage == HgiTextureUsageBitsUndefined ||\n              _descriptor.usage & HgiTextureUsageBitsSwapchain);\n}\n\nHgiVkTexture::~HgiVkTexture()\n{\n    // Swapchain image lifetimes are managed internally by the swapchain.\n    // We should not attempt to destroy their vulkan resources here.\n    if (_descriptor.usage == HgiTextureUsageBitsUndefined ||\n        _descriptor.usage & HgiTextureUsageBitsSwapchain) {\n        return;\n    }\n\n    vkDestroyImageView(\n        _device->GetVulkanDevice(),\n        _vkDescriptor.imageView,\n        HgiVkAllocator());\n\n    vkDestroySampler(\n        _device->GetVulkanDevice(),\n        _vkDescriptor.sampler,\n        HgiVkAllocator());\n\n    vmaDestroyImage(\n        _device->GetVulkanMemoryAllocator(),\n        _vkImage,\n        _vmaImageAllocation);\n}\n\nVkImage\nHgiVkTexture::GetImage() const\n{\n    return _vkImage;\n}\n\nVkImageView\nHgiVkTexture::GetImageView() const\n{\n    return _vkDescriptor.imageView;\n}\n\nVkImageLayout\nHgiVkTexture::GetImageLayout() const\n{\n    return _vkDescriptor.imageLayout;\n}\n\nVkSampler\nHgiVkTexture::GetSampler() const\n{\n    return _vkDescriptor.sampler;\n}\n\nHgiTextureDesc const&\nHgiVkTexture::GetDescriptor() const\n{\n    return _descriptor;\n}\n\nvoid\nHgiVkTexture::CopyTextureFrom(\n    HgiVkCommandBuffer* cb,\n    HgiVkBuffer const& src)\n{\n    // Setup buffer copy regions for each mip level\n    std::vector<VkBufferImageCopy> bufferCopyRegions;\n\n    uint32_t bpp = HgiVkConversions::GetBytesPerPixel(_descriptor.format);\n\n    float width = (float) _descriptor.dimensions[0];\n    float height = (float) _descriptor.dimensions[1];\n    float depth = (float) _descriptor.dimensions[2];\n\n    // See dimension reduction rule in ARB_texture_non_power_of_two.\n    // Default numMips is: 1 + floor(log2(max(w, h, d)));\n\n    uint32_t offset = 0;\n    for (uint32_t i = 0; i < _descriptor.mipLevels; i++) {\n        float div = powf(2, i);\n        float mipWidth = std::max(1.0f, std::floor(width / div));\n        float mipHeight = std::max(1.0f, std::floor(height / div));\n        float mipDepth = std::max(1.0f, std::floor(depth / div));\n        VkBufferImageCopy bufferCopyRegion = {};\n        bufferCopyRegion.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;\n        bufferCopyRegion.imageSubresource.mipLevel = i;\n        bufferCopyRegion.imageSubresource.baseArrayLayer = 0;\n        bufferCopyRegion.imageSubresource.layerCount = _descriptor.layerCount;\n        bufferCopyRegion.imageExtent.width = (uint32_t) mipWidth;\n        bufferCopyRegion.imageExtent.height = (uint32_t) mipHeight;\n        bufferCopyRegion.imageExtent.depth = (uint32_t) mipDepth;\n        bufferCopyRegion.bufferOffset = offset;\n\n        bufferCopyRegions.push_back(bufferCopyRegion);\n\n        // Determine byte-offset in total pixel buffer for this mip\n        offset += (mipWidth * mipHeight * mipDepth * bpp);\n    }\n\n    //\n    // Image memory barriers for the texture image\n    //\n\n    // Transition image so we can copy into it\n    TransitionImageBarrier(\n        cb,\n        this,\n        VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, // Transition tex to this layout\n        VK_ACCESS_TRANSFER_WRITE_BIT,         // Write access to image\n        VK_PIPELINE_STAGE_HOST_BIT,           // producer stage\n        VK_PIPELINE_STAGE_TRANSFER_BIT);      // consumer stage\n\n    // Copy pixels (all mip levels) from staging buffer to gpu image\n    vkCmdCopyBufferToImage(\n        cb->GetCommandBufferForRecoding(),\n        src.GetBuffer(),\n        _vkImage,\n        VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,\n        static_cast<uint32_t>(bufferCopyRegions.size()),\n        bufferCopyRegions.data());\n\n    // Transition image to SHADER_READ when copy is finished\n    TransitionImageBarrier(\n        cb,\n        this,\n        VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,   // transition tex to this\n        HgiVkRenderPass::GetDefaultDstAccessMask(), // Shader read access\n        VK_PIPELINE_STAGE_TRANSFER_BIT,             // producer stage\n        VK_PIPELINE_STAGE_VERTEX_SHADER_BIT);       // consumer stage\n}\n\nvoid\nHgiVkTexture::TransitionImageBarrier(\n    HgiVkCommandBuffer* cb,\n    HgiVkTexture* tex,\n    VkImageLayout newLayout,\n    VkAccessFlags accesRequest,\n    VkPipelineStageFlags producerStage,\n    VkPipelineStageFlags consumerStage)\n{\n    bool isDepthBuffer = _descriptor.usage & HgiTextureUsageBitsDepthTarget;\n\n    // https://github.com/KhronosGroup/Vulkan-Docs/wiki/Synchronization-Examples\n    //\n    // https://gpuopen.com/vulkan-barriers-explained/\n    // Commands start at TOP_OF_PIPE_BIT and end at BOTTOM_OF_PIPE_BIT\n    // Inbetween those are various stages the graphics pipeline flows through.\n    // With an image barrier we describe what is the producer stage and what\n    // will be the earliest consumer stage. This helps schedule work and avoid\n    // wait-bubbles.\n\n    // XXX srcAccessMask=0:\n    // Only invalidation barrier, no flush barrier. For read-only resources.\n    // Meaning: There are no pending writes. Multiple passes can go back to back\n    // which all read the resource.\n\n    VkImageMemoryBarrier barrier[1] = {};\n    barrier[0].sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;\n    barrier[0].srcAccessMask = 0;            // what producer does\n    barrier[0].dstAccessMask = accesRequest; // what consumer does\n    barrier[0].oldLayout = _vkDescriptor.imageLayout;\n    barrier[0].newLayout = newLayout;\n    barrier[0].srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;\n    barrier[0].dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;\n    barrier[0].image = _vkImage;\n    barrier[0].subresourceRange.aspectMask = isDepthBuffer ?\n        VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT :\n        VK_IMAGE_ASPECT_COLOR_BIT;\n    barrier[0].subresourceRange.levelCount = _descriptor.mipLevels;\n    barrier[0].subresourceRange.layerCount = _descriptor.layerCount;\n\n    // Insert a memory dependency at the proper pipeline stages that will\n    // execute the image layout transition.\n\n    vkCmdPipelineBarrier(\n        cb->GetCommandBufferForRecoding(),\n        producerStage,\n        consumerStage,\n        0, 0, NULL, 0, NULL, 1,\n        barrier);\n\n    _vkDescriptor.imageLayout = newLayout;\n}\n\nPXR_NAMESPACE_CLOSE_SCOPE\n",
			"file": "src/USD/hgiVk/texture.cpp",
			"file_size": 15437,
			"file_write_time": 132398942795041058,
			"settings":
			{
				"buffer_size": 15437,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#include \"pxr/base/tf/diagnostic.h\"\n\n#include \"USD/hgiVk/buffer.h\"\n#include \"USD/hgiVk/commandBuffer.h\"\n#include \"USD/hgiVk/conversions.h\"\n#include \"USD/hgiVk/device.h\"\n#include \"USD/hgiVk/diagnostic.h\"\n\nPXR_NAMESPACE_OPEN_SCOPE\n\n\nHgiVkBuffer::HgiVkBuffer(\n    HgiVkDevice* device,\n    HgiBufferDesc const& desc)\n    : HgiBuffer(desc)\n    , _device(device)\n    , _descriptor(desc)\n    , _vkBuffer(nullptr)\n    , _vmaBufferAllocation(nullptr)\n    , _dataMapped(nullptr)\n{\n    bool isStagingBuffer = (desc.usage & HgiBufferUsageTransferSrc);\n    bool isDestinationBuffer = (desc.usage & HgiBufferUsageTransferDst);\n\n    if (isStagingBuffer && desc.usage != HgiBufferUsageTransferSrc) {\n        TF_CODING_ERROR(\"Buffer [%x] states it is HgiBufferUsageTransferSrc, \"\n                        \"but has additional usage flags. Buffers that are used \"\n                        \"as staging buffers (TransferSrc) must be used \"\n                        \"exclusively for that purposes.\", this);\n    }\n\n    VkBufferCreateInfo bufCreateInfo = {VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO};\n    bufCreateInfo.size = desc.byteSize;\n    bufCreateInfo.usage = HgiVkConversions::GetBufferUsage(desc.usage);\n    bufCreateInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE; // gfx queue only\n\n    if (desc.data && !isStagingBuffer && !isDestinationBuffer) {\n        // It is likely the caller intended for desc.data to be uploaded into\n        // the buffer, but did not make this clear in the usage flags.\n        // We should warn, because perhaps the data is accidental garbage.\n        TF_WARN(\"Buffer [%x] descriptor provides data, but is missing \"\n                \"HgiBufferUsageTransferDst in its usage flags.\", this);\n        bufCreateInfo.usage |= VK_BUFFER_USAGE_TRANSFER_DST_BIT;\n    }\n\n// todo check with device if supported.\n    bufCreateInfo.usage |=\n        VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR;\n\n    // https://gpuopen-librariesandsdks.github.io/\n    // VulkanMemoryAllocator/html/usage_patterns.html\n\n    // Create buffer with memory allocated and bound.\n    // Equivalent to: vkCreateBuffer, vkAllocateMemory, vkBindBufferMemory\n    VmaAllocationCreateInfo allocInfo = {};\n    allocInfo.usage = VMA_MEMORY_USAGE_GPU_ONLY;\n\n    // XXX On VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU it may be beneficial to\n    // skip staging buffers and use VMA_MEMORY_USAGE_CPU_TO_GPU since all\n    // memory is shared between CPU and GPU\n\n    if (isStagingBuffer) {\n        allocInfo.usage = VMA_MEMORY_USAGE_CPU_ONLY;\n    } else if (desc.usage & HgiBufferUsageCpuToGpu) {\n        // Read-backs are possible for GPU_TO_CPU, but are likely very slow.\n        allocInfo.usage = VMA_MEMORY_USAGE_CPU_TO_GPU;\n    } else if (desc.usage & HgiBufferUsageGpuToCpu) {\n        allocInfo.usage = VMA_MEMORY_USAGE_GPU_TO_CPU;\n    }\n\n    // XXX On APPLE VMA_MEMORY_USAGE_CPU_TO_GPU may not work (textures only?).\n    // I believe there is a bug with MoltenVK where we need to ensure\n    // HOST_COHERENT is on the staging buffer. Without it the 'unmap' call below\n    // causes a problem and the data never gets into the final buffer.\n    // github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator/issues/47\n    // So far I've seen this happen with HgiVkBlitEncoder::CopyTextureGpuToCpu.\n    // There we request a GpuToCpu buffer, but it never manages to fill the\n    // buffer with the texture's pixels. Using VMA_MEMORY_USAGE_CPU_ONLY works.\n    #if defined(__APPLE__)\n        if (allocInfo.usage != VMA_MEMORY_USAGE_GPU_ONLY) {\n            allocInfo.usage = VMA_MEMORY_USAGE_CPU_ONLY;\n        }\n    #endif\n\n    TF_VERIFY(\n        vmaCreateBuffer(\n            _device->GetVulkanMemoryAllocator(),\n            &bufCreateInfo,\n            &allocInfo,\n            &_vkBuffer,\n            &_vmaBufferAllocation,\n            nullptr) == VK_SUCCESS\n    );\n\n    // Persistently map the (HOST_VISIBLE) buffer\n    if (allocInfo.usage != VMA_MEMORY_USAGE_GPU_ONLY) {\n        TF_VERIFY(\n            vmaMapMemory(\n                _device->GetVulkanMemoryAllocator(),\n                _vmaBufferAllocation,\n                &_dataMapped) == VK_SUCCESS\n        );\n    }\n\n    if (isStagingBuffer) {\n        // Copy buffer data into host local staging buffer\n        memcpy(_dataMapped, desc.data, desc.byteSize);\n\n        // If the buffer was created with HOST_COHERENT we dont need to flush.\n        // Only VMA_MEMORY_USAGE_CPU_ONLY guarantees this, please see comment\n        // for vmaFlushAllocation in VulkanMemoryAllocator.\n        if (allocInfo.usage != VMA_MEMORY_USAGE_CPU_ONLY) {\n            vmaFlushAllocation(\n                _device->GetVulkanMemoryAllocator(),\n                _vmaBufferAllocation,\n                0, // offset\n                VK_WHOLE_SIZE);\n        }\n    }\n\n    // Don't hold onto buffer data ptr locally. HgiBufferDesc states that:\n    // \"The application may alter or free this memory as soon as the constructor\n    //  of the HgiTexture has returned.\"\n    _descriptor.data = nullptr;\n\n    // Debug label - XXX RenderDoc crashes if we set it on stagingBuffer\n    if (!isStagingBuffer && !_descriptor.debugName.empty()) {\n        std::string debugLabel = \"Buffer \" + _descriptor.debugName;\n        HgiVkSetDebugName(\n            _device,\n            (uint64_t)_vkBuffer,\n            VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT,\n            debugLabel.c_str());\n    }\n}\n\nHgiVkBuffer::~HgiVkBuffer()\n{\n    if (_dataMapped) {\n        vmaUnmapMemory(\n            _device->GetVulkanMemoryAllocator(),\n            _vmaBufferAllocation);\n    }\n\n    vmaDestroyBuffer(\n        _device->GetVulkanMemoryAllocator(),\n        _vkBuffer,\n        _vmaBufferAllocation);\n}\n\n\nvoid\nHgiVkBuffer::UpdateBufferData(\n    uint32_t byteOffset,\n    size_t byteSize,\n    const void* data)\n{\n    if (!TF_VERIFY(_dataMapped, \"Buffer is not HOST_VISIBLE\")) return;\n\n    // XXX Needs more testing. Does a copy succeed even with other usage\n    // flags, but is just really slow? Or will is fail all together.\n    TF_VERIFY(_descriptor.usage & HgiBufferUsageCpuToGpu,\n              \"Buffer [%x] usage is missing HgiBufferUsageCpuToGpu. \"\n              \"UpdateBufferData may fail.\", this);\n\n    if (!TF_VERIFY(byteSize <= _descriptor.byteSize,\n                   \"Provided data too large for Buffer [%x].\", this)) {\n        return;\n    }\n\n    char* dest = (char*)_dataMapped;\n    dest += byteOffset;\n    memcpy(dest, data, byteSize);\n\n    // We need to manually flush the persistent mapped buffer to make sure the\n    // write is made visible to gpu.\n    // See comments in VMA header (search for vmaFlushAllocation).\n    // See also vkFlushMappedMemoryRanges (we don't need another barrier).\n    vmaFlushAllocation(\n        _device->GetVulkanMemoryAllocator(),\n        _vmaBufferAllocation,\n        byteOffset,\n        (VkDeviceSize) byteSize\n    );\n}\n\nVkBuffer\nHgiVkBuffer::GetBuffer() const\n{\n    return _vkBuffer;\n}\n\nHgiBufferDesc const&\nHgiVkBuffer::GetDescriptor() const\n{\n    return _descriptor;\n}\n\nuint64_t\nHgiVkBuffer::GetBufferAddress() const\n{\n    if (!_device->vkGetBufferDeviceAddressEXT) return 0;\n\n    VkBufferDeviceAddressInfoKHR info =\n        {VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR};\n    info.buffer = _vkBuffer;\n\n    VkDeviceAddress address = _device->vkGetBufferDeviceAddressEXT(\n        _device->GetVulkanDevice(),\n        &info);\n\n    TF_VERIFY(address);\n    return (uint64_t) address;\n}\n\nvoid\nHgiVkBuffer::CopyBufferFrom(\n    HgiVkCommandBuffer* cb,\n    HgiVkBuffer const& src)\n{\n    HgiBufferDesc const& srcDesc = src.GetDescriptor();\n    bool isStagingBuffer = (srcDesc.usage & HgiBufferUsageTransferSrc);\n    if (!isStagingBuffer) {\n        TF_CODING_ERROR(\"Buffer [%x] is missing usage flag: \"\n                        \"HgiBufferUsageTransferSrc\", &src);\n        return;\n    }\n\n    bool isDestSrc = (_descriptor.usage & HgiBufferUsageTransferDst);\n    if (!isDestSrc) {\n        TF_CODING_ERROR(\"Buffer [%x] is missing usage flag: \"\n                        \"HgiBufferUsageTransferDst\", this);\n        return;\n    }\n\n    if (srcDesc.byteSize > _descriptor.byteSize) {\n        TF_CODING_ERROR(\"Buffer src [%x] is larger than dest buffer [%x].\",\n                        &src, this);\n        return;\n    }\n\n    // Copy data from staging buffer to destination (gpu) buffer\n    VkBufferCopy copyRegion = {};\n    copyRegion.srcOffset = 0;\n    copyRegion.dstOffset = 0;\n    copyRegion.size = srcDesc.byteSize;\n    vkCmdCopyBuffer(\n        cb->GetCommandBufferForRecoding(),\n        src.GetBuffer(),\n        _vkBuffer,\n        1, // regionCount\n        &copyRegion);\n\n    // Make sure copy finishes before the next draw call.\n    // XXX Optimization opportunity: Currently we always set vertex/index\n    // as the consumer stage, but some buffers may be used later, such as an\n    // SSBO used only in the fragment stage.\n    VkBufferMemoryBarrier barrier = {VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER};\n    barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT; // what producer does\n    barrier.dstAccessMask = VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT |\n                            VK_ACCESS_INDEX_READ_BIT;     // what consumer does\n    barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;\n    barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;\n    barrier.buffer = _vkBuffer;\n    barrier.size = VK_WHOLE_SIZE;\n\n    vkCmdPipelineBarrier(\n        cb->GetCommandBufferForRecoding(),\n        VK_PIPELINE_STAGE_TRANSFER_BIT,     // producer stage\n        VK_PIPELINE_STAGE_VERTEX_INPUT_BIT, // consumer stage\n        0, 0, nullptr, 1, &barrier, 0, nullptr);\n}\n\nvoid\nHgiVkBuffer::CopyBufferTo(\n    void* cpuDestBuffer)\n{\n    if (!TF_VERIFY(cpuDestBuffer, \"Invalid dest buffer\")) return;\n    if (!TF_VERIFY(_dataMapped, \"Buffer is not HOST_VISIBLE\")) return;\n    memcpy(cpuDestBuffer, _dataMapped, _descriptor.byteSize);\n}\n\n\nPXR_NAMESPACE_CLOSE_SCOPE\n",
			"file": "src/USD/hgiVk/buffer.cpp",
			"file_size": 9825,
			"file_write_time": 132398943130678360,
			"settings":
			{
				"buffer_size": 9825,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#include \"USD/hgiVk/blitEncoder.h\"\n#include \"USD/hgiVk/commandBuffer.h\"\n#include \"USD/hgiVk/conversions.h\"\n#include \"USD/hgiVk/device.h\"\n#include \"USD/hgiVk/diagnostic.h\"\n#include \"USD/hgiVk/renderPass.h\"\n#include \"USD/hgiVk/texture.h\"\n#include \"USD/hgiVk/vulkan.h\"\n\n#include \"pxr/imaging/hgi/blitEncoderOps.h\"\n\nPXR_NAMESPACE_OPEN_SCOPE\n\nHgiVkBlitEncoder::HgiVkBlitEncoder(\n    HgiVkDevice* device,\n    HgiVkCommandBuffer* cmdBuf)\n    : HgiBlitEncoder()\n    , _device(device)\n    , _commandBuffer(cmdBuf)\n    , _isRecording(true)\n{\n\n}\n\nHgiVkBlitEncoder::~HgiVkBlitEncoder()\n{\n    if (_isRecording) {\n        EndEncoding();\n    }\n}\n\nvoid\nHgiVkBlitEncoder::EndEncoding()\n{\n    _commandBuffer = nullptr;\n    _isRecording = false;\n}\n\nvoid\nHgiVkBlitEncoder::CopyTextureGpuToCpu(\n    HgiTextureGpuToCpuOp const& copyOp)\n{\n    HgiVkTexture* srcTexture =\n        static_cast<HgiVkTexture*>(copyOp.gpuSourceTexture);\n\n    if (!TF_VERIFY(srcTexture && srcTexture->GetImage(),\n        \"Invalid texture handle\")) {\n        return;\n    }\n\n    if (copyOp.destinationBufferByteSize == 0) {\n        TF_WARN(\"The size of the data to copy was zero (aborted)\");\n        return;\n    }\n\n    HgiTextureDesc const& desc = srcTexture->GetDescriptor();\n\n    uint32_t layerCnt = copyOp.startLayer + copyOp.numLayers;\n    if (!TF_VERIFY(desc.layerCount >= layerCnt,\n        \"Texture has less layers than attempted to be copied\")) {\n        return;\n    }\n\n    // Create a new command pool and command buffer for this command since we\n    // need to submit it immediately and wait for it to complete so that the\n    // CPU can read the pixels data.\n    HgiVkCommandPool cp(_device);\n    HgiVkCommandBuffer cb(_device, &cp, HgiVkCommandBufferUsagePrimary);\n    VkCommandBuffer vkCmdBuf = cb.GetCommandBufferForRecoding();\n\n    // Create the GPU buffer that will receive a copy of the GPU texels that\n    // we can then memcpy to CPU buffer.\n    HgiBufferDesc dstDesc;\n    dstDesc.usage = HgiBufferUsageTransferDst | HgiBufferUsageGpuToCpu;\n    dstDesc.byteSize = copyOp.destinationBufferByteSize;\n    dstDesc.data = nullptr;\n\n    HgiVkBuffer dstBuffer(_device, dstDesc);\n\n    // Setup info to copy data form gpu texture to gpu buffer\n    HgiTextureDesc const& texDesc = srcTexture->GetDescriptor();\n\n    VkOffset3D imageOffset;\n    imageOffset.x = copyOp.sourceTexelOffset[0];\n    imageOffset.y = copyOp.sourceTexelOffset[1];\n    imageOffset.z = copyOp.sourceTexelOffset[2];\n\n    VkExtent3D imageExtent;\n    imageExtent.width = texDesc.dimensions[0];\n    imageExtent.height = texDesc.dimensions[1];\n    imageExtent.depth = texDesc.dimensions[2];\n\n    VkImageSubresourceLayers imageSub;\n    imageSub.aspectMask = HgiVkConversions::GetImageAspectFlag(texDesc.usage);\n    imageSub.baseArrayLayer = copyOp.startLayer;\n    imageSub.layerCount = copyOp.numLayers;\n    imageSub.mipLevel = copyOp.mipLevel;\n\n    // See vulkan docs: Copying Data Between Buffers and Images\n    VkBufferImageCopy region;\n    region.bufferImageHeight = 0; // Buffer is tightly packed, like image\n    region.bufferRowLength = 0;   // Buffer is tightly packed, like image\n    region.bufferOffset = (VkDeviceSize) copyOp.destinationByteOffset;\n    region.imageExtent = imageExtent;\n    region.imageOffset = imageOffset;\n    region.imageSubresource = imageSub;\n\n    // Transition image to TRANSFER_READ\n    VkImageLayout oldLayout = srcTexture->GetImageLayout();\n    srcTexture->TransitionImageBarrier(\n        &cb,\n        srcTexture,\n        VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, // transition tex to this layout\n        VK_ACCESS_TRANSFER_READ_BIT,          // type of access\n        VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,    // producer stage\n        VK_PIPELINE_STAGE_TRANSFER_BIT);      // consumer stage\n\n    // Copy gpu texture to gpu buffer\n    vkCmdCopyImageToBuffer(\n        vkCmdBuf,\n        srcTexture->GetImage(),\n        srcTexture->GetImageLayout(),\n        dstBuffer.GetBuffer(),\n        1,\n        &region);\n\n    // Transition image back to what it was.\n    srcTexture->TransitionImageBarrier(\n        &cb,\n        srcTexture,\n        oldLayout, // transition tex to this layout\n        HgiVkRenderPass::GetDefaultDstAccessMask(), // type of access\n        VK_PIPELINE_STAGE_TRANSFER_BIT,             // producer stage\n        VK_PIPELINE_STAGE_VERTEX_SHADER_BIT);       // consumer stage\n\n    cb.EndRecording();\n\n    // Create a fence we can block the CPU on until copy is completed\n    VkFence vkFence;\n    VkFenceCreateInfo fenceInfo = {VK_STRUCTURE_TYPE_FENCE_CREATE_INFO};\n\n    TF_VERIFY(\n        vkCreateFence(\n            _device->GetVulkanDevice(),\n            &fenceInfo,\n            HgiVkAllocator(),\n            &vkFence) == VK_SUCCESS\n    );\n\n    // Submit the command buffer\n    std::vector<VkSubmitInfo> submitInfos;\n    VkSubmitInfo submitInfo = {VK_STRUCTURE_TYPE_SUBMIT_INFO};\n    submitInfo.commandBufferCount = 1;\n    submitInfo.pCommandBuffers = &vkCmdBuf;\n    submitInfos.emplace_back(std::move(submitInfo));\n    _device->SubmitToQueue(submitInfos, vkFence);\n\n    // Wait for the copy from GPU to CPU to complete.\n    // XXX Performance warning: This call is going to stall CPU.\n    TF_VERIFY(\n        vkWaitForFences(\n            _device->GetVulkanDevice(),\n            1,\n            &vkFence,\n            VK_TRUE,\n            100000000000) == VK_SUCCESS\n    );\n\n    vkDestroyFence(_device->GetVulkanDevice(), vkFence, HgiVkAllocator());\n\n    // Copy the data from gpu buffer to cpu destination buffer\n    dstBuffer.CopyBufferTo(copyOp.cpuDestinationBuffer);\n}\n\nvoid\nHgiVkBlitEncoder::PushDebugGroup(const char* label)\n{\n    if (!TF_VERIFY(_isRecording && _commandBuffer)) return;\n    HgiVkBeginDebugMarker(_commandBuffer, label);\n}\n\nvoid\nHgiVkBlitEncoder::PopDebugGroup()\n{\n    if (!TF_VERIFY(_isRecording && _commandBuffer)) return;\n    HgiVkEndDebugMarker(_commandBuffer);\n}\n\nvoid\nHgiVkBlitEncoder::PushTimeQuery(const char* name)\n{\n    if (!TF_VERIFY(_isRecording && _commandBuffer)) return;\n    _commandBuffer->PushTimeQuery(name);\n}\n\nvoid\nHgiVkBlitEncoder::PopTimeQuery()\n{\n    if (!TF_VERIFY(_isRecording && _commandBuffer)) return;\n    _commandBuffer->PopTimeQuery();\n}\n\nPXR_NAMESPACE_CLOSE_SCOPE\n",
			"file": "src/USD/hgiVk/blitEncoder.cpp",
			"file_size": 6180,
			"file_write_time": 132398943397824659,
			"settings":
			{
				"buffer_size": 6180,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#ifndef PXR_IMAGING_HGIVK_BLIT_ENCODER_H\n#define PXR_IMAGING_HGIVK_BLIT_ENCODER_H\n\n#include \"pxr/pxr.h\"\n#include \"USD/hgiVk/api.h\"\n#include \"pxr/imaging/hgi/blitEncoder.h\"\n\nPXR_NAMESPACE_OPEN_SCOPE\n\nclass HgiVkCommandBuffer;\nclass HgiVkDevice;\n\n/// \\class HgiVkBlitEncoder\n///\n/// Vulkan implementation of HgiBlitEncoder.\n///\nclass HgiVkBlitEncoder final : public HgiBlitEncoder\n{\npublic:\n    HGIVK_API\n    HgiVkBlitEncoder(\n        HgiVkDevice* device,\n        HgiVkCommandBuffer* cmdBuf);\n\n    HGIVK_API\n    virtual ~HgiVkBlitEncoder();\n\n    HGIVK_API\n    void EndEncoding() override;\n\n    HGIVK_API\n    void CopyTextureGpuToCpu(HgiTextureGpuToCpuOp const& copyOp) override;\n\n    HGIVK_API\n    void PushDebugGroup(const char* label) override;\n\n    HGIVK_API\n    void PopDebugGroup() override;\n\n    HGIVK_API\n    void PushTimeQuery(const char* label) override;\n\n    HGIVK_API\n    void PopTimeQuery() override;\n\nprivate:\n    HgiVkBlitEncoder() = delete;\n    HgiVkBlitEncoder & operator=(const HgiVkBlitEncoder&) = delete;\n    HgiVkBlitEncoder(const HgiVkBlitEncoder&) = delete;\n\nprivate:\n    HgiVkDevice* _device;\n    HgiVkCommandBuffer* _commandBuffer;\n    bool _isRecording;\n\n    // Encoder is used only one frame so storing multi-frame state on encoder\n    // will not survive.\n};\n\nPXR_NAMESPACE_CLOSE_SCOPE\n\n#endif\n",
			"file": "src/USD/hgiVk/blitEncoder.h",
			"file_size": 1319,
			"file_write_time": 132398943556775947,
			"settings":
			{
				"buffer_size": 1319,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#ifndef PXR_IMAGING_HGIVK_BUFFER_H\n#define PXR_IMAGING_HGIVK_BUFFER_H\n\n#include \"pxr/imaging/hgi/buffer.h\"\n\n#include \"USD/hgiVk/api.h\"\n#include \"USD/hgiVk/vulkan.h\"\n\nPXR_NAMESPACE_OPEN_SCOPE\n\nclass HgiVkDevice;\nclass HgiVkCommandBuffer;\n\n\n///\n/// \\class HgiVkBuffer\n///\n/// Vulkan implementation of HgiBuffer\n///\nclass HgiVkBuffer final : public HgiBuffer {\npublic:\n    HGIVK_API\n    HgiVkBuffer(\n        HgiVkDevice* device,\n        HgiBufferDesc const& desc);\n\n    HGIVK_API\n    virtual ~HgiVkBuffer();\n\n    HGIVK_API\n    void UpdateBufferData(\n        uint32_t byteOffset,\n        size_t byteSize,\n        const void* data) override;\n\n    HGIVK_API\n    uint64_t GetBufferAddress() const override;\n\npublic:\n    /// Returns the vulkan buffer.\n    HGIVK_API\n    VkBuffer GetBuffer() const;\n\n    /// Returns the descriptor of this buffer.\n    HGIVK_API\n    HgiBufferDesc const& GetDescriptor() const;\n\n    /// Records a GPU->GPU copy command to copy the data from the provided\n    /// source buffer into this (destination) buffer. This requires that the\n    /// source buffer is setup as a staging buffer (HgiBufferUsageTransferSrc)\n    /// and that this (destination) buffer has usage: HgiBufferUsageTransferDst.\n    HGIVK_API\n    void CopyBufferFrom(\n        HgiVkCommandBuffer* cb,\n        HgiVkBuffer const& src);\n\n    /// Copy the entire contents of this buffer to the cpuDestBuffer.\n    /// 'cpuDestBuffer' must be off minimum size: GetDescriptor().byteSize.\n    /// The buffer must have usage flags HgiBufferUsageGpuToCpu or\n    /// HgiBufferUsageCpuToGpu.\n    HGIVK_API\n    void CopyBufferTo(\n        void* cpuDestBuffer);\n\nprivate:\n    HgiVkBuffer() = delete;\n    HgiVkBuffer & operator=(const HgiVkBuffer&) = delete;\n    HgiVkBuffer(const HgiVkBuffer&) = delete;\n\nprivate:\n    HgiVkDevice* _device;\n    HgiBufferDesc _descriptor;\n    VkBuffer _vkBuffer;\n    VmaAllocation _vmaBufferAllocation;\n    void* _dataMapped;\n};\n\n\nPXR_NAMESPACE_CLOSE_SCOPE\n\n#endif\n",
			"file": "src/USD/hgiVk/buffer.h",
			"file_size": 1965,
			"file_write_time": 132398943634251770,
			"settings":
			{
				"buffer_size": 1965,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#ifndef PXR_IMAGING_HGIVK_COMMAND_BUFFER_H\n#define PXR_IMAGING_HGIVK_COMMAND_BUFFER_H\n\n#include <vector>\n\n#include \"pxr/pxr.h\"\n#include \"pxr/imaging/hgi/encoderOps.h\"\n#include \"pxr/imaging/hgi/graphicsEncoderDesc.h\"\n\n#include \"USD/hgiVk/api.h\"\n#include \"USD/hgiVk/vulkan.h\"\n\n#define HGIVK_MAX_TIMESTAMPS 16\n\n\nPXR_NAMESPACE_OPEN_SCOPE\n\nclass HgiVkCommandPool;\nclass HgiVkDevice;\nclass HgiVkRenderPass;\n\n\n/// \\enum HgiVkCommandBufferUsage\n///\n/// Describes the purpose of the command buffer.\n///\n/// <ul>\n/// <li>HgiVkCommandBufferUsagePrimary:\n///   Primary cmd buf.</li>\n/// <li>HgiVkCommandBufferUsageSecondaryRenderPass:\n///   Secondary cmd buf used during parallel draw commands recording within\n///   a render pass.</li>\n/// <li>HgiVkCommandBufferUsageSecondaryOther:\n///   Secondary cmd buf used during parallel command recording outside of\n///   a render pass (ie. non-draw calls).</li>\n/// </ul>\n///\nenum HgiVkCommandBufferUsage {\n    HgiVkCommandBufferUsagePrimary = 0,\n    HgiVkCommandBufferUsageSecondaryRenderPass,\n    HgiVkCommandBufferUsageSecondaryOther,\n\n    HgiVkCommandBufferUsageCount\n};\n\n\n/// \\class HgiVkCommandBuffer\n///\n/// Wrapper for vulkan command buffer\n///\nclass HgiVkCommandBuffer final\n{\npublic:\n    HGIVK_API\n    HgiVkCommandBuffer(\n        HgiVkDevice* device,\n        HgiVkCommandPool* commandPool,\n        HgiVkCommandBufferUsage usage);\n\n    HGIVK_API\n    virtual ~HgiVkCommandBuffer();\n\n    /// When a command buffer is used as a secondary command buffer during\n    /// parallel graphics encoding it needs to know the renderpass it will\n    /// inherit from (the render pass that is begin/ended in the primary\n    /// command buffer).\n    HGIVK_API\n    void SetRenderPass(HgiVkRenderPass* rp);\n\n    /// End recording for command buffer.\n    HGIVK_API\n    void EndRecording();\n\n    /// Returns true if the command buffer has been used this frame.\n    HGIVK_API\n    bool IsRecording() const;\n\n    /// Ensures the command buffer is ready to record commands and returns the\n    /// vulkan command buffer.\n    HGIVK_API\n    VkCommandBuffer GetCommandBufferForRecoding();\n\n    /// Returns the vulkan command buffer. Makes no attempt to ensure the\n    /// command buffer is ready to record (see AcquireVulkanCommandBuffer);\n    HGIVK_API\n    VkCommandBuffer GetVulkanCommandBuffer() const;\n\n    /// Set debug name.\n    HGIVK_API\n    void SetDebugName(const char* name);\n\n    /// Push a time stamp onto stack. This records the start time (TOP_OF_PIPE).\n    HGIVK_API\n    void PushTimeQuery(const char* name);\n\n    /// Pop last timestamp of stack. This records the end time (BOTTOM_OF_PIPE).\n    HGIVK_API\n    void PopTimeQuery();\n\n    /// Returns the list of recorded time queries.\n    /// This must be called after EndRecording & before recording is re-started.\n    HGIVK_API\n    HgiTimeQueryVector const& GetTimeQueries();\n\n    /// Reset time queries. This must be called before any render pass begins.\n    /// It is called from the command buffer manager at BeginFrame.\n    /// Reset happens in the provided cmd buf, not the internal cmd buf.\n    HGIVK_API\n    void ResetTimeQueries(HgiVkCommandBuffer* cb);\n\nprivate:\n    HgiVkCommandBuffer() = delete;\n    HgiVkCommandBuffer & operator= (const HgiVkCommandBuffer&) = delete;\n    HgiVkCommandBuffer(const HgiVkCommandBuffer&) = delete;\n\n    // Ensures a command buffer is ready to record commands.\n    void _BeginRecording();\n\nprivate:\n    HgiVkDevice* _device;\n    HgiVkCommandPool* _commandPool;\n    HgiVkCommandBufferUsage _usage;\n\n    bool _isRecording;\n\n    VkCommandBuffer _vkCommandBuffer;\n    VkCommandBufferInheritanceInfo _vkInheritanceInfo;\n\n    VkQueryPool _vkTimeStampQueryPool;\n    HgiTimeQueryVector _timeQueries;\n    bool _timeQueriesReset;\n};\n\ntypedef std::vector<HgiVkCommandBuffer*> HgiVkCommandBufferVector;\n\n\nPXR_NAMESPACE_CLOSE_SCOPE\n\n#endif\n",
			"file": "src/USD/hgiVk/commandBuffer.h",
			"file_size": 3844,
			"file_write_time": 132398943729046720,
			"settings":
			{
				"buffer_size": 3844,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#ifndef PXR_IMAGING_HGIVK_COMMAND_BUFFER_MANAGER_H\n#define PXR_IMAGING_HGIVK_COMMAND_BUFFER_MANAGER_H\n\n#include <atomic>\n#include <memory>\n#include <string>\n\n#include \"pxr/pxr.h\"\n\n#include \"USD/hgiVk/api.h\"\n#include \"USD/hgiVk/commandBuffer.h\"\n#include \"USD/hgiVk/commandPool.h\"\n#include \"USD/hgiVk/vulkan.h\"\n\nPXR_NAMESPACE_OPEN_SCOPE\n\n\nclass HgiVkDevice;\nclass HgiVkCommandBuffer;\n\n\n/// \\class HgiVkCommandBufferManager\n///\n/// Manages the creation and thread-safety of command pool and buffers for one\n/// render frame. Vulkan command pools & buffers are 'externally synchornized'.\n/// Which means we need to ensure only one thread access them at a time.\n/// The command buffer manager does this by creating a pool & buffer per thread.\n/// Thread local storage is used to assign one pool and buffer to a thread.\n///\n///\nclass HgiVkCommandBufferManager final\n{\npublic:\n    HGIVK_API\n    HgiVkCommandBufferManager(\n        HgiVkDevice* device);\n\n    HGIVK_API\n    virtual ~HgiVkCommandBufferManager();\n\n    /// Should be called exactly once at the start of rendering an app frame.\n    HGIVK_API\n    void BeginFrame(uint64_t frame);\n\n    /// Should be called exactly once at the end of rendering an app frame.\n    /// The provided fence is submitted to the queue and will be signaled once\n    /// the command buffers have been consumed. This would usually be the same\n    /// fence that the Frame waits on.\n    HGIVK_API\n    void EndFrame(VkFence fence);\n\n    /// Returns a (thread_local) resource command buffer.\n    /// It is guaranteed the returned command buffer is not currently being\n    /// consumed by the GPU.\n    /// Thread safety: The returned command buffer is thread_local. It is\n    /// guaranteed no other thread will use this command buffer for recording.\n    HGIVK_API\n    HgiVkCommandBuffer* GetResourceCommandBuffer();\n\n    /// Returns a (thread_local) draw command buffer.\n    /// It is guaranteed the returned command buffer is not currently being\n    /// consumed by the GPU.\n    /// Thread safety: The returned command buffer is thread_local. It is\n    /// guaranteed no other thread will use this command buffer for recording.\n    HGIVK_API\n    HgiVkCommandBuffer* GetDrawCommandBuffer();\n\n    /// Called by each parallel encoder to ensure there is enough secondary\n    /// command buffers space available. Returns the 'unique start id' of the\n    /// encoder's location in the secondary command buffer vector.\n    /// This unique id is needed during GetSecondaryDrawCommandBuffer.\n    /// Thread safety: Not thread safe. Must be called before any parallel\n    /// rendering begins.\n    HGIVK_API\n    size_t ReserveSecondaryDrawBuffersForParallelEncoder();\n\n    /// Returns a (thread_local) secondary draw command buffer.\n    /// Secondary command buffers are used during parallel graphics encoding to\n    /// split draw calls over multiple threads. The 'id' should be the value\n    /// returned by ReserveSecondaryDrawBuffersForParallelEncoder().\n    /// It is guaranteed the returned command buffer is not currently being\n    /// consumed by the GPU.\n    /// Thread safety: The returned command buffer is thread_local. It is\n    /// guaranteed no other thread will use this command buffer for recording.\n    HGIVK_API\n    HgiVkCommandBuffer* GetSecondaryDrawCommandBuffer(size_t id);\n\n    /// End recording for the secondary command buffers identified with 'id' and\n    /// executes (records) them into the primary command buffer.\n    HGIVK_API\n    void ExecuteSecondaryCommandBuffers(\n        size_t id,\n        HgiVkCommandBuffer* primaryCommandBuffer);\n\n    /// Set debug name the vulkan objects held by this manager will have.\n    HGIVK_API\n    void SetDebugName(std::string const& name);\n\n    /// Returns the time queries of all command buffers of the previous run.\n    HGIVK_API\n    HgiTimeQueryVector const & GetTimeQueries() const;\n\nprivate:\n    HgiVkCommandBufferManager() = delete;\n    HgiVkCommandBufferManager & operator= (\n        const HgiVkCommandBufferManager&) = delete;\n    HgiVkCommandBufferManager(\n        const HgiVkCommandBufferManager&) = delete;\n\n    // Create pools and command buffers for parallel recording.\n    void _CreatePoolsAndBuffers();\n\n    // This function ensures that each thread grabs an unique index in the\n    // command buffer vectors for the current frame.\n    void _UpdateThreadLocalIndex();\n\nprivate:\n    HgiVkDevice* _device;\n\n    uint64_t _frame;\n\n    // This index is reset each frame and allows each thread to grab an\n    // unique index into the command buffer and descriptor pool vectors.\n    std::atomic<uint16_t> _nextAvailableIndex;\n\n    // These are the primary command buffers.\n    // Resource commands and draw commands are split into seperate command\n    // buffers so we can submit the resources changes first. We want them to\n    // complete before the draw commands begin.\n    // The vectors hold a command buffer for each thread.\n    HgiVkCommandBufferVector _resourceCommandBuffers;\n    HgiVkCommandBufferVector _drawCommandBuffers;\n\n    // Secondary draw command buffers are used to parallize rendering into a\n    // render pass. This vector is grown dynamically as needed by parallel\n    // command encoders.\n    HgiVkCommandBufferVector _secondaryDrawCommandBuffers;\n\n    // One command pool per primary command buffer, per thread.\n    HgiVkCommandPoolVector _commandPools;\n\n    // This counter keeps track of how many parallel encoders are used each\n    // frame so we can make sure we have enough secondary command buffers.\n    uint16_t _parallelEncoderCounter;\n\n    // This semaphore is used to synchronize the submission of resource and draw\n    // command buffers.\n    VkSemaphore _vkSemaphore;\n\n    // Time queries of previous run.\n    HgiTimeQueryVector _timeQueries;\n\n    // Debug label\n    std::string _debugName;\n};\n\n\nPXR_NAMESPACE_CLOSE_SCOPE\n\n#endif\n",
			"file": "src/USD/hgiVk/commandBufferManager.h",
			"file_size": 5853,
			"file_write_time": 132398943873119169,
			"settings":
			{
				"buffer_size": 5853,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#ifndef PXR_IMAGING_HGIVK_COMMAND_POOL_H\n#define PXR_IMAGING_HGIVK_COMMAND_POOL_H\n\n#include <vector>\n\n#include \"pxr/pxr.h\"\n#include \"pxr/imaging/hgi/graphicsEncoderDesc.h\"\n\n#include \"USD/hgiVk/api.h\"\n#include \"USD/hgiVk/vulkan.h\"\n\nPXR_NAMESPACE_OPEN_SCOPE\n\nclass HgiVkDevice;\n\n\n/// \\class HgiVkCommandPool\n///\n/// Wrapper for vulkan command pool\n///\nclass HgiVkCommandPool final\n{\npublic:\n    HGIVK_API\n    HgiVkCommandPool(HgiVkDevice* device);\n\n    HGIVK_API\n    virtual ~HgiVkCommandPool();\n\n    /// Reset the command pool.\n    HGIVK_API\n    void ResetCommandPool();\n\n    /// Returns the vulkan command pool.\n    HGIVK_API\n    VkCommandPool GetVulkanCommandPool() const;\n\n    /// Set debug name.\n    HGIVK_API\n    void SetDebugName(std::string const& name);\n\nprivate:\n    HgiVkCommandPool() = delete;\n    HgiVkCommandPool & operator= (const HgiVkCommandPool&) = delete;\n    HgiVkCommandPool(const HgiVkCommandPool&) = delete;\n\nprivate:\n    HgiVkDevice* _device;\n    VkCommandPool _vkCommandPool;\n};\n\ntypedef std::vector<HgiVkCommandPool*> HgiVkCommandPoolVector;\n\n\nPXR_NAMESPACE_CLOSE_SCOPE\n\n#endif\n",
			"file": "src/USD/hgiVk/commandPool.h",
			"file_size": 1102,
			"file_write_time": 132398944036230797,
			"settings":
			{
				"buffer_size": 1102,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#ifndef PXR_IMAGING_HGIVK_COMPUTE_ENCODER_H\n#define PXR_IMAGING_HGIVK_COMPUTE_ENCODER_H\n\n#include \"pxr/pxr.h\"\n#include \"pxr/imaging/hgi/computeEncoder.h\"\n#include \"pxr/imaging/hgi/pipeline.h\"\n#include \"pxr/imaging/hgi/resourceBindings.h\"\n\n#include \"USD/hgiVk/api.h\"\n\n\nPXR_NAMESPACE_OPEN_SCOPE\n\nclass HgiVkCommandBuffer;\nclass HgiVkDevice;\n\n\n/// \\class HgiVkComputeEncoder\n///\n/// Vulkan implementation of HgiComputeEncoder.\n///\nclass HgiVkComputeEncoder final : public HgiComputeEncoder\n{\npublic:\n    HGIVK_API\n    HgiVkComputeEncoder(\n        HgiVkDevice* device,\n        HgiVkCommandBuffer* cb);\n\n    HGIVK_API\n    virtual ~HgiVkComputeEncoder();\n\n    HGIVK_API\n    void EndEncoding() override;\n\n    HGIVK_API\n    void BindPipeline(HgiPipelineHandle pipeline) override;\n\n    HGIVK_API\n    void BindResources(HgiResourceBindingsHandle resources) override;\n\n    HGIVK_API\n    void Dispatch(\n        uint32_t threadGrpCntX,\n        uint32_t threadGrpCntY,\n        uint32_t threadGrpCntZ) override;\n\n    /// Push a debug marker onto the encoder.\n    HGI_API\n    void PushDebugGroup(const char* label) override;\n\n    /// Pop the lastest debug marker off encoder.\n    HGI_API\n    void PopDebugGroup() override;\n\nprivate:\n    HgiVkComputeEncoder() = delete;\n    HgiVkComputeEncoder & operator=(const HgiVkComputeEncoder&) = delete;\n    HgiVkComputeEncoder(const HgiVkComputeEncoder&) = delete;\n\nprivate:\n    HgiVkDevice* _device;\n    HgiVkCommandBuffer* _commandBuffer;\n    bool _isRecording;\n\n    // Encoder is used only one frame so storing multi-frame state on encoder\n    // will not survive.\n};\n\n\nPXR_NAMESPACE_CLOSE_SCOPE\n\n#endif\n",
			"file": "src/USD/hgiVk/computeEncoder.h",
			"file_size": 1631,
			"file_write_time": 132398944087988179,
			"settings":
			{
				"buffer_size": 1631,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#ifndef PXR_IMAGING_HGIVK_CONVERSIONS_H\n#define PXR_IMAGING_HGIVK_CONVERSIONS_H\n\n#include \"pxr/pxr.h\"\n#include \"pxr/imaging/hgi/enums.h\"\n#include \"pxr/imaging/hgi/types.h\"\n\n#include \"pxr/imaging/hgi/enums.h\"\n\n#include \"USD/hgiVk/api.h\"\n#include \"USD/hgiVk/vulkan.h\"\n\nPXR_NAMESPACE_OPEN_SCOPE\n\n///\n/// \\class HgiVkConversions\n///\n/// Converts from Hgi types to Vulkan types.\n///\nclass HgiVkConversions final\n{\npublic:\n    HGIVK_API\n    static VkFormat GetFormat(HgiFormat inFormat);\n\n    HGIVK_API\n    static HgiFormat GetFormat(VkFormat inFormat);\n\n    HGIVK_API\n    static uint32_t GetBytesPerPixel(HgiFormat inFormat);\n\n    HGIVK_API\n    static VkImageAspectFlags GetImageAspectFlag(HgiTextureUsage usage);\n\n    HGIVK_API\n    static VkImageUsageFlags GetTextureUsage(HgiTextureUsage tu);\n\n    HGIVK_API\n    static VkFormatFeatureFlags GetFormatFeature(HgiTextureUsage tu);\n\n    HGIVK_API\n    static VkAttachmentLoadOp GetLoadOp(HgiAttachmentLoadOp op);\n\n    HGIVK_API\n    static VkAttachmentStoreOp GetStoreOp(HgiAttachmentStoreOp op);\n\n    HGIVK_API\n    static VkSampleCountFlagBits GetSampleCount(HgiSampleCount sc);\n\n    HGIVK_API\n    static VkShaderStageFlags GetShaderStages(HgiShaderStage ss);\n\n    HGIVK_API\n    static VkBufferUsageFlags GetBufferUsage(HgiBufferUsage bu);\n\n    HGIVK_API\n    static VkCullModeFlags GetCullMode(HgiCullMode cm);\n\n    HGIVK_API\n    static VkPolygonMode GetPolygonMode(HgiPolygonMode pm);\n\n    HGIVK_API\n    static VkFrontFace GetWinding(HgiWinding wd);\n\n    HGIVK_API\n    static VkCompareOp GetCompareOp(HgiCompareOp co);\n\n    HGIVK_API\n    static VkDescriptorType GetDescriptorType(HgiBindResourceType rt);\n};\n\n\nPXR_NAMESPACE_CLOSE_SCOPE\n\n#endif\n\n",
			"file": "src/USD/hgiVk/conversions.h",
			"file_size": 1688,
			"file_write_time": 132398944151904971,
			"settings":
			{
				"buffer_size": 1688,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#ifndef PXR_IMAGING_HGIVK_DEVICE_H\n#define PXR_IMAGING_HGIVK_DEVICE_H\n\n#include <mutex>\n#include <vector>\n\n#include \"pxr/pxr.h\"\n#include \"pxr/imaging/hgi/deviceFeatures.h\"\n\n#include \"USD/hgiVk/api.h\"\n#include \"USD/hgiVk/frame.h\"\n#include \"USD/hgiVk/object.h\"\n#include \"USD/hgiVk/renderPassPipelineCache.h\"\n#include \"USD/hgiVk/shaderCompiler.h\"\n#include \"USD/hgiVk/vulkan.h\"\n\n\nPXR_NAMESPACE_OPEN_SCOPE\n\nclass HgiVkInstance;\nclass HgiVkCommands;\nclass HgiVkCommandBuffer;\nclass HgiVkCommandBufferManager;\nclass HgiVkCommandPool;\n\n\n/// Device configuration settings\nenum HgiVkDeviceSettings{\n    HgiVkPresentationType = 0,\n    HgiVkRingBufferSize = 3\n};\n\n\n/// \\class HgiVkDevice\n///\n/// Vulkan implementation of GPU device.\n///\nclass HgiVkDevice final {\npublic:\n    HGIVK_API\n    HgiVkDevice(\n        HgiVkInstance* instance,\n        HgiVkDeviceSettings deviceType);\n\n    HGIVK_API\n    ~HgiVkDevice();\n\n    /// Should be called exactly once at the start of rendering a new app frame.\n    HGIVK_API\n    void BeginFrame();\n\n    /// Should be called exactly once at the end of rendering an app frame.\n    HGIVK_API\n    void EndFrame();\n\n    /// Returns the command buffer manager of the current frame.\n    /// The command buffer manager is used to acquire a command buffer.\n    /// Do not hold onto this ptr. It is valid only for one frame and must be\n    /// re-acquired each frame.\n    HGIVK_API\n    HgiVkCommandBufferManager* GetCommandBufferManager();\n\n    /// Commits provided command buffers to queue.\n    /// `fence` is optional and can be nullptr.\n    /// Thread safety: This call ensures only one thread can submit at once.\n    HGIVK_API\n    void SubmitToQueue(\n        std::vector<VkSubmitInfo> const& submitInfos,\n        VkFence fence);\n\n    /// Returns the vulkan device\n    HGIVK_API\n    VkDevice GetVulkanDevice() const;\n\n    /// Returns the vulkan physical device\n    HGIVK_API\n    VkPhysicalDevice GetVulkanPhysicalDevice() const;\n\n    /// Returns the vulkan physical device properties\n    HGIVK_API\n    VkPhysicalDeviceProperties const& GetVulkanPhysicalDeviceProperties() const;\n\n    /// Returns the vulkan physical device features\n    HGIVK_API\n    VkPhysicalDeviceFeatures const& GetVulkanPhysicalDeviceFeatures() const;\n\n    /// Returns the indexing features of the physical device\n    HGIVK_API\n    VkPhysicalDeviceDescriptorIndexingFeaturesEXT const&\n    GetVulkanPhysicalDeviceIndexingFeatures() const;\n\n    /// Returns the vulkan memory allocator\n    HGIVK_API\n    VmaAllocator GetVulkanMemoryAllocator() const;\n\n    /// Returns a render pass for the provided descriptor.\n    /// Call ReleaseRenderPass after ending the render pass.\n    HGIVK_API\n    HgiVkRenderPass* AcquireRenderPass(HgiGraphicsEncoderDesc const& desc);\n\n    /// Releases the usage of the provided render pass.\n    /// Another graphics encoder may now re-use this render pass.\n    /// This should be called after calling EndRenderPass on the render pass.\n    HGIVK_API\n    void ReleaseRenderPass(HgiVkRenderPass* rp);\n\n    /// Returns the vulkan device queue.\n    HGIVK_API\n    VkQueue GetVulkanDeviceQueue() const;\n\n    /// Returns the family index of the vulkan device queue.\n    HGIVK_API\n    uint32_t GetVulkanDeviceQueueFamilyIndex() const;\n\n    /// Returns the vulkan pipeline cache\n    HGIVK_API\n    VkPipelineCache GetVulkanPipelineCache() const;\n\n    /// Returns the glsl to SPIRV shader compiler\n    HGIVK_API\n    HgiVkShaderCompiler* GetShaderCompiler();\n\n    /// Manages deletion of a vulkan object.\n    /// Deletion of all objects must happen via this method since we can have\n    /// multiple frames of cmd buffers in-flight and deletion of the object must\n    /// wait until no cmd buffers are using the object anymore.\n    /// For this reason, vulkan object deletion (and GPU memory release) may be\n    /// delayed by several frames.\n    HGIVK_API\n    void DestroyObject(HgiVkObject const& object);\n\n    /// Wait for all queued up commands to have been processed on device.\n    /// This should ideally never be used as it creates very big stalls.\n    HGIVK_API\n    void WaitForIdle();\n\n    /// Returns the (internal) frame counter value.\n    HGIVK_API\n    uint64_t GetCurrentFrame() const;\n\n    /// Returns device used and unused memmory.\n    HGIVK_API\n    void GetDeviceMemoryInfo(size_t* used, size_t* unused) const;\n\n    /// Returns true if the device support debug marker extension\n    HGIVK_API\n    bool GetDeviceSupportDebugMarkers() const;\n\n    /// Returns true if the device support time stamps\n    HGIVK_API\n    bool GetDeviceSupportTimeStamps() const;\n\n    /// Returns time queries recorded in the previous run of the current frame.\n    HGIVK_API\n    HgiTimeQueryVector const & GetTimeQueries() const;\n\n    /// Returns the feature and limits of the device\n    HGIVK_API\n    HgiDeviceFeatures const& GetDeviceFeatures() const;\n\npublic:\n    /// device extension functions\n\n    // Not supported on MoltenVk 1\n    PFN_vkCreateRenderPass2KHR vkCreateRenderPass2KHR = 0;\n    PFN_vkGetBufferDeviceAddressEXT vkGetBufferDeviceAddressEXT = 0;\n\nprivate:\n    HgiVkDevice() = delete;\n    HgiVkDevice & operator=(const HgiVkDevice&) = delete;\n    HgiVkDevice(const HgiVkDevice&) = delete;\n\n    // Returns true if the provided extension is supported by the device\n    bool _IsSupportedExtension(const char* extensionName) const;\n\nprivate:\n    // Vulkan device objects\n    VmaAllocator _vmaAllocator;\n    VkPhysicalDevice _vkPhysicalDevice;\n    VkPhysicalDeviceProperties _vkDeviceProperties;\n    VkPhysicalDeviceFeatures _vkDeviceFeatures;\n    VkPhysicalDeviceDescriptorIndexingFeaturesEXT _indexingFeatures;\n    VkPhysicalDeviceMemoryProperties _vkMemoryProperties;\n    VkDevice _vkDevice;\n    uint32_t _vkQueueFamilyIndex;\n    VkQueue _vkQueue;\n    VkPipelineCache _vkPipelineCache;\n    std::vector<VkExtensionProperties> _extensions;\n    bool _supportsDebugMarkers;\n    bool _supportsTimeStamps;\n\n    // Vulkan queue is externally synchronized\n    std::mutex _queuelock;\n\n    // glsl SPIRV shader compiler\n    HgiVkShaderCompiler _shaderCompiler;\n\n    // Frame information\n    uint64_t _frame;\n    bool _frameStarted;\n\n    // Internal cache of render passes that map to client created pipelines.\n    HgiVkRenderPassPipelineCache _renderPassPipelineCache;\n\n    // We can have multiple frames in-flight (ring-buffer) where the CPU is\n    // recording new command for frame N while the GPU is rendering frame N-2.\n    int8_t _ringBufferIndex;\n    HgiVkRenderFrameVector _frames;\n\n    // Features Hgi is interested in\n    HgiDeviceFeatures _hgiDeviceFeatures;\n};\n\n\nPXR_NAMESPACE_CLOSE_SCOPE\n\n#endif\n",
			"file": "src/USD/hgiVk/device.h",
			"file_size": 6599,
			"file_write_time": 132398944337095829,
			"settings":
			{
				"buffer_size": 6599,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#ifndef PXR_IMAGING_HGIVK_DIAGNOSTIC_H\n#define PXR_IMAGING_HGIVK_DIAGNOSTIC_H\n\n#include <stdint.h>\n\n#include \"pxr/pxr.h\"\n\n#include \"USD/hgiVk/api.h\"\n\nPXR_NAMESPACE_OPEN_SCOPE\n\nclass HgiVkInstance;\nclass HgiVkDevice;\nclass HgiVkCommandBuffer;\n\n\n/// Returns true if debugging is enabled (HGIVK_DEBUG=1)\nHGIVK_API\nbool HgiVkIsDebugEnabled();\n\n/// Setup vulkan debug callbacks\nHGIVK_API\nvoid HgiVkCreateDebug(HgiVkInstance* instance);\n\n/// Tear down vulkan debug callbacks\nHGIVK_API\nvoid HgiVkDestroyDebug(HgiVkInstance* instance);\n\n/// Setup vulkan device debug function ptrs\nHGIVK_API\nvoid HgiVkInitializeDeviceDebug(HgiVkDevice* device);\n\n/// Push a debug marker\nHGIVK_API\nvoid HgiVkBeginDebugMarker(\n    HgiVkCommandBuffer* cmdBuf,\n    const char* name);\n\n/// Pop a debug marker\nHGIVK_API\nvoid HgiVkEndDebugMarker(\n    HgiVkCommandBuffer* cb);\n\n/// Add a debug name to a vulkan object\nHGIVK_API\nvoid HgiVkSetDebugName(\n    HgiVkDevice* device,\n    uint64_t vulkanObject,\n    uint32_t /*VkDebugReportObjectTypeEXT*/ objectType,\n    const char* name);\n\nPXR_NAMESPACE_CLOSE_SCOPE\n\n#endif\n",
			"file": "src/USD/hgiVk/diagnostic.h",
			"file_size": 1085,
			"file_write_time": 132398944418611875,
			"settings":
			{
				"buffer_size": 1085,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#ifndef PXR_IMAGING_HGIVK_FRAME_H\n#define PXR_IMAGING_HGIVK_FRAME_H\n\n#include <atomic>\n#include <string>\n#include <vector>\n\n#include \"pxr/pxr.h\"\n\n#include \"USD/hgiVk/api.h\"\n#include \"USD/hgiVk/commandBufferManager.h\"\n#include \"USD/hgiVk/garbageCollector.h\"\n#include \"USD/hgiVk/vulkan.h\"\n\n\nPXR_NAMESPACE_OPEN_SCOPE\n\nclass HgiVkDevice;\n\n\n/// \\class HgiVkRenderFrame\n///\n/// A frame is used to let the CPU record a new frame while the GPU is\n/// processing an older frame. This safeguards the data the GPU is consuming,\n/// by introducing some latency between cpu writes and gpu reads.\n///\n/// Deletion of objects must also take care not to delete objects still being\n/// consumed by the GPU. The frame has a 'garbage collector' that handles this.\n///\nclass HgiVkRenderFrame final {\npublic:\n    HgiVkRenderFrame(HgiVkDevice* device);\n    ~HgiVkRenderFrame();\n\n    /// Should be called exactly once at the start of rendering an app frame.\n    HGIVK_API\n    void BeginFrame(uint64_t frame);\n\n    /// Should be called exactly once at the end of rendering an app frame.\n    HGIVK_API\n    void EndFrame();\n\n    /// Returns the garbage collector of the frame.\n    HGIVK_API\n    HgiVkGarbageCollector* GetGarbageCollector();\n\n    /// Returns the command buffer manager of the frame.\n    HGIVK_API\n    HgiVkCommandBufferManager* GetCommandBufferManager();\n\n    /// Set debug name the vulkan objects held by this frame will have.\n    void SetDebugName(std::string const& name);\n\n    /// Returns all time queries recorded in the previous run of the frame.\n    HgiTimeQueryVector const & GetTimeQueries() const;\n\nprivate:\n    HgiVkRenderFrame() = delete;\n    HgiVkRenderFrame & operator=(const HgiVkRenderFrame&) = delete;\n    HgiVkRenderFrame(const HgiVkRenderFrame&) = delete;\n\nprivate:\n    HgiVkDevice* _device;\n\n    // Thread-safe managing of one frame's command buffers.\n    HgiVkCommandBufferManager _commandBufferManager;\n\n    // This fence is used to make sure the cpu does not re-use the command\n    // buffers until the gpu has finished consuming them.\n    VkFence _vkFence;\n\n    // Expired objects (deferred deleted when no longer used by gpu)\n    HgiVkGarbageCollector _garbageCollector;\n};\n\ntypedef std::vector<HgiVkRenderFrame*> HgiVkRenderFrameVector;\n\n\nPXR_NAMESPACE_CLOSE_SCOPE\n\n#endif\n",
			"file": "src/USD/hgiVk/frame.h",
			"file_size": 2289,
			"file_write_time": 132398944594283498,
			"settings":
			{
				"buffer_size": 2289,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#ifndef PXR_IMAGING_HGIVK_GARBAGE_COLLECTOR_H\n#define PXR_IMAGING_HGIVK_GARBAGE_COLLECTOR_H\n\n#include <atomic>\n#include <vector>\n\n#include \"pxr/pxr.h\"\n\n#include \"USD/hgiVk/api.h\"\n#include \"USD/hgiVk/object.h\"\n\nPXR_NAMESPACE_OPEN_SCOPE\n\n\n/// \\class HgiVkGarbageCollector\n///\n/// Destroys vulkan objects.\n///\nclass HgiVkGarbageCollector final\n{\npublic:\n    HGIVK_API\n    HgiVkGarbageCollector();\n\n    HGIVK_API\n    virtual ~HgiVkGarbageCollector();\n\n    /// Schedule deletion of a vulkan object.\n    /// Deletion of all objects must happen via this method since we can have\n    /// multiple frames of cmd buffers in-flight and deletion of the object must\n    /// wait until no cmd buffers are using the object anymore.\n    /// For this reason, vulkan object deletion (and GPU memory release) may be\n    /// delayed by several frames.\n    HGIVK_API\n    void ScheduleObjectDestruction(HgiVkObject const& object);\n\n    /// Destroys objects that were scheduled for destruction.\n    /// This should be called once on the oldest render frame.\n    HGIVK_API\n    void DestroyGarbage(uint64_t frame);\n\nprivate:\n    HgiVkGarbageCollector & operator=(const HgiVkGarbageCollector&) = delete;\n    HgiVkGarbageCollector(const HgiVkGarbageCollector&) = delete;\n\n    typedef std::vector<HgiVkObject> VkObjectVector;\n    typedef std::vector<VkObjectVector> VkObjectThreadLocalVector;\n\n    // Per-thread vectors of objects to be deleted in the future.\n    std::atomic<uint16_t> _numUsedExpired;\n    VkObjectThreadLocalVector _expiredVulkanObjects;\n\n    // Frame information\n    uint64_t _frame;\n    bool _frameStarted;\n};\n\nPXR_NAMESPACE_CLOSE_SCOPE\n\n#endif\n",
			"file": "src/USD/hgiVk/garbageCollector.h",
			"file_size": 1637,
			"file_write_time": 132398944651800796,
			"settings":
			{
				"buffer_size": 1637,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#ifndef PXR_IMAGING_HGIVK_GRAPHICS_ENCODER_H\n#define PXR_IMAGING_HGIVK_GRAPHICS_ENCODER_H\n\n#include <cstdint>\n\n#include \"pxr/pxr.h\"\n#include \"pxr/base/gf/vec4i.h\"\n\n#include \"pxr/imaging/hgi/graphicsEncoder.h\"\n#include \"pxr/imaging/hgi/pipeline.h\"\n#include \"pxr/imaging/hgi/resourceBindings.h\"\n\n#include \"USD/hgiVk/api.h\"\n\nPXR_NAMESPACE_OPEN_SCOPE\n\nclass HgiVkCommandBuffer;\nclass HgiVkDevice;\nclass HgiVkRenderPass;\nstruct HgiGraphicsEncoderDesc;\n\n\n/// \\class HgiVkGraphicsEncoder\n///\n/// Vulkan implementation of HgiGraphicsEncoder.\n///\nclass HgiVkGraphicsEncoder final : public HgiGraphicsEncoder\n{\npublic:\n    /// Constructor for recording in primary command buffer\n    HGIVK_API\n    HgiVkGraphicsEncoder(\n        HgiVkDevice* device,\n        HgiVkCommandBuffer* cb,\n        HgiGraphicsEncoderDesc const& desc);\n\n    /// Constructor for parallel recording into secondary command buffer\n    HGIVK_API\n    HgiVkGraphicsEncoder(\n        HgiVkDevice* device,\n        HgiVkCommandBuffer* cb,\n        HgiVkRenderPass* renderPass);\n\n    HGIVK_API\n    virtual ~HgiVkGraphicsEncoder();\n\n    HGIVK_API\n    void EndEncoding() override;\n\n    HGIVK_API\n    void SetViewport(GfVec4i const& vp) override;\n\n    HGIVK_API\n    void SetScissor(GfVec4i const& sc) override;\n\n    HGIVK_API\n    void BindPipeline(HgiPipelineHandle pipeline) override;\n\n    HGIVK_API\n    void BindResources(HgiResourceBindingsHandle resources) override;\n\n    HGIVK_API\n    void BindVertexBuffers(HgiBufferHandleVector const& vertexBuffers) override;\n\n    HGIVK_API\n    void SetConstantValues(\n        HgiResourceBindingsHandle resources,\n        HgiShaderStage stages,\n        uint32_t byteOffset,\n        uint32_t byteSize,\n        const void* data) override;\n\n    HGIVK_API\n    void DrawIndexed(\n        HgiBufferHandle const& indexBuffer,\n        uint32_t indexCount,\n        uint32_t indexBufferByteOffset,\n        uint32_t firstIndex,\n        uint32_t vertexOffset,\n        uint32_t instanceCount,\n        uint32_t firstInstance) override;\n\n    HGIVK_API\n    void PushDebugGroup(const char* label) override;\n\n    HGIVK_API\n    void PopDebugGroup() override;\n\n    HGIVK_API\n    void PushTimeQuery(const char* name) override;\n\n    HGIVK_API\n    void PopTimeQuery() override;\n\nprivate:\n    HgiVkGraphicsEncoder() = delete;\n    HgiVkGraphicsEncoder & operator=(const HgiVkGraphicsEncoder&) = delete;\n    HgiVkGraphicsEncoder(const HgiVkGraphicsEncoder&) = delete;\n\nprivate:\n    HgiVkDevice* _device;\n    HgiVkCommandBuffer* _commandBuffer;\n    HgiVkRenderPass* _renderPass;\n    bool _isParallelEncoder;\n    bool _isRecording;\n\n    // Encoder is used only one frame so storing multi-frame state on encoder\n    // will not survive.\n};\n\nPXR_NAMESPACE_CLOSE_SCOPE\n\n#endif\n",
			"file": "src/USD/hgiVk/graphicsEncoder.h",
			"file_size": 2732,
			"file_write_time": 132398944702278442,
			"settings":
			{
				"buffer_size": 2732,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#ifndef PXR_IMAGING_HGIVK_HGIVK_H\n#define PXR_IMAGING_HGIVK_HGIVK_H\n\n#include <atomic>\n#include <vector>\n\n#include \"pxr/pxr.h\"\n#include \"pxr/imaging/hgi/enums.h\"\n#include \"pxr/imaging/hgi/hgi.h\"\n\n#include \"USD/hgiVk/api.h\"\n\n\nPXR_NAMESPACE_OPEN_SCOPE\n\nclass HgiVkInstance;\nclass HgiVkDevice;\nclass HgiVkSurface;\nclass HgiVkSwapchain;\nstruct HgiVkSurfaceDesc;\n\n\ntypedef std::vector<HgiVkDevice*> HgiVkDeviceVector;\ntypedef HgiVkSwapchain* HgiVkSwapchainHandle;\ntypedef HgiVkSurface* HgiVkSurfaceHandle;\n\n\n/// \\class HgiVk\n///\n/// Vulkan implementation of the Hydra Graphics Interface.\n///\nclass HgiVk final : public Hgi\n{\npublic:\n    HGIVK_API\n    HgiVk();\n\n    HGIVK_API\n    ~HgiVk();\n\n    HGIVK_API\n    void EndFrame() override;\n\n    HGIVK_API\n    HgiGraphicsEncoderUniquePtr CreateGraphicsEncoder(\n        HgiGraphicsEncoderDesc const& desc) override;\n\n    HGIVK_API\n    HgiParallelGraphicsEncoderUniquePtr CreateParallelGraphicsEncoder(\n        HgiGraphicsEncoderDesc const& desc,\n        HgiPipelineHandle pipeline,\n        const char* debugName=nullptr) override;\n\n    HGIVK_API\n    HgiBlitEncoderUniquePtr CreateBlitEncoder() override;\n\n    HGIVK_API\n    HgiTextureHandle CreateTexture(HgiTextureDesc const& desc) override;\n\n    HGIVK_API\n    void DestroyTexture(HgiTextureHandle* texHandle) override;\n\n    HGIVK_API\n    HgiBufferHandle CreateBuffer(HgiBufferDesc const& desc) override;\n\n    HGIVK_API\n    void DestroyBuffer(HgiBufferHandle* bufferHandle) override;\n\n    HGIVK_API\n    HgiPipelineHandle CreatePipeline(\n        HgiPipelineDesc const& pipeDesc) override;\n\n    HGIVK_API\n    void DestroyPipeline(HgiPipelineHandle* pipeHandle) override;\n\n    HGIVK_API\n    HgiResourceBindingsHandle CreateResourceBindings(\n        HgiResourceBindingsDesc const& desc) override;\n\n    HGIVK_API\n    void DestroyResourceBindings(\n        HgiResourceBindingsHandle* resHandle) override;\n\n    HGIVK_API\n    HgiShaderFunctionHandle CreateShaderFunction(\n        HgiShaderFunctionDesc const& desc) override;\n\n    HGIVK_API\n    void DestroyShaderFunction(\n        HgiShaderFunctionHandle* shaderFunctionHandle) override;\n\n    HGIVK_API\n    HgiShaderProgramHandle CreateShaderProgram(\n        HgiShaderProgramDesc const& desc) override;\n\n    HGIVK_API\n    void DestroyShaderProgram(\n        HgiShaderProgramHandle* shaderProgramHandle) override;\n\n    HGIVK_API\n    void GetMemoryInfo(size_t* used, size_t* unused) override;\n\n    HGIVK_API\n    HgiTimeQueryVector const& GetTimeQueries() override;\n\n    HGIVK_API\n    HgiDeviceFeatures const& GetDeviceFeatures() override;\n\npublic:\n\n    // Returns the Hgi vulkan instance.\n    HGIVK_API\n    HgiVkInstance* GetVulkanInstance() const;\n\n    // Returns the vkInstace as void pointer.\n    // This makes it a little easier to pass the vkInstance around without\n    // having to deal with vulkan headers everywhere that includes hgi.\n    HGIVK_API\n    void* GetVkInstance();\n\n    // Returns the primary device. This device must support presentation and\n    // resource creation.\n    HGIVK_API\n    HgiVkDevice* GetPrimaryDevice() const;\n\n    /// Create a new surface\n    HGIVK_API\n    HgiVkSurfaceHandle CreateSurface(HgiVkSurfaceDesc const& desc);\n\n    /// Destroy a surface\n    HGIVK_API\n    void DestroySurface(HgiVkSurfaceHandle* surfaceHandle);\n\n    /// Create a new swapcain\n    HGIVK_API\n    HgiVkSwapchainHandle CreateSwapchain(HgiVkSurfaceHandle surfaceHandle);\n\n    /// Destroy a swapcain\n    HGIVK_API\n    void DestroySwapchain(HgiVkSwapchainHandle* swapchainHandle);\n\n    /// Destroys all devices and vulkan instance.\n    /// Should be called once during application shutdown.\n    HGIVK_API\n    void DestroyHgiVk();\n\n    /// Returns the max number of threads we expect to run.\n    HGIVK_API\n    static uint32_t GetThreadCount();\n\nprivate:\n    HgiVk & operator=(const HgiVk&) = delete;\n    HgiVk(const HgiVk&) = delete;\n\n    // Begin a new frame of rendering.\n    // This call is managed internally. See EndFrame definition for details.\n    void _BeginFrame();\n\nprivate:\n    HgiVkInstance* _instance;\n    HgiVkDeviceVector _devices;\n    bool _frameStarted;\n};\n\n\n// Global / static access to Vulkan Hydra graphics interface.\n// Multiple plugins want to use the same HgiVkDevice, so that resources are\n// shared (e.g. UI wants to display images produced by renderer)\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n    HGIVK_API\n    HgiVk* HgiVkGetHydraGraphicsInterface();\n#ifdef __cplusplus\n}\n#endif\n\n\nPXR_NAMESPACE_CLOSE_SCOPE\n\n#endif\n",
			"file": "src/USD/hgiVk/hgi.h",
			"file_size": 4470,
			"file_write_time": 132398944769235343,
			"settings":
			{
				"buffer_size": 4470,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#ifndef PXR_IMAGING_HGIVK_INSTANCE_H\n#define PXR_IMAGING_HGIVK_INSTANCE_H\n\n#include \"pxr/pxr.h\"\n\n#include \"USD/hgiVk/api.h\"\n#include \"USD/hgiVk/vulkan.h\"\n\nPXR_NAMESPACE_OPEN_SCOPE\n\n\nclass HgiVkInstance final {\npublic:\n    HGIVK_API\n    HgiVkInstance();\n\n    HGIVK_API\n    virtual ~HgiVkInstance();\n\n    /// Returns the vulkan instance.\n    HGIVK_API\n    VkInstance GetVulkanInstance() const;\n\npublic:\n    // Extra vulkan function pointers\n    VkDebugReportCallbackEXT vkDebugCallback;\n    PFN_vkCreateDebugReportCallbackEXT vkCreateDebugCallbackEXT;\n    PFN_vkDestroyDebugReportCallbackEXT vkDestroyDebugCallbackEXT;\n\nprivate:\n    VkInstance _vkInstance;\n};\n\n\nPXR_NAMESPACE_CLOSE_SCOPE\n\n#endif",
			"file": "src/USD/hgiVk/instance.h",
			"file_size": 693,
			"file_write_time": 132398944830032552,
			"settings":
			{
				"buffer_size": 693,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#ifndef PXR_IMAGING_HGIVK_PARALLEL_GRAPHICS_ENCODER_H\n#define PXR_IMAGING_HGIVK_PARALLEL_GRAPHICS_ENCODER_H\n\n#include <atomic>\n#include <cstdint>\n\n#include \"pxr/pxr.h\"\n#include \"pxr/imaging/hgi/parallelGraphicsEncoder.h\"\n#include \"pxr/imaging/hgi/graphicsEncoder.h\"\n\n#include \"USD/hgiVk/api.h\"\n\nPXR_NAMESPACE_OPEN_SCOPE\n\nclass HgiVkCommandBuffer;\nclass HgiVkDevice;\nclass HgiVkRenderPass;\nstruct HgiGraphicsEncoderDesc;\n\n\n/// \\class HgiVkParallelGraphicsEncoder\n///\n/// Vulkan implementation of HgiParallelGraphicsEncoder.\n///\nclass HgiVkParallelGraphicsEncoder final : public HgiParallelGraphicsEncoder\n{\npublic:\n    HGIVK_API\n    HgiVkParallelGraphicsEncoder(\n        const char* debugName,\n        HgiVkDevice* device,\n        HgiVkCommandBuffer* primaryCB,\n        HgiGraphicsEncoderDesc const& desc,\n        HgiPipelineHandle pipeline);\n\n    HGIVK_API\n    virtual ~HgiVkParallelGraphicsEncoder();\n\n    HGIVK_API\n    HgiGraphicsEncoderUniquePtr CreateGraphicsEncoder() override;\n\n    HGIVK_API\n    void EndEncoding() override;\n\nprivate:\n    HgiVkParallelGraphicsEncoder() = delete;\n    HgiVkParallelGraphicsEncoder & operator=(\n        const HgiVkParallelGraphicsEncoder&) = delete;\n    HgiVkParallelGraphicsEncoder(\n        const HgiVkParallelGraphicsEncoder&) = delete;\n\nprivate:\n    HgiVkDevice* _device;\n    HgiVkCommandBuffer* _primaryCommandBuffer;\n    HgiVkRenderPass* _renderPass;\n    bool _isRecording;\n    bool _isDebugging;\n    size_t _cmdBufBlockId;\n\n    // Encoder is used only one frame so storing multi-frame state on encoder\n    // will not survive.\n};\n\nPXR_NAMESPACE_CLOSE_SCOPE\n\n#endif\n",
			"file": "src/USD/hgiVk/parallelGraphicsEncoder.h",
			"file_size": 1608,
			"file_write_time": 132398944893229674,
			"settings":
			{
				"buffer_size": 1608,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/MogwaiSettings.h",
			"settings":
			{
				"buffer_size": 2575,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/MogwaiSettings.cpp",
			"settings":
			{
				"buffer_size": 10806,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/MogwaiScripting.cpp",
			"settings":
			{
				"buffer_size": 6767,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Shader.h",
			"settings":
			{
				"buffer_size": 8437,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Sampler.h",
			"settings":
			{
				"buffer_size": 7871,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Sampler.cpp",
			"settings":
			{
				"buffer_size": 3887,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKShader.cpp",
			"settings":
			{
				"buffer_size": 2775,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/stdafx.h",
			"settings":
			{
				"buffer_size": 1831,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/CopyContext.cpp",
			"settings":
			{
				"buffer_size": 6896,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/VAO.cpp",
			"settings":
			{
				"buffer_size": 3603,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKBuffer.cpp",
			"settings":
			{
				"buffer_size": 6579,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/ComputeContext.cpp",
			"settings":
			{
				"buffer_size": 3000,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/D3D12/D3D12ComputeContext.cpp",
			"settings":
			{
				"buffer_size": 6740,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/D3D12/D3D12LowLevelContextData.cpp",
			"settings":
			{
				"buffer_size": 4664,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKLowLevelContextData.cpp",
			"settings":
			{
				"buffer_size": 5608,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/FencedPool.h",
			"settings":
			{
				"buffer_size": 4321,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKComputeContext.cpp",
			"settings":
			{
				"buffer_size": 8062,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Utils/MathHelpersTests.cpp",
			"settings":
			{
				"buffer_size": 12262,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKRenderContext.cpp",
			"settings":
			{
				"buffer_size": 16727,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/BasePasses/RasterPass.cpp",
			"settings":
			{
				"buffer_size": 3029,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/BasePasses/RasterPass.h",
			"settings":
			{
				"buffer_size": 4410,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKResourceViews.cpp",
			"settings":
			{
				"buffer_size": 13407,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 3482,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/max/Desktop/gbuffer.py",
			"settings":
			{
				"buffer_size": 574,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/GBuffer/GBufferParams.slang",
			"settings":
			{
				"buffer_size": 2388,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Threading.cpp",
			"settings":
			{
				"buffer_size": 2799,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/TermColor.cpp",
			"settings":
			{
				"buffer_size": 3484,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/TermColor.h",
			"settings":
			{
				"buffer_size": 2499,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Threading.h",
			"settings":
			{
				"buffer_size": 3003,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "/***************************************************************************\n # Copyright (c) 2020, NVIDIA CORPORATION. All rights reserved.\n #\n # Redistribution and use in source and binary forms, with or without\n # modification, are permitted provided that the following conditions\n # are met:\n #  * Redistributions of source code must retain the above copyright\n #    notice, this list of conditions and the following disclaimer.\n #  * Redistributions in binary form must reproduce the above copyright\n #    notice, this list of conditions and the following disclaimer in the\n #    documentation and/or other materials provided with the distribution.\n #  * Neither the name of NVIDIA CORPORATION nor the names of its\n #    contributors may be used to endorse or promote products derived\n #    from this software without specific prior written permission.\n #\n # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY\n # EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n # IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n # PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n # CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n # EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n # PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n # PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n **************************************************************************/\n#include \"Utils/Math/MathConstants.slangh\"\n#include \"Scene/Material/MaterialDefines.slangh\"\n\nimport Scene.Scene;\nimport Scene.TextureSampler;\nimport Experimental.Scene.Material.MaterialShading;\nimport Experimental.Scene.Lights.EnvProbe;\nimport Utils.Sampling.SampleGenerator;\nimport Utils.Debug.PixelDebug;\nimport Utils.Math.BitTricks;\nimport Utils.Math.MathHelpers;\nimport BSDFViewerParams;\n\ncbuffer PerFrameCB\n{\n    BSDFViewerParams gParams;\n    EnvProbe gEnvProbe;\n}\n\nRWTexture2D<float4> gOutput;\nRWStructuredBuffer<PixelData> gPixelData;\n\nstatic const float3 kGroundPlaneColor = float3(0.05f);\n\nstruct SurfaceData\n{\n    ShadingData sd;\n\n    // Additional fields we want to inspect that are not part of Falcor's ShadingData.\n    float3 baseColor;\n    float3 wi;\n};\n\n\n/** Get normalized viewport coordinate.\n    The viewport is centered on the image with square aspect and height 1.0. The y-axis points down.\n    TODO: Change to a more standard definition.\n    \\return Viewport coordinate.\n*/\nfloat2 getViewportCoord(uint2 pixel)\n{\n    float2 p = pixel + float2(0.5f);\n    return (p - gParams.viewportOffset) * gParams.viewportScale;\n}\n\n/** Setup geometric frame of reference for BRDF slice.\n    \\param[in] uv Viewport coordinate in [0,1].\n    \\param[out] v Interpolated attributes for the point on the sphere.\n    \\param[out] viewDir View direction.\n    \\return Normalized incident direction (light vector).\n*/\nfloat3 calculateSliceGeometry(float2 uv, out VertexData v, out float3 viewDir)\n{\n    // Setup local surface frame as T,B,N (right-handed).\n    v.posW = float3(0, 0, 0);\n    v.normalW = float3(0, 0, 1);\n    v.bitangentW = float3(0, 1, 0);\n    v.texC = gParams.texCoords;\n    v.faceNormalW = v.normalW;\n\n    // Compute dot products.\n    // These are based on the axes in the 2D slice (theta_h, theta_d) with origin in lower-left corner.\n    // This is the same format as the slices in Burley et al. 2012, 2015.\n    float theta_h = uv.x * (M_PI / 2);\n    float theta_d = (1.f - uv.y) * (M_PI / 2);\n\n    float NdotH = cos(theta_h);\n    float HdotL = cos(theta_d);     // Note: HdotL = HdotV\n\n    // Place the H vector at (0,0,1) to start.\n    // Compute L, V that are mirrored about the yz-plane.\n    float3 L = float3(sqrt(1.f - HdotL * HdotL), 0, HdotL);\n    float3 V = float3(-L.x, 0.f, L.z);\n\n    // Rotate L, V about the x-axis by an angle theta_h.\n    float cos_h = NdotH;\n    float sin_h = sqrt(1 - NdotH * NdotH);\n    L = float3(L.x, cos_h * L.y - sin_h * L.z, sin_h * L.y + cos_h * L.z);\n    V = float3(V.x, cos_h * V.y - sin_h * V.z, sin_h * V.y + cos_h * V.z);\n\n    // Return vectors.\n    viewDir = V;\n    return normalize(L);\n}\n\n/** Ray-sphere intersection.\n    This function implements the standard analytic test and returns the closest hit.\n    \\param[in] rayOrigin Ray origin.\n    \\param[in] rayDir Ray direction (does not have to be normalized).\n    \\param[in] center Sphere center.\n    \\param[in] radius Sphere radius.\n    \\param[in] intersectionPos Position on the sphere for the closest intersection (if any).\n    \\return True if the ray intersects the sphere.\n*/\nbool raySphereIntersection(float3 rayOrigin, float3 rayDir, float3 center, float radius, out float3 intersectionPos)\n{\n    // The sphere equation is ||P-C||^2 = r^2 and the ray P = A+tB.\n    // Solve for minimum positive t to find the closest intersection.\n    float3 oc = rayOrigin - center;\n    float a = dot(rayDir, rayDir); // = 1.0 if direction is normalized\n    float b = 2.f * dot(rayDir, oc);\n    float c = dot(oc, oc) - radius * radius;\n    float discriminant = b * b - 4.f * a * c;\n\n    // Negative discriminant means ray missed sphere.\n    if (discriminant < 0.f) return false;\n\n    // There are two solutions t0 and t1, but one or both may be negative.\n    float t0 = -b - sqrt(discriminant);\n    float t1 = -b + sqrt(discriminant);\n    float tc = t0 < 0.f ? t1 : t0; // tc is the closest hit we care about\n    if (tc < 0.f) return false;\n\n    float t = tc / (2.f * a);\n    intersectionPos = rayOrigin + t * rayDir;\n    return true;\n}\n\n/** Calculate sphere geometry for the given viewport coordinate.\n    \\param[in] uv Viewport coordinate in [0,1].\n    \\param[out] v Interpolated attributes for the point on the sphere (if hit).\n    \\param[out] rayDir Ray direction for the camera ray (normalized).\n    \\return True if we're on the sphere.\n*/\nbool calculateSphereGeometry(float2 uv, out VertexData v, out float3 rayDir)\n{\n    const float2 ndc = float2(2.f * uv.x - 1.f, -2.f * uv.y + 1.f);\n\n    if (gParams.orthographicCamera)\n    {\n        // Calculate intersection with the unit sphere.\n        // The orthographic camera's viewport is +-1 units vertically so the sphere fits exactly.\n        float3 p = float3(ndc, 0);\n        float d = 1.f - p.x * p.x - p.y * p.y;\n        rayDir = float3(0, 0, -1);\n\n        if (d < 0.f) return false;\n        p.z = sqrt(d);\n        v.posW = p;\n    }\n    else // Projective camera\n    {\n        // Setup camera ray and calculate ray-sphere intersection.\n        float3 origin = { 0, 0, gParams.cameraDistance };\n        float3 target = float3(ndc * gParams.cameraViewportScale, 0);\n        rayDir = normalize(target - origin);\n\n        float3 p;\n        if (!raySphereIntersection(origin, rayDir, float3(0), 1.f, p)) return false;\n        v.posW = p;\n    }\n\n    // Setup surface attributes for the unit sphere.\n    v.normalW = v.posW;\n    v.bitangentW = perp_stark(v.normalW); // Make up a bitangent\n    v.faceNormalW = v.normalW;\n\n    if (gParams.useFixedTexCoords)\n    {\n        v.texC = gParams.texCoords;\n    }\n    else\n    {\n        // Compute texture coords using cylindrical mapping of the visible hemisphere.\n        // We place u=0 on the left side and and u=1 on the right, and v=0 at the bottom and v=1 at the top.\n        float3 p = v.posW;\n        float texU = atan2(p.z, -p.x) / M_PI;\n        float texV = acos(-p.y) / M_PI;\n        v.texC = float2(texU, texV);\n    }\n\n    return true;\n}\n\n/** Prepare SurfaceData struct with material parameters.\n    All unused fields are initialized to their default values.\n*/\nSurfaceData prepareMaterial(VertexData v, float3 viewDir)\n{\n    SurfaceData data = {};\n\n    if (gParams.useSceneMaterial)\n    {\n        // Setup Falcor's ShadingData based on scene material.\n        ExplicitLodTextureSampler lod = { 0.f };\n        data.sd = _prepareShadingData(v, gParams.materialID, gScene.materials[gParams.materialID], gScene.materialResources[gParams.materialID], viewDir, lod, gParams.useNormalMapping);\n\n        // Setup additional fields not currently available in ShadingData.\n        MaterialData md = gScene.getMaterial(gParams.materialID);\n        MaterialResources mr = gScene.materialResources[gParams.materialID];\n        data.baseColor = sampleTexture(mr.baseColor, mr.samplerState, v.texC, md.baseColor, EXTRACT_DIFFUSE_TYPE(md.flags), lod).rgb;\n    }\n    else\n    {\n        ShadingData sd = {};\n\n        // Set geometric parameters.\n        sd.posW = v.posW;\n        sd.uv = v.texC;\n        sd.V = normalize(viewDir);\n        sd.N = normalize(v.normalW);\n        sd.B = normalize(v.bitangentW - sd.N * (dot(v.bitangentW, sd.N)));\n        sd.T = normalize(cross(sd.B, sd.N));\n        sd.NdotV = dot(sd.N, sd.V);\n        sd.faceN = v.faceNormalW;\n        sd.frontFacing = dot(sd.V, sd.faceN) >= 0.f;\n        sd.doubleSided = false;\n\n        // Set material parameters.\n        // Calculate the specular reflectance for dielectrics from the IoR.\n        sd.IoR = gParams.IoR;\n        float f = (sd.IoR - 1.f) / (sd.IoR + 1.f);\n        float F0 = f * f;\n        sd.diffuse = lerp(gParams.baseColor.rgb, float3(0), gParams.metallic);\n        sd.specular = lerp(float3(F0), gParams.baseColor.rgb, gParams.metallic);\n        sd.linearRoughness = gParams.linearRoughness;\n        sd.ggxAlpha = sd.linearRoughness * sd.linearRoughness;\n        sd.metallic = gParams.metallic;\n\n        // Unused\n        sd.opacity = 1;\n        sd.occlusion = 1;\n\n        // Store outputs\n        data.sd = sd;\n        data.baseColor = gParams.baseColor;\n    }\n\n    return data;\n}\n\n/** Returns the color to use for background pixels.\n    \\param[in] uv Viewport coordinates.\n    \\param[in] dir Normalized ray direction.\n*/\nfloat3 evalBackground(float2 uv, float3 dir)\n{\n    if (gParams.useGroundPlane)\n    {\n        bool hitGround = gParams.orthographicCamera ? (uv.y >= 0.5f) : (dir.y < 0.f);\n        if (hitGround) return kGroundPlaneColor;\n    }\n    if (gParams.useDirectionalLight) return float3(0);\n\n    float3 L = gParams.useEnvMap ? evalEnvProbe(gEnvProbe, dir) : gParams.lightColor;\n    return L * gParams.lightIntensity;\n}\n\n/** Evaluates the incident lighting from a given direction.\n    If directional lighting is enabled, it can be assumed 'dir' is light's direction.\n*/\nfloat3 evalLighting(float3 dir)\n{\n    if (gParams.useGroundPlane && dir.y < 0.f)\n    {\n        return float3(0.f);\n    }\n\n    float3 L = gParams.useEnvMap ? evalEnvProbe(gEnvProbe, dir) : gParams.lightColor;\n    return L * gParams.lightIntensity;\n}\n\n/** Returns the BSDF lobe mask for the currently enabled lobes.\n*/\nuint getActiveLobes()\n{\n    uint lobes = 0;\n    if (gParams.enableDiffuse) lobes |= (uint)LobeType::DiffuseReflection;\n    if (gParams.enableSpecular) lobes |= (uint)LobeType::SpecularReflection;\n    // TODO: Viewer doesn't support transmission lobes yet\n    return lobes;\n}\n\n/** Evaluates the BSDF slice for a given viewport coordinate.\n    \\return Evaluated BSDF value.\n*/\nfloat3 evalBSDFSlice(float2 uv, inout SurfaceData data)\n{\n    // Calculate geometry and incident/outgoing directions.\n    VertexData v;\n    float3 viewDir;\n    float3 lightDir = calculateSliceGeometry(uv, v, viewDir);\n\n    // Setup shading data based on the current material.\n    data = prepareMaterial(v, viewDir);\n    data.wi = lightDir;\n\n    // Evaluate BRDF at this point.\n    float3 f = evalBSDFCosine(data.sd, data.wi, getActiveLobes());\n\n    // Remove cosine term if it's disabled in the viewer.\n    if (!gParams.applyNdotL)\n    {\n        float NdotL = dot(data.sd.N, data.wi);\n        f = NdotL > 0.f ? f / NdotL : float3(0);\n    }\n\n    return f;\n}\n\n/** Samples the BSDF to evaluate incident illumination.\n    This is done differently depending on the configuration.\n    \\param[in] sd Shading point data.\n    \\param[in] sg Sample generator.\n    \\param[out] s Generated sample. Only valid if true is returned.\n    \\return True if a sample was generated, false otherwise.\n*/\nbool generateBSDFSample(const ShadingData sd, inout SampleGenerator sg, out BSDFSample s)\n{\n    if (gParams.useDirectionalLight)\n    {\n        // With directional light, disable BSDF sampling and just return a sample in the light's direction.\n        s.wi = -normalize(gParams.lightDir);\n        s.weight = evalBSDFCosine(sd, s.wi);\n        s.pdf = 1.f;\n        return dot(sd.N, s.wi) > 0.f;\n    }\n    else\n    {\n        if (gParams.useBrdfSampling) return sampleBSDF(sd, sg, s);\n        else return sampleBSDF_Reference(sd, sg, s);\n    }\n}\n\n/** Evaluates the lit sphere for a given viewport coordinate.\n    The viewport shows an analytic sphere of the specified material at infinite distance.\n    When each pixel is evaluated using a random light direction and omnidirectional white light,\n    the result converges to the total reflectance (integral of BSDF times the dot(N,L) factor.\n    \\return Outgoing radiance value.\n*/\nfloat3 evalSphere(float2 uv, inout SurfaceData data, inout SampleGenerator sg)\n{\n    // Calculate the local surface frame.\n    VertexData v;\n    float3 rayDir;\n    if (!calculateSphereGeometry(uv, v, rayDir)) return evalBackground(uv, rayDir);\n\n    // Setup shading data based on the current material.\n    data = prepareMaterial(v, -rayDir);\n\n    float3 output = 0;\n    \n    BSDFSample s = {};\n    \n    if (generateBSDFSample(data.sd, sg, s)) {\n        data.wi = s.wi;\n        float3 L = evalLighting(s.wi);\n\n        // Use computed pdf explicitly (for debugging).\n        if (gParams.usePdf) {\n            output = L * evalBSDFCosine(data.sd, s.wi) / s.pdf;\n        } else {\n            output = L * s.weight;\n        }\n    }\n\n    return output;\n}\n\n/** BSDF viewer pass entry point.\n*/\n[numthreads(16, 16, 1)]\nvoid main(uint3 dispatchThreadID : SV_DispatchThreadID)\n{\n    const uint2 pixel = dispatchThreadID.xy;\n    if (any(pixel >= gParams.frameDim)) return;\n\n    printSetPixel(pixel);\n\n    SurfaceData data = {};\n    float3 output = 0;\n    float2 uv = getViewportCoord(pixel);\n\n    if (gParams.sliceViewer)\n    {\n        if (all(uv >= 0.f && uv < 1.f))\n        {\n            output = evalBSDFSlice(uv, data);\n        }\n    }\n    else\n    {\n        // Create pseudorandom number generator.\n        SampleGenerator sg = SampleGenerator.create(pixel, gParams.frameCount);\n        output = evalSphere(uv, data, sg);\n    }\n\n    // DEBUG\n    //if (gParams.debugSwitch0)\n    //{\n    //    if (sd.N.z < 0.f) output = float3(1, 0, 0);\n    //}\n\n    // Write output data.\n    gOutput[pixel] = float4(output, 1);\n\n    if (gParams.readback && all(pixel == gParams.selectedPixel))\n    {\n        PixelData px;\n        px.texC = data.sd.uv;\n        px.baseColor = data.baseColor;\n        px.diffuse = data.sd.diffuse;\n        px.specular = data.sd.specular;\n        px.linearRoughness = data.sd.linearRoughness;\n        px.metallic = data.sd.metallic;\n        px.N = data.sd.N;\n        px.T = data.sd.T;\n        px.B = data.sd.B;\n        px.wo = data.sd.V;\n        px.wi = data.wi;\n        px.output = output;\n        gPixelData[0] = px;\n    }\n}\n",
			"file": "build/bin/Shaders/RenderPasses/BSDFViewer/BSDFViewer.cs.slang",
			"file_size": 15202,
			"file_write_time": 132389801358286917,
			"settings":
			{
				"buffer_size": 15202,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/Utils/Utils.cpp",
			"settings":
			{
				"buffer_size": 2234,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/tools/render-test/cuda/cuda-compute-util.cpp",
			"settings":
			{
				"buffer_size": 53192,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VkSmartHandle.cpp",
			"settings":
			{
				"buffer_size": 6726,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKRootSignature.cpp",
			"settings":
			{
				"buffer_size": 8750,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/ProgramVersion.h",
			"settings":
			{
				"buffer_size": 10447,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/examples/model-viewer/main.cpp",
			"settings":
			{
				"buffer_size": 86920,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/ResourceViews.h",
			"settings":
			{
				"buffer_size": 9621,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/RootSignature.h",
			"settings":
			{
				"buffer_size": 6716,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/RootSignature.cpp",
			"settings":
			{
				"buffer_size": 8993,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKSampler.cpp",
			"settings":
			{
				"buffer_size": 2442,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/tools/gfx/render.h",
			"settings":
			{
				"buffer_size": 28476,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/FalcorVK.h",
			"settings":
			{
				"buffer_size": 5196,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Device.h",
			"settings":
			{
				"buffer_size": 11497,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/GpuMemoryHeap.h",
			"settings":
			{
				"buffer_size": 4090,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/GpuMemoryHeap.cpp",
			"settings":
			{
				"buffer_size": 5126,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKComputeStateObject.cpp",
			"settings":
			{
				"buffer_size": 2823,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKCopyContext.cpp",
			"settings":
			{
				"buffer_size": 22034,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKDescriptorPool.cpp",
			"settings":
			{
				"buffer_size": 5083,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKDescriptorSet.cpp",
			"settings":
			{
				"buffer_size": 7835,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKDevice.h",
			"settings":
			{
				"buffer_size": 3020,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKDeviceManager.cpp",
			"settings":
			{
				"buffer_size": 2844,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/DeviceManager.h",
			"settings":
			{
				"buffer_size": 3635,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKDevice.cpp",
			"settings":
			{
				"buffer_size": 28452,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKGpuFence.cpp",
			"settings":
			{
				"buffer_size": 10228,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKGpuTimer.cpp",
			"settings":
			{
				"buffer_size": 2646,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/D3D12/D3D12GpuFence.cpp",
			"settings":
			{
				"buffer_size": 3766,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/GpuFence.h",
			"settings":
			{
				"buffer_size": 3526,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKSmartHandle.h",
			"settings":
			{
				"buffer_size": 9756,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKState.cpp",
			"settings":
			{
				"buffer_size": 27538,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKTexture.cpp",
			"settings":
			{
				"buffer_size": 7857,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "falcor.sublime-project",
			"settings":
			{
				"buffer_size": 2453,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/vulkan/include/vulkan/vulkan.hpp",
			"settings":
			{
				"buffer_size": 2369181,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/usr/include/vulkan/vulkan.hpp",
			"settings":
			{
				"buffer_size": 4010350,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/vulkan/include/vulkan/vulkan_core.h",
			"settings":
			{
				"buffer_size": 451013,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Math/FalcorMath.h",
			"settings":
			{
				"buffer_size": 8456,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Framework.h",
			"settings":
			{
				"buffer_size": 13061,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/type.h",
			"settings":
			{
				"buffer_size": 6550,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Framework.cpp",
			"settings":
			{
				"buffer_size": 2253,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/CopyContext.h",
			"settings":
			{
				"buffer_size": 7677,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/VertexLayout.cpp",
			"settings":
			{
				"buffer_size": 1862,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/FalcorConfig.h",
			"settings":
			{
				"buffer_size": 2544,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderPassStandardFlags.h",
			"settings":
			{
				"buffer_size": 2479,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Falcor.h",
			"settings":
			{
				"buffer_size": 6959,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Debug/PixelDebug.h",
			"settings":
			{
				"buffer_size": 5769,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Image/Bitmap.h",
			"settings":
			{
				"buffer_size": 6060,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Image/Bitmap.cpp",
			"settings":
			{
				"buffer_size": 21119,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Scripting/ScriptBindings.h",
			"settings":
			{
				"buffer_size": 10279,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/max/Desktop/compos.py",
			"settings":
			{
				"buffer_size": 1267,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Scripting/Console.h",
			"settings":
			{
				"buffer_size": 2101,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Scripting/Scripting.h",
			"settings":
			{
				"buffer_size": 5726,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/DescriptorPool.h",
			"settings":
			{
				"buffer_size": 5596,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/DescriptorPool.cpp",
			"settings":
			{
				"buffer_size": 2683,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/State/GraphicsState.h",
			"settings":
			{
				"buffer_size": 10063,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/State/GraphicsState.cpp",
			"settings":
			{
				"buffer_size": 8458,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/State/ComputeState.cpp",
			"settings":
			{
				"buffer_size": 3405,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/ComputeStateObject.cpp",
			"settings":
			{
				"buffer_size": 2465,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/GpuTimer.cpp",
			"settings":
			{
				"buffer_size": 4479,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/State/ComputeState.h",
			"settings":
			{
				"buffer_size": 3782,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/State/StateGraph.h",
			"settings":
			{
				"buffer_size": 4323,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Raytracing/RtProgram/RtProgram.cpp",
			"settings":
			{
				"buffer_size": 7986,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Raytracing/RtProgram/RtProgram.h",
			"settings":
			{
				"buffer_size": 6561,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/AppData.h",
			"settings":
			{
				"buffer_size": 2896,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Platform/Linux/ProgressBarLinux.cpp",
			"settings":
			{
				"buffer_size": 5059,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/AppData.cpp",
			"settings":
			{
				"buffer_size": 5386,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/Extensions/Capture/CaptureTrigger.h",
			"settings":
			{
				"buffer_size": 3842,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Sample.cpp",
			"settings":
			{
				"buffer_size": 25053,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/VertexLayout.h",
			"settings":
			{
				"buffer_size": 7327,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/DeviceManager.cpp",
			"settings":
			{
				"buffer_size": 5194,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VkQueryHeap.cpp",
			"settings":
			{
				"buffer_size": 2779,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/D3D12/D3D12Device.cpp",
			"settings":
			{
				"buffer_size": 15156,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/DescriptorSet.h",
			"settings":
			{
				"buffer_size": 5856,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/DescriptorSet.cpp",
			"settings":
			{
				"buffer_size": 2618,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/ResourceViews.cpp",
			"settings":
			{
				"buffer_size": 5611,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "Falcor.sln",
			"settings":
			{
				"buffer_size": 19418,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Scene.h",
			"settings":
			{
				"buffer_size": 25118,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderGraphUI.h",
			"settings":
			{
				"buffer_size": 8554,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderGraph.h",
			"settings":
			{
				"buffer_size": 11413,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/ResourceCache.h",
			"settings":
			{
				"buffer_size": 5357,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/BasePasses/RasterScenePass.h",
			"settings":
			{
				"buffer_size": 4425,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Debug/DebugConsole.h",
			"settings":
			{
				"buffer_size": 4292,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/SceneBuilder.h",
			"settings":
			{
				"buffer_size": 11802,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Debug/debug.h",
			"settings":
			{
				"buffer_size": 2463,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "#ifndef __FALCOR_DEBUG_H__"
			}
		},
		{
			"file": "src/Falcor/Core/BufferTypes/ParameterBlock.h",
			"settings":
			{
				"buffer_size": 20403,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Scene.cpp",
			"settings":
			{
				"buffer_size": 49096,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Camera/CameraController.cpp",
			"settings":
			{
				"buffer_size": 9863,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Camera/Camera.cpp",
			"settings":
			{
				"buffer_size": 13365,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/D3D12/D3D12Resource.cpp",
			"settings":
			{
				"buffer_size": 6227,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"Package Control: ",
				"Package Control: Install Package"
			]
		],
		"width": 0.0
	},
	"console":
	{
		"height": 320.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/max/dev/Falcor",
		"/home/max/dev/Falcor/cmake",
		"/home/max/dev/Falcor/contrib",
		"/home/max/dev/Falcor/contrib/houdini",
		"/home/max/dev/Falcor/contrib/houdini/soho",
		"/home/max/dev/Falcor/src",
		"/home/max/dev/Falcor/src/Falcor",
		"/home/max/dev/Falcor/src/Falcor/Core",
		"/home/max/dev/Falcor/src/Falcor/Core/API",
		"/home/max/dev/Falcor/src/Falcor/Utils",
		"/home/max/dev/Falcor/src/Falcor/Utils/Debug",
		"/home/max/dev/Falcor/src/lava_cmd",
		"/home/max/dev/Falcor/src/lava_cmd/bin",
		"/home/max/dev/Falcor/src/lava_lib",
		"/home/max/dev/Falcor/src/lava_lib/_bak",
		"/home/max/dev/Falcor/src/lava_lib/_bak2",
		"/home/max/dev/Falcor/src/lava_lib/readers",
		"/home/max/dev/Falcor/src/lava_utils_lib",
		"/home/max/dev/Falcor/third_party",
		"/home/max/dev/Falcor/third_party/antlr4",
		"/home/max/dev/Falcor/third_party/antlr4/runtime",
		"/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp",
		"/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/cmake",
		"/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime",
		"/home/max/dev/Falcor/third_party/ri_display"
	],
	"file_history":
	[
		"/home/max/dev/Falcor/src/lava_lib/readers/grammar_lsd_old.h",
		"/home/max/dev/Falcor/src/lava_lib/Antlr4Cpp.cmake",
		"/home/max/dev/Falcor/src/lava_lib/loaders/syntax_lsd.h",
		"/home/max/dev/Falcor/src/lava_lib/loaders/renderer_iface_lsd.h",
		"/home/max/dev/Falcor/contrib/houdini/soho/LSDarchive.py",
		"/home/max/dev/Falcor/contrib/houdini/soho/LSDapilavatext.py",
		"/home/max/dev/Falcor/contrib/houdini/soho/LSDlava.py",
		"/home/max/Pictures/Screenshot from 2020-08-27 17-35-02.png",
		"/home/max/dev/Falcor/src/USD/hdLava/context.h",
		"/home/max/dev/Falcor/src/USD/hdLava/config.h",
		"/home/max/dev/Falcor/src/USD/hdLava/config.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKDeviceManager.h",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Engine.h",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Engine.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKGpuFence.cpp",
		"/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Utils/AABB_VKTests.cs.slang",
		"/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Utils/AABB_VKTests.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKFbo.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKTexture.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKState.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKGraphicsStateObject.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKGpuTimer.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/API/GpuTimer.cpp",
		"/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Utils/HalfUtilsTests.cpp",
		"/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Slang/SlangMutatingTests.cpp",
		"/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Slang/WaveOps.cs.slang",
		"/home/max/dev/Falcor/src/Falcor/Scene/SceneBuilder.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/BufferTypes/ParameterBlock.cpp",
		"/home/max/dev/Falcor/src/Falcor/Data/LightProbes/20050806-03_hd.hdr",
		"/home/max/dev/Falcor/build/bin/Data/cube.obj",
		"/home/max/.config/sublime-text-3/Packages/SublimeLinter-gcc/miscellaneous/demo.cpp",
		"/home/max/.config/sublime-text-3/Packages/Package Control/Package Control.sublime-settings",
		"/home/max/Downloads/Telegram Desktop/scene.v001.usda",
		"/home/max/dev/blender/source/blender/draw/engines/eevee/eevee_occlusion_trace.c",
		"/home/max/dev/blender/release/scripts/startup/bl_ui/__init__.py",
		"/home/max/dev/blender/source/blender/draw/engines/eevee/shaders/common_fullscreen_embree_vert.glsl",
		"/home/max/dev/blender/source/blender/draw/engines/eevee/shaders/common_uniforms_embree_lib.glsl",
		"/home/max/dev/blender/source/blender/draw/engines/eevee/eevee_objects_map.h",
		"/home/max/dev/blender/source/blender/blenlib/intern/winstuff_dir.c",
		"/home/max/dev/blender/source/blender/draw/intern/draw_cache_extract.h",
		"/home/max/dev/blender/source/blender/draw/engines/workbench/workbench_engine.c",
		"/home/max/dev/blender/source/blender/draw/DRW_engine_types.h",
		"/home/max/dev/blender/source/blender/blenlib/BLI_hash.h",
		"/home/max/dev/blender/source/blender/blenlib/BLI_index_range.h",
		"/home/max/dev/blender/source/blender/bmesh/intern/bmesh_operators_private.h",
		"/home/max/dev/blender/source/blender/bmesh/intern/bmesh_operators.h",
		"/home/max/dev/blender/source/blender/python/intern/CMakeLists.txt",
		"/home/max/dev/blender/source/blender/blenlib/intern/BLI_ghash_utils.c",
		"/home/max/dev/blender/source/blender/blenlib/intern/BLI_ghash.c",
		"/home/max/dev/blender/source/blender/blenloader/intern/versioning_280.c",
		"/home/max/dev/blender/source/blender/draw/engines/eevee/shaders/ambient_occlusion_trace_lib.glsl",
		"/home/max/dev/bivis/src/blender/addon/ui.py",
		"/home/max/dev/bivis/src/blender/addon/presets.py",
		"/home/max/dev/bivis/src/blender/addon/properties.py",
		"/home/max/dev/bivis/src/blender/addon/osl.py",
		"/home/max/dev/bivis/src/blender/addon/operators.py",
		"/home/max/dev/bivis/src/blender/blender_python.cpp",
		"/home/max/dev/bivis/src/blender/addon/engine.py",
		"/home/max/dev/bivis/src/blender/addon/__init__.py",
		"/home/max/dev/bivis/src/blender/CMakeLists.txt",
		"/home/max/dev/blender/intern/CMakeLists.txt",
		"/home/max/dev/unity/scripts/mesh_smoother.cs",
		"/home/max/dev/unity/scripts/mesh_helper.cs",
		"/home/max/dev/fasta/src/fasta_lib/renderer.h",
		"/home/max/dev/fasta/CMakeLists.txt",
		"/home/max/dev/fasta/third_party/glad/include/KHR/khrplatform.h",
		"/home/max/dev/fasta/third_party/glad/include/glad/glad.h",
		"/home/max/dev/fasta/src/locomotive_lib/logging.h",
		"/home/max/dev/fasta/src/locomotive_lib/CMakeLists.txt",
		"/home/max/dev/fasta/src/locomotive_lib/logging.cpp",
		"/home/max/dev/fasta/src/xenon_lib/XN_RendererIPR.h",
		"/home/max/dev/fasta/src/xenon_py/CMakeLists.txt",
		"/home/max/dev/fasta/src/xenon_lib/XN_Shader.h",
		"/home/max/dev/fasta/src/xenon_lib/CMakeLists.txt",
		"/home/max/dev/fasta/src/xenon_cmd/CMakeLists.txt",
		"/home/max/dev/fasta/src/xenon_lib/XN_Mesh.h",
		"/home/max/dev/fasta/src/xenon_lib/XN_Shader.cpp",
		"/home/max/dev/fasta/src/xenon_lib/XN_GBuffer.cpp",
		"/home/max/dev/fasta/src/xenon_lib/XN_GBuffer.h",
		"/home/max/dev/fasta/src/xenon_lib/XN_Renderer.h",
		"/home/max/dev/fasta/src/xenon_lib/XN_Renderer.cpp",
		"/home/max/dev/fasta/src/xenon_cmd/fsquad.h",
		"/home/max/dev/fasta/src/xenon_cmd/xenon.cpp",
		"/home/max/dev/fasta/src/xenon_lib/XN_RendererIPR.cpp",
		"/home/max/projects/Xenon/xenon.sublime-project",
		"/home/max/projects/Xenon/src/ROP_Xenon.h",
		"/home/max/projects/Xenon/src/ROP_Xenon.cpp",
		"/home/max/projects/Xenon/makefile"
	],
	"find":
	{
		"height": 39.0
	},
	"find_in_files":
	{
		"height": 125.0,
		"where_history":
		[
			"/home/max/dev/Falcor/third_party/antlr4/runtime/Cpp/runtime/src",
			"/home/max/dev/Falcor/",
			"/home/max/dev/Falcor/contrib",
			"/home/max/dev/Falcor/src",
			"/home/max/dev/Falcor/src/Falcor",
			"/opt/USD",
			"/home/max/dev/Falcor/src",
			"/home/max/dev/Falcor/",
			"/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava",
			"/home/max/dev/RadeonProRenderUSD",
			"/home/max/dev/Falcor",
			"/home/max/dev/RadeonProRenderUSD",
			"/home/max/dev/Falcor",
			"/home/max/dev/Falcor/src",
			"/home/max/dev/Falcor/src,/home/max/dev/Falcor/third_party/slang",
			"/home/max/dev/Falcor/src",
			"/home/max/dev/Falcor/src/Falcor",
			"/home/max/dev/Falcor/src/Falcor,/home/max/dev/Falcor/third_party/slang",
			"/home/max/dev/Falcor/src/Falcor",
			"/home/max/dev/Falcor/third_party/slang/source",
			"/home/max/dev/Falcor/src",
			"/home/max/dev/Falcor/third_party/slang",
			"/home/max/dev/Falcor/src",
			"/home/max/dev/Falcor/third_party/slang",
			"/home/max/dev/Falcor/src",
			"/home/max/dev/Falcor/Build",
			"/home/max/dev/Falcor/",
			"/home/max/dev/Falcor/src/",
			"/home/max/dev/Falcor/src/Mogwai",
			"/home/max/dev/Falcor/src/Falcor",
			"/home/max/dev/Falcor/",
			"/home/max/dev/Falcor/src/Falcor",
			"/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan",
			"/home/max/dev/Falcor/src",
			"/home/max/dev/Falcor/src/Falcor",
			"/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan",
			"/home/max/dev/Falcor"
		]
	},
	"find_state":
	{
		"case_sensitive": true,
		"find_history":
		[
			"build",
			"addParseListener",
			"getText",
			"context",
			"ctx",
			"IFD",
			"ExternalProject_Add_Step",
			"ray_",
			"lv_samples",
			"lv_samplesx",
			"vm_samples",
			"samples",
			"lv_samples",
			"vm_",
			"vm_picture",
			"vm_device",
			"vm_display",
			"ri_",
			"ri_device",
			"Unable to find:",
			"LSDapilavatext",
			"RIB",
			"IFD",
			"ray_",
			"IFD",
			"ray_",
			"IFD",
			"ray_",
			"IFD",
			"ray_",
			"IFD",
			"ray_",
			"outputCamera",
			"ray_",
			"ray_geometry",
			"ROP_Xenon",
			"Xenon",
			"fasta",
			"Render",
			"_Execute",
			"HdLavaRenderBuffer",
			"PYBIND11_EMBEDDED_MODULE",
			"pybind11::module",
			"pybind11",
			"initialize_interpreter",
			"Can't add new modules after the interpreter has been initialized",
			"Scripting::start",
			"Can't add new modules after the interpreter has been initialized",
			"GetNumActivePixels",
			"m_delegate",
			"m_rprContext",
			"CONTEXT",
			"RPR",
			"RPR_CONTEXT_LAST_ERROR_MESSAGE",
			"RPR",
			"RPR_SUCCESS",
			"RPR",
			"rpr_aov",
			"Aov",
			"class Aov",
			"enum Aov",
			"Rpr",
			"RPR",
			"Rpr",
			"RPR",
			"HdRpr",
			"LavaRenderSettingsTokens",
			"HdRpr",
			"HDRPR",
			"HdRpr",
			"GetRenderSettingDescriptors",
			"config.h",
			"HdOSPRay",
			"HdRpr",
			"HDRPR",
			"HdRpr",
			"HDRPR",
			"HdRpr",
			"copyHeaderForBuild",
			"HDRPR",
			"HdRpr",
			"HDRPR",
			"HdRpr",
			"HDRPR",
			"HdRpr",
			"OSPRay",
			"_sceneVersion",
			"_modelVersion",
			"_sceneVersion",
			"_renderer",
			"opp::Renderer",
			"OSPRay",
			"OSPRAY",
			"OSPRay",
			"OSPRAY",
			"HDOSPRAY",
			"_sceneVersion",
			"_sce",
			"_settingDescriptors",
			"_lastCommittedModelVersion",
			"_renderParam",
			"mRenderParam",
			"OSPRAY",
			"OSPRay",
			"OSPRAY",
			"OSPRay",
			"IRenderer",
			"onFrameRender",
			"executeActiveGraph",
			"updateGraph",
			"compile",
			"getPasses",
			"GraphicsVars::create",
			"ProgramVars(",
			"getDefaultParameterBlock",
			"setDefaultParameterBlock",
			"mpDefaultBlock",
			"ParameterBlock(",
			"ParameterBlock::create",
			"mGraphs",
			"gpFramework",
			"debugReportCallback",
			"singleton",
			"staticFunc_",
			"PYBIND11_MODULE",
			"loadRenderPassLibrary",
			"Device uid",
			"smartDevicePtr"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"ctx",
			"context",
			"LSD",
			"cmd_",
			"lv_",
			"li_",
			"LSD",
			"cmd_",
			"LSD",
			"cmd_",
			"LSD",
			"cmd_",
			"LSD",
			"cmd_",
			"LSD",
			"cmd_",
			"ROP_Lava",
			"Lava",
			"lava",
			"mRenderer",
			"RENDERER",
			"LAVA",
			"Lava",
			"LAVA",
			"Lava",
			"LAVA",
			"HdLava",
			"HDLAVA",
			"HdLava",
			"HDLAVA",
			"HdLava",
			"HDLAVA",
			"HdLava",
			"HDLAVA",
			"HdLava",
			"HDLAVA",
			"HdLava",
			"HDLAVA",
			"HdLava",
			"Lava",
			"mSceneVersion",
			"mModelVersion",
			"mSceneVersion",
			"mRenderer",
			"Falcor::LavaRenderer",
			"Lava",
			"LAVA",
			"Lava",
			"LAVA",
			"mSceneVersion",
			"mSettingDescriptors",
			"mLastCommittedModelVersion",
			"mRenderParam",
			"LAVA",
			"Lava",
			"LAVA",
			"Lava",
			"mpDevice",
			"kPassTempLibSuffix",
			"PROJECT_DIR",
			"spData"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 245,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "src/Falcor/Core/API/D3D12/D3D12ResourceViews.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 18914,
						"regions":
						{
						},
						"selection":
						[
							[
								11151,
								11151
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4150.0,
						"zoom_level": 1.0
					},
					"stack_index": 118,
					"type": "text"
				},
				{
					"buffer": 1,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 75186,
						"regions":
						{
							"match":
							{
								"flags": 112,
								"regions":
								[
									[
										298,
										314
									],
									[
										572,
										588
									],
									[
										613,
										629
									],
									[
										751,
										767
									],
									[
										1336,
										1358
									],
									[
										1865,
										1873
									],
									[
										2131,
										2139
									],
									[
										2443,
										2451
									],
									[
										2782,
										2790
									],
									[
										3145,
										3153
									],
									[
										3154,
										3162
									],
									[
										3252,
										3260
									],
									[
										3486,
										3494
									],
									[
										3528,
										3536
									],
									[
										3569,
										3577
									],
									[
										4139,
										4147
									],
									[
										5601,
										5609
									],
									[
										6706,
										6714
									],
									[
										7822,
										7830
									],
									[
										8935,
										8943
									],
									[
										9551,
										9559
									],
									[
										9844,
										9852
									],
									[
										10164,
										10172
									],
									[
										10338,
										10346
									],
									[
										10664,
										10672
									],
									[
										10951,
										10959
									],
									[
										11204,
										11212
									],
									[
										11213,
										11221
									],
									[
										11375,
										11383
									],
									[
										11570,
										11578
									],
									[
										11857,
										11865
									],
									[
										12030,
										12038
									],
									[
										12056,
										12064
									],
									[
										12265,
										12273
									],
									[
										12385,
										12393
									],
									[
										12556,
										12564
									],
									[
										12761,
										12769
									],
									[
										12980,
										12988
									],
									[
										13044,
										13052
									],
									[
										13273,
										13281
									],
									[
										13459,
										13467
									],
									[
										13765,
										13773
									],
									[
										14083,
										14091
									],
									[
										14230,
										14238
									],
									[
										14475,
										14483
									],
									[
										14702,
										14710
									],
									[
										14732,
										14740
									],
									[
										14905,
										14913
									],
									[
										15047,
										15055
									],
									[
										15131,
										15139
									],
									[
										15221,
										15229
									],
									[
										15376,
										15384
									],
									[
										15516,
										15524
									],
									[
										15574,
										15582
									],
									[
										15612,
										15620
									],
									[
										15839,
										15847
									],
									[
										15989,
										15997
									],
									[
										16007,
										16015
									],
									[
										16214,
										16222
									],
									[
										16232,
										16240
									],
									[
										16441,
										16449
									],
									[
										16496,
										16504
									],
									[
										16776,
										16784
									],
									[
										16948,
										16956
									],
									[
										17050,
										17058
									],
									[
										17211,
										17219
									],
									[
										17395,
										17403
									],
									[
										17483,
										17491
									],
									[
										17521,
										17529
									],
									[
										17628,
										17636
									],
									[
										17695,
										17703
									],
									[
										17726,
										17734
									],
									[
										17886,
										17894
									],
									[
										18075,
										18083
									],
									[
										18261,
										18269
									],
									[
										18407,
										18415
									],
									[
										18721,
										18737
									],
									[
										18919,
										18935
									],
									[
										19264,
										19280
									],
									[
										19548,
										19564
									],
									[
										19714,
										19730
									],
									[
										19837,
										19853
									],
									[
										20016,
										20032
									],
									[
										20118,
										20134
									],
									[
										20279,
										20295
									],
									[
										20556,
										20580
									],
									[
										20963,
										20981
									],
									[
										21232,
										21250
									],
									[
										21632,
										21650
									],
									[
										21853,
										21871
									],
									[
										22087,
										22105
									],
									[
										22107,
										22125
									],
									[
										22241,
										22259
									],
									[
										22521,
										22539
									],
									[
										22774,
										22792
									],
									[
										22973,
										22991
									],
									[
										23161,
										23179
									],
									[
										23367,
										23385
									],
									[
										23490,
										23508
									],
									[
										23604,
										23622
									],
									[
										23712,
										23730
									],
									[
										23824,
										23842
									],
									[
										23905,
										23923
									],
									[
										24016,
										24034
									],
									[
										24146,
										24164
									],
									[
										24354,
										24372
									],
									[
										24431,
										24449
									],
									[
										24482,
										24500
									],
									[
										24896,
										24914
									],
									[
										25221,
										25239
									],
									[
										25565,
										25583
									],
									[
										25869,
										25887
									],
									[
										26195,
										26203
									],
									[
										26548,
										26556
									],
									[
										26784,
										26792
									],
									[
										27122,
										27130
									],
									[
										27453,
										27467
									],
									[
										27485,
										27499
									],
									[
										27776,
										27791
									],
									[
										28119,
										28128
									],
									[
										28144,
										28153
									],
									[
										28468,
										28477
									],
									[
										28744,
										28753
									],
									[
										29051,
										29060
									],
									[
										29372,
										29381
									],
									[
										29395,
										29404
									],
									[
										29774,
										29783
									],
									[
										30212,
										30221
									],
									[
										30589,
										30599
									],
									[
										30774,
										30784
									],
									[
										31032,
										31042
									],
									[
										31356,
										31366
									],
									[
										31614,
										31624
									],
									[
										31971,
										31981
									],
									[
										32360,
										32370
									],
									[
										32910,
										32917
									],
									[
										33099,
										33106
									],
									[
										33401,
										33408
									],
									[
										33547,
										33554
									],
									[
										33792,
										33799
									],
									[
										33973,
										33980
									],
									[
										34153,
										34160
									],
									[
										34348,
										34355
									],
									[
										34549,
										34556
									],
									[
										34811,
										34818
									],
									[
										34986,
										34993
									],
									[
										35302,
										35309
									],
									[
										35622,
										35629
									],
									[
										35804,
										35811
									],
									[
										36087,
										36094
									],
									[
										36416,
										36423
									],
									[
										36444,
										36451
									],
									[
										36494,
										36501
									],
									[
										36524,
										36531
									],
									[
										36858,
										36865
									],
									[
										36879,
										36886
									],
									[
										37220,
										37227
									],
									[
										37252,
										37259
									],
									[
										37482,
										37489
									],
									[
										37517,
										37524
									],
									[
										37552,
										37559
									],
									[
										37579,
										37586
									],
									[
										37679,
										37686
									],
									[
										37714,
										37721
									],
									[
										37749,
										37756
									],
									[
										37776,
										37783
									],
									[
										38068,
										38075
									],
									[
										38095,
										38102
									],
									[
										38386,
										38393
									],
									[
										38492,
										38499
									],
									[
										38799,
										38806
									],
									[
										38894,
										38901
									],
									[
										39035,
										39042
									],
									[
										39244,
										39251
									],
									[
										39385,
										39392
									],
									[
										39504,
										39511
									],
									[
										39629,
										39636
									],
									[
										39933,
										39940
									],
									[
										39977,
										39984
									],
									[
										40036,
										40043
									],
									[
										40516,
										40523
									],
									[
										41061,
										41071
									],
									[
										41499,
										41523
									],
									[
										41734,
										41758
									],
									[
										42118,
										42142
									],
									[
										42288,
										42312
									],
									[
										42503,
										42527
									],
									[
										42673,
										42697
									],
									[
										42867,
										42891
									],
									[
										43037,
										43061
									],
									[
										43252,
										43276
									],
									[
										43422,
										43446
									],
									[
										43655,
										43679
									],
									[
										43825,
										43849
									],
									[
										44040,
										44064
									],
									[
										44210,
										44234
									],
									[
										44675,
										44682
									],
									[
										44977,
										44984
									],
									[
										45295,
										45302
									],
									[
										45405,
										45412
									],
									[
										45820,
										45827
									],
									[
										46158,
										46165
									],
									[
										46565,
										46572
									],
									[
										47046,
										47053
									],
									[
										47366,
										47373
									],
									[
										47675,
										47682
									],
									[
										47876,
										47883
									],
									[
										47921,
										47928
									],
									[
										48019,
										48026
									],
									[
										48177,
										48184
									],
									[
										48282,
										48289
									],
									[
										48326,
										48333
									],
									[
										48418,
										48425
									],
									[
										48525,
										48532
									],
									[
										48806,
										48813
									],
									[
										48857,
										48864
									],
									[
										48938,
										48945
									],
									[
										49005,
										49012
									],
									[
										49386,
										49393
									],
									[
										49691,
										49698
									],
									[
										49849,
										49856
									],
									[
										50029,
										50036
									],
									[
										50222,
										50229
									],
									[
										50468,
										50475
									],
									[
										50607,
										50614
									],
									[
										50898,
										50905
									],
									[
										51200,
										51207
									],
									[
										51427,
										51434
									],
									[
										51731,
										51738
									],
									[
										52092,
										52099
									],
									[
										52279,
										52286
									],
									[
										52608,
										52615
									],
									[
										52946,
										52953
									],
									[
										53138,
										53145
									],
									[
										53475,
										53482
									],
									[
										53915,
										53922
									],
									[
										54340,
										54347
									],
									[
										54659,
										54666
									],
									[
										54796,
										54803
									],
									[
										54976,
										54983
									],
									[
										55373,
										55380
									],
									[
										55711,
										55718
									],
									[
										56134,
										56141
									],
									[
										56401,
										56408
									],
									[
										56790,
										56797
									],
									[
										57221,
										57228
									],
									[
										57587,
										57594
									],
									[
										57791,
										57798
									],
									[
										57963,
										57970
									],
									[
										58176,
										58183
									],
									[
										58407,
										58414
									],
									[
										58699,
										58706
									],
									[
										58916,
										58923
									],
									[
										59231,
										59238
									],
									[
										59434,
										59441
									],
									[
										59628,
										59635
									],
									[
										59909,
										59916
									],
									[
										60123,
										60130
									],
									[
										60378,
										60385
									],
									[
										60605,
										60612
									],
									[
										60853,
										60860
									],
									[
										61216,
										61223
									],
									[
										61434,
										61441
									],
									[
										61651,
										61658
									],
									[
										61709,
										61716
									],
									[
										61804,
										61811
									],
									[
										61862,
										61869
									],
									[
										61976,
										61983
									],
									[
										62004,
										62011
									],
									[
										62127,
										62134
									],
									[
										62178,
										62185
									],
									[
										62292,
										62299
									],
									[
										62344,
										62351
									],
									[
										62442,
										62449
									],
									[
										62736,
										62743
									],
									[
										62964,
										62971
									],
									[
										63322,
										63329
									],
									[
										63495,
										63502
									],
									[
										63925,
										63932
									],
									[
										64165,
										64172
									],
									[
										64376,
										64383
									],
									[
										64725,
										64732
									],
									[
										64947,
										64954
									],
									[
										65006,
										65013
									],
									[
										65217,
										65224
									],
									[
										65413,
										65420
									],
									[
										65726,
										65733
									],
									[
										65806,
										65813
									],
									[
										66165,
										66172
									],
									[
										66423,
										66430
									],
									[
										66440,
										66447
									],
									[
										66628,
										66635
									],
									[
										66873,
										66880
									],
									[
										67027,
										67034
									],
									[
										67259,
										67266
									],
									[
										67576,
										67583
									],
									[
										67830,
										67837
									],
									[
										68068,
										68075
									],
									[
										68255,
										68262
									],
									[
										68444,
										68451
									],
									[
										68701,
										68708
									],
									[
										69023,
										69030
									],
									[
										69228,
										69235
									],
									[
										69264,
										69271
									],
									[
										69360,
										69367
									],
									[
										69594,
										69601
									],
									[
										69990,
										69997
									],
									[
										70170,
										70177
									],
									[
										70310,
										70317
									],
									[
										70485,
										70492
									],
									[
										70778,
										70785
									],
									[
										71015,
										71022
									],
									[
										71228,
										71235
									],
									[
										71622,
										71629
									],
									[
										71851,
										71858
									],
									[
										71949,
										71956
									],
									[
										72000,
										72007
									],
									[
										72094,
										72101
									],
									[
										72154,
										72161
									],
									[
										72308,
										72315
									],
									[
										72488,
										72495
									],
									[
										72712,
										72719
									],
									[
										72793,
										72800
									],
									[
										72844,
										72851
									],
									[
										72911,
										72918
									],
									[
										73221,
										73237
									],
									[
										73394,
										73410
									],
									[
										73681,
										73697
									],
									[
										73955,
										73971
									],
									[
										74155,
										74171
									],
									[
										74375,
										74391
									],
									[
										74588,
										74604
									],
									[
										74801,
										74817
									],
									[
										75057,
										75073
									]
								],
								"scope": ""
							}
						},
						"selection":
						[
							[
								73039,
								73039
							]
						],
						"settings":
						{
							"detect_indentation": false,
							"line_numbers": false,
							"output_tag": 26,
							"result_base_dir": "",
							"result_file_regex": "^([^ \t].*):$",
							"result_line_regex": "^ +([0-9]+):",
							"scroll_past_end": true,
							"syntax": "Packages/Default/Find Results.hidden-tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 30430.0,
						"zoom_level": 1.0
					},
					"stack_index": 27,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "third_party/antlr4/runtime/Cpp/runtime/src/atn/LexerATNSimulator.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 21812,
						"regions":
						{
						},
						"selection":
						[
							[
								20903,
								20903
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3406.0,
						"zoom_level": 1.0
					},
					"stack_index": 28,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "third_party/antlr4/runtime/Cpp/runtime/src/UnbufferedTokenStream.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7464,
						"regions":
						{
						},
						"selection":
						[
							[
								2188,
								2188
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 816.0,
						"zoom_level": 1.0
					},
					"stack_index": 20,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "/home/max/dev/RadeonProRenderUSD/deps/RPR/RadeonProRender/inc/RadeonProRender_v2.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 124838,
						"regions":
						{
						},
						"selection":
						[
							[
								6712,
								6712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 2669.0,
						"zoom_level": 1.0
					},
					"stack_index": 127,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "src/lava/lava.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 133,
						"regions":
						{
						},
						"selection":
						[
							[
								43,
								43
							]
						],
						"settings":
						{
							"auto_name": "#ifndef LAVA_TYPES_H_",
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 48,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "src/lava/types.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6995,
						"regions":
						{
						},
						"selection":
						[
							[
								2185,
								2185
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 551.0,
						"zoom_level": 1.0
					},
					"stack_index": 47,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "/home/max/dev/RadeonProRenderUSD/deps/RPR/RadeonProRender/inc/RadeonProRender.cs",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 143659,
						"regions":
						{
						},
						"selection":
						[
							[
								20100,
								20100
							]
						],
						"settings":
						{
							"syntax": "Packages/C#/C#.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 48230.0,
						"zoom_level": 1.0
					},
					"stack_index": 132,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "/home/max/dev/RadeonProRenderUSD/pxr/imaging/plugin/hdRpr/python/generateRenderSettingFiles.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 24851,
						"regions":
						{
						},
						"selection":
						[
							[
								13470,
								13470
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 6889.0,
						"zoom_level": 1.0
					},
					"stack_index": 136,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "third_party/USD/cmake/macros/Private.cmake",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 50720,
						"regions":
						{
						},
						"selection":
						[
							[
								2462,
								2462
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 385.0,
						"zoom_level": 1.0
					},
					"stack_index": 142,
					"type": "text"
				},
				{
					"buffer": 10,
					"file": "src/Falcor/Core/API/D3D12/D3D12NvApiExDesc.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4956,
						"regions":
						{
						},
						"selection":
						[
							[
								4176,
								4176
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1062.0,
						"zoom_level": 1.0
					},
					"stack_index": 262,
					"type": "text"
				},
				{
					"buffer": 11,
					"file": "src/Falcor/Core/API/Vulkan/VkResource.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1884,
						"regions":
						{
						},
						"selection":
						[
							[
								1754,
								1754
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 299,
					"type": "text"
				},
				{
					"buffer": 12,
					"file": "src/Mogwai/Data/ForwardRenderer.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1872,
						"regions":
						{
						},
						"selection":
						[
							[
								1872,
								1872
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 477,
					"type": "text"
				},
				{
					"buffer": 13,
					"file": "src/Mogwai/Data/BSDFViewer.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 634,
						"regions":
						{
						},
						"selection":
						[
							[
								156,
								156
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 478,
					"type": "text"
				},
				{
					"buffer": 14,
					"file": "third_party/slang/external/glslang/glslang/Include/BaseTypes.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 18643,
						"regions":
						{
						},
						"selection":
						[
							[
								18403,
								18403
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 8214.0,
						"zoom_level": 1.0
					},
					"stack_index": 489,
					"type": "text"
				},
				{
					"buffer": 15,
					"file": "third_party/slang/external/glslang/glslang/MachineIndependent/Initialize.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 477356,
						"regions":
						{
						},
						"selection":
						[
							[
								383248,
								383248
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 141562.0,
						"zoom_level": 1.0
					},
					"stack_index": 490,
					"type": "text"
				},
				{
					"buffer": 16,
					"file": "src/Falcor/Scene/Raster.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4526,
						"regions":
						{
						},
						"selection":
						[
							[
								2674,
								2674
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1173.0,
						"zoom_level": 1.0
					},
					"stack_index": 481,
					"type": "text"
				},
				{
					"buffer": 17,
					"file": "src/RenderPasses/GBuffer/GBuffer/GBufferRaster.3d.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7187,
						"regions":
						{
						},
						"selection":
						[
							[
								5949,
								5949
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 473,
					"type": "text"
				},
				{
					"buffer": 18,
					"file": "src/Falcor/Scene/ShadingData.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15181,
						"regions":
						{
						},
						"selection":
						[
							[
								2978,
								2978
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 510.0,
						"zoom_level": 1.0
					},
					"stack_index": 482,
					"type": "text"
				},
				{
					"buffer": 19,
					"file": "src/RenderPasses/Antialiasing/TAA/TAA.ps.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5743,
						"regions":
						{
						},
						"selection":
						[
							[
								1764,
								1764
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 488,
					"type": "text"
				},
				{
					"buffer": 20,
					"file": "src/Falcor/Experimental/Scene/Lights/LightBVH.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 18635,
						"regions":
						{
						},
						"selection":
						[
							[
								2197,
								2197
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 341,
					"type": "text"
				},
				{
					"buffer": 21,
					"file": "src/Falcor/Experimental/Scene/Lights/LightBVHBuilder.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11295,
						"regions":
						{
						},
						"selection":
						[
							[
								11255,
								11255
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 393.0,
						"zoom_level": 1.0
					},
					"stack_index": 343,
					"type": "text"
				},
				{
					"buffer": 22,
					"file": "src/Falcor/Experimental/Scene/Lights/LightBVHBuilder.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 41661,
						"regions":
						{
						},
						"selection":
						[
							[
								9495,
								9495
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2703.0,
						"zoom_level": 1.0
					},
					"stack_index": 340,
					"type": "text"
				},
				{
					"buffer": 23,
					"file": "src/Falcor/Experimental/Scene/Lights/LightBVH.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 12420,
						"regions":
						{
						},
						"selection":
						[
							[
								5412,
								5412
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1530.0,
						"zoom_level": 1.0
					},
					"stack_index": 342,
					"type": "text"
				},
				{
					"buffer": 24,
					"file": "src/Falcor/Utils/Algorithm/ParallelReduction.ps.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4191,
						"regions":
						{
						},
						"selection":
						[
							[
								1791,
								1791
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 507,
					"type": "text"
				},
				{
					"buffer": 25,
					"file": "src/RenderPasses/BSDFViewer/BSDFViewerParams.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6511,
						"regions":
						{
						},
						"selection":
						[
							[
								6078,
								6078
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1400.0,
						"zoom_level": 1.0
					},
					"stack_index": 485,
					"type": "text"
				},
				{
					"buffer": 26,
					"file": "third_party/slang/external/glslang/glslang/MachineIndependent/ParseHelper.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 364782,
						"regions":
						{
						},
						"selection":
						[
							[
								97986,
								97986
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 35727.0,
						"zoom_level": 1.0
					},
					"stack_index": 512,
					"type": "text"
				},
				{
					"buffer": 27,
					"file": "third_party/slang/external/glslang/SPIRV/SpvBuilder.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 105150,
						"regions":
						{
						},
						"selection":
						[
							[
								1975,
								1975
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 734.0,
						"zoom_level": 1.0
					},
					"stack_index": 509,
					"type": "text"
				},
				{
					"buffer": 28,
					"file": "third_party/slang/source/slang/slang-ir.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 150177,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 14249.0,
						"zoom_level": 1.0
					},
					"stack_index": 511,
					"type": "text"
				},
				{
					"buffer": 29,
					"file": "third_party/slang/external/glslang/SPIRV/SpvBuilder.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 35460,
						"regions":
						{
						},
						"selection":
						[
							[
								2248,
								2248
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 547.0,
						"zoom_level": 1.0
					},
					"stack_index": 510,
					"type": "text"
				},
				{
					"buffer": 30,
					"file": "third_party/slang/source/slang-glslang/slang-glslang.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 18679,
						"regions":
						{
						},
						"selection":
						[
							[
								9729,
								9729
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3760.0,
						"zoom_level": 1.0
					},
					"stack_index": 514,
					"type": "text"
				},
				{
					"buffer": 31,
					"file": "third_party/slang/external/spirv-tools/source/spirv_target_env.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10524,
						"regions":
						{
						},
						"selection":
						[
							[
								6159,
								6159
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2145.0,
						"zoom_level": 1.0
					},
					"stack_index": 515,
					"type": "text"
				},
				{
					"buffer": 32,
					"file": "third_party/slang/external/spirv-tools/CHANGES",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 47890,
						"regions":
						{
						},
						"selection":
						[
							[
								26053,
								26053
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 3,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 969.0,
						"zoom_level": 1.0
					},
					"stack_index": 516,
					"type": "text"
				},
				{
					"buffer": 33,
					"file": "src/Falcor/Scene/SceneBuilder.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 23587,
						"regions":
						{
						},
						"selection":
						[
							[
								20564,
								20564
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3009.0,
						"zoom_level": 1.0
					},
					"stack_index": 264,
					"type": "text"
				},
				{
					"buffer": 34,
					"file": "src/Falcor/Scene/SceneTypes.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5249,
						"regions":
						{
						},
						"selection":
						[
							[
								5227,
								5227
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1842.0,
						"zoom_level": 1.0
					},
					"stack_index": 480,
					"type": "text"
				},
				{
					"buffer": 35,
					"file": "third_party/slang/source/slang/slang-type-layout.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 149248,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3250.0,
						"zoom_level": 1.0
					},
					"stack_index": 522,
					"type": "text"
				},
				{
					"buffer": 36,
					"file": "third_party/slang/source/slang/slang-type-layout.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 34158,
						"regions":
						{
						},
						"selection":
						[
							[
								4752,
								4752
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 7568.0,
						"zoom_level": 1.0
					},
					"stack_index": 521,
					"type": "text"
				},
				{
					"buffer": 37,
					"file": "third_party/slang/slang.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 132132,
						"regions":
						{
						},
						"selection":
						[
							[
								14421,
								14421
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1367.0,
						"zoom_level": 1.0
					},
					"stack_index": 517,
					"type": "text"
				},
				{
					"buffer": 38,
					"file": "third_party/slang/external/glm/test/core/core_type_aligned.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5440,
						"regions":
						{
						},
						"selection":
						[
							[
								1764,
								1764
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 612.0,
						"zoom_level": 1.0
					},
					"stack_index": 523,
					"type": "text"
				},
				{
					"buffer": 39,
					"file": "src/Falcor/Core/API/Formats.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 19719,
						"regions":
						{
						},
						"selection":
						[
							[
								1805,
								1805
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 180.0,
						"zoom_level": 1.0
					},
					"stack_index": 504,
					"type": "text"
				},
				{
					"buffer": 40,
					"file": "third_party/slang/external/glm/glm/gtx/compatibility.hpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14979,
						"regions":
						{
						},
						"selection":
						[
							[
								452,
								452
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 534,
					"type": "text"
				},
				{
					"buffer": 41,
					"file": "src/Falcor/Core/API/Vulkan/VKFormats.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10446,
						"regions":
						{
						},
						"selection":
						[
							[
								8644,
								8644
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1346.0,
						"zoom_level": 1.0
					},
					"stack_index": 424,
					"type": "text"
				},
				{
					"buffer": 42,
					"file": "third_party/slang/external/glslang/glslang/Include/intermediate.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 54763,
						"regions":
						{
						},
						"selection":
						[
							[
								25731,
								25731
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 16441.0,
						"zoom_level": 1.0
					},
					"stack_index": 538,
					"type": "text"
				},
				{
					"buffer": 43,
					"file": "third_party/slang/docs/language-reference/04-types.md",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14365,
						"regions":
						{
						},
						"selection":
						[
							[
								1184,
								1184
							]
						],
						"settings":
						{
							"syntax": "Packages/Markdown/Markdown.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 541,
					"type": "text"
				},
				{
					"buffer": 44,
					"file": "third_party/slang/external/glslang/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4705,
						"regions":
						{
						},
						"selection":
						[
							[
								2012,
								2012
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 542,
					"type": "text"
				},
				{
					"buffer": 45,
					"file": "third_party/slang/external/glslang/SPIRV/GlslangToSpv.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 339007,
						"regions":
						{
						},
						"selection":
						[
							[
								1976,
								1976
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 255.0,
						"zoom_level": 1.0
					},
					"stack_index": 543,
					"type": "text"
				},
				{
					"buffer": 46,
					"file": "third_party/slang/external/glslang/Test/100.frag",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4744,
						"regions":
						{
						},
						"selection":
						[
							[
								1633,
								1633
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1683.0,
						"zoom_level": 1.0
					},
					"stack_index": 544,
					"type": "text"
				},
				{
					"buffer": 47,
					"file": "third_party/slang/external/glext.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 811328,
						"regions":
						{
						},
						"selection":
						[
							[
								91506,
								91506
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 29021.0,
						"zoom_level": 1.0
					},
					"stack_index": 545,
					"type": "text"
				},
				{
					"buffer": 48,
					"file": "third_party/slang/docs/wave-intrinsics.md",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13145,
						"regions":
						{
						},
						"selection":
						[
							[
								370,
								370
							]
						],
						"settings":
						{
							"syntax": "Packages/Markdown/Markdown.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4675.0,
						"zoom_level": 1.0
					},
					"stack_index": 513,
					"type": "text"
				},
				{
					"buffer": 49,
					"file": "src/RenderPasses/DebugPasses/InvalidPixelDetectionPass/InvalidPixelDetectionPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4322,
						"regions":
						{
						},
						"selection":
						[
							[
								3840,
								3840
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 243.0,
						"zoom_level": 1.0
					},
					"stack_index": 181,
					"type": "text"
				},
				{
					"buffer": 50,
					"file": "src/Tools/FalcorTest/Tests/Core/RootBufferParamBlockTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8904,
						"regions":
						{
						},
						"selection":
						[
							[
								7978,
								7978
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 328.0,
						"zoom_level": 1.0
					},
					"stack_index": 527,
					"type": "text"
				},
				{
					"buffer": 51,
					"file": "src/Tools/FalcorTest/Tests/Core/RootBufferParamBlockTests.cs.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3086,
						"regions":
						{
						},
						"selection":
						[
							[
								1883,
								1883
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 530,
					"type": "text"
				},
				{
					"buffer": 52,
					"file": "src/Tools/FalcorTest/Tests/Core/ParamBlockDefinition.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2225,
						"regions":
						{
						},
						"selection":
						[
							[
								2107,
								2107
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 531,
					"type": "text"
				},
				{
					"buffer": 53,
					"file": "src/Falcor/Core/Program/ProgramVersion.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8252,
						"regions":
						{
						},
						"selection":
						[
							[
								4136,
								4136
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1125.0,
						"zoom_level": 1.0
					},
					"stack_index": 408,
					"type": "text"
				},
				{
					"buffer": 54,
					"file": "src/Falcor/RenderGraph/RenderGraphIR.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5845,
						"regions":
						{
						},
						"selection":
						[
							[
								2376,
								2376
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 47.0,
						"zoom_level": 1.0
					},
					"stack_index": 282,
					"type": "text"
				},
				{
					"buffer": 55,
					"file": "src/Falcor/RenderGraph/RenderGraphIR.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3409,
						"regions":
						{
						},
						"selection":
						[
							[
								1773,
								1773
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 432.0,
						"zoom_level": 1.0
					},
					"stack_index": 283,
					"type": "text"
				},
				{
					"buffer": 56,
					"file": "src/Falcor/Scene/Importers/AssimpImporter.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 44987,
						"regions":
						{
						},
						"selection":
						[
							[
								40724,
								40724
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 14260.0,
						"zoom_level": 1.0
					},
					"stack_index": 376,
					"type": "text"
				},
				{
					"buffer": 57,
					"file": "src/Falcor/Scene/Importers/AssimpImporter.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2484,
						"regions":
						{
						},
						"selection":
						[
							[
								1819,
								1819
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 354,
					"type": "text"
				},
				{
					"buffer": 58,
					"file": "src/Falcor/Scene/Importers/PythonImporter.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2145,
						"regions":
						{
						},
						"selection":
						[
							[
								1987,
								1987
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 352,
					"type": "text"
				},
				{
					"buffer": 59,
					"file": "src/Falcor/Scene/Camera/Camera.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11607,
						"regions":
						{
						},
						"selection":
						[
							[
								606,
								606
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 170.0,
						"zoom_level": 1.0
					},
					"stack_index": 347,
					"type": "text"
				},
				{
					"buffer": 60,
					"file": "src/Falcor/Utils/Sampling/SampleGenerator.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4312,
						"regions":
						{
						},
						"selection":
						[
							[
								4312,
								4312
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 277.0,
						"zoom_level": 1.0
					},
					"stack_index": 356,
					"type": "text"
				},
				{
					"buffer": 61,
					"file": "src/Falcor/Utils/SampleGenerators/StratifiedSamplePattern.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3466,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 357.0,
						"zoom_level": 1.0
					},
					"stack_index": 367,
					"type": "text"
				},
				{
					"buffer": 62,
					"file": "src/Falcor/Utils/SampleGenerators/HaltonSamplePattern.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3159,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 366,
					"type": "text"
				},
				{
					"buffer": 63,
					"file": "src/Falcor/Utils/SampleGenerators/CPUSampleGenerator.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2791,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 365,
					"type": "text"
				},
				{
					"buffer": 64,
					"file": "src/Falcor/Core/API/GraphicsStateObject.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6433,
						"regions":
						{
						},
						"selection":
						[
							[
								5115,
								5115
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 918.0,
						"zoom_level": 1.0
					},
					"stack_index": 395,
					"type": "text"
				},
				{
					"buffer": 65,
					"file": "src/Falcor/Core/API/GraphicsStateObject.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4274,
						"regions":
						{
						},
						"selection":
						[
							[
								4227,
								4227
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 734.0,
						"zoom_level": 1.0
					},
					"stack_index": 394,
					"type": "text"
				},
				{
					"buffer": 66,
					"file": "src/Falcor/Core/API/Vulkan/VKFbo.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5380,
						"regions":
						{
						},
						"selection":
						[
							[
								2311,
								2311
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1446.0,
						"zoom_level": 1.0
					},
					"stack_index": 280,
					"type": "text"
				},
				{
					"buffer": 67,
					"file": "src/Falcor/Core/API/ComputeStateObject.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3496,
						"regions":
						{
						},
						"selection":
						[
							[
								3496,
								3496
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 530.0,
						"zoom_level": 1.0
					},
					"stack_index": 398,
					"type": "text"
				},
				{
					"buffer": 68,
					"file": "src/Falcor/Experimental/Scene/Lights/EnvProbe.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6616,
						"regions":
						{
						},
						"selection":
						[
							[
								1791,
								1791
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 351,
					"type": "text"
				},
				{
					"buffer": 69,
					"file": "src/Falcor/Core/API/ComputeContext.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3969,
						"regions":
						{
						},
						"selection":
						[
							[
								3612,
								3612
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1071.0,
						"zoom_level": 1.0
					},
					"stack_index": 273,
					"type": "text"
				},
				{
					"buffer": 70,
					"file": "src/Falcor/Core/API/GpuTimer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3787,
						"regions":
						{
						},
						"selection":
						[
							[
								2467,
								2467
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 597.0,
						"zoom_level": 1.0
					},
					"stack_index": 427,
					"type": "text"
				},
				{
					"buffer": 71,
					"file": "src/Falcor/Core/API/LowLevelContextData.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3656,
						"regions":
						{
						},
						"selection":
						[
							[
								3566,
								3566
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 428.0,
						"zoom_level": 1.0
					},
					"stack_index": 414,
					"type": "text"
				},
				{
					"buffer": 72,
					"file": "src/Falcor/Utils/Timing/Profiler.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8484,
						"regions":
						{
						},
						"selection":
						[
							[
								6832,
								6832
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2244.0,
						"zoom_level": 1.0
					},
					"stack_index": 326,
					"type": "text"
				},
				{
					"buffer": 73,
					"file": "src/Falcor/Core/Platform/Windows/Windows.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 26025,
						"regions":
						{
						},
						"selection":
						[
							[
								25040,
								25040
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 11154.0,
						"zoom_level": 1.0
					},
					"stack_index": 577,
					"type": "text"
				},
				{
					"buffer": 74,
					"file": "third_party/slang/tools/gfx/d3d12/render-d3d12.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 139342,
						"regions":
						{
						},
						"selection":
						[
							[
								17858,
								17858
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 7779.0,
						"zoom_level": 1.0
					},
					"stack_index": 591,
					"type": "text"
				},
				{
					"buffer": 75,
					"file": "third_party/slang/tools/gfx/vulkan/render-vk.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 99401,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 7701.0,
						"zoom_level": 1.0
					},
					"stack_index": 590,
					"type": "text"
				},
				{
					"buffer": 76,
					"file": "src/Falcor/Raytracing/RtProgramVarsHelper.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6214,
						"regions":
						{
						},
						"selection":
						[
							[
								5889,
								5889
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1486.0,
						"zoom_level": 1.0
					},
					"stack_index": 499,
					"type": "text"
				},
				{
					"buffer": 77,
					"file": "src/Falcor/Core/API/D3D12/FalcorD3D12.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9709,
						"regions":
						{
						},
						"selection":
						[
							[
								1759,
								1759
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 592,
					"type": "text"
				},
				{
					"buffer": 78,
					"file": "src/Falcor/Core/Platform/OS.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8771,
						"regions":
						{
						},
						"selection":
						[
							[
								5508,
								5508
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 801.0,
						"zoom_level": 1.0
					},
					"stack_index": 554,
					"type": "text"
				},
				{
					"buffer": 79,
					"file": "src/RenderPasses/SkyBox/SkyBox.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2520,
						"regions":
						{
						},
						"selection":
						[
							[
								1900,
								1900
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 553,
					"type": "text"
				},
				{
					"buffer": 80,
					"file": "src/RenderPasses/CSM/VisibilityPass.ps.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2953,
						"regions":
						{
						},
						"selection":
						[
							[
								2130,
								2130
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 204.0,
						"zoom_level": 1.0
					},
					"stack_index": 474,
					"type": "text"
				},
				{
					"buffer": 81,
					"file": "src/RenderPasses/ToneMapper/ToneMapping.ps.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5616,
						"regions":
						{
						},
						"selection":
						[
							[
								2154,
								2154
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 153.0,
						"zoom_level": 1.0
					},
					"stack_index": 552,
					"type": "text"
				},
				{
					"buffer": 82,
					"file": "src/RenderPasses/ToneMapper/Luminance.ps.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2106,
						"regions":
						{
						},
						"selection":
						[
							[
								1729,
								1729
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 252,
					"type": "text"
				},
				{
					"buffer": 83,
					"file": "src/Falcor/Scene/Importers/PythonImporter.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3931,
						"regions":
						{
						},
						"selection":
						[
							[
								3536,
								3536
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 765.0,
						"zoom_level": 1.0
					},
					"stack_index": 377,
					"type": "text"
				},
				{
					"buffer": 84,
					"file": "src/Falcor/Scene/Importers/SceneImporter.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 36435,
						"regions":
						{
						},
						"selection":
						[
							[
								2727,
								2727
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1573.0,
						"zoom_level": 1.0
					},
					"stack_index": 382,
					"type": "text"
				},
				{
					"buffer": 85,
					"file": "src/Falcor/Scene/Importers/SceneImporter.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2157,
						"regions":
						{
						},
						"selection":
						[
							[
								1980,
								1980
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 353,
					"type": "text"
				},
				{
					"buffer": 86,
					"file": "src/Falcor/Core/Program/Program.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 12423,
						"regions":
						{
						},
						"selection":
						[
							[
								1815,
								1815
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 459.0,
						"zoom_level": 1.0
					},
					"stack_index": 277,
					"type": "text"
				},
				{
					"buffer": 87,
					"file": "src/Falcor/Core/Program/GraphicsProgram.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3809,
						"regions":
						{
						},
						"selection":
						[
							[
								3024,
								3024
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 275.0,
						"zoom_level": 1.0
					},
					"stack_index": 409,
					"type": "text"
				},
				{
					"buffer": 88,
					"file": "src/Falcor/Core/Program/ComputeProgram.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3818,
						"regions":
						{
						},
						"selection":
						[
							[
								2221,
								2221
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 171.0,
						"zoom_level": 1.0
					},
					"stack_index": 392,
					"type": "text"
				},
				{
					"buffer": 89,
					"file": "src/Falcor/Core/Program/GraphicsProgram.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2616,
						"regions":
						{
						},
						"selection":
						[
							[
								2229,
								2229
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 410,
					"type": "text"
				},
				{
					"buffer": 90,
					"file": "src/Falcor/Scene/Camera/Camera.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5388,
						"regions":
						{
						},
						"selection":
						[
							[
								4265,
								4265
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 487,
					"type": "text"
				},
				{
					"buffer": 91,
					"file": "src/Falcor/Utils/ArgList.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4051,
						"regions":
						{
						},
						"selection":
						[
							[
								1841,
								1841
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 492,
					"type": "text"
				},
				{
					"buffer": 92,
					"file": "src/Mogwai/Mogwai.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 25052,
						"regions":
						{
						},
						"selection":
						[
							[
								23595,
								23595
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 10380.0,
						"zoom_level": 1.0
					},
					"stack_index": 113,
					"type": "text"
				},
				{
					"buffer": 93,
					"file": "src/Mogwai/stdafx.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1851,
						"regions":
						{
						},
						"selection":
						[
							[
								1850,
								1850
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 583,
					"type": "text"
				},
				{
					"buffer": 94,
					"file": "src/Falcor/Core/Renderer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7238,
						"regions":
						{
						},
						"selection":
						[
							[
								4740,
								4740
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1912.0,
						"zoom_level": 1.0
					},
					"stack_index": 125,
					"type": "text"
				},
				{
					"buffer": 95,
					"file": "src/Falcor/RenderGraph/RenderPassLibrary.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11374,
						"regions":
						{
						},
						"selection":
						[
							[
								8250,
								8250
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2739.0,
						"zoom_level": 1.0
					},
					"stack_index": 190,
					"type": "text"
				},
				{
					"buffer": 96,
					"file": "src/Falcor/RenderGraph/RenderPassLibrary.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5360,
						"regions":
						{
						},
						"selection":
						[
							[
								3684,
								3684
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 944.0,
						"zoom_level": 1.0
					},
					"stack_index": 281,
					"type": "text"
				},
				{
					"buffer": 97,
					"file": "src/Falcor/Utils/UI/UserInput.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7116,
						"regions":
						{
						},
						"selection":
						[
							[
								1793,
								1793
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 396.0,
						"zoom_level": 1.0
					},
					"stack_index": 348,
					"type": "text"
				},
				{
					"buffer": 98,
					"file": "src/Externals/GLM/glm/gtx/compatibility.hpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14969,
						"regions":
						{
						},
						"selection":
						[
							[
								10757,
								10757
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 1029.0,
						"zoom_level": 1.0
					},
					"stack_index": 350,
					"type": "text"
				},
				{
					"buffer": 99,
					"file": "src/Falcor/Core/Sample.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7395,
						"regions":
						{
						},
						"selection":
						[
							[
								5619,
								5619
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1567.0,
						"zoom_level": 1.0
					},
					"stack_index": 169,
					"type": "text"
				},
				{
					"buffer": 100,
					"file": "src/Falcor/Utils/UI/Gui.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 26357,
						"regions":
						{
						},
						"selection":
						[
							[
								26237,
								26237
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1479.0,
						"zoom_level": 1.0
					},
					"stack_index": 173,
					"type": "text"
				},
				{
					"buffer": 101,
					"file": "src/Falcor/Core/Window.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 17937,
						"regions":
						{
						},
						"selection":
						[
							[
								12930,
								12930
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4933.0,
						"zoom_level": 1.0
					},
					"stack_index": 318,
					"type": "text"
				},
				{
					"buffer": 102,
					"file": "src/Falcor/Core/Window.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5627,
						"regions":
						{
						},
						"selection":
						[
							[
								4740,
								4740
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1282.0,
						"zoom_level": 1.0
					},
					"stack_index": 308,
					"type": "text"
				},
				{
					"buffer": 103,
					"file": "src/Falcor/Utils/ArgList.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6269,
						"regions":
						{
						},
						"selection":
						[
							[
								6268,
								6268
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1893.0,
						"zoom_level": 1.0
					},
					"stack_index": 491,
					"type": "text"
				},
				{
					"buffer": 104,
					"file": "src/Falcor/Utils/AlignedAllocator.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6544,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1479.0,
						"zoom_level": 1.0
					},
					"stack_index": 470,
					"type": "text"
				},
				{
					"buffer": 105,
					"file": "src/Falcor/Core/API/Resource.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7622,
						"regions":
						{
						},
						"selection":
						[
							[
								7023,
								7023
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1720.0,
						"zoom_level": 1.0
					},
					"stack_index": 306,
					"type": "text"
				},
				{
					"buffer": 106,
					"file": "src/Tools/FalcorTest/Tests/Core/BufferTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6996,
						"regions":
						{
						},
						"selection":
						[
							[
								1742,
								1742
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1978.0,
						"zoom_level": 1.0
					},
					"stack_index": 528,
					"type": "text"
				},
				{
					"buffer": 107,
					"file": "src/Tools/FalcorTest/Tests/DebugPasses/InvalidPixelDetectionTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3746,
						"regions":
						{
						},
						"selection":
						[
							[
								2971,
								2971
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 88.0,
						"zoom_level": 1.0
					},
					"stack_index": 479,
					"type": "text"
				},
				{
					"buffer": 108,
					"file": "src/Tools/FalcorTest/Tests/ShadingUtils/ShadingUtilsTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 12331,
						"regions":
						{
						},
						"selection":
						[
							[
								12306,
								12306
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 548,
					"type": "text"
				},
				{
					"buffer": 109,
					"file": "src/Falcor/Testing/UnitTest.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 18208,
						"regions":
						{
						},
						"selection":
						[
							[
								4230,
								4230
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1303.0,
						"zoom_level": 1.0
					},
					"stack_index": 375,
					"type": "text"
				},
				{
					"buffer": 110,
					"file": "src/Falcor/Testing/UnitTest.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11972,
						"regions":
						{
						},
						"selection":
						[
							[
								11972,
								11972
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4227.0,
						"zoom_level": 1.0
					},
					"stack_index": 374,
					"type": "text"
				},
				{
					"buffer": 111,
					"file": "src/Falcor/Core/Program/ComputeProgram.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2634,
						"regions":
						{
						},
						"selection":
						[
							[
								2219,
								2219
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 291,
					"type": "text"
				},
				{
					"buffer": 112,
					"file": "src/Tools/FalcorTest/Tests/Core/BufferAccessTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6233,
						"regions":
						{
						},
						"selection":
						[
							[
								4566,
								4566
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 357.0,
						"zoom_level": 1.0
					},
					"stack_index": 529,
					"type": "text"
				},
				{
					"buffer": 113,
					"file": "src/Tools/FalcorTest/Tests/Core/BufferAccessTests.cs.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1913,
						"regions":
						{
						},
						"selection":
						[
							[
								1913,
								1913
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 533,
					"type": "text"
				},
				{
					"buffer": 114,
					"file": "src/Falcor/Core/API/Resource.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5154,
						"regions":
						{
						},
						"selection":
						[
							[
								4887,
								4887
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 300,
					"type": "text"
				},
				{
					"buffer": 115,
					"file": "src/Falcor/Core/API/RenderContext.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11441,
						"regions":
						{
						},
						"selection":
						[
							[
								11026,
								11026
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2754.0,
						"zoom_level": 1.0
					},
					"stack_index": 274,
					"type": "text"
				},
				{
					"buffer": 116,
					"file": "src/Falcor/Core/API/RenderContext.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5362,
						"regions":
						{
						},
						"selection":
						[
							[
								2053,
								2053
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 520.0,
						"zoom_level": 1.0
					},
					"stack_index": 168,
					"type": "text"
				},
				{
					"buffer": 117,
					"file": "src/Falcor/Core/API/RasterizerState.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7490,
						"regions":
						{
						},
						"selection":
						[
							[
								1841,
								1841
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2300.0,
						"zoom_level": 1.0
					},
					"stack_index": 497,
					"type": "text"
				},
				{
					"buffer": 118,
					"file": "src/Falcor/Core/API/RasterizerState.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2247,
						"regions":
						{
						},
						"selection":
						[
							[
								1768,
								1768
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 498,
					"type": "text"
				},
				{
					"buffer": 119,
					"file": "src/Falcor/Core/API/Vulkan/VKRasterizerState.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2034,
						"regions":
						{
						},
						"selection":
						[
							[
								1761,
								1761
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 505,
					"type": "text"
				},
				{
					"buffer": 120,
					"file": "src/Falcor/Core/API/QueryHeap.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3579,
						"regions":
						{
						},
						"selection":
						[
							[
								2529,
								2529
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 377.0,
						"zoom_level": 1.0
					},
					"stack_index": 302,
					"type": "text"
				},
				{
					"buffer": 121,
					"file": "src/Falcor/Core/API/Formats.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13822,
						"regions":
						{
						},
						"selection":
						[
							[
								12301,
								12301
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 5661.0,
						"zoom_level": 1.0
					},
					"stack_index": 423,
					"type": "text"
				},
				{
					"buffer": 122,
					"file": "src/Falcor/Core/API/Buffer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 19243,
						"regions":
						{
						},
						"selection":
						[
							[
								10640,
								10640
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2043.0,
						"zoom_level": 1.0
					},
					"stack_index": 305,
					"type": "text"
				},
				{
					"buffer": 123,
					"file": "src/Falcor/Experimental/Scene/Lights/EnvProbe.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3717,
						"regions":
						{
						},
						"selection":
						[
							[
								3676,
								3676
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 204.0,
						"zoom_level": 1.0
					},
					"stack_index": 387,
					"type": "text"
				},
				{
					"buffer": 124,
					"file": "src/Mogwai/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1908,
						"regions":
						{
						},
						"selection":
						[
							[
								1509,
								1509
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 153.0,
						"zoom_level": 1.0
					},
					"stack_index": 141,
					"type": "text"
				},
				{
					"buffer": 125,
					"file": "src/Mogwai/Extensions/Capture/CaptureTrigger.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7579,
						"regions":
						{
						},
						"selection":
						[
							[
								7161,
								7161
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1381.0,
						"zoom_level": 1.0
					},
					"stack_index": 178,
					"type": "text"
				},
				{
					"buffer": 126,
					"file": "src/Mogwai/Extensions/Capture/VideoCapture.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9661,
						"regions":
						{
						},
						"selection":
						[
							[
								2501,
								2501
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 340.0,
						"zoom_level": 1.0
					},
					"stack_index": 170,
					"type": "text"
				},
				{
					"buffer": 127,
					"file": "src/Mogwai/Extensions/Capture/FrameCapture.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6569,
						"regions":
						{
						},
						"selection":
						[
							[
								5593,
								5593
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1653.0,
						"zoom_level": 1.0
					},
					"stack_index": 166,
					"type": "text"
				},
				{
					"buffer": 128,
					"file": "src/Mogwai/Extensions/Capture/FrameCapture.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2710,
						"regions":
						{
						},
						"selection":
						[
							[
								1765,
								1765
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 167,
					"type": "text"
				},
				{
					"buffer": 129,
					"file": "src/Tools/RenderGraphEditor/RenderGraphEditor.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 20776,
						"regions":
						{
						},
						"selection":
						[
							[
								20445,
								20445
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 292,
					"type": "text"
				},
				{
					"buffer": 130,
					"file": "src/Externals/dear_imgui_addons/imguinodegrapheditor/imguinodegrapheditor.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 47853,
						"regions":
						{
						},
						"selection":
						[
							[
								23852,
								23852
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 6018.0,
						"zoom_level": 1.0
					},
					"stack_index": 578,
					"type": "text"
				},
				{
					"buffer": 131,
					"file": "src/Tools/ImageCompare/ImageCompare.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14050,
						"regions":
						{
						},
						"selection":
						[
							[
								13223,
								13223
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 6069.0,
						"zoom_level": 1.0
					},
					"stack_index": 574,
					"type": "text"
				},
				{
					"buffer": 132,
					"file": "src/Mogwai/Mogwai.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8364,
						"regions":
						{
						},
						"selection":
						[
							[
								4167,
								4167
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1540.0,
						"zoom_level": 1.0
					},
					"stack_index": 171,
					"type": "text"
				},
				{
					"buffer": 133,
					"file": "src/Falcor/RenderGraph/RenderGraphImportExport.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6264,
						"regions":
						{
						},
						"selection":
						[
							[
								2379,
								2379
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2182.0,
						"zoom_level": 1.0
					},
					"stack_index": 576,
					"type": "text"
				},
				{
					"buffer": 134,
					"file": "src/Falcor/RenderGraph/ResourceCache.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8382,
						"regions":
						{
						},
						"selection":
						[
							[
								1783,
								1783
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 385,
					"type": "text"
				},
				{
					"buffer": 135,
					"file": "src/Falcor/Scene/Animation/AnimationController.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13034,
						"regions":
						{
						},
						"selection":
						[
							[
								11190,
								11190
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3009.0,
						"zoom_level": 1.0
					},
					"stack_index": 335,
					"type": "text"
				},
				{
					"buffer": 136,
					"file": "src/Falcor/RenderGraph/RenderPassReflection.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 12090,
						"regions":
						{
						},
						"selection":
						[
							[
								9644,
								9644
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2113.0,
						"zoom_level": 1.0
					},
					"stack_index": 289,
					"type": "text"
				},
				{
					"buffer": 137,
					"file": "src/Falcor/RenderGraph/RenderPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2471,
						"regions":
						{
						},
						"selection":
						[
							[
								2428,
								2428
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 357.0,
						"zoom_level": 1.0
					},
					"stack_index": 192,
					"type": "text"
				},
				{
					"buffer": 138,
					"file": "src/Falcor/RenderPasses/ResolvePass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2717,
						"regions":
						{
						},
						"selection":
						[
							[
								2610,
								2610
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 154.0,
						"zoom_level": 1.0
					},
					"stack_index": 214,
					"type": "text"
				},
				{
					"buffer": 139,
					"file": "src/Falcor/RenderPasses/ResolvePass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3142,
						"regions":
						{
						},
						"selection":
						[
							[
								2562,
								2562
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 341.0,
						"zoom_level": 1.0
					},
					"stack_index": 213,
					"type": "text"
				},
				{
					"buffer": 140,
					"file": "src/lava/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 919,
						"regions":
						{
						},
						"selection":
						[
							[
								848,
								848
							]
						],
						"settings":
						{
							"auto_name": "file( GLOB SOURCES",
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 114,
					"type": "text"
				},
				{
					"buffer": 141,
					"file": "src/Falcor/Scene/ParticleSystem/ParticleSystem.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10438,
						"regions":
						{
						},
						"selection":
						[
							[
								10145,
								10145
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3060.0,
						"zoom_level": 1.0
					},
					"stack_index": 378,
					"type": "text"
				},
				{
					"buffer": 142,
					"file": "src/Falcor/Scene/ParticleSystem/ParticleSystem.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 16405,
						"regions":
						{
						},
						"selection":
						[
							[
								7935,
								7935
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2235.0,
						"zoom_level": 1.0
					},
					"stack_index": 258,
					"type": "text"
				},
				{
					"buffer": 143,
					"file": "src/Falcor/Scene/HitInfo.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3622,
						"regions":
						{
						},
						"selection":
						[
							[
								3622,
								3622
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 355,
					"type": "text"
				},
				{
					"buffer": 144,
					"file": "src/Samples/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1201,
						"regions":
						{
						},
						"selection":
						[
							[
								1105,
								1105
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 573,
					"type": "text"
				},
				{
					"buffer": 145,
					"file": "src/Tools/RenderGraphEditor/RenderGraphEditor.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3325,
						"regions":
						{
						},
						"selection":
						[
							[
								1883,
								1883
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 357.0,
						"zoom_level": 1.0
					},
					"stack_index": 293,
					"type": "text"
				},
				{
					"buffer": 146,
					"file": "src/RenderPasses/DebugPasses/DebugPasses.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2422,
						"regions":
						{
						},
						"selection":
						[
							[
								2305,
								2305
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 189,
					"type": "text"
				},
				{
					"buffer": 147,
					"file": "src/RenderPasses/DebugPasses/SplitScreenPass/SplitScreenPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3241,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 357.0,
						"zoom_level": 1.0
					},
					"stack_index": 188,
					"type": "text"
				},
				{
					"buffer": 148,
					"file": "src/RenderPasses/DebugPasses/SplitScreenPass/SplitScreenPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6309,
						"regions":
						{
						},
						"selection":
						[
							[
								4169,
								4169
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1721.0,
						"zoom_level": 1.0
					},
					"stack_index": 187,
					"type": "text"
				},
				{
					"buffer": 149,
					"file": "src/RenderPasses/DebugPasses/SideBySidePass/SideBySidePass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2670,
						"regions":
						{
						},
						"selection":
						[
							[
								2484,
								2484
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 255.0,
						"zoom_level": 1.0
					},
					"stack_index": 185,
					"type": "text"
				},
				{
					"buffer": 150,
					"file": "src/RenderPasses/DebugPasses/SideBySidePass/SideBySidePass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3143,
						"regions":
						{
						},
						"selection":
						[
							[
								2603,
								2603
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 459.0,
						"zoom_level": 1.0
					},
					"stack_index": 186,
					"type": "text"
				},
				{
					"buffer": 151,
					"file": "src/RenderPasses/DebugPasses/InvalidPixelDetectionPass/InvalidPixelDetectionPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2841,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 357.0,
						"zoom_level": 1.0
					},
					"stack_index": 184,
					"type": "text"
				},
				{
					"buffer": 152,
					"file": "src/RenderPasses/CSM/CSM.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9053,
						"regions":
						{
						},
						"selection":
						[
							[
								9018,
								9018
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2587.0,
						"zoom_level": 1.0
					},
					"stack_index": 238,
					"type": "text"
				},
				{
					"buffer": 153,
					"file": "src/RenderPasses/CSM/CSM.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 35619,
						"regions":
						{
						},
						"selection":
						[
							[
								34358,
								34358
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3480.0,
						"zoom_level": 1.0
					},
					"stack_index": 237,
					"type": "text"
				},
				{
					"buffer": 154,
					"file": "src/Falcor/Utils/UI/Gui.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2501,
						"regions":
						{
						},
						"selection":
						[
							[
								1773,
								1773
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 580,
					"type": "text"
				},
				{
					"buffer": 155,
					"file": "src/Falcor/Utils/UI/TextRenderer.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2282,
						"regions":
						{
						},
						"selection":
						[
							[
								1872,
								1872
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 471,
					"type": "text"
				},
				{
					"buffer": 156,
					"file": "src/RenderPasses/ErrorMeasurePass/ErrorMeasurePass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 16583,
						"regions":
						{
						},
						"selection":
						[
							[
								4855,
								4855
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1245.0,
						"zoom_level": 1.0
					},
					"stack_index": 196,
					"type": "text"
				},
				{
					"buffer": 157,
					"file": "src/RenderPasses/GBuffer/VBuffer/VBufferRaster.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3145,
						"regions":
						{
						},
						"selection":
						[
							[
								2158,
								2158
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 357.0,
						"zoom_level": 1.0
					},
					"stack_index": 233,
					"type": "text"
				},
				{
					"buffer": 158,
					"file": "src/RenderPasses/ErrorMeasurePass/ErrorMeasurePass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4985,
						"regions":
						{
						},
						"selection":
						[
							[
								2890,
								2890
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 561.0,
						"zoom_level": 1.0
					},
					"stack_index": 197,
					"type": "text"
				},
				{
					"buffer": 159,
					"file": "src/RenderPasses/PixelInspectorPass/PixelInspectorPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3691,
						"regions":
						{
						},
						"selection":
						[
							[
								3621,
								3621
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 561.0,
						"zoom_level": 1.0
					},
					"stack_index": 206,
					"type": "text"
				},
				{
					"buffer": 160,
					"file": "src/Falcor/RenderGraph/RenderPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7147,
						"regions":
						{
						},
						"selection":
						[
							[
								7101,
								7101
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2056.0,
						"zoom_level": 1.0
					},
					"stack_index": 235,
					"type": "text"
				},
				{
					"buffer": 161,
					"file": "src/RenderPasses/PixelInspectorPass/PixelInspectorPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15137,
						"regions":
						{
						},
						"selection":
						[
							[
								3993,
								3993
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 837.0,
						"zoom_level": 1.0
					},
					"stack_index": 229,
					"type": "text"
				},
				{
					"buffer": 162,
					"file": "src/RenderPasses/SSAO/SSAO.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4594,
						"regions":
						{
						},
						"selection":
						[
							[
								4594,
								4594
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 612.0,
						"zoom_level": 1.0
					},
					"stack_index": 221,
					"type": "text"
				},
				{
					"buffer": 163,
					"file": "src/RenderPasses/SkyBox/SkyBox.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3515,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 51.0,
						"zoom_level": 1.0
					},
					"stack_index": 222,
					"type": "text"
				},
				{
					"buffer": 164,
					"file": "src/RenderPasses/SkyBox/SkyBox.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8117,
						"regions":
						{
						},
						"selection":
						[
							[
								2934,
								2934
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1275.0,
						"zoom_level": 1.0
					},
					"stack_index": 228,
					"type": "text"
				},
				{
					"buffer": 165,
					"file": "src/RenderPasses/Antialiasing/FXAA/FXAA.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3484,
						"regions":
						{
						},
						"selection":
						[
							[
								3429,
								3429
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 816.0,
						"zoom_level": 1.0
					},
					"stack_index": 203,
					"type": "text"
				},
				{
					"buffer": 166,
					"file": "src/RenderPasses/Antialiasing/TAA/TAA.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3271,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 102.0,
						"zoom_level": 1.0
					},
					"stack_index": 240,
					"type": "text"
				},
				{
					"buffer": 167,
					"file": "src/RenderPasses/Antialiasing/TAA/TAA.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5491,
						"regions":
						{
						},
						"selection":
						[
							[
								2176,
								2176
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 327.0,
						"zoom_level": 1.0
					},
					"stack_index": 198,
					"type": "text"
				},
				{
					"buffer": 168,
					"file": "src/RenderPasses/Antialiasing/FXAA/FXAA.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4663,
						"regions":
						{
						},
						"selection":
						[
							[
								2273,
								2273
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 408.0,
						"zoom_level": 1.0
					},
					"stack_index": 241,
					"type": "text"
				},
				{
					"buffer": 169,
					"file": "src/RenderPasses/SkyBox/Data/cube.obj",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 401,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 555,
					"type": "text"
				},
				{
					"buffer": 170,
					"file": "src/RenderPasses/ForwardLightingPass/ForwardLightingPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4770,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 102.0,
						"zoom_level": 1.0
					},
					"stack_index": 225,
					"type": "text"
				},
				{
					"buffer": 171,
					"file": "src/RenderPasses/ForwardLightingPass/ForwardLightingPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9795,
						"regions":
						{
						},
						"selection":
						[
							[
								3751,
								3751
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 716.0,
						"zoom_level": 1.0
					},
					"stack_index": 234,
					"type": "text"
				},
				{
					"buffer": 172,
					"file": "src/RenderPasses/ImageLoader/ImageLoader.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3059,
						"regions":
						{
						},
						"selection":
						[
							[
								2992,
								2992
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 408.0,
						"zoom_level": 1.0
					},
					"stack_index": 211,
					"type": "text"
				},
				{
					"buffer": 173,
					"file": "src/RenderPasses/ImageLoader/ImageLoader.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5146,
						"regions":
						{
						},
						"selection":
						[
							[
								3757,
								3757
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 616.0,
						"zoom_level": 1.0
					},
					"stack_index": 212,
					"type": "text"
				},
				{
					"buffer": 174,
					"file": "src/RenderPasses/ToneMapper/ToneMapper.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5743,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 209.0,
						"zoom_level": 1.0
					},
					"stack_index": 216,
					"type": "text"
				},
				{
					"buffer": 175,
					"file": "src/RenderPasses/ToneMapper/ToneMapper.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 16343,
						"regions":
						{
						},
						"selection":
						[
							[
								6646,
								6646
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1653.0,
						"zoom_level": 1.0
					},
					"stack_index": 205,
					"type": "text"
				},
				{
					"buffer": 176,
					"file": "src/RenderPasses/AccumulatePass/AccumulatePass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10962,
						"regions":
						{
						},
						"selection":
						[
							[
								4424,
								4424
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1005.0,
						"zoom_level": 1.0
					},
					"stack_index": 191,
					"type": "text"
				},
				{
					"buffer": 177,
					"file": "src/RenderPasses/GBuffer/GBufferBase.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3832,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 51.0,
						"zoom_level": 1.0
					},
					"stack_index": 204,
					"type": "text"
				},
				{
					"buffer": 178,
					"file": "src/RenderPasses/GBuffer/GBufferBase.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6981,
						"regions":
						{
						},
						"selection":
						[
							[
								5540,
								5540
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1674.0,
						"zoom_level": 1.0
					},
					"stack_index": 180,
					"type": "text"
				},
				{
					"buffer": 179,
					"file": "src/Falcor/Utils/SampleGenerators/HaltonSamplePattern.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2647,
						"regions":
						{
						},
						"selection":
						[
							[
								2237,
								2237
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 369,
					"type": "text"
				},
				{
					"buffer": 180,
					"file": "src/RenderPasses/GBuffer/VBuffer/VBufferRT.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2997,
						"regions":
						{
						},
						"selection":
						[
							[
								2997,
								2997
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 223,
					"type": "text"
				},
				{
					"buffer": 181,
					"file": "src/RenderPasses/GBuffer/GBuffer/GBufferRaster.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10032,
						"regions":
						{
						},
						"selection":
						[
							[
								4532,
								4532
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1428.0,
						"zoom_level": 1.0
					},
					"stack_index": 201,
					"type": "text"
				},
				{
					"buffer": 182,
					"file": "src/RenderPasses/GBuffer/GBuffer/GBufferRaster.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3272,
						"regions":
						{
						},
						"selection":
						[
							[
								2031,
								2031
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 256.0,
						"zoom_level": 1.0
					},
					"stack_index": 230,
					"type": "text"
				},
				{
					"buffer": 183,
					"file": "src/RenderPasses/GBuffer/GBuffer/GBuffer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3324,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 255.0,
						"zoom_level": 1.0
					},
					"stack_index": 200,
					"type": "text"
				},
				{
					"buffer": 184,
					"file": "src/RenderPasses/GBuffer/GBuffer/GBuffer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5817,
						"regions":
						{
						},
						"selection":
						[
							[
								5727,
								5727
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1313.0,
						"zoom_level": 1.0
					},
					"stack_index": 199,
					"type": "text"
				},
				{
					"buffer": 185,
					"file": "src/RenderPasses/DepthPass/DepthPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5276,
						"regions":
						{
						},
						"selection":
						[
							[
								3373,
								3373
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 686.0,
						"zoom_level": 1.0
					},
					"stack_index": 207,
					"type": "text"
				},
				{
					"buffer": 186,
					"file": "src/RenderPasses/Utils/GaussianBlur/GaussianBlur.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8197,
						"regions":
						{
						},
						"selection":
						[
							[
								2361,
								2361
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 412.0,
						"zoom_level": 1.0
					},
					"stack_index": 226,
					"type": "text"
				},
				{
					"buffer": 187,
					"file": "src/RenderPasses/SSAO/SSAO.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11813,
						"regions":
						{
						},
						"selection":
						[
							[
								3849,
								3849
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2452.0,
						"zoom_level": 1.0
					},
					"stack_index": 220,
					"type": "text"
				},
				{
					"buffer": 188,
					"file": "src/RenderPasses/Utils/GaussianBlur/GaussianBlur.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3739,
						"regions":
						{
						},
						"selection":
						[
							[
								3739,
								3739
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 918.0,
						"zoom_level": 1.0
					},
					"stack_index": 215,
					"type": "text"
				},
				{
					"buffer": 189,
					"file": "src/RenderPasses/Utils/Composite/Composite.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4310,
						"regions":
						{
						},
						"selection":
						[
							[
								2255,
								2255
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 157.0,
						"zoom_level": 1.0
					},
					"stack_index": 209,
					"type": "text"
				},
				{
					"buffer": 190,
					"file": "src/RenderPasses/TemporalDelayPass/TemporalDelayPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2910,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 306.0,
						"zoom_level": 1.0
					},
					"stack_index": 217,
					"type": "text"
				},
				{
					"buffer": 191,
					"file": "src/RenderPasses/Utils/Composite/Composite.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3098,
						"regions":
						{
						},
						"selection":
						[
							[
								3040,
								3040
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 408.0,
						"zoom_level": 1.0
					},
					"stack_index": 208,
					"type": "text"
				},
				{
					"buffer": 192,
					"file": "src/RenderPasses/DepthPass/DepthPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3513,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 236,
					"type": "text"
				},
				{
					"buffer": 193,
					"file": "src/RenderPasses/GBuffer/GBuffer/GBufferRT.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3771,
						"regions":
						{
						},
						"selection":
						[
							[
								1726,
								1726
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 51.0,
						"zoom_level": 1.0
					},
					"stack_index": 224,
					"type": "text"
				},
				{
					"buffer": 194,
					"file": "src/RenderPasses/GBuffer/VBuffer/VBufferRT.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5767,
						"regions":
						{
						},
						"selection":
						[
							[
								1771,
								1771
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 153.0,
						"zoom_level": 1.0
					},
					"stack_index": 581,
					"type": "text"
				},
				{
					"buffer": 195,
					"file": "src/RenderPasses/GBuffer/VBuffer/VBufferRaster.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5672,
						"regions":
						{
						},
						"selection":
						[
							[
								2920,
								2920
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 510.0,
						"zoom_level": 1.0
					},
					"stack_index": 232,
					"type": "text"
				},
				{
					"buffer": 196,
					"file": "src/RenderPasses/GBuffer/GBuffer/GBufferRT.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9623,
						"regions":
						{
						},
						"selection":
						[
							[
								9623,
								9623
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2721.0,
						"zoom_level": 1.0
					},
					"stack_index": 231,
					"type": "text"
				},
				{
					"buffer": 197,
					"file": "src/RenderPasses/Antialiasing/Antialiasing.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2797,
						"regions":
						{
						},
						"selection":
						[
							[
								2797,
								2797
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 255.0,
						"zoom_level": 1.0
					},
					"stack_index": 202,
					"type": "text"
				},
				{
					"buffer": 198,
					"file": "src/RenderPasses/BlitPass/BlitPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3995,
						"regions":
						{
						},
						"selection":
						[
							[
								3459,
								3459
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 867.0,
						"zoom_level": 1.0
					},
					"stack_index": 210,
					"type": "text"
				},
				{
					"buffer": 199,
					"file": "src/RenderPasses/BSDFViewer/BSDFViewer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4475,
						"regions":
						{
						},
						"selection":
						[
							[
								4420,
								4420
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1020.0,
						"zoom_level": 1.0
					},
					"stack_index": 194,
					"type": "text"
				},
				{
					"buffer": 200,
					"file": "src/RenderPasses/SVGFPass/SVGFPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 19004,
						"regions":
						{
						},
						"selection":
						[
							[
								4186,
								4186
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1518.0,
						"zoom_level": 1.0
					},
					"stack_index": 227,
					"type": "text"
				},
				{
					"buffer": 201,
					"file": "src/RenderPasses/TemporalDelayPass/TemporalDelayPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6201,
						"regions":
						{
						},
						"selection":
						[
							[
								2572,
								2572
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1245.0,
						"zoom_level": 1.0
					},
					"stack_index": 218,
					"type": "text"
				},
				{
					"buffer": 202,
					"file": "src/RenderPasses/SVGFPass/SVGFPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4664,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 219,
					"type": "text"
				},
				{
					"buffer": 203,
					"file": "src/RenderPasses/BSDFViewer/BSDFViewer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 18949,
						"regions":
						{
						},
						"selection":
						[
							[
								4324,
								4324
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1262.0,
						"zoom_level": 1.0
					},
					"stack_index": 195,
					"type": "text"
				},
				{
					"buffer": 204,
					"file": "src/RenderPasses/DebugPasses/ComparisonPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3286,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 408.0,
						"zoom_level": 1.0
					},
					"stack_index": 183,
					"type": "text"
				},
				{
					"buffer": 205,
					"file": "src/RenderPasses/DebugPasses/ComparisonPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5212,
						"regions":
						{
						},
						"selection":
						[
							[
								4572,
								4572
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 497.0,
						"zoom_level": 1.0
					},
					"stack_index": 182,
					"type": "text"
				},
				{
					"buffer": 206,
					"file": "src/RenderPasses/BlitPass/BlitPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2955,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 408.0,
						"zoom_level": 1.0
					},
					"stack_index": 239,
					"type": "text"
				},
				{
					"buffer": 207,
					"file": "src/RenderPasses/AccumulatePass/AccumulatePass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5448,
						"regions":
						{
						},
						"selection":
						[
							[
								3628,
								3628
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 561.0,
						"zoom_level": 1.0
					},
					"stack_index": 193,
					"type": "text"
				},
				{
					"buffer": 208,
					"file": "CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4659,
						"regions":
						{
						},
						"selection":
						[
							[
								4303,
								4303
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1683.0,
						"zoom_level": 1.0
					},
					"stack_index": 35,
					"type": "text"
				},
				{
					"buffer": 209,
					"file": "third_party/antlr4/runtime/Cpp/cmake/ExternalAntlr4Cpp.cmake",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5189,
						"regions":
						{
						},
						"selection":
						[
							[
								37,
								37
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 765.0,
						"zoom_level": 1.0
					},
					"stack_index": 23,
					"type": "text"
				},
				{
					"buffer": 210,
					"file": "contrib/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 425,
						"regions":
						{
						},
						"selection":
						[
							[
								396,
								396
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 61,
					"type": "text"
				},
				{
					"buffer": 211,
					"file": "contrib/houdini/soho/LSD.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 22594,
						"regions":
						{
						},
						"selection":
						[
							[
								547,
								547
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1887.0,
						"zoom_level": 1.0
					},
					"stack_index": 51,
					"type": "text"
				},
				{
					"buffer": 212,
					"file": "contrib/houdini/soho/LSDapi.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8206,
						"regions":
						{
						},
						"selection":
						[
							[
								8206,
								8206
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 14.0,
						"zoom_level": 1.0
					},
					"stack_index": 50,
					"type": "text"
				},
				{
					"buffer": 213,
					"file": "contrib/houdini/soho/LSDframe.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 64676,
						"regions":
						{
						},
						"selection":
						[
							[
								10845,
								10845
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3752.0,
						"zoom_level": 1.0
					},
					"stack_index": 53,
					"type": "text"
				},
				{
					"buffer": 214,
					"file": "contrib/houdini/soho/LSDgeo.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 40221,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 54,
					"type": "text"
				},
				{
					"buffer": 215,
					"file": "contrib/houdini/soho/LSDhooks.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1873,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 408.0,
						"zoom_level": 1.0
					},
					"stack_index": 52,
					"type": "text"
				},
				{
					"buffer": 216,
					"file": "contrib/houdini/soho/LSDmisc.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15491,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 714.0,
						"zoom_level": 1.0
					},
					"stack_index": 55,
					"type": "text"
				},
				{
					"buffer": 217,
					"file": "contrib/houdini/soho/LSDmantra.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 21971,
						"regions":
						{
						},
						"selection":
						[
							[
								9239,
								9239
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 6038.0,
						"zoom_level": 1.0
					},
					"stack_index": 49,
					"type": "text"
				},
				{
					"buffer": 218,
					"file": "contrib/houdini/soho/LSDparm.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 18230,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 60,
					"type": "text"
				},
				{
					"buffer": 219,
					"file": "contrib/houdini/soho/LSDptinst.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14292,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 204.0,
						"zoom_level": 1.0
					},
					"stack_index": 59,
					"type": "text"
				},
				{
					"buffer": 220,
					"file": "contrib/houdini/soho/LSDsettings.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 31540,
						"regions":
						{
						},
						"selection":
						[
							[
								31540,
								31540
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4.0,
						"zoom_level": 1.0
					},
					"stack_index": 56,
					"type": "text"
				},
				{
					"buffer": 221,
					"file": "contrib/houdini/soho/LSDsohogeo.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 90040,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 58,
					"type": "text"
				},
				{
					"buffer": 222,
					"file": "src/lava_cmd/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1270,
						"regions":
						{
						},
						"selection":
						[
							[
								1246,
								1246
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 80,
					"type": "text"
				},
				{
					"buffer": 223,
					"file": "src/lava_cmd/bin/lava",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 335,
						"regions":
						{
						},
						"selection":
						[
							[
								281,
								281
							]
						],
						"settings":
						{
							"syntax": "Packages/ShellScript/Bash.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 79,
					"type": "text"
				},
				{
					"buffer": 224,
					"file": "src/lava_cmd/bin/app_init.sh",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 274,
						"regions":
						{
						},
						"selection":
						[
							[
								40,
								40
							]
						],
						"settings":
						{
							"syntax": "Packages/ShellScript/Bash.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 78,
					"type": "text"
				},
				{
					"buffer": 225,
					"file": "src/houdini/ropLava/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 464,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"auto_name": "#project( My_HDK_Project )",
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 81,
					"type": "text"
				},
				{
					"buffer": 226,
					"file": "src/houdini/soho/LSD.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 22594,
						"regions":
						{
						},
						"selection":
						[
							[
								7704,
								7704
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 63,
					"type": "text"
				},
				{
					"buffer": 227,
					"file": "src/houdini/soho/LSDapi.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8206,
						"regions":
						{
						},
						"selection":
						[
							[
								373,
								373
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 74,
					"type": "text"
				},
				{
					"buffer": 228,
					"file": "src/houdini/soho/LSDframe.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 64676,
						"regions":
						{
						},
						"selection":
						[
							[
								1621,
								1621
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 535.0,
						"zoom_level": 1.0
					},
					"stack_index": 73,
					"type": "text"
				},
				{
					"buffer": 229,
					"file": "src/houdini/soho/LSDmisc.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15491,
						"regions":
						{
						},
						"selection":
						[
							[
								10861,
								10861
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 255.0,
						"zoom_level": 1.0
					},
					"stack_index": 65,
					"type": "text"
				},
				{
					"buffer": 230,
					"file": "src/houdini/soho/LSDsettings.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 31540,
						"regions":
						{
						},
						"selection":
						[
							[
								373,
								373
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 72,
					"type": "text"
				},
				{
					"buffer": 231,
					"file": "src/houdini/soho/LSDgeo.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 40221,
						"regions":
						{
						},
						"selection":
						[
							[
								365,
								365
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 71,
					"type": "text"
				},
				{
					"buffer": 232,
					"file": "src/houdini/soho/LSDhooks.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1873,
						"regions":
						{
						},
						"selection":
						[
							[
								1818,
								1818
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 637.0,
						"zoom_level": 1.0
					},
					"stack_index": 69,
					"type": "text"
				},
				{
					"buffer": 233,
					"file": "/opt/hfs17.5.460/houdini/soho/python2.7/IFD.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 22594,
						"regions":
						{
						},
						"selection":
						[
							[
								22594,
								22594
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 76,
					"type": "text"
				},
				{
					"buffer": 234,
					"file": "/opt/hfs17.5.460/houdini/soho/python2.7/IFDmisc.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15491,
						"regions":
						{
						},
						"selection":
						[
							[
								15491,
								15491
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 514.0,
						"zoom_level": 1.0
					},
					"stack_index": 66,
					"type": "text"
				},
				{
					"buffer": 235,
					"file": "src/houdini/soho/LSDmantra.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 21971,
						"regions":
						{
						},
						"selection":
						[
							[
								21673,
								21673
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 67,
					"type": "text"
				},
				{
					"buffer": 236,
					"file": "/opt/hfs17.5.460/houdini/soho/python2.7/IFDapi.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8206,
						"regions":
						{
						},
						"selection":
						[
							[
								8206,
								8206
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 153.0,
						"zoom_level": 1.0
					},
					"stack_index": 75,
					"type": "text"
				},
				{
					"buffer": 237,
					"file": "/opt/hfs17.5.460/houdini/soho/python2.7/IFDframe.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 64638,
						"regions":
						{
						},
						"selection":
						[
							[
								64638,
								64638
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 11237.0,
						"zoom_level": 1.0
					},
					"stack_index": 70,
					"type": "text"
				},
				{
					"buffer": 238,
					"file": "/opt/hfs17.5.460/houdini/soho/python2.7/IFDsettings.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 31540,
						"regions":
						{
						},
						"selection":
						[
							[
								31540,
								31540
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 13056.0,
						"zoom_level": 1.0
					},
					"stack_index": 68,
					"type": "text"
				},
				{
					"buffer": 239,
					"file": "src/houdini/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 355,
						"regions":
						{
						},
						"selection":
						[
							[
								355,
								355
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 62,
					"type": "text"
				},
				{
					"buffer": 240,
					"file": "src/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 457,
						"regions":
						{
						},
						"selection":
						[
							[
								268,
								268
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 36,
					"type": "text"
				},
				{
					"buffer": 241,
					"file": "src/houdini/ropLava/ROP_Lava.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3542,
						"regions":
						{
						},
						"selection":
						[
							[
								2711,
								2711
							]
						],
						"settings":
						{
							"auto_name": "#ifndef __ROP_Xenon_h__",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 612.0,
						"zoom_level": 1.0
					},
					"stack_index": 84,
					"type": "text"
				},
				{
					"buffer": 242,
					"file": "src/houdini/ropLava/ROP_Lava.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14145,
						"regions":
						{
						},
						"selection":
						[
							[
								10231,
								10231
							]
						],
						"settings":
						{
							"auto_name": "#include \"ROP_Xenon.h\"",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4028.0,
						"zoom_level": 1.0
					},
					"stack_index": 83,
					"type": "text"
				},
				{
					"buffer": 243,
					"file": "src/lava_lib/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3754,
						"regions":
						{
						},
						"selection":
						[
							[
								2741,
								2741
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 918.0,
						"zoom_level": 1.0
					},
					"stack_index": 14,
					"type": "text"
				},
				{
					"buffer": 244,
					"file": "src/lava_lib/readers/reader_lsd.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1743,
						"regions":
						{
						},
						"selection":
						[
							[
								1315,
								1315
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 459.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 245,
					"file": "src/lava_lib/readers/grammar_bgeo.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6414,
						"regions":
						{
						},
						"selection":
						[
							[
								3644,
								3644
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1683.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 246,
					"file": "src/lava_lib/readers/grammar_lsd.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 21928,
						"regions":
						{
						},
						"selection":
						[
							[
								4149,
								4149
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2720.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 247,
					"file": "src/lava_lib/readers/backtracking.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1000,
						"regions":
						{
						},
						"selection":
						[
							[
								111,
								111
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 248,
					"file": "/opt/lava/test/simple_inline_ascii.lsd",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 201,
						"regions":
						{
						},
						"selection":
						[
							[
								173,
								173
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 249,
					"file": "/opt/lava/test/test_ascii.lsd",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3912,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 714.0,
						"zoom_level": 1.0
					},
					"stack_index": 12,
					"type": "text"
				},
				{
					"buffer": 250,
					"file": "/opt/lava/test/lava.lsd",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3518,
						"regions":
						{
						},
						"selection":
						[
							[
								1840,
								1840
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 204.0,
						"zoom_level": 1.0
					},
					"stack_index": 13,
					"type": "text"
				},
				{
					"buffer": 251,
					"file": "/opt/lava/test/test_inline_binary.lsd",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 25330,
						"regions":
						{
						},
						"selection":
						[
							[
								807,
								807
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 4182.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 252,
					"file": "src/lava_lib/LSD.g4",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2123,
						"regions":
						{
						},
						"selection":
						[
							[
								1152,
								1152
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 3,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 153.0,
						"zoom_level": 1.0
					},
					"stack_index": 21,
					"type": "text"
				},
				{
					"buffer": 253,
					"file": "src/lava_lib/loaders/renderer_iface_lsd.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 237,
						"regions":
						{
						},
						"selection":
						[
							[
								213,
								213
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 42,
					"type": "text"
				},
				{
					"buffer": 254,
					"file": "src/lava_lib/loaders/loader_base.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 589,
						"regions":
						{
						},
						"selection":
						[
							[
								523,
								523
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 40,
					"type": "text"
				},
				{
					"buffer": 255,
					"file": "src/lava_lib/loaders/loader_base.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 605,
						"regions":
						{
						},
						"selection":
						[
							[
								431,
								431
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 41,
					"type": "text"
				},
				{
					"buffer": 256,
					"file": "third_party/ri_display/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 681,
						"regions":
						{
						},
						"selection":
						[
							[
								286,
								286
							]
						],
						"settings":
						{
							"auto_name": "set (SOURCES",
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 44,
					"type": "text"
				},
				{
					"buffer": 257,
					"file": "src/lava_cmd/lava_cmd.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6608,
						"regions":
						{
						},
						"selection":
						[
							[
								6466,
								6466
							]
						],
						"settings":
						{
							"auto_name": "#include <fstream>",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2054.0,
						"zoom_level": 1.0
					},
					"stack_index": 22,
					"type": "text"
				},
				{
					"buffer": 258,
					"file": "src/lava_lib/loaders/reader_lsd.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1025,
						"regions":
						{
						},
						"selection":
						[
							[
								392,
								392
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 39,
					"type": "text"
				},
				{
					"buffer": 259,
					"file": "src/lava_lib/loaders/reader_lsd.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3705,
						"regions":
						{
						},
						"selection":
						[
							[
								3664,
								3664
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1530.0,
						"zoom_level": 1.0
					},
					"stack_index": 38,
					"type": "text"
				},
				{
					"buffer": 260,
					"file": "third_party/ri_display/d_houdini.C",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 32420,
						"regions":
						{
						},
						"selection":
						[
							[
								657,
								657
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 37,
					"type": "text"
				},
				{
					"buffer": 261,
					"file": "src/lava_lib/scene_readers_registry.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 909,
						"regions":
						{
						},
						"selection":
						[
							[
								830,
								830
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 34,
					"type": "text"
				},
				{
					"buffer": 262,
					"file": "src/lava_lib/scene_reader_base.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1036,
						"regions":
						{
						},
						"selection":
						[
							[
								965,
								965
							]
						],
						"settings":
						{
							"auto_name": "#ifndef __SCN_IOTranslator_h__",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 11,
					"type": "text"
				},
				{
					"buffer": 263,
					"file": "src/lava_lib/readers/reader_lsd.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1252,
						"regions":
						{
						},
						"selection":
						[
							[
								917,
								917
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"type": "text"
				},
				{
					"buffer": 264,
					"file": "src/lava_lib/readers/input_stream.h.bak",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4694,
						"regions":
						{
						},
						"selection":
						[
							[
								2576,
								2576
							]
						],
						"settings":
						{
							"auto_name": "/* Copyright (c) 2012-2017 The ANTLR Project. All",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 164.0,
						"zoom_level": 1.0
					},
					"stack_index": 31,
					"type": "text"
				},
				{
					"buffer": 265,
					"file": "src/lava_lib/readers/input_stream.cpp.bak",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6683,
						"regions":
						{
						},
						"selection":
						[
							[
								3209,
								3209
							]
						],
						"settings":
						{
							"auto_name": "/* Copyright (c) 2012-2017 The ANTLR Project. All",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1632.0,
						"zoom_level": 1.0
					},
					"stack_index": 30,
					"type": "text"
				},
				{
					"buffer": 266,
					"file": "src/lava_lib/readers/input_stream.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6041,
						"regions":
						{
						},
						"selection":
						[
							[
								314,
								314
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 26,
					"type": "text"
				},
				{
					"buffer": 267,
					"file": "src/lava_lib/readers/input_stream.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4608,
						"regions":
						{
						},
						"selection":
						[
							[
								1124,
								1124
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 816.0,
						"zoom_level": 1.0
					},
					"stack_index": 29,
					"type": "text"
				},
				{
					"buffer": 268,
					"file": "src/lava_lib/readers/reader_lsd.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1743,
						"regions":
						{
						},
						"selection":
						[
							[
								584,
								584
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1174.0,
						"zoom_level": 1.0
					},
					"stack_index": 25,
					"type": "text"
				},
				{
					"buffer": 269,
					"file": "src/lava_lib/_bak/syntax_lsd.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5510,
						"regions":
						{
						},
						"selection":
						[
							[
								4830,
								4830
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 969.0,
						"zoom_level": 1.0
					},
					"stack_index": 24,
					"type": "text"
				},
				{
					"buffer": 270,
					"file": "/home/max/lava.lsd",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 29,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 32,
					"type": "text"
				},
				{
					"buffer": 271,
					"file": "src/lava_lib/renderer_iface_base.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 543,
						"regions":
						{
						},
						"selection":
						[
							[
								17,
								17
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 272,
					"file": "src/lava_lib/renderer.cpp",
					"semi_transient": true,
					"settings":
					{
						"buffer_size": 586,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 273,
					"file": "src/lava_lib/renderer_iface_base.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 663,
						"regions":
						{
						},
						"selection":
						[
							[
								432,
								432
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				},
				{
					"buffer": 274,
					"file": "src/lava_lib/scene_reader_base.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 502,
						"regions":
						{
						},
						"selection":
						[
							[
								426,
								426
							]
						],
						"settings":
						{
							"auto_name": "#include \"SCN_IOTranslator.h\"",
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 10,
					"type": "text"
				},
				{
					"buffer": 275,
					"file": "src/lava_lib/scene_readers_registry.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 939,
						"regions":
						{
						},
						"selection":
						[
							[
								828,
								828
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 33,
					"type": "text"
				},
				{
					"buffer": 276,
					"file": "src/lava_lib/types.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7007,
						"regions":
						{
						},
						"selection":
						[
							[
								6973,
								6973
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 2754.0,
						"zoom_level": 1.0
					},
					"stack_index": 64,
					"type": "text"
				},
				{
					"buffer": 277,
					"file": "src/lava_lib/pymodule/pymodule.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 694,
						"regions":
						{
						},
						"selection":
						[
							[
								369,
								369
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 45,
					"type": "text"
				},
				{
					"buffer": 278,
					"file": "src/lava_lib/display.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 923,
						"regions":
						{
						},
						"selection":
						[
							[
								393,
								393
							]
						],
						"settings":
						{
							"auto_name": "#ifndef SRC_LAVA_LIB_H_",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 57,
					"type": "text"
				},
				{
					"buffer": 279,
					"file": "src/lava_utils_lib/string.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 548,
						"regions":
						{
						},
						"selection":
						[
							[
								510,
								510
							]
						],
						"settings":
						{
							"auto_name": "#ifndef LAVA_UTILS_LOGGING_H_",
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 15,
					"type": "text"
				},
				{
					"buffer": 280,
					"file": "src/lava_utils_lib/string.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 308,
						"regions":
						{
						},
						"selection":
						[
							[
								191,
								191
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 16,
					"type": "text"
				},
				{
					"buffer": 281,
					"file": "src/lava_utils_lib/logging.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2672,
						"regions":
						{
						},
						"selection":
						[
							[
								586,
								586
							]
						],
						"settings":
						{
							"auto_name": "#include <fstream>",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 718.0,
						"zoom_level": 1.0
					},
					"stack_index": 19,
					"type": "text"
				},
				{
					"buffer": 282,
					"file": "src/pxr/imaging/plugin/hdLava/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1655,
						"regions":
						{
						},
						"selection":
						[
							[
								911,
								911
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 357.0,
						"zoom_level": 1.0
					},
					"stack_index": 115,
					"type": "text"
				},
				{
					"buffer": 283,
					"file": "src/pxr/imaging/plugin/hdLava/renderBuffer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2211,
						"regions":
						{
						},
						"selection":
						[
							[
								871,
								871
							]
						],
						"settings":
						{
							"auto_name": "/*************************************************",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 100,
					"type": "text"
				},
				{
					"buffer": 284,
					"file": "src/pxr/imaging/plugin/hdLava/renderBuffer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3578,
						"regions":
						{
						},
						"selection":
						[
							[
								1268,
								1268
							]
						],
						"settings":
						{
							"auto_name": "/*************************************************",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 446.0,
						"zoom_level": 1.0
					},
					"stack_index": 98,
					"type": "text"
				},
				{
					"buffer": 285,
					"file": "src/pxr/imaging/plugin/hdLava/renderThread.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4673,
						"regions":
						{
						},
						"selection":
						[
							[
								2719,
								2719
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 886.0,
						"zoom_level": 1.0
					},
					"stack_index": 93,
					"type": "text"
				},
				{
					"buffer": 286,
					"file": "src/pxr/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 526,
						"regions":
						{
						},
						"selection":
						[
							[
								287,
								287
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 123,
					"type": "text"
				},
				{
					"buffer": 287,
					"file": "cmake/modules/FindTBB.cmake",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 12566,
						"regions":
						{
						},
						"selection":
						[
							[
								9627,
								9627
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4488.0,
						"zoom_level": 1.0
					},
					"stack_index": 139,
					"type": "text"
				},
				{
					"buffer": 288,
					"file": "cmake/defaults/Packages.cmake",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7991,
						"regions":
						{
						},
						"selection":
						[
							[
								4095,
								4095
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1377.0,
						"zoom_level": 1.0
					},
					"stack_index": 138,
					"type": "text"
				},
				{
					"buffer": 289,
					"file": "src/pxr/imaging/plugin/hdLava/renderDelegate.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3434,
						"regions":
						{
						},
						"selection":
						[
							[
								2681,
								2681
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 408.0,
						"zoom_level": 1.0
					},
					"stack_index": 88,
					"type": "text"
				},
				{
					"buffer": 290,
					"file": "src/pxr/imaging/plugin/hdLava/rendererPlugin.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 975,
						"regions":
						{
						},
						"selection":
						[
							[
								316,
								316
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 96,
					"type": "text"
				},
				{
					"buffer": 291,
					"file": "build/include/src/pxr/imaging/plugin/hdLava/renderDelegate.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3512,
						"regions":
						{
						},
						"selection":
						[
							[
								345,
								345
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 121,
					"type": "text"
				},
				{
					"buffer": 292,
					"file": "src/pxr/imaging/plugin/hdLava/renderParam.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1740,
						"regions":
						{
						},
						"selection":
						[
							[
								715,
								715
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 99,
					"type": "text"
				},
				{
					"buffer": 293,
					"file": "src/pxr/imaging/plugin/hdLava/renderPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4716,
						"regions":
						{
						},
						"selection":
						[
							[
								865,
								865
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1683.0,
						"zoom_level": 1.0
					},
					"stack_index": 95,
					"type": "text"
				},
				{
					"buffer": 294,
					"file": "src/pxr/imaging/plugin/hdLava/camera.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2562,
						"regions":
						{
						},
						"selection":
						[
							[
								2562,
								2562
							]
						],
						"settings":
						{
							"auto_name": "/*************************************************",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 128,
					"type": "text"
				},
				{
					"buffer": 295,
					"file": "src/pxr/imaging/plugin/hdLava/camera.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6546,
						"regions":
						{
						},
						"selection":
						[
							[
								2739,
								2739
							]
						],
						"settings":
						{
							"auto_name": "/*************************************************",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 102.0,
						"zoom_level": 1.0
					},
					"stack_index": 137,
					"type": "text"
				},
				{
					"buffer": 296,
					"file": "src/pxr/imaging/plugin/hdLava/renderParam.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1800,
						"regions":
						{
						},
						"selection":
						[
							[
								435,
								435
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 94,
					"type": "text"
				},
				{
					"buffer": 297,
					"file": "src/pxr/imaging/plugin/hdLava/renderDelegate.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14452,
						"regions":
						{
						},
						"selection":
						[
							[
								4739,
								4739
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2399.0,
						"zoom_level": 1.0
					},
					"stack_index": 92,
					"type": "text"
				},
				{
					"buffer": 298,
					"file": "build/include/src/pxr/imaging/plugin/hdLava/renderBuffer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2287,
						"regions":
						{
						},
						"selection":
						[
							[
								929,
								929
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 105,
					"type": "text"
				},
				{
					"buffer": 299,
					"file": "src/pxr/imaging/plugin/hdLava/rendererPlugin.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1864,
						"regions":
						{
						},
						"selection":
						[
							[
								1504,
								1504
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 101,
					"type": "text"
				},
				{
					"buffer": 300,
					"file": "src/pxr/imaging/plugin/hdLava/lavaApiAov.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6577,
						"regions":
						{
						},
						"selection":
						[
							[
								4954,
								4954
							]
						],
						"settings":
						{
							"auto_name": "/*************************************************",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1479.0,
						"zoom_level": 1.0
					},
					"stack_index": 129,
					"type": "text"
				},
				{
					"buffer": 301,
					"file": "src/pxr/imaging/plugin/hdLava/lavaApiAov.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 20630,
						"regions":
						{
						},
						"selection":
						[
							[
								794,
								794
							]
						],
						"settings":
						{
							"auto_name": "/*************************************************",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 459.0,
						"zoom_level": 1.0
					},
					"stack_index": 90,
					"type": "text"
				},
				{
					"buffer": 302,
					"file": "src/pxr/imaging/plugin/hdLava/lavaApiFramebuffer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4795,
						"regions":
						{
						},
						"selection":
						[
							[
								4000,
								4000
							]
						],
						"settings":
						{
							"auto_name": "/*************************************************",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1943.0,
						"zoom_level": 1.0
					},
					"stack_index": 103,
					"type": "text"
				},
				{
					"buffer": 303,
					"file": "src/pxr/imaging/plugin/hdLava/aovDescriptor.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3408,
						"regions":
						{
						},
						"selection":
						[
							[
								943,
								943
							]
						],
						"settings":
						{
							"auto_name": "/*************************************************",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 969.0,
						"zoom_level": 1.0
					},
					"stack_index": 130,
					"type": "text"
				},
				{
					"buffer": 304,
					"file": "src/pxr/imaging/plugin/hdLava/aovDescriptor.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9187,
						"regions":
						{
						},
						"selection":
						[
							[
								999,
								999
							]
						],
						"settings":
						{
							"auto_name": "/*************************************************",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 131,
					"type": "text"
				},
				{
					"buffer": 305,
					"file": "src/pxr/imaging/plugin/hdLava/error.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4955,
						"regions":
						{
						},
						"selection":
						[
							[
								2405,
								2405
							]
						],
						"settings":
						{
							"auto_name": "/*************************************************",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 357.0,
						"zoom_level": 1.0
					},
					"stack_index": 126,
					"type": "text"
				},
				{
					"buffer": 306,
					"file": "src/lava/renderer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 590,
						"regions":
						{
						},
						"selection":
						[
							[
								389,
								389
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 91,
					"type": "text"
				},
				{
					"buffer": 307,
					"file": "src/lava/renderer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 533,
						"regions":
						{
						},
						"selection":
						[
							[
								392,
								392
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 102,
					"type": "text"
				},
				{
					"buffer": 308,
					"file": "src/pxr/imaging/plugin/hdLava/debugCodes.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1141,
						"regions":
						{
						},
						"selection":
						[
							[
								1013,
								1013
							]
						],
						"settings":
						{
							"auto_name": "/*************************************************",
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 134,
					"type": "text"
				},
				{
					"buffer": 309,
					"file": "src/pxr/imaging/plugin/hdLava/debugCodes.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1010,
						"regions":
						{
						},
						"selection":
						[
							[
								1009,
								1009
							]
						],
						"settings":
						{
							"auto_name": "/*************************************************",
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 133,
					"type": "text"
				},
				{
					"buffer": 310,
					"file": "src/pxr/imaging/plugin/hdLava/lavaApiFramebuffer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2080,
						"regions":
						{
						},
						"selection":
						[
							[
								829,
								829
							]
						],
						"settings":
						{
							"auto_name": "/*************************************************",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 104,
					"type": "text"
				},
				{
					"buffer": 311,
					"file": "src/pxr/imaging/plugin/hdLava/config.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 26047,
						"regions":
						{
						},
						"selection":
						[
							[
								23,
								23
							]
						],
						"settings":
						{
							"auto_name": "//",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 7243.0,
						"zoom_level": 1.0
					},
					"stack_index": 119,
					"type": "text"
				},
				{
					"buffer": 312,
					"file": "src/pxr/imaging/plugin/hdLava/config.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7104,
						"regions":
						{
						},
						"selection":
						[
							[
								188,
								188
							]
						],
						"settings":
						{
							"auto_name": "//",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2907.0,
						"zoom_level": 1.0
					},
					"stack_index": 120,
					"type": "text"
				},
				{
					"buffer": 313,
					"file": "src/pxr/imaging/plugin/hdLava/renderPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 852,
						"regions":
						{
						},
						"selection":
						[
							[
								477,
								477
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 97,
					"type": "text"
				},
				{
					"buffer": 314,
					"file": "src/pxr/imaging/plugin/hdLava/lavaApi.h.old",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6854,
						"regions":
						{
						},
						"selection":
						[
							[
								6384,
								6384
							]
						],
						"settings":
						{
							"auto_name": "/*************************************************",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1845.0,
						"zoom_level": 1.0
					},
					"stack_index": 89,
					"type": "text"
				},
				{
					"buffer": 315,
					"file": "src/pxr/imaging/plugin/hdLava/lavaApi.cpp.old",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 113965,
						"regions":
						{
						},
						"selection":
						[
							[
								46746,
								46746
							]
						],
						"settings":
						{
							"auto_name": "/*************************************************",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 18871.0,
						"zoom_level": 1.0
					},
					"stack_index": 85,
					"type": "text"
				},
				{
					"buffer": 316,
					"file": "third_party/USD/pxr/base/tf/diagnosticLite.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6024,
						"regions":
						{
						},
						"selection":
						[
							[
								4923,
								4923
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1295.0,
						"zoom_level": 1.0
					},
					"stack_index": 122,
					"type": "text"
				},
				{
					"buffer": 317,
					"file": "src/pxr/imaging/plugin/hdLava/lavaApi.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2703,
						"regions":
						{
						},
						"selection":
						[
							[
								2552,
								2552
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 663.0,
						"zoom_level": 1.0
					},
					"stack_index": 87,
					"type": "text"
				},
				{
					"buffer": 318,
					"file": "src/pxr/imaging/plugin/hdLava/lavaApi.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5811,
						"regions":
						{
						},
						"selection":
						[
							[
								4789,
								4789
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2450.0,
						"zoom_level": 1.0
					},
					"stack_index": 86,
					"type": "text"
				},
				{
					"buffer": 319,
					"file": "src/Falcor/Utils/StringUtils.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 12635,
						"regions":
						{
						},
						"selection":
						[
							[
								12119,
								12119
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4699.0,
						"zoom_level": 1.0
					},
					"stack_index": 494,
					"type": "text"
				},
				{
					"buffer": 320,
					"file": "src/Samples/ModelViewer/ModelViewer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9979,
						"regions":
						{
						},
						"selection":
						[
							[
								3916,
								3916
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2397.0,
						"zoom_level": 1.0
					},
					"stack_index": 569,
					"type": "text"
				},
				{
					"buffer": 321,
					"file": "src/Samples/ModelViewer/ModelViewer.ps.slang.bak",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2408,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 558,
					"type": "text"
				},
				{
					"buffer": 322,
					"file": "src/Samples/ModelViewer/ModelViewer.ps.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2391,
						"regions":
						{
						},
						"selection":
						[
							[
								2383,
								2383
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 556,
					"type": "text"
				},
				{
					"buffer": 323,
					"file": "src/Falcor/Scene/Lights/LightProbeIntegration.ps.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7921,
						"regions":
						{
						},
						"selection":
						[
							[
								1944,
								1944
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 116.0,
						"zoom_level": 1.0
					},
					"stack_index": 566,
					"type": "text"
				},
				{
					"buffer": 324,
					"file": "src/Tools/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1429,
						"regions":
						{
						},
						"selection":
						[
							[
								1133,
								1133
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 564,
					"type": "text"
				},
				{
					"buffer": 325,
					"file": "src/Samples/ShaderToy/ShaderToy.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4229,
						"regions":
						{
						},
						"selection":
						[
							[
								4138,
								4138
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 482.0,
						"zoom_level": 1.0
					},
					"stack_index": 565,
					"type": "text"
				},
				{
					"buffer": 326,
					"file": "src/Falcor/RenderGraph/BasePasses/FullScreenPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5700,
						"regions":
						{
						},
						"selection":
						[
							[
								4350,
								4350
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1555.0,
						"zoom_level": 1.0
					},
					"stack_index": 251,
					"type": "text"
				},
				{
					"buffer": 327,
					"file": "src/Falcor/RenderGraph/BasePasses/ComputePass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6377,
						"regions":
						{
						},
						"selection":
						[
							[
								6233,
								6233
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1326.0,
						"zoom_level": 1.0
					},
					"stack_index": 248,
					"type": "text"
				},
				{
					"buffer": 328,
					"file": "src/Falcor/RenderGraph/BasePasses/FullScreenPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4028,
						"regions":
						{
						},
						"selection":
						[
							[
								3859,
								3859
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 475.0,
						"zoom_level": 1.0
					},
					"stack_index": 246,
					"type": "text"
				},
				{
					"buffer": 329,
					"file": "src/Falcor/RenderGraph/BasePasses/ComputePass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4043,
						"regions":
						{
						},
						"selection":
						[
							[
								2711,
								2711
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 226.0,
						"zoom_level": 1.0
					},
					"stack_index": 247,
					"type": "text"
				},
				{
					"buffer": 330,
					"file": "src/Falcor/RenderGraph/BasePasses/BaseGraphicsPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2824,
						"regions":
						{
						},
						"selection":
						[
							[
								1949,
								1949
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 290.0,
						"zoom_level": 1.0
					},
					"stack_index": 249,
					"type": "text"
				},
				{
					"buffer": 331,
					"file": "src/Falcor/Utils/Timing/FrameRate.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3811,
						"regions":
						{
						},
						"selection":
						[
							[
								2009,
								2009
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 87.0,
						"zoom_level": 1.0
					},
					"stack_index": 344,
					"type": "text"
				},
				{
					"buffer": 332,
					"file": "src/Falcor/Utils/Timing/FrameRate.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2265,
						"regions":
						{
						},
						"selection":
						[
							[
								1815,
								1815
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 360,
					"type": "text"
				},
				{
					"buffer": 333,
					"file": "src/Falcor/Experimental/Scene/Lights/LightBVHSampler.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6356,
						"regions":
						{
						},
						"selection":
						[
							[
								2964,
								2964
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 816.0,
						"zoom_level": 1.0
					},
					"stack_index": 588,
					"type": "text"
				},
				{
					"buffer": 334,
					"file": "src/Falcor/Experimental/Scene/Lights/LightBVHSampler.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7714,
						"regions":
						{
						},
						"selection":
						[
							[
								7713,
								7713
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1840.0,
						"zoom_level": 1.0
					},
					"stack_index": 339,
					"type": "text"
				},
				{
					"buffer": 335,
					"file": "src/Falcor/Experimental/Scene/Lights/LightCollection.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 29489,
						"regions":
						{
						},
						"selection":
						[
							[
								2921,
								2921
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 422.0,
						"zoom_level": 1.0
					},
					"stack_index": 338,
					"type": "text"
				},
				{
					"buffer": 336,
					"file": "src/Falcor/RenderGraph/BasePasses/BaseGraphicsPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3726,
						"regions":
						{
						},
						"selection":
						[
							[
								3594,
								3594
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 681.0,
						"zoom_level": 1.0
					},
					"stack_index": 250,
					"type": "text"
				},
				{
					"buffer": 337,
					"file": "src/Falcor/Experimental/Scene/Lights/LightCollection.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 12783,
						"regions":
						{
						},
						"selection":
						[
							[
								2005,
								2005
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 391,
					"type": "text"
				},
				{
					"buffer": 338,
					"file": "src/Falcor/Core/BufferTypes/ParameterBlock.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 67261,
						"regions":
						{
						},
						"selection":
						[
							[
								9976,
								9976
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3869.0,
						"zoom_level": 1.0
					},
					"stack_index": 255,
					"type": "text"
				},
				{
					"buffer": 339,
					"file": "src/RenderPasses/BSDFViewer/BSDFViewer.cs.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15202,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 105.0,
						"zoom_level": 1.0
					},
					"stack_index": 486,
					"type": "text"
				},
				{
					"buffer": 340,
					"file": "src/Tools/FalcorTest/Tests/Core/BufferTests.cs.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2850,
						"regions":
						{
						},
						"selection":
						[
							[
								2587,
								2587
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 367.0,
						"zoom_level": 1.0
					},
					"stack_index": 532,
					"type": "text"
				},
				{
					"buffer": 341,
					"file": "src/Falcor/Core/Program/ShaderVar.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15515,
						"regions":
						{
						},
						"selection":
						[
							[
								12657,
								12657
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4745.0,
						"zoom_level": 1.0
					},
					"stack_index": 568,
					"type": "text"
				},
				{
					"buffer": 342,
					"file": "src/Falcor/Scene/Lights/LightProbe.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11503,
						"regions":
						{
						},
						"selection":
						[
							[
								6471,
								6471
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3264.0,
						"zoom_level": 1.0
					},
					"stack_index": 380,
					"type": "text"
				},
				{
					"buffer": 343,
					"file": "src/Falcor/Scene/Lights/LightProbe.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7813,
						"regions":
						{
						},
						"selection":
						[
							[
								3374,
								3374
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 765.0,
						"zoom_level": 1.0
					},
					"stack_index": 379,
					"type": "text"
				},
				{
					"buffer": 344,
					"file": "src/Falcor/RenderGraph/BasePasses/RasterScenePass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3402,
						"regions":
						{
						},
						"selection":
						[
							[
								1991,
								1991
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 255.0,
						"zoom_level": 1.0
					},
					"stack_index": 243,
					"type": "text"
				},
				{
					"buffer": 345,
					"file": "src/Falcor/RenderGraph/RenderGraphCompiler.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 18153,
						"regions":
						{
						},
						"selection":
						[
							[
								1729,
								1729
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 366.0,
						"zoom_level": 1.0
					},
					"stack_index": 386,
					"type": "text"
				},
				{
					"buffer": 346,
					"file": "src/Falcor/RenderGraph/RenderGraph.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 30158,
						"regions":
						{
						},
						"selection":
						[
							[
								2489,
								2489
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 341.0,
						"zoom_level": 1.0
					},
					"stack_index": 267,
					"type": "text"
				},
				{
					"buffer": 347,
					"file": "src/Falcor/RenderGraph/RenderGraphExe.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4177,
						"regions":
						{
						},
						"selection":
						[
							[
								3590,
								3590
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 412.0,
						"zoom_level": 1.0
					},
					"stack_index": 336,
					"type": "text"
				},
				{
					"buffer": 348,
					"file": "src/Falcor/RenderGraph/RenderGraphExe.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4072,
						"regions":
						{
						},
						"selection":
						[
							[
								2042,
								2042
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 337,
					"type": "text"
				},
				{
					"buffer": 349,
					"file": "src/Falcor/Utils/Scripting/Dictionary.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4523,
						"regions":
						{
						},
						"selection":
						[
							[
								2654,
								2654
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 583.0,
						"zoom_level": 1.0
					},
					"stack_index": 112,
					"type": "text"
				},
				{
					"buffer": 350,
					"file": "src/Falcor/RenderGraph/RenderGraphUI.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 64727,
						"regions":
						{
						},
						"selection":
						[
							[
								24936,
								24936
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 9384.0,
						"zoom_level": 1.0
					},
					"stack_index": 179,
					"type": "text"
				},
				{
					"buffer": 351,
					"file": "src/Falcor/Utils/Debug/PixelDebug.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9625,
						"regions":
						{
						},
						"selection":
						[
							[
								1814,
								1814
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1683.0,
						"zoom_level": 1.0
					},
					"stack_index": 364,
					"type": "text"
				},
				{
					"buffer": 352,
					"file": "src/Falcor/Utils/Algorithm/ParallelReduction.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6148,
						"regions":
						{
						},
						"selection":
						[
							[
								1729,
								1729
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 536.0,
						"zoom_level": 1.0
					},
					"stack_index": 332,
					"type": "text"
				},
				{
					"buffer": 353,
					"file": "src/Tools/FalcorTest/Tests/Utils/ParallelReductionTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11656,
						"regions":
						{
						},
						"selection":
						[
							[
								9905,
								9905
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3213.0,
						"zoom_level": 1.0
					},
					"stack_index": 508,
					"type": "text"
				},
				{
					"buffer": 354,
					"file": "src/Tools/FalcorTest/Tests/Utils/PrefixSumTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4850,
						"regions":
						{
						},
						"selection":
						[
							[
								4793,
								4793
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1173.0,
						"zoom_level": 1.0
					},
					"stack_index": 503,
					"type": "text"
				},
				{
					"buffer": 355,
					"file": "src/Falcor/Utils/Algorithm/PrefixSum.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7112,
						"regions":
						{
						},
						"selection":
						[
							[
								3289,
								3289
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 379.0,
						"zoom_level": 1.0
					},
					"stack_index": 331,
					"type": "text"
				},
				{
					"buffer": 356,
					"file": "src/Falcor/Utils/Algorithm/BitonicSort.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4470,
						"regions":
						{
						},
						"selection":
						[
							[
								2970,
								2970
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 906.0,
						"zoom_level": 1.0
					},
					"stack_index": 334,
					"type": "text"
				},
				{
					"buffer": 357,
					"file": "src/Falcor/Utils/Algorithm/ComputeParallelReduction.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4901,
						"regions":
						{
						},
						"selection":
						[
							[
								1906,
								1906
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 612.0,
						"zoom_level": 1.0
					},
					"stack_index": 370,
					"type": "text"
				},
				{
					"buffer": 358,
					"file": "src/Falcor/Utils/Algorithm/ParallelReduction.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3575,
						"regions":
						{
						},
						"selection":
						[
							[
								3574,
								3574
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 357.0,
						"zoom_level": 1.0
					},
					"stack_index": 372,
					"type": "text"
				},
				{
					"buffer": 359,
					"file": "src/Falcor/Utils/Algorithm/BitonicSort.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4169,
						"regions":
						{
						},
						"selection":
						[
							[
								4169,
								4169
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 816.0,
						"zoom_level": 1.0
					},
					"stack_index": 373,
					"type": "text"
				},
				{
					"buffer": 360,
					"file": "src/Falcor/Utils/Algorithm/PrefixSum.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4191,
						"regions":
						{
						},
						"selection":
						[
							[
								4191,
								4191
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 878.0,
						"zoom_level": 1.0
					},
					"stack_index": 371,
					"type": "text"
				},
				{
					"buffer": 361,
					"file": "src/Falcor/Utils/Algorithm/ComputeParallelReduction.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9541,
						"regions":
						{
						},
						"selection":
						[
							[
								4105,
								4105
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 504.0,
						"zoom_level": 1.0
					},
					"stack_index": 333,
					"type": "text"
				},
				{
					"buffer": 362,
					"file": "src/Falcor/Utils/Scripting/Console.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4108,
						"regions":
						{
						},
						"selection":
						[
							[
								1760,
								1760
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 969.0,
						"zoom_level": 1.0
					},
					"stack_index": 107,
					"type": "text"
				},
				{
					"buffer": 363,
					"file": "src/Falcor/Utils/Scripting/ScriptBindings.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4913,
						"regions":
						{
						},
						"selection":
						[
							[
								3009,
								3009
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 387.0,
						"zoom_level": 1.0
					},
					"stack_index": 77,
					"type": "text"
				},
				{
					"buffer": 364,
					"file": "src/Falcor/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5206,
						"regions":
						{
						},
						"selection":
						[
							[
								5198,
								5198
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2346.0,
						"zoom_level": 1.0
					},
					"stack_index": 82,
					"type": "text"
				},
				{
					"buffer": 365,
					"file": "src/Falcor/Utils/Sampling/SampleGenerator.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3452,
						"regions":
						{
						},
						"selection":
						[
							[
								3451,
								3451
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 306.0,
						"zoom_level": 1.0
					},
					"stack_index": 368,
					"type": "text"
				},
				{
					"buffer": 366,
					"file": "src/Falcor/Utils/Timing/Clock.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9831,
						"regions":
						{
						},
						"selection":
						[
							[
								8210,
								8210
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3482.0,
						"zoom_level": 1.0
					},
					"stack_index": 358,
					"type": "text"
				},
				{
					"buffer": 367,
					"file": "src/Falcor/Utils/Timing/Clock.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8564,
						"regions":
						{
						},
						"selection":
						[
							[
								2111,
								2111
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 51.0,
						"zoom_level": 1.0
					},
					"stack_index": 359,
					"type": "text"
				},
				{
					"buffer": 368,
					"file": "src/Falcor/Core/API/TextureLoader.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 24304,
						"regions":
						{
						},
						"selection":
						[
							[
								23777,
								23777
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 162,
					"type": "text"
				},
				{
					"buffer": 369,
					"file": "third_party/assimp/include/assimp/Bitmap.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4295,
						"regions":
						{
						},
						"selection":
						[
							[
								2138,
								2138
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1162.0,
						"zoom_level": 1.0
					},
					"stack_index": 571,
					"type": "text"
				},
				{
					"buffer": 370,
					"file": "src/Falcor/Core/API/VAO.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5144,
						"regions":
						{
						},
						"selection":
						[
							[
								2540,
								2540
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1395.0,
						"zoom_level": 1.0
					},
					"stack_index": 390,
					"type": "text"
				},
				{
					"buffer": 371,
					"file": "src/Falcor/Utils/Logger.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5549,
						"regions":
						{
						},
						"selection":
						[
							[
								5217,
								5217
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 18,
					"type": "text"
				},
				{
					"buffer": 372,
					"file": "src/Falcor/Utils/Logger.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5968,
						"regions":
						{
						},
						"selection":
						[
							[
								5674,
								5674
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2115.0,
						"zoom_level": 1.0
					},
					"stack_index": 483,
					"type": "text"
				},
				{
					"buffer": 373,
					"file": "src/Falcor/Utils/BinaryFileStream.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5898,
						"regions":
						{
						},
						"selection":
						[
							[
								1843,
								1843
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 170.0,
						"zoom_level": 1.0
					},
					"stack_index": 493,
					"type": "text"
				},
				{
					"buffer": 374,
					"file": "src/Falcor/Utils/Scripting/Scripting.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5902,
						"regions":
						{
						},
						"selection":
						[
							[
								4748,
								4748
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1698.0,
						"zoom_level": 1.0
					},
					"stack_index": 46,
					"type": "text"
				},
				{
					"buffer": 375,
					"file": "src/Falcor/Utils/Timing/Profiler.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10754,
						"regions":
						{
						},
						"selection":
						[
							[
								2524,
								2524
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 359.0,
						"zoom_level": 1.0
					},
					"stack_index": 325,
					"type": "text"
				},
				{
					"buffer": 376,
					"file": "src/Falcor/Utils/UI/Gui.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 56184,
						"regions":
						{
						},
						"selection":
						[
							[
								8303,
								8303
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2116.0,
						"zoom_level": 1.0
					},
					"stack_index": 174,
					"type": "text"
				},
				{
					"buffer": 377,
					"file": "src/Falcor/Utils/UI/PixelZoom.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5190,
						"regions":
						{
						},
						"selection":
						[
							[
								2488,
								2488
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 867.0,
						"zoom_level": 1.0
					},
					"stack_index": 321,
					"type": "text"
				},
				{
					"buffer": 378,
					"file": "src/Falcor/Utils/UI/TextRenderer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7231,
						"regions":
						{
						},
						"selection":
						[
							[
								5273,
								5273
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1212.0,
						"zoom_level": 1.0
					},
					"stack_index": 323,
					"type": "text"
				},
				{
					"buffer": 379,
					"file": "src/Falcor/Utils/UI/TextRenderer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3353,
						"regions":
						{
						},
						"selection":
						[
							[
								2192,
								2192
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 408.0,
						"zoom_level": 1.0
					},
					"stack_index": 324,
					"type": "text"
				},
				{
					"buffer": 380,
					"file": "src/Falcor/Utils/UI/PixelZoom.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3368,
						"regions":
						{
						},
						"selection":
						[
							[
								3286,
								3286
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 158.0,
						"zoom_level": 1.0
					},
					"stack_index": 322,
					"type": "text"
				},
				{
					"buffer": 381,
					"file": "src/Falcor/Utils/UI/DebugDrawer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4027,
						"regions":
						{
						},
						"selection":
						[
							[
								3944,
								3944
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 636.0,
						"zoom_level": 1.0
					},
					"stack_index": 330,
					"type": "text"
				},
				{
					"buffer": 382,
					"file": "src/Falcor/Utils/UI/DebugDrawer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8927,
						"regions":
						{
						},
						"selection":
						[
							[
								2050,
								2050
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 51.0,
						"zoom_level": 1.0
					},
					"stack_index": 329,
					"type": "text"
				},
				{
					"buffer": 383,
					"file": "src/Falcor/Utils/UI/Font.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4060,
						"regions":
						{
						},
						"selection":
						[
							[
								2244,
								2244
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 378.0,
						"zoom_level": 1.0
					},
					"stack_index": 328,
					"type": "text"
				},
				{
					"buffer": 384,
					"file": "third_party/slang/tools/render-test/bind-location.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 19257,
						"regions":
						{
						},
						"selection":
						[
							[
								10547,
								10547
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3980.0,
						"zoom_level": 1.0
					},
					"stack_index": 567,
					"type": "text"
				},
				{
					"buffer": 385,
					"file": "src/Falcor/Utils/UI/Font.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5156,
						"regions":
						{
						},
						"selection":
						[
							[
								2559,
								2559
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 255.0,
						"zoom_level": 1.0
					},
					"stack_index": 327,
					"type": "text"
				},
				{
					"buffer": 386,
					"file": "src/Falcor/Core/Program/ProgramReflection.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 85087,
						"regions":
						{
						},
						"selection":
						[
							[
								85086,
								85086
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 35103.0,
						"zoom_level": 1.0
					},
					"stack_index": 257,
					"type": "text"
				},
				{
					"buffer": 387,
					"file": "src/Falcor/Core/API/Vulkan/VKGraphicsStateObject.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5776,
						"regions":
						{
						},
						"selection":
						[
							[
								5776,
								5776
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 921.0,
						"zoom_level": 1.0
					},
					"stack_index": 403,
					"type": "text"
				},
				{
					"buffer": 388,
					"file": "third_party/slang/source/slang/slang-reflection.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 50216,
						"regions":
						{
						},
						"selection":
						[
							[
								2619,
								2619
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1382.0,
						"zoom_level": 1.0
					},
					"stack_index": 562,
					"type": "text"
				},
				{
					"buffer": 389,
					"file": "third_party/slang/source/slang/slang-compiler.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 90183,
						"regions":
						{
						},
						"selection":
						[
							[
								83549,
								83549
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 34736.0,
						"zoom_level": 1.0
					},
					"stack_index": 561,
					"type": "text"
				},
				{
					"buffer": 390,
					"file": "third_party/slang/source/slang/slang-name.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 800,
						"regions":
						{
						},
						"selection":
						[
							[
								630,
								630
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 56.0,
						"zoom_level": 1.0
					},
					"stack_index": 560,
					"type": "text"
				},
				{
					"buffer": 391,
					"file": "third_party/slang/source/core/slang-dictionary.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13988,
						"regions":
						{
						},
						"selection":
						[
							[
								8683,
								8683
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 559,
					"type": "text"
				},
				{
					"buffer": 392,
					"file": "src/Falcor/Core/Program/ProgramVars.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14440,
						"regions":
						{
						},
						"selection":
						[
							[
								3693,
								3693
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 972.0,
						"zoom_level": 1.0
					},
					"stack_index": 254,
					"type": "text"
				},
				{
					"buffer": 393,
					"file": "src/Falcor/Raytracing/RtProgramVarsHelper.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14339,
						"regions":
						{
						},
						"selection":
						[
							[
								2753,
								2753
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 299.0,
						"zoom_level": 1.0
					},
					"stack_index": 500,
					"type": "text"
				},
				{
					"buffer": 394,
					"file": "src/Falcor/Core/Program/ProgramVars.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6798,
						"regions":
						{
						},
						"selection":
						[
							[
								3457,
								3457
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1106.0,
						"zoom_level": 1.0
					},
					"stack_index": 256,
					"type": "text"
				},
				{
					"buffer": 395,
					"file": "src/Falcor/Core/Program/ShaderVar.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 17036,
						"regions":
						{
						},
						"selection":
						[
							[
								17036,
								17036
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 6056.0,
						"zoom_level": 1.0
					},
					"stack_index": 406,
					"type": "text"
				},
				{
					"buffer": 396,
					"file": "src/Falcor/Core/Program/ProgramReflection.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 54816,
						"regions":
						{
						},
						"selection":
						[
							[
								49501,
								49501
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 24131.0,
						"zoom_level": 1.0
					},
					"stack_index": 259,
					"type": "text"
				},
				{
					"buffer": 397,
					"file": "src/Falcor/Core/Program/Program.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 34062,
						"regions":
						{
						},
						"selection":
						[
							[
								27215,
								27215
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 11768.0,
						"zoom_level": 1.0
					},
					"stack_index": 407,
					"type": "text"
				},
				{
					"buffer": 398,
					"file": "src/Falcor/Core/API/Buffer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13450,
						"regions":
						{
						},
						"selection":
						[
							[
								11550,
								11550
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3287.0,
						"zoom_level": 1.0
					},
					"stack_index": 285,
					"type": "text"
				},
				{
					"buffer": 399,
					"file": "src/Falcor/Core/API/FBO.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 18040,
						"regions":
						{
						},
						"selection":
						[
							[
								6037,
								6037
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2397.0,
						"zoom_level": 1.0
					},
					"stack_index": 160,
					"type": "text"
				},
				{
					"buffer": 400,
					"file": "src/Falcor/Core/API/BlendState.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9346,
						"regions":
						{
						},
						"selection":
						[
							[
								9106,
								9106
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2535.0,
						"zoom_level": 1.0
					},
					"stack_index": 400,
					"type": "text"
				},
				{
					"buffer": 401,
					"file": "src/Falcor/Core/API/BlendState.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3664,
						"regions":
						{
						},
						"selection":
						[
							[
								1729,
								1729
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 306.0,
						"zoom_level": 1.0
					},
					"stack_index": 425,
					"type": "text"
				},
				{
					"buffer": 402,
					"file": "src/Falcor/Core/API/FBO.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13546,
						"regions":
						{
						},
						"selection":
						[
							[
								4985,
								4985
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 648.0,
						"zoom_level": 1.0
					},
					"stack_index": 159,
					"type": "text"
				},
				{
					"buffer": 403,
					"file": "src/USD/hdLava/rendererPlugin.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 734,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 145,
					"type": "text"
				},
				{
					"buffer": 404,
					"file": "src/USD/hdLava/renderDelegate.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3463,
						"regions":
						{
						},
						"selection":
						[
							[
								3463,
								3463
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 148,
					"type": "text"
				},
				{
					"buffer": 405,
					"file": "src/USD/hdLava/renderDelegate.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14534,
						"regions":
						{
						},
						"selection":
						[
							[
								11073,
								11073
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 5155.0,
						"zoom_level": 1.0
					},
					"stack_index": 135,
					"type": "text"
				},
				{
					"buffer": 406,
					"file": "src/USD/hdLava/renderThread.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2169,
						"regions":
						{
						},
						"selection":
						[
							[
								1508,
								1508
							]
						],
						"settings":
						{
							"auto_name": "/*************************************************",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 766.0,
						"zoom_level": 1.0
					},
					"stack_index": 156,
					"type": "text"
				},
				{
					"buffer": 407,
					"file": "src/USD/hdLava/renderThread.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4673,
						"regions":
						{
						},
						"selection":
						[
							[
								4673,
								4673
							]
						],
						"settings":
						{
							"auto_name": "/*************************************************",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 155,
					"type": "text"
				},
				{
					"buffer": 408,
					"file": "src/USD/hdLava/rendererPlugin.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1809,
						"regions":
						{
						},
						"selection":
						[
							[
								1233,
								1233
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 7.0,
						"zoom_level": 1.0
					},
					"stack_index": 146,
					"type": "text"
				},
				{
					"buffer": 409,
					"file": "src/Falcor/Core/API/Texture.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15518,
						"regions":
						{
						},
						"selection":
						[
							[
								13663,
								13663
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2788.0,
						"zoom_level": 1.0
					},
					"stack_index": 161,
					"type": "text"
				},
				{
					"buffer": 410,
					"file": "src/Tools/FalcorTest/Tests/ShadingUtils/RaytracingTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4882,
						"regions":
						{
						},
						"selection":
						[
							[
								4881,
								4881
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1315.0,
						"zoom_level": 1.0
					},
					"stack_index": 547,
					"type": "text"
				},
				{
					"buffer": 411,
					"file": "src/Tools/FalcorTest/Tests/Slang/SlangTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8055,
						"regions":
						{
						},
						"selection":
						[
							[
								6777,
								6777
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2518.0,
						"zoom_level": 1.0
					},
					"stack_index": 537,
					"type": "text"
				},
				{
					"buffer": 412,
					"file": "src/Tools/FalcorTest/Tests/Slang/SlangTests.cs.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6527,
						"regions":
						{
						},
						"selection":
						[
							[
								4191,
								4191
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1297.0,
						"zoom_level": 1.0
					},
					"stack_index": 539,
					"type": "text"
				},
				{
					"buffer": 413,
					"file": "src/Tools/FalcorTest/Tests/Slang/SlangShared.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2435,
						"regions":
						{
						},
						"selection":
						[
							[
								1765,
								1765
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 357.0,
						"zoom_level": 1.0
					},
					"stack_index": 540,
					"type": "text"
				},
				{
					"buffer": 414,
					"file": "src/Tools/FalcorTest/Tests/Slang/ShaderModel.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3182,
						"regions":
						{
						},
						"selection":
						[
							[
								2515,
								2515
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 75.0,
						"zoom_level": 1.0
					},
					"stack_index": 535,
					"type": "text"
				},
				{
					"buffer": 415,
					"file": "src/Tools/FalcorTest/Tests/Slang/Int64Tests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3694,
						"regions":
						{
						},
						"selection":
						[
							[
								1882,
								1882
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1060.0,
						"zoom_level": 1.0
					},
					"stack_index": 549,
					"type": "text"
				},
				{
					"buffer": 416,
					"file": "src/Tools/FalcorTest/Tests/Slang/TraceRayFlags.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3163,
						"regions":
						{
						},
						"selection":
						[
							[
								1762,
								1743
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 227.0,
						"zoom_level": 1.0
					},
					"stack_index": 546,
					"type": "text"
				},
				{
					"buffer": 417,
					"file": "src/Tools/FalcorTest/Tests/Slang/TraceRayInline.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2113,
						"regions":
						{
						},
						"selection":
						[
							[
								2113,
								2113
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 551,
					"type": "text"
				},
				{
					"buffer": 418,
					"file": "src/Tools/FalcorTest/Tests/Slang/WaveOps.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6067,
						"regions":
						{
						},
						"selection":
						[
							[
								3182,
								3182
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1122.0,
						"zoom_level": 1.0
					},
					"stack_index": 536,
					"type": "text"
				},
				{
					"buffer": 419,
					"file": "src/Tools/FalcorTest/Tests/Utils/AABBTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7752,
						"regions":
						{
						},
						"selection":
						[
							[
								2261,
								2261
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 262.0,
						"zoom_level": 1.0
					},
					"stack_index": 520,
					"type": "text"
				},
				{
					"buffer": 420,
					"file": "third_party/slang/prelude/slang-cpp-types.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 28997,
						"regions":
						{
						},
						"selection":
						[
							[
								1493,
								1493
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 614.0,
						"zoom_level": 1.0
					},
					"stack_index": 349,
					"type": "text"
				},
				{
					"buffer": 421,
					"file": "src/Tools/FalcorTest/FalcorTest.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2143,
						"regions":
						{
						},
						"selection":
						[
							[
								1866,
								1866
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 563,
					"type": "text"
				},
				{
					"buffer": 422,
					"file": "src/Tools/FalcorTest/FalcorTest.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3605,
						"regions":
						{
						},
						"selection":
						[
							[
								3312,
								3312
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 346.0,
						"zoom_level": 1.0
					},
					"stack_index": 550,
					"type": "text"
				},
				{
					"buffer": 423,
					"file": "src/Tools/FalcorTest/Tests/Sampling/SampleGeneratorTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7287,
						"regions":
						{
						},
						"selection":
						[
							[
								4059,
								4059
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 551.0,
						"zoom_level": 1.0
					},
					"stack_index": 524,
					"type": "text"
				},
				{
					"buffer": 424,
					"file": "src/Tools/FalcorTest/Tests/Core/RootBufferTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8005,
						"regions":
						{
						},
						"selection":
						[
							[
								7231,
								7231
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2098.0,
						"zoom_level": 1.0
					},
					"stack_index": 525,
					"type": "text"
				},
				{
					"buffer": 425,
					"file": "src/Tools/FalcorTest/Tests/Core/RootBufferStructTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5631,
						"regions":
						{
						},
						"selection":
						[
							[
								4710,
								4710
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 526,
					"type": "text"
				},
				{
					"buffer": 426,
					"file": "src/Falcor/Core/API/Vulkan/VkGpuMemoryHeap.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2413,
						"regions":
						{
						},
						"selection":
						[
							[
								2413,
								2413
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 415,
					"type": "text"
				},
				{
					"buffer": 427,
					"file": "src/Falcor/Core/Platform/Linux/Linux.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15074,
						"regions":
						{
						},
						"selection":
						[
							[
								14787,
								14787
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 7551.0,
						"zoom_level": 1.0
					},
					"stack_index": 502,
					"type": "text"
				},
				{
					"buffer": 428,
					"file": "src/Falcor/Core/Platform/Windows/ProgressBarWin.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4513,
						"regions":
						{
						},
						"selection":
						[
							[
								2360,
								2360
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 204.0,
						"zoom_level": 1.0
					},
					"stack_index": 587,
					"type": "text"
				},
				{
					"buffer": 429,
					"file": "src/Falcor/Core/Platform/OS.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15995,
						"regions":
						{
						},
						"selection":
						[
							[
								1983,
								1983
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2550.0,
						"zoom_level": 1.0
					},
					"stack_index": 570,
					"type": "text"
				},
				{
					"buffer": 430,
					"file": "src/Falcor/Core/API/Vulkan/VKState.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3960,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 377.0,
						"zoom_level": 1.0
					},
					"stack_index": 401,
					"type": "text"
				},
				{
					"buffer": 431,
					"file": "src/Falcor/Core/API/Texture.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 16435,
						"regions":
						{
						},
						"selection":
						[
							[
								11982,
								11982
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3706.0,
						"zoom_level": 1.0
					},
					"stack_index": 165,
					"type": "text"
				},
				{
					"buffer": 432,
					"file": "src/USD/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 638,
						"regions":
						{
						},
						"selection":
						[
							[
								549,
								549
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 144,
					"type": "text"
				},
				{
					"buffer": 433,
					"file": "src/USD/hdLava/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1179,
						"regions":
						{
						},
						"selection":
						[
							[
								26,
								26
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 143,
					"type": "text"
				},
				{
					"buffer": 434,
					"file": "src/USD/hdLava/api.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 788,
						"regions":
						{
						},
						"selection":
						[
							[
								788,
								788
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 154,
					"type": "text"
				},
				{
					"buffer": 435,
					"file": "src/USD/hdLava/pch.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5431,
						"regions":
						{
						},
						"selection":
						[
							[
								1419,
								1419
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 1468.0,
						"zoom_level": 1.0
					},
					"stack_index": 149,
					"type": "text"
				},
				{
					"buffer": 436,
					"file": "src/USD/hdLava/boostIncludePath.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1114,
						"regions":
						{
						},
						"selection":
						[
							[
								772,
								772
							]
						],
						"settings":
						{
							"auto_name": "/*************************************************",
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 150,
					"type": "text"
				},
				{
					"buffer": 437,
					"file": "src/USD/hdLava/plugInfo.json",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 604,
						"regions":
						{
						},
						"selection":
						[
							[
								456,
								456
							]
						],
						"settings":
						{
							"syntax": "Packages/JavaScript/JSON.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 157,
					"type": "text"
				},
				{
					"buffer": 438,
					"file": "src/USD/hdLava/renderPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 715,
						"regions":
						{
						},
						"selection":
						[
							[
								226,
								226
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 153,
					"type": "text"
				},
				{
					"buffer": 439,
					"file": "src/USD/hdLava/renderPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2970,
						"regions":
						{
						},
						"selection":
						[
							[
								2970,
								2970
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 152,
					"type": "text"
				},
				{
					"buffer": 440,
					"file": "src/USD/hdLava/renderParam.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2361,
						"regions":
						{
						},
						"selection":
						[
							[
								2361,
								2361
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 459.0,
						"zoom_level": 1.0
					},
					"stack_index": 151,
					"type": "text"
				},
				{
					"buffer": 441,
					"file": "src/USD/hdLava/renderParam.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2251,
						"regions":
						{
						},
						"selection":
						[
							[
								10,
								10
							]
						],
						"settings":
						{
							"auto_name": "/*************************************************",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 147,
					"type": "text"
				},
				{
					"buffer": 442,
					"file": "src/USD/hgiVk/commandBuffer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8461,
						"regions":
						{
						},
						"selection":
						[
							[
								1472,
								1472
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 430,
					"type": "text"
				},
				{
					"buffer": 443,
					"file": "src/USD/hgiVk/commandBufferManager.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13416,
						"regions":
						{
						},
						"selection":
						[
							[
								184,
								184
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 468,
					"type": "text"
				},
				{
					"buffer": 444,
					"file": "src/USD/hgiVk/commandPool.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1629,
						"regions":
						{
						},
						"selection":
						[
							[
								114,
								114
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 467,
					"type": "text"
				},
				{
					"buffer": 445,
					"file": "src/USD/hgiVk/computeEncoder.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1791,
						"regions":
						{
						},
						"selection":
						[
							[
								222,
								222
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 466,
					"type": "text"
				},
				{
					"buffer": 446,
					"file": "src/USD/hgiVk/conversions.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9785,
						"regions":
						{
						},
						"selection":
						[
							[
								150,
								150
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 465,
					"type": "text"
				},
				{
					"buffer": 447,
					"file": "src/USD/hgiVk/device.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 17769,
						"regions":
						{
						},
						"selection":
						[
							[
								209,
								209
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 464,
					"type": "text"
				},
				{
					"buffer": 448,
					"file": "src/USD/hgiVk/diagnostic.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6577,
						"regions":
						{
						},
						"selection":
						[
							[
								239,
								239
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 463,
					"type": "text"
				},
				{
					"buffer": 449,
					"file": "src/USD/hgiVk/frame.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2455,
						"regions":
						{
						},
						"selection":
						[
							[
								113,
								113
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 440,
					"type": "text"
				},
				{
					"buffer": 450,
					"file": "src/USD/hgiVk/garbageCollector.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3957,
						"regions":
						{
						},
						"selection":
						[
							[
								423,
								423
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 462,
					"type": "text"
				},
				{
					"buffer": 451,
					"file": "src/USD/hgiVk/graphicsEncoder.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6479,
						"regions":
						{
						},
						"selection":
						[
							[
								405,
								405
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 461,
					"type": "text"
				},
				{
					"buffer": 452,
					"file": "src/USD/hgiVk/hgi.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14444,
						"regions":
						{
						},
						"selection":
						[
							[
								961,
								961
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 460,
					"type": "text"
				},
				{
					"buffer": 453,
					"file": "src/USD/hgiVk/instance.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1940,
						"regions":
						{
						},
						"selection":
						[
							[
								103,
								103
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 459,
					"type": "text"
				},
				{
					"buffer": 454,
					"file": "src/USD/hgiVk/parallelGraphicsEncoder.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3913,
						"regions":
						{
						},
						"selection":
						[
							[
								387,
								387
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 458,
					"type": "text"
				},
				{
					"buffer": 455,
					"file": "src/USD/hgiVk/pipeline.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15055,
						"regions":
						{
						},
						"selection":
						[
							[
								348,
								348
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 457,
					"type": "text"
				},
				{
					"buffer": 456,
					"file": "src/USD/hgiVk/renderPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15805,
						"regions":
						{
						},
						"selection":
						[
							[
								264,
								264
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 433,
					"type": "text"
				},
				{
					"buffer": 457,
					"file": "src/USD/hgiVk/pipeline.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1831,
						"regions":
						{
						},
						"selection":
						[
							[
								1176,
								1176
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 432,
					"type": "text"
				},
				{
					"buffer": 458,
					"file": "src/USD/hgiVk/renderPassPipelineCache.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8095,
						"regions":
						{
						},
						"selection":
						[
							[
								322,
								322
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 456,
					"type": "text"
				},
				{
					"buffer": 459,
					"file": "src/USD/hgiVk/resourceBindings.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 16563,
						"regions":
						{
						},
						"selection":
						[
							[
								276,
								276
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 455,
					"type": "text"
				},
				{
					"buffer": 460,
					"file": "src/USD/hgiVk/shaderCompiler.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10186,
						"regions":
						{
						},
						"selection":
						[
							[
								285,
								285
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 454,
					"type": "text"
				},
				{
					"buffer": 461,
					"file": "src/USD/hgiVk/shaderFunction.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2509,
						"regions":
						{
						},
						"selection":
						[
							[
								149,
								149
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 453,
					"type": "text"
				},
				{
					"buffer": 462,
					"file": "src/USD/hgiVk/shaderProgram.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 437,
						"regions":
						{
						},
						"selection":
						[
							[
								50,
								50
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 452,
					"type": "text"
				},
				{
					"buffer": 463,
					"file": "src/USD/hgiVk/surface.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3812,
						"regions":
						{
						},
						"selection":
						[
							[
								112,
								112
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 306.0,
						"zoom_level": 1.0
					},
					"stack_index": 164,
					"type": "text"
				},
				{
					"buffer": 464,
					"file": "src/USD/hgiVk/swapchain.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 17443,
						"regions":
						{
						},
						"selection":
						[
							[
								253,
								253
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 451,
					"type": "text"
				},
				{
					"buffer": 465,
					"file": "src/USD/hgiVk/texture.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15437,
						"regions":
						{
						},
						"selection":
						[
							[
								1497,
								1497
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 450,
					"type": "text"
				},
				{
					"buffer": 466,
					"file": "src/USD/hgiVk/buffer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9825,
						"regions":
						{
						},
						"selection":
						[
							[
								182,
								182
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 449,
					"type": "text"
				},
				{
					"buffer": 467,
					"file": "src/USD/hgiVk/blitEncoder.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6180,
						"regions":
						{
						},
						"selection":
						[
							[
								1024,
								1024
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 448,
					"type": "text"
				},
				{
					"buffer": 468,
					"file": "src/USD/hgiVk/blitEncoder.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1319,
						"regions":
						{
						},
						"selection":
						[
							[
								378,
								378
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 429,
					"type": "text"
				},
				{
					"buffer": 469,
					"file": "src/USD/hgiVk/buffer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1965,
						"regions":
						{
						},
						"selection":
						[
							[
								148,
								148
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 447,
					"type": "text"
				},
				{
					"buffer": 470,
					"file": "src/USD/hgiVk/commandBuffer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3844,
						"regions":
						{
						},
						"selection":
						[
							[
								216,
								216
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 431,
					"type": "text"
				},
				{
					"buffer": 471,
					"file": "src/USD/hgiVk/commandBufferManager.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5853,
						"regions":
						{
						},
						"selection":
						[
							[
								292,
								292
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 446,
					"type": "text"
				},
				{
					"buffer": 472,
					"file": "src/USD/hgiVk/commandPool.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1102,
						"regions":
						{
						},
						"selection":
						[
							[
								213,
								213
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 445,
					"type": "text"
				},
				{
					"buffer": 473,
					"file": "src/USD/hgiVk/computeEncoder.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1631,
						"regions":
						{
						},
						"selection":
						[
							[
								252,
								252
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 444,
					"type": "text"
				},
				{
					"buffer": 474,
					"file": "src/USD/hgiVk/conversions.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1688,
						"regions":
						{
						},
						"selection":
						[
							[
								249,
								249
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 443,
					"type": "text"
				},
				{
					"buffer": 475,
					"file": "src/USD/hgiVk/device.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6599,
						"regions":
						{
						},
						"selection":
						[
							[
								357,
								357
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 442,
					"type": "text"
				},
				{
					"buffer": 476,
					"file": "src/USD/hgiVk/diagnostic.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1085,
						"regions":
						{
						},
						"selection":
						[
							[
								135,
								135
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 441,
					"type": "text"
				},
				{
					"buffer": 477,
					"file": "src/USD/hgiVk/frame.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2289,
						"regions":
						{
						},
						"selection":
						[
							[
								270,
								270
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 439,
					"type": "text"
				},
				{
					"buffer": 478,
					"file": "src/USD/hgiVk/garbageCollector.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1637,
						"regions":
						{
						},
						"selection":
						[
							[
								192,
								192
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 438,
					"type": "text"
				},
				{
					"buffer": 479,
					"file": "src/USD/hgiVk/graphicsEncoder.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2732,
						"regions":
						{
						},
						"selection":
						[
							[
								307,
								307
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 437,
					"type": "text"
				},
				{
					"buffer": 480,
					"file": "src/USD/hgiVk/hgi.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4470,
						"regions":
						{
						},
						"selection":
						[
							[
								195,
								195
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 436,
					"type": "text"
				},
				{
					"buffer": 481,
					"file": "src/USD/hgiVk/instance.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 693,
						"regions":
						{
						},
						"selection":
						[
							[
								137,
								137
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 435,
					"type": "text"
				},
				{
					"buffer": 482,
					"file": "src/USD/hgiVk/parallelGraphicsEncoder.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1608,
						"regions":
						{
						},
						"selection":
						[
							[
								280,
								280
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 434,
					"type": "text"
				},
				{
					"buffer": 483,
					"file": "src/Mogwai/MogwaiSettings.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2575,
						"regions":
						{
						},
						"selection":
						[
							[
								1742,
								1742
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 319,
					"type": "text"
				},
				{
					"buffer": 484,
					"file": "src/Mogwai/MogwaiSettings.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10806,
						"regions":
						{
						},
						"selection":
						[
							[
								10629,
								10629
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1751.0,
						"zoom_level": 1.0
					},
					"stack_index": 176,
					"type": "text"
				},
				{
					"buffer": 485,
					"file": "src/Mogwai/MogwaiScripting.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6767,
						"regions":
						{
						},
						"selection":
						[
							[
								5949,
								5949
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1496.0,
						"zoom_level": 1.0
					},
					"stack_index": 320,
					"type": "text"
				},
				{
					"buffer": 486,
					"file": "src/Falcor/Core/API/Shader.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8437,
						"regions":
						{
						},
						"selection":
						[
							[
								7321,
								7321
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2910.0,
						"zoom_level": 1.0
					},
					"stack_index": 418,
					"type": "text"
				},
				{
					"buffer": 487,
					"file": "src/Falcor/Core/API/Sampler.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7871,
						"regions":
						{
						},
						"selection":
						[
							[
								5224,
								5224
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1680.0,
						"zoom_level": 1.0
					},
					"stack_index": 381,
					"type": "text"
				},
				{
					"buffer": 488,
					"file": "src/Falcor/Core/API/Sampler.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3887,
						"regions":
						{
						},
						"selection":
						[
							[
								3190,
								3190
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 139.0,
						"zoom_level": 1.0
					},
					"stack_index": 419,
					"type": "text"
				},
				{
					"buffer": 489,
					"file": "src/Falcor/Core/API/Vulkan/VKShader.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2775,
						"regions":
						{
						},
						"selection":
						[
							[
								2709,
								2709
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 411,
					"type": "text"
				},
				{
					"buffer": 490,
					"file": "src/Falcor/stdafx.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1831,
						"regions":
						{
						},
						"selection":
						[
							[
								1788,
								1788
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 575,
					"type": "text"
				},
				{
					"buffer": 491,
					"file": "src/Falcor/Core/API/CopyContext.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6896,
						"regions":
						{
						},
						"selection":
						[
							[
								2129,
								2129
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 595.0,
						"zoom_level": 1.0
					},
					"stack_index": 270,
					"type": "text"
				},
				{
					"buffer": 492,
					"file": "src/Falcor/Core/API/VAO.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3603,
						"regions":
						{
						},
						"selection":
						[
							[
								3603,
								3603
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 530.0,
						"zoom_level": 1.0
					},
					"stack_index": 389,
					"type": "text"
				},
				{
					"buffer": 493,
					"file": "src/Falcor/Core/API/Vulkan/VKBuffer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6579,
						"regions":
						{
						},
						"selection":
						[
							[
								5086,
								5086
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 408.0,
						"zoom_level": 1.0
					},
					"stack_index": 304,
					"type": "text"
				},
				{
					"buffer": 494,
					"file": "src/Falcor/Core/API/ComputeContext.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3000,
						"regions":
						{
						},
						"selection":
						[
							[
								1989,
								1989
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 411.0,
						"zoom_level": 1.0
					},
					"stack_index": 268,
					"type": "text"
				},
				{
					"buffer": 495,
					"file": "src/Falcor/Core/API/D3D12/D3D12ComputeContext.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6740,
						"regions":
						{
						},
						"selection":
						[
							[
								3585,
								3585
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 852.0,
						"zoom_level": 1.0
					},
					"stack_index": 519,
					"type": "text"
				},
				{
					"buffer": 496,
					"file": "src/Falcor/Core/API/D3D12/D3D12LowLevelContextData.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4664,
						"regions":
						{
						},
						"selection":
						[
							[
								2929,
								2929
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 775.0,
						"zoom_level": 1.0
					},
					"stack_index": 586,
					"type": "text"
				},
				{
					"buffer": 497,
					"file": "src/Falcor/Core/API/Vulkan/VKLowLevelContextData.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5608,
						"regions":
						{
						},
						"selection":
						[
							[
								4399,
								4399
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 663.0,
						"zoom_level": 1.0
					},
					"stack_index": 413,
					"type": "text"
				},
				{
					"buffer": 498,
					"file": "src/Falcor/Core/API/FencedPool.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4321,
						"regions":
						{
						},
						"selection":
						[
							[
								3683,
								3683
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 995.0,
						"zoom_level": 1.0
					},
					"stack_index": 420,
					"type": "text"
				},
				{
					"buffer": 499,
					"file": "src/Falcor/Core/API/Vulkan/VKComputeContext.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8062,
						"regions":
						{
						},
						"selection":
						[
							[
								2892,
								2892
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 309.0,
						"zoom_level": 1.0
					},
					"stack_index": 272,
					"type": "text"
				},
				{
					"buffer": 500,
					"file": "src/Tools/FalcorTest/Tests/Utils/MathHelpersTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 12262,
						"regions":
						{
						},
						"selection":
						[
							[
								9216,
								9216
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2856.0,
						"zoom_level": 1.0
					},
					"stack_index": 518,
					"type": "text"
				},
				{
					"buffer": 501,
					"file": "src/Falcor/Core/API/Vulkan/VKRenderContext.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 16727,
						"regions":
						{
						},
						"selection":
						[
							[
								15648,
								15648
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4464.0,
						"zoom_level": 1.0
					},
					"stack_index": 163,
					"type": "text"
				},
				{
					"buffer": 502,
					"file": "src/Falcor/RenderGraph/BasePasses/RasterPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3029,
						"regions":
						{
						},
						"selection":
						[
							[
								1986,
								1986
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 204.0,
						"zoom_level": 1.0
					},
					"stack_index": 244,
					"type": "text"
				},
				{
					"buffer": 503,
					"file": "src/Falcor/RenderGraph/BasePasses/RasterPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4410,
						"regions":
						{
						},
						"selection":
						[
							[
								4242,
								4242
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 458.0,
						"zoom_level": 1.0
					},
					"stack_index": 245,
					"type": "text"
				},
				{
					"buffer": 504,
					"file": "src/Falcor/Core/API/Vulkan/VKResourceViews.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13407,
						"regions":
						{
						},
						"selection":
						[
							[
								13307,
								13307
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4549.0,
						"zoom_level": 1.0
					},
					"stack_index": 296,
					"type": "text"
				},
				{
					"buffer": 505,
					"file": "src/RenderPasses/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3482,
						"regions":
						{
						},
						"selection":
						[
							[
								3314,
								3314
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1173.0,
						"zoom_level": 1.0
					},
					"stack_index": 140,
					"type": "text"
				},
				{
					"buffer": 506,
					"file": "/home/max/Desktop/gbuffer.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 574,
						"regions":
						{
						},
						"selection":
						[
							[
								141,
								141
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 476,
					"type": "text"
				},
				{
					"buffer": 507,
					"file": "src/RenderPasses/GBuffer/GBuffer/GBufferParams.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2388,
						"regions":
						{
						},
						"selection":
						[
							[
								2363,
								2363
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 472,
					"type": "text"
				},
				{
					"buffer": 508,
					"file": "src/Falcor/Utils/Threading.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2799,
						"regions":
						{
						},
						"selection":
						[
							[
								1945,
								1945
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 388.0,
						"zoom_level": 1.0
					},
					"stack_index": 383,
					"type": "text"
				},
				{
					"buffer": 509,
					"file": "src/Falcor/Utils/TermColor.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3484,
						"regions":
						{
						},
						"selection":
						[
							[
								2669,
								2669
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 663.0,
						"zoom_level": 1.0
					},
					"stack_index": 495,
					"type": "text"
				},
				{
					"buffer": 510,
					"file": "src/Falcor/Utils/TermColor.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2499,
						"regions":
						{
						},
						"selection":
						[
							[
								1843,
								1843
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 496,
					"type": "text"
				},
				{
					"buffer": 511,
					"file": "src/Falcor/Utils/Threading.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3003,
						"regions":
						{
						},
						"selection":
						[
							[
								2415,
								2415
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 507.0,
						"zoom_level": 1.0
					},
					"stack_index": 384,
					"type": "text"
				},
				{
					"buffer": 512,
					"file": "build/bin/Shaders/RenderPasses/BSDFViewer/BSDFViewer.cs.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15202,
						"regions":
						{
						},
						"selection":
						[
							[
								13788,
								13788
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 5865.0,
						"zoom_level": 1.0
					},
					"stack_index": 506,
					"type": "text"
				},
				{
					"buffer": 513,
					"file": "src/RenderPasses/Utils/Utils.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2234,
						"regions":
						{
						},
						"selection":
						[
							[
								2234,
								2234
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 475,
					"type": "text"
				},
				{
					"buffer": 514,
					"file": "third_party/slang/tools/render-test/cuda/cuda-compute-util.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 53192,
						"regions":
						{
						},
						"selection":
						[
							[
								1255,
								1255
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 357.0,
						"zoom_level": 1.0
					},
					"stack_index": 582,
					"type": "text"
				},
				{
					"buffer": 515,
					"file": "src/Falcor/Core/API/Vulkan/VkSmartHandle.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6726,
						"regions":
						{
						},
						"selection":
						[
							[
								3921,
								3921
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1278.0,
						"zoom_level": 1.0
					},
					"stack_index": 297,
					"type": "text"
				},
				{
					"buffer": 516,
					"file": "src/Falcor/Core/API/Vulkan/VKRootSignature.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8750,
						"regions":
						{
						},
						"selection":
						[
							[
								4765,
								4765
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1006.0,
						"zoom_level": 1.0
					},
					"stack_index": 316,
					"type": "text"
				},
				{
					"buffer": 517,
					"file": "src/Falcor/Core/Program/ProgramVersion.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10447,
						"regions":
						{
						},
						"selection":
						[
							[
								6330,
								6330
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3453.0,
						"zoom_level": 1.0
					},
					"stack_index": 261,
					"type": "text"
				},
				{
					"buffer": 518,
					"file": "third_party/slang/examples/model-viewer/main.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 86920,
						"regions":
						{
						},
						"selection":
						[
							[
								7215,
								7215
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3835.0,
						"zoom_level": 1.0
					},
					"stack_index": 593,
					"type": "text"
				},
				{
					"buffer": 519,
					"file": "src/Falcor/Core/API/ResourceViews.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9621,
						"regions":
						{
						},
						"selection":
						[
							[
								4513,
								4513
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1244.0,
						"zoom_level": 1.0
					},
					"stack_index": 276,
					"type": "text"
				},
				{
					"buffer": 520,
					"file": "src/Falcor/Core/API/RootSignature.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6716,
						"regions":
						{
						},
						"selection":
						[
							[
								4554,
								4554
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1386.0,
						"zoom_level": 1.0
					},
					"stack_index": 310,
					"type": "text"
				},
				{
					"buffer": 521,
					"file": "src/Falcor/Core/API/RootSignature.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8993,
						"regions":
						{
						},
						"selection":
						[
							[
								4764,
								4764
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1261.0,
						"zoom_level": 1.0
					},
					"stack_index": 311,
					"type": "text"
				},
				{
					"buffer": 522,
					"file": "src/Falcor/Core/API/Vulkan/VKSampler.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2442,
						"regions":
						{
						},
						"selection":
						[
							[
								2415,
								2415
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 412,
					"type": "text"
				},
				{
					"buffer": 523,
					"file": "third_party/slang/tools/gfx/render.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 28476,
						"regions":
						{
						},
						"selection":
						[
							[
								14530,
								14530
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 9715.0,
						"zoom_level": 1.0
					},
					"stack_index": 585,
					"type": "text"
				},
				{
					"buffer": 524,
					"file": "src/Falcor/Core/API/Vulkan/FalcorVK.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5196,
						"regions":
						{
						},
						"selection":
						[
							[
								2936,
								2936
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 898.0,
						"zoom_level": 1.0
					},
					"stack_index": 288,
					"type": "text"
				},
				{
					"buffer": 525,
					"file": "src/Falcor/Core/API/Device.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11497,
						"regions":
						{
						},
						"selection":
						[
							[
								2466,
								2466
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 577.0,
						"zoom_level": 1.0
					},
					"stack_index": 43,
					"type": "text"
				},
				{
					"buffer": 526,
					"file": "src/Falcor/Core/API/GpuMemoryHeap.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4090,
						"regions":
						{
						},
						"selection":
						[
							[
								3927,
								3927
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 938.0,
						"zoom_level": 1.0
					},
					"stack_index": 417,
					"type": "text"
				},
				{
					"buffer": 527,
					"file": "src/Falcor/Core/API/GpuMemoryHeap.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5126,
						"regions":
						{
						},
						"selection":
						[
							[
								4817,
								4817
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1428.0,
						"zoom_level": 1.0
					},
					"stack_index": 416,
					"type": "text"
				},
				{
					"buffer": 528,
					"file": "src/Falcor/Core/API/Vulkan/VKComputeStateObject.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2823,
						"regions":
						{
						},
						"selection":
						[
							[
								2798,
								2798
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 294,
					"type": "text"
				},
				{
					"buffer": 529,
					"file": "src/Falcor/Core/API/Vulkan/VKCopyContext.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 22034,
						"regions":
						{
						},
						"selection":
						[
							[
								16385,
								16385
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4661.0,
						"zoom_level": 1.0
					},
					"stack_index": 271,
					"type": "text"
				},
				{
					"buffer": 530,
					"file": "src/Falcor/Core/API/Vulkan/VKDescriptorPool.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5083,
						"regions":
						{
						},
						"selection":
						[
							[
								5083,
								5083
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 287,
					"type": "text"
				},
				{
					"buffer": 531,
					"file": "src/Falcor/Core/API/Vulkan/VKDescriptorSet.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7835,
						"regions":
						{
						},
						"selection":
						[
							[
								3804,
								3804
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 632.0,
						"zoom_level": 1.0
					},
					"stack_index": 309,
					"type": "text"
				},
				{
					"buffer": 532,
					"file": "src/Falcor/Core/API/Vulkan/VKDevice.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3020,
						"regions":
						{
						},
						"selection":
						[
							[
								2741,
								2741
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 357.0,
						"zoom_level": 1.0
					},
					"stack_index": 279,
					"type": "text"
				},
				{
					"buffer": 533,
					"file": "src/Falcor/Core/API/Vulkan/VKDeviceManager.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2844,
						"regions":
						{
						},
						"selection":
						[
							[
								2772,
								2772
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 442.0,
						"zoom_level": 1.0
					},
					"stack_index": 275,
					"type": "text"
				},
				{
					"buffer": 534,
					"file": "src/Falcor/Core/API/DeviceManager.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3635,
						"regions":
						{
						},
						"selection":
						[
							[
								3218,
								3218
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 532.0,
						"zoom_level": 1.0
					},
					"stack_index": 110,
					"type": "text"
				},
				{
					"buffer": 535,
					"file": "src/Falcor/Core/API/Vulkan/VKDevice.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 28452,
						"regions":
						{
						},
						"selection":
						[
							[
								2940,
								2940
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2803.0,
						"zoom_level": 1.0
					},
					"stack_index": 117,
					"type": "text"
				},
				{
					"buffer": 536,
					"file": "src/Falcor/Core/API/Vulkan/VKGpuFence.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10228,
						"regions":
						{
						},
						"selection":
						[
							[
								10027,
								10027
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 124.0,
						"zoom_level": 1.0
					},
					"stack_index": 286,
					"type": "text"
				},
				{
					"buffer": 537,
					"file": "src/Falcor/Core/API/Vulkan/VKGpuTimer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2646,
						"regions":
						{
						},
						"selection":
						[
							[
								1791,
								1791
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 153.0,
						"zoom_level": 1.0
					},
					"stack_index": 421,
					"type": "text"
				},
				{
					"buffer": 538,
					"file": "src/Falcor/Core/API/D3D12/D3D12GpuFence.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3766,
						"regions":
						{
						},
						"selection":
						[
							[
								3204,
								3204
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 714.0,
						"zoom_level": 1.0
					},
					"stack_index": 595,
					"type": "text"
				},
				{
					"buffer": 539,
					"file": "src/Falcor/Core/API/GpuFence.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3526,
						"regions":
						{
						},
						"selection":
						[
							[
								2490,
								2490
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 598.0,
						"zoom_level": 1.0
					},
					"stack_index": 422,
					"type": "text"
				},
				{
					"buffer": 540,
					"file": "src/Falcor/Core/API/Vulkan/VKSmartHandle.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9756,
						"regions":
						{
						},
						"selection":
						[
							[
								3141,
								3141
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3335.0,
						"zoom_level": 1.0
					},
					"stack_index": 298,
					"type": "text"
				},
				{
					"buffer": 541,
					"file": "src/Falcor/Core/API/Vulkan/VKState.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 27538,
						"regions":
						{
						},
						"selection":
						[
							[
								2463,
								2463
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 9370.0,
						"zoom_level": 1.0
					},
					"stack_index": 402,
					"type": "text"
				},
				{
					"buffer": 542,
					"file": "src/Falcor/Core/API/Vulkan/VKTexture.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7857,
						"regions":
						{
						},
						"selection":
						[
							[
								7442,
								7442
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1799.0,
						"zoom_level": 1.0
					},
					"stack_index": 314,
					"type": "text"
				},
				{
					"buffer": 543,
					"file": "falcor.sublime-project",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2453,
						"regions":
						{
						},
						"selection":
						[
							[
								2326,
								2326
							]
						],
						"settings":
						{
							"syntax": "Packages/JavaScript/JSON.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 683.0,
						"zoom_level": 1.0
					},
					"stack_index": 158,
					"type": "text"
				},
				{
					"buffer": 544,
					"file": "third_party/slang/external/vulkan/include/vulkan/vulkan.hpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2369181,
						"regions":
						{
						},
						"selection":
						[
							[
								509353,
								509353
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 193521.0,
						"zoom_level": 1.0
					},
					"stack_index": 557,
					"type": "text"
				},
				{
					"buffer": 545,
					"file": "/usr/include/vulkan/vulkan.hpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4010350,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 584,
					"type": "text"
				},
				{
					"buffer": 546,
					"file": "third_party/slang/external/vulkan/include/vulkan/vulkan_core.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 451013,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 572,
					"type": "text"
				},
				{
					"buffer": 547,
					"file": "src/Falcor/Utils/Math/FalcorMath.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8456,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 596,
					"type": "text"
				},
				{
					"buffer": 548,
					"file": "src/Falcor/Core/Framework.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13061,
						"regions":
						{
						},
						"selection":
						[
							[
								2644,
								2644
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 778.0,
						"zoom_level": 1.0
					},
					"stack_index": 124,
					"type": "text"
				},
				{
					"buffer": 549,
					"file": "src/Falcor/Core/type.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6550,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 501,
					"type": "text"
				},
				{
					"buffer": 550,
					"file": "src/Falcor/Core/Framework.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2253,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 175,
					"type": "text"
				},
				{
					"buffer": 551,
					"file": "src/Falcor/Core/API/CopyContext.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7677,
						"regions":
						{
						},
						"selection":
						[
							[
								3015,
								3015
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 820.0,
						"zoom_level": 1.0
					},
					"stack_index": 269,
					"type": "text"
				},
				{
					"buffer": 552,
					"file": "src/Falcor/Core/API/VertexLayout.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1862,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 388,
					"type": "text"
				},
				{
					"buffer": 553,
					"file": "src/Falcor/Core/FalcorConfig.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2544,
						"regions":
						{
						},
						"selection":
						[
							[
								2500,
								2500
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 307,
					"type": "text"
				},
				{
					"buffer": 554,
					"file": "src/Falcor/RenderGraph/RenderPassStandardFlags.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2479,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 579,
					"type": "text"
				},
				{
					"buffer": 555,
					"file": "src/Falcor/Falcor.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6959,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 469,
					"type": "text"
				},
				{
					"buffer": 556,
					"file": "src/Falcor/Utils/Debug/PixelDebug.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5769,
						"regions":
						{
						},
						"selection":
						[
							[
								5769,
								5769
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1326.0,
						"zoom_level": 1.0
					},
					"stack_index": 363,
					"type": "text"
				},
				{
					"buffer": 557,
					"file": "src/Falcor/Utils/Image/Bitmap.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6060,
						"regions":
						{
						},
						"selection":
						[
							[
								3538,
								3538
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1326.0,
						"zoom_level": 1.0
					},
					"stack_index": 362,
					"type": "text"
				},
				{
					"buffer": 558,
					"file": "src/Falcor/Utils/Image/Bitmap.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 21119,
						"regions":
						{
						},
						"selection":
						[
							[
								7400,
								7400
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2612.0,
						"zoom_level": 1.0
					},
					"stack_index": 361,
					"type": "text"
				},
				{
					"buffer": 559,
					"file": "src/Falcor/Utils/Scripting/ScriptBindings.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10279,
						"regions":
						{
						},
						"selection":
						[
							[
								9480,
								9480
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 155.0,
						"zoom_level": 1.0
					},
					"stack_index": 109,
					"type": "text"
				},
				{
					"buffer": 560,
					"file": "/home/max/Desktop/compos.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1267,
						"regions":
						{
						},
						"selection":
						[
							[
								1205,
								1205
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 295,
					"type": "text"
				},
				{
					"buffer": 561,
					"file": "src/Falcor/Utils/Scripting/Console.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2101,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 108,
					"type": "text"
				},
				{
					"buffer": 562,
					"file": "src/Falcor/Utils/Scripting/Scripting.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5726,
						"regions":
						{
						},
						"selection":
						[
							[
								3778,
								3778
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1447.0,
						"zoom_level": 1.0
					},
					"stack_index": 106,
					"type": "text"
				},
				{
					"buffer": 563,
					"file": "src/Falcor/Core/API/DescriptorPool.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5596,
						"regions":
						{
						},
						"selection":
						[
							[
								3627,
								3627
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1275.0,
						"zoom_level": 1.0
					},
					"stack_index": 313,
					"type": "text"
				},
				{
					"buffer": 564,
					"file": "src/Falcor/Core/API/DescriptorPool.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2683,
						"regions":
						{
						},
						"selection":
						[
							[
								2157,
								2157
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 312,
					"type": "text"
				},
				{
					"buffer": 565,
					"file": "src/Falcor/Core/State/GraphicsState.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10063,
						"regions":
						{
						},
						"selection":
						[
							[
								9145,
								9145
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3188.0,
						"zoom_level": 1.0
					},
					"stack_index": 396,
					"type": "text"
				},
				{
					"buffer": 566,
					"file": "src/Falcor/Core/State/GraphicsState.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8458,
						"regions":
						{
						},
						"selection":
						[
							[
								2784,
								2784
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 451.0,
						"zoom_level": 1.0
					},
					"stack_index": 393,
					"type": "text"
				},
				{
					"buffer": 567,
					"file": "src/Falcor/Core/State/ComputeState.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3405,
						"regions":
						{
						},
						"selection":
						[
							[
								2529,
								2529
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 153.0,
						"zoom_level": 1.0
					},
					"stack_index": 404,
					"type": "text"
				},
				{
					"buffer": 568,
					"file": "src/Falcor/Core/API/ComputeStateObject.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2465,
						"regions":
						{
						},
						"selection":
						[
							[
								2089,
								2089
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 397,
					"type": "text"
				},
				{
					"buffer": 569,
					"file": "src/Falcor/Core/API/GpuTimer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4479,
						"regions":
						{
						},
						"selection":
						[
							[
								3328,
								3328
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 459.0,
						"zoom_level": 1.0
					},
					"stack_index": 426,
					"type": "text"
				},
				{
					"buffer": 570,
					"file": "src/Falcor/Core/State/ComputeState.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3782,
						"regions":
						{
						},
						"selection":
						[
							[
								2662,
								2662
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 349.0,
						"zoom_level": 1.0
					},
					"stack_index": 405,
					"type": "text"
				},
				{
					"buffer": 571,
					"file": "src/Falcor/Core/State/StateGraph.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4323,
						"regions":
						{
						},
						"selection":
						[
							[
								4098,
								4098
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 102.0,
						"zoom_level": 1.0
					},
					"stack_index": 399,
					"type": "text"
				},
				{
					"buffer": 572,
					"file": "src/Falcor/Raytracing/RtProgram/RtProgram.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7986,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 599,
					"type": "text"
				},
				{
					"buffer": 573,
					"file": "src/Falcor/Raytracing/RtProgram/RtProgram.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6561,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 598,
					"type": "text"
				},
				{
					"buffer": 574,
					"file": "src/Mogwai/AppData.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2896,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 408.0,
						"zoom_level": 1.0
					},
					"stack_index": 357,
					"type": "text"
				},
				{
					"buffer": 575,
					"file": "src/Falcor/Core/Platform/Linux/ProgressBarLinux.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5059,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 589,
					"type": "text"
				},
				{
					"buffer": 576,
					"file": "src/Mogwai/AppData.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5386,
						"regions":
						{
						},
						"selection":
						[
							[
								2276,
								2276
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1071.0,
						"zoom_level": 1.0
					},
					"stack_index": 172,
					"type": "text"
				},
				{
					"buffer": 577,
					"file": "src/Mogwai/Extensions/Capture/CaptureTrigger.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3842,
						"regions":
						{
						},
						"selection":
						[
							[
								2782,
								2782
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 459.0,
						"zoom_level": 1.0
					},
					"stack_index": 177,
					"type": "text"
				},
				{
					"buffer": 578,
					"file": "src/Falcor/Core/Sample.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 25053,
						"regions":
						{
						},
						"selection":
						[
							[
								23955,
								23955
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 9735.0,
						"zoom_level": 1.0
					},
					"stack_index": 116,
					"type": "text"
				},
				{
					"buffer": 579,
					"file": "src/Falcor/Core/API/VertexLayout.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7327,
						"regions":
						{
						},
						"selection":
						[
							[
								7087,
								7087
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1977.0,
						"zoom_level": 1.0
					},
					"stack_index": 290,
					"type": "text"
				},
				{
					"buffer": 580,
					"file": "src/Falcor/Core/API/DeviceManager.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5194,
						"regions":
						{
						},
						"selection":
						[
							[
								3234,
								3234
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1688.0,
						"zoom_level": 1.0
					},
					"stack_index": 111,
					"type": "text"
				},
				{
					"buffer": 581,
					"file": "src/Falcor/Core/API/Vulkan/VkQueryHeap.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2779,
						"regions":
						{
						},
						"selection":
						[
							[
								2659,
								2659
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 190.0,
						"zoom_level": 1.0
					},
					"stack_index": 303,
					"type": "text"
				},
				{
					"buffer": 582,
					"file": "src/Falcor/Core/API/D3D12/D3D12Device.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15156,
						"regions":
						{
						},
						"selection":
						[
							[
								11323,
								11323
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4233.0,
						"zoom_level": 1.0
					},
					"stack_index": 428,
					"type": "text"
				},
				{
					"buffer": 583,
					"file": "src/Falcor/Core/API/DescriptorSet.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5856,
						"regions":
						{
						},
						"selection":
						[
							[
								5033,
								5033
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1173.0,
						"zoom_level": 1.0
					},
					"stack_index": 317,
					"type": "text"
				},
				{
					"buffer": 584,
					"file": "src/Falcor/Core/API/DescriptorSet.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2618,
						"regions":
						{
						},
						"selection":
						[
							[
								2546,
								2546
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 315,
					"type": "text"
				},
				{
					"buffer": 585,
					"file": "src/Falcor/Core/API/ResourceViews.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5611,
						"regions":
						{
						},
						"selection":
						[
							[
								2562,
								2562
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 853.0,
						"zoom_level": 1.0
					},
					"stack_index": 301,
					"type": "text"
				},
				{
					"buffer": 586,
					"file": "Falcor.sln",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 19418,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 597,
					"type": "text"
				},
				{
					"buffer": 587,
					"file": "src/Falcor/Scene/Scene.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 25118,
						"regions":
						{
						},
						"selection":
						[
							[
								7107,
								7107
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 8670.0,
						"zoom_level": 1.0
					},
					"stack_index": 266,
					"type": "text"
				},
				{
					"buffer": 588,
					"file": "src/Falcor/RenderGraph/RenderGraphUI.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8554,
						"regions":
						{
						},
						"selection":
						[
							[
								2602,
								2602
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 697.0,
						"zoom_level": 1.0
					},
					"stack_index": 253,
					"type": "text"
				},
				{
					"buffer": 589,
					"file": "src/Falcor/RenderGraph/RenderGraph.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11413,
						"regions":
						{
						},
						"selection":
						[
							[
								2635,
								2635
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1938.0,
						"zoom_level": 1.0
					},
					"stack_index": 284,
					"type": "text"
				},
				{
					"buffer": 590,
					"file": "src/Falcor/RenderGraph/ResourceCache.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5357,
						"regions":
						{
						},
						"selection":
						[
							[
								5357,
								5357
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1224.0,
						"zoom_level": 1.0
					},
					"stack_index": 278,
					"type": "text"
				},
				{
					"buffer": 591,
					"file": "src/Falcor/RenderGraph/BasePasses/RasterScenePass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4425,
						"regions":
						{
						},
						"selection":
						[
							[
								4186,
								4186
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 561.0,
						"zoom_level": 1.0
					},
					"stack_index": 242,
					"type": "text"
				},
				{
					"buffer": 592,
					"file": "src/Falcor/Utils/Debug/DebugConsole.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4292,
						"regions":
						{
						},
						"selection":
						[
							[
								2156,
								2156
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 143.0,
						"zoom_level": 1.0
					},
					"stack_index": 484,
					"type": "text"
				},
				{
					"buffer": 593,
					"file": "src/Falcor/Scene/SceneBuilder.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11802,
						"regions":
						{
						},
						"selection":
						[
							[
								10308,
								10308
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1221.0,
						"zoom_level": 1.0
					},
					"stack_index": 265,
					"type": "text"
				},
				{
					"buffer": 594,
					"file": "src/Falcor/Utils/Debug/debug.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2463,
						"regions":
						{
						},
						"selection":
						[
							[
								263,
								263
							]
						],
						"settings":
						{
							"auto_name": "#ifndef __FALCOR_DEBUG_H__",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 17,
					"type": "text"
				},
				{
					"buffer": 595,
					"file": "src/Falcor/Core/BufferTypes/ParameterBlock.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 20403,
						"regions":
						{
						},
						"selection":
						[
							[
								15970,
								15970
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1197.0,
						"zoom_level": 1.0
					},
					"stack_index": 260,
					"type": "text"
				},
				{
					"buffer": 596,
					"file": "src/Falcor/Scene/Scene.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 49096,
						"regions":
						{
						},
						"selection":
						[
							[
								6768,
								6768
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2906.0,
						"zoom_level": 1.0
					},
					"stack_index": 263,
					"type": "text"
				},
				{
					"buffer": 597,
					"file": "src/Falcor/Scene/Camera/CameraController.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9863,
						"regions":
						{
						},
						"selection":
						[
							[
								9668,
								9668
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3353.0,
						"zoom_level": 1.0
					},
					"stack_index": 346,
					"type": "text"
				},
				{
					"buffer": 598,
					"file": "src/Falcor/Scene/Camera/Camera.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13365,
						"regions":
						{
						},
						"selection":
						[
							[
								11054,
								11054
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3829.0,
						"zoom_level": 1.0
					},
					"stack_index": 345,
					"type": "text"
				},
				{
					"buffer": 599,
					"file": "src/Falcor/Core/API/D3D12/D3D12Resource.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6227,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 594,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 38.0
	},
	"input":
	{
		"height": 40.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.SublimeLinter":
	{
		"height": 0.0
	},
	"output.find_results":
	{
		"height": 120.0
	},
	"output.unsaved_changes":
	{
		"height": 120.0
	},
	"pinned_build_system": "Packages/Makefile/Make.sublime-build",
	"project": "falcor.sublime-project",
	"replace":
	{
		"height": 70.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 362.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
