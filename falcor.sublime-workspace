{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"cre",
				"create2D"
			],
			[
				"pO",
				"pOutTex"
			],
			[
				"uint",
				"uint32_t"
			],
			[
				"ui",
				"uint32_t"
			],
			[
				"pT",
				"pTargetFbo"
			],
			[
				"mpDe",
				"mpDevice"
			],
			[
				"res",
				"resourceFormat"
			],
			[
				"arr",
				"arraySlice"
			],
			[
				"read",
				"readTextureData"
			],
			[
				"Re",
				"ResourceFormat"
			],
			[
				"tex",
				"textureData"
			],
			[
				"ar",
				"arraySlice"
			],
			[
				"mi",
				"mipLevel"
			],
			[
				"ren",
				"renderFrame"
			],
			[
				"dev",
				"device"
			],
			[
				"pC",
				"pContext"
			],
			[
				"getRe",
				"getRenderContext"
			],
			[
				"DE",
				"Device"
			],
			[
				"pr",
				"printf\tprintf â€¦"
			],
			[
				"de",
				"device"
			],
			[
				"inc",
				"include"
			],
			[
				"en",
				"enableDebugLayer"
			],
			[
				"mp",
				"mpWindow"
			],
			[
				"in",
				"instance"
			],
			[
				"Device",
				"DeviceManager"
			],
			[
				"Devi",
				"DeviceManger"
			],
			[
				"p",
				"pDevice"
			],
			[
				"Dev",
				"DeviceID"
			],
			[
				"De",
				"DeviceID"
			],
			[
				"name",
				"namespace"
			],
			[
				"crea",
				"createInstance"
			],
			[
				"str",
				"struct\tstruct"
			],
			[
				"un",
				"unordered_map\tstandard header (since c++11)"
			],
			[
				"i",
				"instance"
			],
			[
				"s",
				"string"
			],
			[
				"_",
				"_gpDevice"
			],
			[
				"R",
				"RenderGraph"
			],
			[
				"Rend",
				"RenderGraph"
			],
			[
				"def",
				"default"
			],
			[
				"LOG",
				"LOG_WARN"
			],
			[
				"sha",
				"shared_from_this"
			],
			[
				"swap",
				"swapchain"
			],
			[
				"LO",
				"LOG_ERR"
			],
			[
				"get",
				"getResource"
			],
			[
				"VK",
				"VkResource"
			],
			[
				"gN",
				"gNullBufferViews"
			],
			[
				"flat",
				"flatIndex"
			],
			[
				"ass",
				"assignedSRV"
			],
			[
				"GBu",
				"GBufferBase"
			],
			[
				"Render",
				"RenderPasses"
			],
			[
				"Ren",
				"RenderPasses"
			],
			[
				"uin",
				"uint8_t"
			],
			[
				"pRe",
				"pRenderContext"
			],
			[
				"c",
				"ctx"
			],
			[
				"Pro",
				"Profiler"
			],
			[
				"cur",
				"curEventName"
			],
			[
				"shared",
				"shared_ptr"
			],
			[
				"Shader",
				"ShaderVar"
			],
			[
				"Gr",
				"GraphicsStateObject"
			],
			[
				"st",
				"stack\tstandard header"
			],
			[
				"VkB",
				"VkBaseApiHandle"
			],
			[
				"sem",
				"semaphoreQueue"
			],
			[
				"fe",
				"fenceQueue"
			],
			[
				"Fe",
				"FenceApiData"
			],
			[
				"Sha",
				"SharedPtr"
			],
			[
				"rele",
				"release"
			],
			[
				"n",
				"nullptr"
			],
			[
				"re",
				"return"
			],
			[
				"colo",
				"colorFormat"
			],
			[
				"init",
				"initHeadless"
			],
			[
				"hea",
				"headless"
			],
			[
				"render",
				"renderer"
			],
			[
				"g",
				"getWidth"
			],
			[
				"mD",
				"mDrawCounterClockwiseMeshes"
			],
			[
				"FA",
				"FALCOR_VK"
			],
			[
				"FALC",
				"FALCOR_D3D12"
			],
			[
				"fl",
				"float3"
			],
			[
				"mS",
				"mStructSize"
			],
			[
				"RE",
				"ResourceFormat"
			],
			[
				"ins",
				"instanceCount"
			],
			[
				"inde",
				"indexCount"
			],
			[
				"co",
				"common"
			],
			[
				"bin",
				"bind"
			],
			[
				"A",
				"API"
			],
			[
				"desc",
				"descriptor"
			],
			[
				"des",
				"descSetIndex"
			],
			[
				"ad",
				"addRange"
			],
			[
				"reg",
				"regSpace"
			],
			[
				"max",
				"maxIndex"
			],
			[
				"getR",
				"getRootDescriptorCount"
			],
			[
				"mDe",
				"mDesc"
			],
			[
				"Vis",
				"ShaderVisibility"
			],
			[
				"G",
				"GraphicsStateObject"
			],
			[
				"bind",
				"binding"
			],
			[
				"VkP",
				"VkPipelineLayoutCreateInfo"
			],
			[
				"inf",
				"infosOut"
			],
			[
				"Sh",
				"ShaderType"
			],
			[
				"LOG_",
				"LOG_DBG"
			],
			[
				"sp",
				"spaceIndex"
			],
			[
				"add",
				"addRootDescriptor"
			],
			[
				"set",
				"setCount"
			],
			[
				"Roo",
				"RootSignature"
			],
			[
				"ma",
				"map\tstandard header"
			],
			[
				"DESCRIPT",
				"descriptor"
			],
			[
				"e",
				"else"
			],
			[
				"ele",
				"numElems"
			],
			[
				"log_",
				"LOG_ERR"
			],
			[
				"ima",
				"imageLayout"
			],
			[
				"prepare",
				"prepareDescriptorSets"
			],
			[
				"Comp",
				"ComputeVars"
			],
			[
				"ap",
				"applyComputeVars"
			],
			[
				"Lo",
				"LOG_DBG"
			],
			[
				"bi",
				"bindFlags"
			],
			[
				"sw",
				"swapchainCount"
			],
			[
				"se",
				"setUav"
			],
			[
				"strin",
				"string"
			],
			[
				"Gp",
				"GpuFence"
			],
			[
				"to",
				"to_string"
			],
			[
				"Scri",
				"ScriptBindings"
			],
			[
				"arg",
				"argv"
			],
			[
				"file",
				"filePath"
			],
			[
				"tr",
				"triangleCount"
			],
			[
				"me",
				"meshInstanceCount"
			],
			[
				"ex",
				"executableDirectory"
			],
			[
				"h",
				"height"
			],
			[
				"wi",
				"width"
			],
			[
				"vect",
				"vector\tstandard header"
			],
			[
				"vec",
				"vector\tstandard header"
			]
		]
	},
	"buffers":
	[
		{
			"file": "src/Falcor/Core/API/D3D12/D3D12ResourceViews.cpp",
			"settings":
			{
				"buffer_size": 18914,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "Searching 1282 files for \"= delete\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/BufferTypes/ParameterBlock.h:\n  317  \n  318      // Delete some functions. If they are not deleted, the compiler will try to convert the uints to string, resulting in runtime error\n  319:     Sampler::SharedPtr getSampler(uint32_t) = delete;\n  320:     bool setSampler(uint32_t, const Sampler::SharedPtr&) = delete;\n  321  \n  322      using SpecializationArgs = std::vector<slang::SpecializationArg>;\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramVersion.h:\n   58      protected:\n   59          EntryPointGroup() = default;\n   60:         EntryPointGroup(const EntryPointGroup&) = delete;\n   61:         EntryPointGroup& operator=(const EntryPointGroup&) = delete;\n   62  \n   63          Type mType;\n   ..\n   94          EntryPointGroupKernels(Type type, const Shaders& shaders);\n   95          EntryPointGroupKernels() = default;\n   96:         EntryPointGroupKernels(const EntryPointGroupKernels&) = delete;\n   97:         EntryPointGroupKernels& operator=(const EntryPointGroupKernels&) = delete;\n   98  \n   99          Type mType;\n\n/home/max/dev/Falcor/src/Falcor/Core/Renderer.h:\n  172  \n  173      // Deleted copy operators (copy a pointer type!)\n  174:     IRenderer(const IRenderer&) = delete;\n  175:     IRenderer& operator=(const IRenderer &) = delete;\n  176  };\n  177  \n\n/home/max/dev/Falcor/src/Falcor/Core/Sample.h:\n  149  \n  150      Sample(IRenderer::UniquePtr& pRenderer) : mpRenderer(std::move(pRenderer)) {}\n  151:     Sample(const Sample&) = delete;\n  152:     Sample& operator=(const Sample&) = delete;\n  153  \n  154      Device::SharedPtr mpDevice;\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVH.h:\n  102              // Assignment is unsafe given how |triangleIndices| is allocated.\n  103              LeafNode() = default;\n  104:             LeafNode(const LeafNode &) = delete;\n  105:             LeafNode &operator=(const LeafNode &) = delete;\n  106          };\n  107  \n\n/home/max/dev/Falcor/src/Falcor/Raytracing/RtProgram/RtProgram.h:\n  133  \n  134      private:\n  135:         RtProgram(RtProgram const&) = delete;\n  136:         RtProgram& operator=(RtProgram const&) = delete;\n  137  \n  138          RtProgram(const Desc& desc, uint32_t maxPayloadSize = FALCOR_RT_MAX_PAYLOAD_SIZE_IN_BYTES, uint32_t maxAttributesSize = D3D12_RAYTRACING_MAX_ATTRIBUTE_SIZE_IN_BYTES);\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderPassLibrary.h:\n   36       public:\n   37          RenderPassLibrary() = default;\n   38:         RenderPassLibrary(RenderPassLibrary&) = delete;\n   39          ~RenderPassLibrary();\n   40          using CreateFunc = std::function<RenderPass::SharedPtr(RenderContext*, const Dictionary&)>;\n\n/home/max/dev/Falcor/src/Falcor/Scene/Importers/AssimpImporter.h:\n   40      private:\n   41          AssimpImporter() = default;\n   42:         AssimpImporter(const AssimpImporter&) = delete;\n   43:         void operator=(const AssimpImporter&) = delete;\n   44      };\n   45  }\n\n/home/max/dev/Falcor/src/Falcor/Scene/ParticleSystem/ParticleSystem.h:\n  144  \n  145      private:\n  146:         ParticleSystem() = delete;\n  147          ParticleSystem(RenderContext* pCtx, uint32_t maxParticles, uint32_t maxEmitPerFrame,\n  148              std::string drawPixelShader, std::string simulateComputeShader, bool sorted);\n\n/home/max/dev/Falcor/src/Falcor/Utils/Logger.h:\n   99  \n  100          static void log(Level L, const std::string& msg, MsgBox mbox = Logger::MsgBox::Auto);\n  101:         Logger() = delete;\n  102      };\n  103  \n\n/home/max/dev/Falcor/src/Falcor/Utils/UI/Font.h:\n   81      private:\n   82          Font();\n   83:         Font(const Font&) = delete;\n   84:         Font& operator=(const Font&) = delete;\n   85  \n   86          bool loadFromFile(const std::string& fontName, float size);\n\n/home/max/dev/Falcor/src/Tools/ImageCompare/args.h:\n 1646              }\n 1647  \n 1648:             Subparser(const Subparser&) = delete;\n 1649:             Subparser(Subparser&&) = delete;\n 1650:             Subparser &operator = (const Subparser&) = delete;\n 1651:             Subparser &operator = (Subparser&&) = delete;\n 1652  \n 1653              const Command &GetCommand()\n\n/home/max/dev/Falcor/src/USD/hgiVk/blitEncoder.h:\n   45  \n   46  private:\n   47:     HgiVkBlitEncoder() = delete;\n   48:     HgiVkBlitEncoder & operator=(const HgiVkBlitEncoder&) = delete;\n   49:     HgiVkBlitEncoder(const HgiVkBlitEncoder&) = delete;\n   50  \n   51  private:\n\n/home/max/dev/Falcor/src/USD/hgiVk/buffer.h:\n   64  \n   65  private:\n   66:     HgiVkBuffer() = delete;\n   67:     HgiVkBuffer & operator=(const HgiVkBuffer&) = delete;\n   68:     HgiVkBuffer(const HgiVkBuffer&) = delete;\n   69  \n   70  private:\n\n/home/max/dev/Falcor/src/USD/hgiVk/commandBuffer.h:\n  110  \n  111  private:\n  112:     HgiVkCommandBuffer() = delete;\n  113:     HgiVkCommandBuffer & operator= (const HgiVkCommandBuffer&) = delete;\n  114:     HgiVkCommandBuffer(const HgiVkCommandBuffer&) = delete;\n  115  \n  116      // Ensures a command buffer is ready to record commands.\n\n/home/max/dev/Falcor/src/USD/hgiVk/commandBufferManager.h:\n  102  \n  103  private:\n  104:     HgiVkCommandBufferManager() = delete;\n  105      HgiVkCommandBufferManager & operator= (\n  106:         const HgiVkCommandBufferManager&) = delete;\n  107      HgiVkCommandBufferManager(\n  108:         const HgiVkCommandBufferManager&) = delete;\n  109  \n  110      // Create pools and command buffers for parallel recording.\n\n/home/max/dev/Falcor/src/USD/hgiVk/commandPool.h:\n   41  \n   42  private:\n   43:     HgiVkCommandPool() = delete;\n   44:     HgiVkCommandPool & operator= (const HgiVkCommandPool&) = delete;\n   45:     HgiVkCommandPool(const HgiVkCommandPool&) = delete;\n   46  \n   47  private:\n\n/home/max/dev/Falcor/src/USD/hgiVk/computeEncoder.h:\n   55  \n   56  private:\n   57:     HgiVkComputeEncoder() = delete;\n   58:     HgiVkComputeEncoder & operator=(const HgiVkComputeEncoder&) = delete;\n   59:     HgiVkComputeEncoder(const HgiVkComputeEncoder&) = delete;\n   60  \n   61  private:\n\n/home/max/dev/Falcor/src/USD/hgiVk/device.h:\n  167  \n  168  private:\n  169:     HgiVkDevice() = delete;\n  170:     HgiVkDevice & operator=(const HgiVkDevice&) = delete;\n  171:     HgiVkDevice(const HgiVkDevice&) = delete;\n  172  \n  173      // Returns true if the provided extension is supported by the device\n\n/home/max/dev/Falcor/src/USD/hgiVk/frame.h:\n   56  \n   57  private:\n   58:     HgiVkRenderFrame() = delete;\n   59:     HgiVkRenderFrame & operator=(const HgiVkRenderFrame&) = delete;\n   60:     HgiVkRenderFrame(const HgiVkRenderFrame&) = delete;\n   61  \n   62  private:\n\n/home/max/dev/Falcor/src/USD/hgiVk/garbageCollector.h:\n   41  \n   42  private:\n   43:     HgiVkGarbageCollector & operator=(const HgiVkGarbageCollector&) = delete;\n   44:     HgiVkGarbageCollector(const HgiVkGarbageCollector&) = delete;\n   45  \n   46      typedef std::vector<HgiVkObject> VkObjectVector;\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/ShaderLang.cpp:\n  982                             std::string* output)\n  983        : getLastSourceIndex(lastSourceIndex), output(output), lastSource(-1), lastLine(0) {}\n  984: //    SourceLineSynchronizer(const SourceLineSynchronizer&) = delete;\n  985: //    SourceLineSynchronizer& operator=(const SourceLineSynchronizer&) = delete;\n  986  \n  987      // Sets the internally tracked source string index to that of the most\n\n/home/max/dev/Falcor/src/USD/hgiVk/graphicsEncoder.h:\n   94  \n   95  private:\n   96:     HgiVkGraphicsEncoder() = delete;\n   97:     HgiVkGraphicsEncoder & operator=(const HgiVkGraphicsEncoder&) = delete;\n   98:     HgiVkGraphicsEncoder(const HgiVkGraphicsEncoder&) = delete;\n   99  \n  100  private:\n\n/home/max/dev/Falcor/src/USD/hgiVk/hgi.h:\n  150  \n  151  private:\n  152:     HgiVk & operator=(const HgiVk&) = delete;\n  153:     HgiVk(const HgiVk&) = delete;\n  154  \n  155      // Begin a new frame of rendering.\n\n/home/max/dev/Falcor/src/USD/hgiVk/parallelGraphicsEncoder.h:\n   44  \n   45  private:\n   46:     HgiVkParallelGraphicsEncoder() = delete;\n   47      HgiVkParallelGraphicsEncoder & operator=(\n   48:         const HgiVkParallelGraphicsEncoder&) = delete;\n   49      HgiVkParallelGraphicsEncoder(\n   50:         const HgiVkParallelGraphicsEncoder&) = delete;\n   51  \n   52  private:\n\n/home/max/dev/Falcor/src/USD/hgiVk/pipeline.h:\n   46  \n   47  private:\n   48:     HgiVkPipeline() = delete;\n   49:     HgiVkPipeline & operator=(const HgiVkPipeline&) = delete;\n   50:     HgiVkPipeline(const HgiVkPipeline&) = delete;\n   51  \n   52      // In Vulkan pipelines require compatibility with render passes.\n\n/home/max/dev/Falcor/src/USD/hgiVk/renderPass.h:\n  121  \n  122  private:\n  123:     HgiVkRenderPass() = delete;\n  124:     HgiVkRenderPass & operator=(const HgiVkRenderPass&) = delete;\n  125:     HgiVkRenderPass(const HgiVkRenderPass&) = delete;\n  126  \n  127      // Extracts the render pass information for one texture.\n\n/home/max/dev/Falcor/src/USD/hgiVk/renderPassPipelineCache.h:\n   71  private:\n   72      HgiVkRenderPassPipelineCache & operator= (\n   73:         const HgiVkRenderPassPipelineCache&) = delete;\n   74:     HgiVkRenderPassPipelineCache(const HgiVkRenderPassPipelineCache&) = delete;\n   75  \n   76  private:\n\n/home/max/dev/Falcor/src/USD/hgiVk/resourceBindings.h:\n   78  \n   79  private:\n   80:     HgiVkResourceBindings() = delete;\n   81:     HgiVkResourceBindings & operator=(const HgiVkResourceBindings&) = delete;\n   82:     HgiVkResourceBindings(const HgiVkResourceBindings&) = delete;\n   83  \n   84  private:\n\n/home/max/dev/Falcor/src/USD/hgiVk/shaderCompiler.h:\n   50  \n   51  private:\n   52:     HgiVkShaderCompiler & operator=(const HgiVkShaderCompiler&) = delete;\n   53:     HgiVkShaderCompiler(const HgiVkShaderCompiler&) = delete;\n   54  \n   55  private:\n\n/home/max/dev/Falcor/src/USD/hgiVk/shaderFunction.h:\n   48  \n   49  private:\n   50:     HgiVkShaderFunction() = delete;\n   51:     HgiVkShaderFunction & operator=(const HgiVkShaderFunction&) = delete;\n   52:     HgiVkShaderFunction(const HgiVkShaderFunction&) = delete;\n   53  \n   54  private:\n\n/home/max/dev/Falcor/src/USD/hgiVk/shaderProgram.h:\n   29  \n   30  private:\n   31:     HgiVkShaderProgram() = delete;\n   32:     HgiVkShaderProgram & operator=(const HgiVkShaderProgram&) = delete;\n   33:     HgiVkShaderProgram(const HgiVkShaderProgram&) = delete;\n   34  \n   35  private:\n\n/home/max/dev/Falcor/src/USD/hgiVk/surface.h:\n   53  \n   54  private:\n   55:     HgiVkSurface() = delete;\n   56:     HgiVkSurface & operator=(const HgiVkSurface&) = delete;\n   57:     HgiVkSurface(const HgiVkSurface&) = delete;\n   58  \n   59  private:\n\n/home/max/dev/Falcor/src/USD/hgiVk/swapchain.h:\n   58  \n   59  private:\n   60:     HgiVkSwapchain() = delete;\n   61:     HgiVkSwapchain & operator=(const HgiVkSwapchain&) = delete;\n   62:     HgiVkSwapchain(const HgiVkSwapchain&) = delete;\n   63  \n   64      // Create a new swapchain (e.g. during resize)\n\n/home/max/dev/Falcor/src/USD/hgiVk/texture.h:\n   80  \n   81  private:\n   82:     HgiVkTexture() = delete;\n   83:     HgiVkTexture & operator=(const HgiVkTexture&) = delete;\n   84:     HgiVkTexture(const HgiVkTexture&) = delete;\n   85  \n   86  private:\n\n/home/max/dev/Falcor/src/USD/hgiVk/vulkanMemoryAllocator/vk_mem_alloc.h:\n 3842      #define VMA_CLASS_NO_COPY(className) \\\n 3843          private: \\\n 3844:             className(const className&) = delete; \\\n 3845:             className& operator=(const className&) = delete;\n 3846  #endif\n 3847  \n ....\n 4370      }\n 4371  \n 4372:     VmaStlAllocator& operator=(const VmaStlAllocator& x) = delete;\n 4373  };\n 4374  \n\n92 matches across 36 files\n\n\nSearching 1282 files for \"LightCollection\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/BuildTriangleList.cs.slang:\n   30  import Scene.Scene;\n   31  import Utils.Color.ColorHelpers;\n   32: import Experimental.Scene.Lights.LightCollection;\n   33  \n   34  cbuffer CB\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/EmissiveIntegrator.ps.slang:\n   31  */\n   32  import Scene.Scene;\n   33: import Experimental.Scene.Lights.LightCollection;\n   34  \n   35  // Setup NvApi. We need this for fp32 atomics.\n   ..\n   43  #endif\n   44  \n   45: ParameterBlock<LightCollection> gLightCollection;\n   46  \n   47  RWByteAddressBuffer gTexelSum;          ///< Sum over texels (RGB) + number of texels (A) in RGBA32Float format. Using raw buffer for fp32 atomics compatibility.\n   ..\n   65      // Fetch light index\n   66      const uint triIdx = vtxIdx / 3;\n   67:     const uint id = gLightCollection.getLightIdx(triIdx);\n   68  \n   69      VsOut vsOut;\n   ..\n   73  \n   74      // Check if triangle is textured.\n   75:     if (gScene.isEmissiveTextured(gLightCollection.getMaterialID(triIdx)))\n   76      {\n   77          // TODO: We could do these computations in a geometry shader once per triangle,\n   ..\n   82          for (uint j = 0; j < 3; j++)\n   83          {\n   84:             uv[j] = gLightCollection.getVtxTexCoord(triIdx + j);\n   85          }\n   86          const float2 uvMin = min(min(uv[0], uv[1]), uv[2]);\n   ..\n   88  \n   89          // Pass on texture coordinate unmodified for pixel to use.\n   90:         vsOut.uv = gLightCollection.getVtxTexCoord(vtxIdx);                 // Normalized (u,v) coordinate.\n   91  \n   92          // Query texture dimensions.\n   93          float width = 0, height = 0, mips = 0;\n   94:         gScene.materialResources[gLightCollection.meshData[id].materialID].emissive.GetDimensions(0, width, height, mips);\n   95  \n   96          // Compute raster position in texture space.\n   ..\n  125      const float2 uv = vsIn.uv;        // Interpolated texture coordinate.\n  126      const uint lightIdx = vsIn.lightIdx;\n  127:     float3 color = gScene.materialResources[gLightCollection.meshData[lightIdx].materialID].emissive.SampleLevel(gPointSampler, uv, 0.f).rgb;  // Sampler at mip 0\n  128  \n  129      // Compute weighted color. TODO: For now assume full coverage (= 1.0 in weight).\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/EmissiveLightSamplerHelpers.slang:\n   29  /** Shared utility functions for emissive light sampler implementations.\n   30  \n   31:      These functions rely on LightCollection, which is a container holding the\n   32       global list of all emissive triangles in the scene.\n   33  \n   ..\n   41  import Scene.ShadingData;\n   42  import Utils.Math.MathHelpers;\n   43: import Experimental.Scene.Lights.LightCollection;\n   44  import Experimental.Scene.Lights.EmissiveLightSamplerInterface;\n   45  \n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/EmissiveUniformSampler.cpp:\n   41      {\n   42          // Make sure the light collection is created.\n   43:         mpScene->getLightCollection(pRenderContext);\n   44      }\n   45  \n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/EmissiveUniformSampler.h:\n   28  #pragma once\n   29  #include \"EmissiveLightSampler.h\"\n   30: #include \"LightCollection.h\"\n   31  \n   32  namespace Falcor\n   ..\n   34      /** Emissive light sampler using uniform sampling of the lights.\n   35  \n   36:         This class wraps a LightCollection object, which holds the set of lights to sample.\n   37      */\n   38      class dlldecl EmissiveUniformSampler : public EmissiveLightSampler, public inherit_shared_from_this<EmissiveLightSampler, EmissiveUniformSampler>\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/EmissiveUniformSampler.slang:\n   38      EmissiveLightSamplerInterface.slang for usage information).\n   39  \n   40:     The struct wraps a LightCollection that stores the pre-processed lights.\n   41      The program should instantiate the struct below. See EmissiveLightSampler.slang.\n   42  */\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/FinalizeIntegration.cs.slang:\n   30  import Scene.Scene;\n   31  import Utils.Color.ColorHelpers;\n   32: import Experimental.Scene.Lights.LightCollection;\n   33  \n   34  cbuffer CB\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVH.cpp:\n   35  namespace Falcor {\n   36  \n   37:     LightBVH::SharedPtr LightBVH::create(std::shared_ptr<Device> device, const LightCollection::SharedConstPtr& pLightCollection) {\n   38:         return SharedPtr(new LightBVH(device, pLightCollection));\n   39      }\n   40  \n   ..\n   46  \n   47          const ComputeVars::SharedPtr& pLeafUpdaterVars = mLeafUpdater->getVars();\n   48:         mpLightCollection->setShaderData(pLeafUpdaterVars[\"CB\"][\"gLights\"]);\n   49          pLeafUpdaterVars[\"CB\"][\"gLightBVH\"][\"nodes\"] = mpBVHNodesBuffer;\n   50          pLeafUpdaterVars[\"gNodeOffsets\"] = mpNodeOffsetsBuffer;\n   51  \n   52          const ComputeVars::SharedPtr& pInternalUpdaterVars = mInternalUpdater->getVars();\n   53:         mpLightCollection->setShaderData(pInternalUpdaterVars[\"CB\"][\"gLights\"]);\n   54          pInternalUpdaterVars[\"CB\"][\"gLightBVH\"][\"nodes\"] = mpBVHNodesBuffer;\n   55          pInternalUpdaterVars[\"gNodeOffsets\"] = mpNodeOffsetsBuffer;\n   ..\n  178      }\n  179  \n  180:     LightBVH::LightBVH(std::shared_ptr<Device> device, const LightCollection::SharedConstPtr& pLightCollection) : mpDevice(device), mpLightCollection(pLightCollection) {\n  181          verifyStaticParams();\n  182          mAlignedAllocator.setMinimumAlignment(16);\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVH.h:\n   30  \n   31  #include \"LightBVHStaticParams.slang\"\n   32: #include \"LightCollection.h\"\n   33  \n   34  #include \"Utils/AlignedAllocator.h\"\n   ..\n  127  \n  128          /** Creates an empty LightBVH object. Use a LightBVHBuilder to build the BVH.\n  129:             \\param[in] pLightCollection The light collection around which the BVH will be built.\n  130          */\n  131:         static SharedPtr create(std::shared_ptr<Device> device, const LightCollection::SharedConstPtr& pLightCollection);\n  132  \n  133          /** Refit all the BVH nodes to the underlying geometry, without changing the hierarchy.\n  ...\n  195  \n  196       protected:\n  197:         LightBVH(std::shared_ptr<Device> device, const LightCollection::SharedConstPtr& pLightCollection);\n  198  \n  199          void computeStats();\n  ...\n  226  \n  227          // Internal state\n  228:         const LightCollection::SharedConstPtr mpLightCollection;\n  229  \n  230          ComputePass::SharedPtr                mLeafUpdater;             ///< Compute pass for refitting the leaf nodes.\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVHBuilder.cpp:\n  221  \n  222          // Get global list of emissive triangles.\n  223:         assert(bvh.mpLightCollection);\n  224:         const auto& triangles = bvh.mpLightCollection->getMeshLightTriangles();\n  225          if (triangles.empty()) return;\n  226  \n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVHRefit.cs.slang:\n   29  \n   30  import Experimental.Scene.Lights.LightBVH;\n   31: import Experimental.Scene.Lights.LightCollection;\n   32  \n   33  cbuffer CB\n   34  {\n   35:     LightCollection     gLights;              ///< The light sources.\n   36      RWLightBVH          gLightBVH;            ///< The BVH around the light sources.\n   37      uint                gFirstNodeIndex;      ///< The index of the first node to be processed.\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVHSampler.cpp:\n   58  \n   59          // Check if light collection has changed.\n   60:         if (is_set(mpScene->getUpdates(), Scene::UpdateFlags::LightCollectionChanged))\n   61          {\n   62              if (mOptions.buildOptions.allowRefitting && !mNeedsRebuild) needsRefit = true;\n   ..\n  172              throw std::runtime_error(\"Failed to create BVH builder\");\n  173          }\n  174:         mpBVH = LightBVH::create(pRenderContext->device(), pScene->getLightCollection(pRenderContext));\n  175          if (!mpBVH) {\n  176              throw std::runtime_error(\"Failed to create BVH\");\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVHSampler.h:\n   31  #include \"LightBVH.h\"\n   32  #include \"LightBVHBuilder.h\"\n   33: #include \"LightCollection.h\"\n   34  #include \"LightBVHSamplerSharedDefinitions.slang\"\n   35  \n   ..\n   44      /** Emissive light sampler using a light BVH.\n   45  \n   46:         This class wraps a LightCollection object, which holds the set of lights to sample.\n   47          Internally, the class build a BVH over the light sources.\n   48      */\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVHSampler.slang:\n   34  import Experimental.Scene.Lights.LightBVH;\n   35  import Experimental.Scene.Lights.LightBVHSamplerSharedDefinitions;\n   36: import Experimental.Scene.Lights.LightCollection;\n   37  import Experimental.Scene.Lights.EmissiveLightSamplerHelpers;\n   38  import Experimental.Scene.Lights.EmissiveLightSamplerInterface;\n   ..\n   55      EmissiveLightSamplerInterface.slang for usage information).\n   56  \n   57:     The struct wraps a LightCollection that stores the pre-processed lights,\n   58      and a LightBVH that stores the data structure used for sampling.\n   59      The program should instantiate the struct below. See EmissiveLightSampler.slang.\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightCollection.cpp:\n   27   **************************************************************************/\n   28  #include \"stdafx.h\"\n   29: #include \"LightCollection.h\"\n   30: #include \"LightCollectionShared.slang\"\n   31  #include \"Scene/Scene.h\"\n   32  #include <sstream>\n   ..\n   46      }\n   47  \n   48:     LightCollection::SharedPtr LightCollection::create(RenderContext* pRenderContext, const std::shared_ptr<Scene>& pScene) {\n   49:         SharedPtr ptr = SharedPtr(new LightCollection());\n   50          return ptr->init(pRenderContext, pScene) ? ptr : nullptr;\n   51      }\n   52  \n   53:     bool LightCollection::update(RenderContext* pRenderContext, UpdateStatus* pUpdateStatus) {\n   54:         PROFILE(\"LightCollection::update()\");\n   55  \n   56          if (pUpdateStatus) {\n   ..\n   94      }\n   95  \n   96:     void LightCollection::renderUI(Gui::Widgets& widget) {\n   97          // Prints stats about the number of lights etc.\n   98          const MeshLightStats& stats = getStats();\n   ..\n  113      }\n  114  \n  115:     bool LightCollection::init(RenderContext* pRenderContext, const std::shared_ptr<Scene>& pScene) {\n  116          assert(pScene);\n  117          mpScene = pScene;\n  ...\n  138      }\n  139  \n  140:     bool LightCollection::initIntegrator(RenderContext* pRenderContext) {\n  141          // The current algorithm rasterizes emissive triangles in texture space,\n  142          // and uses atomic operations to sum up the contribution from all covered texels.\n  ...\n  146          std::string s;\n  147          if (findFileInShaderDirectories(\"NVAPI/nvHLSLExtns.h\", s) == false) {\n  148:             logError(\"LightCollection relies on NVAPI, which appears to be missing. Please make sure you have NVAPI installed (instructions are in the readme file)\");\n  149              return false;\n  150          }\n  ...\n  187      }\n  188  \n  189:     bool LightCollection::setupMeshLights() {\n  190          mMeshLights.clear();\n  191          mpSamplerState = nullptr;\n  ...\n  228      }\n  229  \n  230:     void LightCollection::build(RenderContext* pRenderContext) {\n  231          if (mTriangleCount == 0) {\n  232              // If there are no emissive triangle, clear everything and mark the CPU data/stats as valid.\n  ...\n  254      }\n  255  \n  256:     void LightCollection::prepareTriangleData(RenderContext* pRenderContext) {\n  257          // Create GPU buffers.\n  258          assert(mTriangleCount > 0);\n  ...\n  261  \n  262          mpMeshLightsVertexPos = Buffer::create(pRenderContext->device(), bufSize, Resource::BindFlags::ShaderResource | Resource::BindFlags::UnorderedAccess, Buffer::CpuAccess::None);\n  263:         mpMeshLightsVertexPos->setName(\"LightCollection_MeshLightsVertexPos\");\n  264          mpMeshLightsTexCoords = Buffer::create(pRenderContext->device(), uvBufSize, Resource::BindFlags::ShaderResource | Resource::BindFlags::UnorderedAccess, Buffer::CpuAccess::None);\n  265:         mpMeshLightsTexCoords->setName(\"LightCollection_MeshLightsTexCoords\");\n  266          mpTriangleData = Buffer::createStructured(pRenderContext->device(), mpTriangleListBuilder->getProgram().get(), \"gTriangleData\", mTriangleCount);\n  267:         mpTriangleData->setName(\"LightCollection_TriangleData\");\n  268  \n  269          // Compute triangle data (vertices, uv-coordinates, materialID) for all mesh lights.\n  ...\n  271      }\n  272  \n  273:     void LightCollection::prepareMeshData(RenderContext* pRenderContext) {\n  274          assert(mMeshLights.size() > 0);\n  275  \n  ...\n  299          // Create the GPU buffer.\n  300          mpPerMeshInstanceOffset = Buffer::createStructured(pRenderContext->device(), sizeof(uint32_t), instanceCount, Resource::BindFlags::ShaderResource);\n  301:         mpPerMeshInstanceOffset->setName(\"LightCollection_PerMeshInstanceOffset\");\n  302  \n  303          const size_t sizeInBytes = triangleOffsets.size() * sizeof(triangleOffsets[0]);\n  ...\n  306      }\n  307  \n  308:     void LightCollection::integrateEmissive(RenderContext* pRenderContext) {\n  309          assert(mTriangleCount > 0);\n  310          assert(mMeshLights.size() > 0);\n  ...\n  317              if (!mIntegrator.pResultBuffer || mIntegrator.pResultBuffer->getSize() < bufSize) {\n  318                  mIntegrator.pResultBuffer = Buffer::create(pRenderContext->device(), bufSize, Resource::BindFlags::ShaderResource | Resource::BindFlags::UnorderedAccess, Buffer::CpuAccess::None);\n  319:                 mIntegrator.pResultBuffer->setName(\"LightCollection_IntegratorResults\");\n  320                  assert(mIntegrator.pResultBuffer);\n  321              }\n  ...\n  331  \n  332              // Bind light collection.\n  333:             setShaderData(mIntegrator.pVars[\"gLightCollection\"]);\n  334  \n  335              // Bind our resources.\n  ...\n  359      }\n  360  \n  361:     void LightCollection::computeStats() const {\n  362          if (mStatsValid) return;\n  363  \n  ...\n  402      }\n  403  \n  404:     void LightCollection::buildTriangleList(RenderContext* pRenderContext) {\n  405          assert(mMeshLights.size() > 0);\n  406  \n  ...\n  429      }\n  430  \n  431:     void LightCollection::updateTrianglePositions(RenderContext* pRenderContext, const std::vector<uint32_t>& updatedLights) {\n  432          // This pass pre-transforms all emissive triangles into world space and updates their area and face normals.\n  433          // It is executed if any geometry in the scene has moved, which is wasteful since it will update also things\n  ...\n  454      }\n  455  \n  456:     bool LightCollection::setShaderData(const ShaderVar& var) const {\n  457          assert(var.isValid());\n  458  \n  ...\n  486      }\n  487  \n  488:     void LightCollection::copyDataToStagingBuffer(RenderContext* pRenderContext) const {\n  489          if (mStagingBufferValid) return;\n  490  \n  ...\n  493          if (!mpStagingBuffer || mpStagingBuffer->getSize() < stagingSize) {\n  494              mpStagingBuffer = Buffer::create(pRenderContext->device(), stagingSize, Resource::BindFlags::None, Buffer::CpuAccess::Read);\n  495:             mpStagingBuffer->setName(\"LightCollection_StagingBuffer\");\n  496              mCPUInvalidData = CPUOutOfDateFlags::All;\n  497          }\n  ...\n  520      }\n  521  \n  522:     void LightCollection::syncCPUData() const {\n  523          if (mCPUInvalidData == CPUOutOfDateFlags::None) return;\n  524  \n  ...\n  526          // This should normally have done by calling prepareSyncCPUData().\n  527          if (!mStagingBufferValid) {\n  528:             logWarning(\"LightCollection::syncCPUData() performance warning - Call LightCollection::prepareSyncCPUData() ahead of time if possible\");\n  529              prepareSyncCPUData(gpDevice->getRenderContext());\n  530          }\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightCollection.h:\n   41  \n   42      This class has utility functions for updating and pre-processing the mesh lights.\n   43:     The LightCollection can be used standalone, but more commonly it will be wrapped\n   44      by an emissive light sampler.\n   45  */\n   46: class dlldecl LightCollection : public std::enable_shared_from_this<LightCollection> {\n   47   public:\n   48:     using SharedPtr = std::shared_ptr<LightCollection>;\n   49:     using ConstSharedPtrRef = const std::shared_ptr<LightCollection>&;\n   50:     using SharedConstPtr = std::shared_ptr<const LightCollection>;\n   51  \n   52      enum class UpdateFlags : uint32_t {\n   ..\n  102  \n  103  \n  104:     ~LightCollection() = default;\n  105  \n  106      /** Creates a light collection for the given scene.\n  ...\n  170  \n  171   protected:\n  172:     LightCollection() = default;\n  173  \n  174      bool init(RenderContext* pRenderContext, const std::shared_ptr<Scene>& pScene);\n  ...\n  227  };\n  228  \n  229: enum_class_operators(LightCollection::CPUOutOfDateFlags);\n  230: enum_class_operators(LightCollection::UpdateFlags);\n  231  \n  232  }  // namespace Falcor\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightCollection.slang:\n   29  \n   30  import Scene.ShadingData;\n   31: __exported import Experimental.Scene.Lights.LightCollectionShared;\n   32  __exported import Experimental.Scene.Lights.MeshLightData;\n   33  \n   ..\n   37      quantities such as emitted flux are pre-computed.\n   38  \n   39:     The user code instantiates LightCollection in e.g. a parameter block and\n   40      calls member functions on the CPU-side class to update/bind it to their program.\n   41  */\n   42: struct LightCollection\n   43  {\n   44      uint                                triangleCount;          ///< Total number of triangles in all mesh lights.\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/MeshLightData.slang:\n   42  {\n   43      uint        meshInstanceID      = kInvalidIndex;    ///< Mesh instance ID in the scene (= getGlobalHitID()).\n   44:     uint        triangleOffset      = kInvalidIndex;    ///< Offset into LightCollection's global list of emissive triangles.\n   45      uint        triangleCount       = 0;                ///< Number of triangles in mesh light.\n   46      uint        materialID          = kInvalidIndex;    ///< Material ID (index into scene.materials array).\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/UpdateTriangleVertices.cs.slang:\n   29  \n   30  import Scene.Scene;\n   31: import Experimental.Scene.Lights.LightCollection;\n   32  \n   33  cbuffer CB\n\n/home/max/dev/Falcor/src/Falcor/Falcor.vcxproj:\n  130      <ClInclude Include=\"Experimental\\Scene\\Lights\\LightBVHSampler.h\" />\n  131      <ShaderSource Include=\"Experimental\\Scene\\Lights\\EmissiveLightSamplerType.slangh\" />\n  132:     <ClInclude Include=\"Experimental\\Scene\\Lights\\LightCollection.h\" />\n  133      <ShaderSource Include=\"Experimental\\Scene\\Lights\\FinalizeIntegration.cs.slang\" />\n  134      <ShaderSource Include=\"Experimental\\Scene\\Lights\\LightBVHSamplerSharedDefinitions.slang\" />\n  135      <ShaderSource Include=\"Experimental\\Scene\\Lights\\LightBVHStaticParams.slang\" />\n  136:     <ShaderSource Include=\"Experimental\\Scene\\Lights\\LightCollectionShared.slang\" />\n  137      <ClInclude Include=\"Raytracing\\RtProgramVars.h\" />\n  138      <ClInclude Include=\"Raytracing\\RtProgramVarsHelper.h\" />\n  ...\n  586      <ClCompile Include=\"Experimental\\Scene\\Lights\\LightBVHBuilder.cpp\" />\n  587      <ClCompile Include=\"Experimental\\Scene\\Lights\\LightBVHSampler.cpp\" />\n  588:     <ClCompile Include=\"Experimental\\Scene\\Lights\\LightCollection.cpp\" />\n  589      <ClCompile Include=\"Raytracing\\RtProgramVars.cpp\" />\n  590      <ClCompile Include=\"Raytracing\\RtProgramVarsHelper.cpp\" />\n  ...\n  672      <ShaderSource Include=\"Experimental\\Scene\\Lights\\LightBVHRefit.cs.slang\" />\n  673      <ShaderSource Include=\"Experimental\\Scene\\Lights\\LightBVHSampler.slang\" />\n  674:     <ShaderSource Include=\"Experimental\\Scene\\Lights\\LightCollection.slang\" />\n  675      <ShaderSource Include=\"Experimental\\Scene\\Lights\\LightHelpers.slang\" />\n  676      <ShaderSource Include=\"Experimental\\Scene\\Material\\MaterialHelpers.slang\" />\n\n/home/max/dev/Falcor/src/Falcor/Falcor.vcxproj.filters:\n  473        <Filter>Experimental\\Scene\\Lights</Filter>\n  474      </ClInclude>\n  475:     <ClInclude Include=\"Experimental\\Scene\\Lights\\LightCollection.h\">\n  476        <Filter>Experimental\\Scene\\Lights</Filter>\n  477      </ClInclude>\n  ...\n 1150        <Filter>Experimental\\Scene\\Lights</Filter>\n 1151      </ClCompile>\n 1152:     <ClCompile Include=\"Experimental\\Scene\\Lights\\LightCollection.cpp\">\n 1153        <Filter>Experimental\\Scene\\Lights</Filter>\n 1154      </ClCompile>\n ....\n 1230        <Filter>Experimental\\Scene\\Lights</Filter>\n 1231      </ShaderSource>\n 1232:     <ShaderSource Include=\"Experimental\\Scene\\Lights\\LightCollection.slang\">\n 1233        <Filter>Experimental\\Scene\\Lights</Filter>\n 1234      </ShaderSource>\n ....\n 1398        <Filter>Experimental\\Scene\\Lights</Filter>\n 1399      </ShaderSource>\n 1400:     <ShaderSource Include=\"Experimental\\Scene\\Lights\\LightCollectionShared.slang\">\n 1401        <Filter>Experimental\\Scene\\Lights</Filter>\n 1402      </ShaderSource>\n\n/home/max/dev/Falcor/src/Falcor/RenderPasses/Shared/PathTracer/PathTracer.cpp:\n  452                  lightingChanged = mpEmissiveSampler->update(pRenderContext);\n  453  \n  454:                 const auto& lightCollection = mpScene->getLightCollection(pRenderContext);\n  455  \n  456                  // Update shared parameters.\n\n/home/max/dev/Falcor/src/Falcor/Scene/Scene.cpp:\n  137  }\n  138  \n  139: LightCollection::ConstSharedPtrRef Scene::getLightCollection(RenderContext* pContext) {\n  140:     if (!mpLightCollection) {\n  141:         mpLightCollection = LightCollection::create(pContext, shared_from_this());\n  142:         mpLightCollection->setShaderData(mpSceneBlock[\"lightCollection\"]);\n  143      }\n  144:     return mpLightCollection;\n  145  }\n  146  \n  ...\n  443  \n  444      // Update light collection\n  445:     if (mpLightCollection && mpLightCollection->update(pContext)) mUpdates |= UpdateFlags::LightCollectionChanged;\n  446  \n  447      return mUpdates;\n  ...\n  521          statsGroup.text(oss.str());\n  522  \n  523:         if (mpLightCollection) {\n  524              auto lightCollectionGroup = Gui::Group(widget, \"Mesh lights\", true);\n  525:             if (lightCollectionGroup.open()) mpLightCollection->renderUI(lightCollectionGroup);\n  526              lightCollectionGroup.release();\n  527          } else {\n\n/home/max/dev/Falcor/src/Falcor/Scene/Scene.h:\n   38  #include \"Animation/AnimationController.h\"\n   39  #include \"Camera/CameraController.h\"\n   40: #include \"Experimental/Scene/Lights/LightCollection.h\"\n   41  #include \"SceneTypes.slang\"\n   42  \n   ..\n  105              LightPropertiesChanged      = 0x20, ///< Other light changes not included in LightIntensityChanged and LightsMoved\n  106              SceneGraphChanged           = 0x40, ///< Any transform in the scene graph changed.\n  107:             LightCollectionChanged      = 0x80, ///< Light collection changed (mesh lights)\n  108              MaterialsChanged            = 0x100,///< Materials changed\n  109  \n  ...\n  241              \\return Returns the light collection.\n  242          */\n  243:         LightCollection::ConstSharedPtrRef getLightCollection(RenderContext* pContext);\n  244  \n  245          /** Get the light probe or nullptr if it doesn't exist.\n  ...\n  470          std::vector<Material::SharedPtr> mMaterials;        ///< Bound to parameter block\n  471          std::vector<AnimatedObject<Light>> mLights;         ///< Bound to parameter block\n  472:         LightCollection::SharedPtr mpLightCollection;       ///< Bound to parameter block\n  473          LightProbe::SharedPtr mpLightProbe;                 ///< Bound to parameter block\n  474          Texture::SharedPtr mpEnvMap;                        ///< Not bound to anything, not rendered automatically. Can be used to render a skybox\n\n/home/max/dev/Falcor/src/Falcor/Scene/Scene.slang:\n   37  import TextureSampler;\n   38  import Utils.Attributes;\n   39: import Experimental.Scene.Lights.LightCollection;\n   40  import Experimental.Scene.Material.TexLODHelpers;\n   41  \n   ..\n   68      // Lights and camera\n   69      StructuredBuffer<LightData> lights;\n   70:     LightCollection lightCollection;\n   71      LightProbeData lightProbe;\n   72      Texture2D envMap;\n\n119 matches across 25 files\n\n\nSearching 1282 files for \"Scene* pScene\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Raytracing/ShaderTable.h:\n   60          /** Create a new object\n   61          */\n   62:         static SharedPtr create();//RtProgram* pProgram, const Scene* pScene);\n   63  \n   64          /** Update the shader table.\n\n/home/max/dev/Falcor/src/Falcor/Scene/Animation/AnimationController.cpp:\n   38  }  // namespace\n   39  \n   40:     AnimationController::AnimationController(Scene* pScene, const StaticVertexVector& staticVertexData, const DynamicVertexVector& dynamicVertexData) :\n   41          mpScene(pScene), mLocalMatrices(pScene->mSceneGraph.size()), mInvTransposeGlobalMatrices(pScene->mSceneGraph.size()), mMatricesChanged(pScene->mSceneGraph.size())\n   42      {\n   ..\n   50      }\n   51  \n   52:     AnimationController::UniquePtr AnimationController::create(Scene* pScene, const StaticVertexVector& staticVertexData, const DynamicVertexVector& dynamicVertexData) {\n   53          return UniquePtr(new AnimationController(pScene, staticVertexData, dynamicVertexData));\n   54      }\n\n/home/max/dev/Falcor/src/Falcor/Scene/Animation/AnimationController.h:\n   63          /** Create a new object\n   64          */\n   65:         static UniquePtr create(Scene* pScene, const StaticVertexVector& staticVertexData, const DynamicVertexVector& dynamicVertexData);\n   66          \n   67          /** Add an animation for a mesh\n   ..\n  116      private:\n  117          friend class SceneBuilder;\n  118:         AnimationController(Scene* pScene, const StaticVertexVector& staticVertexData, const DynamicVertexVector& dynamicVertexData);\n  119  \n  120          void allocatePrevWorldMatrixBuffer();\n\n/home/max/dev/Falcor/src/Falcor/Scene/HitInfo.h:\n   40      /** Returns defines needed packing/unpacking a HitInfo struct.\n   41      */\n   42:     static Shader::DefineList getDefines(const Scene* pScene) {\n   43          // Setup bit allocations for encoding the meshInstanceID and primitive indices.\n   44  \n\n/home/max/dev/Falcor/src/Falcor/Scene/Importers/AssimpImporter.cpp:\n  184          public:\n  185              ImporterData(const aiScene* pAiScene, SceneBuilder& sceneBuilder, const SceneBuilder::InstanceMatrices& modelInstances_) : pScene(pAiScene), modelInstances(modelInstances_), builder(sceneBuilder) {}\n  186:             const aiScene* pScene;\n  187  \n  188              SceneBuilder& builder;\n  ...\n  531          bool createMeshes(ImporterData& data)\n  532          {\n  533:             const aiScene* pScene = data.pScene;\n  534              for (uint32_t i = 0; i < pScene->mNumMeshes; i++)\n  535              {\n  ...\n  661          void createBoneList(ImporterData& data)\n  662          {\n  663:             const aiScene* pScene = data.pScene;\n  664              auto& boneMatrices = data.localToBindPoseMatrices;\n  665  \n  ...\n  927          }\n  928  \n  929:         BoneMeshMap createBoneMap(const aiScene* pScene)\n  930          {\n  931              BoneMeshMap boneMap;\n  ...\n  952          }\n  953  \n  954:         MeshInstanceList countMeshInstances(const aiScene* pScene)\n  955          {\n  956              MeshInstanceList meshInstances(pScene->mNumMeshes);\n  ...\n  973          }\n  974  \n  975:         bool validateBones(const aiScene* pScene)\n  976          {\n  977              // Make sure that each bone is only affecting a single mesh.\n  ...\n 1002          }\n 1003  \n 1004:         void verifyScene(const aiScene* pScene)\n 1005          {\n 1006              bool b = true;\n ....\n 1039  \n 1040          Assimp::Importer importer;\n 1041:         const aiScene* pScene = importer.ReadFile(fullpath, assimpFlags);\n 1042  \n 1043          if (pScene == nullptr)\n\n/home/max/dev/Falcor/src/Falcor/Scene/SceneBuilder.cpp:\n  352      }\n  353  \n  354:     void SceneBuilder::createGlobalMatricesBuffer(Scene* pScene)\n  355      {\n  356          pScene->mSceneGraph.resize(mSceneGraph.size());\n  ...\n  363      }\n  364  \n  365:     uint32_t SceneBuilder::createMeshData(Scene* pScene)\n  366      {\n  367          auto& meshData = pScene->mMeshDesc;\n  ...\n  444      }\n  445  \n  446:     void SceneBuilder::calculateMeshBoundingBoxes(Scene* pScene)\n  447      {\n  448          // Calculate mesh bounding boxes\n  ...\n  474      }\n  475  \n  476:     void SceneBuilder::createAnimationController(Scene* pScene)\n  477      {\n  478          pScene->mpAnimationController = AnimationController::create(pScene, mBuffersData.staticData, mBuffersData.dynamicData);\n\n/home/max/dev/Falcor/src/Falcor/Scene/SceneBuilder.h:\n  221      Vao::SharedPtr createVao(uint16_t drawCount);\n  222  \n  223:     uint32_t createMeshData(Scene* pScene);\n  224:     void createGlobalMatricesBuffer(Scene* pScene);\n  225:     void calculateMeshBoundingBoxes(Scene* pScene);\n  226:     void createAnimationController(Scene* pScene);\n  227      std::string mFilename;\n  228  };\n\n22 matches across 7 files\n\n\nSearching 1282 files for \"UnitTestContext\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Testing/UnitTest.cpp:\n   94          auto startTime = std::chrono::steady_clock::now();\n   95  \n   96:         CPUUnitTestContext cpuCtx;\n   97:         GPUUnitTestContext gpuCtx(pRenderContext);\n   98  \n   99          std::string extraMessage;\n  ...\n  180      ///////////////////////////////////////////////////////////////////////////\n  181  \n  182:     void GPUUnitTestContext::createProgram( const std::string& path,\n  183                                              const std::string& entry,\n  184                                              const Program::DefineList& programDefines,\n  ...\n  196      }\n  197  \n  198:     void GPUUnitTestContext::createVars() {\n  199          // Create shader variables.\n  200          ProgramReflection::SharedConstPtr pReflection = mpProgram->getReflector();\n  ...\n  208      }\n  209  \n  210:     void GPUUnitTestContext::allocateStructuredBuffer(const std::string& name, uint32_t nElements, const void* pInitData, size_t initDataSize) {\n  211          assert(mpVars);\n  212          mStructuredBuffers[name].pBuffer = Buffer::createStructured(mpProgram.get(), name, nElements);\n  ...\n  220      }\n  221  \n  222:     void GPUUnitTestContext::runProgram(const uint3& dimensions) {\n  223          assert(mpVars);\n  224          for (const auto& buffer : mStructuredBuffers) {\n  ...\n  232      }\n  233  \n  234:     void GPUUnitTestContext::unmapBuffer(const char* bufferName) {\n  235          assert(mStructuredBuffers.find(bufferName) != mStructuredBuffers.end());\n  236          \n  ...\n  243      }\n  244  \n  245:     const void* GPUUnitTestContext::mapRawRead(const char* bufferName) {\n  246          assert(mStructuredBuffers.find(bufferName) != mStructuredBuffers.end());\n  247  \n\n/home/max/dev/Falcor/src/Falcor/Testing/UnitTest.h:\n   54      static constexpr int kMaxTestFailures = 25;\n   55  \n   56:     class CPUUnitTestContext;\n   57:     class GPUUnitTestContext;\n   58  \n   59      struct TooManyFailedTestsException : public std::exception { };\n   ..\n   69      };\n   70  \n   71:     using CPUTestFunc = std::function<void(CPUUnitTestContext& ctx)>;\n   72:     using GPUTestFunc = std::function<void(GPUUnitTestContext& ctx)>;\n   73  \n   74      dlldecl void registerCPUTest(const std::string& filename, const std::string& name, const std::string& skipMessage, CPUTestFunc func);\n   ..\n   76      dlldecl int32_t runTests(std::ostream& stream, RenderContext* pRenderContext, const std::string& testFilterRegexp);\n   77  \n   78:     class dlldecl UnitTestContext {\n   79       public:\n   80          /** reportFailure is called with an error message to report a failing\n   ..\n   95      };\n   96  \n   97:     class dlldecl CPUUnitTestContext : public UnitTestContext { };\n   98  \n   99:     class dlldecl GPUUnitTestContext : public UnitTestContext {\n  100       public:\n  101:         GPUUnitTestContext(RenderContext* pContext) : mpContext(pContext) { }\n  102  \n  103          /** createProgram creates a compute program from the source code at the\n  ...\n  207          StreamSink does the former, and if it has passed, it does the latter.)\n  208          In the event of a test failure, passes along the failure message to the\n  209:         provided GPUUnitTestContext's |reportFailure| method.\n  210      */\n  211      class StreamSink {\n  ...\n  218  \n  219          /** Construct a StreamSink for a test context.\n  220:             If a non-nullptr UnitTestContext is provided, the values printed\n  221              will be accumulated and passed to the context's reportFailure()\n  222              method when the StreamSink destructor runs.\n  223          */\n  224:         StreamSink(UnitTestContext* ctx) : mpCtx(ctx) {}\n  225  \n  226          ~StreamSink() {\n  ...\n  268      private:\n  269          std::stringstream mSs;\n  270:         UnitTestContext* mpCtx = nullptr;\n  271      };\n  272  \n  273      template <typename T, typename U>\n  274      inline StreamSink expectEqInternal(T x, const char* xString, U y, const char* yString,\n  275:                                        UnitTestContext& ctx, const char* file, int line) {\n  276          if (x == y) return StreamSink(nullptr);\n  277  \n  ...\n  285      template <typename T, typename U>\n  286      inline StreamSink expectNeInternal(T x, const char* xString, U y, const char* yString,\n  287:                                        UnitTestContext& ctx, const char* file, int line) {\n  288          if (x != y) return StreamSink(nullptr);\n  289  \n  ...\n  297      template <typename T, typename U>\n  298      inline StreamSink expectGeInternal(T x, const char* xString, U y, const char* yString,\n  299:                                        UnitTestContext& ctx, const char* file, int line) {\n  300          if (x >= y) return StreamSink(nullptr);\n  301  \n  ...\n  309      template <typename T, typename U>\n  310      inline StreamSink expectGtInternal(T x, const char* xString, U y, const char* yString,\n  311:                                        UnitTestContext& ctx, const char* file, int line) {\n  312          if (x > y) return StreamSink(nullptr);\n  313  \n  ...\n  321      template <typename T, typename U>\n  322      inline StreamSink expectLeInternal(T x, const char* xString, U y, const char* yString,\n  323:                                        UnitTestContext& ctx, const char* file, int line) {\n  324          if (x <= y) return StreamSink(nullptr);\n  325  \n  ...\n  333      template <typename T, typename U>\n  334      inline StreamSink expectLtInternal(T x, const char* xString, U y, const char* yString,\n  335:                                        UnitTestContext& ctx, const char* file, int line) {\n  336          if (x < y) return StreamSink(nullptr);\n  337  \n  ...\n  344  \n  345      template <typename T>\n  346:     inline StreamSink expectInternal(T x, const char* xString, UnitTestContext& ctx,\n  347                                       const char* file, int line) {\n  348          if (x) return StreamSink(nullptr);\n  ...\n  368  */\n  369  #define CPU_TEST(Name, ...)                                                     \\\n  370:     static void CPUUnitTest##Name(CPUUnitTestContext& ctx);                     \\\n  371      struct CPUUnitTestRegisterer##Name {                                        \\\n  372          CPUUnitTestRegisterer##Name()                                           \\\n  ...\n  376          }                                                                       \\\n  377      } RegisterCPUTest##Name;                                                    \\\n  378:     static void CPUUnitTest##Name(CPUUnitTestContext& ctx) /* over to the user for the braces */\n  379  \n  380  /** Macro to define a GPU unit test. The optional skip message will\n  ...\n  383  */\n  384  #define GPU_TEST(Name, ...)                                                     \\\n  385:     static void GPUUnitTest##Name(GPUUnitTestContext& ctx);                     \\\n  386      struct GPUUnitTestRegisterer##Name {                                        \\\n  387          GPUUnitTestRegisterer##Name()                                           \\\n  ...\n  391          }                                                                       \\\n  392      } RegisterGPUTest##Name;                                                    \\\n  393:     static void GPUUnitTest##Name(GPUUnitTestContext& ctx) /* over to the user for the braces */\n  394  \n  395  /** Macro definitions for the GPU unit testing framework. Note that they\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Core/BufferAccessTests.cpp:\n   47      The test binds the buffer to a compute program which reads back the data.\n   48  */\n   49: void testBufferReadback(GPUUnitTestContext& ctx, Buffer::CpuAccess cpuAccess) {\n   50      auto pBuf = createTestBuffer(cpuAccess);\n   51  \n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Core/BufferTests.cpp:\n   42  \n   43          template <Type type>\n   44:         void testBuffer(GPUUnitTestContext& ctx, uint32_t numElems, uint32_t index = 0, uint32_t count = 0)\n   45          {\n   46              numElems = div_round_up(numElems, 256u) * 256u; // Make sure we run full thread groups.\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Core/RootBufferParamBlockTests.cpp:\n   46          auto r = [&]() -> uint32_t { return dist(rng); };\n   47  \n   48:         void testRootBuffer(GPUUnitTestContext& ctx, const std::string& shaderModel, bool useUav)\n   49          {\n   50              Program::DefineList defines = { {\"USE_UAV\", useUav ? \"1\" : \"0\"} };\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Core/RootBufferStructTests.cpp:\n   40          auto r = [&]() -> uint32_t { return dist(rng); };\n   41  \n   42:         void testRootBufferInStruct(GPUUnitTestContext& ctx, const std::string& shaderModel, bool useUav)\n   43          {\n   44              Program::DefineList defines = { {\"USE_UAV\", useUav ? \"1\" : \"0\"} };\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Core/RootBufferTests.cpp:\n   49          };\n   50  \n   51:         void testRootBuffer(GPUUnitTestContext& ctx, const std::string& shaderModel, bool useUav)\n   52          {\n   53              Program::DefineList defines = { {\"USE_UAV\", useUav ? \"1\" : \"0\"} };\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Sampling/SampleGeneratorTests.cpp:\n   72          }\n   73  \n   74:         void testSampleGenerator(GPUUnitTestContext& ctx, uint32_t type, const double corrThreshold, bool testInstances)\n   75          {\n   76              // Create sample generator.\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Slang/Int64Tests.cpp:\n   50          std::mt19937 r;\n   51  \n   52:         void test(GPUUnitTestContext& ctx, const std::string& shaderModel, bool useUav)\n   53          {\n   54              Program::DefineList defines = { {\"USE_UAV\", useUav ? \"1\" : \"0\"} };\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Slang/ShaderModel.cpp:\n   34          const uint32_t kNumElems = 256;\n   35  \n   36:         void test(GPUUnitTestContext& ctx, const std::string& shaderModel)\n   37          {\n   38              ctx.createProgram(\"Tests/Slang/ShaderModel.cs.slang\", \"main\", Program::DefineList(), Shader::CompilerFlags::None, shaderModel);\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Slang/SlangTests.cpp:\n   45      namespace\n   46      {\n   47:         void testEnum(GPUUnitTestContext& ctx, const std::string& shaderModel)\n   48          {\n   49              ctx.createProgram(\"Tests/Slang/SlangTests.cs.slang\", \"testEnum\", Program::DefineList(), Shader::CompilerFlags::None, shaderModel);\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Slang/TraceRayFlags.cpp:\n   51  }\n   52  #endif\n   53: void testRayFlags(GPUUnitTestContext& ctx, uint32_t expected, const Program::DefineList& defines, const std::string& shaderModel) {\n   54      ctx.createProgram(\"Tests/Slang/TraceRayFlags.cs.slang\", \"testRayFlags\", defines, Shader::CompilerFlags::None, shaderModel);\n   55      ctx.allocateStructuredBuffer(\"result\", 1);\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Utils/BitonicSortTests.cpp:\n   45          }\n   46  \n   47:         void testGpuSort(GPUUnitTestContext& ctx, BitonicSort* pSort, const uint32_t n, const uint32_t chunkSize)\n   48          {\n   49              // Create a buffer of random data to use as test data.\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Utils/HalfUtilsTests.cpp:\n  175          }\n  176  \n  177:         std::vector<float> generateFP16TestData(UnitTestContext& ctx)\n  178          {\n  179              std::vector<float> data;\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Utils/MathHelpersTests.cpp:\n   43          };\n   44  \n   45:         void runBBoxTestComputeShader(GPUUnitTestContext& ctx, const BBoxTestCase* testCases, int nTests, const char* entrypoint)\n   46          {\n   47              Buffer::SharedPtr pOriginBuffer = Buffer::createTyped<float3>(nTests);\n   ..\n   67          }\n   68  \n   69:         void testKnownBBoxes(GPUUnitTestContext& ctx, const char* entrypoint)\n   70          {\n   71              // Generate test data...\n   ..\n  112          }\n  113  \n  114:         void testRandomBBoxes(GPUUnitTestContext& ctx, const char* entrypoint)\n  115          {\n  116              // Generate test data.\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Utils/ParallelReductionTests.cpp:\n   87  \n   88          template<typename DataType, typename RefType>\n   89:         void testReduction(GPUUnitTestContext& ctx, const ComputeParallelReduction::SharedPtr& pReduction, ResourceFormat format, uint32_t width, uint32_t height)\n   90          {\n   91              // Create random test data.\n   ..\n  208          }\n  209  \n  210:         void testReduction(GPUUnitTestContext& ctx, const ComputeParallelReduction::SharedPtr& pReduction, ResourceFormat format, uint32_t width, uint32_t height)\n  211          {\n  212              const FormatType type = getFormatType(format);\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Utils/PrefixSumTests.cpp:\n   49          }\n   50  \n   51:         void testPrefixSum(GPUUnitTestContext& ctx, const PrefixSum::SharedPtr& pPrefixSum, uint32_t numElems)\n   52          {\n   53              // Create a buffer of random data to use as test data.\n\n51 matches across 17 files\n\n\nSearching 1282 files for \"FrameRate\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/Renderer.h:\n   35  \n   36  class Clock;\n   37: class FrameRate;\n   38  \n   39  /** Sample configuration\n   ..\n   64      virtual Clock& getGlobalClock() = 0;\n   65  \n   66:     /** Get the global FrameRate object\n   67      */\n   68:     virtual FrameRate& getFrameRate() = 0;\n   69  \n   70      /** Resize the swap-chain buffers*/\n\n/home/max/dev/Falcor/src/Falcor/Core/Sample.cpp:\n   51  Sample::Sample(Device::SharedPtr pDevice, IRenderer::UniquePtr& pRenderer) : mpRenderer(std::move(pRenderer)), mpDevice(pDevice) {\n   52      mClock = nullptr;\n   53:     mFrameRate = nullptr;\n   54  }\n   55  \n   ..\n  124                          mVsyncOn = !mVsyncOn;\n  125                          mpDevice->toggleVSync(mVsyncOn);\n  126:                         mFrameRate.reset();\n  127                          mClock.setTime(0);\n  128                          break;\n  ...\n  288          pBar = nullptr;\n  289  \n  290:         mFrameRate->reset();\n  291          mpWindow->msgLoop();\n  292  \n  ...\n  418              }\n  419  \n  420:             mpGui->render(getRenderContext(), mpDevice->getSwapChainFbo(), (float)mFrameRate.getLastFrameTime());\n  421          }\n  422      }\n  ...\n  429  \n  430          mClock.tick();\n  431:         mFrameRate.newFrame();\n  432          if (mVideoCapture.fixedTimeDelta) { mClock.setTime(mVideoCapture.currentTime); }\n  433  \n\n/home/max/dev/Falcor/src/Falcor/Core/Sample.h:\n   39  #include \"Renderer.h\"\n   40  #include \"Falcor/Utils/ArgList.h\"\n   41: #include \"Falcor/Utils/Timing/FrameRate.h\"\n   42  #include \"Falcor/Utils/UI/Gui.h\"\n   43  #include \"Falcor/Utils/UI/TextRenderer.h\"\n   ..\n   81      Window* getWindow() override { return mpWindow.get(); }\n   82      Clock& getGlobalClock() override { return mClock; }\n   83:     FrameRate& getFrameRate() override { return mFrameRate; }\n   84      void resizeSwapChain(uint32_t width, uint32_t height) override;\n   85      bool isKeyPressed(const KeyboardEvent::Key& key) override;\n   ..\n  132      bool mCaptureScreen = false;\n  133      \n  134:     FrameRate *mFrameRate;\n  135      Clock *mClock;\n  136  \n\n/home/max/dev/Falcor/src/Falcor/Falcor.h:\n  148  #include \"Falcor/Utils/Timing/CpuTimer.h\"\n  149  #include \"Falcor/Utils/Timing/Clock.h\"\n  150: #include \"Falcor/Utils/Timing/FrameRate.h\"\n  151  #include \"Falcor/Utils/Timing/Profiler.h\"\n  152  #include \"Falcor/Utils/UI/Font.h\"\n\n/home/max/dev/Falcor/src/Falcor/Falcor.vcxproj:\n  271      <ClInclude Include=\"Utils\\Timing\\Clock.h\" />\n  272      <ClInclude Include=\"Utils\\Timing\\CpuTimer.h\" />\n  273:     <ClInclude Include=\"Utils\\Timing\\FrameRate.h\" />\n  274      <ClInclude Include=\"Utils\\Timing\\Profiler.h\" />\n  275      <ClInclude Include=\"Utils\\UI\\DebugDrawer.h\" />\n  ...\n  651      <ClCompile Include=\"Utils\\Threading.cpp\" />\n  652      <ClCompile Include=\"Utils\\Timing\\Clock.cpp\" />\n  653:     <ClCompile Include=\"Utils\\Timing\\FrameRate.cpp\" />\n  654      <ClCompile Include=\"Utils\\Timing\\Profiler.cpp\" />\n  655      <ClCompile Include=\"Utils\\UI\\DebugDrawer.cpp\" />\n\n/home/max/dev/Falcor/src/Falcor/Falcor.vcxproj.filters:\n  196        <Filter>Utils\\Timing</Filter>\n  197      </ClInclude>\n  198:     <ClInclude Include=\"Utils\\Timing\\FrameRate.h\">\n  199        <Filter>Utils\\Timing</Filter>\n  200      </ClInclude>\n  ...\n 1054        <Filter>Utils</Filter>\n 1055      </ClCompile>\n 1056:     <ClCompile Include=\"Utils\\Timing\\FrameRate.cpp\">\n 1057        <Filter>Utils\\Timing</Filter>\n 1058      </ClCompile>\n\n/home/max/dev/Falcor/src/Falcor/Utils/Timing/FrameRate.cpp:\n   27   **************************************************************************/\n   28  #include \"stdafx.h\"\n   29: #include \"Falcor/Utils/Timing/FrameRate.h\"\n   30  #include <sstream>\n   31  \n   32  namespace Falcor {\n   33  \n   34: std::string FrameRate::getMsg(bool vsyncOn) const {\n   35      float msPerFrame = (float)getAverageFrameTime();\n   36      std::stringstream strstr;\n   ..\n   43  }  // namespace Falcor\n   44  \n   45: const uint64_t Falcor::FrameRate::sFrameWindow = 60;\n\n/home/max/dev/Falcor/src/Falcor/Utils/Timing/FrameRate.h:\n   39  /** Framerate calculator\n   40  */\n   41: class dlldecl FrameRate {\n   42  public:\n   43:     FrameRate(std::shared_ptr<Device> pDevice) {\n   44          mClock = new Clock(pDevice);\n   45          mFrameTimes.resize(sFrameWindow);\n   ..\n   47      }\n   48  \n   49:     ~FrameRate() {\n   50          delete mClock;\n   51      }\n   ..\n   99  };\n  100  \n  101: inline std::string to_string(const FrameRate& fr, bool vsyncOn = false) { return fr.getMsg(vsyncOn); }\n  102  \n  103  }  // namespace Falcor\n\n/home/max/dev/Falcor/src/Mogwai/Extensions/Profiler/TimingCapture.cpp:\n   83          if (!mFrameTimeFile.is_open()) return;\n   84  \n   85:         // The FrameRate object is updated at the start of each frame, the first valid time is available on the second frame.\n   86:         auto& frameRate = gpFramework->getFrameRate();\n   87          if (frameRate.getFrameCount() > 1)\n   88              mFrameTimeFile << frameRate.getLastFrameTime() << std::endl;\n\n/home/max/dev/Falcor/src/Mogwai/MogwaiSettings.cpp:\n   57  void showFps(Gui* pGui) {\n   58      Gui::Window w(pGui, \"##FPS\", { 0, 0 }, { 10, 25 }, Gui::WindowFlags::AllowMove | Gui::WindowFlags::AutoResize | Gui::WindowFlags::SetFocus);\n   59:     std::string msg = gpFramework->getFrameRate().getMsg(gpFramework->isVsyncEnabled());\n   60      w.text(msg);\n   61  }\n\n/home/max/dev/Falcor/src/Samples/HelloDXR/HelloDXR.cpp:\n  129      }\n  130  \n  131:     TextRenderer::render(pRenderContext, gpFramework->getFrameRate().getMsg(), pTargetFbo, { 20, 20 });\n  132  }\n  133  \n\n/home/max/dev/Falcor/src/Tools/RenderGraphEditor/RenderGraphEditor.cpp:\n  265  \n  266      if (mUpdateFilePath.size()) {\n  267:         mRenderGraphUIs[mCurrentGraphIndex].writeUpdateScriptToFile(pRenderContext, mUpdateFilePath, (float)gpFramework->getFrameRate().getLastFrameTime());\n  268      }\n  269  \n\n32 matches across 12 files\n\n\nSearching 1282 files for \"getGlobalClock\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/Sample.h:\n   81      Window* getWindow() override { return mpWindow.get(); }\n   82      \n   83:     //Clock& getGlobalClock() override { return mClock; }\n   84  \n   85      Clock& getClock() override { return *mClock; }\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightCollection.cpp:\n   73              if (mpScene->getAnimationController()->getMeshAnimationCount(instanceData.meshID) > 0) {\n   74                  bool hasAnimation = mpScene->getAnimationController()->getActiveAnimation(instanceData.meshID) != AnimationController::kBindPoseAnimationId;\n   75:                 bool isPaused = gpFramework->getGlobalClock().isPaused();\n   76                  if (hasAnimation && !isPaused) updateFlags |= UpdateFlags::AnimationChanged;\n   77              }\n\n/home/max/dev/Falcor/src/Mogwai/Extensions/Capture/CaptureTrigger.cpp:\n  101          RenderGraph* pGraph = mpRenderer->getActiveGraph();\n  102          if (!pGraph) return;\n  103:         uint64_t frameId = gpFramework->getGlobalClock().getFrame();\n  104          if (mGraphRanges.find(pGraph) == mGraphRanges.end()) return;\n  105          const auto& ranges = mGraphRanges.at(pGraph);\n  ...\n  127      {\n  128          if (!mCurrent.pGraph) return;\n  129:         uint64_t frameId = gpFramework->getGlobalClock().getFrame();\n  130          const auto& ranges = mGraphRanges.at(mCurrent.pGraph);\n  131  \n\n/home/max/dev/Falcor/src/Mogwai/Extensions/Capture/FrameCapture.cpp:\n  125              Texture* pTex = pGraph->getOutput(i)->asTexture().get();\n  126              assert(pTex);\n  127:             std::string filename = getOutputNamePrefix(pGraph->getOutputName(i)) + to_string(gpFramework->getGlobalClock().getFrame()) + \".\";;\n  128              auto ext = Bitmap::getFileExtFromResourceFormat(pTex->getFormat());\n  129              filename += ext;\n  ...\n  157          auto pGraph = mpRenderer->getActiveGraph();\n  158          if (!pGraph) return;\n  159:         uint64_t frameID = gpFramework->getGlobalClock().getFrame();\n  160          triggerFrame(gpDevice->getRenderContext(), pGraph, frameID);\n  161      }\n\n/home/max/dev/Falcor/src/Mogwai/Mogwai.cpp:\n  419  \n  420      for (auto& g : mGraphs) g.pGraph->setScene(mpScene);\n  421:     gpFramework->getGlobalClock().setTime(0);\n  422  }\n  423  \n  ...\n  492          // Update scene and camera.\n  493          if (mpScene) {\n  494:             mpScene->update(pRenderContext, gpFramework->getGlobalClock().getTime());\n  495          }\n  496  \n\n/home/max/dev/Falcor/src/Mogwai/MogwaiScripting.cpp:\n  105  \n  106      s += \"# Time Settings\\n\";\n  107:     s += gpFramework->getGlobalClock().getScript(kTimeVar) + \"\\n\";\n  108  \n  109      for (auto& pe : mpExtensions) {\n  ...\n  138      Extension::Bindings b(m, c);\n  139      b.addGlobalObject(kRendererVar, this, \"The engine\");\n  140:     b.addGlobalObject(kTimeVar, &gpFramework->getGlobalClock(), \"Time Utilities\");\n  141      for (auto& pe : mpExtensions) pe->scriptBindings(b);\n  142      mGlobalHelpMessage = prepareHelpMessage(b.mGlobalObjects);\n\n/home/max/dev/Falcor/src/Mogwai/MogwaiSettings.cpp:\n  132      Gui::Window w(pGui, \"Time\", mShowTime, { 0, 0 }, { 350, 25 }, Gui::WindowFlags::AllowMove | Gui::WindowFlags::AutoResize | Gui::WindowFlags::ShowTitleBar | Gui::WindowFlags::CloseButton);\n  133  \n  134:     Clock& clock = gpFramework->getGlobalClock();\n  135      clock.renderUI(w);\n  136      w.separator(2);\n\n/home/max/dev/Falcor/src/RenderPasses/DebugPasses/SplitScreenPass/SplitScreenPass.cpp:\n   61  {\n   62      mpArrowTex = Texture::create2D(16, 16, ResourceFormat::R8Unorm, 1, Texture::kMaxPossible, kArrowArray);\n   63:     mClock = gpFramework->getGlobalClock();\n   64      createProgram();\n   65  }\n\n/home/max/dev/Falcor/src/Samples/HelloDXR/HelloDXR.cpp:\n  124      if(mpScene)\n  125      {\n  126:         mpScene->update(pRenderContext, gpFramework->getGlobalClock().getTime());\n  127          if (mRayTrace) renderRT(pRenderContext, pTargetFbo.get());\n  128          else mpRasterPass->renderScene(pRenderContext, pTargetFbo);\n\n/home/max/dev/Falcor/src/Samples/ModelViewer/ModelViewer.cpp:\n  165  \n  166      if(mpScene) {\n  167:         mpScene->update(pRenderContext, gpFramework->getGlobalClock().getTime());\n  168  \n  169          // Set render state\n\n/home/max/dev/Falcor/src/Samples/ShaderToy/ShaderToy.cpp:\n   58      float height = (float)pTargetFbo->getHeight();\n   59      mpMainPass[\"ToyCB\"][\"iResolution\"] = float2(width, height);\n   60:     mpMainPass[\"ToyCB\"][\"iGlobalTime\"] = (float)gpFramework->getGlobalClock().getTime();\n   61  \n   62      // run final pass\n\n15 matches across 11 files\n\n\nSearching 1282 files for \"getGlobalClock\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/Sample.h:\n   81      Window* getWindow() override { return mpWindow.get(); }\n   82      \n   83:     //Clock& getGlobalClock() override { return mClock; }\n   84  \n   85      Clock& getClock() override { return *mClock; }\n\n/home/max/dev/Falcor/src/Mogwai/Extensions/Capture/CaptureTrigger.cpp:\n  101          RenderGraph* pGraph = mpRenderer->getActiveGraph();\n  102          if (!pGraph) return;\n  103:         uint64_t frameId = gpFramework->getGlobalClock().getFrame();\n  104          if (mGraphRanges.find(pGraph) == mGraphRanges.end()) return;\n  105          const auto& ranges = mGraphRanges.at(pGraph);\n  ...\n  127      {\n  128          if (!mCurrent.pGraph) return;\n  129:         uint64_t frameId = gpFramework->getGlobalClock().getFrame();\n  130          const auto& ranges = mGraphRanges.at(mCurrent.pGraph);\n  131  \n\n/home/max/dev/Falcor/src/Mogwai/Extensions/Capture/FrameCapture.cpp:\n  125              Texture* pTex = pGraph->getOutput(i)->asTexture().get();\n  126              assert(pTex);\n  127:             std::string filename = getOutputNamePrefix(pGraph->getOutputName(i)) + to_string(gpFramework->getGlobalClock().getFrame()) + \".\";;\n  128              auto ext = Bitmap::getFileExtFromResourceFormat(pTex->getFormat());\n  129              filename += ext;\n  ...\n  157          auto pGraph = mpRenderer->getActiveGraph();\n  158          if (!pGraph) return;\n  159:         uint64_t frameID = gpFramework->getGlobalClock().getFrame();\n  160          triggerFrame(gpDevice->getRenderContext(), pGraph, frameID);\n  161      }\n\n/home/max/dev/Falcor/src/Mogwai/Mogwai.cpp:\n  419  \n  420      for (auto& g : mGraphs) g.pGraph->setScene(mpScene);\n  421:     gpFramework->getGlobalClock().setTime(0);\n  422  }\n  423  \n  ...\n  492          // Update scene and camera.\n  493          if (mpScene) {\n  494:             mpScene->update(pRenderContext, gpFramework->getGlobalClock().getTime());\n  495          }\n  496  \n\n/home/max/dev/Falcor/src/Mogwai/MogwaiScripting.cpp:\n  105  \n  106      s += \"# Time Settings\\n\";\n  107:     s += gpFramework->getGlobalClock().getScript(kTimeVar) + \"\\n\";\n  108  \n  109      for (auto& pe : mpExtensions) {\n  ...\n  138      Extension::Bindings b(m, c);\n  139      b.addGlobalObject(kRendererVar, this, \"The engine\");\n  140:     b.addGlobalObject(kTimeVar, &gpFramework->getGlobalClock(), \"Time Utilities\");\n  141      for (auto& pe : mpExtensions) pe->scriptBindings(b);\n  142      mGlobalHelpMessage = prepareHelpMessage(b.mGlobalObjects);\n\n/home/max/dev/Falcor/src/Mogwai/MogwaiSettings.cpp:\n  132      Gui::Window w(pGui, \"Time\", mShowTime, { 0, 0 }, { 350, 25 }, Gui::WindowFlags::AllowMove | Gui::WindowFlags::AutoResize | Gui::WindowFlags::ShowTitleBar | Gui::WindowFlags::CloseButton);\n  133  \n  134:     Clock& clock = gpFramework->getGlobalClock();\n  135      clock.renderUI(w);\n  136      w.separator(2);\n\n/home/max/dev/Falcor/src/RenderPasses/DebugPasses/SplitScreenPass/SplitScreenPass.cpp:\n   61  {\n   62      mpArrowTex = Texture::create2D(16, 16, ResourceFormat::R8Unorm, 1, Texture::kMaxPossible, kArrowArray);\n   63:     mClock = gpFramework->getGlobalClock();\n   64      createProgram();\n   65  }\n\n/home/max/dev/Falcor/src/Samples/HelloDXR/HelloDXR.cpp:\n  124      if(mpScene)\n  125      {\n  126:         mpScene->update(pRenderContext, gpFramework->getGlobalClock().getTime());\n  127          if (mRayTrace) renderRT(pRenderContext, pTargetFbo.get());\n  128          else mpRasterPass->renderScene(pRenderContext, pTargetFbo);\n\n/home/max/dev/Falcor/src/Samples/ModelViewer/ModelViewer.cpp:\n  165  \n  166      if(mpScene) {\n  167:         mpScene->update(pRenderContext, gpFramework->getGlobalClock().getTime());\n  168  \n  169          // Set render state\n\n/home/max/dev/Falcor/src/Samples/ShaderToy/ShaderToy.cpp:\n   58      float height = (float)pTargetFbo->getHeight();\n   59      mpMainPass[\"ToyCB\"][\"iResolution\"] = float2(width, height);\n   60:     mpMainPass[\"ToyCB\"][\"iGlobalTime\"] = (float)gpFramework->getGlobalClock().getTime();\n   61  \n   62      // run final pass\n\n14 matches across 10 files\n\n\nSearching 1282 files for \"getGlobalClock\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/Sample.h:\n   81      Window* getWindow() override { return mpWindow.get(); }\n   82      \n   83:     //Clock& getGlobalClock() override { return mClock; }\n   84  \n   85      Clock& getClock() override { return *mClock; }\n\n/home/max/dev/Falcor/src/Mogwai/Extensions/Capture/FrameCapture.cpp:\n  125              Texture* pTex = pGraph->getOutput(i)->asTexture().get();\n  126              assert(pTex);\n  127:             std::string filename = getOutputNamePrefix(pGraph->getOutputName(i)) + to_string(gpFramework->getGlobalClock().getFrame()) + \".\";;\n  128              auto ext = Bitmap::getFileExtFromResourceFormat(pTex->getFormat());\n  129              filename += ext;\n  ...\n  157          auto pGraph = mpRenderer->getActiveGraph();\n  158          if (!pGraph) return;\n  159:         uint64_t frameID = gpFramework->getGlobalClock().getFrame();\n  160          triggerFrame(gpDevice->getRenderContext(), pGraph, frameID);\n  161      }\n\n/home/max/dev/Falcor/src/Mogwai/Mogwai.cpp:\n  419  \n  420      for (auto& g : mGraphs) g.pGraph->setScene(mpScene);\n  421:     gpFramework->getGlobalClock().setTime(0);\n  422  }\n  423  \n  ...\n  492          // Update scene and camera.\n  493          if (mpScene) {\n  494:             mpScene->update(pRenderContext, gpFramework->getGlobalClock().getTime());\n  495          }\n  496  \n\n/home/max/dev/Falcor/src/Mogwai/MogwaiScripting.cpp:\n  105  \n  106      s += \"# Time Settings\\n\";\n  107:     s += gpFramework->getGlobalClock().getScript(kTimeVar) + \"\\n\";\n  108  \n  109      for (auto& pe : mpExtensions) {\n  ...\n  138      Extension::Bindings b(m, c);\n  139      b.addGlobalObject(kRendererVar, this, \"The engine\");\n  140:     b.addGlobalObject(kTimeVar, &gpFramework->getGlobalClock(), \"Time Utilities\");\n  141      for (auto& pe : mpExtensions) pe->scriptBindings(b);\n  142      mGlobalHelpMessage = prepareHelpMessage(b.mGlobalObjects);\n\n/home/max/dev/Falcor/src/Mogwai/MogwaiSettings.cpp:\n  132      Gui::Window w(pGui, \"Time\", mShowTime, { 0, 0 }, { 350, 25 }, Gui::WindowFlags::AllowMove | Gui::WindowFlags::AutoResize | Gui::WindowFlags::ShowTitleBar | Gui::WindowFlags::CloseButton);\n  133  \n  134:     Clock& clock = gpFramework->getGlobalClock();\n  135      clock.renderUI(w);\n  136      w.separator(2);\n\n/home/max/dev/Falcor/src/RenderPasses/DebugPasses/SplitScreenPass/SplitScreenPass.cpp:\n   61  {\n   62      mpArrowTex = Texture::create2D(16, 16, ResourceFormat::R8Unorm, 1, Texture::kMaxPossible, kArrowArray);\n   63:     mClock = gpFramework->getGlobalClock();\n   64      createProgram();\n   65  }\n\n/home/max/dev/Falcor/src/Samples/HelloDXR/HelloDXR.cpp:\n  124      if(mpScene)\n  125      {\n  126:         mpScene->update(pRenderContext, gpFramework->getGlobalClock().getTime());\n  127          if (mRayTrace) renderRT(pRenderContext, pTargetFbo.get());\n  128          else mpRasterPass->renderScene(pRenderContext, pTargetFbo);\n\n/home/max/dev/Falcor/src/Samples/ModelViewer/ModelViewer.cpp:\n  165  \n  166      if(mpScene) {\n  167:         mpScene->update(pRenderContext, gpFramework->getGlobalClock().getTime());\n  168  \n  169          // Set render state\n\n/home/max/dev/Falcor/src/Samples/ShaderToy/ShaderToy.cpp:\n   58      float height = (float)pTargetFbo->getHeight();\n   59      mpMainPass[\"ToyCB\"][\"iResolution\"] = float2(width, height);\n   60:     mpMainPass[\"ToyCB\"][\"iGlobalTime\"] = (float)gpFramework->getGlobalClock().getTime();\n   61  \n   62      // run final pass\n\n12 matches across 9 files\n\n\nSearching 1282 files for \"getGlobalClock\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/Sample.h:\n   81      Window* getWindow() override { return mpWindow.get(); }\n   82      \n   83:     //Clock& getGlobalClock() override { return mClock; }\n   84  \n   85      Clock& getClock() override { return *mClock; }\n\n/home/max/dev/Falcor/src/Mogwai/Extensions/Capture/FrameCapture.cpp:\n  157          auto pGraph = mpRenderer->getActiveGraph();\n  158          if (!pGraph) return;\n  159:         uint64_t frameID = gpFramework->getGlobalClock().getFrame();\n  160          triggerFrame(gpDevice->getRenderContext(), pGraph, frameID);\n  161      }\n\n/home/max/dev/Falcor/src/Mogwai/Mogwai.cpp:\n  419  \n  420      for (auto& g : mGraphs) g.pGraph->setScene(mpScene);\n  421:     gpFramework->getGlobalClock().setTime(0);\n  422  }\n  423  \n  ...\n  492          // Update scene and camera.\n  493          if (mpScene) {\n  494:             mpScene->update(pRenderContext, gpFramework->getGlobalClock().getTime());\n  495          }\n  496  \n\n/home/max/dev/Falcor/src/Mogwai/MogwaiScripting.cpp:\n  105  \n  106      s += \"# Time Settings\\n\";\n  107:     s += gpFramework->getGlobalClock().getScript(kTimeVar) + \"\\n\";\n  108  \n  109      for (auto& pe : mpExtensions) {\n  ...\n  138      Extension::Bindings b(m, c);\n  139      b.addGlobalObject(kRendererVar, this, \"The engine\");\n  140:     b.addGlobalObject(kTimeVar, &gpFramework->getGlobalClock(), \"Time Utilities\");\n  141      for (auto& pe : mpExtensions) pe->scriptBindings(b);\n  142      mGlobalHelpMessage = prepareHelpMessage(b.mGlobalObjects);\n\n/home/max/dev/Falcor/src/Mogwai/MogwaiSettings.cpp:\n  132      Gui::Window w(pGui, \"Time\", mShowTime, { 0, 0 }, { 350, 25 }, Gui::WindowFlags::AllowMove | Gui::WindowFlags::AutoResize | Gui::WindowFlags::ShowTitleBar | Gui::WindowFlags::CloseButton);\n  133  \n  134:     Clock& clock = gpFramework->getGlobalClock();\n  135      clock.renderUI(w);\n  136      w.separator(2);\n\n/home/max/dev/Falcor/src/RenderPasses/DebugPasses/SplitScreenPass/SplitScreenPass.cpp:\n   61  {\n   62      mpArrowTex = Texture::create2D(16, 16, ResourceFormat::R8Unorm, 1, Texture::kMaxPossible, kArrowArray);\n   63:     mClock = gpFramework->getGlobalClock();\n   64      createProgram();\n   65  }\n\n/home/max/dev/Falcor/src/Samples/HelloDXR/HelloDXR.cpp:\n  124      if(mpScene)\n  125      {\n  126:         mpScene->update(pRenderContext, gpFramework->getGlobalClock().getTime());\n  127          if (mRayTrace) renderRT(pRenderContext, pTargetFbo.get());\n  128          else mpRasterPass->renderScene(pRenderContext, pTargetFbo);\n\n/home/max/dev/Falcor/src/Samples/ModelViewer/ModelViewer.cpp:\n  165  \n  166      if(mpScene) {\n  167:         mpScene->update(pRenderContext, gpFramework->getGlobalClock().getTime());\n  168  \n  169          // Set render state\n\n/home/max/dev/Falcor/src/Samples/ShaderToy/ShaderToy.cpp:\n   58      float height = (float)pTargetFbo->getHeight();\n   59      mpMainPass[\"ToyCB\"][\"iResolution\"] = float2(width, height);\n   60:     mpMainPass[\"ToyCB\"][\"iGlobalTime\"] = (float)gpFramework->getGlobalClock().getTime();\n   61  \n   62      // run final pass\n\n11 matches across 9 files\n\n\nSearching 1282 files for \"_profileEvent\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Utils/Timing/Profiler.h:\n  189  \n  190  #if _PROFILING_ENABLED\n  191: #define PROFILE_ALL_FLAGS(_name) Falcor::ProfilerEvent _profileEvent##__LINE__(_name)\n  192: #define PROFILE_SOME_FLAGS(_name, _flags) Falcor::ProfilerEvent _profileEvent##__LINE__(_name, _flags)\n  193  \n  194  #define GET_PROFILE(_1, _2, NAME, ...) NAME\n\n2 matches in 1 file\n\n\nSearching 1282 files for \"createDescriptorSetLayout\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKDescriptorSet.cpp:\n   37  namespace Falcor {\n   38  \n   39:     VkDescriptorSetLayout createDescriptorSetLayout(const DescriptorSet::Layout& layout);\n   40      VkDescriptorType falcorToVkDescType(DescriptorPool::Type type);\n   41  \n   42      void DescriptorSet::apiInit() {\n   43:         auto layout = createDescriptorSetLayout(mLayout);\n   44          VkDescriptorSetAllocateInfo allocInfo = {};\n   45          allocInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKRootSignature.cpp:\n   67      }\n   68  \n   69:     VkDescriptorSetLayout createDescriptorSetLayout(std::shared_ptr<Device> device, const DescriptorSet::Layout& layout) {\n   70          std::vector<VkDescriptorSetLayoutBinding> bindings(layout.getRangeCount());\n   71  \n   ..\n  120          }\n  121  \n  122:         static VkDescriptorSetLayout emptyLayout = createDescriptorSetLayout(mpDevice, {});   // #VKTODO This gets deleted multiple times on exit\n  123          std::vector<VkDescriptorSetLayout> vkSetLayouts(maxIndex + 1, emptyLayout);\n  124  \n  125          for (const auto& set : mDesc.mSets) {\n  126:             vkSetLayouts[set.getRange(0).regSpace] = createDescriptorSetLayout(mpDevice, set); //createDescriptorSetLayout() verifies that all ranges use the same register space\n  127          }\n  128  \n\n6 matches across 2 files\n\n\nSearching 1282 files for \"createDescriptorSetLayout\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKDescriptorSet.cpp:\n   37  namespace Falcor {\n   38  \n   39:     VkDescriptorSetLayout createDescriptorSetLayout(std::shared_ptr<Device> pDevice, const DescriptorSet::Layout& layout);\n   40      VkDescriptorType falcorToVkDescType(DescriptorPool::Type type);\n   41  \n   42      void DescriptorSet::apiInit() {\n   43:         auto layout = createDescriptorSetLayout(mpDevice, mLayout);\n   44          VkDescriptorSetAllocateInfo allocInfo = {};\n   45          allocInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKRootSignature.cpp:\n   67      }\n   68  \n   69:     VkDescriptorSetLayout createDescriptorSetLayout(std::shared_ptr<Device> device, const DescriptorSet::Layout& layout) {\n   70          std::vector<VkDescriptorSetLayoutBinding> bindings(layout.getRangeCount());\n   71  \n   ..\n  120          }\n  121  \n  122:         static VkDescriptorSetLayout emptyLayout = createDescriptorSetLayout(mpDevice, {});   // #VKTODO This gets deleted multiple times on exit\n  123          std::vector<VkDescriptorSetLayout> vkSetLayouts(maxIndex + 1, emptyLayout);\n  124  \n  125          for (const auto& set : mDesc.mSets) {\n  126:             vkSetLayouts[set.getRange(0).regSpace] = createDescriptorSetLayout(mpDevice, set); //createDescriptorSetLayout() verifies that all ranges use the same register space\n  127          }\n  128  \n\n6 matches across 2 files\n\n\nSearching 1282 files for \"createDescriptorSetLayout\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKDescriptorSet.cpp:\n   37  namespace Falcor {\n   38  \n   39:     VkDescriptorSetLayout createDescriptorSetLayout(std::shared_ptr<Device> pDevice, const DescriptorSet::Layout& layout);\n   40      VkDescriptorType falcorToVkDescType(DescriptorPool::Type type);\n   41  \n   42      void DescriptorSet::apiInit() {\n   43:         auto layout = createDescriptorSetLayout(mpDevice, mLayout);\n   44          VkDescriptorSetAllocateInfo allocInfo = {};\n   45          allocInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKRootSignature.cpp:\n   67      }\n   68  \n   69:     VkDescriptorSetLayout createDescriptorSetLayout(std::shared_ptr<Device> pDevice, const DescriptorSet::Layout& layout) {\n   70          std::vector<VkDescriptorSetLayoutBinding> bindings(layout.getRangeCount());\n   71  \n   ..\n  120          }\n  121  \n  122:         static VkDescriptorSetLayout emptyLayout = createDescriptorSetLayout(mpDevice, {});   // #VKTODO This gets deleted multiple times on exit\n  123          std::vector<VkDescriptorSetLayout> vkSetLayouts(maxIndex + 1, emptyLayout);\n  124  \n  125          for (const auto& set : mDesc.mSets) {\n  126:             vkSetLayouts[set.getRange(0).regSpace] = createDescriptorSetLayout(mpDevice, set); //createDescriptorSetLayout() verifies that all ranges use the same register space\n  127          }\n  128  \n\n6 matches across 2 files\n\n\nSearching 1282 files for \"getBufferDataAlignment\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Buffer.cpp:\n   57  }  // namespace\n   58  \n   59: size_t getBufferDataAlignment(const Buffer* pBuffer);\n   60  void* mapBufferApi(const Buffer::ApiHandle& apiHandle, size_t size);\n   61  \n   ..\n  250  \n  251          mpCBV = nullptr;\n  252:         mDynamicData = mpDevice->getUploadHeap()->allocate(mSize, getBufferDataAlignment(this));\n  253          mApiHandle = mDynamicData.pResourceHandle;\n  254          mGpuVaOffset = mDynamicData.offset;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Buffer.cpp:\n   61      }\n   62  \n   63:     size_t getBufferDataAlignment(const Buffer* pBuffer)\n   64      {\n   65          // This in order of the alignment size\n   ..\n   97              {\n   98                  assert(gpDevice);\n   99:                 mDynamicData = gpDevice->getUploadHeap()->allocate(mSize, getBufferDataAlignment(this));\n  100                  mApiHandle = mDynamicData.pResourceHandle;\n  101                  mGpuVaOffset = mDynamicData.offset;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKBuffer.cpp:\n   80  }\n   81  \n   82: size_t getBufferDataAlignment(Device::SharedPtr device, const Buffer* pBuffer) {\n   83      VkMemoryRequirements reqs;\n   84      vkGetBufferMemoryRequirements(device->getApiHandle(), pBuffer->getApiHandle(), &reqs);\n\n5 matches across 3 files\n\n\nSearching 1282 files for \"getBufferDataAlignment\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Buffer.cpp:\n   57  }  // namespace\n   58  \n   59: size_t getBufferDataAlignment(Device::SharedPtr pDevice, const Buffer* pBuffer);\n   60  void* mapBufferApi(const Buffer::ApiHandle& apiHandle, size_t size);\n   61  \n   ..\n  250  \n  251          mpCBV = nullptr;\n  252:         mDynamicData = mpDevice->getUploadHeap()->allocate(mSize, getBufferDataAlignment(mpDevice, this));\n  253          mApiHandle = mDynamicData.pResourceHandle;\n  254          mGpuVaOffset = mDynamicData.offset;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Buffer.cpp:\n   61      }\n   62  \n   63:     size_t getBufferDataAlignment(const Buffer* pBuffer)\n   64      {\n   65          // This in order of the alignment size\n   ..\n   97              {\n   98                  assert(gpDevice);\n   99:                 mDynamicData = gpDevice->getUploadHeap()->allocate(mSize, getBufferDataAlignment(this));\n  100                  mApiHandle = mDynamicData.pResourceHandle;\n  101                  mGpuVaOffset = mDynamicData.offset;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKBuffer.cpp:\n   80  }\n   81  \n   82: size_t getBufferDataAlignment(Device::SharedPtr device, const Buffer* pBuffer) {\n   83      VkMemoryRequirements reqs;\n   84      vkGetBufferMemoryRequirements(device->getApiHandle(), pBuffer->getApiHandle(), &reqs);\n\n5 matches across 3 files\n\n\nSearching 1282 files for \"getBufferDataAlignment\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Buffer.cpp:\n   57  }  // namespace\n   58  \n   59: size_t getBufferDataAlignment(const Buffer* pBuffer);\n   60  void* mapBufferApi(const Buffer::ApiHandle& apiHandle, size_t size);\n   61  \n   ..\n  250  \n  251          mpCBV = nullptr;\n  252:         mDynamicData = mpDevice->getUploadHeap()->allocate(mSize, getBufferDataAlignment(this));\n  253          mApiHandle = mDynamicData.pResourceHandle;\n  254          mGpuVaOffset = mDynamicData.offset;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Buffer.cpp:\n   61      }\n   62  \n   63:     size_t getBufferDataAlignment(const Buffer* pBuffer)\n   64      {\n   65          // This in order of the alignment size\n   ..\n   97              {\n   98                  assert(gpDevice);\n   99:                 mDynamicData = gpDevice->getUploadHeap()->allocate(mSize, getBufferDataAlignment(this));\n  100                  mApiHandle = mDynamicData.pResourceHandle;\n  101                  mGpuVaOffset = mDynamicData.offset;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKBuffer.cpp:\n   80  }\n   81  \n   82: size_t getBufferDataAlignment(Device::SharedPtr pDevice, const Buffer* pBuffer) {\n   83      VkMemoryRequirements reqs;\n   84      vkGetBufferMemoryRequirements(pDevice->getApiHandle(), pBuffer->getApiHandle(), &reqs);\n\n5 matches across 3 files\n\n\nSearching 1282 files for \"getBufferDataAlignment\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Buffer.cpp:\n   57  }  // namespace\n   58  \n   59: size_t getBufferDataAlignment(const Buffer* pBuffer);\n   60  void* mapBufferApi(const Buffer::ApiHandle& apiHandle, size_t size);\n   61  \n   ..\n  250  \n  251          mpCBV = nullptr;\n  252:         mDynamicData = mpDevice->getUploadHeap()->allocate(mSize, getBufferDataAlignment(this));\n  253          mApiHandle = mDynamicData.pResourceHandle;\n  254          mGpuVaOffset = mDynamicData.offset;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Buffer.cpp:\n   61      }\n   62  \n   63:     size_t getBufferDataAlignment(const Buffer* pBuffer)\n   64      {\n   65          // This in order of the alignment size\n   ..\n   97              {\n   98                  assert(gpDevice);\n   99:                 mDynamicData = gpDevice->getUploadHeap()->allocate(mSize, getBufferDataAlignment(this));\n  100                  mApiHandle = mDynamicData.pResourceHandle;\n  101                  mGpuVaOffset = mDynamicData.offset;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKBuffer.cpp:\n   80  }\n   81  \n   82: size_t getBufferDataAlignment(const Buffer* pBuffer) {\n   83      VkMemoryRequirements reqs;\n   84      vkGetBufferMemoryRequirements(pBuffer->device()->getApiHandle(), pBuffer->getApiHandle(), &reqs);\n\n5 matches across 3 files\n\n\nSearching 1282 files for \"mapBufferApi\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Buffer.cpp:\n   58  \n   59  size_t getBufferDataAlignment(const Buffer* pBuffer);\n   60: void* mapBufferApi(const Buffer::ApiHandle& apiHandle, size_t size);\n   61  \n   62  Buffer::Buffer(std::shared_ptr<Device> pDevice, size_t size, BindFlags bindFlags, CpuAccess cpuAccess): Resource(pDevice, Type::Buffer, bindFlags, size), mCpuAccess(cpuAccess) {}\n   ..\n  263          } else if (mCpuAccess == CpuAccess::Read) {\n  264              assert(mBindFlags == BindFlags::None);\n  265:             return mapBufferApi(mApiHandle, mSize);\n  266          } else {\n  267              // For buffers without CPU access we must copy the contents to a staging buffer.\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Buffer.cpp:\n   71      }\n   72  \n   73:     void* mapBufferApi(const Buffer::ApiHandle& apiHandle, size_t size)\n   74      {\n   75          D3D12_RANGE r{ 0, size };\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKBuffer.cpp:\n   47  }\n   48  \n   49: void* mapBufferApi(Device::SharedPtr device, const Buffer::ApiHandle& apiHandle, size_t size) {\n   50      void* pData;\n   51      vk_call(vkMapMemory(device->getApiHandle(), apiHandle, 0, size, 0, &pData));\n\n4 matches across 3 files\n\n\nSearching 1282 files for \"ResourceHandle\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Buffer.cpp:\n  169      if (mpAliasedResource) return;\n  170  \n  171:     if (mDynamicData.pResourceHandle) {\n  172          mpDevice->getUploadHeap()->release(mDynamicData);\n  173      } else {\n  ...\n  243  \n  244          // Allocate a new buffer\n  245:         if (mDynamicData.pResourceHandle) {\n  246              mpDevice->getUploadHeap()->release(mDynamicData);\n  247          }\n  ...\n  249          mpCBV = nullptr;\n  250          mDynamicData = mpDevice->getUploadHeap()->allocate(mSize, getBufferDataAlignment(this));\n  251:         mApiHandle = mDynamicData.pResourceHandle;\n  252          mGpuVaOffset = mDynamicData.offset;\n  253          invalidateViews();\n  ...\n  258          if (mCpuAccess == CpuAccess::Write) {\n  259              // Buffers on the upload heap are already mapped, just return the ptr.\n  260:             assert(mDynamicData.pResourceHandle);\n  261              assert(mDynamicData.pData);\n  262              return mDynamicData.pData;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Buffer.cpp:\n   98                  assert(gpDevice);\n   99                  mDynamicData = gpDevice->getUploadHeap()->allocate(mSize, getBufferDataAlignment(this));\n  100:                 mApiHandle = mDynamicData.pResourceHandle;\n  101                  mGpuVaOffset = mDynamicData.offset;\n  102              }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Device.cpp:\n  252      }\n  253  \n  254:     bool Device::getApiFboData(uint32_t width, uint32_t height, ResourceFormat colorFormat, ResourceFormat depthFormat, ResourceHandle apiHandles[kSwapChainBuffersCount], uint32_t& currentBackBufferIndex) {\n  255          for (uint32_t i = 0; i < kSwapChainBuffersCount; i++) {\n  256              HRESULT hr = mpApiData->pSwapChain->GetBuffer(i, IID_PPV_ARGS(&apiHandles[i]));\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12GpuMemoryHeap.cpp:\n   71      void GpuMemoryHeap::initBasePageData(BaseData& data, size_t size)\n   72      {\n   73:         data.pResourceHandle = createBuffer(getInitState(mType), size, getHeapProps(mType), Buffer::BindFlags::None);\n   74          data.offset = 0;\n   75          D3D12_RANGE readRange = {};\n   76:         d3d_call(data.pResourceHandle->Map(0, &readRange, (void**)&data.pData));\n   77      }\n   78  }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/FalcorD3D12.h:\n  210      using CommandSignatureHandle = ID3D12CommandSignaturePtr;\n  211      using FenceHandle = ID3D12FencePtr;\n  212:     using ResourceHandle = ID3D12ResourcePtr;\n  213      using RtvHandle = std::shared_ptr<DescriptorSet>;\n  214      using DsvHandle = std::shared_ptr<DescriptorSet>;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Device.cpp:\n  166  \n  167  bool Device::updateDefaultFBO(uint32_t width, uint32_t height, ResourceFormat colorFormat, ResourceFormat depthFormat) {\n  168:     ResourceHandle apiHandles[kSwapChainBuffersCount] = {};\n  169      getApiFboData(width, height, colorFormat, depthFormat, apiHandles, mCurrentBackBufferIndex);\n  170  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Device.h:\n  249  \n  250      // API specific functions\n  251:     bool getApiFboData(uint32_t width, uint32_t height, ResourceFormat colorFormat, ResourceFormat depthFormat, ResourceHandle &apiHandle);\n  252:     bool getApiFboData(uint32_t width, uint32_t height, ResourceFormat colorFormat, ResourceFormat depthFormat, ResourceHandle apiHandles[kSwapChainBuffersCount], uint32_t& currentBackBufferIndex);\n  253      void destroyApiObjects();\n  254      void apiPresent();\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Engine.cpp:\n  131  \n  132  bool Engine::updateDefaultFBO(uint32_t width, uint32_t height, ResourceFormat colorFormat, ResourceFormat depthFormat) {\n  133:     ResourceHandle apiHandles[kSwapChainBuffersCount] = {};\n  134      getApiFboData(width, height, colorFormat, depthFormat, apiHandles, mCurrentBackBufferIndex);\n  135  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/GpuMemoryHeap.cpp:\n   84              data.offset = currentOffset;\n   85              data.pData = mpActivePage->pData + currentOffset;\n   86:             data.pResourceHandle = mpActivePage->pResourceHandle;\n   87              mpActivePage->currentOffset = currentOffset + size;\n   88              mpActivePage->allocationsCount++;\n   ..\n   94  \n   95      void GpuMemoryHeap::release(Allocation& data) {\n   96:         assert(data.pResourceHandle);\n   97          mDeferredReleases.push(data);\n   98      }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/GpuMemoryHeap.h:\n   53  \n   54      struct BaseData {\n   55:         ResourceHandle pResourceHandle;\n   56          GpuAddress offset = 0;\n   57          uint8_t* pData = nullptr;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Resource.h:\n   46  class dlldecl Resource : public std::enable_shared_from_this<Resource> {\n   47   public:\n   48:     using ApiHandle = ResourceHandle;\n   49      using BindFlags = ResourceBindFlags;\n   50  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/FalcorVK.h:\n   91  using CommandSignatureHandle = void*;\n   92  using FenceHandle = VkSemaphore;\n   93: using ResourceHandle = VkResource<VkImage, VkBuffer>::SharedPtr;\n   94  using RtvHandle = VkResource<VkImageView, VkBufferView>::SharedPtr;\n   95  using DsvHandle = VkResource<VkImageView, VkBufferView>::SharedPtr;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKBuffer.cpp:\n  113      if (mCpuAccess == CpuAccess::Write) {\n  114          mDynamicData = mpDevice->getUploadHeap()->allocate(mSize);\n  115:         mApiHandle = mDynamicData.pResourceHandle;\n  116      } else {\n  117          if (mCpuAccess == CpuAccess::Read && mBindFlags == BindFlags::None) {\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKDevice.cpp:\n  124  }\n  125  \n  126: bool Device::getApiFboData(uint32_t width, uint32_t height, ResourceFormat colorFormat, ResourceFormat depthFormat, ResourceHandle &apiHandle) {\n  127      VkImage image;\n  128      \n  129:     apiHandle = ResourceHandle::create(SharedPtr(this), image, nullptr);\n  130      return true;\n  131  }\n  132  \n  133: bool Device::getApiFboData(uint32_t width, uint32_t height, ResourceFormat colorFormat, ResourceFormat depthFormat, ResourceHandle apiHandles[kSwapChainBuffersCount], uint32_t& currentBackBufferIndex) {\n  134      uint32_t imageCount = 0;\n  135      vkGetSwapchainImagesKHR(mApiHandle, mpApiData->swapchain, &imageCount, nullptr);\n  ...\n  140      vkGetSwapchainImagesKHR(mApiHandle, mpApiData->swapchain, &imageCount, swapchainImages.data());\n  141      for (size_t i = 0; i < swapchainImages.size(); i++) {\n  142:         apiHandles[i] = ResourceHandle::create(SharedPtr(this), swapchainImages[i], nullptr);\n  143      }\n  144  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VkGpuMemoryHeap.cpp:\n   37  void GpuMemoryHeap::initBasePageData(BaseData& data, size_t size) {\n   38      // Create a buffer\n   39:     data.pResourceHandle = createBuffer(mpDevice, size, Buffer::BindFlags::Constant | Buffer::BindFlags::Vertex | Buffer::BindFlags::Index, mType);\n   40      data.offset = 0;\n   41:     vk_call(vkMapMemory(mpDevice->getApiHandle(), data.pResourceHandle, 0, VK_WHOLE_SIZE, 0, (void**)&data.pData));\n   42  }\n   43  \n\n27 matches across 15 files\n\n\nSearching 1282 files for \"VkResource\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/FalcorVK.h:\n   91  using CommandSignatureHandle = void*;\n   92  using FenceHandle = VkSemaphore;\n   93: using ResourceHandle = VkResource<VkImage, VkBuffer>::SharedPtr;\n   94: using RtvHandle = VkResource<VkImageView, VkBufferView>::SharedPtr;\n   95: using DsvHandle = VkResource<VkImageView, VkBufferView>::SharedPtr;\n   96: using SrvHandle = VkResource<VkImageView, VkBufferView>::SharedPtr;\n   97: using UavHandle = VkResource<VkImageView, VkBufferView>::SharedPtr;\n   98: using CbvHandle = VkResource<VkImageView, VkBufferView>::SharedPtr;\n   99  using FboHandle = VkFbo::SharedPtr;\n  100  using SamplerHandle = VkHandle<VkSampler>::SharedPtr;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKComputeContext.cpp:\n   96      void clearColorImageCommon(CopyContext* pCtx, const ViewType* pView, const ClearType& clearVal)\n   97      {\n   98:         if(pView->getApiHandle().getType() != VkResourceType::Image)\n   99          {\n  100              logWarning(\"Looks like you are trying to clear a buffer. Vulkan only supports clearing Buffers with a single uint value. Please use the uint version of clearUav(). Call is ignored\");\n  ...\n  127      void ComputeContext::clearUAV(const UnorderedAccessView* pUav, const uint4& value)\n  128      {\n  129:         if(pUav->getApiHandle().getType() == VkResourceType::Buffer)\n  130          {\n  131              if ((value.x != value.y) || ((value.x != value.z) && (value.x != value.w)))\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKCopyContext.cpp:\n  276      bool CopyContext::textureBarrier(const Texture* pTexture, Resource::State newState)\n  277      {\n  278:         assert(pTexture->getApiHandle().getType() == VkResourceType::Image);\n  279  \n  280          VkImageLayout srcLayout = getImageLayout(pTexture->getGlobalState());\n  ...\n  310      {\n  311          assert(pBuffer);\n  312:         assert(pBuffer->getApiHandle().getType() == VkResourceType::Buffer);\n  313  \n  314          VkPipelineStageFlags srcStageMask = getShaderStageMask(pBuffer->getGlobalState(), true);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKDescriptorSet.cpp:\n   69          VkBufferView texelBufferView = {};\n   70  \n   71:         if (handle.getType() == VkResourceType::Buffer) {\n   72              Buffer* pBuffer = dynamic_cast<Buffer*>(pView->getResource());\n   73              if (pBuffer->isTyped()) {\n   ..\n   81              }\n   82          } else {\n   83:             assert(handle.getType() == VkResourceType::Image);\n   84              image.imageLayout = isUav ? VK_IMAGE_LAYOUT_GENERAL : VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;\n   85              image.imageView = handle;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKResourceViews.cpp:\n  133  \n  134  // SharedConstPtr = std::shared_ptr<const Resource>;\n  135: VkResource<VkImageView, VkBufferView>::SharedPtr createViewCommon(const Resource::SharedConstPtr& pSharedPtr, uint32_t mostDetailedMip, uint32_t mipCount, uint32_t firstArraySlice, uint32_t arraySize) {\n  136      const Resource* pResource = pSharedPtr.get();\n  137      assert(pResource);\n  138  \n  139      switch (pResource->getApiHandle().getType()) {\n  140:         case VkResourceType::Image: {\n  141              VkImageViewCreateInfo info = initializeImageViewInfo((const Texture*)pResource, mostDetailedMip, mipCount, firstArraySlice, arraySize);\n  142              VkImageView imageView;\n  143              vk_call(vkCreateImageView(pResource->device()->getApiHandle(), &info, nullptr, &imageView));\n  144:             return VkResource<VkImageView, VkBufferView>::SharedPtr::create(pResource->device(), imageView, nullptr);\n  145          }\n  146  \n  147:         case VkResourceType::Buffer: {\n  148              // We only create views for typed Buffers\n  149              VkBufferView bufferView = {};\n  ...\n  155              }\n  156  \n  157:             return VkResource<VkImageView, VkBufferView>::SharedPtr::create(pResource->device(), bufferView, nullptr);\n  158          }\n  159  \n  160          default:\n  161              should_not_get_here();\n  162:             return VkResource<VkImageView, VkBufferView>::SharedPtr();\n  163      }\n  164  }\n  ...\n  181      if (!pBuffer) {\n  182          VkBufferView bufferView = {};\n  183:         auto view = VkResource<VkImageView, VkBufferView>::SharedPtr::create(pBuffer.get()->device(), bufferView, nullptr);\n  184          return SharedPtr(new ShaderResourceView(pBuffer, view, firstElement, elementCount));\n  185      }\n  186  \n  187:     if (pBuffer->getApiHandle().getType() == VkResourceType::Image) {\n  188          logWarning(\"Cannot create DepthStencilView from a texture!\");\n  189          return getNullBufferView();\n  ...\n  202      }\n  203  \n  204:     auto view = VkResource<VkImageView, VkBufferView>::SharedPtr::create(pBuffer.get()->device(), bufferView, nullptr);\n  205  \n  206      return SharedPtr(new ShaderResourceView(pBuffer, view, firstElement, elementCount));\n  ...\n  213      }\n  214  \n  215:     if (pTexture->getApiHandle().getType() == VkResourceType::Buffer) {\n  216          logWarning(\"Cannot create DepthStencilView from a buffer!\");\n  217          return getNullView();\n  ...\n  227      }\n  228  \n  229:     if (pTexture->getApiHandle().getType() == VkResourceType::Buffer) {\n  230          logWarning(\"Cannot create UnorderedAccessView from a buffer!\");\n  231          return getNullView();;\n  ...\n  243      if (!pBuffer) {\n  244          VkBufferView bufferView = {};\n  245:         auto view = VkResource<VkImageView, VkBufferView>::SharedPtr::create(pBuffer.get()->device(), bufferView, nullptr);\n  246          return SharedPtr(new UnorderedAccessView(pBuffer, view, firstElement, elementCount));\n  247      }\n  248  \n  249:     if (pBuffer->getApiHandle().getType() == VkResourceType::Image) {\n  250          logWarning(\"Cannot create UnorderedAccessView from a texture!\");\n  251          return getNullBufferView();\n  ...\n  264      }\n  265  \n  266:     auto view = VkResource<VkImageView, VkBufferView>::SharedPtr::create(pBuffer.get()->device(), bufferView, nullptr);\n  267      return SharedPtr(new UnorderedAccessView(pBuffer, view, firstElement, elementCount));\n  268  }\n  ...\n  277  \n  278      // Check type\n  279:     if (pTexture->getApiHandle().getType() == VkResourceType::Buffer) {\n  280          logWarning(\"Cannot create RenderTargetView from a buffer!\");\n  281          return getNullView();\n  ...\n  291  \n  292      VkBufferView bufferView = {};\n  293:     auto handle = VkResource<VkImageView, VkBufferView>::SharedPtr::create(pBuffer.get()->device(), bufferView, nullptr);\n  294  \n  295  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VkSmartHandle.cpp:\n   56  \n   57      template<>\n   58:     VkResource<VkImage, VkBuffer>::~VkResource() {\n   59          if (!mpDevice) {\n   60:             // #VKTODO This is here because of the black texture in VkResourceViews.cpp\n   61              return;\n   62          }\n   63:         assert(mDeviceMem || mType == VkResourceType::Image);  // All of our resources are allocated with memory, except for the swap-chain backbuffers that we shouldn't release\n   64          if (mDeviceMem) {\n   65              switch (mType) {\n   66:                 case VkResourceType::Image:\n   67                      if (mImage) {\n   68                          vkDestroyImage(mpDevice->getApiHandle(), mImage, nullptr);\n   69                      }\n   70                      break;\n   71:                 case VkResourceType::Buffer:\n   72                      if (mBuffer) {\n   73                          vkDestroyBuffer(mpDevice->getApiHandle(), mBuffer, nullptr);\n   ..\n   82  \n   83      template<>\n   84:     VkResource<VkImageView, VkBufferView>::~VkResource() {\n   85          if (!mpDevice) {\n   86:             // #VKTODO This is here because of the black texture in VkResourceViews.cpp\n   87              return;\n   88          }\n   89          switch (mType) {\n   90:             case VkResourceType::Image:\n   91                  if (mImage) {\n   92                      vkDestroyImageView(mpDevice->getApiHandle(), mImage, nullptr);\n   93                  }\n   94                  break;\n   95:             case VkResourceType::Buffer:\n   96                  if (mBuffer) {\n   97                      vkDestroyBufferView(mpDevice->getApiHandle(), mBuffer, nullptr);\n   ..\n  127      template VkHandle<VkQueryPool>::~VkHandle();\n  128  \n  129:     template VkResource<VkImage, VkBuffer>::~VkResource();\n  130:     template VkResource<VkImageView, VkBufferView>::~VkResource();\n  131  }  // namespace Falcor\n  132  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKSmartHandle.h:\n  127  };\n  128  \n  129: enum class VkResourceType {\n  130      None,\n  131      Image,\n  ...\n  134  \n  135  template<typename ImageType, typename BufferType>\n  136: class VkResource : public VkBaseApiHandle, public inherit_shared_from_this<VkBaseApiHandle, VkResource<ImageType, BufferType>> {\n  137   public:\n  138:     class SharedPtr : public std::shared_ptr<VkResource<ImageType, BufferType>> {\n  139       public:\n  140          SharedPtr() = default;\n  141:         explicit SharedPtr(VkResource<ImageType, BufferType>* pRes) : std::shared_ptr<VkResource<ImageType, BufferType>>(pRes) {}\n  142  \n  143          static SharedPtr create(std::shared_ptr<Device> device, ImageType image, VkDeviceMemory mem) {\n  144:             return SharedPtr(new VkResource<ImageType, BufferType>(device, image, mem));\n  145          }\n  146  \n  147          static SharedPtr create(std::shared_ptr<Device> device, BufferType buffer, VkDeviceMemory mem) {\n  148:             return SharedPtr(new VkResource<ImageType, BufferType>(device, buffer, mem));\n  149          }\n  150  \n  151:         VkResourceType getType() const { return get()->mType; }\n  152          ImageType getImage() const {\n  153              return get()->mImage;\n  154          }\n  155:         operator ImageType() const {assert(get()->mType == VkResourceType::Image); return get()->mImage; }\n  156:         operator BufferType() const { assert(get()->mType == VkResourceType::Buffer); return get()->mBuffer; }\n  157          operator VkDeviceMemory() const { return get()->mDeviceMem; }\n  158  \n  159       private:\n  160:         VkResource<ImageType, BufferType>* get() const { return std::shared_ptr<VkResource<ImageType, BufferType>>::get(); }\n  161      };\n  162  \n  163:     ~VkResource() {\n  164  #ifdef _WIN32\n  165:         static_assert(false, \"VkResource missing destructor specialization\");\n  166  #endif\n  167      }\n  ...\n  169   private:\n  170      friend SharedPtr;\n  171:     VkResource(std::shared_ptr<Device> device, ImageType image, VkDeviceMemory mem) : VkBaseApiHandle(device), mType(VkResourceType::Image), mImage(image), mDeviceMem(mem) { }\n  172      \n  173:     VkResource(std::shared_ptr<Device> device, BufferType buffer, VkDeviceMemory mem) : VkBaseApiHandle(device), mType(VkResourceType::Buffer), mBuffer(buffer), mDeviceMem(mem) { }\n  174  \n  175:     VkResourceType mType = VkResourceType::None;\n  176      ImageType mImage = VK_NULL_HANDLE;\n  177      BufferType mBuffer = VK_NULL_HANDLE;\n  ...\n  217  template<> VkHandle<VkQueryPool>::~VkHandle();\n  218  \n  219: template<> VkResource<VkImage, VkBuffer>::~VkResource();\n  220: template<> VkResource<VkImageView, VkBufferView>::~VkResource();\n  221  \n  222  }  // namespace Falcor\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKTexture.cpp:\n   38  \n   39      Texture::~Texture() {\n   40:         // #VKTODO the `if` is here because of the black texture in VkResourceView.cpp\n   41          if (mpDevice ) mpDevice->releaseResource(std::static_pointer_cast<VkBaseApiHandle>(mApiHandle));\n   42      }\n\n/home/max/dev/Falcor/src/Falcor/Falcor.vcxproj:\n  508        <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='ReleaseD3D12|x64'\">true</ExcludedFromBuild>\n  509      </ClCompile>\n  510:     <ClCompile Include=\"Core\\API\\Vulkan\\VkResource.cpp\">\n  511        <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='DebugD3D12|x64'\">true</ExcludedFromBuild>\n  512        <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='ReleaseD3D12|x64'\">true</ExcludedFromBuild>\n\n/home/max/dev/Falcor/src/Falcor/Falcor.vcxproj.filters:\n  747        <Filter>Core\\API\\Vulkan</Filter>\n  748      </ClCompile>\n  749:     <ClCompile Include=\"Core\\API\\Vulkan\\VkResource.cpp\">\n  750        <Filter>Core\\API\\Vulkan</Filter>\n  751      </ClCompile>\n\n/home/max/dev/Falcor/src/USD/hgiVk/computeEncoder.cpp:\n   46  HgiVkComputeEncoder::BindResources(HgiResourceBindingsHandle res)\n   47  {\n   48:     if (HgiVkResourceBindings* r = static_cast<HgiVkResourceBindings*>(res)) {\n   49          r->BindResources(_commandBuffer);\n   50      }\n\n/home/max/dev/Falcor/src/USD/hgiVk/garbageCollector.cpp:\n   86                  }\n   87                  case HgiVkObjectTypeResourceBindings: {\n   88:                     HgiVkResourceBindings* r = obj.resourceBindings;\n   89                      delete r;\n   90                      break;\n\n/home/max/dev/Falcor/src/USD/hgiVk/graphicsEncoder.cpp:\n  130  HgiVkGraphicsEncoder::BindResources(HgiResourceBindingsHandle res)\n  131  {\n  132:     if (HgiVkResourceBindings* r = static_cast<HgiVkResourceBindings*>(res)) {\n  133          r->BindResources(_commandBuffer);\n  134      }\n  ...\n  167      const void* data)\n  168  {\n  169:     HgiVkResourceBindings* r = static_cast<HgiVkResourceBindings*>(res);\n  170      if (!TF_VERIFY(r)) return;\n  171  \n\n/home/max/dev/Falcor/src/USD/hgiVk/hgi.cpp:\n  294  {\n  295      HgiVkDevice* device = GetPrimaryDevice();\n  296:     return new HgiVkResourceBindings(device, desc);\n  297  }\n  298  \n  ...\n  305          object.type = HgiVkObjectTypeResourceBindings;\n  306          if (object.resourceBindings =\n  307:                 static_cast<HgiVkResourceBindings*>(*resHandle)) {\n  308              device->DestroyObject(object);\n  309              *resHandle = nullptr;\n\n/home/max/dev/Falcor/src/USD/hgiVk/object.h:\n   34          class HgiVkRenderPass* renderPass;\n   35          class HgiVkPipeline* pipeline;\n   36:         class HgiVkResourceBindings* resourceBindings;\n   37          class HgiVkShaderFunction* shaderFunction;\n   38          class HgiVkShaderProgram* shaderProgram;\n\n/home/max/dev/Falcor/src/USD/hgiVk/pipeline.cpp:\n  133      //\n  134  \n  135:     HgiVkResourceBindings* resources =\n  136:         static_cast<HgiVkResourceBindings*>(_descriptor.resourceBindings);\n  137  \n  138      HgiVertexBufferDescVector const& vbos = resources->GetVertexBuffers();\n  ...\n  387      // This was generated when the resource bindings was created.\n  388      //\n  389:     HgiVkResourceBindings* resources =\n  390:         static_cast<HgiVkResourceBindings*>(_descriptor.resourceBindings);\n  391  \n  392      pipeCreateInfo.layout = resources->GetPipelineLayout();\n\n/home/max/dev/Falcor/src/USD/hgiVk/resourceBindings.cpp:\n   12  PXR_NAMESPACE_OPEN_SCOPE\n   13  \n   14: HgiVkResourceBindings::HgiVkResourceBindings(\n   15      HgiVkDevice* device,\n   16      HgiResourceBindingsDesc const& desc)\n   ..\n  366  }\n  367  \n  368: HgiVkResourceBindings::~HgiVkResourceBindings()\n  369  {\n  370      vkDestroyDescriptorSetLayout(\n  ...\n  396  \n  397  HgiBufferBindDescVector const&\n  398: HgiVkResourceBindings::GetBufferBindings() const\n  399  {\n  400      return _descriptor.buffers;\n  ...\n  402  \n  403  HgiTextureBindDescVector const&\n  404: HgiVkResourceBindings::GetTextureBindings() const\n  405  {\n  406      return _descriptor.textures;\n  ...\n  408  \n  409  HgiVertexBufferDescVector const&\n  410: HgiVkResourceBindings::GetVertexBuffers() const\n  411  {\n  412      return _descriptor.vertexBuffers;\n  ...\n  414  \n  415  void\n  416: HgiVkResourceBindings::BindResources(HgiVkCommandBuffer* cb)\n  417  {\n  418      VkPipelineBindPoint bindPoint =\n  ...\n  438  \n  439  VkPipelineLayout\n  440: HgiVkResourceBindings::GetPipelineLayout() const\n  441  {\n  442      return _vkPipelineLayout;\n  ...\n  444  \n  445  VkDescriptorSet\n  446: HgiVkResourceBindings::GetDescriptorSet() const\n  447  {\n  448      return _vkDescriptorSet;\n  ...\n  450  \n  451  VkDescriptorImageInfoVector const&\n  452: HgiVkResourceBindings::GetImageInfos() const\n  453  {\n  454      return _imageInfos;\n  ...\n  456  \n  457  VkDescriptorBufferInfoVector const&\n  458: HgiVkResourceBindings::GetBufferInfos() const\n  459  {\n  460      return _bufferInfos;\n\n/home/max/dev/Falcor/src/USD/hgiVk/resourceBindings.h:\n   21  \n   22  ///\n   23: /// \\class HgiVkResourceBindings\n   24  ///\n   25  /// Vulkan implementation of HgiResourceBindings.\n   ..\n   35  /// design is to have one descriptor pool per resourceBindings.\n   36  ///\n   37: class HgiVkResourceBindings final : public HgiResourceBindings {\n   38  public:\n   39      HGIVK_API\n   40:     HgiVkResourceBindings(\n   41          HgiVkDevice* device,\n   42          HgiResourceBindingsDesc const& desc);\n   43  \n   44      HGIVK_API\n   45:     virtual ~HgiVkResourceBindings();\n   46  \n   47      /// Returns the list of buffers that needs to be bound.\n   ..\n   78  \n   79  private:\n   80:     HgiVkResourceBindings() = delete;\n   81:     HgiVkResourceBindings & operator=(const HgiVkResourceBindings&) = delete;\n   82:     HgiVkResourceBindings(const HgiVkResourceBindings&) = delete;\n   83  \n   84  private:\n\n106 matches across 18 files\n\n\nSearching 1282 files for \"VkResource\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/FalcorVK.h:\n   91  using CommandSignatureHandle = void*;\n   92  using FenceHandle = VkSemaphore;\n   93: using ResourceHandle = VkResource<VkImage, VkBuffer>::SharedPtr;\n   94: using RtvHandle = VkResource<VkImageView, VkBufferView>::SharedPtr;\n   95: using DsvHandle = VkResource<VkImageView, VkBufferView>::SharedPtr;\n   96: using SrvHandle = VkResource<VkImageView, VkBufferView>::SharedPtr;\n   97: using UavHandle = VkResource<VkImageView, VkBufferView>::SharedPtr;\n   98: using CbvHandle = VkResource<VkImageView, VkBufferView>::SharedPtr;\n   99  using FboHandle = VkFbo::SharedPtr;\n  100  using SamplerHandle = VkHandle<VkSampler>::SharedPtr;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKComputeContext.cpp:\n   96      void clearColorImageCommon(CopyContext* pCtx, const ViewType* pView, const ClearType& clearVal)\n   97      {\n   98:         if(pView->getApiHandle().getType() != VkResourceType::Image)\n   99          {\n  100              logWarning(\"Looks like you are trying to clear a buffer. Vulkan only supports clearing Buffers with a single uint value. Please use the uint version of clearUav(). Call is ignored\");\n  ...\n  127      void ComputeContext::clearUAV(const UnorderedAccessView* pUav, const uint4& value)\n  128      {\n  129:         if(pUav->getApiHandle().getType() == VkResourceType::Buffer)\n  130          {\n  131              if ((value.x != value.y) || ((value.x != value.z) && (value.x != value.w)))\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKCopyContext.cpp:\n  276      bool CopyContext::textureBarrier(const Texture* pTexture, Resource::State newState)\n  277      {\n  278:         assert(pTexture->getApiHandle().getType() == VkResourceType::Image);\n  279  \n  280          VkImageLayout srcLayout = getImageLayout(pTexture->getGlobalState());\n  ...\n  310      {\n  311          assert(pBuffer);\n  312:         assert(pBuffer->getApiHandle().getType() == VkResourceType::Buffer);\n  313  \n  314          VkPipelineStageFlags srcStageMask = getShaderStageMask(pBuffer->getGlobalState(), true);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKDescriptorSet.cpp:\n   69          VkBufferView texelBufferView = {};\n   70  \n   71:         if (handle.getType() == VkResourceType::Buffer) {\n   72              Buffer* pBuffer = dynamic_cast<Buffer*>(pView->getResource());\n   73              if (pBuffer->isTyped()) {\n   ..\n   81              }\n   82          } else {\n   83:             assert(handle.getType() == VkResourceType::Image);\n   84              image.imageLayout = isUav ? VK_IMAGE_LAYOUT_GENERAL : VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;\n   85              image.imageView = handle;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKResourceViews.cpp:\n  133  \n  134  // SharedConstPtr = std::shared_ptr<const Resource>;\n  135: VkResource<VkImageView, VkBufferView>::SharedPtr createViewCommon(const Resource::SharedConstPtr& pSharedPtr, uint32_t mostDetailedMip, uint32_t mipCount, uint32_t firstArraySlice, uint32_t arraySize) {\n  136      const Resource* pResource = pSharedPtr.get();\n  137      assert(pResource);\n  138  \n  139      switch (pResource->getApiHandle().getType()) {\n  140:         case VkResourceType::Image: {\n  141              VkImageViewCreateInfo info = initializeImageViewInfo((const Texture*)pResource, mostDetailedMip, mipCount, firstArraySlice, arraySize);\n  142              VkImageView imageView;\n  143              vk_call(vkCreateImageView(pResource->device()->getApiHandle(), &info, nullptr, &imageView));\n  144:             return VkResource<VkImageView, VkBufferView>::SharedPtr::create(pResource->device(), imageView, nullptr);\n  145          }\n  146  \n  147:         case VkResourceType::Buffer: {\n  148              // We only create views for typed Buffers\n  149              VkBufferView bufferView = {};\n  ...\n  155              }\n  156  \n  157:             return VkResource<VkImageView, VkBufferView>::SharedPtr::create(pResource->device(), bufferView, nullptr);\n  158          }\n  159  \n  160          default:\n  161              should_not_get_here();\n  162:             return VkResource<VkImageView, VkBufferView>::SharedPtr();\n  163      }\n  164  }\n  ...\n  181      if (!pBuffer) {\n  182          VkBufferView bufferView = {};\n  183:         auto view = VkResource<VkImageView, VkBufferView>::SharedPtr::create(pBuffer.get()->device(), bufferView, nullptr);\n  184          return SharedPtr(new ShaderResourceView(pBuffer, view, firstElement, elementCount));\n  185      }\n  186  \n  187:     if (pBuffer->getApiHandle().getType() == VkResourceType::Image) {\n  188          logWarning(\"Cannot create DepthStencilView from a texture!\");\n  189          return getNullBufferView();\n  ...\n  202      }\n  203  \n  204:     auto view = VkResource<VkImageView, VkBufferView>::SharedPtr::create(pBuffer.get()->device(), bufferView, nullptr);\n  205  \n  206      return SharedPtr(new ShaderResourceView(pBuffer, view, firstElement, elementCount));\n  ...\n  213      }\n  214  \n  215:     if (pTexture->getApiHandle().getType() == VkResourceType::Buffer) {\n  216          logWarning(\"Cannot create DepthStencilView from a buffer!\");\n  217          return getNullView();\n  ...\n  227      }\n  228  \n  229:     if (pTexture->getApiHandle().getType() == VkResourceType::Buffer) {\n  230          logWarning(\"Cannot create UnorderedAccessView from a buffer!\");\n  231          return getNullView();;\n  ...\n  243      if (!pBuffer) {\n  244          VkBufferView bufferView = {};\n  245:         auto view = VkResource<VkImageView, VkBufferView>::SharedPtr::create(pBuffer.get()->device(), bufferView, nullptr);\n  246          return SharedPtr(new UnorderedAccessView(pBuffer, view, firstElement, elementCount));\n  247      }\n  248  \n  249:     if (pBuffer->getApiHandle().getType() == VkResourceType::Image) {\n  250          logWarning(\"Cannot create UnorderedAccessView from a texture!\");\n  251          return getNullBufferView();\n  ...\n  264      }\n  265  \n  266:     auto view = VkResource<VkImageView, VkBufferView>::SharedPtr::create(pBuffer.get()->device(), bufferView, nullptr);\n  267      return SharedPtr(new UnorderedAccessView(pBuffer, view, firstElement, elementCount));\n  268  }\n  ...\n  277  \n  278      // Check type\n  279:     if (pTexture->getApiHandle().getType() == VkResourceType::Buffer) {\n  280          logWarning(\"Cannot create RenderTargetView from a buffer!\");\n  281          return getNullView();\n  ...\n  291  \n  292      VkBufferView bufferView = {};\n  293:     auto handle = VkResource<VkImageView, VkBufferView>::SharedPtr::create(pBuffer.get()->device(), bufferView, nullptr);\n  294  \n  295  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VkSmartHandle.cpp:\n   56  \n   57      template<>\n   58:     VkResource<VkImage, VkBuffer>::~VkResource() {\n   59          if (!mpDevice) {\n   60:             // #VKTODO This is here because of the black texture in VkResourceViews.cpp\n   61              return;\n   62          }\n   63:         assert(mDeviceMem || mType == VkResourceType::Image);  // All of our resources are allocated with memory, except for the swap-chain backbuffers that we shouldn't release\n   64          if (mDeviceMem) {\n   65              switch (mType) {\n   66:                 case VkResourceType::Image:\n   67                      if (mImage) {\n   68                          vkDestroyImage(mpDevice->getApiHandle(), mImage, nullptr);\n   69                      }\n   70                      break;\n   71:                 case VkResourceType::Buffer:\n   72                      if (mBuffer) {\n   73                          vkDestroyBuffer(mpDevice->getApiHandle(), mBuffer, nullptr);\n   ..\n   82  \n   83      template<>\n   84:     VkResource<VkImageView, VkBufferView>::~VkResource() {\n   85          if (!mpDevice) {\n   86:             // #VKTODO This is here because of the black texture in VkResourceViews.cpp\n   87              return;\n   88          }\n   89          switch (mType) {\n   90:             case VkResourceType::Image:\n   91                  if (mImage) {\n   92                      vkDestroyImageView(mpDevice->getApiHandle(), mImage, nullptr);\n   93                  }\n   94                  break;\n   95:             case VkResourceType::Buffer:\n   96                  if (mBuffer) {\n   97                      vkDestroyBufferView(mpDevice->getApiHandle(), mBuffer, nullptr);\n   ..\n  127      template VkHandle<VkQueryPool>::~VkHandle();\n  128  \n  129:     template VkResource<VkImage, VkBuffer>::~VkResource();\n  130:     template VkResource<VkImageView, VkBufferView>::~VkResource();\n  131  }  // namespace Falcor\n  132  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKSmartHandle.h:\n  130  };\n  131  \n  132: enum class VkResourceType {\n  133      None,\n  134      Image,\n  ...\n  137  \n  138  template<typename ImageType, typename BufferType>\n  139: class VkResource : public VkBaseApiHandle, public inherit_shared_from_this<VkBaseApiHandle, VkResource<ImageType, BufferType>> {\n  140   public:\n  141:     class SharedPtr : public std::shared_ptr<VkResource<ImageType, BufferType>> {\n  142       public:\n  143          SharedPtr() = default;\n  144:         explicit SharedPtr(VkResource<ImageType, BufferType>* pRes) : std::shared_ptr<VkResource<ImageType, BufferType>>(pRes) {}\n  145  \n  146          static SharedPtr create(std::shared_ptr<Device> device, ImageType image, VkDeviceMemory mem) {\n  147:             return SharedPtr(new VkResource<ImageType, BufferType>(device, image, mem));\n  148          }\n  149  \n  150          static SharedPtr create(std::shared_ptr<Device> device, BufferType buffer, VkDeviceMemory mem) {\n  151:             return SharedPtr(new VkResource<ImageType, BufferType>(device, buffer, mem));\n  152          }\n  153  \n  154:         VkResourceType getType() const { return get()->mType; }\n  155          ImageType getImage() const {\n  156              return get()->mImage;\n  157          }\n  158:         operator ImageType() const {assert(get()->mType == VkResourceType::Image); return get()->mImage; }\n  159:         operator BufferType() const { assert(get()->mType == VkResourceType::Buffer); return get()->mBuffer; }\n  160          operator VkDeviceMemory() const { return get()->mDeviceMem; }\n  161  \n  162       private:\n  163:         VkResource<ImageType, BufferType>* get() const { return std::shared_ptr<VkResource<ImageType, BufferType>>::get(); }\n  164      };\n  165  \n  166:     ~VkResource() {\n  167  #ifdef _WIN32\n  168:         static_assert(false, \"VkResource missing destructor specialization\");\n  169  #endif\n  170      }\n  ...\n  172   private:\n  173      friend SharedPtr;\n  174:     VkResource(std::shared_ptr<Device> device, ImageType image, VkDeviceMemory mem) : VkBaseApiHandle(device), mType(VkResourceType::Image), mImage(image), mDeviceMem(mem) { }\n  175      \n  176:     VkResource(std::shared_ptr<Device> device, BufferType buffer, VkDeviceMemory mem) : VkBaseApiHandle(device), mType(VkResourceType::Buffer), mBuffer(buffer), mDeviceMem(mem) { }\n  177  \n  178:     VkResourceType mType = VkResourceType::None;\n  179      ImageType mImage = VK_NULL_HANDLE;\n  180      BufferType mBuffer = VK_NULL_HANDLE;\n  ...\n  220  template<> VkHandle<VkQueryPool>::~VkHandle();\n  221  \n  222: template<> VkResource<VkImage, VkBuffer>::~VkResource();\n  223: template<> VkResource<VkImageView, VkBufferView>::~VkResource();\n  224  \n  225  }  // namespace Falcor\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKTexture.cpp:\n   38  \n   39      Texture::~Texture() {\n   40:         // #VKTODO the `if` is here because of the black texture in VkResourceView.cpp\n   41          if (mpDevice ) mpDevice->releaseResource(std::static_pointer_cast<VkBaseApiHandle>(mApiHandle));\n   42      }\n\n/home/max/dev/Falcor/src/Falcor/Falcor.vcxproj:\n  508        <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='ReleaseD3D12|x64'\">true</ExcludedFromBuild>\n  509      </ClCompile>\n  510:     <ClCompile Include=\"Core\\API\\Vulkan\\VkResource.cpp\">\n  511        <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='DebugD3D12|x64'\">true</ExcludedFromBuild>\n  512        <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='ReleaseD3D12|x64'\">true</ExcludedFromBuild>\n\n/home/max/dev/Falcor/src/Falcor/Falcor.vcxproj.filters:\n  747        <Filter>Core\\API\\Vulkan</Filter>\n  748      </ClCompile>\n  749:     <ClCompile Include=\"Core\\API\\Vulkan\\VkResource.cpp\">\n  750        <Filter>Core\\API\\Vulkan</Filter>\n  751      </ClCompile>\n\n/home/max/dev/Falcor/src/USD/hgiVk/computeEncoder.cpp:\n   46  HgiVkComputeEncoder::BindResources(HgiResourceBindingsHandle res)\n   47  {\n   48:     if (HgiVkResourceBindings* r = static_cast<HgiVkResourceBindings*>(res)) {\n   49          r->BindResources(_commandBuffer);\n   50      }\n\n/home/max/dev/Falcor/src/USD/hgiVk/garbageCollector.cpp:\n   86                  }\n   87                  case HgiVkObjectTypeResourceBindings: {\n   88:                     HgiVkResourceBindings* r = obj.resourceBindings;\n   89                      delete r;\n   90                      break;\n\n/home/max/dev/Falcor/src/USD/hgiVk/graphicsEncoder.cpp:\n  130  HgiVkGraphicsEncoder::BindResources(HgiResourceBindingsHandle res)\n  131  {\n  132:     if (HgiVkResourceBindings* r = static_cast<HgiVkResourceBindings*>(res)) {\n  133          r->BindResources(_commandBuffer);\n  134      }\n  ...\n  167      const void* data)\n  168  {\n  169:     HgiVkResourceBindings* r = static_cast<HgiVkResourceBindings*>(res);\n  170      if (!TF_VERIFY(r)) return;\n  171  \n\n/home/max/dev/Falcor/src/USD/hgiVk/hgi.cpp:\n  294  {\n  295      HgiVkDevice* device = GetPrimaryDevice();\n  296:     return new HgiVkResourceBindings(device, desc);\n  297  }\n  298  \n  ...\n  305          object.type = HgiVkObjectTypeResourceBindings;\n  306          if (object.resourceBindings =\n  307:                 static_cast<HgiVkResourceBindings*>(*resHandle)) {\n  308              device->DestroyObject(object);\n  309              *resHandle = nullptr;\n\n/home/max/dev/Falcor/src/USD/hgiVk/object.h:\n   34          class HgiVkRenderPass* renderPass;\n   35          class HgiVkPipeline* pipeline;\n   36:         class HgiVkResourceBindings* resourceBindings;\n   37          class HgiVkShaderFunction* shaderFunction;\n   38          class HgiVkShaderProgram* shaderProgram;\n\n/home/max/dev/Falcor/src/USD/hgiVk/pipeline.cpp:\n  133      //\n  134  \n  135:     HgiVkResourceBindings* resources =\n  136:         static_cast<HgiVkResourceBindings*>(_descriptor.resourceBindings);\n  137  \n  138      HgiVertexBufferDescVector const& vbos = resources->GetVertexBuffers();\n  ...\n  387      // This was generated when the resource bindings was created.\n  388      //\n  389:     HgiVkResourceBindings* resources =\n  390:         static_cast<HgiVkResourceBindings*>(_descriptor.resourceBindings);\n  391  \n  392      pipeCreateInfo.layout = resources->GetPipelineLayout();\n\n/home/max/dev/Falcor/src/USD/hgiVk/resourceBindings.cpp:\n   12  PXR_NAMESPACE_OPEN_SCOPE\n   13  \n   14: HgiVkResourceBindings::HgiVkResourceBindings(\n   15      HgiVkDevice* device,\n   16      HgiResourceBindingsDesc const& desc)\n   ..\n  366  }\n  367  \n  368: HgiVkResourceBindings::~HgiVkResourceBindings()\n  369  {\n  370      vkDestroyDescriptorSetLayout(\n  ...\n  396  \n  397  HgiBufferBindDescVector const&\n  398: HgiVkResourceBindings::GetBufferBindings() const\n  399  {\n  400      return _descriptor.buffers;\n  ...\n  402  \n  403  HgiTextureBindDescVector const&\n  404: HgiVkResourceBindings::GetTextureBindings() const\n  405  {\n  406      return _descriptor.textures;\n  ...\n  408  \n  409  HgiVertexBufferDescVector const&\n  410: HgiVkResourceBindings::GetVertexBuffers() const\n  411  {\n  412      return _descriptor.vertexBuffers;\n  ...\n  414  \n  415  void\n  416: HgiVkResourceBindings::BindResources(HgiVkCommandBuffer* cb)\n  417  {\n  418      VkPipelineBindPoint bindPoint =\n  ...\n  438  \n  439  VkPipelineLayout\n  440: HgiVkResourceBindings::GetPipelineLayout() const\n  441  {\n  442      return _vkPipelineLayout;\n  ...\n  444  \n  445  VkDescriptorSet\n  446: HgiVkResourceBindings::GetDescriptorSet() const\n  447  {\n  448      return _vkDescriptorSet;\n  ...\n  450  \n  451  VkDescriptorImageInfoVector const&\n  452: HgiVkResourceBindings::GetImageInfos() const\n  453  {\n  454      return _imageInfos;\n  ...\n  456  \n  457  VkDescriptorBufferInfoVector const&\n  458: HgiVkResourceBindings::GetBufferInfos() const\n  459  {\n  460      return _bufferInfos;\n\n/home/max/dev/Falcor/src/USD/hgiVk/resourceBindings.h:\n   21  \n   22  ///\n   23: /// \\class HgiVkResourceBindings\n   24  ///\n   25  /// Vulkan implementation of HgiResourceBindings.\n   ..\n   35  /// design is to have one descriptor pool per resourceBindings.\n   36  ///\n   37: class HgiVkResourceBindings final : public HgiResourceBindings {\n   38  public:\n   39      HGIVK_API\n   40:     HgiVkResourceBindings(\n   41          HgiVkDevice* device,\n   42          HgiResourceBindingsDesc const& desc);\n   43  \n   44      HGIVK_API\n   45:     virtual ~HgiVkResourceBindings();\n   46  \n   47      /// Returns the list of buffers that needs to be bound.\n   ..\n   78  \n   79  private:\n   80:     HgiVkResourceBindings() = delete;\n   81:     HgiVkResourceBindings & operator=(const HgiVkResourceBindings&) = delete;\n   82:     HgiVkResourceBindings(const HgiVkResourceBindings&) = delete;\n   83  \n   84  private:\n\n106 matches across 18 files\n\n\nSearching 1282 files for \"mapBufferApi\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Buffer.cpp:\n   58  \n   59  size_t getBufferDataAlignment(const Buffer* pBuffer);\n   60: void* mapBufferApi(const Buffer::ApiHandle& apiHandle, size_t size);\n   61  \n   62  Buffer::Buffer(std::shared_ptr<Device> pDevice, size_t size, BindFlags bindFlags, CpuAccess cpuAccess): Resource(pDevice, Type::Buffer, bindFlags, size), mCpuAccess(cpuAccess) {}\n   ..\n  263          } else if (mCpuAccess == CpuAccess::Read) {\n  264              assert(mBindFlags == BindFlags::None);\n  265:             return mapBufferApi(mApiHandle, mSize);\n  266          } else {\n  267              // For buffers without CPU access we must copy the contents to a staging buffer.\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Buffer.cpp:\n   71      }\n   72  \n   73:     void* mapBufferApi(const Buffer::ApiHandle& apiHandle, size_t size)\n   74      {\n   75          D3D12_RANGE r{ 0, size };\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKBuffer.cpp:\n   47  }\n   48  \n   49: void* mapBufferApi(Device::SharedPtr device, const Buffer::ApiHandle& apiHandle, size_t size) {\n   50      void* pData;\n   51      vk_call(vkMapMemory(device->getApiHandle(), apiHandle, 0, size, 0, &pData));\n\n4 matches across 3 files\n\n\nSearching 1282 files for \"device\" (case sensitive)\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/setup.hpp:\n  387  \n  388  #if GLM_COMPILER & GLM_COMPILER_CUDA\n  389: #\tdefine GLM_CUDA_FUNC_DEF __device__ __host__\n  390: #\tdefine GLM_CUDA_FUNC_DECL __device__ __host__\n  391  #else\n  392  #\tdefine GLM_CUDA_FUNC_DEF\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/matrix_clip_space.hpp:\n   45  \n   46  \t/// Creates a matrix for an orthographic parallel viewing volume, using left-handed coordinates.\n   47: \t/// The near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n   48  \t///\n   49  \t/// @tparam T A floating-point scalar type\n   ..\n   55  \n   56  \t/// Creates a matrix for an orthographic parallel viewing volume using right-handed coordinates.\n   57: \t/// The near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n   58  \t///\n   59  \t/// @tparam T A floating-point scalar type\n   ..\n   65  \n   66  \t/// Creates a matrix for an orthographic parallel viewing volume, using left-handed coordinates.\n   67: \t/// The near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n   68  \t///\n   69  \t/// @tparam T A floating-point scalar type\n   ..\n   75  \n   76  \t/// Creates a matrix for an orthographic parallel viewing volume, using right-handed coordinates.\n   77: \t/// The near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n   78  \t///\n   79  \t/// @tparam T A floating-point scalar type\n   ..\n   85  \n   86  \t/// Creates a matrix for an orthographic parallel viewing volume, using left-handed coordinates.\n   87: \t/// The near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n   88  \t///\n   89  \t/// @tparam T A floating-point scalar type\n   ..\n   95  \n   96  \t/// Creates a matrix for an orthographic parallel viewing volume, using left-handed coordinates if GLM_FORCE_LEFT_HANDED if defined or right-handed coordinates otherwise.\n   97: \t/// The near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n   98  \t///\n   99  \t/// @tparam T A floating-point scalar type\n  ...\n  105  \n  106  \t/// Creates a matrix for an orthographic parallel viewing volume, using left-handed coordinates.\n  107: \t/// If GLM_FORCE_DEPTH_ZERO_TO_ONE is defined, the near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n  108: \t/// Otherwise, the near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n  109  \t///\n  110  \t/// @tparam T A floating-point scalar type\n  ...\n  116  \n  117  \t/// Creates a matrix for an orthographic parallel viewing volume, using right-handed coordinates.\n  118: \t/// If GLM_FORCE_DEPTH_ZERO_TO_ONE is defined, the near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n  119: \t/// Otherwise, the near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n  120  \t///\n  121  \t/// @tparam T A floating-point scalar type\n  ...\n  138  \n  139  \t/// Creates a left handed frustum matrix.\n  140: \t/// The near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n  141  \t///\n  142  \t/// @tparam T A floating-point scalar type\n  ...\n  146  \n  147  \t/// Creates a left handed frustum matrix.\n  148: \t/// The near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n  149  \t///\n  150  \t/// @tparam T A floating-point scalar type\n  ...\n  154  \n  155  \t/// Creates a right handed frustum matrix.\n  156: \t/// The near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n  157  \t///\n  158  \t/// @tparam T A floating-point scalar type\n  ...\n  162  \n  163  \t/// Creates a right handed frustum matrix.\n  164: \t/// The near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n  165  \t///\n  166  \t/// @tparam T A floating-point scalar type\n  ...\n  170  \n  171  \t/// Creates a frustum matrix using left-handed coordinates if GLM_FORCE_LEFT_HANDED if defined or right-handed coordinates otherwise.\n  172: \t/// The near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n  173  \t///\n  174  \t/// @tparam T A floating-point scalar type\n  ...\n  178  \n  179  \t/// Creates a frustum matrix using left-handed coordinates if GLM_FORCE_LEFT_HANDED if defined or right-handed coordinates otherwise.\n  180: \t/// The near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n  181  \t///\n  182  \t/// @tparam T A floating-point scalar type\n  ...\n  186  \n  187  \t/// Creates a left handed frustum matrix.\n  188: \t/// If GLM_FORCE_DEPTH_ZERO_TO_ONE is defined, the near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n  189: \t/// Otherwise, the near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n  190  \t///\n  191  \t/// @tparam T A floating-point scalar type\n  ...\n  195  \n  196  \t/// Creates a right handed frustum matrix.\n  197: \t/// If GLM_FORCE_DEPTH_ZERO_TO_ONE is defined, the near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n  198: \t/// Otherwise, the near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n  199  \t///\n  200  \t/// @tparam T A floating-point scalar type\n  ...\n  214  \n  215  \t/// Creates a matrix for a right handed, symetric perspective-view frustum.\n  216: \t/// The near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n  217  \t///\n  218  \t/// @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.\n  ...\n  227  \n  228  \t/// Creates a matrix for a right handed, symetric perspective-view frustum.\n  229: \t/// The near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n  230  \t///\n  231  \t/// @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.\n  ...\n  240  \n  241  \t/// Creates a matrix for a left handed, symetric perspective-view frustum.\n  242: \t/// The near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n  243  \t///\n  244  \t/// @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.\n  ...\n  253  \n  254  \t/// Creates a matrix for a left handed, symetric perspective-view frustum.\n  255: \t/// The near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n  256  \t///\n  257  \t/// @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.\n  ...\n  266  \n  267  \t/// Creates a matrix for a symetric perspective-view frustum using left-handed coordinates if GLM_FORCE_LEFT_HANDED if defined or right-handed coordinates otherwise.\n  268: \t/// The near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n  269  \t///\n  270  \t/// @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.\n  ...\n  279  \n  280  \t/// Creates a matrix for a symetric perspective-view frustum using left-handed coordinates if GLM_FORCE_LEFT_HANDED if defined or right-handed coordinates otherwise.\n  281: \t/// The near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n  282  \t///\n  283  \t/// @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.\n  ...\n  292  \n  293  \t/// Creates a matrix for a right handed, symetric perspective-view frustum.\n  294: \t/// If GLM_FORCE_DEPTH_ZERO_TO_ONE is defined, the near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n  295: \t/// Otherwise, the near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n  296  \t///\n  297  \t/// @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.\n  ...\n  306  \n  307  \t/// Creates a matrix for a left handed, symetric perspective-view frustum.\n  308: \t/// If GLM_FORCE_DEPTH_ZERO_TO_ONE is defined, the near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n  309: \t/// Otherwise, the near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n  310  \t///\n  311  \t/// @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.\n  ...\n  334  \n  335  \t/// Builds a perspective projection matrix based on a field of view using right-handed coordinates.\n  336: \t/// The near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n  337  \t///\n  338  \t/// @param fov Expressed in radians.\n  ...\n  348  \n  349  \t/// Builds a perspective projection matrix based on a field of view using right-handed coordinates.\n  350: \t/// The near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n  351  \t///\n  352  \t/// @param fov Expressed in radians.\n  ...\n  362  \n  363  \t/// Builds a perspective projection matrix based on a field of view using left-handed coordinates.\n  364: \t/// The near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n  365  \t///\n  366  \t/// @param fov Expressed in radians.\n  ...\n  376  \n  377  \t/// Builds a perspective projection matrix based on a field of view using left-handed coordinates.\n  378: \t/// The near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n  379  \t///\n  380  \t/// @param fov Expressed in radians.\n  ...\n  390  \n  391  \t/// Builds a perspective projection matrix based on a field of view using left-handed coordinates if GLM_FORCE_LEFT_HANDED if defined or right-handed coordinates otherwise.\n  392: \t/// The near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n  393  \t///\n  394  \t/// @param fov Expressed in radians.\n  ...\n  404  \n  405  \t/// Builds a perspective projection matrix based on a field of view using left-handed coordinates if GLM_FORCE_LEFT_HANDED if defined or right-handed coordinates otherwise.\n  406: \t/// The near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n  407  \t///\n  408  \t/// @param fov Expressed in radians.\n  ...\n  418  \n  419  \t/// Builds a right handed perspective projection matrix based on a field of view.\n  420: \t/// If GLM_FORCE_DEPTH_ZERO_TO_ONE is defined, the near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n  421: \t/// Otherwise, the near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n  422  \t///\n  423  \t/// @param fov Expressed in radians.\n  ...\n  433  \n  434  \t/// Builds a left handed perspective projection matrix based on a field of view.\n  435: \t/// If GLM_FORCE_DEPTH_ZERO_TO_ONE is defined, the near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n  436: \t/// Otherwise, the near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n  437  \t///\n  438  \t/// @param fov Expressed in radians.\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/matrix_projection.hpp:\n   36  \n   37  \t/// Map the specified object coordinates (obj.x, obj.y, obj.z) into window coordinates.\n   38: \t/// The near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n   39  \t///\n   40  \t/// @param obj Specify the object coordinates.\n   ..\n   52  \n   53  \t/// Map the specified object coordinates (obj.x, obj.y, obj.z) into window coordinates.\n   54: \t/// The near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n   55  \t///\n   56  \t/// @param obj Specify the object coordinates.\n   ..\n   84  \n   85  \t/// Map the specified window coordinates (win.x, win.y, win.z) into object coordinates.\n   86: \t/// The near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n   87  \t///\n   88  \t/// @param win Specify the window coordinates to be mapped.\n   ..\n  100  \n  101  \t/// Map the specified window coordinates (win.x, win.y, win.z) into object coordinates.\n  102: \t/// The near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n  103  \t///\n  104  \t/// @param win Specify the window coordinates to be mapped.\n\n/home/max/dev/Falcor/src/Falcor/Core/API/BlendState.cpp:\n   37      }\n   38  \n   39:     BlendState::Desc::Desc(std::shared_ptr<Device> device): mpDevice(device) {\n   40:         mRtDesc.resize(Fbo::getMaxColorTargetCount(device));\n   41      }\n   42  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/BlendState.h:\n   79      class dlldecl Desc {\n   80       public:\n   81:         Desc(std::shared_ptr<Device> device);\n   82          friend class BlendState;\n   83  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/ComputeContext.cpp:\n   33  namespace Falcor {\n   34  \n   35: ComputeContext::SharedPtr ComputeContext::create(std::shared_ptr<Device> device, CommandQueueHandle queue) {\n   36:     auto pCtx = SharedPtr(new ComputeContext(device, LowLevelContextData::CommandQueueType::Compute, queue));\n   37      pCtx->bindDescriptorHeaps(); // TODO: Should this be done here?\n   38      return pCtx;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/ComputeContext.h:\n   47          \\return A new object, or throws an exception if creation failed.\n   48      */\n   49:     static SharedPtr create(std::shared_ptr<Device> device, CommandQueueHandle queue);\n   50  \n   51      /** Dispatch a compute task\n   ..\n   81  \n   82   protected:\n   83:     ComputeContext(std::shared_ptr<Device> device, LowLevelContextData::CommandQueueType type, CommandQueueHandle queue);\n   84      bool prepareForDispatch(ComputeState* pState, ComputeVars* pVars);\n   85      bool applyComputeVars(ComputeVars* pVars, RootSignature* pRootSignature);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/ComputeStateObject.cpp:\n   43  }\n   44  \n   45: ComputeStateObject::ComputeStateObject(std::shared_ptr<Device> device, const Desc& desc) : mpDevice(device), mDesc(desc) {\n   46      apiInit();\n   47  }\n   48  \n   49: ComputeStateObject::SharedPtr ComputeStateObject::create(std::shared_ptr<Device> device, const Desc& desc) {\n   50:     return SharedPtr(new ComputeStateObject(device, desc));\n   51  }\n   52  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/ComputeStateObject.h:\n   61          \\return New object, or throws an exception if creation failed.\n   62      */\n   63:     static SharedPtr create(std::shared_ptr<Device> device, const Desc& desc);\n   64  \n   65      const ApiHandle& getApiHandle() { return mApiHandle; }\n   ..\n   67  \n   68   private:\n   69:     ComputeStateObject(std::shared_ptr<Device> device, const Desc& desc);\n   70      void apiInit();\n   71  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/CopyContext.cpp:\n   36  CopyContext::~CopyContext() = default;\n   37  \n   38: CopyContext::CopyContext(std::shared_ptr<Device> device, LowLevelContextData::CommandQueueType type, CommandQueueHandle queue) {\n   39:     mpLowLevelData = LowLevelContextData::create(device, type, queue);\n   40      assert(mpLowLevelData);\n   41:     mpDevice = device;\n   42  }\n   43  \n   44: CopyContext::SharedPtr CopyContext::create(std::shared_ptr<Device> device, CommandQueueHandle queue) {\n   45      assert(queue);\n   46:     return SharedPtr(new CopyContext(device, LowLevelContextData::CommandQueueType::Copy, queue));\n   47  }\n   48  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/CopyContext.h:\n   69      virtual ~CopyContext();\n   70  \n   71:     std::shared_ptr<Device> device() { return mpDevice; };\n   72  \n   73      /** Create a copy context.\n   ..\n   75          \\return A new object, or throws an exception if creation failed.\n   76      */\n   77:     static SharedPtr create(std::shared_ptr<Device> device, CommandQueueHandle queue);\n   78  \n   79      /** Flush the command list. This doesn't reset the command allocator, just submits the commands\n   ..\n  147      void setLowLevelContextData(LowLevelContextData::SharedPtr pLowLevelData) { mpLowLevelData = pLowLevelData; }\n  148  \n  149:     /** Bind the descriptor heaps from the device into the command list.\n  150      */\n  151      void bindDescriptorHeaps();\n  152  \n  153   protected:\n  154:     CopyContext(std::shared_ptr<Device> device, LowLevelContextData::CommandQueueType type, CommandQueueHandle queue);\n  155  \n  156      bool textureBarrier(const Texture* pTexture, Resource::State newState);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Device.cpp:\n  125      DeviceHandle createDevice(IDXGIFactory4* pFactory, D3D_FEATURE_LEVEL requestedFeatureLevel, const std::vector<UUID>& experimentalFeatures)\n  126      {\n  127:         // Feature levels to try creating devices. Listed in descending order so the highest supported level is used.\n  128          const static D3D_FEATURE_LEVEL kFeatureLevels[] =\n  129          {\n  ...\n  142          IDXGIAdapter1Ptr pAdapter;\n  143          DeviceHandle pDevice;\n  144:         D3D_FEATURE_LEVEL deviceFeatureLevel;\n  145  \n  146:         // Read FALCOR_GPU_DEVICE_ID environment variable or select first GPU device\n  147          const uint32_t selectedGpuDeviceId = ([] ()\n  148          {\n  ...\n  165                  if (SUCCEEDED(D3D12CreateDevice(pAdapter, pFeatureLevels[i], IID_PPV_ARGS(&pDevice))))\n  166                  {\n  167:                     deviceFeatureLevel = pFeatureLevels[i];\n  168                      return true;\n  169                  }\n  ...\n  185              if (selectedGpuVendorId != 0 && desc.VendorId != selectedGpuVendorId) continue;\n  186  \n  187:             // Skip to selected device id\n  188              if (gpuDeviceId++ < selectedGpuDeviceId) continue;\n  189  \n  ...\n  193              if (pDevice != nullptr)\n  194              {\n  195:                 logInfo(\"Successfully created device with feature level: \" + to_string(deviceFeatureLevel));\n  196                  return pDevice;\n  197              }\n  198          }\n  199  \n  200:         logFatal(\"Could not find a GPU that supports D3D12 device\");\n  201          return nullptr;\n  202      }\n  ...\n  210          if (FAILED(hr) || features2.ProgrammableSamplePositionsTier == D3D12_PROGRAMMABLE_SAMPLE_POSITIONS_TIER_NOT_SUPPORTED)\n  211          {\n  212:             logInfo(\"Programmable sample positions is not supported on this device.\");\n  213          }\n  214          else\n  ...\n  222          if (FAILED(hr) || features5.RaytracingTier == D3D12_RAYTRACING_TIER_NOT_SUPPORTED)\n  223          {\n  224:             logInfo(\"Raytracing is not supported on this device.\");\n  225          }\n  226          else\n  ...\n  297          d3d_call(CreateDXGIFactory2(dxgiFlags, IID_PPV_ARGS(&mpApiData->pDxgiFactory)));\n  298  \n  299:         // Create the device\n  300          mApiHandle = createDevice(mpApiData->pDxgiFactory, getD3DFeatureLevel(mDesc.apiMajorVersion, mDesc.apiMinorVersion), mDesc.experimentalFeatures);\n  301          if (mApiHandle == nullptr) return false;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/DescriptorPool.cpp:\n   31  namespace Falcor {\n   32  \n   33: DescriptorPool::SharedPtr DescriptorPool::create(std::shared_ptr<Device> device, const Desc& desc, const GpuFence::SharedPtr& pFence) {\n   34:     return SharedPtr(new DescriptorPool(device, desc, pFence));\n   35  }\n   36  \n   37: DescriptorPool::DescriptorPool(std::shared_ptr<Device> device, const Desc& desc, const GpuFence::SharedPtr& pFence): mDesc(desc), mpFence(pFence) {\n   38      apiInit();\n   39  }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/DescriptorPool.h:\n   96          \\return A new object, or throws an exception if creation failed.\n   97      */\n   98:     static SharedPtr create(std::shared_ptr<Device> device, const Desc& desc, const GpuFence::SharedPtr& pFence);\n   99  \n  100:     std::shared_ptr<Device> device() { return mpDevice; }\n  101  \n  102      uint32_t getDescCount(Type type) const { return mDesc.mDescCount[(uint32_t)type]; }\n  ...\n  109   private:\n  110      friend DescriptorSet;\n  111:     DescriptorPool(std::shared_ptr<Device> device, const Desc& desc, const GpuFence::SharedPtr & pFence);\n  112      void apiInit();\n  113      void releaseAllocation(std::shared_ptr<DescriptorSetApiData> pData);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Device.cpp:\n   33  namespace Falcor {\n   34      \n   35: void createNullViews(Device::SharedPtr device);\n   36  void releaseNullViews();\n   37: void createNullBufferViews(Device::SharedPtr device);\n   38  void releaseNullBufferViews();\n   39: void createNullTypedBufferViews(Device::SharedPtr device);\n   40  void releaseNullTypedBufferViews();\n   41  \n   ..\n   55  Device::SharedPtr Device::create(Window::SharedPtr& pWindow, const Device::Desc& desc) {\n   56      if(pWindow) {\n   57:         // Swapchain enabled device\n   58          if (_gpDevice) {\n   59:             logError(\"Falcor only supports a single device\");\n   60              return nullptr;\n   61          }\n   ..\n   65          return _gpDevice;\n   66      } else {\n   67:         // Headless device\n   68          if (_gpDeviceHeadless) {\n   69:             logError(\"Falcor only supports a single headless device\");\n   70              return nullptr;\n   71          }\n   72  \n   73:         _gpDeviceHeadless = SharedPtr(new Device(nullptr, desc));  // headless device\n   74          if (_gpDeviceHeadless->init() == false) { _gpDeviceHeadless = nullptr;}\n   75          return _gpDeviceHeadless;\n   ..\n   78  \n   79  /**\n   80:  * Initialize device\n   81   */\n   82  bool Device::init() {\n   ..\n  330  \n  331  SCRIPT_BINDING(Device) {\n  332:     auto deviceDesc = m.class_<Device::Desc>(\"DeviceDesc\");\n  333  #define desc_field(f_) rwField(#f_, &Device::Desc::f_)\n  334:     deviceDesc.desc_field(colorFormat).desc_field(depthFormat).desc_field(apiMajorVersion).desc_field(apiMinorVersion);\n  335:     deviceDesc.desc_field(enableVsync).desc_field(enableDebugLayer).desc_field(cmdQueues);\n  336  #undef desc_field\n  337  \n  338:     auto deviceClass = m.regClass(Device);\n  339:     deviceClass.ctor(&Device::create);\n  340  }\n  341  \n  ...\n  363  \n  364      // RenderPassLibrary\n  365:     const auto& createRenderPass = [](std::shared_ptr<Device> device, const std::string& passName, pybind11::dict d = {}) {\n  366:         auto pPass = RenderPassLibrary::instance().createPass(device->getRenderContext(), passName.c_str(), Dictionary(d));\n  367          if (!pPass) { \n  368              throw std::runtime_error((\"Can't create a render pass named `\" + passName + \"`. Make sure the required library was loaded.\").c_str());\n  ...\n  370          return pPass;\n  371      };\n  372:     passClass.ctor(createRenderPass, \"device\"_a, \"name\"_a, \"dict\"_a = pybind11::dict());\n  373  \n  374      const auto& loadPassLibrary = [](const std::string& library) {\n  ...\n  378      m.func_(RenderGraphIR::kLoadPassLibrary, loadPassLibrary, \"name\"_a);\n  379  \n  380:     const auto& updateRenderPass = [](std::shared_ptr<Device> device, const RenderGraph::SharedPtr& pGraph, const std::string& passName, pybind11::dict d) {\n  381:         pGraph->updatePass(device->getRenderContext(), passName, Dictionary(d));\n  382      };\n  383  \n  384:     graphClass.func_(RenderGraphIR::kUpdatePass, updateRenderPass, \"device\"_a, \"name\"_a, \"dict\"_a);\n  385  }\n  386  */\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Device.h:\n   69          ResourceFormat colorFormat = ResourceFormat::BGRA8UnormSrgb;    ///< The color buffer format\n   70          ResourceFormat depthFormat = ResourceFormat::D32Float;          ///< The depth buffer format\n   71:         uint32_t apiMajorVersion = 0;                                   ///< Requested API major version. If specified, device creation will fail if not supported. Otherwise, the highest supported version will be automatically selected.\n   72:         uint32_t apiMinorVersion = 0;                                   ///< Requested API minor version. If specified, device creation will fail if not supported. Otherwise, the highest supported version will be automatically selected.\n   73          bool enableVsync = false;                                       ///< Controls vertical-sync\n   74          bool enableDebugLayer = DEFAULT_ENABLE_DEBUG_LAYER;             ///< Enable the debug layer. The default for release build is false, for debug build it's true.\n   ..\n   99      using MemoryType = GpuMemoryHeap::Type;\n  100  \n  101:     /** Create a new device.\n  102          \\param[in] pWindow a previously-created window object\n  103          \\param[in] desc Device configuration descriptor.\n  104:         \\return nullptr if the function failed, otherwise a new device object\n  105      */\n  106      static SharedPtr create(Window::SharedPtr& pWindow, const Desc& desc);\n  ...\n  121      bool isHeadless() { return headless; };\n  122  \n  123:     /** Get physical device name\n  124      */\n  125      std::string& getPhysicalDeviceName();\n  ...\n  141  \n  142      /** Get the default render-context.\n  143:         The default render-context is managed completely by the device. The user should just queue commands into it, the device will take care of allocation, submission and synchronization\n  144      */\n  145      RenderContext* getRenderContext() const { return mpRenderContext.get(); }\n  ...\n  196      double getGpuTimestampFrequency() const { return mGpuTimestampFrequency; }  // ms/tick\n  197  \n  198:     /** Check if features are supported by the device\n  199      */\n  200      bool isFeatureSupported(SupportedFeatures flags) const;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Engine.cpp:\n   39  Engine::SharedPtr gpEngineHeadless;    \n   40  \n   41: Engine::Engine(Device::SharedPtr device) : mpDevice(device) {\n   42      headless = mpDevice->isHeadless();\n   43  }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Engine.h:\n   57          \\param[in] pWindow a previously-created window object\n   58          \\param[in] desc Device configuration descriptor.\n   59:         \\return nullptr if the function failed, otherwise a new device object\n   60      */\n   61      static SharedPtr create(Window::SharedPtr& pWindow, const Device::Desc& desc);\n   ..\n   73      Fbo::SharedPtr getOffscreenFbo() const;\n   74  \n   75:     Device::SharedPtr device() { return mpDevice; };\n   76  \n   77   private:\n   78:     Engine(Device::SharedPtr device);\n   79  \n   80      void releaseFboData();\n\n/home/max/dev/Falcor/src/Falcor/Core/API/FBO.cpp:\n  114          }\n  115  \n  116:         Texture::SharedPtr createTexture2D(std::shared_ptr<Device> device, uint32_t w, uint32_t h, ResourceFormat format, uint32_t sampleCount, uint32_t arraySize, uint32_t mipLevels, Texture::BindFlags flags) {\n  117              if (format == ResourceFormat::Unknown) {\n  118                  logError(\"Can't create Texture2D with an unknown resource format\");\n  ...\n  122              Texture::SharedPtr pTex;\n  123              if (sampleCount > 1) {\n  124:                 pTex = Texture::create2DMS(device, w, h, format, sampleCount, arraySize, flags);\n  125              } else {\n  126:                 pTex = Texture::create2D(device, w, h, format, arraySize, mipLevels, nullptr, flags);\n  127              }\n  128  \n  ...\n  147          std::hash<uint32_t> u32hash;\n  148          std::hash<bool> bhash;\n  149:         for (uint32_t i = 0; i < getMaxColorTargetCount(d.device()); i++) {\n  150              uint32_t format = (uint32_t)d.getColorTargetFormat(i);\n  151              format <<= i;\n  ...\n  174      }\n  175  \n  176:     Fbo::Desc::Desc(std::shared_ptr<Device> device): mpDevice(device) {\n  177:         mColorTargets.resize(Fbo::getMaxColorTargetCount(device));\n  178      }\n  179  \n  180:     Fbo::SharedPtr Fbo::create(std::shared_ptr<Device> device) {\n  181:         return SharedPtr(new Fbo(device));\n  182      }\n  183  \n  184:     Fbo::SharedPtr Fbo::create(std::shared_ptr<Device> device, const std::vector<Texture::SharedPtr>& colors, const Texture::SharedPtr& pDepth) {\n  185:         auto pFbo = create(device);\n  186          for (uint32_t i = 0 ; i < colors.size() ; i++) {\n  187              pFbo->attachColorTarget(colors[i], i);\n  ...\n  194      }\n  195  \n  196:     Fbo::SharedPtr Fbo::getDefault(std::shared_ptr<Device> device) {\n  197          static Fbo::SharedPtr pDefault;\n  198          if (pDefault == nullptr) {\n  199:             pDefault = Fbo::SharedPtr(new Fbo(device));\n  200          }\n  201          return pDefault;\n  ...\n  344      }\n  345  \n  346:     Fbo::SharedPtr Fbo::create2D(std::shared_ptr<Device> device, uint32_t width, uint32_t height, const Fbo::Desc& fboDesc, uint32_t arraySize, uint32_t mipLevels) {\n  347          uint32_t sampleCount = fboDesc.getSampleCount();\n  348          if (checkParams(\"Create2D\", width, height, arraySize, mipLevels, sampleCount) == false) {\n  ...\n  350          }\n  351          \n  352:         Fbo::SharedPtr pFbo = create(device);\n  353          \n  354          // Create the color targets\n  355:         for (uint32_t i = 0; i < Fbo::getMaxColorTargetCount(device); i++) {\n  356              if (fboDesc.getColorTargetFormat(i) != ResourceFormat::Unknown) {\n  357                  Texture::BindFlags flags = getBindFlags(false, fboDesc.isColorTargetUav(i));\n  358:                 Texture::SharedPtr pTex = createTexture2D(device, width, height, fboDesc.getColorTargetFormat(i), sampleCount, arraySize, mipLevels, flags);\n  359                  pFbo->attachColorTarget(pTex, i, 0, 0, kAttachEntireMipLevel);\n  360              }\n  ...\n  363          if (fboDesc.getDepthStencilFormat() != ResourceFormat::Unknown) {\n  364              Texture::BindFlags flags = getBindFlags(true, fboDesc.isDepthStencilUav());\n  365:             Texture::SharedPtr pDepth = createTexture2D(device, width, height, fboDesc.getDepthStencilFormat(), sampleCount, arraySize, mipLevels, flags);\n  366              pFbo->attachDepthStencilTarget(pDepth, 0, 0, kAttachEntireMipLevel);\n  367          }\n  ...\n  370      }\n  371  \n  372:     Fbo::SharedPtr Fbo::createCubemap(std::shared_ptr<Device> device, uint32_t width, uint32_t height, const Desc& fboDesc, uint32_t arraySize, uint32_t mipLevels) {\n  373          if (fboDesc.getSampleCount() > 1) {\n  374              throw std::runtime_error(\"Can't create cubemap FBO. Multisampled cubemap is not supported.\");\n  ...\n  378          }\n  379  \n  380:         Fbo::SharedPtr pFbo = create(device);\n  381  \n  382          // Create the color targets\n  383:         for (uint32_t i = 0; i < getMaxColorTargetCount(device); i++) {\n  384              Texture::BindFlags flags = getBindFlags(false, fboDesc.isColorTargetUav(i));\n  385:             auto pTex = Texture::createCube(device, width, height, fboDesc.getColorTargetFormat(i), arraySize, mipLevels, nullptr, flags);\n  386              pFbo->attachColorTarget(pTex, i, 0, kAttachEntireMipLevel);\n  387          }\n  ...\n  389          if (fboDesc.getDepthStencilFormat() != ResourceFormat::Unknown) {\n  390              Texture::BindFlags flags = getBindFlags(true, fboDesc.isDepthStencilUav());\n  391:             auto pDepth = Texture::createCube(device, width, height, fboDesc.getDepthStencilFormat(), arraySize, mipLevels, nullptr, flags);\n  392              pFbo->attachDepthStencilTarget(pDepth, 0, kAttachEntireMipLevel);\n  393          }\n  ...\n  396      }\n  397  \n  398:     Fbo::SharedPtr Fbo::create2D(std::shared_ptr<Device> device, uint32_t width, uint32_t height, ResourceFormat color, ResourceFormat depth) {\n  399:         Desc d(device);\n  400          d.setColorTarget(0, color).setDepthStencilTarget(depth);\n  401:         return create2D(device, width, height, d);\n  402      }\n  403  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/FBO.h:\n   49      class dlldecl Desc {\n   50       public:\n   51:         Desc(std::shared_ptr<Device> device);\n   52  \n   53:         std::shared_ptr<Device> device() const { return mpDevice; }        \n   54  \n   55          /** Set a render target to be a color target.\n   ..\n  122      /** Get a FBO representing the default framebuffer object\n  123      */\n  124:     static SharedPtr getDefault(std::shared_ptr<Device> device);\n  125  \n  126      /** Create a new empty FBO.\n  127          \\return A new object, or throws an exception if creation failed.\n  128      */\n  129:     static SharedPtr create(std::shared_ptr<Device> device);\n  130  \n  131      /** Create an FBO from a list of textures. It will bind mip 0 and the all of the array slices.\n  ...\n  134          \\return A new object. An exception is thrown if creation failed, for example due to texture size mismatch, bind flags issues, illegal formats, etc.\n  135      */\n  136:     static SharedPtr create(std::shared_ptr<Device> device, const std::vector<Texture::SharedPtr>& colors, const Texture::SharedPtr& pDepth = nullptr);\n  137  \n  138      /** Create a color-only 2D framebuffer.\n  ...\n  144          \\return A new object. An exception is thrown if creation failed, for example due to invalid parameters.\n  145      */\n  146:     static SharedPtr create2D(std::shared_ptr<Device> device, uint32_t width, uint32_t height, const Desc& fboDesc, uint32_t arraySize = 1, uint32_t mipLevels = 1);\n  147  \n  148      /** Create a color-only cubemap framebuffer.\n  ...\n  154          \\return A new object. An exception is thrown if creation failed, for example due to invalid parameters.\n  155      */\n  156:     static SharedPtr createCubemap(std::shared_ptr<Device> device, uint32_t width, uint32_t height, const Desc& fboDesc, uint32_t arraySize = 1, uint32_t mipLevels = 1);\n  157  \n  158      /** Creates an FBO with a single color texture (single mip, single array slice), and optionally a depth buffer.\n  ...\n  163          \\return A new object. An exception is thrown if creation failed, for example due to invalid parameters.\n  164      */\n  165:     static SharedPtr create2D(std::shared_ptr<Device> device, uint32_t width, uint32_t height, ResourceFormat color, ResourceFormat depth = ResourceFormat::Unknown);\n  166  \n  167      /** Attach a depth-stencil texture.\n  ...\n  190      /** Get the maximum number of color targets\n  191      */\n  192:     static uint32_t getMaxColorTargetCount(std::shared_ptr<Device> device);\n  193  \n  194      /** Get an attached color texture. If no texture is attached will return nullptr.\n  ...\n  271      void finalize() const;\n  272  \n  273:     Fbo(std::shared_ptr<Device> device);\n  274      std::vector<Attachment> mColorAttachments;\n  275      std::vector<SamplePosition> mSamplePositions;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/FencedPool.h:\n   51          \\return A new object, or throws an exception if creation failed.\n   52      */\n   53:     static SharedPtr create(std::shared_ptr<Device> device, GpuFence::SharedConstPtr pFence, NewObjectFuncType newFunc, void* pUserData = nullptr) {\n   54:         return SharedPtr(new FencedPool(device, pFence, newFunc, pUserData));\n   55      }\n   56  \n   ..\n   78  \n   79  private:\n   80:     FencedPool(std::shared_ptr<Device> device, GpuFence::SharedConstPtr pFence, NewObjectFuncType newFunc, void* pUserData)\n   81          : mpUserData(pUserData)\n   82          , mpFence(pFence)\n   83          , mNewObjFunc(newFunc)\n   84:         , mpDevice(device)\n   85      {\n   86:         assert(device);\n   87          assert(pFence && newFunc);\n   88          mActiveObject = createObject();\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Formats.h:\n  355      /** Get the supported bind-flags for a specific format\n  356      */\n  357:     ResourceBindFlags getFormatBindFlags(std::shared_ptr<Device> device, ResourceFormat format);\n  358  \n  359      inline const std::string& to_string(ResourceFormat format) {\n\n/home/max/dev/Falcor/src/Falcor/Core/API/GpuFence.h:\n   53          \\return A new object, or throws an exception if creation failed.\n   54      */\n   55:     static SharedPtr create(std::shared_ptr<Device> device);\n   56  \n   57      /** Get the internal API handle\n   ..\n   79      uint64_t gpuSignal(CommandQueueHandle pQueue);\n   80  private:\n   81:     GpuFence(std::shared_ptr<Device> device) : mCpuValue(0), mpDevice(device) {}\n   82      uint64_t mCpuValue;\n   83  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/GpuMemoryHeap.cpp:\n   36      }\n   37  \n   38:     GpuMemoryHeap::GpuMemoryHeap(std::shared_ptr<Device> device, Type type, size_t pageSize, const GpuFence::SharedPtr& pFence)\n   39          : mType(type)\n   40          , mPageSize(pageSize)\n   41          , mpFence(pFence)\n   42:         , mpDevice(device)\n   43      {\n   44          allocateNewPage();\n   45      }\n   46  \n   47:     GpuMemoryHeap::SharedPtr GpuMemoryHeap::create(std::shared_ptr<Device> device, Type type, size_t pageSize, const GpuFence::SharedPtr& pFence) {\n   48:         return SharedPtr(new GpuMemoryHeap(device, type, pageSize, pFence));\n   49      }\n   50  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/GpuMemoryHeap.h:\n   74          \\return A new object, or throws an exception if creation failed.\n   75      */\n   76:     static SharedPtr create(std::shared_ptr<Device> device, Type type, size_t pageSize, const GpuFence::SharedPtr& pFence);\n   77  \n   78      Allocation allocate(size_t size, size_t alignment = 1);\n   ..\n   82  \n   83  private:\n   84:     GpuMemoryHeap(std::shared_ptr<Device> device, Type type, size_t pageSize, const GpuFence::SharedPtr& pFence);\n   85  \n   86      struct PageData : public BaseData {\n\n/home/max/dev/Falcor/src/Falcor/Core/API/GpuTimer.cpp:\n   40  std::weak_ptr<QueryHeap> GpuTimer::spHeap;\n   41  \n   42: GpuTimer::SharedPtr GpuTimer::create(std::shared_ptr<Device> device) {\n   43:     return SharedPtr(new GpuTimer(device));\n   44  }\n   45  \n   46: GpuTimer::GpuTimer(std::shared_ptr<Device> device): mpDevice(device) {\n   47:     assert(device);\n   48  #ifdef FALCOR_D3D12\n   49:     mpResolveBuffer = Buffer::create(device, sizeof(uint64_t) * 2, Buffer::BindFlags::None, Buffer::CpuAccess::Read, nullptr);\n   50  #endif\n   51      // Create timestamp query heap upon first use.\n   52      // We're allocating pairs of adjacent queries, so need our own heap to meet this requirement.\n   53      if (spHeap.expired()) {\n   54:         spHeap = device->createQueryHeap(QueryHeap::Type::Timestamp, 16 * 1024);\n   55      }\n   56      auto pHeap = spHeap.lock();\n   ..\n   62      }\n   63      assert(mEnd == (mStart + 1));\n   64:     mpLowLevelData = device->getRenderContext()->getLowLevelData();\n   65  }\n   66  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/GpuTimer.h:\n   49          \\return A new object, or throws an exception if creation failed.\n   50      */\n   51:     static SharedPtr create(std::shared_ptr<Device> device);\n   52  \n   53      /** Destroy a new object\n   ..\n   71  \n   72   private:\n   73:     GpuTimer(std::shared_ptr<Device> device);\n   74  \n   75      enum Status {\n\n/home/max/dev/Falcor/src/Falcor/Core/API/GraphicsStateObject.cpp:\n   70  }\n   71  \n   72: GraphicsStateObject::GraphicsStateObject(std::shared_ptr<Device> device, const Desc& desc) : mpDevice(device), mDesc(desc) {\n   73      if (spDefaultBlendState == nullptr) {\n   74          // Create default objects\n   75:         spDefaultBlendState = BlendState::create(BlendState::Desc(device));\n   76          spDefaultDepthStencilState = DepthStencilState::create(DepthStencilState::Desc());\n   77          spDefaultRasterizerState = RasterizerState::create(RasterizerState::Desc());\n   ..\n   86  }\n   87  \n   88: GraphicsStateObject::SharedPtr GraphicsStateObject::create(std::shared_ptr<Device> device, const Desc& desc) {\n   89:     return SharedPtr(new GraphicsStateObject(device, desc));\n   90  }\n   91  \n   92: GraphicsStateObject::Desc::Desc (std::shared_ptr<Device> device): mFboDesc(device) {\n   93  \n   94  }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/GraphicsStateObject.h:\n   91          friend class GraphicsState;\n   92  \n   93:         Desc(std::shared_ptr<Device> device);\n   94  \n   95          Fbo::Desc mFboDesc;\n   ..\n  121          \\return New object, or throws an exception if creation failed.\n  122      */\n  123:     static SharedPtr create(std::shared_ptr<Device> device, const Desc& desc);\n  124  \n  125      const ApiHandle& getApiHandle() { return mApiHandle; }\n  ...\n  128  \n  129   private:\n  130:     GraphicsStateObject(std::shared_ptr<Device> device, const Desc& desc);\n  131      void apiInit();\n  132  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/LowLevelContextData.h:\n   58          \\return A new object, or throws an expception if creation failed.\n   59      */\n   60:     static SharedPtr create(std::shared_ptr<Device> device, CommandQueueType type, CommandQueueHandle queue);\n   61  \n   62      void flush();\n   ..\n   74  \n   75   protected:\n   76:     LowLevelContextData(std::shared_ptr<Device> device, CommandQueueType type, CommandQueueHandle queue);\n   77  \n   78      LowLevelContextApiData* mpApiData = nullptr;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/QueryHeap.h:\n   57          \\return New object, or throws an exception if creation failed.\n   58      */\n   59:     static SharedPtr create(std::shared_ptr<Device> device, Type type, uint32_t count) { return SharedPtr(new QueryHeap(device, type, count)); }\n   60  \n   61      const ApiHandle& getApiHandle() const { return mApiHandle; }\n   ..\n   85  \n   86   private:\n   87:     QueryHeap(std::shared_ptr<Device> device, Type type, uint32_t count);\n   88      ApiHandle mApiHandle;\n   89      uint32_t mCount = 0;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/RenderContext.cpp:\n   35  namespace Falcor {\n   36  \n   37:     RenderContext::SharedPtr RenderContext::create(std::shared_ptr<Device> device, CommandQueueHandle queue) {\n   38:         return SharedPtr(new RenderContext(device, queue));\n   39      }\n   40  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/RenderContext.h:\n   76          \\return A new object, or throws an exception if creation failed.\n   77      */\n   78:     static SharedPtr create(std::shared_ptr<Device> device, CommandQueueHandle queue);\n   79  \n   80      /** Clear an FBO.\n   ..\n  194  \n  195  private:\n  196:     RenderContext(std::shared_ptr<Device> device, CommandQueueHandle queue);\n  197      bool applyGraphicsVars(GraphicsVars* pVars, RootSignature* pRootSignature);\n  198      bool prepareForDraw(GraphicsState* pState, GraphicsVars* pVars);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Resource.h:\n   99      virtual ~Resource() = 0;\n  100  \n  101:     std::shared_ptr<Device> device() { return mpDevice; }\n  102:     std::shared_ptr<Device> device() const { return mpDevice; }\n  103  \n  104      /** Get the bind flags\n  ...\n  177      friend class CopyContext;\n  178  \n  179:     Resource(std::shared_ptr<Device> device, Type type, BindFlags bindFlags, uint64_t size) : mpDevice(device), mType(type), mBindFlags(bindFlags), mSize(size) {}\n  180  \n  181      Type mType;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/ResourceViews.cpp:\n   38  static NullResourceViews gNullTypedBufferViews;\n   39  \n   40: Buffer::SharedPtr getEmptyBuffer(Device::SharedPtr device);\n   41: Buffer::SharedPtr getEmptyTypedBuffer(Device::SharedPtr device);\n   42: Buffer::SharedPtr createZeroBuffer(Device::SharedPtr device);\n   43: Buffer::SharedPtr createZeroTypedBuffer(Device::SharedPtr device);\n   44  \n   45: Texture::SharedPtr getEmptyTexture(Device::SharedPtr device);\n   46: Texture::SharedPtr createBlackTexture(Device::SharedPtr device);\n   47  \n   48: void createNullViews(Device::SharedPtr device) {\n   49:     gNullViews.srv = ShaderResourceView::create(getEmptyTexture(device), 0, 1, 0, 1);\n   50:     gNullViews.dsv = DepthStencilView::create(getEmptyTexture(device), 0, 0, 1);\n   51:     gNullViews.uav = UnorderedAccessView::create(getEmptyTexture(device), 0, 0, 1);\n   52:     gNullViews.rtv = RenderTargetView::create(getEmptyTexture(device), 0, 0, 1);\n   53      gNullViews.cbv = ConstantBufferView::create(Buffer::SharedPtr());\n   54  }\n   55  \n   56: void createNullBufferViews(Device::SharedPtr device) {\n   57:     gNullBufferViews.srv = ShaderResourceView::create(getEmptyBuffer(device), 0, 0);\n   58:     gNullBufferViews.uav = UnorderedAccessView::create(getEmptyBuffer(device), 0, 0);\n   59  }\n   60  \n   61: void createNullTypedBufferViews(Device::SharedPtr device) {\n   62:     gNullTypedBufferViews.srv = ShaderResourceView::create(getEmptyTypedBuffer(device), 0, 0);\n   63:     gNullTypedBufferViews.uav = UnorderedAccessView::create(getEmptyTypedBuffer(device), 0, 0);\n   64  }\n   65  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/RootSignature.cpp:\n   63  }\n   64  \n   65: RootSignature::RootSignature(std::shared_ptr<Device> device, const Desc& desc): mDesc(desc), mpDevice(device) {\n   66      sObjCount++;\n   67      apiInit();\n   ..\n   76  }\n   77  \n   78: RootSignature::SharedPtr RootSignature::getEmpty(std::shared_ptr<Device> device) {\n   79      if (spEmptySig) return spEmptySig;\n   80:     return create(device, Desc());\n   81  }\n   82  \n   83: RootSignature::SharedPtr RootSignature::create(std::shared_ptr<Device> device, const Desc& desc) {\n   84      bool empty = desc.mSets.empty() && desc.mRootDescriptors.empty() && desc.mRootConstants.empty();\n   85      if (empty && spEmptySig) {\n   ..\n   87      }\n   88  \n   89:     SharedPtr pSig = SharedPtr(new RootSignature(device, desc));\n   90      if (empty) spEmptySig = pSig;\n   91  \n   ..\n  172  }\n  173  \n  174: RootSignature::SharedPtr RootSignature::create(std::shared_ptr<Device> device, const ProgramReflection* pReflector) {\n  175      assert(pReflector);\n  176      RootSignature::Desc d;\n  177      addParamBlockSets(pReflector->getDefaultParameterBlock().get(), d);\n  178      addRootDescriptors(pReflector->getDefaultParameterBlock().get(), d);\n  179:     return RootSignature::create(device, d);\n  180  }\n  181  \n  182: RootSignature::SharedPtr RootSignature::createLocal(std::shared_ptr<Device> device, const EntryPointBaseReflection* pReflector) {\n  183      assert(pReflector);\n  184      RootSignature::Desc d;\n  ...\n  193  #endif\n  194  \n  195:     return RootSignature::create(device, d);\n  196  }\n  197  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/RootSignature.h:\n  112          \\return Empty root signtuare, or throws an exception on error.\n  113      */\n  114:     static SharedPtr getEmpty(std::shared_ptr<Device> device);\n  115  \n  116      /** Create a root signature.\n  ...\n  118          \\return New object, or throws an exception if creation failed.\n  119      */\n  120:     static SharedPtr create(std::shared_ptr<Device> device, const Desc& desc);\n  121  \n  122      /** Create a root signature from program reflection.\n  ...\n  124          \\return New object, or throws an exception if creation failed.\n  125      */\n  126:     static SharedPtr create(std::shared_ptr<Device> device, const ProgramReflection* pReflection);\n  127  \n  128      /** Create a local root signature for use with DXR.\n  ...\n  130          \\return New object, or throws an exception if creation failed.\n  131      */\n  132:     static SharedPtr createLocal(std::shared_ptr<Device> device, const EntryPointGroupReflection* pReflector);\n  133  \n  134      const ApiHandle& getApiHandle() const { return mApiHandle; }\n  ...\n  150  \n  151   protected:\n  152:     RootSignature(std::shared_ptr<Device> device, const Desc& desc);\n  153      void apiInit();\n  154  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Sampler.cpp:\n   37  SamplerData gSamplerData;\n   38  \n   39: Sampler::Sampler(std::shared_ptr<Device> device, const Desc& desc) : mDesc(desc), mpDevice(device) {\n   40      gSamplerData.objectCount++;\n   41  }\n   ..\n   82  }\n   83  \n   84: Sampler::SharedPtr Sampler::getDefault(std::shared_ptr<Device> device) {\n   85      if (gSamplerData.pDefaultSampler == nullptr) {\n   86:         gSamplerData.pDefaultSampler = create(device, Desc());\n   87      }\n   88      return gSamplerData.pDefaultSampler;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Sampler.h:\n  129          \\return A new object, or throws an exception if creation failed.\n  130      */\n  131:     static SharedPtr create(std::shared_ptr<Device> device, const Desc& desc);\n  132  \n  133      /** Get the API handle\n  ...\n  189      /** Get an object that represents a default sampler\n  190      */\n  191:     static Sampler::SharedPtr getDefault(std::shared_ptr<Device> device);\n  192  \n  193  private:\n  194:     Sampler(std::shared_ptr<Device> device, const Desc& desc);\n  195      Desc mDesc;\n  196      ApiHandle mApiHandle = {};\n  197:     static uint32_t getApiMaxAnisotropy(std::shared_ptr<Device> device);\n  198  \n  199      std::shared_ptr<Device> mpDevice; \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Shader.h:\n  187          \\return If success, a new shader object, otherwise nullptr\n  188      */\n  189:     static SharedPtr create(std::shared_ptr<Device> device, const Blob& shaderBlob, ShaderType type, std::string const&  entryPointName, CompilerFlags flags, std::string& log) {\n  190:         SharedPtr pShader = SharedPtr(new Shader(device, type));\n  191          pShader->mEntryPointName = entryPointName;\n  192          return pShader->init(shaderBlob, entryPointName, flags, log) ? pShader : nullptr;\n  ...\n  214      // API handle depends on the shader Type, so it stored be stored as part of the private data\n  215      bool init(const Blob& shaderBlob, const std::string&  entryPointName, CompilerFlags flags, std::string& log);\n  216:     Shader(std::shared_ptr<Device> device, ShaderType Type);\n  217      ShaderType mType;\n  218      std::string mEntryPointName;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Texture.cpp:\n   37  \n   38  // namespace {\n   39: Texture::BindFlags updateBindFlags(Device::SharedPtr device, Texture::BindFlags flags, bool hasInitData, uint32_t mipLevels, ResourceFormat format, const std::string& texType) {\n   40      if ((mipLevels == Texture::kMaxPossible) && hasInitData) {\n   41          flags |= Texture::BindFlags::RenderTarget;\n   42      }\n   43  \n   44:     Texture::BindFlags supported = getFormatBindFlags(device, format);\n   45      supported |= ResourceBindFlags::Shared;\n   46      if ((flags & supported) != flags) {\n   ..\n   55  // }\n   56  \n   57: Texture::SharedPtr Texture::createFromApiHandle(std::shared_ptr<Device> device, ApiHandle handle, Type type, uint32_t width, uint32_t height, uint32_t depth, ResourceFormat format, uint32_t sampleCount, uint32_t arraySize, uint32_t mipLevels, State initState, BindFlags bindFlags) {\n   58      assert(handle);\n   59      switch (type) {\n   ..\n   78      }\n   79  \n   80:     Texture::SharedPtr pTexture = SharedPtr(new Texture(device, width, height, depth, arraySize, mipLevels, sampleCount, format, type, bindFlags));\n   81      pTexture->mApiHandle = handle;\n   82      pTexture->mState.global = initState;\n   ..\n   85  }\n   86  \n   87: Texture::SharedPtr Texture::create1D(std::shared_ptr<Device> device, uint32_t width, ResourceFormat format, uint32_t arraySize, uint32_t mipLevels, const void* pData, BindFlags bindFlags) {\n   88:     bindFlags = updateBindFlags(device, bindFlags, pData != nullptr, mipLevels, format, \"Texture1D\");\n   89:     Texture::SharedPtr pTexture = SharedPtr(new Texture(device, width, 1, 1, arraySize, mipLevels, 1, format, Type::Texture1D, bindFlags));\n   90      pTexture->apiInit(pData, (mipLevels == kMaxPossible));\n   91      return pTexture;\n   92  }\n   93  \n   94: Texture::SharedPtr Texture::create2D(std::shared_ptr<Device> device, uint32_t width, uint32_t height, ResourceFormat format, uint32_t arraySize, uint32_t mipLevels, const void* pData, BindFlags bindFlags) {\n   95:     bindFlags = updateBindFlags(device, bindFlags, pData != nullptr, mipLevels, format, \"Texture2D\");\n   96:     Texture::SharedPtr pTexture = SharedPtr(new Texture(device, width, height, 1, arraySize, mipLevels, 1, format, Type::Texture2D, bindFlags));\n   97      pTexture->apiInit(pData, (mipLevels == kMaxPossible));\n   98      return pTexture;\n   99  }\n  100  \n  101: Texture::SharedPtr Texture::create3D(std::shared_ptr<Device> device, uint32_t width, uint32_t height, uint32_t depth, ResourceFormat format, uint32_t mipLevels, const void* pData, BindFlags bindFlags, bool isSparse) {\n  102:     bindFlags = updateBindFlags(device, bindFlags, pData != nullptr, mipLevels, format, \"Texture3D\");\n  103:     Texture::SharedPtr pTexture = SharedPtr(new Texture(device, width, height, depth, 1, mipLevels, 1, format, Type::Texture3D, bindFlags));\n  104      pTexture->apiInit(pData, (mipLevels == kMaxPossible));\n  105      return pTexture;\n  106  }\n  107  \n  108: Texture::SharedPtr Texture::createCube(std::shared_ptr<Device> device, uint32_t width, uint32_t height, ResourceFormat format, uint32_t arraySize, uint32_t mipLevels, const void* pData, BindFlags bindFlags) {\n  109:     bindFlags = updateBindFlags(device, bindFlags, pData != nullptr, mipLevels, format, \"TextureCube\");\n  110:     Texture::SharedPtr pTexture = SharedPtr(new Texture(device, width, height, 1, arraySize, mipLevels, 1, format, Type::TextureCube, bindFlags));\n  111      pTexture->apiInit(pData, (mipLevels == kMaxPossible));\n  112      return pTexture;\n  113  }\n  114  \n  115: Texture::SharedPtr Texture::create2DMS(std::shared_ptr<Device> device, uint32_t width, uint32_t height, ResourceFormat format, uint32_t sampleCount, uint32_t arraySize, BindFlags bindFlags) {\n  116:     bindFlags = updateBindFlags(device, bindFlags, false, 1, format, \"Texture2DMultisample\");\n  117:     Texture::SharedPtr pTexture = SharedPtr(new Texture(device, width, height, 1, arraySize, 1, sampleCount, format, Type::Texture2DMultisample, bindFlags));\n  118      pTexture->apiInit(nullptr, false);\n  119      return pTexture;\n  120  }\n  121  \n  122: Texture::Texture(std::shared_ptr<Device> device, uint32_t width, uint32_t height, uint32_t depth, uint32_t arraySize, uint32_t mipLevels, uint32_t sampleCount, ResourceFormat format, Type type, BindFlags bindFlags)\n  123:     : Resource(device, type, bindFlags, 0), mWidth(width), mHeight(height), mDepth(depth), mMipLevels(mipLevels), mSampleCount(sampleCount), mArraySize(arraySize), mFormat(format) {\n  124      assert(width > 0 && height > 0 && depth > 0);\n  125      assert(arraySize > 0 && mipLevels > 0 && sampleCount > 0);\n  ...\n  323  \n  324      auto data = [](Texture* pTexture, uint32_t subresource) {\n  325:         return pTexture->device()->getRenderContext()->readTextureSubresource(pTexture, subresource);\n  326      };\n  327      c.func_(\"data\", data, \"subresource\"_a);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Texture.h:\n  111          \\return A pointer to a new texture, or throws an exception if creation failed.\n  112      */\n  113:     static SharedPtr createFromApiHandle(std::shared_ptr<Device> device, ApiHandle handle, Type type, uint32_t width, uint32_t height, uint32_t depth, ResourceFormat format, uint32_t sampleCount, uint32_t arraySize, uint32_t mipLevels, State initState, BindFlags bindFlags);\n  114  \n  115      /** Create a 1D texture.\n  ...\n  122          \\return A pointer to a new texture, or throws an exception if creation failed.\n  123      */\n  124:     static SharedPtr create1D(std::shared_ptr<Device> device, uint32_t width, ResourceFormat format, uint32_t arraySize = 1, uint32_t mipLevels = kMaxPossible, const void* pInitData = nullptr, BindFlags bindFlags = BindFlags::ShaderResource);\n  125  \n  126      /** Create a 2D texture.\n  ...\n  134          \\return A pointer to a new texture, or throws an exception if creation failed.\n  135      */\n  136:     static SharedPtr create2D(std::shared_ptr<Device> device, uint32_t width, uint32_t height, ResourceFormat format, uint32_t arraySize = 1, uint32_t mipLevels = kMaxPossible, const void* pInitData = nullptr, BindFlags bindFlags = BindFlags::ShaderResource);\n  137  \n  138      /** Create a 3D texture.\n  ...\n  147          \\return A pointer to a new texture, or throws an exception if creation failed.\n  148      */\n  149:     static SharedPtr create3D(std::shared_ptr<Device> device, uint32_t width, uint32_t height, uint32_t depth, ResourceFormat format, uint32_t mipLevels = kMaxPossible, const void* pInitData = nullptr, BindFlags bindFlags = BindFlags::ShaderResource, bool isSparse = false);\n  150  \n  151      /** Create a cube texture.\n  ...\n  159          \\return A pointer to a new texture, or throws an exception if creation failed.\n  160      */\n  161:     static SharedPtr createCube(std::shared_ptr<Device> device, uint32_t width, uint32_t height, ResourceFormat format, uint32_t arraySize = 1, uint32_t mipLevels = kMaxPossible, const void* pInitData = nullptr, BindFlags bindFlags = BindFlags::ShaderResource);\n  162  \n  163      /** Create a multi-sampled 2D texture.\n  ...\n  170          \\return A pointer to a new texture, or throws an exception if creation failed.\n  171      */\n  172:     static SharedPtr create2DMS(std::shared_ptr<Device> device, uint32_t width, uint32_t height, ResourceFormat format, uint32_t sampleCount, uint32_t arraySize = 1, BindFlags bindFlags = BindFlags::ShaderResource);\n  173  \n  174      /** Create a new texture object from a file.\n  ...\n  179          \\return A new texture, or nullptr if the texture failed to load.\n  180      */\n  181:     static SharedPtr createFromFile(std::shared_ptr<Device> device, const std::string& filename, bool generateMipLevels, bool loadAsSrgb, BindFlags bindFlags = BindFlags::ShaderResource);\n  182  \n  183      /** Get a shader-resource view for the entire resource\n  ...\n  244  \n  245   protected:\n  246:     Texture(std::shared_ptr<Device> device, uint32_t width, uint32_t height, uint32_t depth, uint32_t arraySize, uint32_t mipLevels, uint32_t sampleCount, ResourceFormat format, Type Type, BindFlags bindFlags);\n  247      void apiInit(const void* pData, bool autoGenMips);\n  248      void uploadInitData(const void* pData, bool autoGenMips);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/TextureLoader.cpp:\n  529  }\n  530  \n  531: Texture::SharedPtr createTextureFromDx10Dds(std::shared_ptr<Device> device, DdsData& ddsData, const std::string& filename, ResourceFormat format, uint32_t mipLevels, Texture::BindFlags bindFlags) {\n  532      format = convertBgrxFormatToBgra(ddsData, format);\n  533  \n  ...\n  537      switch(ddsData.dx10Header.resourceDimension) {\n  538          case DXResourceDimension::RESOURCE_DIMENSION_TEXTURE1D:\n  539:             return Texture::create1D(device, ddsData.header.width, format, arraySize, mipLevels, ddsData.data.data(), bindFlags);\n  540          case DXResourceDimension::RESOURCE_DIMENSION_TEXTURE2D:\n  541              if(ddsData.dx10Header.miscFlag & DdsHeaderDX10::kCubeMapMask) {\n  542                  flipData(ddsData, format, ddsData.header.width, ddsData.header.height, 6 * arraySize, mipLevels == Texture::kMaxPossible ? 1 : mipLevels, true);\n  543:                 return Texture::createCube(device, ddsData.header.width, ddsData.header.height, format, arraySize, mipLevels, ddsData.data.data(), bindFlags);\n  544              } else {\n  545                  flipData(ddsData, format, ddsData.header.width, ddsData.header.height, arraySize, mipLevels == Texture::kMaxPossible ? 1 : mipLevels);\n  546:                 return Texture::create2D(device, ddsData.header.width, ddsData.header.height, format, arraySize, mipLevels, ddsData.data.data(), bindFlags);\n  547              }\n  548          case DXResourceDimension::RESOURCE_DIMENSION_TEXTURE3D:\n  549              flipData(ddsData, format, ddsData.header.width, ddsData.header.height, ddsData.header.depth, mipLevels == Texture::kMaxPossible ? 1 : mipLevels);\n  550:             return Texture::create3D(device, ddsData.header.width, ddsData.header.height, ddsData.header.depth, format, mipLevels, ddsData.data.data(), bindFlags);\n  551          case DXResourceDimension::RESOURCE_DIMENSION_BUFFER:\n  552          case DXResourceDimension::RESOURCE_DIMENSION_UNKNOWN:\n  ...\n  559  }\n  560  \n  561: Texture::SharedPtr createTextureFromLegacyDds(std::shared_ptr<Device> device, DdsData& ddsData, const std::string& filename, ResourceFormat format, uint32_t mipLevels, Texture::BindFlags bindFlags) {\n  562      format = convertBgrxFormatToBgra(ddsData, format);\n  563  \n  ...\n  565      if (ddsData.header.flags & DdsHeader::kDepthMask) {\n  566          flipData(ddsData, format, ddsData.header.width, ddsData.header.height, ddsData.header.depth, mipLevels == Texture::kMaxPossible ? 1 : mipLevels);\n  567:         return Texture::create3D(device, ddsData.header.width, ddsData.header.height, ddsData.header.depth, format, mipLevels, ddsData.data.data(), bindFlags);\n  568      } else if (ddsData.header.caps[1] & DdsHeader::kCaps2CubeMapMask) {\n  569          // Load the cubemap texture\n  570:         return Texture::createCube(device, ddsData.header.width, ddsData.header.height, format, 1, mipLevels, ddsData.data.data(), bindFlags);\n  571      } else {\n  572          // This is a 2D Texture\n  573          flipData(ddsData, format, ddsData.header.width, ddsData.header.height, 1, mipLevels == Texture::kMaxPossible ? 1 : mipLevels);\n  574:         return Texture::create2D(device, ddsData.header.width, ddsData.header.height, format, 1, mipLevels, ddsData.data.data(), bindFlags);\n  575      }\n  576  \n  ...\n  579  }\n  580  \n  581: Texture::SharedPtr createTextureFromDDSFile(std::shared_ptr<Device> device, const std::string filename, bool generateMips, bool loadAsSrgb, Texture::BindFlags bindFlags) {\n  582      DdsData ddsData;\n  583      if (!loadDDSDataFromFile(filename, ddsData)) return nullptr;\n  ...\n  601  \n  602      if (ddsData.hasDX10Header) {\n  603:         return createTextureFromDx10Dds(device, ddsData, filename, format, mipLevels, bindFlags);\n  604      } else {\n  605:         return createTextureFromLegacyDds(device, ddsData, filename, format, mipLevels, bindFlags);\n  606      }\n  607  }\n  608  \n  609: Texture::SharedPtr Texture::createFromFile(std::shared_ptr<Device> device, const std::string& filename, bool generateMipLevels, bool loadAsSrgb, Texture::BindFlags bindFlags) {\n  610      std::string fullpath;\n  611      if (findFileInDataDirectories(filename, fullpath) == false) {\n  ...\n  616      Texture::SharedPtr pTex;\n  617      if (hasSuffix(filename, \".dds\")) {\n  618:         pTex = createTextureFromDDSFile(device, fullpath, generateMipLevels, loadAsSrgb, bindFlags);\n  619      } else {\n  620:         Bitmap::UniqueConstPtr pBitmap = Bitmap::createFromFile(device, fullpath, kTopDown);\n  621          if (pBitmap) {\n  622              ResourceFormat texFormat = pBitmap->getFormat();\n  ...\n  625              }\n  626  \n  627:             pTex = Texture::create2D(device, pBitmap->getWidth(), pBitmap->getHeight(), texFormat, 1, generateMipLevels ? Texture::kMaxPossible : 1, pBitmap->getData(), bindFlags);\n  628          }\n  629      }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/FalcorVK.h:\n  128  class Device;\n  129  \n  130: uint32_t getMaxViewportCount(std::shared_ptr<Device> device);\n  131  \n  132  }  // namespace Falcor\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKBuffer.cpp:\n   36  namespace Falcor {\n   37      \n   38: VkDeviceMemory allocateDeviceMemory(Device::SharedPtr device, GpuMemoryHeap::Type memType, uint32_t memoryTypeBits, size_t size) {\n   39      VkMemoryAllocateInfo allocInfo = {};\n   40      allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;\n   41      allocInfo.allocationSize = size;\n   42:     allocInfo.memoryTypeIndex = device->getVkMemoryType(memType, memoryTypeBits);\n   43  \n   44:     VkDeviceMemory deviceMem;\n   45:     vk_call(vkAllocateMemory(device->getApiHandle(), &allocInfo, nullptr, &deviceMem));\n   46:     return deviceMem;\n   47  }\n   48  \n   49: void* mapBufferApi(Device::SharedPtr device, const Buffer::ApiHandle& apiHandle, size_t size) {\n   50      void* pData;\n   51:     vk_call(vkMapMemory(apiHandle.device()->getApiHandle(), apiHandle, 0, size, 0, &pData));\n   52      return pData;\n   53  }\n   ..\n   82  size_t getBufferDataAlignment(const Buffer* pBuffer) {\n   83      VkMemoryRequirements reqs;\n   84:     vkGetBufferMemoryRequirements(pBuffer->device()->getApiHandle(), pBuffer->getApiHandle(), &reqs);\n   85      return reqs.alignment;\n   86  }\n   87  \n   88: Buffer::ApiHandle createBuffer(Device::SharedPtr device, size_t size, Buffer::BindFlags bindFlags, GpuMemoryHeap::Type memType) {\n   89      VkBufferCreateInfo bufferInfo = {};\n   90      bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;\n   ..\n   97      \n   98      VkBuffer buffer;\n   99:     vk_call(vkCreateBuffer(device->getApiHandle(), &bufferInfo, nullptr, &buffer));\n  100  \n  101      // Get the required buffer size\n  102      VkMemoryRequirements reqs;\n  103:     vkGetBufferMemoryRequirements(device->getApiHandle(), buffer, &reqs);\n  104  \n  105:     VkDeviceMemory mem = allocateDeviceMemory(device, memType, reqs.memoryTypeBits, reqs.size);\n  106:     vk_call(vkBindBufferMemory(device->getApiHandle(), buffer, mem, 0));\n  107:     Buffer::ApiHandle apiHandle = Buffer::ApiHandle::create(device, buffer, mem);\n  108  \n  109      return apiHandle;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKComputeContext.cpp:\n   39  namespace Falcor {\n   40  \n   41:     ComputeContext::ComputeContext(std::shared_ptr<Device> device, LowLevelContextData::CommandQueueType type, CommandQueueHandle queue) : CopyContext(device, type, queue) {\n   42          assert(queue);\n   43      }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKCopyContext.cpp:\n  166      }\n  167  \n  168:     static void initTexAccessParams(std::shared_ptr<Device> device, const Texture* pTexture, uint32_t subresourceIndex, VkBufferImageCopy& vkCopy, Buffer::SharedPtr& pStaging, const void* pSrcData, const uint3& offset, const uint3& size, size_t& dataSize)\n  169      {\n  170          assert(isDepthStencilFormat(pTexture->getFormat()) == false); // #VKTODO Nothing complicated here, just that Vulkan doesn't support writing to both depth and stencil, which may be confusing to the user\n  ...\n  186  \n  187          // Upload the data to a staging buffer\n  188:         pStaging = Buffer::create(device, dataSize, Buffer::BindFlags::None, pSrcData ? Buffer::CpuAccess::Write : Buffer::CpuAccess::Read, pSrcData);\n  189          vkCopy.bufferOffset = pStaging->getGpuAddressOffset();\n  190      }\n  ...\n  195          Buffer::SharedPtr pStaging;\n  196          size_t dataSize;\n  197:         initTexAccessParams(pCtx->device(), pTexture, subresourceIndex, vkCopy, pStaging, pData, offset, size, dataSize);\n  198  \n  199          // Execute the copy\n  ...\n  226  \n  227          VkBufferImageCopy vkCopy;\n  228:         initTexAccessParams(pCtx->device(), pTexture, subresourceIndex, vkCopy, pThis->mpBuffer, nullptr, {}, uint3(-1, -1, -1), pThis->mDataSize);\n  229  \n  230          // Execute the copy\n  ...\n  234  \n  235          // Create a fence and signal\n  236:         pThis->mpFence = GpuFence::create(pCtx->device());\n  237          pCtx->flush(false);\n  238          pThis->mpFence->gpuSignal(pCtx->getLowLevelData()->getCommandQueue());\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKDescriptorData.h:\n   38  \n   39  struct DescriptorSetApiData {\n   40:     DescriptorSetApiData(Device::SharedPtr device, VkDescriptorSetLayout l, VkDescriptorPool p, VkDescriptorSet s) : layout(l), set(s), pool(p), mpDevice(device) {}\n   41      \n   42      VkDescriptorSetLayout layout;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKDescriptorSet.cpp:\n   47          allocInfo.descriptorSetCount = 1;\n   48          allocInfo.pSetLayouts = &layout;\n   49:         vk_call(vkAllocateDescriptorSets(mpPool->device()->getApiHandle(), &allocInfo, &mApiHandle));\n   50:         mpApiData = std::make_shared<DescriptorSetApiData>(mpPool->device(), layout, mpPool->getApiHandle(0), mApiHandle);\n   51      }\n   52  \n   ..\n   62  \n   63      template<bool isUav, typename ViewType>\n   64:     static void setSrvUavCommon(Device::SharedPtr device, VkDescriptorSet set, uint32_t bindIndex, uint32_t arrayIndex, const ViewType* pView, DescriptorPool::Type type) {\n   65          VkWriteDescriptorSet write = {};\n   66          VkDescriptorImageInfo image;\n   ..\n   95          write.descriptorCount = 1;\n   96  \n   97:         vkUpdateDescriptorSets(device->getApiHandle(), 1, &write, 0, nullptr);\n   98      }\n   99  \n  100      void DescriptorSet::setSrv(uint32_t rangeIndex, uint32_t descIndex, const ShaderResourceView* pSrv) {\n  101:         setSrvUavCommon<false>(mpPool->device(), mApiHandle, mLayout.getRange(rangeIndex).baseRegIndex, descIndex, pSrv, mLayout.getRange(rangeIndex).type);\n  102      }\n  103  \n  104      void DescriptorSet::setUav(uint32_t rangeIndex, uint32_t descIndex, const UnorderedAccessView* pUav) {\n  105:         setSrvUavCommon<true>(mpPool->device(), mApiHandle, mLayout.getRange(rangeIndex).baseRegIndex, descIndex, pUav, mLayout.getRange(rangeIndex).type);\n  106      }\n  107  \n  ...\n  121          write.pImageInfo = &info;\n  122  \n  123:         vkUpdateDescriptorSets(mpPool->device()->getApiHandle(), 1, &write, 0, nullptr);\n  124      }\n  125  \n  ...\n  141          write.descriptorCount = 1;\n  142          write.pBufferInfo = &info;\n  143:         vkUpdateDescriptorSets(mpPool->device()->getApiHandle(), 1, &write, 0, nullptr);\n  144      }\n  145  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKDevice.cpp:\n   61  #endif\n   62  \n   63: uint32_t getMaxViewportCount(std::shared_ptr<Device> device) {\n   64:     assert(device);\n   65:     return device->getPhysicalDeviceLimits().maxViewports;\n   66  }\n   67  \n   ..\n   71      uint32_t falcorToVulkanQueueType[Device::kQueueTypeCount];\n   72      uint32_t vkMemoryTypeBits[(uint32_t)Device::MemoryType::Count];\n   73:     VkPhysicalDeviceLimits deviceLimits;\n   74:     std::vector<VkExtensionProperties> deviceExtensions;\n   75  \n   76      struct {\n   ..\n   96  }\n   97  \n   98: static uint32_t getCurrentBackBufferIndex(VkDevice device, uint32_t backBufferCount, DeviceApiData* pApiData) {\n   99      VkFence fence = pApiData->presentFences.f[pApiData->presentFences.cur];\n  100:     vk_call(vkWaitForFences(device, 1, &fence, false, -1));\n  101  \n  102      pApiData->presentFences.cur = (pApiData->presentFences.cur + 1) % backBufferCount;\n  103      fence = pApiData->presentFences.f[pApiData->presentFences.cur];\n  104:     vkResetFences(device, 1, &fence);\n  105      uint32_t newIndex;\n  106:     vk_call(vkAcquireNextImageKHR(device, pApiData->swapchain, std::numeric_limits<uint64_t>::max(), nullptr, fence, &newIndex));\n  107      return newIndex;\n  108  }\n  ...\n  280  void Device::toggleFullScreen(bool fullscreen){}\n  281  \n  282: /** Select best physical device based on memory\n  283  */\n  284: VkPhysicalDevice selectPhysicalDevice(const std::vector<VkPhysicalDevice>& devices) {\n  285:     LOG_DBG(\"Selecting physical Vulkan device...\");\n  286      VkPhysicalDevice bestDevice = VK_NULL_HANDLE;\n  287      uint64_t bestMemory = 0;\n  288  \n  289:     for (const VkPhysicalDevice& device : devices) {\n  290          VkPhysicalDeviceMemoryProperties properties;\n  291:         vkGetPhysicalDeviceMemoryProperties(device, &properties);\n  292  \n  293:         // Get local memory size from device\n  294:         uint64_t deviceMemory = 0;\n  295          for (uint32_t i = 0; i < properties.memoryHeapCount; i++) {\n  296              if ((properties.memoryHeaps[i].flags & VK_MEMORY_HEAP_DEVICE_LOCAL_BIT) > 0) {\n  297:                 deviceMemory = properties.memoryHeaps[i].size;\n  298                  break;\n  299              }\n  ...\n  301  \n  302          // Save if best found so far\n  303:         if (bestDevice == VK_NULL_HANDLE || deviceMemory > bestMemory) {\n  304:             bestDevice = device;\n  305:             bestMemory = deviceMemory;\n  306          }\n  307      }\n  ...\n  310      vkGetPhysicalDeviceProperties(bestDevice, &pProperties);\n  311  \n  312:     LOG_DBG(\"Selected Vulkan physical device: %s\", pProperties.deviceName);\n  313      return bestDevice;\n  314  }\n  315  \n  316  VkPhysicalDevice initPhysicalDevice(VkInstance instance, DeviceApiData* pData, const Device::Desc& desc) {\n  317:     // Enumerate devices\n  318      uint32_t count = 0;\n  319      vkEnumeratePhysicalDevices(instance, &count, nullptr);\n  320      assert(count > 0);\n  321  \n  322:     std::vector<VkPhysicalDevice> devices(count);\n  323:     vkEnumeratePhysicalDevices(instance, &count, devices.data());\n  324  \n  325:     // Pick a device\n  326:     VkPhysicalDevice physicalDevice = selectPhysicalDevice(devices);\n  327      vkGetPhysicalDeviceProperties(physicalDevice, &pData->properties);\n  328:     pData->deviceLimits = pData->properties.limits;\n  329  \n  330:     // Check that the device/driver supports the requested API version\n  331      uint32_t vkApiVersion = VK_MAKE_VERSION(desc.apiMajorVersion, desc.apiMinorVersion, 0);\n  332      if (vkApiVersion != 0 && pData->properties.apiVersion < vkApiVersion) {\n  333          std::string reqVerStr = std::to_string(desc.apiMajorVersion) + \".\" + std::to_string(desc.apiMinorVersion);\n  334          std::string supportedStr = std::to_string(VK_VERSION_MAJOR(pData->properties.apiVersion)) + \".\" + std::to_string(VK_VERSION_MINOR(pData->properties.apiVersion));\n  335:         logError(\"Vulkan device does not support requested API version. Requested version: \" + reqVerStr + \", Highest supported: \" + supportedStr);\n  336          return nullptr;\n  337      }\n  ...\n  376          const uint32_t queueCount = desc.cmdQueues[type];\n  377          queuePriorities[type].resize(queueCount, 1.0f); // Setting all priority at max for now\n  378:         cmdQueues[type].resize(queueCount); // Save how many queues of each type there will be so we can retrieve them easier after device creation\n  379  \n  380          VkDeviceQueueCreateInfo info = {};\n  ...\n  403      uint32_t extensionCount = 0;\n  404      vkEnumerateDeviceExtensionProperties(physicalDevice, nullptr, &extensionCount, nullptr);\n  405:     pData->deviceExtensions.resize(extensionCount);\n  406:     vkEnumerateDeviceExtensionProperties(physicalDevice, nullptr, &extensionCount, pData->deviceExtensions.data());\n  407  \n  408:     for (const VkExtensionProperties& extension : pData->deviceExtensions) {\n  409          logInfo(\"Available Device Extension: \" + std::string(extension.extensionName) + \" - VK Spec Version: \" + std::to_string(extension.specVersion));\n  410      }\n  411  \n  412      std::vector<const char*> extensionNames = { \"VK_KHR_swapchain\" };\n  413:     assert(isExtensionSupported(extensionNames[0], pData->deviceExtensions));\n  414  \n  415      for (const auto& a : desc.requiredExtensions) {\n  416:         if (isExtensionSupported(a, pData->deviceExtensions)) {\n  417              extensionNames.push_back(a.c_str());\n  418          } else {\n  419:             logWarning(\"The device doesn't support the requested '\" + a + \"` extension\");\n  420          }\n  421      }\n  422  \n  423      // Logical Device\n  424:     VkDeviceCreateInfo deviceInfo = {};\n  425:     deviceInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;\n  426:     deviceInfo.queueCreateInfoCount = (uint32_t)queueInfos.size();\n  427:     deviceInfo.pQueueCreateInfos = queueInfos.data();\n  428:     deviceInfo.enabledExtensionCount = (uint32_t)extensionNames.size();\n  429:     deviceInfo.ppEnabledExtensionNames = extensionNames.data();\n  430:     deviceInfo.pEnabledFeatures = &requiredFeatures;\n  431  \n  432:     VkDevice device;\n  433:     if (VK_FAILED(vkCreateDevice(physicalDevice, &deviceInfo, nullptr, &device))) {\n  434:         logError(\"Could not create Vulkan logical device.\");\n  435          return nullptr;\n  436      }\n  ...\n  439      for (uint32_t type = 0; type < arraysize(pData->falcorToVulkanQueueType); type++) {\n  440          for (uint32_t i = 0; i < (uint32_t)cmdQueues[type].size(); i++) {\n  441:             vkGetDeviceQueue(device, pData->falcorToVulkanQueueType[type], i, &cmdQueues[type][i]);\n  442          }\n  443      }\n  444  \n  445:     return device;\n  446  }\n  447  \n  ...\n  592  \n  593  /**\n  594:  * Initialize swapchain enabled vulkan device\n  595   */\n  596  bool Device::apiInit() {\n  ...\n  607      if (!surface) return false;\n  608      \n  609:     VkDevice device = createLogicalDevice(physicalDevice, mpApiData, desc, mCmdQueues);\n  610:     if (!device) return false;\n  611      \n  612      if (initMemoryTypes(physicalDevice, mpApiData) == false) return false;\n  613  \n  614:     mApiHandle = DeviceHandle::create(SharedPtr(this), instance, physicalDevice, device, surface);\n  615      mGpuTimestampFrequency = getPhysicalDeviceLimits().timestampPeriod / (1000 * 1000);\n  616:     mPhysicalDeviceName = std::string(mpApiData->properties.deviceName);\n  617  \n  618      if(!headless) {\n  ...\n  625              VkFenceCreateInfo info = { VK_STRUCTURE_TYPE_FENCE_CREATE_INFO };\n  626              info.flags = VK_FENCE_CREATE_SIGNALED_BIT;\n  627:             vk_call(vkCreateFence(device, &info, nullptr, &f));\n  628          }\n  629      } else {\n  ...\n  656  bool Device::isExtensionSupported(const std::string& name) const\n  657  {\n  658:     //return Falcor::isExtensionSupported(name, mpApiData->deviceExtensions);\n  659      return true;\n  660  }\n  ...\n  672  \n  673  const VkPhysicalDeviceLimits& Device::getPhysicalDeviceLimits() const {\n  674:     return mpApiData->deviceLimits;\n  675  }\n  676  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKFbo.cpp:\n   36  namespace Falcor {\n   37  \n   38: Fbo::Fbo(std::shared_ptr<Device> device): mpDevice(device), mTempDesc(device) {\n   39:     mColorAttachments.resize(getMaxColorTargetCount(device));\n   40  }\n   41  \n   ..\n   49  }\n   50  \n   51: uint32_t Fbo::getMaxColorTargetCount(std::shared_ptr<Device> device) {\n   52:     int count =device->getPhysicalDeviceLimits().maxFragmentOutputAttachments;\n   53      return count;\n   54  }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKFormats.cpp:\n  112      };\n  113  \n  114:     ResourceBindFlags getFormatBindFlags(Device::SharedPtr device, ResourceFormat format) {\n  115          VkFormatProperties p;\n  116:         vkGetPhysicalDeviceFormatProperties(device->getApiHandle(), getVkFormat(format), &p);\n  117  \n  118          auto convertFlags = [](VkFormatFeatureFlags vk) -> ResourceBindFlags\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKGpuFence.cpp:\n   36  \n   37      // #VKTODO This entire class seems overly complicated. Need to make sure that there are no performance issues\n   38:     VkFence createFence(std::shared_ptr<Device> device) {\n   39          VkFenceCreateInfo info = {};\n   40          info.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;\n   41          VkFence fence;\n   42:         vkCreateFence(device->getApiHandle(), &info, nullptr, &fence);\n   43          return fence;\n   44      }\n   45  \n   46:     void destroyFence(std::shared_ptr<Device> device, VkFence fence) {\n   47:         vkDestroyFence(device->getApiHandle(), fence, nullptr);\n   48      }\n   49  \n   50:     void resetFence(std::shared_ptr<Device> device, VkFence fence) {\n   51:         vkResetFences(device->getApiHandle(), 1, &fence);\n   52      }\n   53  \n   54:     VkSemaphore createSemaphore(std::shared_ptr<Device> device) {\n   55          VkSemaphoreCreateInfo semaphoreInfo = {};\n   56          semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;\n   57          VkSemaphore sem;\n   58:         vkCreateSemaphore(device->getApiHandle(), &semaphoreInfo, nullptr, &sem);\n   59          return sem;\n   60      };\n   61  \n   62:     void destroySemaphore(std::shared_ptr<Device> device, VkSemaphore semaphore) {\n   63:         vkDestroySemaphore(device->getApiHandle(), semaphore, nullptr);\n   64      }\n   65  \n   66      struct FenceApiData {\n   67:         FenceApiData(std::shared_ptr<Device> device) { \n   68:             fenceQueue =  std::make_unique<SmartQueue<VkFence, createFence, destroyFence, resetFence>>(device);\n   69:             semaphoreQueue = std::make_unique<SmartQueue<VkSemaphore, createSemaphore, destroySemaphore, nullptr>>(device);\n   70          }\n   71  \n   ..\n   73          class SmartQueue {\n   74           public:\n   75:             SmartQueue(std::shared_ptr<Device> device) { mpDevice = device; }\n   76              ~SmartQueue() {\n   77                  popAllObjects();\n   ..\n  133      }\n  134  \n  135:     GpuFence::SharedPtr GpuFence::create(std::shared_ptr<Device> device) {\n  136:         SharedPtr pFence = SharedPtr(new GpuFence(device));\n  137:         pFence->mpApiData = new FenceApiData(device);\n  138          pFence->mCpuValue = 1;\n  139          return pFence;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VkGpuMemoryHeap.cpp:\n   33  namespace Falcor {\n   34  \n   35: Buffer::ApiHandle createBuffer(std::shared_ptr<Device> device, size_t size, Buffer::BindFlags bindFlags, GpuMemoryHeap::Type memType);\n   36  \n   37  void GpuMemoryHeap::initBasePageData(BaseData& data, size_t size) {\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKLowLevelContextData.cpp:\n   39      };\n   40  \n   41:     VkCommandBuffer createCommandBuffer(std::shared_ptr<Device> device, void* pUserData)\n   42      {\n   43          LowLevelContextData* pThis = (LowLevelContextData*)pUserData;\n   ..\n   48          cmdBufAllocateInfo.commandBufferCount = 1;\n   49          VkCommandBuffer cmdBuf;\n   50:         vk_call(vkAllocateCommandBuffers(device->getApiHandle(), &cmdBufAllocateInfo, &cmdBuf));\n   51          return cmdBuf;\n   52      }\n   ..\n   63      }\n   64  \n   65:     LowLevelContextData::LowLevelContextData(std::shared_ptr<Device> device, CommandQueueType type, CommandQueueHandle queue): mType(type), mpQueue(queue), mpDevice(device)\n   66      {\n   67  \n   68      }\n   69  \n   70:     LowLevelContextData::SharedPtr LowLevelContextData::create(std::shared_ptr<Device> device, LowLevelContextData::CommandQueueType type, CommandQueueHandle queue) {\n   71:         SharedPtr pThis = SharedPtr(new LowLevelContextData(device, type, queue));\n   72          pThis->mType = type;\n   73:         pThis->mpFence = GpuFence::create(device);\n   74          pThis->mpQueue = queue;\n   75  \n   ..\n   77          commandPoolCreateInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;\n   78          commandPoolCreateInfo.flags = VK_COMMAND_POOL_CREATE_TRANSIENT_BIT | VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;\n   79:         commandPoolCreateInfo.queueFamilyIndex = device->getApiCommandQueueType(type);\n   80          VkCommandPool pool;\n   81:         if (VK_FAILED(vkCreateCommandPool(device->getApiHandle(), &commandPoolCreateInfo, nullptr, &pool)))\n   82          {\n   83              logError(\"Could not create command pool\");\n   84              return nullptr;\n   85          }\n   86:         pThis->mpAllocator = CommandAllocatorHandle::create(device, pool);\n   87          pThis->mpApiData = new LowLevelContextApiData;\n   88:         pThis->mpApiData->pCmdBufferAllocator = FencedPool<VkCommandBuffer>::create(device, pThis->mpFence, createCommandBuffer, pThis.get());\n   89          pThis->mpList = pThis->mpApiData->pCmdBufferAllocator->newObject();\n   90          initCommandList(pThis->mpApiData, pThis->mpList);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VkQueryHeap.cpp:\n   46  }\n   47  \n   48: QueryHeap::QueryHeap(std::shared_ptr<Device> device, Type type, uint32_t count) : mType(type), mCount(count) {\n   49      VkQueryPoolCreateInfo info = {};\n   50      info.sType = VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO;\n   ..\n   53      info.pipelineStatistics = VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM;\n   54      VkQueryPool pool;\n   55:     vk_call(vkCreateQueryPool(device->getApiHandle(), &info, nullptr, &pool));\n   56:     mApiHandle = ApiHandle::create(device, pool);\n   57  }\n   58  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKRenderContext.cpp:\n   39      VkImageLayout getImageLayout(Resource::State state);\n   40  \n   41:     RenderContext::RenderContext(std::shared_ptr<Device> device, CommandQueueHandle queue)\n   42:         : ComputeContext(device, LowLevelContextData::CommandQueueType::Direct, queue)\n   43      {\n   44      }\n   ..\n  152      static void transitionFboResources(RenderContext* pCtx, const Fbo* pFbo) {\n  153          // We are setting the entire RTV array to make sure everything that was previously bound is detached\n  154:         uint32_t colorTargets = Fbo::getMaxColorTargetCount(pCtx->device());\n  155  \n  156          if (pFbo) {\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKResourceViews.cpp:\n   44  template<typename ApiHandleType>\n   45  ResourceView<ApiHandleType>::~ResourceView() {\n   46:     getResource()->device()->releaseResource(mApiHandle);\n   47  }\n   48  \n   49: Texture::SharedPtr createBlackTexture(Device::SharedPtr device) {\n   50      uint8_t blackPixel[4] = { 0 };\n   51:     return Texture::create2D(device, 1, 1, ResourceFormat::RGBA8Unorm, 1, 1, blackPixel, Resource::BindFlags::ShaderResource | Resource::BindFlags::RenderTarget | Resource::BindFlags::UnorderedAccess);\n   52  }\n   53  \n   54: Buffer::SharedPtr createZeroBuffer(Device::SharedPtr device) {\n   55      static const uint32_t zero = 0;\n   56:     return Buffer::create(device, sizeof(uint32_t), Resource::BindFlags::UnorderedAccess, Buffer::CpuAccess::None, &zero);\n   57  }\n   58  \n   59: Buffer::SharedPtr createZeroTypedBuffer(Device::SharedPtr device) {\n   60      static const uint32_t zero = 0;\n   61:     return Buffer::createTyped<uint32_t>(device, 1, Resource::BindFlags::UnorderedAccess, Buffer::CpuAccess::None, &zero);\n   62  }\n   63  \n   64: Texture::SharedPtr getEmptyTexture(Device::SharedPtr device) {\n   65:     static Texture::SharedPtr sBlackTexture = createBlackTexture(device);\n   66      return sBlackTexture;\n   67  }\n   68  \n   69: Buffer::SharedPtr getEmptyBuffer(Device::SharedPtr device) {\n   70:     static Buffer::SharedPtr sZeroBuffer = createZeroBuffer(device);\n   71      return sZeroBuffer;\n   72  }\n   73  \n   74: Buffer::SharedPtr getEmptyTypedBuffer(Device::SharedPtr device) {\n   75:     static Buffer::SharedPtr sZeroTypedBuffer = createZeroTypedBuffer(device);\n   76      return sZeroTypedBuffer;\n   77  }\n   ..\n  141              VkImageViewCreateInfo info = initializeImageViewInfo((const Texture*)pResource, mostDetailedMip, mipCount, firstArraySlice, arraySize);\n  142              VkImageView imageView;\n  143:             vk_call(vkCreateImageView(pResource->device()->getApiHandle(), &info, nullptr, &imageView));\n  144:             return VkResource<VkImageView, VkBufferView>::SharedPtr::create(pResource->device(), imageView, nullptr);\n  145          }\n  146  \n  ...\n  152              if (pBuffer->isTyped()) {\n  153                  VkBufferViewCreateInfo info = initializeBufferViewInfo(pBuffer);\n  154:                 vk_call(vkCreateBufferView(pResource->device()->getApiHandle(), &info, nullptr, &bufferView));\n  155              }\n  156  \n  157:             return VkResource<VkImageView, VkBufferView>::SharedPtr::create(pResource->device(), bufferView, nullptr);\n  158          }\n  159  \n  ...\n  181      if (!pBuffer) {\n  182          VkBufferView bufferView = {};\n  183:         auto view = VkResource<VkImageView, VkBufferView>::SharedPtr::create(pBuffer.get()->device(), bufferView, nullptr);\n  184          return SharedPtr(new ShaderResourceView(pBuffer, view, firstElement, elementCount));\n  185      }\n  ...\n  199      if (buffer->isTyped()) {\n  200          VkBufferViewCreateInfo info = initializeBufferViewInfo(buffer);\n  201:         vk_call(vkCreateBufferView(pBuffer->device()->getApiHandle(), &info, nullptr, &bufferView));\n  202      }\n  203  \n  204:     auto view = VkResource<VkImageView, VkBufferView>::SharedPtr::create(pBuffer.get()->device(), bufferView, nullptr);\n  205  \n  206      return SharedPtr(new ShaderResourceView(pBuffer, view, firstElement, elementCount));\n  ...\n  243      if (!pBuffer) {\n  244          VkBufferView bufferView = {};\n  245:         auto view = VkResource<VkImageView, VkBufferView>::SharedPtr::create(pBuffer.get()->device(), bufferView, nullptr);\n  246          return SharedPtr(new UnorderedAccessView(pBuffer, view, firstElement, elementCount));\n  247      }\n  ...\n  261      if (buffer->isTyped()) {\n  262          VkBufferViewCreateInfo info = initializeBufferViewInfo(buffer);\n  263:         vk_call(vkCreateBufferView(pBuffer->device()->getApiHandle(), &info, nullptr, &bufferView));\n  264      }\n  265  \n  266:     auto view = VkResource<VkImageView, VkBufferView>::SharedPtr::create(pBuffer.get()->device(), bufferView, nullptr);\n  267      return SharedPtr(new UnorderedAccessView(pBuffer, view, firstElement, elementCount));\n  268  }\n  ...\n  291  \n  292      VkBufferView bufferView = {};\n  293:     auto handle = VkResource<VkImageView, VkBufferView>::SharedPtr::create(pBuffer.get()->device(), bufferView, nullptr);\n  294  \n  295  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKSampler.cpp:\n   33  namespace Falcor {\n   34  \n   35: uint32_t Sampler::getApiMaxAnisotropy(std::shared_ptr<Device> device) {\n   36:     return (uint32_t)device->getPhysicalDeviceLimits().maxSamplerAnisotropy;\n   37  }\n   38  \n   39: Sampler::SharedPtr Sampler::create(std::shared_ptr<Device> device, const Desc& desc) {\n   40:     SharedPtr pSampler = SharedPtr(new Sampler(device, desc));\n   41  \n   42      VkSamplerCreateInfo info;\n   43      initVkSamplerInfo(pSampler.get(), info);\n   44      VkSampler handle;\n   45:     vk_call(vkCreateSampler(device->getApiHandle(), &info, nullptr, &handle));\n   46:     pSampler->mApiHandle = ApiHandle::create(device, handle);\n   47      return pSampler;\n   48  }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKShader.cpp:\n   32  namespace Falcor {\n   33  \n   34:     Shader::Shader(std::shared_ptr<Device> device, ShaderType type) : mType(type), mpDevice(device) {}\n   35  \n   36      Shader::~Shader() = default;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKSmartHandle.h:\n   44      virtual ~VkBaseApiHandle() = default;\n   45  \n   46:     Device::SharedPtr device() { return mpDevice; }\n   47  \n   48   protected:\n   49:     VkBaseApiHandle(std::shared_ptr<Device> device) { mpDevice = device; }\n   50  \n   51   protected:\n   ..\n   60          SharedPtr() = default;\n   61          explicit SharedPtr(VkHandle<ApiHandle>* pHandle) : std::shared_ptr<VkHandle<ApiHandle>>(pHandle) {}\n   62:         static SharedPtr create(std::shared_ptr<Device> device, ApiHandle handle) { return SharedPtr(new VkHandle(device, handle)); }\n   63          operator ApiHandle() const { return get()->mApiHandle; }\n   64       private:\n   ..\n   73   private:\n   74      friend class SharedPtr;\n   75:     explicit VkHandle(std::shared_ptr<Device> device, const ApiHandle& apiHandle) : VkBaseApiHandle(device), mApiHandle(apiHandle) {}\n   76      ApiHandle mApiHandle;\n   77  };\n   ..\n   83          SharedPtr() = default;\n   84          explicit SharedPtr(VkRootSignature* pHandle) : std::shared_ptr<VkRootSignature>(pHandle) {}\n   85:         static SharedPtr create(std::shared_ptr<Device> device, VkPipelineLayout layout, const std::vector<VkDescriptorSetLayout>& sets) { return SharedPtr(new VkRootSignature(device ,layout, sets)); }\n   86          operator VkPipelineLayout() const { return get()->mApiHandle; }\n   87  \n   ..\n   94   private:\n   95      friend class SharedPtr;\n   96:     VkRootSignature(std::shared_ptr<Device> device, VkPipelineLayout layout, const std::vector<VkDescriptorSetLayout>& sets) : VkBaseApiHandle(device), mApiHandle(layout), mSets(sets) {}\n   97      VkPipelineLayout mApiHandle;\n   98      std::vector<VkDescriptorSetLayout> mSets;\n   ..\n  105          SharedPtr() = default;\n  106          explicit SharedPtr(VkDeviceData* pData) : std::shared_ptr<VkDeviceData>(pData) {}\n  107:         static SharedPtr create(std::shared_ptr<Device> device, VkInstance instance, VkPhysicalDevice physicalDevice, VkDevice vkdevice, VkSurfaceKHR surface) {\n  108:             return SharedPtr(new VkDeviceData(device, instance, physicalDevice, vkdevice, surface));\n  109          }\n  110  \n  ...\n  122   private:\n  123      friend SharedPtr;\n  124:     VkDeviceData(std::shared_ptr<Device> device, VkInstance instance, VkPhysicalDevice physicalDevice, VkDevice vkdevice, VkSurfaceKHR surface) :\n  125:         VkBaseApiHandle(device), mInstance(instance), mPhysicalDevice(physicalDevice), mLogicalDevice(vkdevice), mSurface(surface) {}\n  126      VkInstance          mInstance;\n  127      VkPhysicalDevice    mPhysicalDevice;\n  ...\n  144          explicit SharedPtr(VkResource<ImageType, BufferType>* pRes) : std::shared_ptr<VkResource<ImageType, BufferType>>(pRes) {}\n  145  \n  146:         static SharedPtr create(std::shared_ptr<Device> device, ImageType image, VkDeviceMemory mem) {\n  147:             return SharedPtr(new VkResource<ImageType, BufferType>(device, image, mem));\n  148          }\n  149  \n  150:         static SharedPtr create(std::shared_ptr<Device> device, BufferType buffer, VkDeviceMemory mem) {\n  151:             return SharedPtr(new VkResource<ImageType, BufferType>(device, buffer, mem));\n  152          }\n  153  \n  ...\n  172   private:\n  173      friend SharedPtr;\n  174:     VkResource(std::shared_ptr<Device> device, ImageType image, VkDeviceMemory mem) : VkBaseApiHandle(device), mType(VkResourceType::Image), mImage(image), mDeviceMem(mem) { }\n  175      \n  176:     VkResource(std::shared_ptr<Device> device, BufferType buffer, VkDeviceMemory mem) : VkBaseApiHandle(device), mType(VkResourceType::Buffer), mBuffer(buffer), mDeviceMem(mem) { }\n  177  \n  178      VkResourceType mType = VkResourceType::None;\n  ...\n  188          SharedPtr() = default;\n  189          explicit SharedPtr(VkFbo* pFbo) : std::shared_ptr<VkFbo>(pFbo) {}\n  190:         static SharedPtr create(std::shared_ptr<Device> device, VkRenderPass renderPass, VkFramebuffer fbo) { return SharedPtr(new VkFbo(device, renderPass, fbo)); }\n  191  \n  192          operator VkFramebuffer() const { return get()->mVkFbo; }\n  ...\n  203   private:\n  204      friend SharedPtr;\n  205:     VkFbo(std::shared_ptr<Device> device, VkRenderPass renderPass, VkFramebuffer fbo) : VkBaseApiHandle(device), mVkRenderPass(renderPass), mVkFbo(fbo) {}\n  206      VkRenderPass mVkRenderPass = VK_NULL_HANDLE;\n  207      VkFramebuffer mVkFbo = VK_NULL_HANDLE;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKState.cpp:\n  161  \n  162      static bool hasColorAttachments(const Fbo::Desc& fboDesc) {\n  163:         for (uint32_t i = 0; i < Fbo::getMaxColorTargetCount(fboDesc.device()); i++) {\n  164              if (fboDesc.getColorTargetFormat(i) != ResourceFormat::Unknown) return true;\n  165          }\n  ...\n  498      void initVkRenderPassInfo(const Fbo::Desc& fboDesc, RenderPassCreateInfo& infoOut) {\n  499          // Init Color and Depth Attachment Info\n  500:         infoOut.attachmentDescs.resize(Fbo::getMaxColorTargetCount(fboDesc.device()) + 1); // Color + Depth\n  501          std::vector<uint32_t> regToAttachmentIndex(infoOut.attachmentDescs.size(), VK_ATTACHMENT_UNUSED);\n  502          uint32_t rtCount = 0;\n  503  \n  504          // Color attachments. We're only attaching textures which are actually bound (non-null)\n  505:         for (uint32_t i = 0; i < Fbo::getMaxColorTargetCount(fboDesc.device()); i++) {\n  506              ResourceFormat format = fboDesc.getColorTargetFormat(i);\n  507              if(format != ResourceFormat::Unknown) {\n  ...\n  560          if(hasColor) {\n  561              // Color attachments. This is where we create the indirection between the attachment in the RenderPass and the shader output-register index\n  562:             for (size_t i = 0; i < Fbo::getMaxColorTargetCount(fboDesc.device()); i++) {\n  563                  VkAttachmentReference& ref = infoOut.attachmentRefs[i];\n  564                  ref.attachment = regToAttachmentIndex[i];\n  ...\n  566              }\n  567  \n  568:             subpassDesc.colorAttachmentCount = Fbo::getMaxColorTargetCount(fboDesc.device());\n  569              subpassDesc.pColorAttachments = infoOut.attachmentRefs.data();\n  570          }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKTexture.cpp:\n  105      }\n  106  \n  107:     static VkImageTiling getFormatImageTiling(std::shared_ptr<Device> device, VkFormat format, VkImageUsageFlags usage) {\n  108          VkFormatProperties p;\n  109:         vkGetPhysicalDeviceFormatProperties(device->getApiHandle(), format, &p);\n  110          auto featureBits = getFormatFeatureBitsFromUsage(usage);\n  111          if ((p.optimalTilingFeatures & featureBits) == featureBits) return VK_IMAGE_TILING_OPTIMAL;\n  ...\n  152          VkMemoryRequirements memRequirements;\n  153          vkGetImageMemoryRequirements(mpDevice->getApiHandle(), image, &memRequirements);\n  154:         VkDeviceMemory deviceMem = allocateDeviceMemory(Device::MemoryType::Default, memRequirements.memoryTypeBits, memRequirements.size);\n  155:         vkBindImageMemory(mpDevice->getApiHandle(), image, deviceMem, 0);\n  156:         mApiHandle = ApiHandle::create(mpDevice, image, deviceMem);\n  157    \n  158          if (pData != nullptr) {\n\n/home/max/dev/Falcor/src/Falcor/Core/BufferTypes/ParameterBlock.cpp:\n  230  ParameterBlock::~ParameterBlock() = default;\n  231  \n  232: ParameterBlock::SharedPtr ParameterBlock::create(std::shared_ptr<Device> device, const std::shared_ptr<const ProgramVersion>& pProgramVersion, const ReflectionType::SharedConstPtr& pElementType) {\n  233      if (!pElementType) {\n  234          throw std::runtime_error(\"Can't create a parameter block without type information\");\n  235      }\n  236      auto pReflection = ParameterBlockReflection::create(pProgramVersion.get(), pElementType);\n  237:     return create(device, pReflection);\n  238  }\n  239  \n  240: ParameterBlock::SharedPtr ParameterBlock::create(std::shared_ptr<Device> device, const ParameterBlockReflection::SharedConstPtr& pReflection) {\n  241      assert(pReflection);\n  242:     return SharedPtr(new ParameterBlock(device, pReflection->getProgramVersion(), pReflection));\n  243  }\n  244  \n  245: ParameterBlock::SharedPtr ParameterBlock::create(std::shared_ptr<Device> device, const std::shared_ptr<const ProgramVersion>& pProgramVersion, const std::string& typeName) {\n  246      assert(pProgramVersion);\n  247:     return ParameterBlock::create(device, pProgramVersion, pProgramVersion->getReflector()->findType(typeName));\n  248  }\n  249  \n  250: ParameterBlock::ParameterBlock(std::shared_ptr<Device> device, const std::shared_ptr<const ProgramVersion>& pProgramVersion, const ParameterBlockReflection::SharedConstPtr& pReflection)\n  251      : mpReflector(pReflection)\n  252      , mpProgramVersion(pProgramVersion)\n  253      , mData(pReflection->getElementType()->getByteSize(), 0) \n  254:     , mpDevice(device) {\n  255  \n  256      ReflectionStructType::BuildState state;\n\n/home/max/dev/Falcor/src/Falcor/Core/BufferTypes/ParameterBlock.h:\n  106      /** Create a new object that holds a value of the given type.\n  107      */\n  108:     static SharedPtr create(std::shared_ptr<Device> device, const std::shared_ptr<const ProgramVersion>& pProgramVersion, const ReflectionType::SharedConstPtr& pType);\n  109  \n  110      /** Create a new object that holds a value described by the given reflector.\n  111      */\n  112:     static SharedPtr create(std::shared_ptr<Device> device, const ParameterBlockReflection::SharedConstPtr& pReflection);\n  113  \n  114      /** Create a new object that holds a value of the type with the given name in the given program.\n  ...\n  116          \\param[in] typeName Name of the type. If the type does not exist an exception is thrown.\n  117      */\n  118:     static SharedPtr create(std::shared_ptr<Device> device, const std::shared_ptr<const ProgramVersion>& pProgramVersion, const std::string& typeName);\n  119  \n  120      /** Set a variable into the block.\n  ...\n  343      std::shared_ptr<Device>  mpDevice;\n  344  \n  345:     ParameterBlock(std::shared_ptr<Device> device, const std::shared_ptr<const ProgramVersion>& pProgramVersion, const ParameterBlockReflection::SharedConstPtr& pReflection);\n  346  \n  347      std::shared_ptr<const ProgramVersion> mpProgramVersion;\n\n/home/max/dev/Falcor/src/Falcor/Core/Platform/MonitorInfo.cpp:\n   84              NULL, //HWND\n   85              DIGCF_PRESENT, // Flags //DIGCF_ALLCLASSES|\n   86:             NULL, // device info, create a new one.\n   87              NULL, // machine name, local machine\n   88              NULL);// reserved\n   ..\n  133          DISPLAY_DEVICE dd;\n  134          dd.cb = sizeof(dd);\n  135:         DWORD devIdx = 0; // device index\n  136  \n  137          bool bFoundDevice = false;\n\n/home/max/dev/Falcor/src/Falcor/Core/Platform/Windows/ProgressBarWin.cpp:\n   36      {\n   37          HWND hwnd;\n   38:         std::random_device rd;\n   39          std::mt19937 rng;\n   40          std::uniform_int_distribution<int> dist;\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ComputeProgram.cpp:\n   31  namespace Falcor {\n   32  \n   33:     ComputeProgram::SharedPtr ComputeProgram::createFromFile(std::shared_ptr<Device> device, const std::string& filename, const std::string& csEntry, const DefineList& programDefines, Shader::CompilerFlags flags, const std::string& shaderModel) {\n   34          Desc d(filename);\n   35          if (!shaderModel.empty()) d.setShaderModel(shaderModel);\n   36          d.setCompilerFlags(flags);\n   37          d.csEntry(csEntry);\n   38:         return create(device, d, programDefines);\n   39      }\n   40  \n   41:     ComputeProgram::SharedPtr ComputeProgram::create(std::shared_ptr<Device> device, const Program::Desc& desc, const DefineList& programDefines) {\n   42          SharedPtr pProg = SharedPtr(new ComputeProgram);\n   43:         pProg->init(device, desc, programDefines);\n   44          return pProg;\n   45      }\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ComputeProgram.h:\n   55          \\return A new object, or an exception is thrown if creation failed.\n   56      */\n   57:     static SharedPtr createFromFile(std::shared_ptr<Device> device, const std::string& filename, const std::string& csEntry, const DefineList& programDefines = DefineList(), Shader::CompilerFlags flags = Shader::CompilerFlags::None, const std::string& shaderModel = \"\");\n   58  \n   59      /** Create a new compute program.\n   ..\n   63          \\return A new object, or an exception is thrown if creation failed.\n   64      */\n   65:     static SharedPtr create(std::shared_ptr<Device> device, const Program::Desc& desc, const DefineList& programDefines = DefineList());\n   66  \n   67   private:\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/GraphicsProgram.cpp:\n   31  namespace Falcor {\n   32  \n   33:     GraphicsProgram::SharedPtr GraphicsProgram::create(std::shared_ptr<Device> device, const Desc& desc, const Program::DefineList& programDefines) {\n   34          SharedPtr pProg = SharedPtr(new GraphicsProgram);\n   35          Desc d = desc;\n   36          d.addDefaultVertexShaderIfNeeded();\n   37:         pProg->init(device, d, programDefines);\n   38          return pProg;\n   39      }\n   40  \n   41:     GraphicsProgram::SharedPtr GraphicsProgram::createFromFile(std::shared_ptr<Device> device, const std::string& filename, const std::string& vsEntry, const std::string& psEntry, const DefineList& programDefines) {\n   42          Desc d(filename);\n   43          d.vsEntry(vsEntry).psEntry(psEntry).addDefaultVertexShaderIfNeeded();\n   44:         return create(device, d, programDefines);\n   45      }\n   46  \n\n/home/max/dev/Falcor/src/Falcor/Core/Program/GraphicsProgram.h:\n   52          \\return A new object, or an exception is thrown if creation failed.\n   53      */\n   54:     static SharedPtr create(std::shared_ptr<Device> device, const Desc& desc, const Program::DefineList& programDefines = DefineList());\n   55  \n   56      /** Create a new graphics program from file.\n   ..\n   61          \\return A new object, or an exception is thrown if creation failed.\n   62      */\n   63:     static SharedPtr createFromFile(std::shared_ptr<Device> device, const std::string& filename, const std::string& vsEntry, const std::string& psEntry, const DefineList& programDefines = DefineList());\n   64  \n   65   private:\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/Program.cpp:\n   41  static Program::DefineList sGlobalDefineList;\n   42  \n   43: static Shader::SharedPtr createShaderFromBlob(std::shared_ptr<Device> device, const Shader::Blob& shaderBlob, ShaderType shaderType, const std::string& entryPointName, Shader::CompilerFlags flags, std::string& log) {\n   44      std::string errorMsg;\n   45:     auto pShader = Shader::create(device, shaderBlob, shaderType, entryPointName, flags, log);\n   46      return pShader;\n   47  }\n   ..\n  151  std::vector<std::weak_ptr<Program>> Program::sPrograms;\n  152  \n  153: void Program::init(std::shared_ptr<Device> device, Desc const& desc, DefineList const& defineList) {\n  154      mDesc = desc;\n  155      mDefineList = defineList;\n  156:     mpDevice = device;\n  157  \n  158      sPrograms.push_back(shared_from_this());\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/Program.h:\n  245      Program() = default;\n  246  \n  247:     void init(std::shared_ptr<Device> device, Desc const& desc, DefineList const& programDefines);\n  248  \n  249      bool link() const;\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramVars.cpp:\n   55      }\n   56  \n   57:     ProgramVars::ProgramVars(std::shared_ptr<Device> device, const ProgramReflection::SharedConstPtr& pReflector)\n   58:         : ParameterBlock(device, pReflector->getProgramVersion(), pReflector->getDefaultParameterBlock())\n   59          , mpReflector(pReflector)\n   60      {\n   ..\n   73      }\n   74  \n   75:     GraphicsVars::GraphicsVars(std::shared_ptr<Device> device, const ProgramReflection::SharedConstPtr& pReflector)\n   76:         : ProgramVars(device, pReflector)\n   77      {\n   78          addSimpleEntryPointGroups();\n   79      }\n   80  \n   81:     GraphicsVars::SharedPtr GraphicsVars::create(std::shared_ptr<Device> device, const ProgramReflection::SharedConstPtr& pReflector) {\n   82          if (pReflector == nullptr) {\n   83              throw std::runtime_error(\"Can't create a GraphicsVars object without a program reflector\");\n   84          }\n   85:         return SharedPtr(new GraphicsVars(device, pReflector));\n   86      }\n   87  \n   88:     GraphicsVars::SharedPtr GraphicsVars::create(std::shared_ptr<Device> device, const GraphicsProgram* pProg) {\n   89          if (pProg == nullptr) {\n   90              throw std::runtime_error(\"Can't create a GraphicsVars object without a program\");\n   91          }\n   92:         return create(device, pProg->getReflector());\n   93      }\n   94  \n   95:     ComputeVars::SharedPtr ComputeVars::create(std::shared_ptr<Device> device, const ProgramReflection::SharedConstPtr& pReflector) {\n   96          if (pReflector == nullptr) {\n   97              throw std::runtime_error(\"Can't create a ComputeVars object without a program reflector\");\n   98          }\n   99:         return SharedPtr(new ComputeVars(device, pReflector));\n  100      }\n  101  \n  102:     ComputeVars::SharedPtr ComputeVars::create(std::shared_ptr<Device> device, const ComputeProgram* pProg) {\n  103          if (pProg == nullptr) {\n  104              throw std::runtime_error(\"Can't create a ComputeVars object without a program\");\n  105          }\n  106:         return create(device, pProg->getReflector());\n  107      }\n  108  \n  109:     ComputeVars::ComputeVars(std::shared_ptr<Device> device, const ProgramReflection::SharedConstPtr& pReflector)\n  110:         : ProgramVars(device, pReflector)\n  111      {\n  112          addSimpleEntryPointGroups();\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramVars.h:\n   50          \\return New object, or throws an exception if creation failed.\n   51      */\n   52:     static SharedPtr create(std::shared_ptr<Device> device, const EntryPointGroupReflection::SharedConstPtr& pReflector, uint32_t groupIndexInProgram) {\n   53          assert(pReflector);\n   54:         return SharedPtr(new EntryPointGroupVars(device, pReflector, groupIndexInProgram));\n   55      }\n   56  \n   ..\n   58  \n   59   protected:\n   60:     EntryPointGroupVars(std::shared_ptr<Device> device, const EntryPointGroupReflection::SharedConstPtr& pReflector, uint32_t groupIndexInProgram)\n   61:         : ParameterBlock(device, pReflector->getProgramVersion(), pReflector)\n   62          , mGroupIndexInProgram(groupIndexInProgram)\n   63      {\n   ..\n   91  \n   92   protected:\n   93:     ProgramVars(std::shared_ptr<Device> device, const ProgramReflection::SharedConstPtr& pReflector);\n   94  \n   95      ProgramReflection::SharedConstPtr mpReflector;\n   ..\n  110          \\return A new object, or an exception is thrown if creation failed.\n  111      */\n  112:     static SharedPtr create(std::shared_ptr<Device> device, const ProgramReflection::SharedConstPtr& pReflector);\n  113  \n  114      /** Create a new graphics vars object.\n  ...\n  116          \\return A new object, or an exception is thrown if creation failed.\n  117      */\n  118:     static SharedPtr create(std::shared_ptr<Device> device, const GraphicsProgram* pProg);\n  119  \n  120      virtual bool apply(RenderContext* pContext, bool bindRootSig, RootSignature* pRootSignature);\n  121  \n  122   protected:\n  123:     GraphicsVars(std::shared_ptr<Device> device, const ProgramReflection::SharedConstPtr& pReflector);\n  124  };\n  125  \n  ...\n  137          \\return A new object, or an exception is thrown if creation failed.\n  138      */\n  139:     static SharedPtr create(std::shared_ptr<Device> device, const ProgramReflection::SharedConstPtr& pReflector);\n  140  \n  141      /** Create a new compute vars object.\n  ...\n  143          \\return A new object, or an exception is thrown if creation failed.\n  144      */\n  145:     static SharedPtr create(std::shared_ptr<Device> device, const ComputeProgram* pProg);\n  146  \n  147      virtual bool apply(ComputeContext* pContext, bool bindRootSig, RootSignature* pRootSignature);\n  148  \n  149   protected:\n  150:     ComputeVars(std::shared_ptr<Device> device, const ProgramReflection::SharedConstPtr& pReflector);\n  151  };\n  152  \n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramVersion.cpp:\n   89  \n   90      ProgramKernels::ProgramKernels(\n   91:         std::shared_ptr<Device> device, \n   92          const ProgramVersion* pVersion,\n   93          const ProgramReflection::SharedPtr& pReflector,\n   ..\n   98          , mpVersion(pVersion)\n   99          , mUniqueEntryPointGroups(uniqueEntryPointGroups)\n  100:         , mpDevice(device)\n  101      {\n  102:         mpRootSignature = RootSignature::create(device, pReflector.get());\n  103      }\n  104  \n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramVersion.h:\n  187      protected:\n  188          ProgramKernels(\n  189:             std::shared_ptr<Device> device, \n  190              const ProgramVersion* pVersion,\n  191              const ProgramReflection::SharedPtr& pReflector,\n\n/home/max/dev/Falcor/src/Falcor/Core/Renderer.h:\n   44  struct SampleConfig : ScriptBindings::enable_to_string {\n   45      Window::Desc windowDesc;                 ///< Controls window creation\n   46:     Device::Desc deviceDesc;                 ///< Controls device creation\n   47      bool suppressInput = false;              ///< Suppress all keyboard and mouse input (other than escape to terminate)\n   48      bool showMessageBoxOnError = true;       ///< Show message box on framework/API errors.\n\n/home/max/dev/Falcor/src/Falcor/Core/Sample.cpp:\n   58              return;\n   59          }\n   60:         // Tell the device to resize the swap chain\n   61          auto winSize = mpWindow->getClientAreaSize();\n   62          auto pBackBufferFBO = mpDevice->resizeSwapChain(winSize.x, winSize.y);\n   ..\n  237          mShowUI = config.showUI;\n  238          \n  239:         mVsyncOn = config.deviceDesc.enableVsync;\n  240  \n  241          // Create the window\n  242          mpWindow = Window::create(config.windowDesc, this);\n  243          if (mpWindow == nullptr) {\n  244:             logError(\"Failed to create device and window\");\n  245              return;\n  246          }\n  247          \n  248:         // Create device \n  249:         mpDevice = Device::create(mpWindow, config.deviceDesc);\n  250  \n  251          mClock = new Clock(mpDevice);\n  ...\n  258          ProgressBar::SharedPtr pBar;\n  259          if (config.windowDesc.mode != Window::WindowMode::Minimized) pBar = ProgressBar::show(\"Initializing Falcor\");\n  260:         Device::Desc d = config.deviceDesc;\n  261          \n  262          if (mpDevice == nullptr) {\n  263:             logError(\"Failed to create device\");\n  264              return;\n  265          }\n  ...\n  579      SampleConfig Sample::getConfig() {\n  580          SampleConfig c;\n  581:         c.deviceDesc = mpDevice->getDesc();\n  582          c.windowDesc = mpWindow->getDesc();\n  583          c.showMessageBoxOnError = Logger::isBoxShownOnError();\n  ...\n  606          auto sampleDesc = m.regClass(SampleConfig);\n  607  #define field(f_) rwField(#f_, &SampleConfig::f_)\n  608:         sampleDesc.field(windowDesc).field(deviceDesc).field(showMessageBoxOnError).field(timeScale);\n  609          sampleDesc.field(pauseTime).field(showUI);\n  610  #undef field\n\n/home/max/dev/Falcor/src/Falcor/Core/State/ComputeState.cpp:\n   33  namespace Falcor {\n   34  \n   35: ComputeState::ComputeState(std::shared_ptr<Device> device): mpDevice(device) {\n   36      mpCsoGraph = _StateGraph::create();\n   37  }\n\n/home/max/dev/Falcor/src/Falcor/Core/State/ComputeState.h:\n   51          \\return A new object, or an exception is thrown if creation failed.\n   52      */\n   53:     static SharedPtr create(std::shared_ptr<Device> device) { return SharedPtr(new ComputeState(device)); }\n   54  \n   55      /** Copy constructor. Useful if you need to make minor changes to an already existing object\n   ..\n   70      \n   71   private:\n   72:     ComputeState(std::shared_ptr<Device> device);\n   73  \n   74      std::shared_ptr<Device> mpDevice;\n\n/home/max/dev/Falcor/src/Falcor/Core/State/GraphicsState.cpp:\n   47  }\n   48  \n   49: GraphicsState::GraphicsState(std::shared_ptr<Device> device): mpDevice(device), mDesc(device) {\n   50:     uint32_t vpCount = getMaxViewportCount(device);\n   51  \n   52      // Create the viewports\n\n/home/max/dev/Falcor/src/Falcor/Core/State/GraphicsState.h:\n   84          \\return A new object, or an exception is thrown if creation failed.\n   85      */\n   86:     static SharedPtr create(std::shared_ptr<Device> device) { return SharedPtr(new GraphicsState(device)); }\n   87  \n   88      /** Copy constructor. Useful if you need to make minor changes to an already existing object\n   ..\n  232  \n  233  private:\n  234:     GraphicsState(std::shared_ptr<Device> device);\n  235  \n  236      Vao::SharedConstPtr mpVao;\n\n/home/max/dev/Falcor/src/Falcor/Data/Framework/Fonts/consolab.ttf:\n    <binary>\n\n/home/max/dev/Falcor/src/Falcor/Data/Framework/Fonts/trebucbd.ttf:\n    <binary>\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/EmissiveIntegrator.ps.slang:\n  102          // We need to detect that and handle it with a fallback mechanism (print error for now).\n  103  \n  104:         // Convert to 2DH normalized device coordinates.\n  105          float2 ndcPos = texelPos * (2.f / _VIEWPORT_DIM) - 1.f;\n  106  \n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/EnvProbe.cpp:\n   72      bool EnvProbe::init(RenderContext* pRenderContext, const std::string& filename) {\n   73          // Create compute program for the setup phase.\n   74:         mpSetupPass = ComputePass::create(pRenderContext->device(), kShaderFilenameSetup, \"main\");\n   75  \n   76          // Create sampler.\n   ..\n   79          samplerDesc.setFilterMode(Sampler::Filter::Linear, Sampler::Filter::Linear, Sampler::Filter::Linear);\n   80          samplerDesc.setAddressingMode(Sampler::AddressMode::Wrap, Sampler::AddressMode::Clamp, Sampler::AddressMode::Clamp);\n   81:         mpEnvSampler = Sampler::create(pRenderContext->device(), samplerDesc);\n   82          samplerDesc.setFilterMode(Sampler::Filter::Point, Sampler::Filter::Point, Sampler::Filter::Point);\n   83          samplerDesc.setAddressingMode(Sampler::AddressMode::Clamp, Sampler::AddressMode::Clamp, Sampler::AddressMode::Clamp);\n   84:         mpImportanceSampler = Sampler::create(pRenderContext->device(), samplerDesc);\n   85  \n   86          // Load environment map from file. Set it to generate mips and use linear color.\n   87:         mpEnvMap = Texture::createFromFile(pRenderContext->device(), filename, true, false);\n   88          if (!mpEnvMap) {\n   89              logError(\"EnvProbe::init() - Failed to load texture \" + filename);\n   ..\n  110  \n  111          // Create importance map. We have to set the RTV flag to be able to use generateMips().\n  112:         mpImportanceMap = Texture::create2D(pRenderContext->device(), dimension, dimension, ResourceFormat::R32Float, 1, mips, nullptr, Resource::BindFlags::ShaderResource | Resource::BindFlags::RenderTarget | Resource::BindFlags::UnorderedAccess);\n  113          assert(mpImportanceMap);\n  114  \n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVH.cpp:\n   35  namespace Falcor {\n   36  \n   37:     LightBVH::SharedPtr LightBVH::create(std::shared_ptr<Device> device, const LightCollection::SharedConstPtr& pLightCollection) {\n   38:         return SharedPtr(new LightBVH(device, pLightCollection));\n   39      }\n   40  \n   ..\n  178      }\n  179  \n  180:     LightBVH::LightBVH(std::shared_ptr<Device> device, const LightCollection::SharedConstPtr& pLightCollection) : mpDevice(device), mpLightCollection(pLightCollection) {\n  181          verifyStaticParams();\n  182          mAlignedAllocator.setMinimumAlignment(16);\n  183          mAlignedAllocator.setCacheLineSize(0);  // Don't worry about allocations that straddle two cache lines.\n  184  \n  185:         mLeafUpdater = ComputePass::create(device, kShaderFile, \"updateLeafNodes\");\n  186:         mInternalUpdater = ComputePass::create(device, kShaderFile, \"updateInternalNodes\");\n  187      }\n  188  \n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVH.h:\n  118          };\n  119  \n  120:         std::shared_ptr<Device> device() { return mpDevice; }\n  121  \n  122          /** Function called on each node.\n  ...\n  131              \\param[in] pLightCollection The light collection around which the BVH will be built.\n  132          */\n  133:         static SharedPtr create(std::shared_ptr<Device> device, const LightCollection::SharedConstPtr& pLightCollection);\n  134  \n  135          /** Refit all the BVH nodes to the underlying geometry, without changing the hierarchy.\n  ...\n  197  \n  198       protected:\n  199:         LightBVH(std::shared_ptr<Device> device, const LightCollection::SharedConstPtr& pLightCollection);\n  200  \n  201          void computeStats();\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVHBuilder.cpp:\n  196  \n  197      void LightBVHBuilder::build(LightBVH& bvh) {\n  198:         PROFILE(bvh.device(), \"LightBVHBuilder::build()\");\n  199  \n  200          bvh.clear();\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVHSampler.cpp:\n   50  \n   51      bool LightBVHSampler::update(RenderContext* pRenderContext) {\n   52:         PROFILE(pRenderContext->device(), \"LightBVHSampler::update\");\n   53  \n   54          bool samplerChanged = false;\n   ..\n  156              throw std::runtime_error(\"Failed to create BVH builder\");\n  157          }\n  158:         mpBVH = LightBVH::create(pRenderContext->device(), pScene->getLightCollection(pRenderContext));\n  159          if (!mpBVH) {\n  160              throw std::runtime_error(\"Failed to create BVH\");\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightCollection.cpp:\n   52  \n   53      bool LightCollection::update(RenderContext* pRenderContext, UpdateStatus* pUpdateStatus) {\n   54:         PROFILE(pRenderContext->device(), \"LightCollection::update()\");\n   55  \n   56          if (pUpdateStatus) {\n   ..\n  116          assert(pScene);\n  117          mpScene = pScene;\n  118:         mpDevice = pRenderContext->device();\n  119  \n  120          // Setup the lights.\n  ...\n  299  \n  300          // Create the GPU buffer.\n  301:         mpPerMeshInstanceOffset = Buffer::createStructured(pRenderContext->device(), sizeof(uint32_t), instanceCount, Resource::BindFlags::ShaderResource);\n  302          mpPerMeshInstanceOffset->setName(\"LightCollection_PerMeshInstanceOffset\");\n  303  \n  ...\n  317  \n  318              if (!mIntegrator.pResultBuffer || mIntegrator.pResultBuffer->getSize() < bufSize) {\n  319:                 mIntegrator.pResultBuffer = Buffer::create(pRenderContext->device(), bufSize, Resource::BindFlags::ShaderResource | Resource::BindFlags::UnorderedAccess, Buffer::CpuAccess::None);\n  320                  mIntegrator.pResultBuffer->setName(\"LightCollection_IntegratorResults\");\n  321                  assert(mIntegrator.pResultBuffer);\n  ...\n  493          const size_t stagingSize = mpMeshLightsVertexPos->getSize() + mpMeshLightsTexCoords->getSize() + mpTriangleData->getSize();\n  494          if (!mpStagingBuffer || mpStagingBuffer->getSize() < stagingSize) {\n  495:             mpStagingBuffer = Buffer::create(pRenderContext->device(), stagingSize, Resource::BindFlags::None, Buffer::CpuAccess::Read);\n  496              mpStagingBuffer->setName(\"LightCollection_StagingBuffer\");\n  497              mCPUInvalidData = CPUOutOfDateFlags::All;\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightCollection.h:\n  108      ~LightCollection() = default;\n  109  \n  110:     std::shared_ptr<Device> const device() { return mpDevice; }\n  111  \n  112      /** Creates a light collection for the given scene.\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/BasePasses/BaseGraphicsPass.cpp:\n   31  namespace Falcor {\n   32  \n   33: BaseGraphicsPass::BaseGraphicsPass(std::shared_ptr<Device> device, const Program::Desc& progDesc, const Program::DefineList& programDefines): mpDevice(device) {\n   34:     auto pProg = GraphicsProgram::create(device, progDesc, programDefines);\n   35  \n   36:     mpState = GraphicsState::create(device);\n   37      mpState->setProgram(pProg);\n   38  \n   39:     mpVars = GraphicsVars::create(device, pProg.get());\n   40  }\n   41  \n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/BasePasses/BaseGraphicsPass.h:\n   75          \\return A new object, or an exception is thrown if creation failed.\n   76      */\n   77:     BaseGraphicsPass(std::shared_ptr<Device> device, const Program::Desc& progDesc, const Program::DefineList& programDefines);\n   78  \n   79      GraphicsVars::SharedPtr mpVars;\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/BasePasses/ComputePass.cpp:\n   31  namespace Falcor {\n   32  \n   33: ComputePass::ComputePass(std::shared_ptr<Device> device, const Program::Desc& desc, const Program::DefineList& defines, bool createVars): mpDevice(device) {\n   34:     auto pProg = ComputeProgram::create(device, desc, defines);\n   35:     mpState = ComputeState::create(device);\n   36      mpState->setProgram(pProg);\n   37:     if (createVars) mpVars = ComputeVars::create(device, pProg.get());\n   38      assert(pProg && mpState && (!createVars || mpVars));\n   39  }\n   40  \n   41: ComputePass::SharedPtr ComputePass::create(std::shared_ptr<Device> device, const std::string& filename, const std::string& csEntry, const Program::DefineList& defines, bool createVars) {\n   42      Program::Desc d;\n   43      d.addShaderLibrary(filename).csEntry(csEntry);\n   44:     return create(device, d, defines, createVars);\n   45  }\n   46  \n   47: ComputePass::SharedPtr ComputePass::create(std::shared_ptr<Device> device, const Program::Desc& desc, const Program::DefineList& defines, bool createVars) {\n   48:     return SharedPtr(new ComputePass(device, desc, defines, createVars));\n   49  }\n   50  \n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/BasePasses/ComputePass.h:\n   48              \\return A new object, or throws an exception if creation failed.\n   49          */\n   50:         static SharedPtr create(std::shared_ptr<Device> device, const std::string& filename, const std::string& csEntry = \"main\", const Program::DefineList& defines = Program::DefineList(), bool createVars = true);\n   51  \n   52          /** Create a new compute pass.\n   ..\n   56              \\return A new object, or throws an exception if creation failed.\n   57          */\n   58:         static SharedPtr create(std::shared_ptr<Device> device, const Program::Desc& desc, const Program::DefineList& defines = Program::DefineList(), bool createVars = true);\n   59  \n   60          /** Execute the pass using the given compute-context\n   ..\n  108  \n  109      protected:\n  110:         ComputePass(std::shared_ptr<Device> device, const Program::Desc& desc, const Program::DefineList& defines, bool createVars);\n  111          ComputeVars::SharedPtr mpVars;\n  112          ComputeState::SharedPtr mpState;\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/BasePasses/FullScreenPass.cpp:\n   70  #undef ADJUST_Y\n   71  \n   72: void initFullScreenData(std::shared_ptr<Device> device, Buffer::SharedPtr& pVB, Vao::SharedPtr& pVao) {\n   73      // First time we got here. create VB and VAO\n   74      const uint32_t vbSize = (uint32_t)(sizeof(Vertex)*arraysize(kVertices));\n   75:     pVB = Buffer::create(device, vbSize, Buffer::BindFlags::Vertex, Buffer::CpuAccess::Write, (void*)kVertices);\n   76      assert(pVB);\n   77  \n   ..\n   90  }  // namespace\n   91  \n   92: FullScreenPass::FullScreenPass(std::shared_ptr<Device> device, const Program::Desc& progDesc, const Program::DefineList& programDefines): BaseGraphicsPass(device, progDesc, programDefines) {\n   93      gFullScreenData.objectCount++;\n   94  \n   ..\n   99  \n  100      if (gFullScreenData.pVertexBuffer == nullptr) {\n  101:         initFullScreenData(device, gFullScreenData.pVertexBuffer, gFullScreenData.pVao);\n  102      }\n  103      assert(gFullScreenData.pVao);\n  ...\n  116  }\n  117  \n  118: FullScreenPass::SharedPtr FullScreenPass::create(std::shared_ptr<Device> device, const Program::Desc& desc, const Program::DefineList& defines, uint32_t viewportMask) {\n  119      Program::Desc d = desc;\n  120      Program::DefineList defs = defines;\n  ...\n  132      if (!d.hasEntryPoint(ShaderType::Vertex)) d.addShaderLibrary(\"RenderGraph/BasePasses/FullScreenPass.vs.slang\").vsEntry(\"main\");\n  133  \n  134:     return SharedPtr(new FullScreenPass(device, d, defs));\n  135  }\n  136  \n  137: FullScreenPass::SharedPtr FullScreenPass::create(std::shared_ptr<Device> device, const std::string& filename, const Program::DefineList& defines, uint32_t viewportMask) {\n  138      Program::Desc d;\n  139      d.addShaderLibrary(filename).psEntry(\"main\");\n  140:     return create(device, d, defines, viewportMask);\n  141  }\n  142  \n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/BasePasses/FullScreenPass.h:\n   46          \\return A new object, or throws an exception if creation failed.\n   47      */\n   48:     static SharedPtr create(std::shared_ptr<Device> device, const std::string& filename, const Program::DefineList& defines = Program::DefineList(), uint32_t viewportMask = 0);\n   49  \n   50      /** Create a new fullscreen pass.\n   ..\n   54          \\return A new object, or throws an exception if creation failed.\n   55      */\n   56:     static SharedPtr create(std::shared_ptr<Device> device, const Program::Desc& desc, const Program::DefineList& defines = Program::DefineList(), uint32_t viewportMask = 0);\n   57  \n   58      /** Execute the pass using an FBO\n   ..\n   64  \n   65   protected:\n   66:     FullScreenPass(std::shared_ptr<Device> device, const Program::Desc& progDesc, const Program::DefineList& programDefines);\n   67  };\n   68  \n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/BasePasses/RasterPass.cpp:\n   32  namespace Falcor {\n   33  \n   34: RasterPass::SharedPtr RasterPass::create(std::shared_ptr<Device> device, const Program::Desc& desc, const Program::DefineList& defines) {\n   35:     return SharedPtr(new RasterPass(device, desc, defines));\n   36  }\n   37  \n   38: RasterPass::SharedPtr RasterPass::create(std::shared_ptr<Device> device, const std::string& filename, const std::string& vsEntry, const std::string& psEntry, const Program::DefineList& defines) {\n   39      Program::Desc d;\n   40      d.addShaderLibrary(filename).vsEntry(vsEntry).psEntry(psEntry);\n   41:     return create(device, d, defines);\n   42  }\n   43  \n   44: RasterPass::RasterPass(std::shared_ptr<Device> device, const Program::Desc& progDesc, const Program::DefineList& programDefines) : BaseGraphicsPass(device, progDesc, programDefines) {\n   45  }\n   46  \n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/BasePasses/RasterPass.h:\n   44              \\return A new object, or throws an exception if creation failed.\n   45          */\n   46:         static SharedPtr create(std::shared_ptr<Device> device, const std::string& filename, const std::string& vsEntry, const std::string& psEntry, const Program::DefineList& defines = Program::DefineList());\n   47  \n   48          /** Create a new object.\n   ..\n   51              \\return A new object, or throws an exception if creation failed.\n   52          */\n   53:         static SharedPtr create(std::shared_ptr<Device> device, const Program::Desc& desc, const Program::DefineList& defines = Program::DefineList());\n   54  \n   55          /** Ordered draw call.\n   ..\n   67  \n   68       protected:\n   69:         RasterPass(std::shared_ptr<Device> device, const Program::Desc& progDesc, const Program::DefineList& programDefines);\n   70      };\n   71  \n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/BasePasses/RasterScenePass.cpp:\n   31  namespace Falcor {\n   32  \n   33: RasterScenePass::RasterScenePass(std::shared_ptr<Device> device, const Scene::SharedPtr& pScene, const Program::Desc& progDesc, const Program::DefineList& programDefines) : BaseGraphicsPass(device, progDesc, programDefines), mpScene(pScene) {\n   34      assert(pScene);\n   35  }\n   36  \n   37: RasterScenePass::SharedPtr RasterScenePass::create(std::shared_ptr<Device> device, const Scene::SharedPtr& pScene, const Program::Desc& progDesc, const Program::DefineList& programDefines) {\n   38      if (pScene == nullptr) {\n   39          throw std::runtime_error(\"Can't create a RasterScenePass object without a scene\");            \n   ..\n   42      dl.add(pScene->getSceneDefines());\n   43  \n   44:     return SharedPtr(new RasterScenePass(device, pScene, progDesc, dl));\n   45  }\n   46  \n   47: RasterScenePass::SharedPtr RasterScenePass::create(std::shared_ptr<Device> device, const Scene::SharedPtr& pScene, const std::string& filename, const std::string& vsEntry, const std::string& psEntry, const Program::DefineList& programDefines) {\n   48      Program::Desc d;\n   49      d.addShaderLibrary(filename).vsEntry(vsEntry).psEntry(psEntry);\n   50:     return create(device, pScene, d, programDefines);\n   51  }\n   52  \n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/BasePasses/RasterScenePass.h:\n   45              \\return A new object, or throws an exception if creation failed.\n   46          */\n   47:         static SharedPtr create(std::shared_ptr<Device> device, const Scene::SharedPtr& pScene, const Program::Desc& progDesc, const Program::DefineList& programDefines = Program::DefineList());\n   48  \n   49          /** Create a new object.\n   ..\n   55              \\return A new object, or throws an exception if creation failed.\n   56          */\n   57:         static SharedPtr create(std::shared_ptr<Device> device, const Scene::SharedPtr& pScene, const std::string& filename, const std::string& vsEntry, const std::string& psEntry, const Program::DefineList& programDefines = Program::DefineList());\n   58  \n   59          /** Render the scene into the dst FBO\n   ..\n   73          const Scene::SharedPtr& getScene() const { return mpScene; }\n   74       private:\n   75:         RasterScenePass(std::shared_ptr<Device> device, const Scene::SharedPtr& pScene, const Program::Desc& progDesc, const Program::DefineList& programDefines);\n   76          Scene::SharedPtr mpScene;\n   77      };\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraph.cpp:\n   37  const FileDialogFilterVec RenderGraph::kFileExtensionFilters = { { \"py\", \"Render Graph Files\"} };\n   38  \n   39: RenderGraph::SharedPtr RenderGraph::create(std::shared_ptr<Device> device, const std::string& name) {\n   40:     return SharedPtr(new RenderGraph(device, name));\n   41  }\n   42  \n   43: RenderGraph::RenderGraph(std::shared_ptr<Device> device, const std::string& name): mName(name), mpDevice(device) {\n   44      if (gpFramework == nullptr) {\n   45          throw std::runtime_error(\"Can't construct RenderGraph - framework is not initialized\");\n   ..\n  673          return pPass;\n  674      };\n  675:     passClass.ctor(createRenderPass, \"device\"_a, \"name\"_a, \"dict\"_a = pybind11::dict());\n  676  \n  677      const auto& loadPassLibrary = [](std::shared_ptr<Device> pDevice, const std::string& library) {\n  ...\n  679      };\n  680  \n  681:     m.func_(RenderGraphIR::kLoadPassLibrary, loadPassLibrary, \"device\"_a, \"name\"_a);\n  682  \n  683      const auto& updateRenderPass = [](std::shared_ptr<Device> pDevice, const RenderGraph::SharedPtr& pGraph, const std::string& passName, pybind11::dict d) {\n  ...\n  685      };\n  686  \n  687:     graphClass.func_(RenderGraphIR::kUpdatePass, updateRenderPass, \"device\"_a, \"name\"_a, \"dict\"_a);\n  688  }\n  689  \n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraph.h:\n   50          ~RenderGraph();\n   51  \n   52:         std::shared_ptr<Device> device() { return mpDevice; }\n   53  \n   54          /** Create a new render graph.\n   ..\n   56              \\return New object, or throws an exception if creation failed.\n   57          */\n   58:         static SharedPtr create(std::shared_ptr<Device> device, const std::string& name = \"\");\n   59  \n   60          /** Set a scene\n   ..\n  213          friend class RenderGraphCompiler;\n  214  \n  215:         RenderGraph(std::shared_ptr<Device> device, const std::string& name);\n  216          std::string mName;\n  217  \n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraphCompiler.cpp:\n   45  \n   46      // Register the external resources\n   47:     auto pResourcesCache = ResourceCache::create(graph.device());\n   48      for (const auto&[name, pRes] : dependencies.externalResources) pResourcesCache->registerExternalResource(name, pRes);\n   49  \n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraphExe.cpp:\n   32  \n   33      void RenderGraphExe::execute(const Context& ctx) {\n   34:         PROFILE(ctx.pRenderContext->device(), \"RenderGraphExe::execute()\");\n   35  \n   36          for (const auto& pass : mExecutionList) {\n   37:             PROFILE(ctx.pRenderContext->device(), pass.name);\n   38  \n   39              RenderData renderData(pass.name, mpResourceCache, ctx.pGraphDictionary, ctx.defaultTexDims, ctx.defaultTexFormat);\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderPassLibrary.cpp:\n   80          auto it = spInstances.find(pDevice.get());\n   81          if(it != spInstances.end()) {\n   82:             // found device bound pass library\n   83              return *it->second;\n   84          } else {\n   85:             // create pass library for a new device\n   86              auto ret = spInstances.insert(std::pair<Device*, RenderPassLibrary*>(pDevice.get(), new RenderPassLibrary(pDevice)));\n   87              if (ret.second == false) {\n   88:                 logError(\"RenderPassLibrary for device \" + pDevice->getPhysicalDeviceName() + \" already created !!!\");\n   89              } else {\n   90:                 // add built-in passes for provided device\n   91                  addBuiltinPasses(pDevice);\n   92              }\n\n/home/max/dev/Falcor/src/Falcor/RenderPasses/ResolvePass.cpp:\n   46  \n   47  ResolvePass::SharedPtr ResolvePass::create(RenderContext* pRenderContext, const Dictionary& dictionary) {\n   48:     return SharedPtr(new ResolvePass(pRenderContext->device()));\n   49  }\n   50  \n\n/home/max/dev/Falcor/src/Falcor/RenderPasses/Shared/PathTracer/PathData.slang:\n   38  };\n   39  \n   40: // TODO: Move enum to host/device shared header so that we can add validation.\n   41  /** The path flags are currently stored in 11 bits. See `kMaxPathFlagsBits`.\n   42      If all ray bits are zero the path is inactive/terminated.\n\n/home/max/dev/Falcor/src/Falcor/RenderPasses/Shared/PathTracer/PathTracer.h:\n   87  \n   88          // Configuration\n   89:         PathTracerParams                    mSharedParams;                  ///< Host/device shared rendering parameters.\n   90          uint32_t                            mSelectedSampleGenerator = SAMPLE_GENERATOR_DEFAULT;            ///< Which pseudorandom sample generator to use.\n   91          EmissiveLightSamplerType            mSelectedEmissiveSampler = EmissiveLightSamplerType::LightBVH;  ///< Which emissive light sampler to use.\n\n/home/max/dev/Falcor/src/Falcor/RenderPasses/Shared/PathTracer/PathTracerParams.slang:\n   51  };\n   52  \n   53: /** Path tracer parameters. Shared between host and device.\n   54  \n   55      Note that if you add configuration parameters, do not forget to register\n\n/home/max/dev/Falcor/src/Falcor/Scene/Animation/AnimationController.cpp:\n   44          uint32_t float4Count = (uint32_t)mLocalMatrices.size() * 4;\n   45  \n   46:         mpWorldMatricesBuffer = Buffer::createStructured(pScene->device(), sizeof(float4), float4Count, Resource::BindFlags::ShaderResource, Buffer::CpuAccess::None, nullptr, false);\n   47          mpPrevWorldMatricesBuffer = mpWorldMatricesBuffer;\n   48:         mpInvTransposeWorldMatricesBuffer = Buffer::createStructured(pScene->device(), sizeof(float4), float4Count, Resource::BindFlags::ShaderResource, Buffer::CpuAccess::None, nullptr, false);\n   49          createSkinningPass(staticVertexData, dynamicVertexData);\n   50      }\n   ..\n   70  \n   71      bool AnimationController::animate(RenderContext* pContext, double currentTime) {\n   72:         PROFILE(pContext->device(), \"animate\");\n   73  \n   74          mMatricesChanged.assign(mMatricesChanged.size(), false);\n   ..\n  189          if (mActiveAnimationCount) {\n  190              if (mpWorldMatricesBuffer == mpPrevWorldMatricesBuffer) {\n  191:                 mpPrevWorldMatricesBuffer = Buffer::createStructured(mpScene->device(), sizeof(float4), mpWorldMatricesBuffer->getElementCount(), Resource::BindFlags::ShaderResource, Buffer::CpuAccess::None, nullptr, false);\n  192              }\n  193          }\n  ...\n  214              mInvTransposeSkinningMatrices.resize(mSkinningMatrices.size());\n  215  \n  216:             mpSkinningPass = ComputePass::create(mpScene->device(), \"Scene/Animation/Skinning.slang\");\n  217              auto block = mpSkinningPass->getVars()[\"gData\"];\n  218              block[\"skinnedVertices\"] = pVB;\n  ...\n  220  \n  221              auto createBuffer = [&](const std::string& name, const auto& initData) {\n  222:                 auto pBuffer = Buffer::createStructured(mpScene->device(), block[name], (uint32_t)initData.size(), ResourceBindFlags::ShaderResource, Buffer::CpuAccess::None, nullptr, false);\n  223                  pBuffer->setBlob(initData.data(), 0, pBuffer->getSize());\n  224                  block[name] = pBuffer;\n  ...\n  230              assert(mSkinningMatrices.size() * 4 < UINT32_MAX);\n  231              uint32_t float4Count = (uint32_t)mSkinningMatrices.size() * 4;\n  232:             mpSkinningMatricesBuffer = Buffer::createStructured(mpScene->device(), sizeof(float4), float4Count, ResourceBindFlags::ShaderResource, Buffer::CpuAccess::None, nullptr, false);\n  233:             mpInvTransposeSkinningMatricesBuffer = Buffer::createStructured(mpScene->device(), sizeof(float4), float4Count, ResourceBindFlags::ShaderResource, Buffer::CpuAccess::None, nullptr, false);\n  234              block[\"boneMatrices\"].setBuffer(mpSkinningMatricesBuffer);\n  235              block[\"inverseTransposeBoneMatrices\"].setBuffer(mpInvTransposeSkinningMatricesBuffer);\n\n/home/max/dev/Falcor/src/Falcor/Scene/Camera/CameraData.slang:\n   31  BEGIN_NAMESPACE_FALCOR\n   32  \n   33: /** This is a host/device structure that describes a camera.\n   34  */\n   35  struct CameraData\n\n/home/max/dev/Falcor/src/Falcor/Scene/Lights/LightData.slang:\n   43  };\n   44  \n   45: /** This is a host/device structure that describes analytic light sources.\n   46  */\n   47  struct LightData\n\n/home/max/dev/Falcor/src/Falcor/Scene/Lights/LightProbe.cpp:\n   76  \n   77          Texture::SharedPtr integrateSpecularLD(RenderContext* pContext, const Texture::SharedPtr& pTexture, uint32_t size, ResourceFormat format, uint32_t sampleCount) {\n   78:             std::shared_ptr<Device> device = pContext->device();\n   79  \n   80              mpSpecularLDPass[\"gInputTex\"] = pTexture;\n   81              mpSpecularLDPass[\"DataCB\"][\"gSampleCount\"] = sampleCount;\n   82  \n   83:             Texture::SharedPtr pOutput = Texture::create2D(device, size, size, format, 1, Texture::kMaxPossible, nullptr, Resource::BindFlags::ShaderResource | Resource::BindFlags::RenderTarget);\n   84  \n   85              // Execute on each mip level\n   86              uint32_t mipCount = pOutput->getMipCount();\n   87              for (uint32_t i = 0; i < mipCount; i++) {\n   88:                 Fbo::SharedPtr pFbo = Fbo::create(device);\n   89                  pFbo->attachColorTarget(pOutput, 0, i);\n   90  \n   ..\n  100  \n  101          Texture::SharedPtr executeSingleMip(RenderContext* pContext, const FullScreenPass::SharedPtr& pPass, const Texture::SharedPtr& pTexture, uint32_t size, ResourceFormat format, uint32_t sampleCount) {\n  102:             std::shared_ptr<Device> device = pContext->device();\n  103  \n  104              pPass[\"gInputTex\"] = pTexture;\n  ...\n  106  \n  107              // Output texture\n  108:             Fbo::SharedPtr pFbo = Fbo::create2D(device, size, size, Fbo::Desc(device).setColorTarget(0, format));\n  109  \n  110              // Execute\n  ...\n  129          if (sIntegration.isInitialized() == false) {\n  130              assert(sLightProbeCount == 0);\n  131:             sIntegration.init(pContext->device());\n  132              sSharedResources.dfgTexture = sIntegration.integrateDFG(pContext, pTexture, 128, ResourceFormat::RGBA16Float, 128);\n  133:             sSharedResources.dfgSampler = Sampler::create(pContext->device(), Sampler::Desc().setFilterMode(Sampler::Filter::Point, Sampler::Filter::Point, Sampler::Filter::Point).setAddressingMode(Sampler::AddressMode::Clamp, Sampler::AddressMode::Clamp, Sampler::AddressMode::Clamp));\n  134          }\n  135  \n  ...\n  151  \n  152      LightProbe::SharedPtr LightProbe::create(RenderContext* pContext, const std::string& filename, bool loadAsSrgb, ResourceFormat overrideFormat, uint32_t diffSampleCount, uint32_t specSampleCount, uint32_t diffSize, uint32_t specSize, ResourceFormat preFilteredFormat) {\n  153:         std::shared_ptr<Device> device = pContext->device();\n  154          \n  155:         assert(device);\n  156          \n  157          Texture::SharedPtr pTexture;\n  158          if (overrideFormat != ResourceFormat::Unknown) {\n  159:             Texture::SharedPtr pOrigTex = Texture::createFromFile(device, filename, false, loadAsSrgb);\n  160              if (pOrigTex) {\n  161:                 pTexture = Texture::create2D(device, pOrigTex->getWidth(), pOrigTex->getHeight(), overrideFormat, 1, Texture::kMaxPossible, nullptr, Resource::BindFlags::RenderTarget | Resource::BindFlags::ShaderResource);\n  162                  pTexture->setSourceFilename(pOrigTex->getSourceFilename());\n  163:                 device->getRenderContext()->blit(pOrigTex->getSRV(0, 1, 0, 1), pTexture->getRTV(0, 0, 1));\n  164:                 pTexture->generateMips(device->getRenderContext());\n  165              }\n  166          } else {\n  167:             pTexture = Texture::createFromFile(device, filename, true, loadAsSrgb);\n  168          }\n  169  \n\n/home/max/dev/Falcor/src/Falcor/Scene/Lights/LightProbeData.slang:\n   36  #endif\n   37  \n   38: /** This is a host/device structure that describes light probe resources.\n   39  */\n   40  struct LightProbeResources\n   ..\n   46  };\n   47  \n   48: /** This is a host/device structure that describes shared light probe resources.\n   49  */\n   50  struct LightProbeSharedResources\n   ..\n   54  };\n   55  \n   56: /** This is a host/device structure that describes light probe data.\n   57  */\n   58  struct LightProbeData\n\n/home/max/dev/Falcor/src/Falcor/Scene/Material/MaterialData.slang:\n   37  #endif\n   38  \n   39: /** This is a host/device structure that describes material resources.\n   40  */\n   41  struct MaterialResources\n   ..\n   53  };\n   54  \n   55: /** This is a host/device structure that describes a material.\n   56  */\n   57  struct MaterialData\n\n/home/max/dev/Falcor/src/Falcor/Scene/ParticleSystem/ParticleSystem.cpp:\n   51      {\n   52  \n   53:         std::shared_ptr<Device> device = pCtx->device();\n   54  \n   55          mShouldSort = sorted;\n   ..\n   60          if (mShouldSort) {\n   61              mMaxParticles = (uint32_t)pow(2, (std::ceil(log2((float)maxParticles))));\n   62:             initSortResources(device);\n   63              defineList.add(\"_SORT\");\n   64          } else {\n   ..\n   66          }\n   67          //compute cs\n   68:         ComputeProgram::SharedPtr pSimulateCs = ComputeProgram::createFromFile(device, simulateComputeShader, \"main\", defineList);\n   69  \n   70          //get num sim threads, required as a define for emit cs\n   ..\n   77          Program::DefineList emitDefines;\n   78          emitDefines.add(\"_SIMULATE_THREADS\", std::to_string(mSimulateThreads));\n   79:         ComputeProgram::SharedPtr pEmitCs = ComputeProgram::createFromFile(device, kEmitShader, \"main\", emitDefines);\n   80  \n   81          //draw shader\n   82          GraphicsProgram::Desc d(kVertexShader);\n   83          d.vsEntry(\"main\").addShaderLibrary(drawPixelShader).psEntry(\"main\");\n   84:         GraphicsProgram::SharedPtr pDrawProgram = GraphicsProgram::create(device, d, defineList);\n   85  \n   86          //ParticlePool\n   87:         mpParticlePool = Buffer::createStructured(device, pEmitCs.get(), \"particlePool\", mMaxParticles);\n   88  \n   89          //emitList\n   90:         mpEmitList = Buffer::createStructured(device, pEmitCs.get(), \"emitList\", mMaxEmitPerFrame);\n   91  \n   92          //Dead List\n   93:         mpDeadList = Buffer::createStructured(device, pEmitCs.get(), \"deadList\", mMaxParticles);\n   94  \n   95          // Init data in dead list buffer\n   ..\n  102  \n  103          // Alive list\n  104:         mpAliveList = Buffer::createStructured(device, pSimulateCs.get(), \"aliveList\", mMaxParticles);\n  105  \n  106          // Indirect args\n  107          Resource::BindFlags indirectBindFlags = Resource::BindFlags::IndirectArg | Resource::BindFlags::UnorderedAccess;\n  108:         mpIndirectArgs = Buffer::createStructured(device, pSimulateCs.get(), \"drawArgs\", 1, indirectBindFlags);\n  109  \n  110          //initialize the first member of the args, vert count per instance, to be 4 for particle billboards\n  ...\n  114          //Vars\n  115          //emit\n  116:         mEmitResources.pVars = ComputeVars::create(device, pEmitCs->getReflector());\n  117          mEmitResources.pVars->setBuffer(\"deadList\", mpDeadList);\n  118          mEmitResources.pVars->setBuffer(\"particlePool\", mpParticlePool);\n  ...\n  120          mEmitResources.pVars->setBuffer(\"numAlive\", mpAliveList->getUAVCounter());\n  121          //simulate\n  122:         mSimulateResources.pVars = ComputeVars::create(device, pSimulateCs->getReflector());\n  123          mSimulateResources.pVars->setBuffer(\"deadList\", mpDeadList);\n  124          mSimulateResources.pVars->setBuffer(\"particlePool\", mpParticlePool);\n  ...\n  135  \n  136          //draw\n  137:         mDrawResources.pVars = GraphicsVars::create(device, pDrawProgram->getReflector());\n  138          mDrawResources.pVars->setBuffer(\"aliveList\", mpAliveList);\n  139          mDrawResources.pVars->setBuffer(\"particlePool\", mpParticlePool);\n  140  \n  141          //State\n  142:         mEmitResources.pState = ComputeState::create(device);\n  143          mEmitResources.pState->setProgram(pEmitCs);\n  144:         mSimulateResources.pState = ComputeState::create(device);\n  145          mSimulateResources.pState->setProgram(pSimulateCs);\n  146:         mDrawResources.pState = GraphicsState::create(device);\n  147          mDrawResources.pState->setProgram(pDrawProgram);\n  148  \n\n/home/max/dev/Falcor/src/Falcor/Scene/Scene.cpp:\n  146  \n  147  void Scene::render(RenderContext* pContext, GraphicsState* pState, GraphicsVars* pVars, RenderFlags flags) {\n  148:     PROFILE(pContext->device(), \"renderScene\");\n  149  \n  150      pState->setVao(mpVao);\n\n/home/max/dev/Falcor/src/Falcor/Scene/Scene.h:\n  126          };\n  127  \n  128:         std::shared_ptr<Device> device() { return mpDevice; }\n  129  \n  130          /** Access the scene's camera to change properties, or use elsewhere.\n\n/home/max/dev/Falcor/src/Falcor/Testing/UnitTest.h:\n   99      class dlldecl GPUUnitTestContext : public UnitTestContext {\n  100       public:\n  101:         GPUUnitTestContext(RenderContext* pContext) : mpContext(pContext) { mpDevice = pContext->device(); }\n  102  \n  103          /** createProgram creates a compute program from the source code at the\n\n/home/max/dev/Falcor/src/Falcor/Utils/Algorithm/BitonicSort.cpp:\n   53  \n   54      bool BitonicSort::execute(RenderContext* pRenderContext, Buffer::SharedPtr pData, uint32_t totalSize, uint32_t chunkSize, uint32_t groupSize) {\n   55:         PROFILE(pRenderContext->device(), \"BitonicSort::execute\");\n   56  \n   57          // Validate inputs.\n\n/home/max/dev/Falcor/src/Falcor/Utils/Algorithm/ComputeParallelReduction.cpp:\n   67      template<typename T>\n   68      bool ComputeParallelReduction::execute(RenderContext* pRenderContext, const Texture::SharedPtr& pInput, Type operation, T* pResult, Buffer::SharedPtr pResultBuffer, uint64_t resultOffset) {\n   69:         PROFILE(pRenderContext->device(), \"ComputeParallelReduction::execute\");\n   70  \n   71          // Check texture array/mip/sample count.\n\n/home/max/dev/Falcor/src/Falcor/Utils/Algorithm/ParallelReductionType.slangh:\n   28  #pragma once\n   29  \n   30: // Type defines shared between host and device.\n   31  #define FORMAT_TYPE_UNKNOWN 0\n   32  #define FORMAT_TYPE_FLOAT   1\n\n/home/max/dev/Falcor/src/Falcor/Utils/Algorithm/PrefixSum.cpp:\n   62  \n   63  bool PrefixSum::execute(RenderContext* pRenderContext, Buffer::SharedPtr pData, uint32_t elementCount, uint32_t* pTotalSum, Buffer::SharedPtr pTotalSumBuffer, uint64_t pTotalSumOffset) {\n   64:     PROFILE(pRenderContext->device(), \"PrefixSum::execute\");\n   65  \n   66      assert(pRenderContext);\n\n/home/max/dev/Falcor/src/Falcor/Utils/Color/ColorHelpers.slang:\n   31  BEGIN_NAMESPACE_FALCOR\n   32  \n   33: /** This file contains host/device shared color utility functions.\n   34  */\n   35  \n\n/home/max/dev/Falcor/src/Falcor/Utils/Math/BitTricks.slang:\n   34      So, deinterleave_16bit(interleave_16bit(x)) == x should hold true.\n   35  \n   36:     TODO: Make this a host/device shared header, ensure code compiles on the host.\n   37      TODO: Add optimized 8-bit and 2x8-bit interleaving functions.\n   38      TODO: Use NvApi intrinsics to optimize the code on NV.\n\n/home/max/dev/Falcor/src/Falcor/Utils/Timing/Profiler.cpp:\n   45      using DeviceProfilerEvents = std::unordered_map<std::string, Profiler::EventData*>;\n   46  \n   47:     std::unordered_map<Profiler::DeviceEventKey, Profiler::EventData*, Profiler::device_event_key_hash> Profiler::sProfilerEvents;\n   48      std::vector<Profiler::EventData*> Profiler::sRegisteredEvents;\n   49      std::string curEventName = \"\";\n\n/home/max/dev/Falcor/src/Falcor/Utils/Timing/Profiler.h:\n   57      typedef std::pair<uint8_t, std::string> DeviceEventKey;\n   58  \n   59:     struct device_event_key_hash    {\n   60          template <class T1, class T2>\n   61          std::size_t operator() (const std::pair<T1, T2> &pair) const {\n   ..\n  161      static double getCpuTime(const EventData* pData);\n  162  \n  163:     static std::unordered_map<DeviceEventKey, EventData*, device_event_key_hash> sProfilerEvents;\n  164      static std::vector<EventData*> sRegisteredEvents;\n  165      static uint32_t sCurrentLevel;\n  ...\n  188  #if _PROFILING_ENABLED\n  189  // Profiling enabled\n  190: #define PROFILE_ALL_FLAGS(_device, _name) Falcor::ProfilerEvent _profileEvent##__LINE__(_device, _name)\n  191: #define PROFILE_SOME_FLAGS(_device, _name, _flags) Falcor::ProfilerEvent _profileEvent##__LINE__(_device, _name, _flags)\n  192  \n  193  #define GET_PROFILE(_1, _2, _3, NAME, ...) NAME\n  ...\n  195  #else\n  196  // Profiling disabled\n  197: #define PROFILE(_device, _name)\n  198  #endif\n  199  \n\n/home/max/dev/Falcor/src/Falcor/Utils/UI/Gui.cpp:\n  147  \n  148      void GuiImpl::init(Gui* pGui, float scaleFactor) {\n  149:         mpDevice = pGui->device();\n  150  \n  151          mScaleFactor = scaleFactor;\n\n/home/max/dev/Falcor/src/Falcor/Utils/UI/Gui.h:\n  478          };\n  479  \n  480:         std::shared_ptr<Device> device() { return mpDevice; }\n  481  \n  482          /** Create a new GUI object. Each object is essentially a container for a GUI window\n\n/home/max/dev/Falcor/src/Mogwai/Extensions/Capture/FrameCapture.cpp:\n  147          if (!pGraph) return;\n  148          uint64_t frameID = gpFramework->getClock().getFrame();\n  149:         triggerFrame(mpRenderer->device()->getRenderContext(), pGraph, frameID);\n  150      }\n  151  \n\n/home/max/dev/Falcor/src/Mogwai/Extensions/Capture/VideoCapture.cpp:\n   90                  auto res = msgBox(\"Trying to record graph output \" + outputName + \" but the resource format is not supported by the video encoder.\\nWould you like to capture the output as an RGBA8Srgb resource?\\n\\nFor HDR textures, this operation will clamp the results\", MsgBoxType::YesNo);\n   91                  if(res == MsgBoxButton::No) continue;\n   92:                 encoder.pBlitTex = createTextureForBlit(mpRenderer->device(), pTex.get());\n   93                  pTex = encoder.pBlitTex;\n   94              }\n\n/home/max/dev/Falcor/src/Mogwai/Mogwai.cpp:\n  589          // offscreen renderer\n  590          auto pNullWindow = Falcor::Window::SharedPtr(nullptr);\n  591:         IRenderer::UniquePtr pRenderer = std::make_unique<Mogwai::Renderer>(Device::create(pNullWindow, config.deviceDesc));\n  592  \n  593          ArgList args;\n\n/home/max/dev/Falcor/src/Mogwai/Mogwai.h:\n   96      Renderer(Falcor::Device::SharedPtr pDevice);\n   97  \n   98:     Falcor::Device::SharedPtr device() { return mpDevice; }\n   99:     Falcor::Device::SharedPtr device() const { return mpDevice; }\n  100  \n  101      void onLoad(RenderContext* pRenderContext) override;\n\n/home/max/dev/Falcor/src/Mogwai/MogwaiSettings.cpp:\n  194          file.separator();\n  195          if (file.item(\"Reload Render-Passes\", \"F5\")) {\n  196:             RenderPassLibrary::instance(mpRenderer->device()).reloadLibraries(gpFramework->getRenderContext());\n  197          }\n  198  \n\n/home/max/dev/Falcor/src/RenderPasses/AccumulatePass/AccumulatePass.cpp:\n   65  \n   66  AccumulatePass::SharedPtr AccumulatePass::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   67:     return SharedPtr(new AccumulatePass(pRenderContext->device(), dict));\n   68  }\n   69  \n\n/home/max/dev/Falcor/src/RenderPasses/Antialiasing/FXAA/FXAA.cpp:\n   53  \n   54  FXAA::SharedPtr FXAA::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   55:     SharedPtr pFXAA = SharedPtr(new FXAA(pRenderContext->device()));\n   56      for (const auto& v : dict) {\n   57          if (v.key() == kQualitySubPix) pFXAA->mQualitySubPix = v.val();\n\n/home/max/dev/Falcor/src/RenderPasses/Antialiasing/TAA/TAA.cpp:\n   51  \n   52  TAA::SharedPtr TAA::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   53:     SharedPtr pTAA = SharedPtr(new TAA(pRenderContext->device()));\n   54      for (const auto& v : dict) {\n   55          if (v.key() == kAlpha) pTAA->mControls.alpha = v.val();\n\n/home/max/dev/Falcor/src/RenderPasses/BlitPass/BlitPass.cpp:\n   64  \n   65  BlitPass::SharedPtr BlitPass::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   66:     return SharedPtr(new BlitPass(pRenderContext->device(), dict));\n   67  }\n   68  \n\n/home/max/dev/Falcor/src/RenderPasses/BSDFViewer/BSDFViewer.cpp:\n   48  \n   49  BSDFViewer::SharedPtr BSDFViewer::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   50:     return SharedPtr(new BSDFViewer(pRenderContext->device(), dict));\n   51  }\n   52  \n\n/home/max/dev/Falcor/src/RenderPasses/BSDFViewer/BSDFViewerParams.slang:\n   31  BEGIN_NAMESPACE_FALCOR\n   32  \n   33: /** BSDFViewer parameters shared between host and device.\n   34      Make sure struct layout follows the HLSL packing rules as it is uploaded as a memory blob.\n   35      Do not use bool's as they are 1 byte in Visual Studio, 4 bytes in HLSL.\n\n/home/max/dev/Falcor/src/RenderPasses/CSM/CSM.cpp:\n  238  \n  239  CSM::SharedPtr CSM::create(RenderContext* pRenderContext, const Dictionary& dict) {\n  240:     auto pCSM = SharedPtr(new CSM(pRenderContext->device()));\n  241      for (const auto& v : dict) {\n  242          if (v.key() == kMapSize) pCSM->mMapSize = (uint2)v.val();\n\n/home/max/dev/Falcor/src/RenderPasses/DebugPasses/InvalidPixelDetectionPass/InvalidPixelDetectionPass.cpp:\n   41  \n   42  InvalidPixelDetectionPass::SharedPtr InvalidPixelDetectionPass::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   43:     SharedPtr pPass = SharedPtr(new InvalidPixelDetectionPass(pRenderContext->device()));\n   44      return pPass;\n   45  }\n\n/home/max/dev/Falcor/src/RenderPasses/DebugPasses/SideBySidePass/SideBySidePass.cpp:\n   42  \n   43  SideBySidePass::SharedPtr SideBySidePass::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   44:     SharedPtr pPass = SharedPtr(new SideBySidePass(pRenderContext->device()));\n   45      for (const auto& v : dict) {\n   46          if (v.key() == kImageLeftBound) pPass->mImageLeftBound = v.val();\n\n/home/max/dev/Falcor/src/RenderPasses/DebugPasses/SplitScreenPass/SplitScreenPass.cpp:\n   64  \n   65  SplitScreenPass::SharedPtr SplitScreenPass::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   66:     SharedPtr pPass = SharedPtr(new SplitScreenPass(pRenderContext->device()));\n   67      for (const auto& v : dict) {\n   68          if (!pPass->parseKeyValuePair(v.key(), v.val())) {\n\n/home/max/dev/Falcor/src/RenderPasses/DepthPass/DepthPass.cpp:\n   64  \n   65  DepthPass::SharedPtr DepthPass::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   66:     return SharedPtr(new DepthPass(pRenderContext->device(), dict));\n   67  }\n   68  \n\n/home/max/dev/Falcor/src/RenderPasses/ErrorMeasurePass/ErrorMeasurePass.cpp:\n   74  \n   75  ErrorMeasurePass::SharedPtr ErrorMeasurePass::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   76:     return SharedPtr(new ErrorMeasurePass(pRenderContext->device(), dict));\n   77  }\n   78  \n\n/home/max/dev/Falcor/src/RenderPasses/ForwardLightingPass/ForwardLightingPass.cpp:\n   54  \n   55  ForwardLightingPass::SharedPtr ForwardLightingPass::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   56:     auto pThis = SharedPtr(new ForwardLightingPass(pRenderContext->device()));\n   57      pThis->setColorFormat(ResourceFormat::RGBA32Float).setMotionVecFormat(ResourceFormat::RG16Float).setNormalMapFormat(ResourceFormat::RGBA8Unorm).setSampleCount(1).usePreGeneratedDepthBuffer(true);\n   58  \n   ..\n  111      if (mpScene) mpState->getProgram()->addDefines(mpScene->getSceneDefines());\n  112  \n  113:     mpVars = GraphicsVars::create(pRenderContext->device(), mpState->getProgram()->getReflector());\n  114  \n  115      Sampler::Desc samplerDesc;\n  116      samplerDesc.setFilterMode(Sampler::Filter::Linear, Sampler::Filter::Linear, Sampler::Filter::Linear);\n  117:     setSampler(Sampler::create(pRenderContext->device(), samplerDesc));\n  118  }\n  119  \n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/GBuffer/GBufferParams.slang:\n   31  BEGIN_NAMESPACE_FALCOR\n   32  \n   33: /** Constants shared between host and device.\n   34      Make sure struct layout follows the HLSL packing rules as it is uploaded as a memory blob.\n   35      Do not use bool's as they are 1 byte in Visual Studio, 4 bytes in HLSL.\n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/GBuffer/GBufferRaster.cpp:\n   76  \n   77  GBufferRaster::SharedPtr GBufferRaster::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   78:     return SharedPtr(new GBufferRaster(pRenderContext->device(), dict));\n   79  }\n   80  \n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/VBuffer/VBufferRaster.cpp:\n   51  \n   52  VBufferRaster::SharedPtr VBufferRaster::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   53:     return SharedPtr(new VBufferRaster(pRenderContext->device(), dict));\n   54  }\n   55  \n\n/home/max/dev/Falcor/src/RenderPasses/ImageLoader/ImageLoader.cpp:\n   55  \n   56  ImageLoader::SharedPtr ImageLoader::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   57:     SharedPtr pPass = SharedPtr(new ImageLoader(pRenderContext->device()));\n   58  \n   59      for (const auto& v : dict) {\n   ..\n   67  \n   68      if (pPass->mImageName.size()) {\n   69:         pPass->mpTex = Texture::createFromFile(pRenderContext->device(), pPass->mImageName, pPass->mGenerateMips, pPass->mLoadSRGB);\n   70      }\n   71  \n   ..\n  115      if (reloadImage && mImageName.size()) {\n  116          mImageName = stripDataDirectories(mImageName);\n  117:         mpTex = Texture::createFromFile(widget.gui()->device(), mImageName, mGenerateMips, mLoadSRGB);\n  118      }\n  119  }\n\n/home/max/dev/Falcor/src/RenderPasses/PixelInspectorPass/PixelInspectorPass.cpp:\n   62  \n   63  PixelInspectorPass::SharedPtr PixelInspectorPass::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   64:     return SharedPtr(new PixelInspectorPass(pRenderContext->device()));\n   65  }\n   66  \n\n/home/max/dev/Falcor/src/RenderPasses/SkyBox/SkyBox.cpp:\n   93  \n   94  SkyBox::SharedPtr SkyBox::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   95:     SharedPtr pSkyBox = SharedPtr(new SkyBox(pRenderContext->device()));\n   96      for (const auto& v : dict) {\n   97          if (v.key() == kTexName) {\n   ..\n  106      std::shared_ptr<Texture> pTexture;\n  107      if (pSkyBox->mTexName.size() != 0) {\n  108:         pTexture = Texture::createFromFile(pRenderContext->device(), pSkyBox->mTexName, false, pSkyBox->mLoadSrgb);\n  109          if (pTexture == nullptr) throw std::runtime_error(\"SkyBox::create - Error creating texture from file\");\n  110          pSkyBox->setTexture(pTexture);\n\n/home/max/dev/Falcor/src/RenderPasses/SSAO/SSAO.cpp:\n   97  \n   98  SSAO::SharedPtr SSAO::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   99:     SharedPtr pSSAO = SharedPtr(new SSAO(pRenderContext->device()));\n  100      Dictionary blurDict;\n  101      for (const auto& v : dict) {\n\n/home/max/dev/Falcor/src/RenderPasses/SVGFPass/SVGFPass.cpp:\n   84  \n   85  SVGFPass::SharedPtr SVGFPass::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   86:     return SharedPtr(new SVGFPass(pRenderContext->device(), dict));\n   87  }\n   88  \n\n/home/max/dev/Falcor/src/RenderPasses/TemporalDelayPass/TemporalDelayPass.cpp:\n   55  \n   56  TemporalDelayPass::SharedPtr TemporalDelayPass::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   57:     SharedPtr pPass = SharedPtr(new TemporalDelayPass(pRenderContext->device()));\n   58      for (const auto& v : dict) {\n   59          if (v.key() == kDelay) pPass->mDelay = (uint32_t) v.val();\n\n/home/max/dev/Falcor/src/RenderPasses/ToneMapper/ToneMapper.cpp:\n  127      if (dict.keyExists(kOutputFormat)) outputFormat = dict[kOutputFormat];\n  128  \n  129:     ToneMapper* pTM = new ToneMapper(pRenderContext->device(), Operator::Aces, outputFormat);\n  130  \n  131      try {\n\n/home/max/dev/Falcor/src/RenderPasses/ToneMapper/ToneMapperParams.slang:\n   66  #endif\n   67  \n   68: /** Tone mapper parameters shared between host and device.\n   69      Make sure struct layout follows the HLSL packing rules as it is uploaded as a memory blob.\n   70      Do not use bool's as they are 1 byte in Visual Studio, 4 bytes in HLSL.\n\n/home/max/dev/Falcor/src/RenderPasses/Utils/Composite/Composite.cpp:\n   43  \n   44  Composite::SharedPtr Composite::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   45:     return SharedPtr(new Composite(pRenderContext->device(), dict));\n   46  }\n   47  \n\n/home/max/dev/Falcor/src/RenderPasses/Utils/GaussianBlur/GaussianBlur.cpp:\n   56  \n   57  GaussianBlur::SharedPtr GaussianBlur::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   58:     SharedPtr pBlur = SharedPtr(new GaussianBlur(pRenderContext->device()));\n   59      for (const auto& v : dict) {\n   60          if (v.key() == kKernelWidth) pBlur->mKernelWidth = v.val();\n\n/home/max/dev/Falcor/src/Samples/CudaInterop/FalcorCUDA.cpp:\n  110  \n  111      uint32_t gNodeMask;\n  112:     CUdevice  gCudaDevice;\n  113      CUcontext gCudaContext;\n  114      CUstream  gCudaStream;\n\n/home/max/dev/Falcor/src/Samples/ShaderToy/ShaderToy.cpp:\n   99      config.windowDesc.width = 1280;\n  100      config.windowDesc.height = 720;\n  101:     config.deviceDesc.enableVsync = true;\n  102      config.windowDesc.resizableWindow = true;\n  103      config.windowDesc.title = \"Falcor Shader Toy\";\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Utils/MathHelpersTests.cpp:\n  116              // Generate test data.\n  117              std::vector<BBoxTestCase> testCases;\n  118:             std::random_device rd;\n  119              std::mt19937 gen(rd());\n  120              std::uniform_real_distribution<> posAndNegDist(-100.f, 100.f);\n\n/home/max/dev/Falcor/src/USD/hgiVk/blitEncoder.cpp:\n    2  #include \"USD/hgiVk/commandBuffer.h\"\n    3  #include \"USD/hgiVk/conversions.h\"\n    4: #include \"USD/hgiVk/device.h\"\n    5  #include \"USD/hgiVk/diagnostic.h\"\n    6  #include \"USD/hgiVk/renderPass.h\"\n    .\n   13  \n   14  HgiVkBlitEncoder::HgiVkBlitEncoder(\n   15:     HgiVkDevice* device,\n   16      HgiVkCommandBuffer* cmdBuf)\n   17      : HgiBlitEncoder()\n   18:     , _device(device)\n   19      , _commandBuffer(cmdBuf)\n   20      , _isRecording(true)\n   ..\n   65      // need to submit it immediately and wait for it to complete so that the\n   66      // CPU can read the pixels data.\n   67:     HgiVkCommandPool cp(_device);\n   68:     HgiVkCommandBuffer cb(_device, &cp, HgiVkCommandBufferUsagePrimary);\n   69      VkCommandBuffer vkCmdBuf = cb.GetCommandBufferForRecoding();\n   70  \n   ..\n   76      dstDesc.data = nullptr;\n   77  \n   78:     HgiVkBuffer dstBuffer(_device, dstDesc);\n   79  \n   80      // Setup info to copy data form gpu texture to gpu buffer\n   ..\n  142      TF_VERIFY(\n  143          vkCreateFence(\n  144:             _device->GetVulkanDevice(),\n  145              &fenceInfo,\n  146              HgiVkAllocator(),\n  ...\n  154      submitInfo.pCommandBuffers = &vkCmdBuf;\n  155      submitInfos.emplace_back(std::move(submitInfo));\n  156:     _device->SubmitToQueue(submitInfos, vkFence);\n  157  \n  158      // Wait for the copy from GPU to CPU to complete.\n  ...\n  160      TF_VERIFY(\n  161          vkWaitForFences(\n  162:             _device->GetVulkanDevice(),\n  163              1,\n  164              &vkFence,\n  ...\n  167      );\n  168  \n  169:     vkDestroyFence(_device->GetVulkanDevice(), vkFence, HgiVkAllocator());\n  170  \n  171      // Copy the data from gpu buffer to cpu destination buffer\n\n/home/max/dev/Falcor/src/USD/hgiVk/blitEncoder.h:\n   20      HGIVK_API\n   21      HgiVkBlitEncoder(\n   22:         HgiVkDevice* device,\n   23          HgiVkCommandBuffer* cmdBuf);\n   24  \n   ..\n   50  \n   51  private:\n   52:     HgiVkDevice* _device;\n   53      HgiVkCommandBuffer* _commandBuffer;\n   54      bool _isRecording;\n\n/home/max/dev/Falcor/src/USD/hgiVk/buffer.cpp:\n    4  #include \"USD/hgiVk/commandBuffer.h\"\n    5  #include \"USD/hgiVk/conversions.h\"\n    6: #include \"USD/hgiVk/device.h\"\n    7  #include \"USD/hgiVk/diagnostic.h\"\n    8  \n    .\n   11  \n   12  HgiVkBuffer::HgiVkBuffer(\n   13:     HgiVkDevice* device,\n   14      HgiBufferDesc const& desc)\n   15      : HgiBuffer(desc)\n   16:     , _device(device)\n   17      , _descriptor(desc)\n   18      , _vkBuffer(nullptr)\n   ..\n   44      }\n   45  \n   46: // todo check with device if supported.\n   47      bufCreateInfo.usage |=\n   48          VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR;\n   ..\n   85      TF_VERIFY(\n   86          vmaCreateBuffer(\n   87:             _device->GetVulkanMemoryAllocator(),\n   88              &bufCreateInfo,\n   89              &allocInfo,\n   ..\n   97          TF_VERIFY(\n   98              vmaMapMemory(\n   99:                 _device->GetVulkanMemoryAllocator(),\n  100                  _vmaBufferAllocation,\n  101                  &_dataMapped) == VK_SUCCESS\n  ...\n  112          if (allocInfo.usage != VMA_MEMORY_USAGE_CPU_ONLY) {\n  113              vmaFlushAllocation(\n  114:                 _device->GetVulkanMemoryAllocator(),\n  115                  _vmaBufferAllocation,\n  116                  0, // offset\n  ...\n  128          std::string debugLabel = \"Buffer \" + _descriptor.debugName;\n  129          HgiVkSetDebugName(\n  130:             _device,\n  131              (uint64_t)_vkBuffer,\n  132              VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT,\n  ...\n  139      if (_dataMapped) {\n  140          vmaUnmapMemory(\n  141:             _device->GetVulkanMemoryAllocator(),\n  142              _vmaBufferAllocation);\n  143      }\n  144  \n  145      vmaDestroyBuffer(\n  146:         _device->GetVulkanMemoryAllocator(),\n  147          _vkBuffer,\n  148          _vmaBufferAllocation);\n  ...\n  178      // See also vkFlushMappedMemoryRanges (we don't need another barrier).\n  179      vmaFlushAllocation(\n  180:         _device->GetVulkanMemoryAllocator(),\n  181          _vmaBufferAllocation,\n  182          byteOffset,\n  ...\n  200  HgiVkBuffer::GetBufferAddress() const\n  201  {\n  202:     if (!_device->vkGetBufferDeviceAddressEXT) return 0;\n  203  \n  204      VkBufferDeviceAddressInfoKHR info =\n  ...\n  206      info.buffer = _vkBuffer;\n  207  \n  208:     VkDeviceAddress address = _device->vkGetBufferDeviceAddressEXT(\n  209:         _device->GetVulkanDevice(),\n  210          &info);\n  211  \n\n/home/max/dev/Falcor/src/USD/hgiVk/buffer.h:\n   22      HGIVK_API\n   23      HgiVkBuffer(\n   24:         HgiVkDevice* device,\n   25          HgiBufferDesc const& desc);\n   26  \n   ..\n   69  \n   70  private:\n   71:     HgiVkDevice* _device;\n   72      HgiBufferDesc _descriptor;\n   73      VkBuffer _vkBuffer;\n\n/home/max/dev/Falcor/src/USD/hgiVk/commandBuffer.cpp:\n    7  #include \"USD/hgiVk/commandPool.h\"\n    8  #include \"USD/hgiVk/blitEncoder.h\"\n    9: #include \"USD/hgiVk/device.h\"\n   10  #include \"USD/hgiVk/diagnostic.h\"\n   11  #include \"USD/hgiVk/graphicsEncoder.h\"\n   ..\n   20  \n   21  HgiVkCommandBuffer::HgiVkCommandBuffer(\n   22:     HgiVkDevice* device,\n   23      HgiVkCommandPool* commandPool,\n   24      HgiVkCommandBufferUsage usage)\n   25:     : _device(device)\n   26      , _commandPool(commandPool)\n   27      , _usage(usage)\n   ..\n   45      TF_VERIFY(\n   46          vkAllocateCommandBuffers(\n   47:             device->GetVulkanDevice(),\n   48              &allocateInfo,\n   49              &_vkCommandBuffer) == VK_SUCCESS\n   ..\n   53      // TimeStamp query pool\n   54      //\n   55:     if (_device->GetDeviceSupportTimeStamps()) {\n   56          _timeQueries.reserve(HGIVK_MAX_TIMESTAMPS/2);\n   57  \n   ..\n   63          TF_VERIFY(\n   64              vkCreateQueryPool(\n   65:                 _device->GetVulkanDevice(),\n   66                  &queryPoolInfo,\n   67                  HgiVkAllocator(),\n   ..\n   79      if (_vkTimeStampQueryPool) {\n   80         vkDestroyQueryPool(\n   81:             _device->GetVulkanDevice(),\n   82              _vkTimeStampQueryPool,\n   83              HgiVkAllocator());\n   ..\n   85  \n   86      vkFreeCommandBuffers(\n   87:         _device->GetVulkanDevice(),\n   88          _commandPool->GetVulkanCommandPool(),\n   89          1, // command buffer cnt\n   ..\n  142      std::string debugLabel = \"Command Buffer \" + std::string(name);\n  143      HgiVkSetDebugName(\n  144:         _device,\n  145          (uint64_t)_vkCommandBuffer,\n  146          VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT,\n  ...\n  150          debugLabel = \"Query Pool \" + std::string(name);\n  151          HgiVkSetDebugName(\n  152:             _device,\n  153              (uint64_t)_vkTimeStampQueryPool,\n  154              VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT,\n  ...\n  224  \n  225      VkPhysicalDeviceProperties const& p =\n  226:         _device->GetVulkanPhysicalDeviceProperties();\n  227      float toNanoSec = p.limits.timestampPeriod;\n  228  \n  ...\n  236      for (HgiTimeQuery& query : _timeQueries) {\n  237          vkGetQueryPoolResults(\n  238:             _device->GetVulkanDevice(),\n  239              _vkTimeStampQueryPool,\n  240              query.beginStamp,\n  ...\n  263      // by a thread. So we record all resets into one single command buffer.\n  264  \n  265:     // XXX VK_KHR_performance_query can do it on a device level, which would fit\n  266      // our design much better. But, for now, it is not that well supported.\n  267  \n\n/home/max/dev/Falcor/src/USD/hgiVk/commandBuffer.h:\n   54      HGIVK_API\n   55      HgiVkCommandBuffer(\n   56:         HgiVkDevice* device,\n   57          HgiVkCommandPool* commandPool,\n   58          HgiVkCommandBufferUsage usage);\n   ..\n  118  \n  119  private:\n  120:     HgiVkDevice* _device;\n  121      HgiVkCommandPool* _commandPool;\n  122      HgiVkCommandBufferUsage _usage;\n\n/home/max/dev/Falcor/src/USD/hgiVk/commandBufferManager.cpp:\n    1  #include \"pxr/base/tf/diagnostic.h\"\n    2  #include \"USD/hgiVk/commandBufferManager.h\"\n    3: #include \"USD/hgiVk/device.h\"\n    4  #include \"USD/hgiVk/diagnostic.h\"\n    5  #include \"USD/hgiVk/hgi.h\"\n    .\n   13  \n   14  \n   15: HgiVkCommandBufferManager::HgiVkCommandBufferManager(HgiVkDevice* device)\n   16:     : _device(device)\n   17      , _frame(~0ull)\n   18      , _nextAvailableIndex(0)\n   ..\n   28      TF_VERIFY(\n   29          vkCreateSemaphore(\n   30:             _device->GetVulkanDevice(),\n   31              &semaCreateInfo,\n   32              HgiVkAllocator(),\n   ..\n   53  \n   54      vkDestroySemaphore(\n   55:         _device->GetVulkanDevice(),\n   56          _vkSemaphore, HgiVkAllocator());\n   57  }\n   ..\n  166  \n  167      // Commit all recorded resource and draw commands from all threads.\n  168:     _device->SubmitToQueue(submitInfos, fence);\n  169  \n  170      // Next frame's threads must re-acquire a command buffer, so reset index.\n  ...\n  262  \n  263          HgiVkCommandBuffer* cb = new HgiVkCommandBuffer(\n  264:             _device,\n  265              cp,\n  266              HgiVkCommandBufferUsageSecondaryRenderPass);\n  ...\n  318      std::string debugLabel = \"Semaphore \" + name;\n  319      HgiVkSetDebugName(\n  320:         _device,\n  321          (uint64_t)_vkSemaphore,\n  322          VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT,\n  ...\n  355  \n  356      for (size_t i=currentSize; i<numThreads; i++) {\n  357:         HgiVkCommandPool* cp = new HgiVkCommandPool(_device);\n  358          _commandPools.push_back(cp);\n  359  \n  360          _resourceCommandBuffers.push_back(\n  361              new HgiVkCommandBuffer(\n  362:                 _device,\n  363                  cp,\n  364                  HgiVkCommandBufferUsagePrimary)\n  ...\n  367          _drawCommandBuffers.push_back(\n  368              new HgiVkCommandBuffer(\n  369:                 _device,\n  370                  cp,\n  371                  HgiVkCommandBufferUsagePrimary)\n\n/home/max/dev/Falcor/src/USD/hgiVk/commandBufferManager.h:\n   34      HGIVK_API\n   35      HgiVkCommandBufferManager(\n   36:         HgiVkDevice* device);\n   37  \n   38      HGIVK_API\n   ..\n  116  \n  117  private:\n  118:     HgiVkDevice* _device;\n  119  \n  120      uint64_t _frame;\n\n/home/max/dev/Falcor/src/USD/hgiVk/commandPool.cpp:\n    1  #include \"pxr/base/tf/diagnostic.h\"\n    2  #include \"USD/hgiVk/commandPool.h\"\n    3: #include \"USD/hgiVk/device.h\"\n    4  #include \"USD/hgiVk/diagnostic.h\"\n    5  \n    .\n    8  \n    9  \n   10: HgiVkCommandPool::HgiVkCommandPool(HgiVkDevice* device)\n   11:     : _device(device)\n   12      , _vkCommandPool(nullptr)\n   13  {\n   ..\n   18      // XXX If Graphics and Compute were to come from different queue families we\n   19      // would need to use a different commandpool/buffer for gfx and compute.\n   20:     poolCreateInfo.queueFamilyIndex = device->GetVulkanDeviceQueueFamilyIndex();\n   21  \n   22      TF_VERIFY(\n   23          vkCreateCommandPool(\n   24:             device->GetVulkanDevice(),\n   25              &poolCreateInfo,\n   26              HgiVkAllocator(),\n   ..\n   32  {\n   33      vkDestroyCommandPool(\n   34:         _device->GetVulkanDevice(),\n   35          _vkCommandPool,\n   36          HgiVkAllocator());\n   ..\n   42      TF_VERIFY(\n   43          vkResetCommandPool(\n   44:             _device->GetVulkanDevice(),\n   45              _vkCommandPool,\n   46              0 /*flags*/) == VK_SUCCESS\n   ..\n   59      std::string debugLabel = \"Command Pool \" + name;\n   60      HgiVkSetDebugName(\n   61:         _device,\n   62          (uint64_t)_vkCommandPool,\n   63          VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT,\n\n/home/max/dev/Falcor/src/USD/hgiVk/commandPool.h:\n   23  public:\n   24      HGIVK_API\n   25:     HgiVkCommandPool(HgiVkDevice* device);\n   26  \n   27      HGIVK_API\n   ..\n   46  \n   47  private:\n   48:     HgiVkDevice* _device;\n   49      VkCommandPool _vkCommandPool;\n   50  };\n\n/home/max/dev/Falcor/src/USD/hgiVk/computeEncoder.cpp:\n    1  #include \"USD/hgiVk/computeEncoder.h\"\n    2  \n    3: #include \"USD/hgiVk/device.h\"\n    4  #include \"USD/hgiVk/diagnostic.h\"\n    5  #include \"USD/hgiVk/pipeline.h\"\n    .\n   11  \n   12  HgiVkComputeEncoder::HgiVkComputeEncoder(\n   13:     HgiVkDevice* device,\n   14      HgiVkCommandBuffer* cb)\n   15      : HgiComputeEncoder()\n   16:     , _device(device)\n   17      , _commandBuffer(_commandBuffer)\n   18      , _isRecording(true)\n\n/home/max/dev/Falcor/src/USD/hgiVk/computeEncoder.h:\n   25      HGIVK_API\n   26      HgiVkComputeEncoder(\n   27:         HgiVkDevice* device,\n   28          HgiVkCommandBuffer* cb);\n   29  \n   ..\n   60  \n   61  private:\n   62:     HgiVkDevice* _device;\n   63      HgiVkCommandBuffer* _commandBuffer;\n   64      bool _isRecording;\n\n/home/max/dev/Falcor/src/USD/hgiVk/device.cpp:\n    2  #include \"pxr/base/tf/envSetting.h\"\n    3  \n    4: #include \"USD/hgiVk/device.h\"\n    5  #include \"USD/hgiVk/diagnostic.h\"\n    6  #include \"USD/hgiVk/hgi.h\"\n    .\n   64  HgiVkDevice::HgiVkDevice(\n   65      HgiVkInstance* instance,\n   66:     HgiVkDeviceSettings deviceType)\n   67      : _vmaAllocator(nullptr)\n   68      , _vkPhysicalDevice(nullptr)\n   ..\n   79  {\n   80      //\n   81:     // Determine physical device\n   82      //\n   83  \n   ..\n  106          if (familyIndex == VK_QUEUE_FAMILY_IGNORED) continue;\n  107  \n  108:         if (deviceType == HgiVkPresentationType) {\n  109              if (!_SupportsPresentation(physicalDevices[i], familyIndex)) {\n  110                  continue;\n  111              }\n  112          } else {\n  113:             TF_CODING_ERROR(\"VULKAN_ERROR: Unknown device type requested\");\n  114          }\n  115  \n  116          if (props.apiVersion < VK_API_VERSION_1_0) continue;\n  117  \n  118:         if (!discrete && props.deviceType==VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU){\n  119              discrete = physicalDevices[i];\n  120              discreteTimeStamps = timeStamps;\n  ...\n  142  \n  143          #if defined(_DEBUG)\n  144:             TF_WARN(\"Selected GPU %s\", _vkDeviceProperties.deviceName);\n  145          #endif\n  146      } else {\n  147:         TF_CODING_ERROR(\"VULKAN_ERROR: Unable to determine physical device\");\n  148          return;\n  149      }\n  150  \n  151      //\n  152:     // Query supported extensions for device\n  153      //\n  154  \n  ...\n  238      } else {\n  239          #if !defined(__APPLE__)\n  240:             TF_WARN(\"Unsupported VK_EXT_buffer_device_address (update drivers?)\");\n  241          #endif\n  242      }\n  ...\n  256      extensions.push_back(VK_KHR_MAINTENANCE1_EXTENSION_NAME);\n  257  \n  258:     // Query device features2.\n  259      // We want to query for descriptor indexing features, but this is unstable\n  260      // on MoltenVk 1. So we skip it (we already know they are not supported).\n  ...\n  272      vkGetPhysicalDeviceFeatures2(_vkPhysicalDevice, &features);\n  273  \n  274:     // XXX Force override indexing features on some devices since they turned\n  275      // out to work or not work even though feature query claimed otherwise.\n  276      #if defined(__linux__)\n  277          // Unbuntu 18.10 Intel UHD 620 does not render with partiallyBound true.\n  278:         if (strstr(_vkDeviceProperties.deviceName, \"UHD Graphics 620\")) {\n  279              _indexingFeatures.descriptorBindingVariableDescriptorCount=VK_TRUE;\n  280              _indexingFeatures.descriptorBindingPartiallyBound=VK_FALSE;\n  ...\n  315      allocatorInfo.instance = instance->GetVulkanInstance();\n  316      allocatorInfo.physicalDevice = _vkPhysicalDevice;\n  317:     allocatorInfo.device = _vkDevice;\n  318      if (dedicatedAllocations) {\n  319          allocatorInfo.flags |=VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT;\n  ...\n  349  \n  350      //\n  351:     // Hgi device features\n  352      //\n  353      _hgiDeviceFeatures.maxSamplers =\n  ...\n  362  HgiVkDevice::~HgiVkDevice()\n  363  {\n  364:     // Make sure device is done consuming all frames before destroying objects.\n  365      TF_VERIFY(vkDeviceWaitIdle(_vkDevice) == VK_SUCCESS);\n  366  \n  ...\n  370      _renderPassPipelineCache.Clear();\n  371  \n  372:     // Destroy vulkan objects in the frames before destroying this device.\n  373      for (HgiVkRenderFrame* frame : _frames) {\n  374          delete frame;\n\n/home/max/dev/Falcor/src/USD/hgiVk/device.h:\n    6  \n    7  #include \"pxr/pxr.h\"\n    8: #include \"pxr/imaging/hgi/deviceFeatures.h\"\n    9  \n   10  #include \"USD/hgiVk/api.h\"\n   ..\n   34  /// \\class HgiVkDevice\n   35  ///\n   36: /// Vulkan implementation of GPU device.\n   37  ///\n   38  class HgiVkDevice final {\n   ..\n   41      HgiVkDevice(\n   42          HgiVkInstance* instance,\n   43:         HgiVkDeviceSettings deviceType);\n   44  \n   45      HGIVK_API\n   ..\n   69          VkFence fence);\n   70  \n   71:     /// Returns the vulkan device\n   72      HGIVK_API\n   73      VkDevice GetVulkanDevice() const;\n   74  \n   75:     /// Returns the vulkan physical device\n   76      HGIVK_API\n   77      VkPhysicalDevice GetVulkanPhysicalDevice() const;\n   78  \n   79:     /// Returns the vulkan physical device properties\n   80      HGIVK_API\n   81      VkPhysicalDeviceProperties const& GetVulkanPhysicalDeviceProperties() const;\n   82  \n   83:     /// Returns the vulkan physical device features\n   84      HGIVK_API\n   85      VkPhysicalDeviceFeatures const& GetVulkanPhysicalDeviceFeatures() const;\n   86  \n   87:     /// Returns the indexing features of the physical device\n   88      HGIVK_API\n   89      VkPhysicalDeviceDescriptorIndexingFeaturesEXT const&\n   ..\n  105      void ReleaseRenderPass(HgiVkRenderPass* rp);\n  106  \n  107:     /// Returns the vulkan device queue.\n  108      HGIVK_API\n  109      VkQueue GetVulkanDeviceQueue() const;\n  110  \n  111:     /// Returns the family index of the vulkan device queue.\n  112      HGIVK_API\n  113      uint32_t GetVulkanDeviceQueueFamilyIndex() const;\n  ...\n  130      void DestroyObject(HgiVkObject const& object);\n  131  \n  132:     /// Wait for all queued up commands to have been processed on device.\n  133      /// This should ideally never be used as it creates very big stalls.\n  134      HGIVK_API\n  ...\n  139      uint64_t GetCurrentFrame() const;\n  140  \n  141:     /// Returns device used and unused memmory.\n  142      HGIVK_API\n  143      void GetDeviceMemoryInfo(size_t* used, size_t* unused) const;\n  144  \n  145:     /// Returns true if the device support debug marker extension\n  146      HGIVK_API\n  147      bool GetDeviceSupportDebugMarkers() const;\n  148  \n  149:     /// Returns true if the device support time stamps\n  150      HGIVK_API\n  151      bool GetDeviceSupportTimeStamps() const;\n  ...\n  155      HgiTimeQueryVector const & GetTimeQueries() const;\n  156  \n  157:     /// Returns the feature and limits of the device\n  158      HGIVK_API\n  159      HgiDeviceFeatures const& GetDeviceFeatures() const;\n  160  \n  161  public:\n  162:     /// device extension functions\n  163  \n  164      // Not supported on MoltenVk 1\n  ...\n  171      HgiVkDevice(const HgiVkDevice&) = delete;\n  172  \n  173:     // Returns true if the provided extension is supported by the device\n  174      bool _IsSupportedExtension(const char* extensionName) const;\n  175  \n  176  private:\n  177:     // Vulkan device objects\n  178      VmaAllocator _vmaAllocator;\n  179      VkPhysicalDevice _vkPhysicalDevice;\n\n/home/max/dev/Falcor/src/USD/hgiVk/diagnostic.cpp:\n    5  \n    6  #include \"USD/hgiVk/commandBuffer.h\"\n    7: #include \"USD/hgiVk/device.h\"\n    8  #include \"USD/hgiVk/diagnostic.h\"\n    9  #include \"USD/hgiVk/instance.h\"\n   ..\n   20  \n   21  // XXX Make HgiVkDebug class and move all function, including below in there.\n   22: // We may have multiple devices where one supports the marker extension and\n   23  // one does not.\n   24  static PFN_vkCmdDebugMarkerBeginEXT _vkCmdDebugMarkerBeginEXT = 0;\n   ..\n   48      // https://github.com/KhronosGroup/Vulkan-ValidationLayers/issues/73\n   49      if (strstr(pMessage, \"Shader requires vertexPipelineStoresAndAtomics but is\"\n   50:                          \" not enabled on the device\")) {\n   51          return VK_FALSE;\n   52      }\n   ..\n   59      if(strstr(pMessage, \"Mapping an image with layout\") != nullptr &&\n   60         strstr(pMessage, \"can result in undefined behavior if this memory is \"\n   61:                         \"used by the device\") != nullptr) {\n   62          return VK_FALSE;\n   63      }\n   ..\n  138  \n  139  void\n  140: HgiVkInitializeDeviceDebug(HgiVkDevice* device)\n  141  {\n  142      if (!HgiVkIsDebugEnabled()) return;\n  143:     if (!device->GetDeviceSupportDebugMarkers()) return;\n  144  \n  145      _vkCmdDebugMarkerBeginEXT = (PFN_vkCmdDebugMarkerBeginEXT)\n  146          vkGetDeviceProcAddr(\n  147:             device->GetVulkanDevice(),\n  148              \"vkCmdDebugMarkerBeginEXT\");\n  149  \n  150      _vkCmdDebugMarkerEndEXT = (PFN_vkCmdDebugMarkerEndEXT)\n  151          vkGetDeviceProcAddr(\n  152:             device->GetVulkanDevice(),\n  153              \"vkCmdDebugMarkerEndEXT\");\n  154  \n  155      _vkDebugMarkerSetObjectNameEXT = (PFN_vkDebugMarkerSetObjectNameEXT)\n  156          vkGetDeviceProcAddr(\n  157:             device->GetVulkanDevice(),\n  158              \"vkDebugMarkerSetObjectNameEXT\");\n  159  }\n  ...\n  189  void\n  190  HgiVkSetDebugName(\n  191:     HgiVkDevice* device,\n  192      uint64_t vulkanObject,\n  193      uint32_t objectType,\n  ...\n  201      debugInfo.objectType = VkDebugReportObjectTypeEXT(objectType);\n  202      debugInfo.pObjectName = name;\n  203:     _vkDebugMarkerSetObjectNameEXT(device->GetVulkanDevice(), &debugInfo);\n  204  }\n  205  \n\n/home/max/dev/Falcor/src/USD/hgiVk/diagnostic.h:\n   27  void HgiVkDestroyDebug(HgiVkInstance* instance);\n   28  \n   29: /// Setup vulkan device debug function ptrs\n   30  HGIVK_API\n   31: void HgiVkInitializeDeviceDebug(HgiVkDevice* device);\n   32  \n   33  /// Push a debug marker\n   ..\n   45  HGIVK_API\n   46  void HgiVkSetDebugName(\n   47:     HgiVkDevice* device,\n   48      uint64_t vulkanObject,\n   49      uint32_t /*VkDebugReportObjectTypeEXT*/ objectType,\n\n/home/max/dev/Falcor/src/USD/hgiVk/frame.cpp:\n    1  #include \"pxr/base/tf/diagnostic.h\"\n    2: #include \"USD/hgiVk/device.h\"\n    3  #include \"USD/hgiVk/diagnostic.h\"\n    4  #include \"USD/hgiVk/frame.h\"\n    .\n    8  \n    9  \n   10: HgiVkRenderFrame::HgiVkRenderFrame(HgiVkDevice* device)\n   11:     : _device(device)\n   12:     , _commandBufferManager(device)\n   13      , _vkFence(nullptr)\n   14  {\n   ..\n   19      TF_VERIFY(\n   20          vkCreateFence(\n   21:             _device->GetVulkanDevice(),\n   22              &fenceInfo,\n   23              HgiVkAllocator(),\n   ..\n   28  HgiVkRenderFrame::~HgiVkRenderFrame()\n   29  {\n   30:     vkDestroyFence(_device->GetVulkanDevice(), _vkFence, HgiVkAllocator());\n   31  }\n   32  \n   ..\n   39      TF_VERIFY(\n   40          vkWaitForFences(\n   41:             _device->GetVulkanDevice(),\n   42              1,\n   43              &_vkFence,\n   ..\n   48      TF_VERIFY(\n   49          vkResetFences(\n   50:             _device->GetVulkanDevice(),\n   51              1,\n   52              &_vkFence)  == VK_SUCCESS\n   ..\n   85      std::string debugLabel = \"Fence \" + name;\n   86      HgiVkSetDebugName(\n   87:         _device,\n   88          (uint64_t)_vkFence,\n   89          VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT,\n\n/home/max/dev/Falcor/src/USD/hgiVk/frame.h:\n   30  class HgiVkRenderFrame final {\n   31  public:\n   32:     HgiVkRenderFrame(HgiVkDevice* device);\n   33      ~HgiVkRenderFrame();\n   34  \n   ..\n   61  \n   62  private:\n   63:     HgiVkDevice* _device;\n   64  \n   65      // Thread-safe managing of one frame's command buffers.\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/Include/Types.h:\n  476      {\n  477          coherent     = false;\n  478:         devicecoherent = false;\n  479          queuefamilycoherent = false;\n  480          workgroupcoherent = false;\n  ...\n  524      bool sample       : 1;\n  525      bool coherent     : 1;\n  526:     bool devicecoherent : 1;\n  527      bool queuefamilycoherent : 1;\n  528      bool workgroupcoherent : 1;\n  ...\n  538      bool isMemory() const\n  539      {\n  540:         return subgroupcoherent || workgroupcoherent || queuefamilycoherent || devicecoherent || coherent || volatil || restrict || readonly || writeonly || nonprivate;\n  541      }\n  542      bool isMemoryQualifierImageAndSSBOOnly() const\n  543      {\n  544:         return subgroupcoherent || workgroupcoherent || queuefamilycoherent || devicecoherent || coherent || volatil || restrict || readonly || writeonly;\n  545      }\n  546      bool bufferReferenceNeedsVulkanMemoryModel() const\n  547      {\n  548          // include qualifiers that map to load/store availability/visibility/nonprivate memory access operands\n  549:         return subgroupcoherent || workgroupcoherent || queuefamilycoherent || devicecoherent || coherent || nonprivate;\n  550      }\n  551  \n  ...\n 1941          if (qualifier.coherent)\n 1942              appendStr(\" coherent\");\n 1943:         if (qualifier.devicecoherent)\n 1944:             appendStr(\" devicecoherent\");\n 1945          if (qualifier.queuefamilycoherent)\n 1946              appendStr(\" queuefamilycoherent\");\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/glslang.y:\n 1424      | DEVICECOHERENT {\n 1425          $$.init($1.loc);\n 1426:         parseContext.requireExtensions($1.loc, 1, &E_GL_KHR_memory_scope_semantics, \"devicecoherent\");\n 1427:         $$.qualifier.devicecoherent = true;\n 1428      }\n 1429      | QUEUEFAMILYCOHERENT {\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/glslang_tab.cpp:\n 5977      {\n 5978          (yyval.interm.type).init((yyvsp[0].lex).loc);\n 5979:         parseContext.requireExtensions((yyvsp[0].lex).loc, 1, &E_GL_KHR_memory_scope_semantics, \"devicecoherent\");\n 5980:         (yyval.interm.type).qualifier.devicecoherent = true;\n 5981      }\n 5982  #line 5983 \"MachineIndependent/glslang_tab.cpp\" /* yacc.c:1646  */\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/Initialize.cpp:\n 5322          (profile == EEsProfile && version >= 310)) {\n 5323          stageBuiltins[EShLangCompute].append(\n 5324:             \"in highp int gl_DeviceIndex;\"     // GL_EXT_device_group\n 5325              \"\\n\");\n 5326      }\n ....\n 5395      if (profile != EEsProfile && version >= 450) {\n 5396          stageBuiltins[EShLangMeshNV].append(\n 5397:             \"in highp int gl_DeviceIndex;\"     // GL_EXT_device_group\n 5398              \"in int gl_DrawIDARB;\"             // GL_ARB_shader_draw_parameters\n 5399              \"\\n\");\n 5400  \n 5401          stageBuiltins[EShLangTaskNV].append(\n 5402:             \"in highp int gl_DeviceIndex;\"     // GL_EXT_device_group\n 5403              \"in int gl_DrawIDARB;\"             // GL_ARB_shader_draw_parameters\n 5404              \"\\n\");\n ....\n 5595          (profile == EEsProfile && version >= 310)) {\n 5596          stageBuiltins[EShLangVertex].append(\n 5597:             \"in highp int gl_DeviceIndex;\"     // GL_EXT_device_group\n 5598              \"in highp int gl_ViewIndex;\"       // GL_EXT_multiview\n 5599              \"\\n\");\n ....\n 5718          (profile == EEsProfile && version >= 310)) {\n 5719          stageBuiltins[EShLangGeometry].append(\n 5720:             \"in highp int gl_DeviceIndex;\"     // GL_EXT_device_group\n 5721              \"in highp int gl_ViewIndex;\"       // GL_EXT_multiview\n 5722              \"\\n\");\n ....\n 5809          (profile == EEsProfile && version >= 310)) {\n 5810          stageBuiltins[EShLangTessControl].append(\n 5811:             \"in highp int gl_DeviceIndex;\"     // GL_EXT_device_group\n 5812              \"in highp int gl_ViewIndex;\"       // GL_EXT_multiview\n 5813              \"\\n\");\n ....\n 5896          (profile == EEsProfile && version >= 310)) {\n 5897          stageBuiltins[EShLangTessEvaluation].append(\n 5898:             \"in highp int gl_DeviceIndex;\"     // GL_EXT_device_group\n 5899              \"in highp int gl_ViewIndex;\"       // GL_EXT_multiview\n 5900              \"\\n\");\n ....\n 6122          (profile == EEsProfile && version >= 310)) {\n 6123          stageBuiltins[EShLangFragment].append(\n 6124:             \"flat in highp int gl_DeviceIndex;\"     // GL_EXT_device_group\n 6125              \"flat in highp int gl_ViewIndex;\"       // GL_EXT_multiview\n 6126              \"\\n\");\n ....\n 6265      }\n 6266      if ((profile != EEsProfile && version >= 140)) {\n 6267:         const char *deviceIndex =\n 6268:             \"in highp int gl_DeviceIndex;\"     // GL_EXT_device_group\n 6269              \"\\n\";\n 6270  \n 6271:         stageBuiltins[EShLangRayGenNV].append(deviceIndex);\n 6272:         stageBuiltins[EShLangIntersectNV].append(deviceIndex);\n 6273:         stageBuiltins[EShLangAnyHitNV].append(deviceIndex);\n 6274:         stageBuiltins[EShLangClosestHitNV].append(deviceIndex);\n 6275:         stageBuiltins[EShLangMissNV].append(deviceIndex);\n 6276      }\n 6277  #endif\n ....\n 8155          if ((profile != EEsProfile && version >= 140) ||\n 8156              (profile == EEsProfile && version >= 310)) {\n 8157:             symbolTable.setVariableExtensions(\"gl_DeviceIndex\",  1, &E_GL_EXT_device_group);\n 8158              BuiltInVariable(\"gl_DeviceIndex\", EbvDeviceIndex, symbolTable);\n 8159              symbolTable.setVariableExtensions(\"gl_ViewIndex\", 1, &E_GL_EXT_multiview);\n ....\n 8448          }\n 8449  \n 8450:         symbolTable.setVariableExtensions(\"gl_DeviceIndex\",  1, &E_GL_EXT_device_group);\n 8451          BuiltInVariable(\"gl_DeviceIndex\", EbvDeviceIndex, symbolTable);\n 8452          symbolTable.setVariableExtensions(\"gl_ViewIndex\", 1, &E_GL_EXT_multiview);\n ....\n 8688          if ((profile != EEsProfile && version >= 140) ||\n 8689              (profile == EEsProfile && version >= 310)) {\n 8690:             symbolTable.setVariableExtensions(\"gl_DeviceIndex\",  1, &E_GL_EXT_device_group);\n 8691              BuiltInVariable(\"gl_DeviceIndex\", EbvDeviceIndex, symbolTable);\n 8692              symbolTable.setVariableExtensions(\"gl_ViewIndex\", 1, &E_GL_EXT_multiview);\n ....\n 8736              symbolTable.setVariableExtensions(\"gl_IncomingRayFlagsNV\", 1, &E_GL_NV_ray_tracing);\n 8737  \n 8738:             symbolTable.setVariableExtensions(\"gl_DeviceIndex\", 1, &E_GL_EXT_device_group);\n 8739  \n 8740              BuiltInVariable(\"gl_LaunchIDNV\",            EbvLaunchIdNV,           symbolTable);\n ....\n 8830  \n 8831          if (profile != EEsProfile && version >= 450) {\n 8832:             // GL_EXT_device_group\n 8833:             symbolTable.setVariableExtensions(\"gl_DeviceIndex\", 1, &E_GL_EXT_device_group);\n 8834              BuiltInVariable(\"gl_DeviceIndex\", EbvDeviceIndex, symbolTable);\n 8835  \n ....\n 8920  \n 8921          if (profile != EEsProfile && version >= 450) {\n 8922:             // GL_EXT_device_group\n 8923:             symbolTable.setVariableExtensions(\"gl_DeviceIndex\", 1, &E_GL_EXT_device_group);\n 8924              BuiltInVariable(\"gl_DeviceIndex\", EbvDeviceIndex, symbolTable);\n 8925  \n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/Intermediate.cpp:\n 1363  \n 1364              // HLSL semantics: the scalar (or vec1) is replicated to every component of the matrix.  Left to its\n 1365:             // own devices, the constructor from a scalar would populate the diagonal.  This forces replication\n 1366              // to every matrix element.\n 1367  \n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/linkValidate.cpp:\n  555      // Memory...\n  556      if (symbol.getQualifier().coherent          != unitSymbol.getQualifier().coherent ||\n  557:         symbol.getQualifier().devicecoherent    != unitSymbol.getQualifier().devicecoherent ||\n  558          symbol.getQualifier().queuefamilycoherent  != unitSymbol.getQualifier().queuefamilycoherent ||\n  559          symbol.getQualifier().workgroupcoherent != unitSymbol.getQualifier().workgroupcoherent ||\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/ParseHelper.cpp:\n 1152                          if (argQualifier.volatil && ! formalQualifier.volatil)\n 1153                              error(arguments->getLoc(), message, \"volatile\", \"\");\n 1154:                         if (argQualifier.coherent && ! (formalQualifier.devicecoherent || formalQualifier.coherent))\n 1155                              error(arguments->getLoc(), message, \"coherent\", \"\");\n 1156:                         if (argQualifier.devicecoherent && ! (formalQualifier.devicecoherent || formalQualifier.coherent))\n 1157:                             error(arguments->getLoc(), message, \"devicecoherent\", \"\");\n 1158:                         if (argQualifier.queuefamilycoherent && ! (formalQualifier.queuefamilycoherent || formalQualifier.devicecoherent || formalQualifier.coherent))\n 1159                              error(arguments->getLoc(), message, \"queuefamilycoherent\", \"\");\n 1160:                         if (argQualifier.workgroupcoherent && ! (formalQualifier.workgroupcoherent || formalQualifier.queuefamilycoherent || formalQualifier.devicecoherent || formalQualifier.coherent))\n 1161                              error(arguments->getLoc(), message, \"workgroupcoherent\", \"\");\n 1162:                         if (argQualifier.subgroupcoherent && ! (formalQualifier.subgroupcoherent || formalQualifier.workgroupcoherent || formalQualifier.queuefamilycoherent || formalQualifier.devicecoherent || formalQualifier.coherent))\n 1163                              error(arguments->getLoc(), message, \"subgroupcoherent\", \"\");\n 1164                          if (argQualifier.readonly && ! formalQualifier.readonly)\n ....\n 3432          dst.precision = src.precision;\n 3433  \n 3434:     if (!force && ((src.coherent && (dst.devicecoherent || dst.queuefamilycoherent || dst.workgroupcoherent || dst.subgroupcoherent)) ||\n 3435:                    (src.devicecoherent && (dst.coherent || dst.queuefamilycoherent || dst.workgroupcoherent || dst.subgroupcoherent)) ||\n 3436:                    (src.queuefamilycoherent && (dst.coherent || dst.devicecoherent || dst.workgroupcoherent || dst.subgroupcoherent)) ||\n 3437:                    (src.workgroupcoherent && (dst.coherent || dst.devicecoherent || dst.queuefamilycoherent || dst.subgroupcoherent)) ||\n 3438:                    (src.subgroupcoherent  && (dst.coherent || dst.devicecoherent || dst.queuefamilycoherent || dst.workgroupcoherent)))) {\n 3439:         error(loc, \"only one coherent/devicecoherent/queuefamilycoherent/workgroupcoherent/subgroupcoherent qualifier allowed\", GetPrecisionQualifierString(src.precision), \"\");\n 3440      }\n 3441      // Layout qualifiers\n ....\n 3462      MERGE_SINGLETON(sample);\n 3463      MERGE_SINGLETON(coherent);\n 3464:     MERGE_SINGLETON(devicecoherent);\n 3465      MERGE_SINGLETON(queuefamilycoherent);\n 3466      MERGE_SINGLETON(workgroupcoherent);\n ....\n 4396          type.getQualifier().volatil   = qualifier.volatil;\n 4397          type.getQualifier().coherent  = qualifier.coherent;\n 4398:         type.getQualifier().devicecoherent  = qualifier.devicecoherent ;\n 4399          type.getQualifier().queuefamilycoherent  = qualifier.queuefamilycoherent;\n 4400          type.getQualifier().workgroupcoherent  = qualifier.workgroupcoherent;\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/Scan.cpp:\n  381      (*KeywordMap)[\"buffer\"] =                  BUFFER;\n  382      (*KeywordMap)[\"coherent\"] =                COHERENT;\n  383:     (*KeywordMap)[\"devicecoherent\"] =          DEVICECOHERENT;\n  384      (*KeywordMap)[\"queuefamilycoherent\"] =     QUEUEFAMILYCOHERENT;\n  385      (*KeywordMap)[\"workgroupcoherent\"] =       WORKGROUPCOHERENT;\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/Versions.cpp:\n  281  \n  282      // EXT extensions\n  283:     extensionBehavior[E_GL_EXT_device_group]             = EBhDisable;\n  284      extensionBehavior[E_GL_EXT_multiview]                = EBhDisable;\n  285  \n  ...\n  456          (profile == EEsProfile && version >= 310)) {\n  457          preamble +=\n  458:             \"#define GL_EXT_device_group 1\\n\"\n  459              \"#define GL_EXT_multiview 1\\n\"\n  460              ;\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/Versions.h:\n  163  \n  164  // EXT extensions\n  165: const char* const E_GL_EXT_device_group                     = \"GL_EXT_device_group\";\n  166  const char* const E_GL_EXT_multiview                        = \"GL_EXT_multiview\";\n  167  const char* const E_GL_EXT_post_depth_coverage              = \"GL_EXT_post_depth_coverage\";\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/SPIRV/GLSL.ext.KHR.h:\n   33  static const char* const E_SPV_KHR_shader_ballot                = \"SPV_KHR_shader_ballot\";\n   34  static const char* const E_SPV_KHR_subgroup_vote                = \"SPV_KHR_subgroup_vote\";\n   35: static const char* const E_SPV_KHR_device_group                 = \"SPV_KHR_device_group\";\n   36  static const char* const E_SPV_KHR_multiview                    = \"SPV_KHR_multiview\";\n   37  static const char* const E_SPV_KHR_shader_draw_parameters       = \"SPV_KHR_shader_draw_parameters\";\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/SPIRV/GlslangToSpv.cpp:\n  501      if (coherentFlags.volatil ||\n  502          coherentFlags.coherent ||\n  503:         coherentFlags.devicecoherent ||\n  504          coherentFlags.queuefamilycoherent ||\n  505          coherentFlags.workgroupcoherent ||\n  ...\n  528      if (coherentFlags.volatil ||\n  529          coherentFlags.coherent ||\n  530:         coherentFlags.devicecoherent ||\n  531          coherentFlags.queuefamilycoherent ||\n  532          coherentFlags.workgroupcoherent ||\n  ...\n  551      spv::Builder::AccessChain::CoherentFlags flags;\n  552      flags.coherent = type.getQualifier().coherent;\n  553:     flags.devicecoherent = type.getQualifier().devicecoherent;\n  554      flags.queuefamilycoherent = type.getQualifier().queuefamilycoherent;\n  555      // shared variables are implicitly workgroupcoherent in GLSL.\n  ...\n  563                         flags.workgroupcoherent ||\n  564                         flags.queuefamilycoherent ||\n  565:                        flags.devicecoherent ||\n  566                         flags.coherent ||\n  567                         flags.volatil;\n  ...\n  576          // coherent defaults to Device scope in the old model, QueueFamilyKHR scope in the new model\n  577          scope = glslangIntermediate->usingVulkanMemoryModel() ? spv::ScopeQueueFamilyKHR : spv::ScopeDevice;\n  578:     } else if (coherentFlags.devicecoherent) {\n  579          scope = spv::ScopeDevice;\n  580      } else if (coherentFlags.queuefamilycoherent) {\n  ...\n  826  \n  827      case glslang::EbvDeviceIndex:\n  828:         addPre13Extension(spv::E_SPV_KHR_device_group);\n  829          builder.addCapability(spv::CapabilityDeviceGroup);\n  830          return spv::BuiltInDeviceIndex;\n  ...\n 1239      if (parent.coherent)\n 1240          child.coherent = true;\n 1241:     if (parent.devicecoherent)\n 1242:         child.devicecoherent = true;\n 1243      if (parent.queuefamilycoherent)\n 1244          child.queuefamilycoherent = true;\n ....\n 7312  spv::Id TGlslangToSpvTraverser::createNoArgOperation(glslang::TOperator op, spv::Decoration precision, spv::Id typeId)\n 7313  {\n 7314:     // GLSL memory barriers use queuefamily scope in new model, device scope in old model\n 7315      spv::Scope memoryBarrierScope = glslangIntermediate->usingVulkanMemoryModel() ? spv::ScopeQueueFamilyKHR : spv::ScopeDevice;\n 7316  \n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/SPIRV/SpvBuilder.h:\n  559          struct CoherentFlags {\n  560              unsigned coherent : 1;\n  561:             unsigned devicecoherent : 1;\n  562              unsigned queuefamilycoherent : 1;\n  563              unsigned workgroupcoherent : 1;\n  ...\n  569              void clear() {\n  570                  coherent = 0;\n  571:                 devicecoherent = 0;\n  572                  queuefamilycoherent = 0;\n  573                  workgroupcoherent = 0;\n  ...\n  581              CoherentFlags operator |=(const CoherentFlags &other) {\n  582                  coherent |= other.coherent;\n  583:                 devicecoherent |= other.devicecoherent;\n  584                  queuefamilycoherent |= other.queuefamilycoherent;\n  585                  workgroupcoherent |= other.workgroupcoherent;\n\n/home/max/dev/Falcor/src/USD/hgiVk/graphicsEncoder.cpp:\n    4  #include \"USD/hgiVk/commandBuffer.h\"\n    5  #include \"USD/hgiVk/conversions.h\"\n    6: #include \"USD/hgiVk/device.h\"\n    7  #include \"USD/hgiVk/diagnostic.h\"\n    8  #include \"USD/hgiVk/graphicsEncoder.h\"\n    .\n   16  \n   17  HgiVkGraphicsEncoder::HgiVkGraphicsEncoder(\n   18:     HgiVkDevice* device,\n   19      HgiVkCommandBuffer* cb,\n   20      HgiGraphicsEncoderDesc const& desc)\n   21      : HgiGraphicsEncoder()\n   22:     , _device(device)\n   23      , _commandBuffer(cb)\n   24      , _renderPass(nullptr)\n   ..\n   26      , _isRecording(true)\n   27  {\n   28:     _renderPass = device->AcquireRenderPass(desc);\n   29      _renderPass->BeginRenderPass(_commandBuffer, _isParallelEncoder);\n   30  }\n   31  \n   32  HgiVkGraphicsEncoder::HgiVkGraphicsEncoder(\n   33:     HgiVkDevice* device,\n   34      HgiVkCommandBuffer* cb,\n   35      HgiVkRenderPass* renderPass)\n   36      : HgiGraphicsEncoder()\n   37:     , _device(device)\n   38      , _commandBuffer(cb)\n   39      , _renderPass(renderPass)\n   ..\n   58      if (!_isParallelEncoder) {\n   59          _renderPass->EndRenderPass(_commandBuffer);\n   60:         _device->ReleaseRenderPass(_renderPass);\n   61      }\n   62  \n\n/home/max/dev/Falcor/src/USD/hgiVk/graphicsEncoder.h:\n   31      HGIVK_API\n   32      HgiVkGraphicsEncoder(\n   33:         HgiVkDevice* device,\n   34          HgiVkCommandBuffer* cb,\n   35          HgiGraphicsEncoderDesc const& desc);\n   ..\n   38      HGIVK_API\n   39      HgiVkGraphicsEncoder(\n   40:         HgiVkDevice* device,\n   41          HgiVkCommandBuffer* cb,\n   42          HgiVkRenderPass* renderPass);\n   ..\n   99  \n  100  private:\n  101:     HgiVkDevice* _device;\n  102      HgiVkCommandBuffer* _commandBuffer;\n  103      HgiVkRenderPass* _renderPass;\n\n/home/max/dev/Falcor/src/USD/hgiVk/hgi.cpp:\n   20  #include \"USD/hgiVk/commandBuffer.h\"\n   21  #include \"USD/hgiVk/commandBufferManager.h\"\n   22: #include \"USD/hgiVk/device.h\"\n   23  #include \"USD/hgiVk/hgi.h\"\n   24  #include \"USD/hgiVk/instance.h\"\n   ..\n   75      _instance = new HgiVkInstance();\n   76  \n   77:     // Create \"primary device\" at front of vector.\n   78      HgiVkDevice* dev = new HgiVkDevice(_instance, HgiVkPresentationType);\n   79      TF_VERIFY(dev);\n   80:     _devices.push_back(dev);\n   81  \n   82      // Make sure HgiVk is ready to modify resources or record commands.\n   ..\n   95      _frameStarted = true;\n   96  \n   97:     for (HgiVkDevice* d : _devices) {\n   98          d->BeginFrame();\n   99      }\n  ...\n  104  {\n  105      // Submit the command buffer to GPU.\n  106:     for (HgiVkDevice* d : _devices) {\n  107          d->EndFrame();\n  108      }\n  ...\n  110      _frameStarted = false;\n  111  \n  112:     // todo Defrag the AMD VulkanMemoryAllocator device->vmaAllocator\n  113      //      You need to destroy/recreate vk buffers and update descriptorSets.\n  114      //      See VMA header: defragmentation\n  ...\n  118      // Additional notes:\n  119      //      https://developer.nvidia.com/vulkan-memory-management\n  120:     //      https://ourmachinery.com/post/device-memory-management/\n  121  \n  122      // Hydra currently does not call BeginFrame() and even if it did during\n  ...\n  139      if (!_ValidateGraphicsEncoderDescriptor(desc)) return nullptr;\n  140  \n  141:     HgiVkDevice* device = GetPrimaryDevice();\n  142:     HgiVkCommandBufferManager* cbm = device->GetCommandBufferManager();\n  143      HgiVkCommandBuffer* cb = cbm->GetDrawCommandBuffer();\n  144:     HgiVkGraphicsEncoder* enc = new HgiVkGraphicsEncoder(device, cb, desc);\n  145  \n  146      return HgiGraphicsEncoderUniquePtr(enc);\n  ...\n  155      if (!_ValidateGraphicsEncoderDescriptor(desc)) return nullptr;\n  156  \n  157:     HgiVkDevice* device = GetPrimaryDevice();\n  158:     HgiVkCommandBufferManager* cbm = device->GetCommandBufferManager();\n  159      HgiVkCommandBuffer* cb = cbm->GetDrawCommandBuffer();\n  160      HgiVkParallelGraphicsEncoder* enc =\n  161:         new HgiVkParallelGraphicsEncoder(debugName, device, cb, desc, pipeline);\n  162  \n  163      return HgiParallelGraphicsEncoderUniquePtr(enc);\n  ...\n  167  HgiVk::CreateBlitEncoder()\n  168  {\n  169:     HgiVkDevice* device = GetPrimaryDevice();\n  170:     HgiVkCommandBufferManager* cbm = device->GetCommandBufferManager();\n  171      HgiVkCommandBuffer* cb = cbm->GetResourceCommandBuffer();\n  172:     return HgiBlitEncoderUniquePtr(new HgiVkBlitEncoder(device, cb));\n  173  }\n  174  \n  ...\n  176  HgiVk::CreateTexture(HgiTextureDesc const& desc)\n  177  {\n  178:     HgiVkDevice* device = GetPrimaryDevice();\n  179:     HgiVkCommandBufferManager* cbm = device->GetCommandBufferManager();\n  180      HgiVkCommandBuffer* cb = cbm->GetResourceCommandBuffer();\n  181:     HgiVkTexture* tex = new HgiVkTexture(device, cb, desc);\n  182  \n  183      // If caller provided data to copy into this texture we create a staging\n  ...\n  192          stagingDesc.data = desc.pixelData;\n  193  \n  194:         HgiVkBuffer* stagingBuffer = new HgiVkBuffer(device, stagingDesc);\n  195  \n  196          // Record the copy\n  ...\n  201          stagingObject.buffer = stagingBuffer;\n  202          stagingObject.type = HgiVkObjectTypeBuffer;\n  203:         device->DestroyObject(stagingObject);\n  204      }\n  205  \n  ...\n  211  {\n  212      if (TF_VERIFY(texHandle, \"Invalid texture\")) {\n  213:         HgiVkDevice* device = GetPrimaryDevice();\n  214          HgiVkObject object;\n  215          object.type = HgiVkObjectTypeTexture;\n  216          if (object.texture = static_cast<HgiVkTexture*>(*texHandle)) {\n  217:             device->DestroyObject(object);\n  218              *texHandle = nullptr;\n  219          }\n  ...\n  224  HgiVk::CreateBuffer(HgiBufferDesc const& desc)\n  225  {\n  226:     HgiVkDevice* device = GetPrimaryDevice();\n  227:     HgiVkCommandBufferManager* cbm = device->GetCommandBufferManager();\n  228:     HgiVkBuffer* buffer = new HgiVkBuffer(device, desc);\n  229  \n  230      // If caller provided data to copy into this buffer we create a staging\n  ...\n  239          stagingDesc.data = desc.data;\n  240  \n  241:         HgiVkBuffer* stagingBuffer = new HgiVkBuffer(device, stagingDesc);\n  242  \n  243          // Record the copy\n  ...\n  249          stagingObject.buffer = stagingBuffer;\n  250          stagingObject.type = HgiVkObjectTypeBuffer;\n  251:         device->DestroyObject(stagingObject);\n  252      }\n  253  \n  ...\n  259  {\n  260      if (TF_VERIFY(bufferHandle, \"Invalid buffer\")) {\n  261:         HgiVkDevice* device = GetPrimaryDevice();\n  262          HgiVkObject object;\n  263          object.type = HgiVkObjectTypeBuffer;\n  264          if (object.buffer = static_cast<HgiVkBuffer*>(*bufferHandle)) {\n  265:             device->DestroyObject(object);\n  266              *bufferHandle = nullptr;\n  267          }\n  ...\n  272  HgiVk::CreatePipeline(HgiPipelineDesc const& desc)\n  273  {\n  274:     HgiVkDevice* device = GetPrimaryDevice();\n  275:     return new HgiVkPipeline(device, desc);\n  276  }\n  277  \n  ...\n  280  {\n  281      if (TF_VERIFY(pipeHandle, \"Invalid pipeline\")) {\n  282:         HgiVkDevice* device = GetPrimaryDevice();\n  283          HgiVkObject object;\n  284          object.type = HgiVkObjectTypePipeline;\n  285          if (object.pipeline = static_cast<HgiVkPipeline*>(*pipeHandle)) {\n  286:             device->DestroyObject(object);\n  287              *pipeHandle = nullptr;\n  288          }\n  ...\n  293  HgiVk::CreateResourceBindings(HgiResourceBindingsDesc const& desc)\n  294  {\n  295:     HgiVkDevice* device = GetPrimaryDevice();\n  296:     return new HgiVkResourceBindings(device, desc);\n  297  }\n  298  \n  ...\n  301  {\n  302      if (TF_VERIFY(resHandle, \"Invalid resource bindings\")) {\n  303:         HgiVkDevice* device = GetPrimaryDevice();\n  304          HgiVkObject object;\n  305          object.type = HgiVkObjectTypeResourceBindings;\n  306          if (object.resourceBindings =\n  307                  static_cast<HgiVkResourceBindings*>(*resHandle)) {\n  308:             device->DestroyObject(object);\n  309              *resHandle = nullptr;\n  310          }\n  ...\n  315  HgiVk::CreateShaderFunction(HgiShaderFunctionDesc const& desc)\n  316  {\n  317:     HgiVkDevice* device = GetPrimaryDevice();\n  318:     return new HgiVkShaderFunction(device, desc);\n  319  }\n  320  \n  ...\n  323  {\n  324      if (TF_VERIFY(shaderFunctionHandle, \"Invalid shader function\")) {\n  325:         HgiVkDevice* device = GetPrimaryDevice();\n  326          HgiVkObject object;\n  327          object.type = HgiVkObjectTypeShaderFunction;\n  328          if (object.shaderFunction =\n  329                  static_cast<HgiVkShaderFunction*>(*shaderFunctionHandle)) {\n  330:             device->DestroyObject(object);\n  331              *shaderFunctionHandle = nullptr;\n  332          }\n  ...\n  344  {\n  345      if (TF_VERIFY(shaderProgramHandle, \"Invalid shader program\")) {\n  346:         HgiVkDevice* device = GetPrimaryDevice();\n  347          HgiVkObject object;\n  348          object.type = HgiVkObjectTypeShaderProgram;\n  349          if (object.shaderProgram =\n  350                  static_cast<HgiVkShaderProgram*>(*shaderProgramHandle)) {\n  351:             device->DestroyObject(object);\n  352              *shaderProgramHandle = nullptr;\n  353          }\n  ...\n  358  HgiVk::GetMemoryInfo(size_t* used, size_t* unused)\n  359  {\n  360:     // XXX for now assume they want the primary device.\n  361:     // But note we can have multiple _devices.\n  362:     HgiVkDevice* device = GetPrimaryDevice();\n  363:     device->GetDeviceMemoryInfo(used, unused);\n  364  }\n  365  \n  ...\n  367  HgiVk::GetTimeQueries()\n  368  {\n  369:     // XXX for now assume they want the primary device.\n  370:     // But note we can have multiple _devices.\n  371:     HgiVkDevice* device = GetPrimaryDevice();\n  372:     return device->GetTimeQueries();\n  373  }\n  374  \n  ...\n  376  HgiVk::GetDeviceFeatures()\n  377  {\n  378:     // XXX for now assume they want the primary device.\n  379:     // But note we can have multiple _devices.\n  380:     HgiVkDevice* device = GetPrimaryDevice();\n  381:     return device->GetDeviceFeatures();\n  382  }\n  383  \n  ...\n  397  HgiVk::GetPrimaryDevice() const\n  398  {\n  399:     if (_devices.empty()) return nullptr;\n  400:     return _devices.front();\n  401  }\n  402  \n  ...\n  404  HgiVk::CreateSurface(HgiVkSurfaceDesc const& desc)\n  405  {\n  406:     HgiVkDevice* device = GetPrimaryDevice();\n  407:     return new HgiVkSurface(_instance, device, desc);\n  408  }\n  409  \n  ...\n  412  {\n  413      if (TF_VERIFY(surfaceHandle, \"Invalid surface\")) {\n  414:         HgiVkDevice* device = GetPrimaryDevice();\n  415          HgiVkObject object;\n  416          object.type = HgiVkObjectTypeSurface;\n  417          if (object.surface = *surfaceHandle) {\n  418:             device->DestroyObject(object);\n  419              *surfaceHandle = nullptr;\n  420          }\n  ...\n  425  HgiVk::CreateSwapchain(HgiVkSurfaceHandle surfaceHandle)\n  426  {\n  427:     HgiVkDevice* device = GetPrimaryDevice();\n  428:     return new HgiVkSwapchain(device, surfaceHandle);\n  429  }\n  430  \n  ...\n  433  {\n  434      if (TF_VERIFY(swapchainHandle, \"Invalid swapchain\")) {\n  435:         HgiVkDevice* device = GetPrimaryDevice();\n  436          HgiVkObject object;\n  437          object.type = HgiVkObjectTypeSwapchain;\n  438          if (object.swapchain = *swapchainHandle) {\n  439:             device->DestroyObject(object);\n  440              *swapchainHandle = nullptr;\n  441          }\n  ...\n  446  HgiVk::DestroyHgiVk()\n  447  {\n  448:     for (HgiVkDevice* device : _devices) {\n  449:         delete device;\n  450      }\n  451:     _devices.clear();\n  452  \n  453      delete _instance;\n\n/home/max/dev/Falcor/src/USD/hgiVk/hgi.h:\n  119      void* GetVkInstance();\n  120  \n  121:     // Returns the primary device. This device must support presentation and\n  122      // resource creation.\n  123      HGIVK_API\n  ...\n  140      void DestroySwapchain(HgiVkSwapchainHandle* swapchainHandle);\n  141  \n  142:     /// Destroys all devices and vulkan instance.\n  143      /// Should be called once during application shutdown.\n  144      HGIVK_API\n  ...\n  159  private:\n  160      HgiVkInstance* _instance;\n  161:     HgiVkDeviceVector _devices;\n  162      bool _frameStarted;\n  163  };\n\n/home/max/dev/Falcor/src/USD/hgiVk/parallelGraphicsEncoder.cpp:\n    3  #include \"USD/hgiVk/commandBuffer.h\"\n    4  #include \"USD/hgiVk/commandBufferManager.h\"\n    5: #include \"USD/hgiVk/device.h\"\n    6  #include \"USD/hgiVk/diagnostic.h\"\n    7  #include \"USD/hgiVk/graphicsEncoder.h\"\n    .\n   17  HgiVkParallelGraphicsEncoder::HgiVkParallelGraphicsEncoder(\n   18      const char* debugName,\n   19:     HgiVkDevice* device,\n   20      HgiVkCommandBuffer* primaryCB,\n   21      HgiGraphicsEncoderDesc const& desc,\n   22      HgiPipelineHandle pipeline)\n   23      : HgiParallelGraphicsEncoder(debugName)\n   24:     , _device(device)\n   25      , _primaryCommandBuffer(primaryCB)\n   26      , _renderPass(nullptr)\n   ..\n   36      // Make sure there are enough secondary commmand buffer for this parallel\n   37      // encoder to use during CreateGraphicsEncoder().\n   38:     HgiVkCommandBufferManager* cbm = _device->GetCommandBufferManager();\n   39      _cmdBufBlockId = cbm->ReserveSecondaryDrawBuffersForParallelEncoder();\n   40  \n   ..\n   43      // individual graphics encoders that are used in the threads.\n   44      // This will ensure the load op for each attachment happens once.\n   45:     _renderPass = device->AcquireRenderPass(desc);\n   46      _renderPass->BeginRenderPass(_primaryCommandBuffer, /*use secondary*/ true);\n   47  \n   ..\n   69  {\n   70      // Record secondary cmd bufs into primary cmd buf\n   71:     HgiVkCommandBufferManager* cbm = _device->GetCommandBufferManager();\n   72      cbm->ExecuteSecondaryCommandBuffers(_cmdBufBlockId, _primaryCommandBuffer);\n   73  \n   74      // End the render pass (perform store ops)\n   75      _renderPass->EndRenderPass(_primaryCommandBuffer);\n   76:     _device->ReleaseRenderPass(_renderPass);\n   77  \n   78      if (_isDebugging) {\n   ..\n   96  \n   97      // Get thread_local secondary command buffer\n   98:     HgiVkCommandBufferManager* cbm = _device->GetCommandBufferManager();\n   99      HgiVkCommandBuffer* cb = cbm->GetSecondaryDrawCommandBuffer(_cmdBufBlockId);\n  100  \n  ...\n  104      // Create the graphics encoder passing it our already started render pass.\n  105      HgiVkGraphicsEncoder* enc = new HgiVkGraphicsEncoder(\n  106:         _device, cb, _renderPass);\n  107  \n  108      return HgiGraphicsEncoderUniquePtr(enc);\n\n/home/max/dev/Falcor/src/USD/hgiVk/parallelGraphicsEncoder.h:\n   29      HgiVkParallelGraphicsEncoder(\n   30          const char* debugName,\n   31:         HgiVkDevice* device,\n   32          HgiVkCommandBuffer* primaryCB,\n   33          HgiGraphicsEncoderDesc const& desc,\n   ..\n   51  \n   52  private:\n   53:     HgiVkDevice* _device;\n   54      HgiVkCommandBuffer* _primaryCommandBuffer;\n   55      HgiVkRenderPass* _renderPass;\n\n/home/max/dev/Falcor/src/USD/hgiVk/pipeline.cpp:\n    5  #include \"USD/hgiVk/commandBuffer.h\"\n    6  #include \"USD/hgiVk/conversions.h\"\n    7: #include \"USD/hgiVk/device.h\"\n    8  #include \"USD/hgiVk/diagnostic.h\"\n    9  #include \"USD/hgiVk/pipeline.h\"\n   ..\n   14  \n   15  HgiVkPipeline::HgiVkPipeline(\n   16:     HgiVkDevice* device,\n   17      HgiPipelineDesc const& desc)\n   18      : HgiPipeline(desc)\n   19:     , _device(device)\n   20      , _descriptor(desc)\n   21      , _vkTopology(VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST)\n   ..\n   31      for (_Pipeline p : _pipelines) {\n   32          vkDestroyPipeline(\n   33:             _device->GetVulkanDevice(),\n   34              p.vkPipeline,\n   35              HgiVkAllocator());\n   ..\n  313      // Render pass\n  314      //\n  315:     HgiVkRenderPass* renderPass = _device->AcquireRenderPass(rpDesc);\n  316      pipeCreateInfo.renderPass = renderPass->GetVulkanRenderPass();\n  317  \n  ...\n  324      // xxx we need to add a pipeline cache to avoid app having to keep compiling\n  325      // shader micro-code for every pipeline combination. We except that the\n  326:     // spir-V shader code is not compiled for the target device until this point\n  327      // where we create the pipeline. So a pipeline cache can be helpful.\n  328      // https://zeux.io/2019/07/17/serializing-pipeline-cache/\n  329      TF_VERIFY(\n  330          vkCreateGraphicsPipelines(\n  331:             _device->GetVulkanDevice(),\n  332:             _device->GetVulkanPipelineCache(),\n  333              1,\n  334              &pipeCreateInfo,\n  ...\n  343          std::string debugLabel = \"Graphics Pipeline \" + _descriptor.debugName;\n  344          HgiVkSetDebugName(\n  345:             _device,\n  346              (uint64_t)pipeline.vkPipeline,\n  347              VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT,\n  ...\n  399      TF_VERIFY(\n  400          vkCreateComputePipelines(\n  401:             _device->GetVulkanDevice(),\n  402:             _device->GetVulkanPipelineCache(),\n  403              1,\n  404              &pipeCreateInfo,\n  ...\n  411          std::string debugLabel = \"Compute Pipeline \" + _descriptor.debugName;\n  412          HgiVkSetDebugName(\n  413:             _device,\n  414              (uint64_t)pipeline.vkPipeline,\n  415              VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT,\n\n/home/max/dev/Falcor/src/USD/hgiVk/pipeline.h:\n   27      HGIVK_API\n   28      HgiVkPipeline(\n   29:         HgiVkDevice* device,\n   30          HgiPipelineDesc const& desc);\n   31  \n   ..\n   65  \n   66  private:\n   67:     HgiVkDevice* _device;\n   68      HgiPipelineDesc _descriptor;\n   69      std::vector<_Pipeline> _pipelines;\n\n/home/max/dev/Falcor/src/USD/hgiVk/renderPass.cpp:\n    3  #include \"USD/hgiVk/commandBuffer.h\"\n    4  #include \"USD/hgiVk/conversions.h\"\n    5: #include \"USD/hgiVk/device.h\"\n    6  #include \"USD/hgiVk/diagnostic.h\"\n    7  #include \"USD/hgiVk/renderPass.h\"\n    .\n   10  \n   11  HgiVkRenderPass::HgiVkRenderPass(\n   12:     HgiVkDevice* device,\n   13      HgiGraphicsEncoderDesc const& desc)\n   14:     : _device(device)\n   15      , _descriptor(desc)\n   16      , _vkRenderPass(nullptr)\n   ..\n   28  \n   29      // Prevent the render pass cache from deleting this render pass.\n   30:     _lastUsedFrame = _device->GetCurrentFrame();\n   31  \n   32      //\n   ..\n  174      TF_VERIFY(\n  175          VK_CREATE_RENDERPASS(\n  176:             _device->GetVulkanDevice(),\n  177              &renderPassInfo,\n  178              HgiVkAllocator(),\n  ...\n  184          std::string debugLabel = \"Render Pass \" + _descriptor.debugName;\n  185          HgiVkSetDebugName(\n  186:             _device,\n  187              (uint64_t)_vkRenderPass,\n  188              VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT,\n  ...\n  201      TF_VERIFY(\n  202          vkCreateFramebuffer(\n  203:             _device->GetVulkanDevice(),\n  204              &fbufCreateInfo,\n  205              HgiVkAllocator(),\n  ...\n  211          std::string debugLabel = \"Framebuffer \" + _descriptor.debugName;\n  212          HgiVkSetDebugName(\n  213:             _device,\n  214              (uint64_t)_vkFramebuffer,\n  215              VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT,\n  ...\n  221  {\n  222      vkDestroyFramebuffer(\n  223:         _device->GetVulkanDevice(),\n  224          _vkFramebuffer,\n  225          HgiVkAllocator());\n  226  \n  227      vkDestroyRenderPass(\n  228:         _device->GetVulkanDevice(),\n  229          _vkRenderPass,\n  230          HgiVkAllocator());\n  ...\n  250  {\n  251      // Prevent the render pass cache from deleting this render pass\n  252:     _lastUsedFrame = _device->GetCurrentFrame();\n  253  \n  254      // Begin render pass in primary command buffer\n\n/home/max/dev/Falcor/src/USD/hgiVk/renderPass.h:\n   44      #define VK_SUBPASS_DEPENDENCY VkSubpassDependency2KHR\n   45      #define VK_SUBPASS_DEPENDENCY_TYPE VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR\n   46:     #define VK_CREATE_RENDERPASS device->vkCreateRenderPass2KHR\n   47  #endif\n   48  \n   ..\n   55      HGIVK_API\n   56      HgiVkRenderPass(\n   57:         HgiVkDevice* device,\n   58          HgiGraphicsEncoderDesc const& desc);\n   59  \n   ..\n  132  \n  133  private:\n  134:     HgiVkDevice* _device;\n  135      HgiGraphicsEncoderDesc _descriptor;\n  136  \n\n/home/max/dev/Falcor/src/USD/hgiVk/renderPassPipelineCache.cpp:\n    5  #include \"pxr/imaging/hgi/graphicsEncoderDesc.h\"\n    6  \n    7: #include \"USD/hgiVk/device.h\"\n    8  #include \"USD/hgiVk/hgi.h\"\n    9  #include \"USD/hgiVk/object.h\"\n   ..\n   25          object.type = HgiVkObjectTypeRenderPass;\n   26          object.renderPass = renderPass;\n   27:         device->DestroyObject(object);\n   28      }\n   29  \n   30:     HgiVkDevice* device = nullptr;\n   31      HgiGraphicsEncoderDesc descriptor;\n   32      HgiVkRenderPass* renderPass = nullptr;\n   ..\n   46  static HgiVkRenderPassCacheItem*\n   47  _CreateRenderPassCacheItem(\n   48:     HgiVkDevice* device,\n   49      const HgiGraphicsEncoderDesc& desc)\n   50  {\n   51      HgiVkRenderPassCacheItem* rci = new HgiVkRenderPassCacheItem();\n   52:     rci->device = device;\n   53      rci->descriptor = desc;\n   54:     rci->renderPass = new HgiVkRenderPass(device, desc);\n   55      return rci;\n   56  }\n   ..\n  113  HgiVkRenderPass*\n  114  HgiVkRenderPassPipelineCache::AcquireRenderPass(\n  115:     HgiVkDevice* device,\n  116      HgiGraphicsEncoderDesc const& desc)\n  117  {\n  ...\n  163      // This new render pass will get merged into the renderPassCache at the\n  164      // end of the frame.\n  165:     HgiVkRenderPassCacheItem* pci = _CreateRenderPassCacheItem(device, desc);\n  166      pv.push_back(pci);\n  167      return pci->renderPass;\n\n/home/max/dev/Falcor/src/USD/hgiVk/renderPassPipelineCache.h:\n   51      HGIVK_API\n   52      HgiVkRenderPass* AcquireRenderPass(\n   53:         HgiVkDevice* device,\n   54          HgiGraphicsEncoderDesc const& desc);\n   55  \n   ..\n   65      /// Clears all render pass from cache.\n   66      /// This initiates destruction of all render passes and should generally\n   67:     /// only be called when the device is being destroyed.\n   68      HGIVK_API\n   69      void Clear();\n\n/home/max/dev/Falcor/src/USD/hgiVk/resourceBindings.cpp:\n    4  #include \"USD/hgiVk/commandBuffer.h\"\n    5  #include \"USD/hgiVk/conversions.h\"\n    6: #include \"USD/hgiVk/device.h\"\n    7  #include \"USD/hgiVk/diagnostic.h\"\n    8  #include \"USD/hgiVk/resourceBindings.h\"\n    .\n   13  \n   14  HgiVkResourceBindings::HgiVkResourceBindings(\n   15:     HgiVkDevice* device,\n   16      HgiResourceBindingsDesc const& desc)\n   17      : HgiResourceBindings(desc)\n   18:     , _device(device)\n   19      , _descriptor(desc)\n   20      , _vkDescriptorSetLayout(nullptr)\n   ..\n   78      // Check descriptor indexing support.\n   79      VkPhysicalDeviceDescriptorIndexingFeaturesEXT indexingFeatures =\n   80:         _device->GetVulkanPhysicalDeviceIndexingFeatures();\n   81      VkDescriptorBindingFlagsEXT bindFlags = 0;\n   82  \n   ..\n  114      TF_VERIFY(\n  115          vkCreateDescriptorSetLayout(\n  116:             _device->GetVulkanDevice(),\n  117              &setCreateInfo,\n  118              HgiVkAllocator(),\n  ...\n  124          std::string debugLabel = \"Descriptor Set Layout \" + _descriptor.debugName;\n  125          HgiVkSetDebugName(\n  126:             _device,\n  127              (uint64_t)_vkDescriptorSetLayout,\n  128              VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT,\n  ...\n  163      TF_VERIFY(\n  164          vkCreateDescriptorPool(\n  165:             _device->GetVulkanDevice(),\n  166              &pool_info,\n  167              HgiVkAllocator(),\n  ...\n  173          std::string debugLabel = \"Descriptor Pool \" + _descriptor.debugName;\n  174          HgiVkSetDebugName(\n  175:             _device,\n  176              (uint64_t)_vkDescriptorPool,\n  177              VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT,\n  ...\n  191      TF_VERIFY(\n  192          vkAllocateDescriptorSets(\n  193:             _device->GetVulkanDevice(),\n  194              &allocateInfo,\n  195              &_vkDescriptorSet) == VK_SUCCESS\n  ...\n  200          std::string debugLabel = \"Descriptor Set \" + _descriptor.debugName;\n  201          HgiVkSetDebugName(\n  202:             _device,\n  203              (uint64_t)_vkDescriptorSet,\n  204              VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT,\n  ...\n  210      //\n  211      VkPhysicalDeviceProperties const& devProps =\n  212:         _device->GetVulkanPhysicalDeviceProperties();\n  213      VkPhysicalDeviceLimits const& limits = devProps.limits;\n  214  \n  ...\n  318      // command buffer recording.\n  319      vkUpdateDescriptorSets(\n  320:         _device->GetVulkanDevice(),\n  321          (uint32_t) writeSets.size(),\n  322          writeSets.data(),\n  ...\n  349      TF_VERIFY(\n  350          vkCreatePipelineLayout(\n  351:             _device->GetVulkanDevice(),\n  352              &pipeLayCreateInfo,\n  353              HgiVkAllocator(),\n  ...\n  359          std::string debugLabel = \"Pipeline Layout \" + _descriptor.debugName;\n  360          HgiVkSetDebugName(\n  361:             _device,\n  362              (uint64_t)_vkPipelineLayout,\n  363              VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT,\n  ...\n  369  {\n  370      vkDestroyDescriptorSetLayout(\n  371:         _device->GetVulkanDevice(),\n  372          _vkDescriptorSetLayout,\n  373          HgiVkAllocator());\n  374  \n  375      vkDestroyPipelineLayout(\n  376:         _device->GetVulkanDevice(),\n  377          _vkPipelineLayout,\n  378          HgiVkAllocator());\n  ...\n  383      // if (_vkDescriptorSet) {\n  384      //     vkFreeDescriptorSets(\n  385:     //         _device->GetVulkanDevice(),\n  386      //         _vkDescriptorPool,\n  387      //         1,\n  ...\n  390      //\n  391      vkDestroyDescriptorPool(\n  392:         _device->GetVulkanDevice(),\n  393          _vkDescriptorPool,\n  394          HgiVkAllocator());\n\n/home/max/dev/Falcor/src/USD/hgiVk/resourceBindings.h:\n   27  /// There is a limit to how many descriptor sets that can be bound at one time.\n   28  /// Aiming for 4 seems like a safe minimum:\n   29: /// http://vulkan.gpuinfo.org/displaydevicelimit.php?name=maxBoundDescriptorSets\n   30  ///\n   31  /// This does not affect how many sets you can make, but you likely want to\n   ..\n   39      HGIVK_API\n   40      HgiVkResourceBindings(\n   41:         HgiVkDevice* device,\n   42          HgiResourceBindingsDesc const& desc);\n   43  \n   ..\n   83  \n   84  private:\n   85:     HgiVkDevice* _device;\n   86      HgiResourceBindingsDesc _descriptor;\n   87  \n\n/home/max/dev/Falcor/src/USD/hgiVk/shaderFunction.cpp:\n    2  \n    3  #include \"USD/hgiVk/conversions.h\"\n    4: #include \"USD/hgiVk/device.h\"\n    5  #include \"USD/hgiVk/diagnostic.h\"\n    6  #include \"USD/hgiVk/shaderFunction.h\"\n    .\n   10  \n   11  HgiVkShaderFunction::HgiVkShaderFunction(\n   12:     HgiVkDevice* device,\n   13      HgiShaderFunctionDesc const& desc)\n   14      : HgiShaderFunction(desc)\n   15:     , _device(device)\n   16      , _descriptor(desc)\n   17      , _vkShaderModule(nullptr)\n   ..\n   20          {VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO};\n   21  \n   22:     HgiVkShaderCompiler* shaderCompiler = device->GetShaderCompiler();\n   23  \n   24      std::vector<unsigned int> spirv;\n   ..\n   42          TF_VERIFY(\n   43              vkCreateShaderModule(\n   44:                 _device->GetVulkanDevice(),\n   45                  &shaderCreateInfo,\n   46                  HgiVkAllocator(),\n   ..\n   52              std::string debugLabel = \"ShaderModule \" + _descriptor.debugName;\n   53              HgiVkSetDebugName(\n   54:                 _device,\n   55                  (uint64_t)_vkShaderModule,\n   56                  VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT,\n   ..\n   64      if (_vkShaderModule) {\n   65          vkDestroyShaderModule(\n   66:             _device->GetVulkanDevice(),\n   67              _vkShaderModule,\n   68              HgiVkAllocator());\n\n/home/max/dev/Falcor/src/USD/hgiVk/shaderFunction.h:\n   21      HGIVK_API\n   22      HgiVkShaderFunction(\n   23:         HgiVkDevice* device,\n   24          HgiShaderFunctionDesc const& desc);\n   25  \n   ..\n   53  \n   54  private:\n   55:     HgiVkDevice* _device;\n   56      HgiShaderFunctionDesc _descriptor;\n   57      std::string _errors;\n\n/home/max/dev/Falcor/src/USD/hgiVk/surface.cpp:\n    1  #include \"pxr/base/tf/diagnostic.h\"\n    2  \n    3: #include \"USD/hgiVk/device.h\"\n    4  #include \"USD/hgiVk/instance.h\"\n    5  #include \"USD/hgiVk/surface.h\"\n    .\n   83  HgiVkSurface::HgiVkSurface(\n   84      HgiVkInstance* instance,\n   85:     HgiVkDevice* device,\n   86      HgiVkSurfaceDesc const& desc)\n   87      : _instance(instance)\n   ..\n   98      TF_VERIFY(\n   99          vkGetPhysicalDeviceSurfaceSupportKHR(\n  100:             device->GetVulkanPhysicalDevice(),\n  101:             device->GetVulkanDeviceQueueFamilyIndex(),\n  102              _vkSurface,\n  103              &presentSupported) == VK_SUCCESS\n  104      );\n  105  \n  106:     TF_VERIFY(presentSupported, \"Presenting not supported on Vulkan device\");\n  107  }\n  108  \n\n/home/max/dev/Falcor/src/USD/hgiVk/surface.h:\n   42      HgiVkSurface(\n   43          HgiVkInstance* instance,\n   44:         HgiVkDevice* device,\n   45          HgiVkSurfaceDesc const& desc);\n   46  \n\n/home/max/dev/Falcor/src/USD/hgiVk/swapchain.cpp:\n    3  #include \"USD/hgiVk/commandBuffer.h\"\n    4  #include \"USD/hgiVk/conversions.h\"\n    5: #include \"USD/hgiVk/device.h\"\n    6  #include \"USD/hgiVk/diagnostic.h\"\n    7  #include \"USD/hgiVk/renderPass.h\"\n    .\n   36  static VkFormat\n   37  _GetSurfaceFormat(\n   38:     HgiVkDevice* device,\n   39      HgiVkSurface* surface)\n   40  {\n   ..\n   42      TF_VERIFY(\n   43          vkGetPhysicalDeviceSurfaceFormatsKHR(\n   44:             device->GetVulkanPhysicalDevice(),\n   45              surface->GetVulkanSurface(),\n   46              &formatCount,\n   ..\n   53      TF_VERIFY(\n   54          vkGetPhysicalDeviceSurfaceFormatsKHR(\n   55:             device->GetVulkanPhysicalDevice(),\n   56              surface->GetVulkanSurface(),\n   57              &formatCount,\n   ..\n   76  static void\n   77  _DestroyVulkanSwapchain(\n   78:     HgiVkDevice* device,\n   79      VkSwapchainKHR vkSwapchain,\n   80      VkSemaphore vkAcquireSemaphore,\n   ..\n   83  {\n   84      TF_VERIFY(\n   85:         vkDeviceWaitIdle(device->GetVulkanDevice()) == VK_SUCCESS\n   86      );\n   87  \n   88      for (uint32_t i = 0; i < vkImageViews.size(); i++) {\n   89          vkDestroyImageView(\n   90:             device->GetVulkanDevice(),\n   91              vkImageViews[i],\n   92              HgiVkAllocator());\n   ..\n   94  \n   95      vkDestroySwapchainKHR(\n   96:         device->GetVulkanDevice(),\n   97          vkSwapchain,\n   98          HgiVkAllocator());\n   99  \n  100      vkDestroySemaphore(\n  101:         device->GetVulkanDevice(),\n  102          vkReleaseSemaphore,\n  103          HgiVkAllocator());\n  104  \n  105      vkDestroySemaphore(\n  106:         device->GetVulkanDevice(),\n  107          vkAcquireSemaphore,\n  108          HgiVkAllocator());\n  ...\n  110  \n  111  HgiVkSwapchain::HgiVkSwapchain(\n  112:     HgiVkDevice* device,\n  113      HgiVkSurfaceHandle surface)\n  114:     : _device(device)\n  115      , _surface(surface)\n  116      , _width(0)\n  ...\n  130      _PreDestroyVulkanSwapchain();\n  131      _DestroyVulkanSwapchain(\n  132:         _device,\n  133          _vkSwapchain,\n  134          _vkAcquireSemaphore,\n  ...\n  213      TF_VERIFY(\n  214          vkQueueSubmit(\n  215:             _device->GetVulkanDeviceQueue(),\n  216              1,\n  217              &submitInfo,\n  ...\n  229  \n  230      VkResult res = vkQueuePresentKHR(\n  231:         _device->GetVulkanDeviceQueue(),\n  232          &vkPresentInfo);\n  233  \n  ...\n  269      TF_VERIFY(\n  270          vkGetPhysicalDeviceSurfaceCapabilitiesKHR(\n  271:             _device->GetVulkanPhysicalDevice(),\n  272              _surface->GetVulkanSurface(),\n  273              &surfaceCaps) == VK_SUCCESS\n  ...\n  276      _width = surfaceCaps.currentExtent.width;\n  277      _height = surfaceCaps.currentExtent.height;\n  278:     _vkSwapchainFormat = _GetSurfaceFormat(_device, _surface);\n  279  \n  280      //\n  ...\n  310          VK_IMAGE_USAGE_TRANSFER_DST_BIT;      // for blitting\n  311      swapCreateInfo.queueFamilyIndexCount = 1;\n  312:     uint32_t queueFamilyIndex = _device->GetVulkanDeviceQueueFamilyIndex();\n  313      swapCreateInfo.pQueueFamilyIndices = &queueFamilyIndex;\n  314      swapCreateInfo.preTransform = VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR;\n  ...\n  319      TF_VERIFY(\n  320          vkCreateSwapchainKHR(\n  321:             _device->GetVulkanDevice(),\n  322              &swapCreateInfo,\n  323              HgiVkAllocator(),\n  ...\n  330          std::string debugLabel = \"Swapchain HgiVk\";\n  331          HgiVkSetDebugName(\n  332:             _device,\n  333              (uint64_t)_vkSwapchain,\n  334              VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT,\n  ...\n  342      TF_VERIFY(\n  343          vkGetSwapchainImagesKHR(\n  344:             _device->GetVulkanDevice(),\n  345              _vkSwapchain,\n  346              &imageCount,\n  ...\n  355      TF_VERIFY(\n  356          vkGetSwapchainImagesKHR(\n  357:             _device->GetVulkanDevice(),\n  358              _vkSwapchain,\n  359              &imageCount,\n  ...\n  368      TF_VERIFY(\n  369          vkCreateSemaphore(\n  370:             _device->GetVulkanDevice(),\n  371              &semaCreateInfo,\n  372              HgiVkAllocator(),\n  ...\n  378          std::string debugLabel = \"Semaphore Acquire HgiVk Swapchain\";\n  379          HgiVkSetDebugName(\n  380:             _device,\n  381              (uint64_t)_vkAcquireSemaphore,\n  382              VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT,\n  ...\n  386      TF_VERIFY(\n  387          vkCreateSemaphore(\n  388:             _device->GetVulkanDevice(),\n  389              &semaCreateInfo,\n  390              HgiVkAllocator(),\n  ...\n  396          std::string debugLabel = \"Semaphore Release HgiVk Swapchain\";\n  397          HgiVkSetDebugName(\n  398:             _device,\n  399              (uint64_t)_vkReleaseSemaphore,\n  400              VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT,\n  ...\n  417          TF_VERIFY(\n  418              vkCreateImageView(\n  419:                 _device->GetVulkanDevice(),\n  420                  &createInfo,\n  421                  HgiVkAllocator(),\n  ...\n  429                                       \" HgiVk Swapchain\";\n  430              HgiVkSetDebugName(\n  431:                 _device,\n  432                  (uint64_t)_vkImageViews[i],\n  433                  VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT,\n  ...\n  460          texVkDesc.sampler = nullptr;\n  461  \n  462:         HgiVkTexture* tex = new HgiVkTexture(_device, texDesc, texVkDesc);\n  463          _textures[i] = tex;\n  464      }\n  ...\n  479          renderPassDesc.colorAttachments.emplace_back(std::move(attachment));\n  480  \n  481:         HgiVkRenderPass* rp = _device->AcquireRenderPass(renderPassDesc);\n  482          _renderPasses.push_back(rp);\n  483      }\n  ...\n  519      _CreateVulkanSwapchain();\n  520      _DestroyVulkanSwapchain(\n  521:         _device,\n  522          vkSwapchain,\n  523          vkAcquireSemaphore,\n  ...\n  532      TF_VERIFY(\n  533          vkGetPhysicalDeviceSurfaceCapabilitiesKHR(\n  534:             _device->GetVulkanPhysicalDevice(),\n  535              _surface->GetVulkanSurface(),\n  536              &surfaceCaps) == VK_SUCCESS\n  ...\n  551  {\n  552      return vkAcquireNextImageKHR(\n  553:         _device->GetVulkanDevice(),\n  554          _vkSwapchain,\n  555          ~0ull,\n\n/home/max/dev/Falcor/src/USD/hgiVk/swapchain.h:\n   27      HGIVK_API\n   28      HgiVkSwapchain(\n   29:         HgiVkDevice* device,\n   30          HgiVkSurfaceHandle surface);\n   31  \n   ..\n   78  \n   79  private:\n   80:     HgiVkDevice* _device;\n   81      HgiVkSurface* _surface;\n   82  \n\n/home/max/dev/Falcor/src/USD/hgiVk/texture.cpp:\n    1: #include \"USD/hgiVk/device.h\"\n    2  #include \"USD/hgiVk/diagnostic.h\"\n    3  #include \"USD/hgiVk/commandBuffer.h\"\n    .\n   20  \n   21  HgiVkTexture::HgiVkTexture(\n   22:     HgiVkDevice* device,\n   23      HgiVkCommandBuffer* cb,\n   24      HgiTextureDesc const & desc)\n   25      : HgiTexture(desc)\n   26:     , _device(device)\n   27      , _descriptor(desc)\n   28      , _vkImage(nullptr)\n   29      , _vmaImageAllocation(nullptr)\n   30  {\n   31:     TF_VERIFY(device && cb);\n   32  \n   33      VkPhysicalDeviceProperties const& vkDeviceProps =\n   34:         device->GetVulkanPhysicalDeviceProperties();\n   35  \n   36      VkPhysicalDeviceFeatures const& vkDeviceFeatures =\n   37:         device->GetVulkanPhysicalDeviceFeatures();\n   38  \n   39      GfVec3i const& dimensions = desc.dimensions;\n   ..\n   71  \n   72      if (!_CheckFormatSupport(\n   73:             device->GetVulkanPhysicalDevice(),\n   74              imageCreateInfo.format,\n   75              formatValidationFlags)) {\n   76:         TF_CODING_ERROR(\"Image format not supported on device\");\n   77      };\n   78  \n   ..\n   86      TF_VERIFY(\n   87          vmaCreateImage(\n   88:             device->GetVulkanMemoryAllocator(),\n   89              &imageCreateInfo,\n   90              &allocInfo,\n   ..\n   98          std::string debugLabel = \"Image \" + _descriptor.debugName;\n   99          HgiVkSetDebugName(\n  100:             _device,\n  101              (uint64_t)_vkImage,\n  102              VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT,\n  ...\n  133      TF_VERIFY(\n  134          vkCreateSampler(\n  135:             device->GetVulkanDevice(),\n  136              &sampler,\n  137              HgiVkAllocator(),\n  ...\n  143          std::string debugLabel = \"Sampler \" + _descriptor.debugName;\n  144          HgiVkSetDebugName(\n  145:             _device,\n  146              (uint64_t)_vkDescriptor.sampler,\n  147              VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT,\n  ...\n  192      TF_VERIFY(\n  193          vkCreateImageView(\n  194:             device->GetVulkanDevice(),\n  195              &view,\n  196              HgiVkAllocator(),\n  ...\n  202          std::string debugLabel = \"Image View \" + _descriptor.debugName;\n  203          HgiVkSetDebugName(\n  204:             _device,\n  205              (uint64_t)_vkDescriptor.imageView,\n  206              VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT,\n  ...\n  247  \n  248  HgiVkTexture::HgiVkTexture(\n  249:     HgiVkDevice* device,\n  250      HgiTextureDesc const & desc,\n  251      VkDescriptorImageInfo const& vkDesc)\n  252      : HgiTexture(desc)\n  253:     , _device(device)\n  254      , _descriptor(desc)\n  255      , _vkDescriptor(vkDesc)\n  ...\n  274  \n  275      vkDestroyImageView(\n  276:         _device->GetVulkanDevice(),\n  277          _vkDescriptor.imageView,\n  278          HgiVkAllocator());\n  279  \n  280      vkDestroySampler(\n  281:         _device->GetVulkanDevice(),\n  282          _vkDescriptor.sampler,\n  283          HgiVkAllocator());\n  284  \n  285      vmaDestroyImage(\n  286:         _device->GetVulkanMemoryAllocator(),\n  287          _vkImage,\n  288          _vmaImageAllocation);\n\n/home/max/dev/Falcor/src/USD/hgiVk/texture.h:\n   26      HGIVK_API\n   27      HgiVkTexture(\n   28:         HgiVkDevice* device,\n   29          HgiVkCommandBuffer* cb,\n   30          HgiTextureDesc const & desc);\n   ..\n   33      HGIVK_API\n   34      HgiVkTexture(\n   35:         HgiVkDevice* device,\n   36          HgiTextureDesc const & desc,\n   37          VkDescriptorImageInfo const& vkDesc);\n   ..\n   85  \n   86  private:\n   87:     HgiVkDevice* _device;\n   88  \n   89      HgiTextureDesc _descriptor;\n\n/home/max/dev/Falcor/src/USD/hgiVk/vulkanMemoryAllocator/vk_mem_alloc.h:\n  156  VmaAllocatorCreateInfo allocatorInfo = {};\n  157  allocatorInfo.physicalDevice = physicalDevice;\n  158: allocatorInfo.device = device;\n  159  \n  160  VmaAllocator allocator;\n  ...\n  194  \\page choosing_memory_type Choosing memory type\n  195  \n  196: Physical devices in Vulkan support various combinations of memory heaps and\n  197  types. Help with choosing correct and optimal memory type for your specific\n  198  resource is one of the key features of this library. You can use it by filling\n  ...\n  203     can use function: vmaFindMemoryTypeIndex(), vmaFindMemoryTypeIndexForBufferInfo(),\n  204     vmaFindMemoryTypeIndexForImageInfo().\n  205: -# If you want to allocate a region of device memory without association with any\n  206     specific image or buffer, you can use function vmaAllocateMemory(). Usage of\n  207     this function is not recommended and usually not needed.\n  ...\n  280  \\section choosing_memory_type_explicit_memory_types Explicit memory types\n  281  \n  282: If you inspected memory types available on the physical device and you have\n  283  a preference for memory types that you want to use, you can fill member\n  284  VmaAllocationCreateInfo::memoryTypeBits. It is a bit mask, where each bit set\n  ...\n  325  - When [VK_KHR_dedicated_allocation](@ref vk_khr_dedicated_allocation) extension is enabled\n  326    and it reports that dedicated allocation is required or recommended for the resource.\n  327: - When allocation of next big memory block fails due to not enough device memory,\n  328    but allocation with the exact requested size succeeds.\n  329  \n  ...\n  375  When mapping, you may see a warning from Vulkan validation layer similar to this one:\n  376  \n  377: <i>Mapping an image with layout VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL can result in undefined behavior if this memory is used by the device. Only GENERAL or PREINITIALIZED should be used.</i>\n  378  \n  379  It happens because the library maps entire `VkDeviceMemory` block, where different\n  ...\n  415  \n  416  - When operating system is Windows 7 or 8.x (Windows 10 is not affected because it uses WDDM2),\n  417:   device is discrete AMD GPU,\n  418    and memory type is the special 256 MiB pool of `DEVICE_LOCAL + HOST_VISIBLE` memory\n  419    (selected when you use #VMA_MEMORY_USAGE_CPU_TO_GPU),\n  ...\n  554  only to obtain statistical information, e.g. for debugging purposes.\n  555  \n  556: It is recommended to use <b>VK_EXT_memory_budget</b> device extension to obtain information\n  557: about the budget from Vulkan device. VMA is able to use this extension automatically.\n  558  When not enabled, the allocator behaves same way, but then it estimates current usage\n  559  and available budget based on its internal information and Vulkan memory heap sizes,\n  560  which may be less precise. In order to use this extension:\n  561  \n  562: 1. Make sure extensions VK_EXT_memory_budget and VK_KHR_get_physical_device_properties2\n  563:    required by it are available and enable them. Please note that the first is a device\n  564     extension and the second is instance extension!\n  565  2. Use flag #VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT when creating #VmaAllocator object.\n  ...\n  603  \n  604  A memory pool contains a number of `VkDeviceMemory` blocks.\n  605: The library automatically creates and manages default pool for each memory type available on the device.\n  606  Default memory pool automatically grows in size.\n  607  Size of allocated blocks is also variable and managed automatically.\n  ...\n  830  \n  831  - Updates #VmaAllocation objects to point to new `VkDeviceMemory` and offset.\n  832:   After allocation has been moved, its VmaAllocationInfo::deviceMemory and/or\n  833    VmaAllocationInfo::offset changes. You must query them again using\n  834    vmaGetAllocationInfo() if you need them.\n  ...\n  859  \\code\n  860  // Given following variables already initialized:\n  861: VkDevice device;\n  862  VmaAllocator allocator;\n  863  std::vector<VkBuffer> buffers;\n  ...\n  884      {\n  885          // Destroy buffer that is immutably bound to memory region which is no longer valid.\n  886:         vkDestroyBuffer(device, buffers[i], nullptr);\n  887  \n  888          // Create new buffer with same parameters.\n  889          VkBufferCreateInfo bufferInfo = ...;\n  890:         vkCreateBuffer(device, &bufferInfo, nullptr, &buffers[i]);\n  891              \n  892          // You can make dummy call to vkGetBufferMemoryRequirements here to silence validation layer warning.\n  ...\n  926  \\code\n  927  // Given following variables already initialized:\n  928: VkDevice device;\n  929  VmaAllocator allocator;\n  930  VkCommandBuffer commandBuffer;\n  ...\n  962      {\n  963          // Destroy buffer that is immutably bound to memory region which is no longer valid.\n  964:         vkDestroyBuffer(device, buffers[i], nullptr);\n  965  \n  966          // Create new buffer with same parameters.\n  967          VkBufferCreateInfo bufferInfo = ...;\n  968:         vkCreateBuffer(device, &bufferInfo, nullptr, &buffers[i]);\n  969              \n  970          // You can make dummy call to vkGetBufferMemoryRequirements here to silence validation layer warning.\n  ...\n 1020     class `VmaDefragmentationAlgorithm` and implement your version of its pure virtual methods.\n 1021     See definition and comments of this class for details.\n 1022: -# Your code needs to interact with device memory block metadata.\n 1023     If you need more access to its data than it's provided by its public interface,\n 1024     declare your new class as a friend class e.g. in class `VmaBlockMetadata_Generic`.\n ....\n 1049  You mustn't forget to destroy this allocation and this buffer/image.\n 1050  vmaGetAllocationInfo() can also be used for checking status of the allocation.\n 1051: Allocation is lost when returned VmaAllocationInfo::deviceMemory == `VK_NULL_HANDLE`.\n 1052  \n 1053  To create an allocation that can make some other allocations lost to make room\n ....\n 1522  by detecting it in Vulkan.\n 1523  To do it, call `vkGetPhysicalDeviceProperties()`, inspect\n 1524: `VkPhysicalDeviceProperties::deviceType` and look for `VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU`.\n 1525  When you find it, you can assume that memory is unified and all memory types are comparably fast\n 1526  to access from GPU, regardless of `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`.\n ....\n 1613  \\section heap_memory_limit Device heap memory limit\n 1614  \n 1615: When device memory of certain heap runs out of free space, new allocations may\n 1616  fail (returning error code) or they may succeed, silently pushing some existing\n 1617  memory blocks from GPU VRAM to system RAM (which degrades performance). This\n ....\n 1619  driver.\n 1620  \n 1621: On AMD cards it can be controlled while creating Vulkan device object by using\n 1622  VK_AMD_memory_overallocation_behavior extension, if available.\n 1623  \n 1624: Alternatively, if you want to test how your program behaves with limited amount of Vulkan device\n 1625  memory available without switching your graphics card to one that really has\n 1626  smaller VRAM, you can use a feature of this library intended for this purpose.\n ....\n 1640  enabled. To enable it:\n 1641  \n 1642: 1 . When creating Vulkan device, check if following 2 device extensions are\n 1643  supported (call `vkEnumerateDeviceExtensionProperties()`).\n 1644  If yes, enable them (fill `VkDeviceCreateInfo::ppEnabledExtensionNames`).\n ....\n 1706    - It happens when VK_KHR_dedicated_allocation extension is enabled.\n 1707      `vkGetBufferMemoryRequirements2KHR` function is used instead, while validation layer seems to be unaware of it.\n 1708: - *Mapping an image with layout VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL can result in undefined behavior if this memory is used by the device. Only GENERAL or PREINITIALIZED should be used.*\n 1709    - It happens when you map a buffer or image, because the library maps entire\n 1710      `VkDeviceMemory` block, where different types of images and buffers may end\n ....\n 1810  \n 1811  #if !defined(VMA_MEMORY_BUDGET)\n 1812:     #if VK_EXT_memory_budget && (VK_KHR_get_physical_device_properties2 || VMA_VULKAN_VERSION >= 1001000)\n 1813          #define VMA_MEMORY_BUDGET 1\n 1814      #else\n ....\n 1836  \n 1837  It is recommended to create just one object of this type per `VkDevice` object,\n 1838: right after Vulkan is initialized and keep it alive until before Vulkan device is destroyed.\n 1839  */\n 1840  VK_DEFINE_HANDLE(VmaAllocator)\n ....\n 1885      GPUs.\n 1886  \n 1887:     You may set this flag only if you found out that following device extensions are\n 1888:     supported, you enabled them while creating Vulkan device passed as\n 1889:     VmaAllocatorCreateInfo::device, and you want them to be used internally by this\n 1890      library:\n 1891  \n 1892:     - VK_KHR_get_memory_requirements2 (device extension)\n 1893:     - VK_KHR_dedicated_allocation (device extension)\n 1894  \n 1895      When this flag is set, you can experience following warnings reported by Vulkan\n ....\n 1905      When it's `VK_API_VERSION_1_1`, the flag is ignored because the extension has been promoted to Vulkan 1.1.\n 1906  \n 1907:     You may set this flag only if you found out that this device extension is supported,\n 1908:     you enabled it while creating Vulkan device passed as VmaAllocatorCreateInfo::device,\n 1909      and you want it to be used internally by this library.\n 1910  \n ....\n 1917      Enables usage of VK_EXT_memory_budget extension.\n 1918  \n 1919:     You may set this flag only if you found out that this device extension is supported,\n 1920:     you enabled it while creating Vulkan device passed as VmaAllocatorCreateInfo::device,\n 1921      and you want it to be used internally by this library, along with another instance extension\n 1922:     VK_KHR_get_physical_device_properties2, which is required by it (or Vulkan 1.1, where this extension is promoted).\n 1923  \n 1924      The extension provides query for current memory usage and budget, which will probably\n ....\n 1999      /// Flags for created allocator. Use #VmaAllocatorCreateFlagBits enum.\n 2000      VmaAllocatorCreateFlags flags;\n 2001:     /// Vulkan physical device.\n 2002      /** It must be valid throughout whole lifetime of created allocator. */\n 2003      VkPhysicalDevice physicalDevice;\n 2004:     /// Vulkan device.\n 2005      /** It must be valid throughout whole lifetime of created allocator. */\n 2006:     VkDevice device;\n 2007      /// Preferred size of a single `VkDeviceMemory` block to be allocated from large heaps > 1 GiB. Optional.\n 2008      /** Set to 0 to use default, which is currently 256 MiB. */\n ....\n 2048      smaller amount of memory, because graphics driver doesn't necessary fail new\n 2049      allocations with `VK_ERROR_OUT_OF_DEVICE_MEMORY` result when memory capacity is\n 2050:     exceeded. It may return success and just silently migrate some device memory\n 2051      blocks to system RAM. This driver behavior can also be controlled using\n 2052      VK_AMD_memory_overallocation_behavior extension.\n ....\n 2219  /** \\brief Retrieves information about current memory budget for all memory heaps.\n 2220  \n 2221: \\param[out] pBudget Must point to array with number of elements at least equal to number of memory heaps in physical device used.\n 2222  \n 2223  This function is called \"get\" not \"calculate\" because it is very fast, suitable to be called\n ....\n 2267      */\n 2268      VMA_MEMORY_USAGE_UNKNOWN = 0,\n 2269:     /** Memory will be used on device only, so fast access from the device is preferred.\n 2270:     It usually means device-local GPU (video) memory.\n 2271      No need to be mappable on host.\n 2272      It is roughly equivalent of `D3D12_HEAP_TYPE_DEFAULT`.\n ....\n 2274      Usage:\n 2275      \n 2276:     - Resources written and read by device, e.g. images used as attachments.\n 2277      - Resources transferred from host once (immutable) or infrequently and read by\n 2278:       device multiple times, e.g. textures to be sampled, vertex buffers, uniform\n 2279        (constant) buffers, and majority of other types of resources used on GPU.\n 2280  \n ....\n 2288      Guarantees to be `HOST_VISIBLE` and `HOST_COHERENT`.\n 2289      CPU access is typically uncached. Writes may be write-combined.\n 2290:     Resources created in this pool may still be accessible to the device, but access to them can be slow.\n 2291      It is roughly equivalent of `D3D12_HEAP_TYPE_UPLOAD`.\n 2292  \n ....\n 2298      CPU access is typically uncached. Writes may be write-combined.\n 2299  \n 2300:     Usage: Resources written frequently by host (dynamic), read by device. E.g. textures, vertex buffers, uniform buffers updated every frame or every draw call.\n 2301      */\n 2302      VMA_MEMORY_USAGE_CPU_TO_GPU = 3,\n ....\n 2306      Usage:\n 2307  \n 2308:     - Resources written by device, read by host - results of some computations, e.g. screen capture, average scene luminance for HDR tone mapping.\n 2309      - Any resources read or accessed randomly on host, e.g. CPU-side copy of vertex buffer used as source of transfer, but also used for collision detection.\n 2310      */\n ....\n 2366  \n 2367      To check if allocation is not lost, call vmaGetAllocationInfo() and check if\n 2368:     VmaAllocationInfo::deviceMemory is not `VK_NULL_HANDLE`.\n 2369  \n 2370      For details about supporting lost allocations, see Lost Allocations\n ....\n 2398      */\n 2399      VMA_ALLOCATION_CREATE_DONT_BIND_BIT = 0x00000080,\n 2400:     /** Create allocation only if additional device memory required for it, if any, won't exceed\n 2401      memory budget. Otherwise return `VK_ERROR_OUT_OF_DEVICE_MEMORY`.\n 2402      */\n ....\n 2495  \\return Returns VK_ERROR_FEATURE_NOT_PRESENT if not found. Receiving such result\n 2496  from this function or any other allocating function probably means that your\n 2497: device doesn't support any memory type with requested features for the specific\n 2498  type of resource you want to use it for. Please check parameters of your\n 2499  resource, like image layout (OPTIMAL versus LINEAR) or mip level count.\n ....\n 2674  } VmaPoolStats;\n 2675  \n 2676: /** \\brief Allocates Vulkan device memory and creates #VmaPool object.\n 2677  \n 2678  @param allocator Allocator object.\n ....\n 2685  \tVmaPool* pPool);\n 2686  \n 2687: /** \\brief Destroys #VmaPool object and frees Vulkan device memory.\n 2688  */\n 2689  VMA_CALL_PRE void VMA_CALL_POST vmaDestroyPool(\n ....\n 2792      If the allocation is lost, it is equal to `VK_NULL_HANDLE`.\n 2793      */\n 2794:     VkDeviceMemory deviceMemory;\n 2795:     /** \\brief Offset into deviceMemory object to the beginning of this allocation, in bytes. (deviceMemory, offset) pair is unique to this allocation.\n 2796  \n 2797      It can change after call to vmaDefragment() if this allocation is passed to the function, or if allocation is lost.\n ....\n 2924  This function also atomically \"touches\" allocation - marks it as used in current frame,\n 2925  just like vmaTouchAllocation().\n 2926: If the allocation is in lost state, `pAllocationInfo->deviceMemory == VK_NULL_HANDLE`.\n 2927  \n 2928  Although this function uses atomics and doesn't lock any mutex, so it should be quite efficient,\n ....\n 3234      uint32_t allocationsMoved;\n 3235      /// Number of empty `VkDeviceMemory` objects that have been released to the system.\n 3236:     uint32_t deviceMemoryBlocksFreed;\n 3237  } VmaDefragmentationStats;\n 3238  \n ....\n 3446  \n 3447  \\code\n 3448: vkDestroyBuffer(device, buffer, allocationCallbacks);\n 3449  vmaFreeMemory(allocator, allocation);\n 3450  \\endcode\n ....\n 3471  \n 3472  \\code\n 3473: vkDestroyImage(device, image, allocationCallbacks);\n 3474  vmaFreeMemory(allocator, allocation);\n 3475  \\endcode\n ....\n 6182  \n 6183  /*\n 6184: Represents a single block of device memory (`VkDeviceMemory`) with all the\n 6185  data about its regions (aka suballocations, #VmaAllocation), assigned and free.\n 6186  \n ....\n 7192      bool IsIntegratedGpu() const\n 7193      {\n 7194:         return m_PhysicalDeviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU;\n 7195      }\n 7196  \n ....\n 12772                  if(pDefragmentationStats != VMA_NULL)\n 12773                  {\n 12774:                     ++pDefragmentationStats->deviceMemoryBlocksFreed;\n 12775                      pDefragmentationStats->bytesFreed += pBlock->m_pMetadata->GetSize();\n 12776                  }\n .....\n 14759      fprintf(m_File, \"PhysicalDevice,driverVersion,%u\\n\", devProps.driverVersion);\n 14760      fprintf(m_File, \"PhysicalDevice,vendorID,%u\\n\", devProps.vendorID);\n 14761:     fprintf(m_File, \"PhysicalDevice,deviceID,%u\\n\", devProps.deviceID);\n 14762:     fprintf(m_File, \"PhysicalDevice,deviceType,%u\\n\", devProps.deviceType);\n 14763:     fprintf(m_File, \"PhysicalDevice,deviceName,%s\\n\", devProps.deviceName);\n 14764  \n 14765      fprintf(m_File, \"PhysicalDeviceLimits,maxMemoryAllocationCount,%u\\n\", devProps.limits.maxMemoryAllocationCount);\n .....\n 14857      m_UseKhrBindMemory2((pCreateInfo->flags & VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT) != 0),\n 14858      m_UseExtMemoryBudget((pCreateInfo->flags & VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT) != 0),\n 14859:     m_hDevice(pCreateInfo->device),\n 14860      m_hInstance(pCreateInfo->instance),\n 14861      m_AllocationCallbacksSpecified(pCreateInfo->pAllocationCallbacks != VMA_NULL),\n .....\n 14886      }\n 14887  \n 14888:     VMA_ASSERT(pCreateInfo->physicalDevice && pCreateInfo->device);\n 14889  \n 14890      if(m_VulkanApiVersion < VK_MAKE_VERSION(1, 1, 0))\n .....\n 15928              {\n 15929                  pAllocationInfo->memoryType = UINT32_MAX;\n 15930:                 pAllocationInfo->deviceMemory = VK_NULL_HANDLE;\n 15931                  pAllocationInfo->offset = 0;\n 15932                  pAllocationInfo->size = hAllocation->GetSize();\n .....\n 15938              {\n 15939                  pAllocationInfo->memoryType = hAllocation->GetMemoryTypeIndex();\n 15940:                 pAllocationInfo->deviceMemory = hAllocation->GetMemory();\n 15941                  pAllocationInfo->offset = hAllocation->GetOffset();\n 15942                  pAllocationInfo->size = hAllocation->GetSize();\n .....\n 15977  \n 15978          pAllocationInfo->memoryType = hAllocation->GetMemoryTypeIndex();\n 15979:         pAllocationInfo->deviceMemory = hAllocation->GetMemory();\n 15980          pAllocationInfo->offset = hAllocation->GetOffset();\n 15981          pAllocationInfo->size = hAllocation->GetSize();\n\n1320 matches across 220 files\n\n\nSearching 1282 files for \"mapBufferApi\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Buffer.cpp:\n   58  \n   59  size_t getBufferDataAlignment(const Buffer* pBuffer);\n   60: void* mapBufferApi(const Buffer::ApiHandle& apiHandle, size_t size);\n   61  \n   62  Buffer::Buffer(std::shared_ptr<Device> pDevice, size_t size, BindFlags bindFlags, CpuAccess cpuAccess): Resource(pDevice, Type::Buffer, bindFlags, size), mCpuAccess(cpuAccess) {}\n   ..\n  263          } else if (mCpuAccess == CpuAccess::Read) {\n  264              assert(mBindFlags == BindFlags::None);\n  265:             return mapBufferApi(mApiHandle, mSize);\n  266          } else {\n  267              // For buffers without CPU access we must copy the contents to a staging buffer.\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Buffer.cpp:\n   71      }\n   72  \n   73:     void* mapBufferApi(const Buffer::ApiHandle& apiHandle, size_t size)\n   74      {\n   75          D3D12_RANGE r{ 0, size };\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKBuffer.cpp:\n   47  }\n   48  \n   49: void* mapBufferApi(Device::SharedPtr device, const Buffer::ApiHandle& apiHandle, size_t size) {\n   50      void* pData;\n   51      vk_call(vkMapMemory(apiHandle.device()->getApiHandle(), apiHandle, 0, size, 0, &pData));\n\n4 matches across 3 files\n\n\nSearching 1282 files for \"mapBufferApi\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Buffer.cpp:\n   58  \n   59  size_t getBufferDataAlignment(const Buffer* pBuffer);\n   60: void* mapBufferApi(const Buffer::ApiHandle& apiHandle, size_t size);\n   61  \n   62  Buffer::Buffer(std::shared_ptr<Device> pDevice, size_t size, BindFlags bindFlags, CpuAccess cpuAccess): Resource(pDevice, Type::Buffer, bindFlags, size), mCpuAccess(cpuAccess) {}\n   ..\n  263          } else if (mCpuAccess == CpuAccess::Read) {\n  264              assert(mBindFlags == BindFlags::None);\n  265:             return mapBufferApi(mApiHandle, mSize);\n  266          } else {\n  267              // For buffers without CPU access we must copy the contents to a staging buffer.\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Buffer.cpp:\n   71      }\n   72  \n   73:     void* mapBufferApi(const Buffer::ApiHandle& apiHandle, size_t size)\n   74      {\n   75          D3D12_RANGE r{ 0, size };\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKBuffer.cpp:\n   47  }\n   48  \n   49: void* mapBufferApi(Device::SharedPtr device, const Buffer::ApiHandle& apiHandle, size_t size) {\n   50      void* pData;\n   51      //vk_call(vkMapMemory(apiHandle.device()->getApiHandle(), apiHandle, 0, size, 0, &pData));\n\n4 matches across 3 files\n\n\nSearching 1282 files for \"mapBufferApi\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Buffer.cpp:\n   58  \n   59  size_t getBufferDataAlignment(const Buffer* pBuffer);\n   60: void* mapBufferApi(const Buffer::ApiHandle& apiHandle, size_t size);\n   61  \n   62  Buffer::Buffer(std::shared_ptr<Device> pDevice, size_t size, BindFlags bindFlags, CpuAccess cpuAccess): Resource(pDevice, Type::Buffer, bindFlags, size), mCpuAccess(cpuAccess) {}\n   ..\n  263          } else if (mCpuAccess == CpuAccess::Read) {\n  264              assert(mBindFlags == BindFlags::None);\n  265:             return mapBufferApi(mApiHandle, mSize);\n  266          } else {\n  267              // For buffers without CPU access we must copy the contents to a staging buffer.\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Buffer.cpp:\n   71      }\n   72  \n   73:     void* mapBufferApi(const Buffer::ApiHandle& apiHandle, size_t size)\n   74      {\n   75          D3D12_RANGE r{ 0, size };\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKBuffer.cpp:\n   47  }\n   48  \n   49: void* mapBufferApi(Device::SharedPtr device, const Buffer::ApiHandle& apiHandle, size_t size) {\n   50      void* pData;\n   51      vk_call(vkMapMemory(apiHandle.device()->getApiHandle(), apiHandle, 0, size, 0, &pData));\n\n4 matches across 3 files\n\n\nSearching 1282 files for \"mapBufferApi\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Buffer.cpp:\n   58  \n   59  size_t getBufferDataAlignment(const Buffer* pBuffer);\n   60: void* mapBufferApi(const Buffer::ApiHandle& apiHandle, size_t size);\n   61  \n   62  Buffer::Buffer(std::shared_ptr<Device> pDevice, size_t size, BindFlags bindFlags, CpuAccess cpuAccess): Resource(pDevice, Type::Buffer, bindFlags, size), mCpuAccess(cpuAccess) {}\n   ..\n  263          } else if (mCpuAccess == CpuAccess::Read) {\n  264              assert(mBindFlags == BindFlags::None);\n  265:             return mapBufferApi(mApiHandle, mSize);\n  266          } else {\n  267              // For buffers without CPU access we must copy the contents to a staging buffer.\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Buffer.cpp:\n   71      }\n   72  \n   73:     void* mapBufferApi(const Buffer::ApiHandle& apiHandle, size_t size)\n   74      {\n   75          D3D12_RANGE r{ 0, size };\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKBuffer.cpp:\n   47  }\n   48  \n   49: void* mapBufferApi(Device::SharedPtr pDevice, const Buffer::ApiHandle& apiHandle, size_t size) {\n   50      void* pData;\n   51      vk_call(vkMapMemory(pDevice->getApiHandle(), apiHandle, 0, size, 0, &pData));\n\n4 matches across 3 files\n\n\nSearching 1282 files for \"mapBufferApi\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Buffer.cpp:\n   58  \n   59  size_t getBufferDataAlignment(const Buffer* pBuffer);\n   60: void* mapBufferApi(std::shared_ptr<Device> pDevice, const Buffer::ApiHandle& apiHandle, size_t size);\n   61  \n   62  Buffer::Buffer(std::shared_ptr<Device> pDevice, size_t size, BindFlags bindFlags, CpuAccess cpuAccess): Resource(pDevice, Type::Buffer, bindFlags, size), mCpuAccess(cpuAccess) {}\n   ..\n  263          } else if (mCpuAccess == CpuAccess::Read) {\n  264              assert(mBindFlags == BindFlags::None);\n  265:             return mapBufferApi(mpDevice, mApiHandle, mSize);\n  266          } else {\n  267              // For buffers without CPU access we must copy the contents to a staging buffer.\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Buffer.cpp:\n   71      }\n   72  \n   73:     void* mapBufferApi(const Buffer::ApiHandle& apiHandle, size_t size)\n   74      {\n   75          D3D12_RANGE r{ 0, size };\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKBuffer.cpp:\n   47  }\n   48  \n   49: void* mapBufferApi(Device::SharedPtr pDevice, const Buffer::ApiHandle& apiHandle, size_t size) {\n   50      void* pData;\n   51      vk_call(vkMapMemory(pDevice->getApiHandle(), apiHandle, 0, size, 0, &pData));\n\n4 matches across 3 files\n\n\nSearching 1282 files for \"allocateDeviceMemory\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKBuffer.cpp:\n   36  namespace Falcor {\n   37      \n   38: VkDeviceMemory allocateDeviceMemory(std::shared_ptr<Device> pDevice, GpuMemoryHeap::Type memType, uint32_t memoryTypeBits, size_t size) {\n   39      VkMemoryAllocateInfo allocInfo = {};\n   40      allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;\n   ..\n  103      vkGetBufferMemoryRequirements(device->getApiHandle(), buffer, &reqs);\n  104  \n  105:     VkDeviceMemory mem = allocateDeviceMemory(device, memType, reqs.memoryTypeBits, reqs.size);\n  106      vk_call(vkBindBufferMemory(device->getApiHandle(), buffer, mem, 0));\n  107      Buffer::ApiHandle apiHandle = Buffer::ApiHandle::create(device, buffer, mem);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKTexture.cpp:\n   32  \n   33  namespace Falcor {\n   34:     VkDeviceMemory allocateDeviceMemory(Device::MemoryType memType, uint32_t memoryTypeBits, size_t size);\n   35  \n   36      struct TextureApiData {\n   ..\n  152          VkMemoryRequirements memRequirements;\n  153          vkGetImageMemoryRequirements(mpDevice->getApiHandle(), image, &memRequirements);\n  154:         VkDeviceMemory deviceMem = allocateDeviceMemory(Device::MemoryType::Default, memRequirements.memoryTypeBits, memRequirements.size);\n  155          vkBindImageMemory(mpDevice->getApiHandle(), image, deviceMem, 0);\n  156          mApiHandle = ApiHandle::create(mpDevice, image, deviceMem);\n\n4 matches across 2 files\n\n\nSearching 1282 files for \"allocateDeviceMemory\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKBuffer.cpp:\n   36  namespace Falcor {\n   37      \n   38: VkDeviceMemory allocateDeviceMemory(std::shared_ptr<Device> pDevice, GpuMemoryHeap::Type memType, uint32_t memoryTypeBits, size_t size) {\n   39      VkMemoryAllocateInfo allocInfo = {};\n   40      allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;\n   ..\n  103      vkGetBufferMemoryRequirements(device->getApiHandle(), buffer, &reqs);\n  104  \n  105:     VkDeviceMemory mem = allocateDeviceMemory(device, memType, reqs.memoryTypeBits, reqs.size);\n  106      vk_call(vkBindBufferMemory(device->getApiHandle(), buffer, mem, 0));\n  107      Buffer::ApiHandle apiHandle = Buffer::ApiHandle::create(device, buffer, mem);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKTexture.cpp:\n   32  \n   33  namespace Falcor {\n   34:     VkDeviceMemory allocateDeviceMemory(std::shared_ptr<Device> pDevice, Device::MemoryType memType, uint32_t memoryTypeBits, size_t size);\n   35  \n   36      struct TextureApiData {\n   ..\n  152          VkMemoryRequirements memRequirements;\n  153          vkGetImageMemoryRequirements(mpDevice->getApiHandle(), image, &memRequirements);\n  154:         VkDeviceMemory deviceMem = allocateDeviceMemory(mpDevice, Device::MemoryType::Default, memRequirements.memoryTypeBits, memRequirements.size);\n  155          vkBindImageMemory(mpDevice->getApiHandle(), image, deviceMem, 0);\n  156          mApiHandle = ApiHandle::create(mpDevice, image, deviceMem);\n\n4 matches across 2 files\n\n\nSearching 1282 files for \"allocateDeviceMemory\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKBuffer.cpp:\n   36  namespace Falcor {\n   37      \n   38: VkDeviceMemory allocateDeviceMemory(std::shared_ptr<Device> pDevice, GpuMemoryHeap::Type memType, uint32_t memoryTypeBits, size_t size) {\n   39      VkMemoryAllocateInfo allocInfo = {};\n   40      allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;\n   ..\n  103      vkGetBufferMemoryRequirements(pDevice->getApiHandle(), buffer, &reqs);\n  104  \n  105:     VkDeviceMemory mem = allocateDeviceMemory(pDevice, memType, reqs.memoryTypeBits, reqs.size);\n  106      vk_call(vkBindBufferMemory(pDevice->getApiHandle(), buffer, mem, 0));\n  107      Buffer::ApiHandle apiHandle = Buffer::ApiHandle::create(pDevice, buffer, mem);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKTexture.cpp:\n   32  \n   33  namespace Falcor {\n   34:     VkDeviceMemory allocateDeviceMemory(std::shared_ptr<Device> pDevice, Device::MemoryType memType, uint32_t memoryTypeBits, size_t size);\n   35  \n   36      struct TextureApiData {\n   ..\n  152          VkMemoryRequirements memRequirements;\n  153          vkGetImageMemoryRequirements(mpDevice->getApiHandle(), image, &memRequirements);\n  154:         VkDeviceMemory deviceMem = allocateDeviceMemory(mpDevice, Device::MemoryType::Default, memRequirements.memoryTypeBits, memRequirements.size);\n  155          vkBindImageMemory(mpDevice->getApiHandle(), image, deviceMem, 0);\n  156          mApiHandle = ApiHandle::create(mpDevice, image, deviceMem);\n\n4 matches across 2 files\n\n\nSearching 1282 files for \"allocateDeviceMemory\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKBuffer.cpp:\n   36  namespace Falcor {\n   37      \n   38: VkDeviceMemory allocateDeviceMemory(std::shared_ptr<Device> pDevice, GpuMemoryHeap::Type memType, uint32_t memoryTypeBits, size_t size) {\n   39      VkMemoryAllocateInfo allocInfo = {};\n   40      allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;\n   ..\n  103      vkGetBufferMemoryRequirements(pDevice->getApiHandle(), buffer, &reqs);\n  104  \n  105:     VkDeviceMemory mem = allocateDeviceMemory(pDevice, memType, reqs.memoryTypeBits, reqs.size);\n  106      vk_call(vkBindBufferMemory(pDevice->getApiHandle(), buffer, mem, 0));\n  107      Buffer::ApiHandle apiHandle = Buffer::ApiHandle::create(pDevice, buffer, mem);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKTexture.cpp:\n   32  \n   33  namespace Falcor {\n   34:     VkDeviceMemory allocateDeviceMemory(std::shared_ptr<Device> pDevice, Device::MemoryType memType, uint32_t memoryTypeBits, size_t size);\n   35  \n   36      struct TextureApiData {\n   ..\n  152          VkMemoryRequirements memRequirements;\n  153          vkGetImageMemoryRequirements(mpDevice->getApiHandle(), image, &memRequirements);\n  154:         VkDeviceMemory deviceMem = allocateDeviceMemory(mpDevice, Device::MemoryType::Default, memRequirements.memoryTypeBits, memRequirements.size);\n  155          vkBindImageMemory(mpDevice->getApiHandle(), image, deviceMem, 0);\n  156          mApiHandle = ApiHandle::create(mpDevice, image, deviceMem);\n\n4 matches across 2 files\n\n\nSearching 1282 files for \"allocateDeviceMemory\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKBuffer.cpp:\n   36  namespace Falcor {\n   37      \n   38: VkDeviceMemory allocateDeviceMemory(std::shared_ptr<Device> pDevice, GpuMemoryHeap::Type memType, uint32_t memoryTypeBits, size_t size) {\n   39      VkMemoryAllocateInfo allocInfo = {};\n   40      allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;\n   ..\n  103      vkGetBufferMemoryRequirements(pDevice->getApiHandle(), buffer, &reqs);\n  104  \n  105:     VkDeviceMemory mem = allocateDeviceMemory(pDevice, memType, reqs.memoryTypeBits, reqs.size);\n  106      vk_call(vkBindBufferMemory(pDevice->getApiHandle(), buffer, mem, 0));\n  107      Buffer::ApiHandle apiHandle = Buffer::ApiHandle::create(pDevice, buffer, mem);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKTexture.cpp:\n   32  \n   33  namespace Falcor {\n   34:     VkDeviceMemory allocateDeviceMemory(std::shared_ptr<Device> pDevice, Device::MemoryType memType, uint32_t memoryTypeBits, size_t size);\n   35  \n   36      struct TextureApiData {\n   ..\n  152          VkMemoryRequirements memRequirements;\n  153          vkGetImageMemoryRequirements(mpDevice->getApiHandle(), image, &memRequirements);\n  154:         VkDeviceMemory deviceMem = allocateDeviceMemory(mpDevice, Device::MemoryType::Default, memRequirements.memoryTypeBits, memRequirements.size);\n  155          vkBindImageMemory(mpDevice->getApiHandle(), image, deviceMem, 0);\n  156          mApiHandle = ApiHandle::create(mpDevice, image, deviceMem);\n\n4 matches across 2 files\n\n\nSearching 1282 files for \"createSurface\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKDevice.cpp:\n  446  }\n  447  \n  448: VkSurfaceKHR createSurface(VkInstance instance, VkPhysicalDevice physicalDevice, DeviceApiData *pData, const Window* pWindow) {\n  449      VkSurfaceKHR surface;\n  450  \n  ...\n  604      if (!physicalDevice) return false;\n  605      \n  606:     VkSurfaceKHR surface = createSurface(instance, physicalDevice, mpApiData, mpWindow.get());\n  607      if (!surface) return false;\n  608      \n\n2 matches in 1 file\n\n\nSearching 1282 files for \"DeviceHandle\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12DescriptorHeap.cpp:\n   34      D3D12DescriptorHeap::D3D12DescriptorHeap(D3D12_DESCRIPTOR_HEAP_TYPE type, uint32_t chunkCount) : mMaxChunkCount(chunkCount), mType(type)\n   35      {\n   36:         DeviceHandle pDevice = gpDevice->getApiHandle();\n   37          mDescriptorSize = pDevice->GetDescriptorHandleIncrementSize(type);\n   38      }\n   ..\n   43      {\n   44          assert(gpDevice);\n   45:         DeviceHandle pDevice = gpDevice->getApiHandle();\n   46  \n   47          uint32_t chunkCount = (descCount + kDescPerChunk - 1) / kDescPerChunk;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Device.cpp:\n  123      }\n  124  \n  125:     DeviceHandle createDevice(IDXGIFactory4* pFactory, D3D_FEATURE_LEVEL requestedFeatureLevel, const std::vector<UUID>& experimentalFeatures)\n  126      {\n  127          // Feature levels to try creating devices. Listed in descending order so the highest supported level is used.\n  ...\n  141          // Find the HW adapter\n  142          IDXGIAdapter1Ptr pAdapter;\n  143:         DeviceHandle pDevice;\n  144          D3D_FEATURE_LEVEL deviceFeatureLevel;\n  145  \n  ...\n  202      }\n  203  \n  204:     Device::SupportedFeatures getSupportedFeatures(DeviceHandle pDevice)\n  205      {\n  206          Device::SupportedFeatures supported = Device::SupportedFeatures::None;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/FalcorD3D12.h:\n  203  \n  204      using WindowHandle = HWND;\n  205:     using DeviceHandle = ID3D12DevicePtr;\n  206      using CommandListHandle = ID3D12GraphicsCommandListPtr;\n  207      using CommandQueueHandle = ID3D12CommandQueuePtr;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Device.h:\n   61      using SharedPtr = std::shared_ptr<Device>;\n   62      using SharedConstPtr = std::shared_ptr<const Device>;\n   63:     using ApiHandle = DeviceHandle;\n   64      static const uint32_t kQueueTypeCount = (uint32_t)LowLevelContextData::CommandQueueType::Count;\n   65  \n   ..\n  156      /** Get the native API handle\n  157      */\n  158:     const DeviceHandle& getApiHandle() { return mApiHandle; }\n  159  \n  160      /** Present the back-buffer to the window\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/FalcorVK.h:\n   84  #endif\n   85  \n   86: using DeviceHandle = VkDeviceData::SharedPtr;\n   87  using CommandListHandle = VkCommandBuffer;\n   88  using CommandQueueHandle = VkQueue;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKDevice.cpp:\n  616  \n  617      if(!headless) {\n  618:         mApiHandle = DeviceHandle::create(SharedPtr(this), instance, physicalDevice, device, surface);\n  619      } else {\n  620:         mApiHandle = DeviceHandle::create(SharedPtr(this), instance, physicalDevice, device);\n  621      }\n  622  \n\n11 matches across 6 files\n\n\nSearching 1282 files for \"VkDeviceData\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/FalcorVK.h:\n   84  #endif\n   85  \n   86: using DeviceHandle = VkDeviceData::SharedPtr;\n   87  using CommandListHandle = VkCommandBuffer;\n   88  using CommandQueueHandle = VkQueue;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VkSmartHandle.cpp:\n   47      template<> VkHandle<VkQueryPool>::~VkHandle() { if (mApiHandle != VK_NULL_HANDLE && mpDevice) vkDestroyQueryPool(mpDevice->getApiHandle(), mApiHandle, nullptr); }\n   48  \n   49:     VkDeviceData::~VkDeviceData() {\n   50          if (mInstance != VK_NULL_HANDLE && mLogicalDevice != VK_NULL_HANDLE && mInstance != VK_NULL_HANDLE) {\n   51              vkDestroySurfaceKHR(mInstance, mSurface, nullptr);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKSmartHandle.h:\n   98  };\n   99  \n  100: class VkDeviceData : public VkBaseApiHandle, public inherit_shared_from_this<VkBaseApiHandle, VkDeviceData> {\n  101   public:\n  102:     class SharedPtr : public std::shared_ptr<VkDeviceData> {\n  103       public:\n  104          SharedPtr() = default;\n  105:         explicit SharedPtr(VkDeviceData* pData) : std::shared_ptr<VkDeviceData>(pData) {}\n  106          static SharedPtr create(std::shared_ptr<Device> device, VkInstance instance, VkPhysicalDevice physicalDevice, VkDevice vkdevice, VkSurfaceKHR surface) {\n  107:             return SharedPtr(new VkDeviceData(device, instance, physicalDevice, vkdevice, surface));\n  108          }\n  109  \n  ...\n  114  \n  115       private:\n  116:         VkDeviceData* get() const { return std::shared_ptr<VkDeviceData>::get(); }\n  117      };\n  118  \n  119:     ~VkDeviceData();\n  120  \n  121   private:\n  122      friend SharedPtr;\n  123:     VkDeviceData(std::shared_ptr<Device> device, VkInstance instance, VkPhysicalDevice physicalDevice, VkDevice vkdevice, VkSurfaceKHR surface) :\n  124          VkBaseApiHandle(device), mInstance(instance), mPhysicalDevice(physicalDevice), mLogicalDevice(vkdevice), mSurface(surface) {}\n  125      VkInstance          mInstance;\n\n13 matches across 3 files\n\n\nSearching 1282 files for \"ConstTextureSharedPtrRef\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12ResourceViews.cpp:\n  281      }\n  282  \n  283:     ShaderResourceView::SharedPtr ShaderResourceView::create(ConstTextureSharedPtrRef pTexture, uint32_t mostDetailedMip, uint32_t mipCount, uint32_t firstArraySlice, uint32_t arraySize)\n  284      {\n  285          if (!pTexture && getNullView()) return getNullView();\n  ...\n  327      }\n  328  \n  329:     DepthStencilView::SharedPtr DepthStencilView::create(ConstTextureSharedPtrRef pTexture, uint32_t mipLevel, uint32_t firstArraySlice, uint32_t arraySize)\n  330      {\n  331          if (!pTexture && getNullView()) return getNullView();\n  ...\n  362      }\n  363  \n  364:     UnorderedAccessView::SharedPtr UnorderedAccessView::create(ConstTextureSharedPtrRef pTexture, uint32_t mipLevel, uint32_t firstArraySlice, uint32_t arraySize)\n  365      {\n  366          if (!pTexture && getNullView()) return getNullView();\n  ...\n  414      RenderTargetView::~RenderTargetView() = default;\n  415  \n  416:     RenderTargetView::SharedPtr RenderTargetView::create(ConstTextureSharedPtrRef pTexture, uint32_t mipLevel, uint32_t firstArraySlice, uint32_t arraySize)\n  417      {\n  418          if (!pTexture && getNullView()) return getNullView();\n\n/home/max/dev/Falcor/src/Falcor/Core/API/ResourceViews.h:\n   42  \n   43  using ResourceWeakPtr = std::weak_ptr<Resource>;\n   44: using ConstTextureSharedPtrRef = const std::shared_ptr<Texture>&;\n   45  using ConstBufferSharedPtrRef = const std::shared_ptr<Buffer>&;\n   46  \n   ..\n  114      using SharedConstPtr = std::shared_ptr<const ShaderResourceView>;\n  115  \n  116:     static SharedPtr create(std::shared_ptr<Device> pDevice, ConstTextureSharedPtrRef pTexture, uint32_t mostDetailedMip, uint32_t mipCount, uint32_t firstArraySlice, uint32_t arraySize);\n  117      static SharedPtr create(std::shared_ptr<Device> pDevice, ConstBufferSharedPtrRef pBuffer, uint32_t firstElement, uint32_t elementCount);\n  118      static SharedPtr getNullView(std::shared_ptr<Device> pDevice);\n  ...\n  134      using SharedConstPtr = std::shared_ptr<const DepthStencilView>;\n  135  \n  136:     static SharedPtr create(std::shared_ptr<Device> pDevice, ConstTextureSharedPtrRef pTexture, uint32_t mipLevel, uint32_t firstArraySlice, uint32_t arraySize);\n  137      static SharedPtr getNullView(std::shared_ptr<Device> pDevice);\n  138  \n  ...\n  147      using SharedConstPtr = std::shared_ptr<const UnorderedAccessView>;\n  148  \n  149:     static SharedPtr create(std::shared_ptr<Device> pDevice, ConstTextureSharedPtrRef pTexture, uint32_t mipLevel, uint32_t firstArraySlice, uint32_t arraySize);\n  150      static SharedPtr create(std::shared_ptr<Device> pDevice, ConstBufferSharedPtrRef pBuffer, uint32_t firstElement, uint32_t elementCount);\n  151      static SharedPtr getNullView(std::shared_ptr<Device> pDevice);\n  ...\n  165      using SharedPtr = std::shared_ptr<RenderTargetView>;\n  166      using SharedConstPtr = std::shared_ptr<const RenderTargetView>;\n  167:     static SharedPtr create(std::shared_ptr<Device> pDevice, ConstTextureSharedPtrRef pTexture, uint32_t mipLevel, uint32_t firstArraySlice, uint32_t arraySize);\n  168      static SharedPtr getNullView(std::shared_ptr<Device> pDevice);\n  169      ~RenderTargetView();\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKResourceViews.cpp:\n  164  }\n  165  \n  166: ShaderResourceView::SharedPtr ShaderResourceView::create(std::shared_ptr<Device> pDevice, ConstTextureSharedPtrRef pTexture, uint32_t mostDetailedMip, uint32_t mipCount, uint32_t firstArraySlice, uint32_t arraySize) {\n  167      if (!pTexture) {\n  168          return getNullView(pDevice);\n  ...\n  207  }\n  208  \n  209: DepthStencilView::SharedPtr DepthStencilView::create(std::shared_ptr<Device> pDevice, ConstTextureSharedPtrRef pTexture, uint32_t mipLevel, uint32_t firstArraySlice, uint32_t arraySize) {\n  210      if (!pTexture) {\n  211          return getNullView(pDevice);\n  ...\n  221  }\n  222  \n  223: UnorderedAccessView::SharedPtr UnorderedAccessView::create(std::shared_ptr<Device> pDevice, ConstTextureSharedPtrRef pTexture, uint32_t mipLevel, uint32_t firstArraySlice, uint32_t arraySize) {\n  224      if (!pTexture) {\n  225          return getNullView(pDevice);\n  ...\n  272  }\n  273  \n  274: RenderTargetView::SharedPtr RenderTargetView::create(std::shared_ptr<Device> pDevice, ConstTextureSharedPtrRef pTexture, uint32_t mipLevel, uint32_t firstArraySlice, uint32_t arraySize) {\n  275      if (!pTexture) return getNullView(pDevice);\n  276  \n\n13 matches across 3 files\n\n\nSearching 1282 files for \"getClientAreaSize\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Device.cpp:\n   98          DXGI_SWAP_CHAIN_DESC1 swapChainDesc = {};\n   99          swapChainDesc.BufferCount = bufferCount;\n  100:         swapChainDesc.Width = pWindow->getClientAreaSize().x;\n  101:         swapChainDesc.Height = pWindow->getClientAreaSize().y;\n  102          // Flip mode doesn't support SRGB formats, so we strip them down when creating the resource. We will create the RTV as SRGB instead.\n  103          // More details at the end of https://msdn.microsoft.com/en-us/library/windows/desktop/bb173064.aspx\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Device.cpp:\n  125  \n  126      // Update the FBOs\n  127:     if (updateDefaultFBO(mpWindow->getClientAreaSize().x, mpWindow->getClientAreaSize().y, mDesc.colorFormat, mDesc.depthFormat) == false) {\n  128          return false;\n  129      }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Engine.cpp:\n   83      // Update the FBOs\n   84      if(!headless) {\n   85:         if (updateDefaultFBO(mpDevice->getWindow()->getClientAreaSize().x, mpDevice->getWindow()->getClientAreaSize().y, mpDevice->getDesc().colorFormat, mpDevice->getDesc().depthFormat) == false) {\n   86              return false;\n   87          }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKDevice.cpp:\n  490      VkExtent2D swapchainExtent = {};\n  491      if (surfaceCapabilities.currentExtent.width == (uint32_t)-1) {\n  492:         const uint2 windowSize = mpWindow->getClientAreaSize();\n  493          swapchainExtent.width = windowSize.x;\n  494          swapchainExtent.height = windowSize.y;\n\n/home/max/dev/Falcor/src/Falcor/Core/Sample.cpp:\n   59          }\n   60          // Tell the device to resize the swap chain\n   61:         auto winSize = mpWindow->getClientAreaSize();\n   62          auto pBackBufferFBO = mpDevice->resizeSwapChain(winSize.x, winSize.y);\n   63          auto width = pBackBufferFBO->getWidth();\n   ..\n  388  \n  389              controlsGroup.separator();\n  390:             screenSizeUI(controlsGroup, mpWindow->getClientAreaSize());\n  391              controlsGroup.separator();\n  392  \n\n/home/max/dev/Falcor/src/Falcor/Core/Window.h:\n  118      /** Get the width of the window's client area\n  119      */\n  120:     uint2 getClientAreaSize() const { return { mDesc.width, mDesc.height }; }\n  121  \n  122      /** Get the descriptor\n\n/home/max/dev/Falcor/src/Mogwai/MogwaiSettings.cpp:\n   88      };\n   89  \n   90:     uint2 currentRes = gpFramework->getWindow()->getClientAreaSize();\n   91      static const Gui::DropdownList dropdownList = initDropDown(resolutions, arraysize(resolutions));\n   92      uint32_t currentVal = initDropDownVal(resolutions, arraysize(resolutions), currentRes);\n\n11 matches across 7 files\n\n\nSearching 1282 files for \"resizeSwapChain\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Device.cpp:\n  295  }\n  296  \n  297: Fbo::SharedPtr Device::resizeSwapChain(uint32_t width, uint32_t height) {\n  298      assert(width > 0 && height > 0);\n  299  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Device.h:\n  173          \\return A new FBO object\n  174      */\n  175:     Fbo::SharedPtr resizeSwapChain(uint32_t width, uint32_t height);\n  176  \n  177      /** Get the desc\n\n/home/max/dev/Falcor/src/Falcor/Core/Renderer.h:\n   72  \n   73      /** Resize the swap-chain buffers*/\n   74:     virtual void resizeSwapChain(uint32_t width, uint32_t height) = 0;\n   75  \n   76      /** Check if a key is pressed*/\n\n/home/max/dev/Falcor/src/Falcor/Core/Sample.cpp:\n   60          // Tell the device to resize the swap chain\n   61          auto winSize = mpWindow->getClientAreaSize();\n   62:         auto pBackBufferFBO = mpDevice->resizeSwapChain(winSize.x, winSize.y);\n   63          auto width = pBackBufferFBO->getWidth();\n   64          auto height = pBackBufferFBO->getHeight();\n   ..\n  335  \n  336          widget.var(\"Screen Resolution\", screenDims);\n  337:         if (widget.dropdown(\"Change Resolution\", dropdownList, currentVal) && (currentVal != 0)) gpFramework->resizeSwapChain(resolutions[currentVal].x, resolutions[currentVal].y);\n  338      }\n  339  \n  ...\n  508      }\n  509  \n  510:     void Sample::resizeSwapChain(uint32_t width, uint32_t height) {\n  511          mpWindow->resize(width, height);\n  512      }\n  ...\n  618          m.func_(\"setWindowPos\", setWindowPos, \"x\"_a, \"y\"_a);\n  619  \n  620:         auto resize = [this](uint32_t width, uint32_t height) {resizeSwapChain(width, height); };\n  621:         m.func_(\"resizeSwapChain\", resize, \"width\"_a, \"height\"_a);\n  622      }\n  623  \n\n/home/max/dev/Falcor/src/Falcor/Core/Sample.h:\n   87      FrameRate& getFrameRate() override { return *mFrameRate; }\n   88  \n   89:     void resizeSwapChain(uint32_t width, uint32_t height) override;\n   90      bool isKeyPressed(const KeyboardEvent::Key& key) override;\n   91      void toggleUI(bool showUI) override { mShowUI = showUI; }\n\n/home/max/dev/Falcor/src/Mogwai/Data/Config.py:\n    6  \n    7  # Window Configuration\n    8: m.resizeSwapChain(1920, 1080)\n    9  m.ui = True\n   10  \n\n/home/max/dev/Falcor/src/Mogwai/MogwaiScripting.cpp:\n   42  const std::string kGetGraph = \"getGraph\";\n   43  const std::string kUI = \"ui\";\n   44: const std::string kResizeSwapChain = \"resizeSwapChain\";\n   45  const std::string kActiveGraph = \"activeGraph\";\n   46  const std::string kScene = \"scene\";\n   ..\n  154  \n  155      // PYTHONDEPRECATED Use the global function defined in the script bindings in Sample.cpp when resizing from a Python script.\n  156:     auto resize = [](Renderer* pRenderer, uint32_t width, uint32_t height) {gpFramework->resizeSwapChain(width, height); };\n  157      c.func_(kResizeSwapChain.c_str(), resize);\n  158  }\n\n/home/max/dev/Falcor/src/Mogwai/MogwaiSettings.cpp:\n  103          } else {\n  104              customSize = {};\n  105:             gpFramework->resizeSwapChain(resolutions[currentVal].x, resolutions[currentVal].y);\n  106          }\n  107      }\n  ...\n  112          w.var(\"##custres\", customSize);\n  113          if (w.button(\"Apply##custres\", true)) {\n  114:             gpFramework->resizeSwapChain(customSize.x, customSize.y);\n  115              forceCustom = false;\n  116          }\n\n14 matches across 8 files\n\n\nSearching 1282 files for \"std::unordered_map<Falcor::ResourceViewInfo\" (case sensitive)\n\n0 matches\n\nSearching 1282 files for \"std::unordered_map\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/GpuMemoryHeap.h:\n   98  \n   99      std::priority_queue<Allocation> mDeferredReleases;\n  100:     std::unordered_map<size_t, PageData::UniquePtr> mUsedPages;\n  101      std::queue<PageData::UniquePtr> mAvailablePages;\n  102  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Resource.h:\n  199      std::shared_ptr<Device> mpDevice;\n  200  \n  201:     mutable std::unordered_map<ResourceViewInfo, ShaderResourceView::SharedPtr, ViewInfoHashFunc> mSrvs;\n  202:     mutable std::unordered_map<ResourceViewInfo, RenderTargetView::SharedPtr, ViewInfoHashFunc> mRtvs;\n  203:     mutable std::unordered_map<ResourceViewInfo, DepthStencilView::SharedPtr, ViewInfoHashFunc> mDsvs;\n  204:     mutable std::unordered_map<ResourceViewInfo, UnorderedAccessView::SharedPtr, ViewInfoHashFunc> mUavs;\n  205  };\n  206  \n\n/home/max/dev/Falcor/src/Falcor/Core/BufferTypes/VariablesBufferUI.cpp:\n   32  namespace Falcor\n   33  {\n   34:     std::unordered_map<std::string, int32_t> VariablesBufferUI::mGuiArrayIndices;\n   35  \n   36      bool renderGuiWidgetFromType(Gui::Widgets& widget, ReflectionBasicType::Type type, uint8_t* data, const std::string& name)\n\n/home/max/dev/Falcor/src/Falcor/Core/BufferTypes/VariablesBufferUI.h:\n   43      private:\n   44          ParameterBlock& mVariablesBufferRef;\n   45:         static std::unordered_map<std::string, int32_t> mGuiArrayIndices;\n   46  \n   47          /** Recursive function for displaying shader reflection member\n\n/home/max/dev/Falcor/src/Falcor/Core/Platform/Windows/Windows.cpp:\n  488      }\n  489  \n  490:     static std::unordered_map<std::string, std::pair<std::thread, bool> > fileThreads;\n  491  \n  492      static void checkFileModifiedStatus(const std::string& filePath, const std::function<void()>& callback)\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/Program.h:\n  284      static std::vector<std::weak_ptr<Program>> sPrograms;\n  285  \n  286:     using string_time_map = std::unordered_map<std::string, time_t>;\n  287      mutable string_time_map mFileTimeMap;\n  288  \n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramReflection.h:\n  880          slang::TypeLayoutReflection*    pSlangTypeLayout);\n  881      std::vector<std::shared_ptr<const ReflectionVar>> mMembers;   // Struct members\n  882:     std::unordered_map<std::string, int32_t> mNameToIndex; // Translates from a name to an index in mMembers\n  883      std::string mName;\n  884  };\n  ...\n 1428          ReflectionBasicType::Type type = ReflectionBasicType::Type::Unknown; ///> The type of the variable\n 1429      };\n 1430:     using VariableMap = std::unordered_map<std::string, ShaderVariable>;\n 1431  \n 1432      using BindLocation = ParameterBlockReflection::BindLocation;\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramVersion.h:\n  260  \n  261          // Cached version of compiled kernels for this program version\n  262:         mutable std::unordered_map<std::string, ProgramKernels::SharedPtr> mpKernels;\n  263      };\n  264  }\n\n/home/max/dev/Falcor/src/Falcor/Core/State/StateGraph.h:\n   99  \n  100   private:\n  101:     using edge_map = std::unordered_map<EdgeType, uint32_t, EdgeHashType>;\n  102      \n  103      const auto getEdgeIt(const EdgeType& e) const {\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraph.cpp:\n  592      // Gather list of passes by order they were added\n  593      std::vector<NodeData*> nodeVec;\n  594:     std::unordered_map<RenderPass*, RenderPassReflection> passReflectionMap;\n  595  \n  596      if (executionOrder.size() > 0) {\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraph.h:\n  232  \n  233          Scene::SharedPtr mpScene;\n  234:         std::unordered_map<std::string, uint32_t> mNameToIndex;\n  235          DirectedGraph::SharedPtr mpGraph;\n  236:         std::unordered_map<uint32_t, EdgeData> mEdgeData;\n  237:         std::unordered_map<uint32_t, NodeData> mNodeData;\n  238  \n  239          struct GraphOut {\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraphCompiler.cpp:\n  216  void RenderGraphCompiler::allocateResources(ResourceCache* pResourceCache) {\n  217      // Build list to look up execution order index from the pass\n  218:     std::unordered_map<RenderPass*, uint32_t> passToIndex;\n  219      for (size_t i = 0; i < mExecutionList.size(); i++) {\n  220          passToIndex.emplace(mExecutionList[i].pPass.get(), uint32_t(i));\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraphUI.cpp:\n  155          uint32_t mPinIndexToDisplay = uint32_t(-1);\n  156          bool mPopupPinIsInput = false;\n  157:         std::unordered_map<uint32_t, ImGui::Node*> mpIDtoNode;\n  158      };\n  159  \n  ...\n 1286          std::unordered_set<std::string> nodeConnectedInput;\n 1287          std::unordered_set<std::string> nodeConnectedOutput;\n 1288:         std::unordered_map<std::string, uint32_t> previousGuiNodeIDs;\n 1289          std::unordered_set<uint32_t> existingIDs;\n 1290  \n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraphUI.h:\n   63  \n   64          std::vector<PinUI> mInputPins;\n   65:         std::unordered_map<std::string, uint32_t> mNameToIndexInput;\n   66  \n   67          std::vector<PinUI> mOutputPins;\n   68:         std::unordered_map<std::string, uint32_t> mNameToIndexOutput;\n   69  \n   70          uint32_t mGuiNodeID;\n   ..\n  190          std::vector<const char*> mAllNodeTypes;\n  191  \n  192:         std::unordered_map <std::string, RenderPassUI> mRenderPassUI;\n  193  \n  194:         std::unordered_map <std::string, uint32_t> mInputPinStringToLinkID;\n  195  \n  196          // maps output pin name to input pin ids. Pair first is pin id, second is node id\n  197:         std::unordered_map <std::string, std::vector< std::pair<uint32_t, uint32_t > > > mOutputToInputPins;\n  198  \n  199          // if in external editing mode, building list of commands for changes to send to the other process\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderPassLibrary.h:\n  120              time_t lastModified;\n  121          };\n  122:         std::unordered_map<std::string, LibDesc> mLibs;\n  123:         std::unordered_map<std::string, ExtendedDesc> mPasses;\n  124  \n  125          std::shared_ptr<Device> mpDevice;\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/ResourceCache.h:\n   40   public:\n   41      using SharedPtr = std::shared_ptr<ResourceCache>;\n   42:     using ResourcesMap = std::unordered_map<std::string, Resource::SharedPtr>;\n   43  \n   44      /** Create a new object\n   ..\n   97  \n   98      // Resources and properties for fields within (and therefore owned by) a render graph\n   99:     std::unordered_map<std::string, uint32_t> mNameToIndex;\n  100      std::vector<ResourceData> mResourceData;\n  101  \n\n/home/max/dev/Falcor/src/Falcor/Scene/Scene.cpp:\n  657  \n  658      // The non-instanced meshes are grouped based on what global matrix ID their transform is.\n  659:     std::unordered_map<uint32_t, std::vector<uint32_t>> nodeToMeshList;\n  660      for (uint32_t meshId = 0; meshId < (uint32_t)instanceLists.size(); meshId++) {\n  661          const auto& instanceList = instanceLists[meshId];\n\n/home/max/dev/Falcor/src/Falcor/Scene/Scene.h:\n  526          };\n  527  \n  528:         std::unordered_map<uint32_t, TlasData> mTlasCache;  ///< Top Level Acceleration Structure for scene data cached per shader ray count\n  529                                                              ///< Number of ray types in program affects Shader Table indexing\n  530          Buffer::SharedPtr mpTlasScratch;                    ///< Scratch buffer used for TLAS builds. Can be shared as long as instance desc count is the same, which for now it is.\n\n/home/max/dev/Falcor/src/Falcor/Scene/SceneBuilder.h:\n  216      MeshList mMeshes;\n  217      std::vector<Material::SharedPtr> mMaterials;\n  218:     std::unordered_map<const Material*, uint32_t> mMaterialToId;\n  219  \n  220      Scene::AnimatedObject<Camera> mCamera;\n\n/home/max/dev/Falcor/src/Falcor/Utils/Algorithm/DirectedGraph.h:\n  187          DirectedGraph() = default;\n  188  \n  189:         std::unordered_map<uint32_t, Node> mNodes;\n  190:         std::unordered_map<uint32_t, Edge> mEdges;\n  191          uint32_t mCurrentNodeId = 0;\n  192          uint32_t mCurrentEdgeId = 0;\n\n/home/max/dev/Falcor/src/Falcor/Utils/ArgList.h:\n  104  \n  105   private:\n  106:     std::unordered_map<std::string, std::vector<Arg>> mMap;\n  107  };\n  108  \n\n/home/max/dev/Falcor/src/Falcor/Utils/Scripting/ScriptBindings.cpp:\n   36  {\n   37      ClassesMap sClasses;\n   38:     std::unordered_map<std::type_index, std::string> sEnumNames;\n   39  \n   40      namespace\n\n/home/max/dev/Falcor/src/Falcor/Utils/Scripting/ScriptBindings.h:\n   58          std::function<std::string(const void*)> printF;\n   59      };\n   60:     std::unordered_map<std::string, Funcs> funcs;\n   61      std::string name;\n   62  };\n   63  \n   64: using ClassesMap = std::unordered_map<std::type_index, ClassDesc>;\n   65  dlldecl extern ClassesMap sClasses;\n   66: dlldecl extern std::unordered_map<std::type_index, std::string> sEnumNames;\n   67  \n   68  using BindComponentFunc = std::function<void(ScriptBindings::Module& m)>;\n\n/home/max/dev/Falcor/src/Falcor/Utils/TermColor.cpp:\n   67  #endif\n   68  \n   69: static const std::unordered_map<TermColor, std::string> kBeginTag = {\n   70      { TermColor::Gray,    \"\\33[90m\" },\n   71      { TermColor::Red,     \"\\33[91m\" },\n\n/home/max/dev/Falcor/src/Falcor/Utils/Timing/Profiler.cpp:\n   43      bool gProfileEnabled = false;  // TODO: make configurable\n   44  \n   45:     using DeviceProfilerEvents = std::unordered_map<std::string, Profiler::EventData*>;\n   46  \n   47:     std::unordered_map<Profiler::DeviceEventKey, Profiler::EventData*, Profiler::device_event_key_hash> Profiler::sProfilerEvents;\n   48      std::vector<Profiler::EventData*> Profiler::sRegisteredEvents;\n   49      std::string curEventName = \"\";\n\n/home/max/dev/Falcor/src/Falcor/Utils/Timing/Profiler.h:\n  161      static double getCpuTime(const EventData* pData);\n  162  \n  163:     static std::unordered_map<DeviceEventKey, EventData*, device_event_key_hash> sProfilerEvents;\n  164      static std::vector<EventData*> sRegisteredEvents;\n  165      static uint32_t sCurrentLevel;\n\n/home/max/dev/Falcor/src/Falcor/Utils/UI/Gui.cpp:\n   56              int32_t currentItem = -1;\n   57          };\n   58:         std::unordered_map<std::string, ComboData> mDropDownValues;\n   59  \n   60          // This struct is used to cache the mouse events\n   ..\n   78          ParameterBlockReflection::BindLocation mGuiImageLoc;\n   79          float mScaleFactor = 1.0f;\n   80:         std::unordered_map<std::string, ImFont*> mFontMap;\n   81          ImFont* mpActiveFont = nullptr;\n   82  \n\n/home/max/dev/Falcor/src/Mogwai/Extensions/Capture/CaptureTrigger.h:\n   65  \n   66          using range_vec = std::vector<Range>;\n   67:         std::unordered_map<const RenderGraph*, range_vec> mGraphRanges;\n   68  \n   69          std::string mBaseFilename = \"Mogwai\";\n\n/home/max/dev/Falcor/src/Mogwai/Mogwai.h:\n   68          Bindings(ScriptBindings::Module& m, ScriptBindings::Class<Renderer>& c) : mModule(m), mMogwai(c) {}\n   69          friend class Renderer;\n   70:         std::unordered_map<std::string, std::string> mGlobalObjects;\n   71          ScriptBindings::Module& mModule;\n   72          ScriptBindings::Class<Renderer>& mMogwai;\n   ..\n  139          std::vector<std::string> originalOutputs;\n  140          std::vector<DebugWindow> debugWindows;\n  141:         std::unordered_map<std::string, uint32_t> graphOutputRefs;\n  142      };\n  143  \n\n/home/max/dev/Falcor/src/RenderPasses/PixelInspectorPass/PixelInspectorPass.h:\n   63      float2                                mCursorPosition = float2(0.0f);\n   64      float2                                mSelectedCursorPosition = float2(0.0f);\n   65:     std::unordered_map<std::string, bool> mAvailableInputs;\n   66:     std::unordered_map<std::string, bool> mIsInputInBounds;\n   67  \n   68      // UI variables\n\n/home/max/dev/Falcor/src/Tools/ImageCompare/args.h:\n 3665       * \\tparam T the type to store the result as\n 3666       * \\tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with operator(), and returning a bool (if ARGS_NOEXCEPT is defined)\n 3667:      * \\tparam Map The Map type.  Should operate like std::map or std::unordered_map\n 3668       */\n 3669      template <\n ....\n 3671          typename T,\n 3672          typename Reader = ValueReader,\n 3673:         template <typename...> class Map = std::unordered_map>\n 3674      class MapFlag : public ValueFlagBase\n 3675      {\n ....\n 3753       * \\tparam List the list type that houses the values\n 3754       * \\tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with operator(), and returning a bool (if ARGS_NOEXCEPT is defined)\n 3755:      * \\tparam Map The Map type.  Should operate like std::map or std::unordered_map\n 3756       */\n 3757      template <\n ....\n 3760          template <typename...> class List = std::vector,\n 3761          typename Reader = ValueReader,\n 3762:         template <typename...> class Map = std::unordered_map>\n 3763      class MapFlagList : public ValueFlagBase\n 3764      {\n ....\n 4064       * \\tparam T the type to store the result as\n 4065       * \\tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with operator(), and returning a bool (if ARGS_NOEXCEPT is defined)\n 4066:      * \\tparam Map The Map type.  Should operate like std::map or std::unordered_map\n 4067       */\n 4068      template <\n ....\n 4070          typename T,\n 4071          typename Reader = ValueReader,\n 4072:         template <typename...> class Map = std::unordered_map>\n 4073      class MapPositional : public PositionalBase\n 4074      {\n ....\n 4145       * \\tparam List the list type that houses the values\n 4146       * \\tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with operator(), and returning a bool (if ARGS_NOEXCEPT is defined)\n 4147:      * \\tparam Map The Map type.  Should operate like std::map or std::unordered_map\n 4148       */\n 4149      template <\n ....\n 4152          template <typename...> class List = std::vector,\n 4153          typename Reader = ValueReader,\n 4154:         template <typename...> class Map = std::unordered_map>\n 4155      class MapPositionalList : public PositionalBase\n 4156      {\n\n/home/max/dev/Falcor/src/Tools/RenderGraphEditor/RenderGraphEditor.h:\n   57      std::vector<RenderGraph::SharedPtr> mpGraphs;\n   58      std::vector<RenderGraphUI> mRenderGraphUIs;\n   59:     std::unordered_map<std::string, uint32_t> mGraphNamesToIndex;\n   60      size_t mCurrentGraphIndex;\n   61      uint2 mWindowSize;\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/Include/Common.h:\n  193  \n  194  template <class K, class D, class HASH = std::hash<K>, class PRED = std::equal_to<K> >\n  195: class TUnorderedMap : public std::unordered_map<K, D, HASH, PRED, pool_allocator<std::pair<K const, D> > > {\n  196  };\n  197  \n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/iomapper.cpp:\n  376  \n  377      typedef std::vector<int> TSlotSet;\n  378:     typedef std::unordered_map<int, TSlotSet> TSlotSetMap;\n  379      TSlotSetMap slots;\n  380  \n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/localintermediate.h:\n  889      bool usePhysicalStorageBuffer;\n  890  \n  891:     std::unordered_map<std::string, int> uniformLocationOverrides;\n  892      int uniformLocationBase;\n  893  \n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/propagateNoContraction.cpp:\n   69  typedef std::unordered_multimap<ObjectAccessChain, glslang::TIntermOperator*> NodeMapping;\n   70  // Mapping from object nodes to their access chain info string.\n   71: typedef std::unordered_map<glslang::TIntermTyped*, ObjectAccessChain> AccessChainMapping;\n   72  \n   73  // Set of object IDs.\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/reflection.h:\n  163      void buildAttributeReflection(EShLanguage, const TIntermediate&);\n  164  \n  165:     // Need a TString hash: typedef std::unordered_map<TString, int> TNameToIndex;\n  166      typedef std::map<std::string, int> TNameToIndex;\n  167      typedef std::vector<TObjectReflection> TMapIndexToReflection;\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/Scan.cpp:\n  324  // A single global usable by all threads, by all versions, by all languages.\n  325  // After a single process-level initialization, this is read only and thread safe\n  326: std::unordered_map<const char*, int, str_hash, str_eq>* KeywordMap = nullptr;\n  327  std::unordered_set<const char*, str_hash, str_eq>* ReservedSet = nullptr;\n  328  \n  ...\n  338          return;\n  339      }\n  340:     KeywordMap = new std::unordered_map<const char*, int, str_hash, str_eq>;\n  341  \n  342      (*KeywordMap)[\"const\"] =                   CONST;\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/SPIRV/GlslangToSpv.cpp:\n  226      const glslang::TIntermediate* glslangIntermediate;\n  227      spv::Id stdBuiltins;\n  228:     std::unordered_map<const char*, spv::Id> extBuiltinMap;\n  229  \n  230:     std::unordered_map<int, spv::Id> symbolValues;\n  231      std::unordered_set<int> rValueParameters;  // set of formal function parameters passed as rValues, rather than a pointer\n  232:     std::unordered_map<std::string, spv::Function*> functionMap;\n  233:     std::unordered_map<const glslang::TTypeList*, spv::Id> structMap[glslang::ElpCount][glslang::ElmCount];\n  234      // for mapping glslang block indices to spv indices (e.g., due to hidden members):\n  235:     std::unordered_map<const glslang::TTypeList*, std::vector<int> > memberRemapper;\n  236      std::stack<bool> breakForLoop;  // false means break for switch\n  237:     std::unordered_map<std::string, const glslang::TIntermSymbol*> counterOriginator;\n  238      // Map pointee types for EbtReference to their forward pointers\n  239      std::map<const glslang::TType *, spv::Id> forwardPointers;\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/SPIRV/SpvBuilder.h:\n  734  \n  735       // not output, internally used for quick & dirty canonical (unique) creation\n  736:     std::unordered_map<unsigned int, std::vector<Instruction*>> groupedConstants;       // map type opcodes to constant inst.\n  737:     std::unordered_map<unsigned int, std::vector<Instruction*>> groupedStructConstants; // map struct-id to constant instructions\n  738:     std::unordered_map<unsigned int, std::vector<Instruction*>> groupedTypes;           // map type opcodes to type instructions\n  739  \n  740      // stack of switches\n  ...\n  745  \n  746      // map from strings to their string ids\n  747:     std::unordered_map<std::string, spv::Id> stringIds;\n  748  \n  749      // map from include file name ids to their contents\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/SPIRV/SPVRemapper.cpp:\n  780  \n  781          spv::Op          thisOpCode(spv::OpNop);\n  782:         std::unordered_map<int, int> opCounter;\n  783          int              idCounter(0);\n  784          fnId = spv::NoResult;\n  ...\n 1107          msg(3, 2, std::string(\"DCE Vars: \"));\n 1108  \n 1109:         std::unordered_map<spv::Id, int> varUseCount;\n 1110  \n 1111          // Count function variable use\n ....\n 1157              isType[asTypeConstId(typeStart)] = true;\n 1158  \n 1159:         std::unordered_map<spv::Id, int> typeUseCount;\n 1160  \n 1161          // This is not the most efficient algorithm, but this is an offline tool, and\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/SPIRV/SPVRemapper.h:\n  135  private:\n  136     // Local to global, or global to local ID map\n  137:    typedef std::unordered_map<spv::Id, spv::Id> idmap_t;\n  138     typedef std::unordered_set<spv::Id>          idset_t;\n  139:    typedef std::unordered_map<spv::Id, int>     blockmap_t;\n  140  \n  141     void remap(std::uint32_t opts = DO_EVERYTHING);\n  142  \n  143     // Map of names to IDs\n  144:    typedef std::unordered_map<std::string, spv::Id> namemap_t;\n  145  \n  146     typedef std::uint32_t spirword_t;\n  ...\n  163     // A set that preserves position order, and a reverse map\n  164     typedef std::set<int>                    posmap_t;\n  165:    typedef std::unordered_map<spv::Id, int> posmap_rev_t;\n  166  \n  167     // Maps and ID to the size of its base type, if known.\n  168:    typedef std::unordered_map<spv::Id, unsigned> typesize_map_t;\n  169  \n  170     // handle error\n  ...\n  269     // Function start and end.  use unordered_map because we'll have\n  270     // many fewer functions than IDs.\n  271:    std::unordered_map<spv::Id, range_t> fnPos;\n  272  \n  273     // Which functions are called, anywhere in the module, with a call count\n  274:    std::unordered_map<spv::Id, int> fnCalls;\n  275  \n  276     posmap_t       typeConstPos;  // word positions that define types & consts (ordered)\n\n/home/max/dev/Falcor/src/USD/hgiVk/vulkanMemoryAllocator/vk_mem_alloc.h:\n 3524  \n 3525  /* Set this macro to 1 to make the library including and using STL containers:\n 3526: std::pair, std::vector, std::list, std::unordered_map.\n 3527  \n 3528  Set it to 0 or undefined to make the library using its own implementation of\n ....\n 5256  \n 5257  #define VMA_MAP_TYPE(KeyT, ValueT) \\\n 5258:     std::unordered_map< KeyT, ValueT, std::hash<KeyT>, std::equal_to<KeyT>, VmaStlAllocator< std::pair<KeyT, ValueT> > >\n 5259  \n 5260  #else // #if VMA_USE_STL_UNORDERED_MAP\n ....\n 5270  };\n 5271  \n 5272: /* Class compatible with subset of interface of std::unordered_map.\n 5273  KeyT, ValueT must be POD because they will be stored in VmaVector.\n 5274  */\n\n89 matches across 43 files\n\n\nSearching 1282 files for \"ResourceViewInfo\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Buffer.cpp:\n  181  template<typename ViewClass, typename ViewMapType>\n  182  typename ViewClass::SharedPtr findViewCommon(Buffer* pBuffer, uint32_t firstElement, uint32_t elementCount, ViewMapType& viewMap, CreateFuncType<ViewClass> createFunc) {\n  183:     ResourceViewInfo view = ResourceViewInfo(firstElement, elementCount);\n  184  \n  185      if (viewMap.find(view) == viewMap.end()) {\n\n/home/max/dev/Falcor/src/Falcor/Core/API/CopyContext.cpp:\n   73  }\n   74  \n   75: bool CopyContext::resourceBarrier(const Resource* pResource, Resource::State newState, const ResourceViewInfo* pViewInfo) {\n   76      const Texture* pTexture = dynamic_cast<const Texture*>(pResource);\n   77      if (pTexture) {\n   ..\n   95  }\n   96  \n   97: bool CopyContext::subresourceBarriers(const Texture* pTexture, Resource::State newState, const ResourceViewInfo* pViewInfo) {\n   98:     ResourceViewInfo fullResource;\n   99      bool setGlobal = false;\n  100  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/CopyContext.h:\n   94          \\return true if a barrier commands were recorded for the entire resource-view, otherwise false (for example, when the current resource state is the same as the new state or when only some subresources were transitioned)\n   95      */\n   96:     virtual bool resourceBarrier(const Resource* pResource, Resource::State newState, const ResourceViewInfo* pViewInfo = nullptr);\n   97  \n   98      /** Insert a UAV barrier\n   ..\n  156      bool textureBarrier(const Texture* pTexture, Resource::State newState);\n  157      bool bufferBarrier(const Buffer* pBuffer, Resource::State newState);\n  158:     bool subresourceBarriers(const Texture* pTexture, Resource::State newState, const ResourceViewInfo* pViewInfo);\n  159      void apiSubresourceBarrier(const Texture* pTexture, Resource::State newState, Resource::State oldState, uint32_t arraySlice, uint32_t mipLevel);\n  160      void updateTextureSubresources(const Texture* pTexture, uint32_t firstSubresource, uint32_t subresourceCount, const void* pData, const uint3& offset = uint3(0), const uint3& size = uint3(-1));\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Resource.h:\n  131  \n  132      struct ViewInfoHashFunc {\n  133:         std::size_t operator()(const ResourceViewInfo& v) const {\n  134              return ((std::hash<uint32_t>()(v.firstArraySlice) ^ (std::hash<uint32_t>()(v.arraySize) << 1)) >> 1)\n  135                  ^ (std::hash<uint32_t>()(v.mipCount) << 1)\n  ...\n  199      std::shared_ptr<Device> mpDevice;\n  200  \n  201:     mutable std::unordered_map<ResourceViewInfo, ShaderResourceView::SharedPtr, ViewInfoHashFunc> mSrvs;\n  202:     mutable std::unordered_map<ResourceViewInfo, RenderTargetView::SharedPtr, ViewInfoHashFunc> mRtvs;\n  203:     mutable std::unordered_map<ResourceViewInfo, DepthStencilView::SharedPtr, ViewInfoHashFunc> mDsvs;\n  204:     mutable std::unordered_map<ResourceViewInfo, UnorderedAccessView::SharedPtr, ViewInfoHashFunc> mUavs;\n  205  };\n  206  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/ResourceViews.h:\n   45  using ConstBufferSharedPtrRef = const std::shared_ptr<Buffer>&;\n   46  \n   47: struct dlldecl ResourceViewInfo {\n   48:     ResourceViewInfo() = default;\n   49:     ResourceViewInfo(uint32_t mostDetailedMip, uint32_t mipCount, uint32_t firstArraySlice, uint32_t arraySize)\n   50          : mostDetailedMip(mostDetailedMip), mipCount(mipCount), firstArraySlice(firstArraySlice), arraySize(arraySize) {}\n   51  \n   52:     ResourceViewInfo(uint32_t firstElement, uint32_t elementCount)\n   53          : firstElement(firstElement), elementCount(elementCount) {}\n   54  \n   ..\n   65      uint32_t elementCount = kMaxPossible;\n   66  \n   67:     bool operator==(const ResourceViewInfo& other) const {\n   68          return (firstArraySlice == other.firstArraySlice)\n   69              && (arraySize == other.arraySize)\n   ..\n   96      /** Get information about the view.\n   97      */\n   98:     const ResourceViewInfo& getViewInfo() const { return mViewInfo; }\n   99  \n  100      /** Get the resource referenced by the view.\n  ...\n  104   protected:\n  105      ApiHandle mApiHandle;\n  106:     ResourceViewInfo mViewInfo;\n  107      ResourceWeakPtr mpResource;\n  108      std::shared_ptr<Device> mpDevice;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Texture.cpp:\n  168      }\n  169  \n  170:     ResourceViewInfo view = ResourceViewInfo(mostDetailedMip, mipCount, firstArraySlice, arraySize);\n  171  \n  172      if (viewMap.find(view) == viewMap.end()) {\n\n/home/max/dev/Falcor/src/Falcor/Raytracing/RtProgramVarsHelper.cpp:\n   53      }\n   54  \n   55:     bool RtVarsContext::resourceBarrier(const Resource* pResource, Resource::State newState, const ResourceViewInfo* pViewInfo)\n   56      {\n   57          return gpDevice->getRenderContext()->resourceBarrier(pResource, newState, pViewInfo);\n\n/home/max/dev/Falcor/src/Falcor/Raytracing/RtProgramVarsHelper.h:\n  151  \n  152          const LowLevelContextData::SharedPtr& getLowLevelData() const override { return mpLowLevelData; }\n  153:         bool resourceBarrier(const Resource* pResource, Resource::State newState, const ResourceViewInfo* pViewInfo = nullptr) override;\n  154          RtVarsCmdList::SharedPtr getRtVarsCmdList() const { return mpList; }\n  155  \n\n23 matches across 8 files\n\n\nSearching 1282 files for \"Resource(\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Buffer.cpp:\n   60  void* mapBufferApi(std::shared_ptr<Device> pDevice, const Buffer::ApiHandle& apiHandle, size_t size);\n   61  \n   62: Buffer::Buffer(std::shared_ptr<Device> pDevice, size_t size, BindFlags bindFlags, CpuAccess cpuAccess): Resource(pDevice, Type::Buffer, bindFlags, size), mCpuAccess(cpuAccess) {}\n   63  \n   64  Buffer::SharedPtr Buffer::create(std::shared_ptr<Device> pDevice, size_t size, BindFlags bindFlags, CpuAccess cpuAccess, const void* pInitData) {\n   ..\n  125  {\n  126      const auto& pDefaultBlock = pProgram->getReflector()->getDefaultParameterBlock();\n  127:     const ReflectionVar* pVar = pDefaultBlock ? pDefaultBlock->getResource(name).get() : nullptr;\n  128      if (pVar == nullptr) {\n  129          throw std::runtime_error(\"Can't find a structured buffer named `\" + name + \"` in the program\");\n  ...\n  132  }\n  133  \n  134: Buffer::SharedPtr Buffer::aliasResource(std::shared_ptr<Device> pDevice, Resource::SharedPtr pBaseResource, GpuAddress offset, size_t size, Resource::BindFlags bindFlags) {\n  135      assert(pBaseResource->asBuffer()); // Only aliasing buffers for now\n  136      CpuAccess cpuAccess = pBaseResource->asBuffer() ? pBaseResource->asBuffer()->getCpuAccess() : CpuAccess::None;\n  137      if (cpuAccess != CpuAccess::None) {\n  138:         logError(\"Buffer::aliasResource() - trying to alias a buffer with CpuAccess::\" + to_string(cpuAccess) + \" which is illegal. Aliased resource must have CpuAccess::None\");\n  139          return nullptr;\n  140      }\n  141  \n  142      if ((pBaseResource->getBindFlags() & bindFlags) != bindFlags) {\n  143:         logError(\"Buffer::aliasResource() - requested buffer bind-flags don't match the aliased resource bind flags.\\nRequested = \" + to_string(bindFlags) + \"\\nAliased = \" + to_string(pBaseResource->getBindFlags()));\n  144          return nullptr;\n  145      }\n  146  \n  147      if (offset >= pBaseResource->getSize() || (offset + size) >= pBaseResource->getSize()) {\n  148:         logError(\"Buffer::aliasResource() - requested offset and size don't fit inside the alias resource dimensions. Requesed size = \" +\n  149              to_string(size) + \", offset = \" + to_string(offset) + \". Aliased resource size = \" + to_string(pBaseResource->getSize()));\n  150          return nullptr;\n  ...\n  172          mpDevice->getUploadHeap()->release(mDynamicData);\n  173      } else {\n  174:         mpDevice->releaseResource(mApiHandle);\n  175      }\n  176  }\n  ...\n  288              RenderContext* pContext = mpDevice->getRenderContext();\n  289              assert(mGpuVaOffset == 0);\n  290:             pContext->copyResource(mpStagingResource.get(), this);\n  291              pContext->flush(true);\n  292  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Buffer.h:\n  180          bool createCounter = true);\n  181  \n  182:     static SharedPtr aliasResource(std::shared_ptr<Device> pDevice, Resource::SharedPtr pBaseResource, GpuAddress offset, size_t size, Resource::BindFlags bindFlags);\n  183  \n  184      /** Create a new buffer from an existing API handle.\n\n/home/max/dev/Falcor/src/Falcor/Core/API/ComputeStateObject.cpp:\n   40  \n   41  ComputeStateObject::~ComputeStateObject() {\n   42:     mpDevice->releaseResource(mApiHandle);\n   43  }\n   44  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/CopyContext.h:\n  102      /** Copy an entire resource\n  103      */\n  104:     void copyResource(const Resource* pDst, const Resource* pSrc);\n  105  \n  106      /** Copy a subresource\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Buffer.cpp:\n   55          ID3D12ResourcePtr pApiHandle;\n   56          D3D12_HEAP_FLAGS heapFlags = is_set(bindFlags, ResourceBindFlags::Shared) ? D3D12_HEAP_FLAG_SHARED : D3D12_HEAP_FLAG_NONE;\n   57:         d3d_call(pDevice->CreateCommittedResource(&heapProps, heapFlags, &bufDesc, d3dState, nullptr, IID_PPV_ARGS(&pApiHandle)));\n   58          \n   59          // Map and upload data if needed\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12ComputeContext.cpp:\n  118      void clearUavCommon(ComputeContext* pContext, const UnorderedAccessView* pUav, const ClearType& clear, ID3D12GraphicsCommandList* pList)\n  119      {\n  120:         pContext->resourceBarrier(pUav->getResource(), Resource::State::UnorderedAccess);\n  121          UavHandle uav = pUav->getApiHandle();\n  122          if (typeid(ClearType) == typeid(float4))\n  123          {\n  124:             pList->ClearUnorderedAccessViewFloat(uav->getGpuHandle(0), uav->getCpuHandle(0), pUav->getResource()->getApiHandle(), (float*)value_ptr(clear), 0, nullptr);\n  125          }\n  126          else if (typeid(ClearType) == typeid(uint4))\n  127          {\n  128:             pList->ClearUnorderedAccessViewUint(uav->getGpuHandle(0), uav->getCpuHandle(0), pUav->getResource()->getApiHandle(), (uint32_t*)value_ptr(clear), 0, nullptr);\n  129          }\n  130          else\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12CopyContext.cpp:\n  277      }\n  278  \n  279:     void CopyContext::copyResource(const Resource* pDst, const Resource* pSrc)\n  280      {\n  281          resourceBarrier(pDst, Resource::State::CopyDest);\n  282          resourceBarrier(pSrc, Resource::State::CopySource);\n  283:         mpLowLevelData->getCommandList()->CopyResource(pDst->getApiHandle(), pSrc->getApiHandle());\n  284          mCommandsPending = true;\n  285      }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12NvApiExDesc.h:\n   86      {\n   87          auto pBlock = pKernels->getReflector()->getDefaultParameterBlock();\n   88:         auto pVar = pBlock->getResource(\"g_NvidiaExt\");\n   89          if (!pVar) return std::optional<uint32_t>();\n   90  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12RenderContext.cpp:\n  140      void RenderContext::clearRtv(const RenderTargetView* pRtv, const float4& color)\n  141      {\n  142:         resourceBarrier(pRtv->getResource(), Resource::State::RenderTarget);\n  143          mpLowLevelData->getCommandList()->ClearRenderTargetView(pRtv->getApiHandle()->getCpuHandle(0), glm::value_ptr(color), 0, nullptr);\n  144          mCommandsPending = true;\n  ...\n  150          flags |= clearStencil ? D3D12_CLEAR_FLAG_STENCIL : 0;\n  151  \n  152:         resourceBarrier(pDsv->getResource(), Resource::State::DepthStencil);\n  153          mpLowLevelData->getCommandList()->ClearDepthStencilView(pDsv->getApiHandle()->getCpuHandle(0), D3D12_CLEAR_FLAGS(flags), depth, stencil, 0, nullptr);\n  154          mCommandsPending = true;\n  ...\n  424          assert(pDst->getViewInfo().arraySize == 1 && pDst->getViewInfo().mipCount == 1);\n  425  \n  426:         const Texture* pSrcTexture = dynamic_cast<const Texture*>(pSrc->getResource());\n  427:         const Texture* pDstTexture = dynamic_cast<const Texture*>(pDst->getResource());\n  428          assert(pSrcTexture != nullptr && pDstTexture != nullptr);\n  429  \n  ...\n  487      }\n  488  \n  489:     void RenderContext::resolveResource(const Texture::SharedPtr& pSrc, const Texture::SharedPtr& pDst)\n  490      {\n  491          bool match = true;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Texture.cpp:\n  143  \n  144          D3D12_HEAP_FLAGS heapFlags = is_set(mBindFlags, ResourceBindFlags::Shared) ? D3D12_HEAP_FLAG_SHARED : D3D12_HEAP_FLAG_NONE;\n  145:         d3d_call(gpDevice->getApiHandle()->CreateCommittedResource(&kDefaultHeapProps, heapFlags, &desc, D3D12_RESOURCE_STATE_COMMON, pClearVal, IID_PPV_ARGS(&mApiHandle)));\n  146  \n  147          if (pData)\n  ...\n  153      Texture::~Texture()\n  154      {\n  155:         gpDevice->releaseResource(mApiHandle);\n  156      }\n  157  }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Device.cpp:\n  227  }\n  228  \n  229: void Device::releaseResource(ApiObjectHandle pResource) {\n  230      if (pResource) {\n  231          // Some static objects get here when the application exits\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Device.h:\n  193      const DescriptorPool::SharedPtr& getGpuDescriptorPool() const { return mpGpuDescPool; }\n  194      const GpuMemoryHeap::SharedPtr& getUploadHeap() const { return mpUploadHeap; }\n  195:     void releaseResource(ApiObjectHandle pResource);\n  196      double getGpuTimestampFrequency() const { return mGpuTimestampFrequency; }  // ms/tick\n  197  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/GraphicsStateObject.cpp:\n   67  \n   68  GraphicsStateObject::~GraphicsStateObject() {\n   69:     mpDevice->releaseResource(mApiHandle);\n   70  }\n   71  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/RenderContext.h:\n  181          If any of these properties don't match, you'll have to use `resolveSubresource`\n  182      */\n  183:     void resolveResource(const Texture::SharedPtr& pSrc, const Texture::SharedPtr& pDst);\n  184  \n  185      /** Resolve a multi-sampled sub-resource\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Resource.cpp:\n   32  namespace Falcor {\n   33  \n   34: Resource::~Resource() = default;\n   35  \n   36  const std::string to_string(Resource::Type type) {\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Resource.h:\n   97      static const uint32_t kMaxPossible = RenderTargetView::kMaxPossible;\n   98  \n   99:     virtual ~Resource() = 0;\n  100  \n  101      std::shared_ptr<Device> device() { return mpDevice; }\n  ...\n  177      friend class CopyContext;\n  178  \n  179:     Resource(std::shared_ptr<Device> pDevice, Type type, BindFlags bindFlags, uint64_t size) : mpDevice(pDevice), mType(type), mBindFlags(bindFlags), mSize(size) {}\n  180  \n  181      Type mType;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/ResourceViews.h:\n   85  \n   86      ResourceView(std::shared_ptr<Device> pDevice, ResourceWeakPtr& pResource, ApiHandle handle, uint32_t mostDetailedMip, uint32_t mipCount, uint32_t firstArraySlice, uint32_t arraySize)\n   87:         : mApiHandle(handle), mpDevice(pDevice), mpResource(pResource), mViewInfo(mostDetailedMip, mipCount, firstArraySlice, arraySize) {}\n   88  \n   89      ResourceView(std::shared_ptr<Device> pDevice, ResourceWeakPtr& pResource, ApiHandle handle, uint32_t firstElement, uint32_t elementCount)\n   90:         : mApiHandle(handle), mpDevice(pDevice), mpResource(pResource), mViewInfo(firstElement, elementCount) {}\n   91  \n   92      /** Get the raw API handle.\n   ..\n  100      /** Get the resource referenced by the view.\n  101      */\n  102:     Resource* getResource() const { return mpResource.lock().get(); }\n  103  \n  104   protected:\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Texture.cpp:\n  121  \n  122  Texture::Texture(std::shared_ptr<Device> device, uint32_t width, uint32_t height, uint32_t depth, uint32_t arraySize, uint32_t mipLevels, uint32_t sampleCount, ResourceFormat format, Type type, BindFlags bindFlags)\n  123:     : Resource(device, type, bindFlags, 0), mWidth(width), mHeight(height), mDepth(depth), mMipLevels(mipLevels), mSampleCount(sampleCount), mArraySize(arraySize), mFormat(format) {\n  124      assert(width > 0 && height > 0 && depth > 0);\n  125      assert(arraySize > 0 && mipLevels > 0 && sampleCount > 0);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKComputeContext.cpp:\n  102              return;\n  103          }\n  104:         pCtx->resourceBarrier(pView->getResource(), Resource::State::CopyDest);\n  105          VkClearColorValue colVal;\n  106          assert(sizeof(ClearType) <= sizeof(colVal.float32));\n  ...\n  114          range.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;\n  115  \n  116:         vkCmdClearColorImage(pCtx->getLowLevelData()->getCommandList(), pView->getResource()->getApiHandle(), VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, &colVal, 1, &range);\n  117      }\n  118  \n  ...\n  133                  logWarning(\"Vulkan buffer clears only support a single element. A vector was supplied which has different elements per channel. only `x` will be used'\");\n  134              }\n  135:             const Buffer* pBuffer = dynamic_cast<const Buffer*>(pUav->getResource());\n  136              vkCmdFillBuffer(getLowLevelData()->getCommandList(), pBuffer->getApiHandle(), pBuffer->getGpuAddressOffset(), pBuffer->getSize(), value.x);\n  137          }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKCopyContext.cpp:\n  334      }\n  335  \n  336:     void CopyContext::copyResource(const Resource* pDst, const Resource* pSrc)\n  337      {\n  338          const Buffer* pDstBuffer = dynamic_cast<const Buffer*>(pDst);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKDescriptorSet.cpp:\n   70  \n   71          if (handle.getType() == VkResourceType::Buffer) {\n   72:             Buffer* pBuffer = dynamic_cast<Buffer*>(pView->getResource());\n   73              if (pBuffer->isTyped()) {\n   74                  texelBufferView = pBuffer->getUAV()->getApiHandle();\n   ..\n  127          VkDescriptorBufferInfo info;\n  128  \n  129:         const auto& pBuffer = dynamic_cast<const Buffer*>(pView->getResource());\n  130          assert(pBuffer);\n  131          info.buffer = pBuffer->getApiHandle();\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKFbo.cpp:\n   41  \n   42  Fbo::~Fbo() {\n   43:     mpDevice->releaseResource(std::static_pointer_cast<VkBaseApiHandle>(mApiHandle));\n   44  }\n   45  \n   ..\n  106      vkCreateFramebuffer(mpDevice->getApiHandle(), &frameBufferInfo, nullptr, &frameBuffer);\n  107  \n  108:     if (mApiHandle) mpDevice->releaseResource(std::static_pointer_cast<VkBaseApiHandle>(mApiHandle));\n  109      mApiHandle = ApiHandle::create(mpDevice, pass, frameBuffer);\n  110  }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKRenderContext.cpp:\n   57      void RenderContext::clearDsv(const DepthStencilView* pDsv, float depth, uint8_t stencil, bool clearDepth, bool clearStencil) {\n   58          // LOG_DBG(\"clear dsv\");\n   59:         resourceBarrier(pDsv->getResource(), Resource::State::CopyDest);\n   60  \n   61          VkClearDepthStencilValue val;\n   ..\n   72          range.aspectMask |= clearStencil ? VK_IMAGE_ASPECT_STENCIL_BIT : 0;\n   73  \n   74:         vkCmdClearDepthStencilImage(mpLowLevelData->getCommandList(), pDsv->getResource()->getApiHandle(), VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, &val, 1, &range);\n   75          mCommandsPending = true;\n   76      }\n   ..\n  263      template<uint32_t offsetCount, typename ViewType>\n  264      void initBlitData(const ViewType* pView, const uint4& rect, VkImageSubresourceLayers& layer, VkOffset3D offset[offsetCount]) {\n  265:         const Texture* pTex = dynamic_cast<const Texture*>(pView->getResource());\n  266  \n  267          layer.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT; // Can't blit depth texture\n  ...\n  285  \n  286      void RenderContext::blit(ShaderResourceView::SharedPtr pSrc, RenderTargetView::SharedPtr pDst, const uint4& srcRect, const uint4& dstRect, Sampler::Filter filter) {\n  287:         const Texture* pTexture = dynamic_cast<const Texture*>(pSrc->getResource());\n  288:         resourceBarrier(pSrc->getResource(), Resource::State::CopySource, &pSrc->getViewInfo());\n  289:         resourceBarrier(pDst->getResource(), Resource::State::CopyDest, &pDst->getViewInfo());\n  290  \n  291          if (pTexture && pTexture->getSampleCount() > 1) {\n  ...\n  299              resolve.extent.depth = 1;\n  300  \n  301:             vkCmdResolveImage(mpLowLevelData->getCommandList(), pSrc->getResource()->getApiHandle(), VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, pDst->getResource()->getApiHandle(), VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &resolve);\n  302          } else {\n  303              VkImageBlit blt;\n  ...\n  307              // Vulkan spec requires VK_FILTER_NEAREST if blit source is a depth and/or stencil format\n  308              VkFilter vkFilter = isDepthStencilFormat(pTexture->getFormat()) ? VK_FILTER_NEAREST : getVkFilter(filter);\n  309:             vkCmdBlitImage(mpLowLevelData->getCommandList(), pSrc->getResource()->getApiHandle(), VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, pDst->getResource()->getApiHandle(), VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &blt, vkFilter);\n  310          }\n  311          mCommandsPending = true;\n  312      }\n  313  \n  314:     void RenderContext::resolveResource(const Texture::SharedPtr& pSrc, const Texture::SharedPtr& pDst) {\n  315          // Just blit. It will work\n  316          blit(pSrc->getSRV(), pDst->getRTV());\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKResourceViews.cpp:\n   47  template<typename ApiHandleType>\n   48  ResourceView<ApiHandleType>::~ResourceView() {\n   49:     getResource()->device()->releaseResource(mApiHandle);\n   50  }\n   51  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VkSmartHandle.cpp:\n   56  \n   57      template<>\n   58:     VkResource<VkImage, VkBuffer>::~VkResource() {\n   59:         LOG_DBG(\"~VkResource() <VkImage, VkBuffer>\");\n   60          if (!mpDevice) {\n   61              // #VKTODO This is here because of the black texture in VkResourceViews.cpp\n   ..\n   83  \n   84      template<>\n   85:     VkResource<VkImageView, VkBufferView>::~VkResource() {\n   86:         LOG_DBG(\"~VkResource() <VkImageView, VkBufferView>\");\n   87          if (!mpDevice) {\n   88              // #VKTODO This is here because of the black texture in VkResourceViews.cpp\n   ..\n  129      template VkHandle<VkQueryPool>::~VkHandle();\n  130  \n  131:     template VkResource<VkImage, VkBuffer>::~VkResource();\n  132:     template VkResource<VkImageView, VkBufferView>::~VkResource();\n  133  }  // namespace Falcor\n  134  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKSmartHandle.h:\n  163      };\n  164  \n  165:     ~VkResource() {\n  166  #ifdef _WIN32\n  167          static_assert(false, \"VkResource missing destructor specialization\");\n  ...\n  171   private:\n  172      friend SharedPtr;\n  173:     VkResource(std::shared_ptr<Device> device, ImageType image, VkDeviceMemory mem) : VkBaseApiHandle(device), mType(VkResourceType::Image), mImage(image), mDeviceMem(mem) { }\n  174      \n  175:     VkResource(std::shared_ptr<Device> device, BufferType buffer, VkDeviceMemory mem) : VkBaseApiHandle(device), mType(VkResourceType::Buffer), mBuffer(buffer), mDeviceMem(mem) { }\n  176  \n  177      VkResourceType mType = VkResourceType::None;\n  ...\n  219  template<> VkHandle<VkQueryPool>::~VkHandle();\n  220  \n  221: template<> VkResource<VkImage, VkBuffer>::~VkResource();\n  222: template<> VkResource<VkImageView, VkBufferView>::~VkResource();\n  223  \n  224  }  // namespace Falcor\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKTexture.cpp:\n   39      Texture::~Texture() {\n   40          // #VKTODO the `if` is here because of the black texture in VkResourceView.cpp\n   41:         if (mpDevice ) mpDevice->releaseResource(std::static_pointer_cast<VkBaseApiHandle>(mApiHandle));\n   42      }\n   43  \n\n/home/max/dev/Falcor/src/Falcor/Core/BufferTypes/ParameterBlock.cpp:\n  144  Resource::SharedPtr getResourceFromView(const ViewType* pView) {\n  145      if (!pView) return nullptr;\n  146:     auto pResource = pView->getResource();\n  147      if (!pResource) return nullptr;\n  148      return pResource->shared_from_this();\n  ...\n 1149  }\n 1150  \n 1151: static void prepareResource(CopyContext* pContext, Resource* pResource, bool isUav) {\n 1152      if (!pResource) return;\n 1153  \n ....\n 1460          // Prepare all bound resources by inserting appropriate barriers/transitions as needed.\n 1461          for (auto& srv : mSRVs) {\n 1462:             prepareResource(pContext, srv.pResource.get(), false);\n 1463          }\n 1464  \n 1465          for (auto& uav : mUAVs) {\n 1466:             prepareResource(pContext, uav.pResource.get(), true);\n 1467          }\n 1468  \n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramReflection.cpp:\n 1556      }\n 1557  \n 1558:     const ReflectionVar::SharedConstPtr ParameterBlockReflection::getResource(const std::string& name) const\n 1559      {\n 1560          return getElementType()->findMember(name);\n ....\n 2020      }\n 2021  \n 2022:     const ReflectionVar::SharedConstPtr ProgramReflection::getResource(const std::string& name) const\n 2023      {\n 2024:         return mpDefaultBlock->getResource(name);\n 2025      }\n 2026  \n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramReflection.h:\n  355          ResourceShaderVarOffset resource)\n  356          : mUniform(uniform)\n  357:         , mResource(resource)\n  358      {}\n  359  \n  ...\n  376      ShaderVarOffset(Invalid _ = kInvalid)\n  377          : mUniform(UniformShaderVarOffset::kInvalid)\n  378:         , mResource(ResourceShaderVarOffset::kInvalid)\n  379      {}\n  380  \n  ...\n  391      ShaderVarOffset(Zero)\n  392          : mUniform(UniformShaderVarOffset::kZero)\n  393:         , mResource(ResourceShaderVarOffset::kZero)\n  394      {}\n  395  \n  ...\n  420      /** Get the underlying resource offset.\n  421      */\n  422:     ResourceShaderVarOffset getResource() const\n  423      {\n  424          return mResource;\n  ...\n 1200      /** Get the variable for a resource in the block\n 1201      */\n 1202:     const ReflectionVar::SharedConstPtr getResource(const std::string& name) const;\n 1203  \n 1204      /** Get the bind-location for a resource in the block\n ....\n 1463      /** Get a resource from the default parameter block\n 1464      */\n 1465:     const ReflectionVar::SharedConstPtr getResource(const std::string& name) const;\n 1466  \n 1467      /** Search for a vertex attribute by its semantic name\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ShaderVar.cpp:\n  169              {\n  170                  UniformShaderVarOffset elementUniformLocation = mOffset.getUniform() + index * pArrayType->getElementByteStride();\n  171:                 ResourceShaderVarOffset elementResourceLocation(mOffset.getResource().getRangeIndex(), mOffset.getResource().getArrayIndex() * elementCount + ResourceShaderVarOffset::ArrayIndex(index));\n  172                  TypedShaderVarOffset newOffset = TypedShaderVarOffset(pArrayType->getElementType().get(), ShaderVarOffset(elementUniformLocation, elementResourceLocation));\n  173                  return ShaderVar(mpBlock, newOffset);\n  ...\n  247              auto offsetIntoElement = byteOffset % elementStride;\n  248  \n  249:             TypedShaderVarOffset elementOffset = TypedShaderVarOffset(pElementType.get(), ShaderVarOffset(mOffset.getUniform() + elementIndex * elementStride, mOffset.getResource()));\n  250              ShaderVar elementCursor(mpBlock, elementOffset);\n  251              return elementCursor[UniformShaderVarOffset(offsetIntoElement)];\n\n/home/max/dev/Falcor/src/Falcor/Core/Sample.cpp:\n  455              auto pSwapChainFbo = mpDevice->getSwapChainFbo();\n  456              RenderContext* pRenderContext = getRenderContext();\n  457:             pRenderContext->copyResource(pSwapChainFbo->getColorTexture(0).get(), mpTargetFBO->getColorTexture(0).get());\n  458  \n  459              // Capture video frame before UI is rendered\n\n/home/max/dev/Falcor/src/Falcor/Raytracing/RtProgramVarsHelper.h:\n   71          void CopyBufferRegion(ID3D12Resource *pDstBuffer, UINT64 DstOffset, ID3D12Resource *pSrcBuffer, UINT64 SrcOffset, UINT64 NumBytes) { should_not_get_here(); }\n   72          void CopyTextureRegion(const D3D12_TEXTURE_COPY_LOCATION *pDst, UINT DstX, UINT DstY, UINT DstZ, const D3D12_TEXTURE_COPY_LOCATION *pSrc, const D3D12_BOX *pSrcBox) { should_not_get_here(); }\n   73:         void CopyResource(ID3D12Resource *pDstResource, ID3D12Resource *pSrcResource) { should_not_get_here(); }\n   74          void CopyTiles(ID3D12Resource *pTiledResource, const D3D12_TILED_RESOURCE_COORDINATE *pTileRegionStartCoordinate, const D3D12_TILE_REGION_SIZE *pTileRegionSize, ID3D12Resource *pBuffer, UINT64 BufferStartOffsetInBytes, D3D12_TILE_COPY_FLAGS Flags) { should_not_get_here(); }\n   75          void ResolveSubresource(ID3D12Resource *pDstResource, UINT DstSubresource, ID3D12Resource *pSrcResource, UINT SrcSubresource, DXGI_FORMAT Format) { should_not_get_here(); }\n   ..\n   98          void ClearUnorderedAccessViewFloat(D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap, D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle, ID3D12Resource *pResource, const FLOAT Values[4], UINT NumRects, const D3D12_RECT *pRects) { should_not_get_here(); }\n   99          void ClearUnorderedAccessViewUint(D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap, D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle, ID3D12Resource *pResource, const UINT Values[4], UINT NumRects, const D3D12_RECT *pRects) { should_not_get_here(); }\n  100:         void DiscardResource(ID3D12Resource *pResource, const D3D12_DISCARD_REGION *pRegion) { should_not_get_here(); }\n  101          void BeginQuery(ID3D12QueryHeap *pQueryHeap, D3D12_QUERY_TYPE Type, UINT Index) { should_not_get_here(); }\n  102          void EndQuery(ID3D12QueryHeap *pQueryHeap, D3D12_QUERY_TYPE Type, UINT Index) { should_not_get_here(); }\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraph.cpp:\n  488      }\n  489  \n  490:     return mpExe->getResource(name);\n  491  }\n  492  \n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraphCompiler.cpp:\n   46      // Register the external resources\n   47      auto pResourcesCache = ResourceCache::create(graph.device());\n   48:     for (const auto&[name, pRes] : dependencies.externalResources) pResourcesCache->registerExternalResource(name, pRes);\n   49  \n   50      c.resolveExecutionOrder();\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraphExe.cpp:\n   87      }\n   88  \n   89:     Resource::SharedPtr RenderGraphExe::getResource(const std::string& name) const {\n   90          assert(mpResourceCache);\n   91:         return mpResourceCache->getResource(name);\n   92      }\n   93  \n   94      void RenderGraphExe::setInput(const std::string& name, const Resource::SharedPtr& pResource) {\n   95:         mpResourceCache->registerExternalResource(name, pResource);\n   96      }\n   97  }\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraphExe.h:\n   70          /** Get a resource from the cache\n   71          */\n   72:         Resource::SharedPtr getResource(const std::string& name) const;\n   73  \n   74          /** Set an external input resource\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderPass.cpp:\n   41  }\n   42  \n   43: const Resource::SharedPtr& RenderData::getResource(const std::string& name) const {\n   44:     return mpResources->getResource(mName + '.' + name);\n   45  }\n   46  \n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderPass.h:\n   46              \\return If the name exists, a pointer to the resource. Otherwise, nullptr\n   47          */\n   48:         const Resource::SharedPtr& operator[](const std::string& name) const { return getResource(name); }\n   49  \n   50          /** Get a resource\n   ..\n   52              \\return If the name exists, a pointer to the resource. Otherwise, nullptr\n   53          */\n   54:         const Resource::SharedPtr& getResource(const std::string& name) const;\n   55  \n   56          /** Get the global dictionary. You can use it to pass data between different passes\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/ResourceCache.cpp:\n   43      }\n   44  \n   45:     const Resource::SharedPtr& ResourceCache::getResource(const std::string& name) const {\n   46          static const Resource::SharedPtr pNull;\n   47          auto extIt = mExternalResources.find(name);\n   ..\n   63      }\n   64  \n   65:     void ResourceCache::registerExternalResource(const std::string& name, const Resource::SharedPtr& pResource) {\n   66          if(pResource) mExternalResources[name] = pResource;\n   67          else\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/ResourceCache.h:\n   57          \\param[in] pResource The resource to register. If this is null, will unregister the resource\n   58      */\n   59:     void registerExternalResource(const std::string& name, const Resource::SharedPtr& pResource);\n   60  \n   61      /** Register a field that requires resources to be allocated.\n   ..\n   70      /** Get a resource by name. Includes external resources known by the cache.\n   71      */\n   72:     const Resource::SharedPtr& getResource(const std::string& name) const;\n   73  \n   74      /** Get the field-reflection of a resource\n\n/home/max/dev/Falcor/src/Falcor/RenderPasses/ResolvePass.cpp:\n   59          }\n   60  \n   61:         pContext->resolveResource(pSrcTex, pDstTex);\n   62      } else {\n   63          logWarning(\"ResolvePass::execute() - missing an input or output resource\");\n\n/home/max/dev/Falcor/src/Falcor/RenderPasses/Shared/PathTracer/PathTracer.cpp:\n  559                  assert(pDstRayCount->getFormat() == pSrcRayCount->getFormat());\n  560                  assert(pDstRayCount->getWidth() == pSrcRayCount->getWidth() && pDstRayCount->getHeight() == pSrcRayCount->getHeight());\n  561:                 pRenderContext->copyResource(pDstRayCount, pSrcRayCount);\n  562              }\n  563          }\n\n/home/max/dev/Falcor/src/Falcor/Scene/Animation/AnimationController.cpp:\n   78              if (mLastAnimationTime == currentTime) {\n   79                  // Copy the current matrices to the previous matrices. We can do that only once, but not sure if it we'll help perf (it only occures when the animation is paused)\n   80:                 pContext->copyResource(mpPrevWorldMatricesBuffer.get(), mpWorldMatricesBuffer.get());\n   81                  return false;\n   82              }\n\n/home/max/dev/Falcor/src/Falcor/Utils/UI/PixelZoom.cpp:\n   73      if (mShouldZoom) {\n   74          //copy backbuffer into src blit fbo\n   75:         pCtx->copyResource(mpSrcBlitFbo->getColorTexture(0).get(), backBuffer->getColorTexture(0).get());\n   76  \n   77          //blit src blit fbo into dst blit fbo\n\n/home/max/dev/Falcor/src/RenderPasses/ForwardLightingPass/ForwardLightingPass.cpp:\n  140      for (uint32_t i = 1; i < 3; i++) {\n  141          const auto& pRtv = mpFbo->getRenderTargetView(i).get();\n  142:         if (pRtv->getResource() != nullptr) pContext->clearRtv(pRtv, float4(0));\n  143      }\n  144  \n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/GBuffer/GBufferRaster.cpp:\n  188      mpDepthPrePassGraph->execute(pRenderContext);\n  189      mpFbo->attachDepthStencilTarget(mpDepthPrePassGraph->getOutput(\"DepthPrePass.depth\")->asTexture());\n  190:     pRenderContext->copyResource(renderData[kDepthName].get(), mpDepthPrePassGraph->getOutput(\"DepthPrePass.depth\").get());\n  191  \n  192      // Bind extra channels as UAV buffers.\n\n/home/max/dev/Falcor/src/RenderPasses/TemporalDelayPass/TemporalDelayPass.cpp:\n  107  void TemporalDelayPass::execute(RenderContext* pRenderContext, const RenderData& renderData) {\n  108      if (mDelay == 0) {\n  109:         pRenderContext->copyResource(renderData[kMaxDelay].get(), renderData[kSrc].get());\n  110          return;\n  111      }\n  112      for (uint32_t copyDst = 0; copyDst <= mDelay; ++copyDst) {\n  113          uint32_t copySrc = copyDst + 1;\n  114:         if (copyDst == 0) pRenderContext->copyResource(renderData[kMaxDelay].get(), renderData[kMaxDelay + \"-\" + to_string(copySrc)].get());\n  115:         else if (copyDst == mDelay) pRenderContext->copyResource(renderData[kMaxDelay + \"-\" + to_string(copyDst)].get(), renderData[kSrc].get());\n  116:         else pRenderContext->copyResource(renderData[kMaxDelay + \"-\" + to_string(copyDst)].get(), renderData[kMaxDelay + \"-\" + to_string(copySrc)].get());\n  117      }\n  118  }\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/SPIRV/GlslangToSpv.cpp:\n 1195  // Return whether or not the given type is something that should be tied to a\n 1196  // descriptor set.\n 1197: bool IsDescriptorResource(const glslang::TType& type)\n 1198  {\n 1199      // uniform and buffer blocks are included, unless it is a push_constant\n ....\n 7472      if (symbol->getQualifier().hasSet())\n 7473          builder.addDecoration(id, spv::DecorationDescriptorSet, symbol->getQualifier().layoutSet);\n 7474:     else if (IsDescriptorResource(symbol->getType())) {\n 7475          // default to 0\n 7476          builder.addDecoration(id, spv::DecorationDescriptorSet, 0);\n ....\n 7478      if (symbol->getQualifier().hasBinding())\n 7479          builder.addDecoration(id, spv::DecorationBinding, symbol->getQualifier().layoutBinding);\n 7480:     else if (IsDescriptorResource(symbol->getType())) {\n 7481          // default to 0\n 7482          builder.addDecoration(id, spv::DecorationBinding, 0);\n\n115 matches across 49 files\n\n\nSearching 1282 files for \"setResourceSrvUavCommon\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/BufferTypes/ParameterBlock.cpp:\n  546  }\n  547  \n  548: bool ParameterBlock::setResourceSrvUavCommon(const BindLocation& bindLoc, const Resource::SharedPtr& pResource, const char* funcName) {\n  549      size_t flatIndex = getFlatIndex(bindLoc);\n  550  \n  ...\n  636      if (!bindLocation.isValid()) return false;\n  637  \n  638:     return setResourceSrvUavCommon(bindLocation, pBuf, \"setBuffer()\");\n  639  }\n  640  \n  ...\n  715  \n  716  bool ParameterBlock::setTexture(const BindLocation& bindLocation, const Texture::SharedPtr& pTexture) {\n  717:     return setResourceSrvUavCommon(bindLocation, pTexture, \"setTexture()\");\n  718  }\n  719  \n\n/home/max/dev/Falcor/src/Falcor/Core/BufferTypes/ParameterBlock.h:\n  422      bool checkRootDescriptorResourceCompatibility(const Resource::SharedPtr& pResource, const std::string& funcName) const;\n  423  \n  424:     bool setResourceSrvUavCommon(const BindLocation& bindLoc, const Resource::SharedPtr& pResource, const char* funcName);\n  425      Resource::SharedPtr getResourceSrvUavCommon(const BindLocation& bindLoc, const char* funcName) const;\n  426  \n\n4 matches across 2 files\n\n\nSearching 1282 files for \"mDeferredReleases\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Device.cpp:\n  168  void Device::release() {\n  169      LOG_DBG(\"Start deffered releses.\");\n  170:     decltype(mDeferredReleases)().swap(mDeferredReleases);  \n  171      LOG_DBG(\"Deffered releases done.\");\n  172  }\n  ...\n  237          // Some static objects get here when the application exits\n  238          if(this) {\n  239:             mDeferredReleases.push({ mpFrameFence->getCpuValue(), pResource });\n  240          }\n  241      }\n  ...\n  250      uint64_t gpuVal = mpFrameFence->getGpuValue();\n  251  \n  252:     while (mDeferredReleases.size() && mDeferredReleases.front().frameID <= gpuVal) {\n  253:         mDeferredReleases.pop();\n  254      }\n  255      \n  ...\n  268      for (uint32_t i = 0; i < arraysize(mCmdQueues); i++) mCmdQueues[i].clear();\n  269      for (uint32_t i = 0; i < kSwapChainBuffersCount; i++) mpSwapChainFbos[i].reset();\n  270:     mDeferredReleases = decltype(mDeferredReleases)();\n  271      releaseNullViews();\n  272      releaseNullBufferViews();\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Device.h:\n  215      };\n  216  \n  217:     std::queue<ResourceRelease> mDeferredReleases;\n  218  \n  219      uint32_t mCurrentBackBufferIndex;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/GpuMemoryHeap.cpp:\n   33  \n   34      GpuMemoryHeap::~GpuMemoryHeap() {\n   35:         mDeferredReleases = decltype(mDeferredReleases)();\n   36      }\n   37  \n   ..\n   95      void GpuMemoryHeap::release(Allocation& data) {\n   96          assert(data.pResourceHandle);\n   97:         mDeferredReleases.push(data);\n   98      }\n   99  \n  100      void GpuMemoryHeap::executeDeferredReleases() {\n  101          uint64_t gpuVal = mpFence->getGpuValue();\n  102:         while (mDeferredReleases.size() && mDeferredReleases.top().fenceValue <= gpuVal) {\n  103:             const Allocation& data = mDeferredReleases.top();\n  104              \n  105              if (data.pageID == mCurrentPageId) {\n  ...\n  119                  // else it's a mega-page. Popping it will release the resource\n  120              }\n  121:             mDeferredReleases.pop();\n  122          }\n  123      }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/GpuMemoryHeap.h:\n   97      PageData::UniquePtr mpActivePage;\n   98  \n   99:     std::priority_queue<Allocation> mDeferredReleases;\n  100      std::unordered_map<size_t, PageData::UniquePtr> mUsedPages;\n  101      std::queue<PageData::UniquePtr> mAvailablePages;\n\n17 matches across 4 files\n\n\nSearching 1282 files for \"SharedPtr(this)\" (case sensitive)\n\n0 matches\n\nSearching 1282 files for \"smartDevicePtr\" (case sensitive)\n\n0 matches\n\nSearching 1282 files for \"Device uid\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Device.cpp:\n   52      if (!pWindow){\n   53          headless = true;\n   54:         LOG_DBG(\"Device uid: %u type headless\", _uid);\n   55      } else {\n   56          headless = false;\n   57:         LOG_DBG(\"Device uid: %u\", _uid);\n   58      }\n   59  }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKResourceViews.cpp:\n  302      VkBufferView bufferView = {};\n  303  \n  304:     std::cout << \"Device uid \" << pDevice->uid() << std::endl;\n  305      \n  306      auto handle = VkResource<VkImageView, VkBufferView>::SharedPtr::create(pDevice, bufferView, nullptr);\n\n3 matches across 2 files\n\n\nSearching 1282 files for \"Device uid\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Device.cpp:\n   52      if (!pWindow){\n   53          headless = true;\n   54:         LOG_DBG(\"Device uid: %u type headless\", _uid);\n   55      } else {\n   56          headless = false;\n   57:         LOG_DBG(\"Device uid: %u\", _uid);\n   58      }\n   59  }\n\n2 matches in 1 file\n\n\nSearching 1282 files for \"loadRenderPassLibrary\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraphIR.cpp:\n   41      const char* RenderGraphIR::kAutoGenEdges = \"autoGenEdges\";\n   42      const char* RenderGraphIR::kUpdatePass = \"updatePass\";\n   43:     const char* RenderGraphIR::kLoadPassLibrary = \"loadRenderPassLibrary\";\n   44      const char* RenderGraphIR::kRenderPass = \"RenderPass\";\n   45      const char* RenderGraphIR::kRenderGraph = \"RenderGraph\";\n\n/home/max/dev/Falcor/src/Mogwai/Data/BSDFViewer.py:\n    1  def render_graph_BSDFViewerGraph():\n    2      g = RenderGraph(\"BSDFViewerGraph\")\n    3:     loadRenderPassLibrary(\"AccumulatePass\")\n    4:     loadRenderPassLibrary(\"BSDFViewer\")\n    5      BSDFViewer = RenderPass(\"BSDFViewer\")\n    6      g.addPass(BSDFViewer, \"BSDFViewer\")\n\n/home/max/dev/Falcor/src/Mogwai/Data/ForwardRenderer.py:\n    1  def render_graph_forward_renderer():\n    2:     loadRenderPassLibrary(\"Antialiasing\")\n    3:     loadRenderPassLibrary(\"BlitPass\")\n    4:     loadRenderPassLibrary(\"CSM\")\n    5:     loadRenderPassLibrary(\"DepthPass\")\n    6:     loadRenderPassLibrary(\"ForwardLightingPass\")\n    7:     loadRenderPassLibrary(\"SSAO\")\n    8:     loadRenderPassLibrary(\"ToneMapper\")\n    9  \n   10      skyBox = RenderPass(\"SkyBox\")\n\n/home/max/dev/Falcor/src/Mogwai/Data/ForwardRendererAA.py:\n    3  def render_graph_forward_renderer():\n    4      g = RenderGraph(\"forward_renderer\")\n    5:     loadRenderPassLibrary(\"AccumulatePass.rpl\")\n    6:     loadRenderPassLibrary(\"SSAO.rpl\")\n    7:     loadRenderPassLibrary(\"ForwardLightingPass.rpl\")\n    8:     loadRenderPassLibrary(\"SkyBox.rpl\")\n    9:     loadRenderPassLibrary(\"GBuffer.rpl\")\n   10:     loadRenderPassLibrary(\"ToneMapper.rpl\")\n   11:     loadRenderPassLibrary(\"DepthPass.rpl\")\n   12:     loadRenderPassLibrary(\"CSM.rpl\")\n   13:     loadRenderPassLibrary(\"BlitPass.rpl\")\n   14:     loadRenderPassLibrary(\"Antialiasing.rpl\")\n   15      AccumulatePass = RenderPass(\"AccumulatePass\", {'enableAccumulation': True, 'precisionMode': AccumulatePrecision.Single})\n   16      g.addPass(AccumulatePass, \"AccumulatePass\")\n\n/home/max/dev/Falcor/src/Mogwai/Data/PathTracer.py:\n    1  def render_graph_PathTracerGraph():\n    2      g = RenderGraph(\"PathTracerGraph\")\n    3:     loadRenderPassLibrary(\"AccumulatePass.dll\")\n    4:     loadRenderPassLibrary(\"GBuffer.dll\")\n    5:     loadRenderPassLibrary(\"ToneMapper.dll\")\n    6:     loadRenderPassLibrary(\"MegakernelPathTracer.dll\")\n    7      AccumulatePass = RenderPass(\"AccumulatePass\", {'enableAccumulation': True})\n    8      g.addPass(AccumulatePass, \"AccumulatePass\")\n\n/home/max/dev/Falcor/src/Mogwai/Data/VBufferPathTracer.py:\n    1  def render_graph_VBufferPathTracerGraph():\n    2      g = RenderGraph(\"VBufferPathTracerGraph\")\n    3:     loadRenderPassLibrary(\"AccumulatePass.dll\")\n    4:     loadRenderPassLibrary(\"GBuffer.dll\")\n    5:     loadRenderPassLibrary(\"ToneMapper.dll\")\n    6:     loadRenderPassLibrary(\"MegakernelPathTracer.dll\")\n    7      AccumulatePass = RenderPass(\"AccumulatePass\", {'enableAccumulation': True})\n    8      g.addPass(AccumulatePass, \"AccumulatePass\")\n\n/home/max/dev/Falcor/src/RenderPasses/MinimalPathTracer/Data/MinimalPathTracer.py:\n    3  def render_graph_MinimalPathTracer():\n    4      g = RenderGraph(\"MinimalPathTracer\")\n    5:     loadRenderPassLibrary(\"AccumulatePass.dll\")\n    6:     loadRenderPassLibrary(\"GBuffer.dll\")\n    7:     loadRenderPassLibrary(\"MinimalPathTracer.dll\")\n    8:     loadRenderPassLibrary(\"ToneMapper.dll\")\n    9      AccumulatePass = RenderPass(\"AccumulatePass\", {'enableAccumulation': True, 'precisionMode': AccumulatePrecision.Single})\n   10      g.addPass(AccumulatePass, \"AccumulatePass\")\n\n/home/max/dev/Falcor/src/RenderPasses/WhittedRayTracer/Data/WhittedRayTracer_GB_rast.py:\n    3  def render_graph_WhittedRayTracer():\n    4      g = RenderGraph(\"DefaultRenderGraph\")\n    5:     loadRenderPassLibrary(\"GBuffer.dll\")\n    6:     loadRenderPassLibrary(\"WhittedRatTracer.dll\")\n    7:     loadRenderPassLibrary(\"ToneMapper.dll\")\n    8      WhittedRayTracer = RenderPass(\"WhittedRayTracer\", {'mUsingRasterizedGBuffer': True, 'mMaxBounces': 1, 'mComputeDirect': True, 'mUseAnalyticLights': 1, 'mUseEmissiveLights': 1, 'mUseEnvLight': 0, 'mUseEnvBackground': 1})\n    9      g.addPass(WhittedRayTracer, \"WhittedRayTracer\")\n\n/home/max/dev/Falcor/src/RenderPasses/WhittedRayTracer/Data/WhittedRayTracer_GB_ray.py:\n    3  def render_graph_WhittedRayTracer():\n    4      g = RenderGraph(\"DefaultRenderGraph\")\n    5:     loadRenderPassLibrary(\"GBuffer.dll\")\n    6:     loadRenderPassLibrary(\"WhittedRatTracer.dll\")\n    7:     loadRenderPassLibrary(\"ToneMapper.dll\")\n    8      WhittedRayTracer = RenderPass(\"WhittedRayTracer\", {'mUsingRasterizedGBuffer': False, 'mMaxBounces': 2, 'mComputeDirect': True, 'mUseAnalyticLights': 1, 'mUseEmissiveLights': 1, 'mUseEnvLight': 0, 'mUseEnvBackground': 1})\n    9      g.addPass(WhittedRayTracer, \"WhittedRayTracer\")\n\n38 matches across 9 files\n\n\nSearching 1282 files for \"PYBIND11_MODULE\" (case sensitive)\n\n0 matches\n\nSearching 1282 files for \"staticFunc_\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/DeviceManager.cpp:\n   42      auto deviceManagerClass = m.regClass(DeviceManager);\n   43      deviceManagerClass.ctor(&DeviceManager::instance);\n   44:     deviceManagerClass.staticFunc_(\"__new__\", &DeviceManager::instance)\n   45  }\n   46  \n\n/home/max/dev/Falcor/src/Falcor/Utils/Scripting/ScriptBindings.h:\n  133  \n  134      template <typename Func, typename... Extra>\n  135:     Class& staticFunc_(const char* name, Func&& f, const Extra&... extra) {\n  136          pyclass.def_static(name, std::forward<Func>(f), extra...);\n  137          return *this;\n\n2 matches across 2 files\n\n\nSearching 1282 files for \"singleton\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderPassLibrary.h:\n   53          using DescVec = std::vector<RenderPassDesc>;\n   54  \n   55:         /** Get an instance of the library. It's a singleton, you'll always get the same object\n   56          */\n   57          static RenderPassLibrary& instance(std::shared_ptr<Device> pDevice);\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/Public/ShaderLang.h:\n  832      std::list<TShader*> stages[EShLangCount];\n  833      TIntermediate* intermediate[EShLangCount];\n  834:     bool newedIntermediate[EShLangCount];      // track which intermediate were \"new\" versus reusing a singleton unit in a stage\n  835      TInfoSink* infoSink;\n  836      TReflection* reflection;\n\n2 matches across 2 files\n\n\nSearching 1284 files for \"debugReportCallback\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKDevice.cpp:\n  118      DestroyDebugReportCallback = (PFN_vkDestroyDebugReportCallbackEXT)vkGetInstanceProcAddr(mApiHandle, \"vkDestroyDebugReportCallbackEXT\");\n  119      if(DestroyDebugReportCallback) {\n  120:         DestroyDebugReportCallback(mApiHandle, mpApiData->debugReportCallbackHandle, nullptr);\n  121      }\n  122      vkDestroySwapchainKHR(mApiHandle, mpApiData->swapchain, nullptr);\n  ...\n  179  \n  180  #ifdef DEFAULT_ENABLE_DEBUG_LAYER\n  181:     callbackCreateInfo.pfnCallback = &debugReportCallback;\n  182  #endif\n  183  \n  ...\n  238      // Hook up callbacks for VK_EXT_debug_report\n  239      if (enableDebugLayer) {\n  240:         initDebugCallback(instance, &pData->debugReportCallbackHandle);\n  241      }\n  242  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKDevice.h:\n   35  \n   36  #ifdef DEFAULT_ENABLE_DEBUG_LAYER\n   37: VKAPI_ATTR VkBool32 VKAPI_CALL debugReportCallback(\n   38      VkDebugReportFlagsEXT       flags,\n   39      VkDebugReportObjectTypeEXT  objectType,\n   ..\n   69  \n   70      #ifdef DEFAULT_ENABLE_DEBUG_LAYER\n   71:     VkDebugReportCallbackEXT debugReportCallbackHandle;\n   72      #endif\n   73  };\n\n/home/max/dev/Falcor/src/USD/hgiVk/diagnostic.cpp:\n  101      if (!TF_VERIFY(instance->vkDestroyDebugCallbackEXT)) return;\n  102  \n  103:     VkDebugReportCallbackCreateInfoEXT debugReportCallbackCInfo;\n  104:     debugReportCallbackCInfo.sType =\n  105          VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT;\n  106  \n  107:     debugReportCallbackCInfo.pNext = nullptr;\n  108:     debugReportCallbackCInfo.flags =\n  109          VK_DEBUG_REPORT_WARNING_BIT_EXT |\n  110          VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT |\n  111          VK_DEBUG_REPORT_ERROR_BIT_EXT;\n  112:     debugReportCallbackCInfo.pfnCallback = _VulkanDebugCallback;\n  113:     debugReportCallbackCInfo.pUserData = nullptr;\n  114  \n  115      TF_VERIFY(\n  116          instance->vkCreateDebugCallbackEXT(\n  117              vkInstance,\n  118:             &debugReportCallbackCInfo,\n  119              HgiVkAllocator(),\n  120              &instance->vkDebugCallback) == VK_SUCCESS\n\n12 matches across 3 files\n\n\nSearching 1284 files for \"gpFramework\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/Renderer.h:\n  123  };\n  124  \n  125: dlldecl extern IFramework* gpFramework;\n  126  \n  127  class IRenderer {\n\n/home/max/dev/Falcor/src/Falcor/Core/Sample.cpp:\n   42  namespace Falcor {\n   43  \n   44: IFramework* gpFramework = nullptr;\n   45  \n   46  namespace {\n   ..\n  229  \n  230      void Sample::runInternal(const SampleConfig& config, uint32_t argc, char** argv) {\n  231:         gpFramework = this;\n  232  \n  233          Logger::showBoxOnError(config.showMessageBoxOnError);\n  ...\n  337  \n  338          widget.var(\"Screen Resolution\", screenDims);\n  339:         if (widget.dropdown(\"Change Resolution\", dropdownList, currentVal) && (currentVal != 0)) gpFramework->resizeSwapChain(resolutions[currentVal].x, resolutions[currentVal].y);\n  340      }\n  341  \n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightCollection.cpp:\n   73              if (mpScene->getAnimationController()->getMeshAnimationCount(instanceData.meshID) > 0) {\n   74                  bool hasAnimation = mpScene->getAnimationController()->getActiveAnimation(instanceData.meshID) != AnimationController::kBindPoseAnimationId;\n   75:                 bool isPaused = gpFramework->getClock().isPaused();\n   76                  if (hasAnimation && !isPaused) updateFlags |= UpdateFlags::AnimationChanged;\n   77              }\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraph.cpp:\n   47  \n   48  RenderGraph::RenderGraph(std::shared_ptr<Device> pDevice, const std::string& name): mName(name), mpDevice(pDevice) {\n   49:     if (gpFramework == nullptr) {\n   50          throw std::runtime_error(\"Can't construct RenderGraph - framework is not initialized\");\n   51      }\n   ..\n   53      mpPassDictionary = Dictionary::create();\n   54      gRenderGraphs.push_back(this);\n   55:     onResize(gpFramework->getTargetFbo().get());\n   56  }\n   57  \n\n/home/max/dev/Falcor/src/Mogwai/Extensions/Capture/CaptureTrigger.cpp:\n   95          RenderGraph* pGraph = mpRenderer->getActiveGraph();\n   96          if (!pGraph) return;\n   97:         uint64_t frameId = gpFramework->getClock().getFrame();\n   98          if (mGraphRanges.find(pGraph) == mGraphRanges.end()) return;\n   99          const auto& ranges = mGraphRanges.at(pGraph);\n  ...\n  117      void CaptureTrigger::endFrame(RenderContext* pRenderContext, const Fbo::SharedPtr& pTargetFbo) {\n  118          if (!mCurrent.pGraph) return;\n  119:         uint64_t frameId = gpFramework->getClock().getFrame();\n  120          const auto& ranges = mGraphRanges.at(mCurrent.pGraph);\n  121  \n\n/home/max/dev/Falcor/src/Mogwai/Extensions/Capture/FrameCapture.cpp:\n  118              Texture* pTex = pGraph->getOutput(i)->asTexture().get();\n  119              assert(pTex);\n  120:             std::string filename = getOutputNamePrefix(pGraph->getOutputName(i)) + to_string(gpFramework->getClock().getFrame()) + \".\";;\n  121              auto ext = Bitmap::getFileExtFromResourceFormat(pTex->getFormat());\n  122              filename += ext;\n  ...\n  146          auto pGraph = mpRenderer->getActiveGraph();\n  147          if (!pGraph) return;\n  148:         uint64_t frameID = gpFramework->getClock().getFrame();\n  149          triggerFrame(mpRenderer->device()->getRenderContext(), pGraph, frameID);\n  150      }\n\n/home/max/dev/Falcor/src/Mogwai/Extensions/Profiler/TimingCapture.cpp:\n   84  \n   85          // The FrameRate object is updated at the start of each frame, the first valid time is available on the second frame.\n   86:         auto& frameRate = gpFramework->getFrameRate();\n   87          if (frameRate.getFrameCount() > 1)\n   88              mFrameTimeFile << frameRate.getLastFrameTime() << std::endl;\n\n/home/max/dev/Falcor/src/Mogwai/Mogwai.cpp:\n   98  \n   99      // If editor opened from running render graph, get the name of the file to read\n  100:     if (gpFramework->getArgList().argExists(kScriptSwitch)) loadScript(gpFramework->getArgList()[kScriptSwitch].asString());\n  101  }\n  102  \n  ...\n  210  \n  211      if (graphOuts.size()) {\n  212:         uint2 dims(gpFramework->getTargetFbo()->getWidth(), gpFramework->getTargetFbo()->getHeight());\n  213  \n  214          for (size_t i = 0; i < mGraphs[mActiveGraph].debugWindows.size();) {\n  ...\n  407  \n  408      if (mpScene) {\n  409:         const auto& pFbo = gpFramework->getTargetFbo();\n  410          float ratio = static_cast<float>(pFbo->getWidth()) / static_cast<float>(pFbo->getHeight());\n  411          mpScene->setCameraAspectRatio(ratio);\n  ...\n  422  \n  423      for (auto& g : mGraphs) g.pGraph->setScene(mpScene);\n  424:     gpFramework->getClock().setTime(0);\n  425  }\n  426  \n  ...\n  495          // Update scene and camera.\n  496          if (mpScene) {\n  497:             mpScene->update(pRenderContext, gpFramework->getClock().getTime());\n  498          }\n  499  \n  ...\n  530  void Renderer::onResizeSwapChain(uint32_t width, uint32_t height) {\n  531      for (auto& g : mGraphs) {\n  532:         g.pGraph->onResize(gpFramework->getTargetFbo().get());\n  533          Scene::SharedPtr graphScene = g.pGraph->getScene();\n  534          if (graphScene) graphScene->setCameraAspectRatio(static_cast<float>(width) / static_cast<float>(height));\n  ...\n  538  \n  539  void Renderer::onHotReload(HotReloadFlags reloaded) {\n  540:     RenderPassLibrary::instance(mpDevice).reloadLibraries(gpFramework->getRenderContext());\n  541      RenderGraph* pActiveGraph = getActiveGraph();\n  542      if (pActiveGraph) pActiveGraph->onHotReload(reloaded);\n\n/home/max/dev/Falcor/src/Mogwai/MogwaiScripting.cpp:\n   69  std::string windowConfig() {\n   70      std::string s;\n   71:     SampleConfig c = gpFramework->getConfig();\n   72      s += \"# Window Configuration\\n\";\n   73      s += Scripting::makeMemberFunc(kRendererVar, kResizeSwapChain, c.windowDesc.width, c.windowDesc.height);\n   ..\n  105  \n  106      s += \"# Time Settings\\n\";\n  107:     s += gpFramework->getClock().getScript(kTimeVar) + \"\\n\";\n  108  \n  109      for (auto& pe : mpExtensions) {\n  ...\n  132      c.roProperty(kActiveGraph.c_str(), &Renderer::getActiveGraph);\n  133  \n  134:     auto getUI = [](Renderer* pRenderer) { return gpFramework->isUiEnabled(); };\n  135:     auto setUI = [](Renderer* pRenderer, bool show) { gpFramework->toggleUI(show); };\n  136      c.property(kUI.c_str(), getUI, setUI);\n  137  \n  138      Extension::Bindings b(m, c);\n  139      b.addGlobalObject(kRendererVar, this, \"The engine\");\n  140:     b.addGlobalObject(kTimeVar, &gpFramework->getClock(), \"Time Utilities\");\n  141      for (auto& pe : mpExtensions) pe->scriptBindings(b);\n  142      mGlobalHelpMessage = prepareHelpMessage(b.mGlobalObjects);\n  ...\n  154  \n  155      // PYTHONDEPRECATED Use the global function defined in the script bindings in Sample.cpp when resizing from a Python script.\n  156:     auto resize = [](Renderer* pRenderer, uint32_t width, uint32_t height) {gpFramework->resizeSwapChain(width, height); };\n  157      c.func_(kResizeSwapChain.c_str(), resize);\n  158  }\n\n/home/max/dev/Falcor/src/Mogwai/MogwaiSettings.cpp:\n   44      s += \" 'F10'  - Show/Hide the FPS\\n\";\n   45      s += \" 'F11'  - Toggle Main Menu Auto-Hide\\n\";\n   46:     s += \"\\n\" + gpFramework->getKeyboardShortcutsStr();\n   47      msgBox(s);\n   48  }\n   ..\n   57  void showFps(Gui* pGui) {\n   58      Gui::Window w(pGui, \"##FPS\", { 0, 0 }, { 10, 25 }, Gui::WindowFlags::AllowMove | Gui::WindowFlags::AutoResize | Gui::WindowFlags::SetFocus);\n   59:     std::string msg = gpFramework->getFrameRate().getMsg(gpFramework->isVsyncEnabled());\n   60      w.text(msg);\n   61  }\n   ..\n   88      };\n   89  \n   90:     uint2 currentRes = gpFramework->getWindow()->getClientAreaSize();\n   91      static const Gui::DropdownList dropdownList = initDropDown(resolutions, arraysize(resolutions));\n   92      uint32_t currentVal = initDropDownVal(resolutions, arraysize(resolutions), currentRes);\n   ..\n  103          } else {\n  104              customSize = {};\n  105:             gpFramework->resizeSwapChain(resolutions[currentVal].x, resolutions[currentVal].y);\n  106          }\n  107      }\n  ...\n  112          w.var(\"##custres\", customSize);\n  113          if (w.button(\"Apply##custres\", true)) {\n  114:             gpFramework->resizeSwapChain(customSize.x, customSize.y);\n  115              forceCustom = false;\n  116          }\n  ...\n  132      Gui::Window w(pGui, \"Time\", mShowTime, { 0, 0 }, { 350, 25 }, Gui::WindowFlags::AllowMove | Gui::WindowFlags::AutoResize | Gui::WindowFlags::ShowTitleBar | Gui::WindowFlags::CloseButton);\n  133  \n  134:     Clock& clock = gpFramework->getClock();\n  135      clock.renderUI(w);\n  136      w.separator(2);\n  ...\n  194          file.separator();\n  195          if (file.item(\"Reload Render-Passes\", \"F5\")) {\n  196:             RenderPassLibrary::instance(mpRenderer->device()).reloadLibraries(gpFramework->getRenderContext());\n  197          }\n  198  \n\n/home/max/dev/Falcor/src/RenderPasses/BSDFViewer/BSDFViewer.cpp:\n  298              if (openFileDialog(filters, filename)) {\n  299                  // TODO: RenderContext* should maybe be a parameter to renderUI()?\n  300:                 auto pRenderContext = gpFramework->getRenderContext();\n  301                  if (loadEnvMap(pRenderContext, filename)) {\n  302                      mParams.useDirectionalLight = false;\n\n/home/max/dev/Falcor/src/RenderPasses/DebugPasses/SplitScreenPass/SplitScreenPass.cpp:\n   59  SplitScreenPass::SplitScreenPass(Device::SharedPtr pDevice): ComparisonPass(pDevice), mClock(pDevice) {\n   60      mpArrowTex = Texture::create2D(pDevice, 16, 16, ResourceFormat::R8Unorm, 1, Texture::kMaxPossible, kArrowArray);\n   61:     mClock = gpFramework->getClock();\n   62      createProgram();\n   63  }\n\n/home/max/dev/Falcor/src/Samples/HelloDXR/HelloDXR.cpp:\n   49          if (openFileDialog(Scene::kFileExtensionFilters, filename))\n   50          {\n   51:             loadScene(filename, gpFramework->getTargetFbo().get());\n   52          }\n   53      }\n   ..\n   92      }\n   93  \n   94:     loadScene(kDefaultScene, gpFramework->getTargetFbo().get());\n   95  }\n   96  \n   ..\n  124      if(mpScene)\n  125      {\n  126:         mpScene->update(pRenderContext, gpFramework->getGlobalClock().getTime());\n  127          if (mRayTrace) renderRT(pRenderContext, pTargetFbo.get());\n  128          else mpRasterPass->renderScene(pRenderContext, pTargetFbo);\n  129      }\n  130  \n  131:     TextRenderer::render(pRenderContext, gpFramework->getFrameRate().getMsg(), pTargetFbo, { 20, 20 });\n  132  }\n  133  \n\n/home/max/dev/Falcor/src/Samples/ModelViewer/ModelViewer.cpp:\n   88      // Load model group\n   89      if (w.button(\"Load Model\")) {\n   90:         loadModel(gpFramework->getTargetFbo()->getColorTexture(0)->getFormat());\n   91      }\n   92  \n   ..\n  165  \n  166      if(mpScene) {\n  167:         mpScene->update(pRenderContext, gpFramework->getGlobalClock().getTime());\n  168  \n  169          // Set render state\n\n/home/max/dev/Falcor/src/Samples/ProjectTemplate/ProjectTemplate.cpp:\n   35  {\n   36      Gui::Window w(pGui, \"Falcor\", { 250, 200 });\n   37:     gpFramework->renderGlobalUI(pGui);\n   38      w.text(\"Hello from ProjectTemplate\");\n   39      if (w.button(\"Click Here\"))\n\n/home/max/dev/Falcor/src/Samples/ShaderToy/ShaderToy.cpp:\n   58      float height = (float)pTargetFbo->getHeight();\n   59      mpMainPass[\"ToyCB\"][\"iResolution\"] = float2(width, height);\n   60:     mpMainPass[\"ToyCB\"][\"iGlobalTime\"] = (float)gpFramework->getGlobalClock().getTime();\n   61  \n   62      // run final pass\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/FalcorTest.cpp:\n   55  void FalcorTest::onFrameRender(RenderContext* pRenderContext, const Fbo::SharedPtr& pTargetFbo) {\n   56      const char* kTestFilterSwitch = \"test_filter\";\n   57:     ArgList argList = gpFramework->getArgList();\n   58      std::string testFilterRegex;\n   59      \n   ..\n   72          sReturnCode = runTests(std::cout, pRenderContext, testFilterRegex);\n   73      }\n   74:     gpFramework->shutdown();\n   75  }\n   76  \n\n/home/max/dev/Falcor/src/Tools/RenderGraphEditor/RenderGraphEditor.cpp:\n   71  \n   72  void RenderGraphEditor::onLoad(RenderContext* pRenderContext) {\n   73:     const auto& argList = gpFramework->getArgList();\n   74      std::string filePath;\n   75      if (argList.argExists(kGraphFileSwitch)) {\n   ..\n  154  // some of this will need to be moved to render graph ui\n  155  void RenderGraphEditor::onGuiRender(Gui* pGui) {\n  156:     RenderContext* pRenderContext = gpFramework->getRenderContext();\n  157  \n  158      uint32_t screenHeight = mWindowSize.y;\n  ...\n  265  \n  266      if (mUpdateFilePath.size()) {\n  267:         mRenderGraphUIs[mCurrentGraphIndex].writeUpdateScriptToFile(pRenderContext, mUpdateFilePath, (float)gpFramework->getFrameRate().getLastFrameTime());\n  268      }\n  269  \n  ...\n  480  \n  481  void RenderGraphEditor::onResizeSwapChain(uint32_t width, uint32_t height) {\n  482:     for(auto pG : mpGraphs) pG->onResize(gpFramework->getTargetFbo().get());\n  483      mWindowSize = {width, height};\n  484      mResetGuiWindows = true;\n\n51 matches across 18 files\n\n\nSearching 1284 files for \"gpFramework\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/Renderer.h:\n  123  };\n  124  \n  125: dlldecl extern IFramework* gpFramework;\n  126  \n  127  class IRenderer {\n\n/home/max/dev/Falcor/src/Falcor/Core/Sample.cpp:\n   42  namespace Falcor {\n   43  \n   44: IFramework* gpFramework = nullptr;\n   45  \n   46  namespace {\n   ..\n  229  \n  230      void Sample::runInternal(const SampleConfig& config, uint32_t argc, char** argv) {\n  231:         gpFramework = this;\n  232  \n  233          Logger::showBoxOnError(config.showMessageBoxOnError);\n  ...\n  337  \n  338          widget.var(\"Screen Resolution\", screenDims);\n  339:         if (widget.dropdown(\"Change Resolution\", dropdownList, currentVal) && (currentVal != 0)) gpFramework->resizeSwapChain(resolutions[currentVal].x, resolutions[currentVal].y);\n  340      }\n  341  \n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightCollection.cpp:\n   73              if (mpScene->getAnimationController()->getMeshAnimationCount(instanceData.meshID) > 0) {\n   74                  bool hasAnimation = mpScene->getAnimationController()->getActiveAnimation(instanceData.meshID) != AnimationController::kBindPoseAnimationId;\n   75:                 bool isPaused = gpFramework->getClock().isPaused();\n   76                  if (hasAnimation && !isPaused) updateFlags |= UpdateFlags::AnimationChanged;\n   77              }\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraph.cpp:\n   47  \n   48  RenderGraph::RenderGraph(std::shared_ptr<Device> pDevice, const std::string& name): mName(name), mpDevice(pDevice) {\n   49:     if (gpFramework == nullptr) {\n   50          throw std::runtime_error(\"Can't construct RenderGraph - framework is not initialized\");\n   51      }\n   ..\n   53      mpPassDictionary = Dictionary::create();\n   54      gRenderGraphs.push_back(this);\n   55:     onResize(gpFramework->getTargetFbo().get());\n   56  }\n   57  \n\n/home/max/dev/Falcor/src/Mogwai/Extensions/Capture/CaptureTrigger.cpp:\n   95          RenderGraph* pGraph = mpRenderer->getActiveGraph();\n   96          if (!pGraph) return;\n   97:         uint64_t frameId = gpFramework->getClock().getFrame();\n   98          if (mGraphRanges.find(pGraph) == mGraphRanges.end()) return;\n   99          const auto& ranges = mGraphRanges.at(pGraph);\n  ...\n  117      void CaptureTrigger::endFrame(RenderContext* pRenderContext, const Fbo::SharedPtr& pTargetFbo) {\n  118          if (!mCurrent.pGraph) return;\n  119:         uint64_t frameId = gpFramework->getClock().getFrame();\n  120          const auto& ranges = mGraphRanges.at(mCurrent.pGraph);\n  121  \n\n/home/max/dev/Falcor/src/Mogwai/Extensions/Capture/FrameCapture.cpp:\n  118              Texture* pTex = pGraph->getOutput(i)->asTexture().get();\n  119              assert(pTex);\n  120:             std::string filename = getOutputNamePrefix(pGraph->getOutputName(i)) + to_string(gpFramework->getClock().getFrame()) + \".\";;\n  121              auto ext = Bitmap::getFileExtFromResourceFormat(pTex->getFormat());\n  122              filename += ext;\n  ...\n  146          auto pGraph = mpRenderer->getActiveGraph();\n  147          if (!pGraph) return;\n  148:         uint64_t frameID = gpFramework->getClock().getFrame();\n  149          triggerFrame(mpRenderer->device()->getRenderContext(), pGraph, frameID);\n  150      }\n\n/home/max/dev/Falcor/src/Mogwai/Extensions/Profiler/TimingCapture.cpp:\n   84  \n   85          // The FrameRate object is updated at the start of each frame, the first valid time is available on the second frame.\n   86:         auto& frameRate = gpFramework->getFrameRate();\n   87          if (frameRate.getFrameCount() > 1)\n   88              mFrameTimeFile << frameRate.getLastFrameTime() << std::endl;\n\n/home/max/dev/Falcor/src/Mogwai/Mogwai.cpp:\n   98  \n   99      // If editor opened from running render graph, get the name of the file to read\n  100:     if (gpFramework->getArgList().argExists(kScriptSwitch)) loadScript(gpFramework->getArgList()[kScriptSwitch].asString());\n  101  }\n  102  \n  ...\n  210  \n  211      if (graphOuts.size()) {\n  212:         uint2 dims(gpFramework->getTargetFbo()->getWidth(), gpFramework->getTargetFbo()->getHeight());\n  213  \n  214          for (size_t i = 0; i < mGraphs[mActiveGraph].debugWindows.size();) {\n  ...\n  407  \n  408      if (mpScene) {\n  409:         const auto& pFbo = gpFramework->getTargetFbo();\n  410          float ratio = static_cast<float>(pFbo->getWidth()) / static_cast<float>(pFbo->getHeight());\n  411          mpScene->setCameraAspectRatio(ratio);\n  ...\n  422  \n  423      for (auto& g : mGraphs) g.pGraph->setScene(mpScene);\n  424:     gpFramework->getClock().setTime(0);\n  425  }\n  426  \n  ...\n  495          // Update scene and camera.\n  496          if (mpScene) {\n  497:             mpScene->update(pRenderContext, gpFramework->getClock().getTime());\n  498          }\n  499  \n  ...\n  530  void Renderer::onResizeSwapChain(uint32_t width, uint32_t height) {\n  531      for (auto& g : mGraphs) {\n  532:         g.pGraph->onResize(gpFramework->getTargetFbo().get());\n  533          Scene::SharedPtr graphScene = g.pGraph->getScene();\n  534          if (graphScene) graphScene->setCameraAspectRatio(static_cast<float>(width) / static_cast<float>(height));\n  ...\n  538  \n  539  void Renderer::onHotReload(HotReloadFlags reloaded) {\n  540:     RenderPassLibrary::instance(mpDevice).reloadLibraries(gpFramework->getRenderContext());\n  541      RenderGraph* pActiveGraph = getActiveGraph();\n  542      if (pActiveGraph) pActiveGraph->onHotReload(reloaded);\n\n/home/max/dev/Falcor/src/Mogwai/MogwaiScripting.cpp:\n   69  std::string windowConfig() {\n   70      std::string s;\n   71:     SampleConfig c = gpFramework->getConfig();\n   72      s += \"# Window Configuration\\n\";\n   73      s += Scripting::makeMemberFunc(kRendererVar, kResizeSwapChain, c.windowDesc.width, c.windowDesc.height);\n   ..\n  105  \n  106      s += \"# Time Settings\\n\";\n  107:     s += gpFramework->getClock().getScript(kTimeVar) + \"\\n\";\n  108  \n  109      for (auto& pe : mpExtensions) {\n  ...\n  132      c.roProperty(kActiveGraph.c_str(), &Renderer::getActiveGraph);\n  133  \n  134:     auto getUI = [](Renderer* pRenderer) { return gpFramework->isUiEnabled(); };\n  135:     auto setUI = [](Renderer* pRenderer, bool show) { gpFramework->toggleUI(show); };\n  136      c.property(kUI.c_str(), getUI, setUI);\n  137  \n  138      Extension::Bindings b(m, c);\n  139      b.addGlobalObject(kRendererVar, this, \"The engine\");\n  140:     b.addGlobalObject(kTimeVar, &gpFramework->getClock(), \"Time Utilities\");\n  141      for (auto& pe : mpExtensions) pe->scriptBindings(b);\n  142      mGlobalHelpMessage = prepareHelpMessage(b.mGlobalObjects);\n  ...\n  154  \n  155      // PYTHONDEPRECATED Use the global function defined in the script bindings in Sample.cpp when resizing from a Python script.\n  156:     auto resize = [](Renderer* pRenderer, uint32_t width, uint32_t height) {gpFramework->resizeSwapChain(width, height); };\n  157      c.func_(kResizeSwapChain.c_str(), resize);\n  158  }\n\n/home/max/dev/Falcor/src/Mogwai/MogwaiSettings.cpp:\n   44      s += \" 'F10'  - Show/Hide the FPS\\n\";\n   45      s += \" 'F11'  - Toggle Main Menu Auto-Hide\\n\";\n   46:     s += \"\\n\" + gpFramework->getKeyboardShortcutsStr();\n   47      msgBox(s);\n   48  }\n   ..\n   57  void showFps(Gui* pGui) {\n   58      Gui::Window w(pGui, \"##FPS\", { 0, 0 }, { 10, 25 }, Gui::WindowFlags::AllowMove | Gui::WindowFlags::AutoResize | Gui::WindowFlags::SetFocus);\n   59:     std::string msg = gpFramework->getFrameRate().getMsg(gpFramework->isVsyncEnabled());\n   60      w.text(msg);\n   61  }\n   ..\n   88      };\n   89  \n   90:     uint2 currentRes = gpFramework->getWindow()->getClientAreaSize();\n   91      static const Gui::DropdownList dropdownList = initDropDown(resolutions, arraysize(resolutions));\n   92      uint32_t currentVal = initDropDownVal(resolutions, arraysize(resolutions), currentRes);\n   ..\n  103          } else {\n  104              customSize = {};\n  105:             gpFramework->resizeSwapChain(resolutions[currentVal].x, resolutions[currentVal].y);\n  106          }\n  107      }\n  ...\n  112          w.var(\"##custres\", customSize);\n  113          if (w.button(\"Apply##custres\", true)) {\n  114:             gpFramework->resizeSwapChain(customSize.x, customSize.y);\n  115              forceCustom = false;\n  116          }\n  ...\n  132      Gui::Window w(pGui, \"Time\", mShowTime, { 0, 0 }, { 350, 25 }, Gui::WindowFlags::AllowMove | Gui::WindowFlags::AutoResize | Gui::WindowFlags::ShowTitleBar | Gui::WindowFlags::CloseButton);\n  133  \n  134:     Clock& clock = gpFramework->getClock();\n  135      clock.renderUI(w);\n  136      w.separator(2);\n  ...\n  194          file.separator();\n  195          if (file.item(\"Reload Render-Passes\", \"F5\")) {\n  196:             RenderPassLibrary::instance(mpRenderer->device()).reloadLibraries(gpFramework->getRenderContext());\n  197          }\n  198  \n\n/home/max/dev/Falcor/src/RenderPasses/BSDFViewer/BSDFViewer.cpp:\n  298              if (openFileDialog(filters, filename)) {\n  299                  // TODO: RenderContext* should maybe be a parameter to renderUI()?\n  300:                 auto pRenderContext = gpFramework->getRenderContext();\n  301                  if (loadEnvMap(pRenderContext, filename)) {\n  302                      mParams.useDirectionalLight = false;\n\n/home/max/dev/Falcor/src/RenderPasses/DebugPasses/SplitScreenPass/SplitScreenPass.cpp:\n   59  SplitScreenPass::SplitScreenPass(Device::SharedPtr pDevice): ComparisonPass(pDevice), mClock(pDevice) {\n   60      mpArrowTex = Texture::create2D(pDevice, 16, 16, ResourceFormat::R8Unorm, 1, Texture::kMaxPossible, kArrowArray);\n   61:     mClock = gpFramework->getClock();\n   62      createProgram();\n   63  }\n\n/home/max/dev/Falcor/src/Samples/HelloDXR/HelloDXR.cpp:\n   49          if (openFileDialog(Scene::kFileExtensionFilters, filename))\n   50          {\n   51:             loadScene(filename, gpFramework->getTargetFbo().get());\n   52          }\n   53      }\n   ..\n   92      }\n   93  \n   94:     loadScene(kDefaultScene, gpFramework->getTargetFbo().get());\n   95  }\n   96  \n   ..\n  124      if(mpScene)\n  125      {\n  126:         mpScene->update(pRenderContext, gpFramework->getGlobalClock().getTime());\n  127          if (mRayTrace) renderRT(pRenderContext, pTargetFbo.get());\n  128          else mpRasterPass->renderScene(pRenderContext, pTargetFbo);\n  129      }\n  130  \n  131:     TextRenderer::render(pRenderContext, gpFramework->getFrameRate().getMsg(), pTargetFbo, { 20, 20 });\n  132  }\n  133  \n\n/home/max/dev/Falcor/src/Samples/ModelViewer/ModelViewer.cpp:\n   88      // Load model group\n   89      if (w.button(\"Load Model\")) {\n   90:         loadModel(gpFramework->getTargetFbo()->getColorTexture(0)->getFormat());\n   91      }\n   92  \n   ..\n  165  \n  166      if(mpScene) {\n  167:         mpScene->update(pRenderContext, gpFramework->getGlobalClock().getTime());\n  168  \n  169          // Set render state\n\n/home/max/dev/Falcor/src/Samples/ProjectTemplate/ProjectTemplate.cpp:\n   35  {\n   36      Gui::Window w(pGui, \"Falcor\", { 250, 200 });\n   37:     gpFramework->renderGlobalUI(pGui);\n   38      w.text(\"Hello from ProjectTemplate\");\n   39      if (w.button(\"Click Here\"))\n\n/home/max/dev/Falcor/src/Samples/ShaderToy/ShaderToy.cpp:\n   58      float height = (float)pTargetFbo->getHeight();\n   59      mpMainPass[\"ToyCB\"][\"iResolution\"] = float2(width, height);\n   60:     mpMainPass[\"ToyCB\"][\"iGlobalTime\"] = (float)gpFramework->getGlobalClock().getTime();\n   61  \n   62      // run final pass\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/FalcorTest.cpp:\n   55  void FalcorTest::onFrameRender(RenderContext* pRenderContext, const Fbo::SharedPtr& pTargetFbo) {\n   56      const char* kTestFilterSwitch = \"test_filter\";\n   57:     ArgList argList = gpFramework->getArgList();\n   58      std::string testFilterRegex;\n   59      \n   ..\n   72          sReturnCode = runTests(std::cout, pRenderContext, testFilterRegex);\n   73      }\n   74:     gpFramework->shutdown();\n   75  }\n   76  \n\n/home/max/dev/Falcor/src/Tools/RenderGraphEditor/RenderGraphEditor.cpp:\n   71  \n   72  void RenderGraphEditor::onLoad(RenderContext* pRenderContext) {\n   73:     const auto& argList = gpFramework->getArgList();\n   74      std::string filePath;\n   75      if (argList.argExists(kGraphFileSwitch)) {\n   ..\n  154  // some of this will need to be moved to render graph ui\n  155  void RenderGraphEditor::onGuiRender(Gui* pGui) {\n  156:     RenderContext* pRenderContext = gpFramework->getRenderContext();\n  157  \n  158      uint32_t screenHeight = mWindowSize.y;\n  ...\n  265  \n  266      if (mUpdateFilePath.size()) {\n  267:         mRenderGraphUIs[mCurrentGraphIndex].writeUpdateScriptToFile(pRenderContext, mUpdateFilePath, (float)gpFramework->getFrameRate().getLastFrameTime());\n  268      }\n  269  \n  ...\n  480  \n  481  void RenderGraphEditor::onResizeSwapChain(uint32_t width, uint32_t height) {\n  482:     for(auto pG : mpGraphs) pG->onResize(gpFramework->getTargetFbo().get());\n  483      mWindowSize = {width, height};\n  484      mResetGuiWindows = true;\n\n51 matches across 18 files\n\n\nSearching 1284 files for \"mGraphs\" (case sensitive)\n\n/home/max/dev/Falcor/src/Mogwai/Mogwai.cpp:\n   84      resetEditor();\n   85      mpDevice->flushAndSync(); // Need to do that because clearing the graphs will try to release some state objects which might be in use\n   86:     mGraphs.clear();\n   87  }\n   88  \n   ..\n  102  \n  103  RenderGraph* Renderer::getActiveGraph() const {\n  104:     return mGraphs.size() ? mGraphs[mActiveGraph].pGraph.get() : nullptr;\n  105  }\n  106  \n  ...\n  122      DebugWindow window;\n  123      window.windowName = \"Debug Window \" + std::to_string(DebugWindow::index++);\n  124:     window.currentOutput = mGraphs[mActiveGraph].mainOutput;\n  125      markOutput(window.currentOutput);\n  126:     mGraphs[mActiveGraph].debugWindows.push_back(window);\n  127  }\n  128  \n  129  void Renderer::unmarkOutput(const std::string& name) {\n  130:     auto& graphData = mGraphs[mActiveGraph];\n  131      // Skip the original outputs\n  132      if (isInVector(graphData.originalOutputs, name)) return;\n  ...\n  142  \n  143  void Renderer::markOutput(const std::string& name) {\n  144:     auto& graphData = mGraphs[mActiveGraph];\n  145      // Skip the original outputs\n  146      if (isInVector(graphData.originalOutputs, name)) return;\n  147:     auto& refVec = mGraphs[mActiveGraph].graphOutputRefs;\n  148      refVec[name]++;\n  149:     if (refVec[name] == 1) mGraphs[mActiveGraph].pGraph->markOutput(name);\n  150  }\n  151  \n  ...\n  173  bool Renderer::renderDebugWindow(Gui::Widgets& widget, const Gui::DropdownList& dropdown, DebugWindow& data, const uint2& winSize) {\n  174      // Get the current output, in case `renderOutputUI()` unmarks it\n  175:     Texture::SharedPtr pTex = std::dynamic_pointer_cast<Texture>(mGraphs[mActiveGraph].pGraph->getOutput(data.currentOutput));\n  176:     std::string label = data.currentOutput + \"##\" + mGraphs[mActiveGraph].pGraph->getName();\n  177      if (!pTex) { logError(\"Invalid output resource. Is not a texture.\"); }\n  178  \n  ...\n  196  \n  197  void Renderer::eraseDebugWindow(size_t id) {\n  198:     unmarkOutput(mGraphs[mActiveGraph].debugWindows[id].currentOutput);\n  199:     mGraphs[mActiveGraph].debugWindows.erase(mGraphs[mActiveGraph].debugWindows.begin() + id);\n  200  }\n  201  \n  202  void Renderer::graphOutputsGui(Gui::Widgets& widget) {\n  203:     RenderGraph::SharedPtr pGraph = mGraphs[mActiveGraph].pGraph;\n  204:     if (mGraphs[mActiveGraph].debugWindows.size()) mGraphs[mActiveGraph].showAllOutputs = true;\n  205:     auto strVec = mGraphs[mActiveGraph].showAllOutputs ? pGraph->getAvailableOutputs() : mGraphs[mActiveGraph].originalOutputs;\n  206:     Gui::DropdownList graphOuts = createDropdownFromVec(strVec, mGraphs[mActiveGraph].mainOutput);\n  207  \n  208:     widget.checkbox(\"List All Outputs\", mGraphs[mActiveGraph].showAllOutputs);\n  209      widget.tooltip(\"Display every possible output in the render-graph, even if it wasn't explicitly marked as one. If there's a debug window open, you won't be able to uncheck this\");\n  210  \n  ...\n  212          uint2 dims(gpFramework->getTargetFbo()->getWidth(), gpFramework->getTargetFbo()->getHeight());\n  213  \n  214:         for (size_t i = 0; i < mGraphs[mActiveGraph].debugWindows.size();) {\n  215:             if (renderDebugWindow(widget, graphOuts, mGraphs[mActiveGraph].debugWindows[i], dims) == false) {\n  216                  eraseDebugWindow(i);\n  217              } else {\n  ...\n  220          }\n  221  \n  222:         renderOutputUI(widget, graphOuts, mGraphs[mActiveGraph].mainOutput);\n  223  \n  224          // Render the debug windows *before* adding/removing debug windows\n  225          if (widget.button(\"Show In Debug Window\")) addDebugWindow();\n  226:         if (mGraphs[mActiveGraph].debugWindows.size()) {\n  227              if (widget.button(\"Close all debug windows\")) {\n  228:                 while (mGraphs[mActiveGraph].debugWindows.size()) eraseDebugWindow(0);\n  229              }\n  230          }\n  ...\n  250  \n  251  void Renderer::openEditor() {\n  252:     bool unmarkOut = (isInVector(mGraphs[mActiveGraph].originalOutputs, mGraphs[mActiveGraph].mainOutput) == false);\n  253      // If the current graph output is not an original output, unmark it\n  254:     if (unmarkOut) mGraphs[mActiveGraph].pGraph->unmarkOutput(mGraphs[mActiveGraph].mainOutput);\n  255  \n  256      mEditorTempFile = getTempFilename();\n  257  \n  258      // Save the graph\n  259:     RenderGraphExporter::save(mGraphs[mActiveGraph].pGraph, mEditorTempFile);\n  260  \n  261      // Register an update callback\n  ...\n  264      // Run the process\n  265      std::string commandLineArgs = '-' + std::string(kEditorSwitch) + \" -\" + std::string(kGraphFileSwitch);\n  266:     commandLineArgs += ' ' + mEditorTempFile + \" -\" + std::string(kGraphNameSwitch) + ' ' + mGraphs[mActiveGraph].pGraph->getName();\n  267      mEditorProcess = executeProcess(kEditorExecutableName, commandLineArgs);\n  268  \n  269      // Mark the output if it's required\n  270:     if (unmarkOut) mGraphs[mActiveGraph].pGraph->markOutput(mGraphs[mActiveGraph].mainOutput);\n  271  }\n  272  \n  ...\n  296      for (auto& e : mpExtensions) e->removeGraph(pGraph.get());\n  297      size_t i = 0;\n  298:     for (; i < mGraphs.size(); i++) {\n  299:         if (mGraphs[i].pGraph == pGraph) break;\n  300      }\n  301:     assert(i < mGraphs.size());\n  302:     mGraphs.erase(mGraphs.begin() + i);\n  303      if (mActiveGraph >= i && mActiveGraph > 0) mActiveGraph--;\n  304      setActiveGraph(mActiveGraph);\n  ...\n  315  \n  316  RenderGraph::SharedPtr Renderer::getGraph(const std::string& graphName) const {\n  317:     for (const auto& g : mGraphs) {\n  318          if (g.pGraph->getName() == graphName) return g.pGraph;\n  319      }\n  ...\n  322  \n  323  void Renderer::removeActiveGraph() {\n  324:     if (mGraphs.size()) removeGraph(mGraphs[mActiveGraph].pGraph);\n  325  }\n  326  \n  ...\n  333  void Renderer::initGraph(const RenderGraph::SharedPtr& pGraph, GraphData* pData) {\n  334      if (!pData) {\n  335:         mGraphs.push_back({});\n  336:         pData = &mGraphs.back();\n  337      }\n  338  \n  ...\n  381      // If a graph with the same name already exists, remove it\n  382      GraphData* pGraphData = nullptr;\n  383:     for (size_t i = 0; i < mGraphs.size(); i++) {\n  384:         if (mGraphs[i].pGraph->getName() == pGraph->getName()) {\n  385              logWarning(\"Replacing existing graph `\" + pGraph->getName() + \"` with new graph.\");\n  386:             pGraphData = &mGraphs[i];\n  387              break;\n  388          }\n  ...\n  422      }\n  423  \n  424:     for (auto& g : mGraphs) g.pGraph->setScene(mpScene);\n  425      gpFramework->getClock().setTime(0);\n  426  }\n  ...\n  438  \n  439      // Unmark the current output if it wasn't originally marked\n  440:     auto pActiveGraph = mGraphs[mActiveGraph].pGraph;\n  441:     bool hasUnmarkedOut = (isInVector(mGraphs[mActiveGraph].originalOutputs, mGraphs[mActiveGraph].mainOutput) == false);\n  442:     if (hasUnmarkedOut) pActiveGraph->unmarkOutput(mGraphs[mActiveGraph].mainOutput);\n  443  \n  444      // Run the scripting\n  ...\n  447  \n  448      // Update the list of marked outputs\n  449:     mGraphs[mActiveGraph].originalOutputs = getGraphOutputs(pActiveGraph);\n  450  \n  451      // If the output before the update was not initially marked but still exists, re-mark it.\n  452      // If it no longer exists, mark a new output from the list of currently marked outputs.\n  453:     if (hasUnmarkedOut && isInVector(pActiveGraph->getAvailableOutputs(), mGraphs[mActiveGraph].mainOutput)) {\n  454:         pActiveGraph->markOutput(mGraphs[mActiveGraph].mainOutput);\n  455:     } else if (isInVector(mGraphs[mActiveGraph].originalOutputs, mGraphs[mActiveGraph].mainOutput) == false) {\n  456:         mGraphs[mActiveGraph].mainOutput = mGraphs[mActiveGraph].originalOutputs[0];\n  457      }\n  458  \n  ...\n  461  \n  462  void Renderer::executeActiveGraph(RenderContext* pRenderContext) {\n  463:     if (mGraphs.empty()) return;\n  464:     auto& pGraph = mGraphs[mActiveGraph].pGraph;\n  465  \n  466      // Execute graph.\n  ...\n  491      pRenderContext->clearFbo(pTargetFbo.get(), clearColor, 1.0f, 0, FboAttachmentType::All);\n  492  \n  493:     if (mGraphs.size()) {\n  494:         auto& pGraph = mGraphs[mActiveGraph].pGraph;\n  495  \n  496          // Update scene and camera.\n  ...\n  502  \n  503          // Blit main graph output to frame buffer.\n  504:         if (mGraphs[mActiveGraph].mainOutput.size()) {\n  505:             Texture::SharedPtr pOutTex = std::dynamic_pointer_cast<Texture>(pGraph->getOutput(mGraphs[mActiveGraph].mainOutput));\n  506              assert(pOutTex);\n  507              pRenderContext->blit(pOutTex->getSRV(), pTargetFbo->getRenderTargetView(0));\n  ...\n  517      }\n  518  \n  519:     if (mGraphs.size()) mGraphs[mActiveGraph].pGraph->onMouseEvent(mouseEvent);\n  520      return mpScene ? mpScene->onMouseEvent(mouseEvent) : false;\n  521  }\n  ...\n  525          if (pe->keyboardEvent(keyEvent)) return true;\n  526      }\n  527:     if (mGraphs.size()) mGraphs[mActiveGraph].pGraph->onKeyEvent(keyEvent);\n  528      return mpScene ? mpScene->onKeyEvent(keyEvent) : false;\n  529  }\n  530  \n  531  void Renderer::onResizeSwapChain(uint32_t width, uint32_t height) {\n  532:     for (auto& g : mGraphs) {\n  533          g.pGraph->onResize(gpFramework->getTargetFbo().get());\n  534          Scene::SharedPtr graphScene = g.pGraph->getScene();\n  ...\n  545  \n  546  size_t Renderer::findGraph(std::string_view name) {\n  547:     for (size_t i = 0; i < mGraphs.size(); i++) {\n  548:         if (mGraphs[i].pGraph->getName() == name) return i;\n  549      }\n  550      return -1;\n\n/home/max/dev/Falcor/src/Mogwai/Mogwai.h:\n  171      AppData mAppData;\n  172  \n  173:     std::vector<GraphData> mGraphs;\n  174      uint32_t mActiveGraph = 0;\n  175      Sampler::SharedPtr mpSampler = nullptr;\n\n/home/max/dev/Falcor/src/Mogwai/MogwaiScripting.cpp:\n   85      std::string s;\n   86  \n   87:     if (!mGraphs.empty()) {\n   88          s += \"# Graphs\\n\";\n   89:         for (const auto& g : mGraphs) {\n   90              s += RenderGraphExporter::getIR(g.pGraph);\n   91              s += kRendererVar + \".\" + kAddGraph + \"(\" + RenderGraphIR::getFuncName(g.pGraph->getName()) + \"())\\n\";\n\n/home/max/dev/Falcor/src/Mogwai/MogwaiSettings.cpp:\n  149  \n  150  void MogwaiSettings::graphs(Gui* pGui) {\n  151:     if (!mShowGraphUI || mpRenderer->mGraphs.empty()) return;\n  152  \n  153      Gui::Window w(pGui, \"Graphs\", mShowGraphUI, { 300, 400 }, { 10, 80 }, Gui::WindowFlags::Default);\n  ...\n  156      if (mpRenderer->mEditorProcess == 0) {\n  157          Gui::DropdownList graphList;\n  158:         for (size_t i = 0; i < mpRenderer->mGraphs.size(); i++) graphList.push_back({ (uint32_t)i, mpRenderer->mGraphs[i].pGraph->getName() });\n  159          uint32_t activeGraph = mpRenderer->mActiveGraph;\n  160  \n  ...\n  167          if (w.button(\"Remove\", true)) {\n  168              mpRenderer->removeActiveGraph();\n  169:             if (mpRenderer->mGraphs.empty()) return;\n  170          }\n  171          w.separator();\n  ...\n  177      // Graph UI\n  178      w.separator();\n  179:     Gui::Group graphGroup(pGui, (mpRenderer->mGraphs[mpRenderer->mActiveGraph].pGraph->getName() + \"##Graph\").c_str());\n  180:     mpRenderer->mGraphs[mpRenderer->mActiveGraph].pGraph->renderUI(graphGroup);\n  181  }\n  182  \n\n81 matches across 4 files\n\n\nSearching 1284 files for \"ParameterBlock::create\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/BufferTypes/ParameterBlock.cpp:\n  230  ParameterBlock::~ParameterBlock() = default;\n  231  \n  232: ParameterBlock::SharedPtr ParameterBlock::create(std::shared_ptr<Device> pDevice, const std::shared_ptr<const ProgramVersion>& pProgramVersion, const ReflectionType::SharedConstPtr& pElementType) {\n  233      if (!pElementType) {\n  234          throw std::runtime_error(\"Can't create a parameter block without type information\");\n  ...\n  238  }\n  239  \n  240: ParameterBlock::SharedPtr ParameterBlock::create(std::shared_ptr<Device> pDevice, const ParameterBlockReflection::SharedConstPtr& pReflection) {\n  241      assert(pReflection);\n  242      return SharedPtr(new ParameterBlock(pDevice, pReflection->getProgramVersion(), pReflection));\n  243  }\n  244  \n  245: ParameterBlock::SharedPtr ParameterBlock::create(std::shared_ptr<Device> pDevice, const std::shared_ptr<const ProgramVersion>& pProgramVersion, const std::string& typeName) {\n  246      assert(pProgramVersion);\n  247:     return ParameterBlock::create(pDevice, pProgramVersion, pProgramVersion->getReflector()->findType(typeName));\n  248  }\n  249  \n  ...\n  301  }\n  302  \n  303: void ParameterBlock::createConstantBuffers(const ShaderVar& var) {\n  304      auto pType = var.getType();\n  305      if (pType->getResourceRangeCount() == 0) return;\n  ...\n  316                  switch (pResourceType->getType()) {\n  317                      case ReflectionResourceType::Type::ConstantBuffer: {\n  318:                             auto pCB = ParameterBlock::create(mpDevice, pResourceType->getParameterBlockReflector());\n  319                              var.setParameterBlock(pCB);\n  320                          }\n\n/home/max/dev/Falcor/src/Falcor/Scene/Scene.cpp:\n  193      assert(pReflection);\n  194  \n  195:     mpSceneBlock = ParameterBlock::create(mpDevice, pReflection);\n  196      mpMeshesBuffer = Buffer::createStructured(mpDevice, mpSceneBlock[kMeshBufferName], (uint32_t)mMeshDesc.size(), Resource::BindFlags::ShaderResource, Buffer::CpuAccess::None, nullptr, false);\n  197      mpMeshInstancesBuffer = Buffer::createStructured(mpDevice, mpSceneBlock[kMeshInstanceBufferName], (uint32_t)mMeshInstanceData.size(), Resource::BindFlags::ShaderResource, Buffer::CpuAccess::None, nullptr, false);\n\n/home/max/dev/Falcor/src/RenderPasses/MegakernelPathTracer/MegakernelPathTracer.cpp:\n  176      ParameterBlockReflection::SharedConstPtr pBlockReflection = pReflection->getParameterBlock(kParameterBlockName);\n  177      assert(pBlockReflection);\n  178:     mTracer.pParameterBlock = ParameterBlock::create(pBlockReflection);\n  179      assert(mTracer.pParameterBlock);\n  180  \n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Core/RootBufferParamBlockTests.cpp:\n   66              auto pBlockReflection = pReflectionProgram->getProgram()->getReflector()->getParameterBlock(\"gParamBlock\");\n   67              EXPECT(pBlockReflection != nullptr);\n   68:             auto pParamBlock = ParameterBlock::create(pBlockReflection);\n   69              EXPECT(pParamBlock != nullptr);\n   70  \n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Core/UserConstantBufferTests.cpp:\n   59          //auto vars = ctx[\"params\"]; // TODO: Can we get a ParameterBlockReflector from ShaderVar?\n   60          auto reflector = ctx.getProgram()->getReflector()->getParameterBlock(\"params\");\n   61:         auto pCB = ParameterBlock::create(reflector);\n   62          ctx[\"params\"] = pCB;\n   63  \n\n10 matches across 5 files\n\n\nSearching 1284 files for \"ParameterBlock::create\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/BufferTypes/ParameterBlock.cpp:\n  230  ParameterBlock::~ParameterBlock() = default;\n  231  \n  232: ParameterBlock::SharedPtr ParameterBlock::create(std::shared_ptr<Device> pDevice, const std::shared_ptr<const ProgramVersion>& pProgramVersion, const ReflectionType::SharedConstPtr& pElementType) {\n  233      if (!pElementType) {\n  234          throw std::runtime_error(\"Can't create a parameter block without type information\");\n  ...\n  238  }\n  239  \n  240: ParameterBlock::SharedPtr ParameterBlock::create(std::shared_ptr<Device> pDevice, const ParameterBlockReflection::SharedConstPtr& pReflection) {\n  241      assert(pReflection);\n  242      return SharedPtr(new ParameterBlock(pDevice, pReflection->getProgramVersion(), pReflection));\n  243  }\n  244  \n  245: ParameterBlock::SharedPtr ParameterBlock::create(std::shared_ptr<Device> pDevice, const std::shared_ptr<const ProgramVersion>& pProgramVersion, const std::string& typeName) {\n  246      assert(pProgramVersion);\n  247:     return ParameterBlock::create(pDevice, pProgramVersion, pProgramVersion->getReflector()->findType(typeName));\n  248  }\n  249  \n  ...\n  301  }\n  302  \n  303: void ParameterBlock::createConstantBuffers(const ShaderVar& var) {\n  304      auto pType = var.getType();\n  305      if (pType->getResourceRangeCount() == 0) return;\n  ...\n  316                  switch (pResourceType->getType()) {\n  317                      case ReflectionResourceType::Type::ConstantBuffer: {\n  318:                             auto pCB = ParameterBlock::create(mpDevice, pResourceType->getParameterBlockReflector());\n  319                              var.setParameterBlock(pCB);\n  320                          }\n\n/home/max/dev/Falcor/src/Falcor/Scene/Scene.cpp:\n  193      assert(pReflection);\n  194  \n  195:     mpSceneBlock = ParameterBlock::create(mpDevice, pReflection);\n  196      mpMeshesBuffer = Buffer::createStructured(mpDevice, mpSceneBlock[kMeshBufferName], (uint32_t)mMeshDesc.size(), Resource::BindFlags::ShaderResource, Buffer::CpuAccess::None, nullptr, false);\n  197      mpMeshInstancesBuffer = Buffer::createStructured(mpDevice, mpSceneBlock[kMeshInstanceBufferName], (uint32_t)mMeshInstanceData.size(), Resource::BindFlags::ShaderResource, Buffer::CpuAccess::None, nullptr, false);\n\n/home/max/dev/Falcor/src/RenderPasses/MegakernelPathTracer/MegakernelPathTracer.cpp:\n  176      ParameterBlockReflection::SharedConstPtr pBlockReflection = pReflection->getParameterBlock(kParameterBlockName);\n  177      assert(pBlockReflection);\n  178:     mTracer.pParameterBlock = ParameterBlock::create(pBlockReflection);\n  179      assert(mTracer.pParameterBlock);\n  180  \n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Core/RootBufferParamBlockTests.cpp:\n   66              auto pBlockReflection = pReflectionProgram->getProgram()->getReflector()->getParameterBlock(\"gParamBlock\");\n   67              EXPECT(pBlockReflection != nullptr);\n   68:             auto pParamBlock = ParameterBlock::create(pBlockReflection);\n   69              EXPECT(pParamBlock != nullptr);\n   70  \n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Core/UserConstantBufferTests.cpp:\n   59          //auto vars = ctx[\"params\"]; // TODO: Can we get a ParameterBlockReflector from ShaderVar?\n   60          auto reflector = ctx.getProgram()->getReflector()->getParameterBlock(\"params\");\n   61:         auto pCB = ParameterBlock::create(reflector);\n   62          ctx[\"params\"] = pCB;\n   63  \n\n10 matches across 5 files\n\n\nSearching 1284 files for \"ParameterBlock::create\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/BufferTypes/ParameterBlock.cpp:\n  230  ParameterBlock::~ParameterBlock() = default;\n  231  \n  232: ParameterBlock::SharedPtr ParameterBlock::create(std::shared_ptr<Device> pDevice, const std::shared_ptr<const ProgramVersion>& pProgramVersion, const ReflectionType::SharedConstPtr& pElementType) {\n  233      if (!pElementType) {\n  234          throw std::runtime_error(\"Can't create a parameter block without type information\");\n  ...\n  238  }\n  239  \n  240: ParameterBlock::SharedPtr ParameterBlock::create(std::shared_ptr<Device> pDevice, const ParameterBlockReflection::SharedConstPtr& pReflection) {\n  241      assert(pReflection);\n  242      return SharedPtr(new ParameterBlock(pDevice, pReflection->getProgramVersion(), pReflection));\n  243  }\n  244  \n  245: ParameterBlock::SharedPtr ParameterBlock::create(std::shared_ptr<Device> pDevice, const std::shared_ptr<const ProgramVersion>& pProgramVersion, const std::string& typeName) {\n  246      assert(pProgramVersion);\n  247:     return ParameterBlock::create(pDevice, pProgramVersion, pProgramVersion->getReflector()->findType(typeName));\n  248  }\n  249  \n  ...\n  301  }\n  302  \n  303: void ParameterBlock::createConstantBuffers(const ShaderVar& var) {\n  304      auto pType = var.getType();\n  305      if (pType->getResourceRangeCount() == 0) return;\n  ...\n  316                  switch (pResourceType->getType()) {\n  317                      case ReflectionResourceType::Type::ConstantBuffer: {\n  318:                             auto pCB = ParameterBlock::create(mpDevice, pResourceType->getParameterBlockReflector());\n  319                              var.setParameterBlock(pCB);\n  320                          }\n\n/home/max/dev/Falcor/src/Falcor/Scene/Scene.cpp:\n  193      assert(pReflection);\n  194  \n  195:     mpSceneBlock = ParameterBlock::create(mpDevice, pReflection);\n  196      mpMeshesBuffer = Buffer::createStructured(mpDevice, mpSceneBlock[kMeshBufferName], (uint32_t)mMeshDesc.size(), Resource::BindFlags::ShaderResource, Buffer::CpuAccess::None, nullptr, false);\n  197      mpMeshInstancesBuffer = Buffer::createStructured(mpDevice, mpSceneBlock[kMeshInstanceBufferName], (uint32_t)mMeshInstanceData.size(), Resource::BindFlags::ShaderResource, Buffer::CpuAccess::None, nullptr, false);\n\n/home/max/dev/Falcor/src/RenderPasses/MegakernelPathTracer/MegakernelPathTracer.cpp:\n  176      ParameterBlockReflection::SharedConstPtr pBlockReflection = pReflection->getParameterBlock(kParameterBlockName);\n  177      assert(pBlockReflection);\n  178:     mTracer.pParameterBlock = ParameterBlock::create(pBlockReflection);\n  179      assert(mTracer.pParameterBlock);\n  180  \n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Core/RootBufferParamBlockTests.cpp:\n   66              auto pBlockReflection = pReflectionProgram->getProgram()->getReflector()->getParameterBlock(\"gParamBlock\");\n   67              EXPECT(pBlockReflection != nullptr);\n   68:             auto pParamBlock = ParameterBlock::create(pBlockReflection);\n   69              EXPECT(pParamBlock != nullptr);\n   70  \n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Core/UserConstantBufferTests.cpp:\n   59          //auto vars = ctx[\"params\"]; // TODO: Can we get a ParameterBlockReflector from ShaderVar?\n   60          auto reflector = ctx.getProgram()->getReflector()->getParameterBlock(\"params\");\n   61:         auto pCB = ParameterBlock::create(reflector);\n   62          ctx[\"params\"] = pCB;\n   63  \n\n10 matches across 5 files\n\n\nSearching 1284 files for \"ParameterBlock(\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Buffer.cpp:\n  124      bool createCounter)\n  125  {\n  126:     const auto& pDefaultBlock = pProgram->getReflector()->getDefaultParameterBlock();\n  127      const ReflectionVar* pVar = pDefaultBlock ? pDefaultBlock->getResource(name).get() : nullptr;\n  128      if (pVar == nullptr) {\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12NvApiExDesc.h:\n   85      inline std::optional<uint32_t> findNvApiShaderRegister(ProgramKernels::SharedConstPtr const& pKernels)\n   86      {\n   87:         auto pBlock = pKernels->getReflector()->getDefaultParameterBlock();\n   88          auto pVar = pBlock->getResource(\"g_NvidiaExt\");\n   89          if (!pVar) return std::optional<uint32_t>();\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12RenderContext.cpp:\n   83                  assert(blitData.pPass && blitData.pFbo);\n   84  \n   85:                 blitData.pSrcRectBuffer = blitData.pPass->getVars()->getParameterBlock(\"SrcRectCB\");\n   86                  blitData.offsetVarOffset = blitData.pSrcRectBuffer->getVariableOffset(\"gOffset\");\n   87                  blitData.scaleVarOffset = blitData.pSrcRectBuffer->getVariableOffset(\"gScale\");\n   ..\n   95                  blitData.pPointSampler = Sampler::create(desc);\n   96  \n   97:                 const auto& pDefaultBlockReflection = blitData.pPass->getProgram()->getReflector()->getDefaultParameterBlock();\n   98                  blitData.texBindLoc = pDefaultBlockReflection->getResourceBinding(\"gTex\");\n   99  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/RootSignature.cpp:\n  175      assert(pReflector);\n  176      RootSignature::Desc d;\n  177:     addParamBlockSets(pReflector->getDefaultParameterBlock().get(), d);\n  178:     addRootDescriptors(pReflector->getDefaultParameterBlock().get(), d);\n  179      return RootSignature::create(device, d);\n  180  }\n\n/home/max/dev/Falcor/src/Falcor/Core/BufferTypes/ParameterBlock.cpp:\n  228  }  // namespace\n  229  \n  230: ParameterBlock::~ParameterBlock() = default;\n  231  \n  232  ParameterBlock::SharedPtr ParameterBlock::create(std::shared_ptr<Device> pDevice, const std::shared_ptr<const ProgramVersion>& pProgramVersion, const ReflectionType::SharedConstPtr& pElementType) {\n  ...\n  240  ParameterBlock::SharedPtr ParameterBlock::create(std::shared_ptr<Device> pDevice, const ParameterBlockReflection::SharedConstPtr& pReflection) {\n  241      assert(pReflection);\n  242:     return SharedPtr(new ParameterBlock(pDevice, pReflection->getProgramVersion(), pReflection));\n  243  }\n  244  \n  ...\n  248  }\n  249  \n  250: ParameterBlock::ParameterBlock(std::shared_ptr<Device> pDevice, const std::shared_ptr<const ProgramVersion>& pProgramVersion, const ParameterBlockReflection::SharedConstPtr& pReflection)\n  251      : mpDevice(pDevice)\n  252      , mpReflector(pReflection)\n  ...\n  319                              \n  320                              auto pCB = ParameterBlock::create(mpDevice, pResourceType->getParameterBlockReflector());\n  321:                             var.setParameterBlock(pCB);\n  322                          }\n  323                          break;\n  ...\n  475  }\n  476  \n  477: bool ParameterBlock::setParameterBlock(const std::string& name, const ParameterBlock::SharedPtr& pCB) {\n  478      auto var = getBufferBindLocation(this, name, ReflectionResourceType::Type::ConstantBuffer);\n  479      if (!var.isValid()) {\n  480:         logError(\"Parameter block \\\"\" + name + \"\\\" was not found. Ignoring setParameterBlock() call.\");\n  481          return false;\n  482      }\n  483:     return var.setParameterBlock(pCB);\n  484  }\n  485  \n  ...\n  514  }\n  515  \n  516: bool ParameterBlock::setParameterBlock(const BindLocation& bindLocation, const ParameterBlock::SharedPtr& pBlock) {\n  517      if (!checkResourceIndices(bindLocation, \"setParameterBlock\")) return false;\n  518      if (!checkDescriptorType(bindLocation, kCbvDescriptorType, \"setParameterBlock\")) return false;\n  ...\n  533  }\n  534  \n  535: ParameterBlock::SharedPtr ParameterBlock::getParameterBlock(const std::string& name) const {\n  536      auto var = getBufferBindLocation(this, name, ReflectionResourceType::Type::ConstantBuffer);\n  537      if (!var.isValid()) {\n  538:         logError(\"Parameter block \\\"\" + name + \"\\\" was not found. Ignoring getParameterBlock() call.\");\n  539          return nullptr;\n  540      }\n  541:     return var.getParameterBlock();\n  542  }\n  543  \n  544: ParameterBlock::SharedPtr ParameterBlock::getParameterBlock(const BindLocation& bindLocation) const {\n  545      if (!checkResourceIndices(bindLocation, \"getParameterBlock\")) return nullptr;\n  546      if (!checkDescriptorType(bindLocation, kCbvDescriptorType, \"getParameterBlock\")) return nullptr;\n  ...\n  870          auto rangeInfo = pReflector->getResourceRange(r);\n  871          for (uint32_t i = 0; i < rangeInfo.count; ++i) {\n  872:             auto& assigned = getAssignedParameterBlock(r, i);\n  873              auto& pSubObject = assigned.pBlock;\n  874  \n  ...\n  890              auto pSubObjectReflector = pReflector->getResourceRangeBindingInfo(resourceRangeIndex).pSubObjectReflector.get();\n  891              for (uint32_t i = 0; i < subObjectCount; ++i) {\n  892:                 auto& assigned = getAssignedParameterBlock(resourceRangeIndex, i);\n  893                  auto& pSubObject = assigned.pBlock;\n  894  \n  ...\n  917          auto rangeInfo = pReflector->getResourceRange(r);\n  918          for (uint32_t i = 0; i < rangeInfo.count; ++i) {\n  919:             auto& assigned = getAssignedParameterBlock(r, i);\n  920              auto& pSubObject = assigned.pBlock;\n  921  \n  ...\n  948          auto rangeInfo = pReflector->getResourceRange(r);\n  949          for (uint32_t i = 0; i < rangeInfo.count; ++i) {\n  950:             auto& assigned = getAssignedParameterBlock(r, i);\n  951              auto& pSubObject = assigned.pBlock;\n  952  \n  ...\n 1021          for (uint32_t ii = 0; ii < rangeInfo.count; ++ii) {\n 1022              assert(ii == 0);\n 1023:             auto pSubObject = getParameterBlock(rr, ii);\n 1024  \n 1025              size_t subObjectOffset = rangeBindingInfo.regIndex;\n ....\n 1175  }\n 1176  \n 1177: ParameterBlock::SharedPtr const& ParameterBlock::getParameterBlock(uint32_t resourceRangeIndex, uint32_t arrayIndex) const {\n 1178      auto rangeInfo = mpReflector->getElementType()->getResourceRange(resourceRangeIndex);\n 1179      return mParameterBlocks[rangeInfo.baseIndex + arrayIndex].pBlock;\n 1180  }\n 1181  \n 1182: ParameterBlock::AssignedParameterBlock const& ParameterBlock::getAssignedParameterBlock(uint32_t resourceRangeIndex, uint32_t arrayIndex) const {\n 1183      auto rangeInfo = mpReflector->getElementType()->getResourceRange(resourceRangeIndex);\n 1184      return mParameterBlocks[rangeInfo.baseIndex + arrayIndex];\n ....\n 1312                  assert(subObjectCount == 1);\n 1313  \n 1314:                 auto pSubObject = getParameterBlock(resourceRangeIndex, i);\n 1315                  if( pReflector->getResourceRangeBindingInfo(resourceRangeIndex).flavor == ParameterBlockReflection::ResourceRangeBindingInfo::Flavor::Interface ) {\n 1316                      pSubObject->bindResourcesIntoDescriptorSet(\n ....\n 1370                          assert(rangeInfo.count == 1);\n 1371  \n 1372:                         auto pSubObject = getParameterBlock(r, 0);\n 1373  \n 1374                          // TODO: We should actually be querying the specialized element type\n ....\n 1387                  case ParameterBlockReflection::ResourceRangeBindingInfo::Flavor::ParameterBlock: {\n 1388                          assert(rangeInfo.count == 1);\n 1389:                         auto pSubObject = getParameterBlock(r, 0);\n 1390                          pSubObject->collectSpecializationArgs(ioArgs);\n 1391                      }\n ....\n 1473  \n 1474              for (uint32_t i = 0; i < objectCount; ++i) {\n 1475:                 auto& assigned = getAssignedParameterBlock(resourceRangeIndex, i);\n 1476                  auto pSubBlock = assigned.pBlock;\n 1477  \n\n/home/max/dev/Falcor/src/Falcor/Core/BufferTypes/ParameterBlock.h:\n   56      /** Implicitly convert a `ShaderVar` to a `ParameterBlock` pointer.\n   57      */\n   58:     ParameterBlockSharedPtr(const ShaderVar& var) : std::shared_ptr<T>(var.getParameterBlock()) {}\n   59  \n   60      /** Get a shader variable that points to the root/contents of the parameter block.\n   ..\n  100      using SharedConstPtr = std::shared_ptr<const ParameterBlock>;\n  101      using ConstSharedPtrRef = const SharedPtr&;\n  102:     ~ParameterBlock();\n  103  \n  104      using BindLocation = ParameterBlockReflection::BindLocation;\n  ...\n  182          \\return false is the call failed, otherwise true\n  183      */\n  184:     bool setParameterBlock(const std::string& name, const ParameterBlock::SharedPtr& pBlock);\n  185  \n  186      /** Bind a parameter block by index.\n  ...\n  190          \\return false is the call failed, otherwise true\n  191      */\n  192:     bool setParameterBlock(const BindLocation& bindLocation, const ParameterBlock::SharedPtr& pBlock);\n  193  \n  194      /** Get a parameter block.\n  ...\n  196          \\return If the name is valid, a shared pointer to the parameter block. Otherwise returns nullptr\n  197      */\n  198:     ParameterBlock::SharedPtr getParameterBlock(const std::string& name) const;\n  199  \n  200      /** Get a parameter block.\n  ...\n  202          \\return If the indices is valid, a shared pointer to the parameter block. Otherwise returns nullptr\n  203      */\n  204:     ParameterBlock::SharedPtr getParameterBlock(const BindLocation& bindLocation) const;\n  205  \n  206      /** Bind a texture. Based on the shader reflection, it will be bound as either an SRV or a UAV\n  ...\n  314  \n  315      void renderUI(Gui::Widgets& widget);\n  316:     ParameterBlock::ConstSharedPtrRef getParameterBlock(uint32_t resourceRangeIndex, uint32_t arrayIndex) const;\n  317  \n  318      // Delete some functions. If they are not deleted, the compiler will try to convert the uints to string, resulting in runtime error\n  ...\n  343      std::shared_ptr<Device>  mpDevice;\n  344  \n  345:     ParameterBlock(std::shared_ptr<Device> pDevice, const std::shared_ptr<const ProgramVersion>& pProgramVersion, const ParameterBlockReflection::SharedConstPtr& pReflection);\n  346  \n  347      std::shared_ptr<const ProgramVersion> mpProgramVersion;\n  ...\n  409      std::vector<Sampler::SharedPtr>         mSamplers;\n  410  \n  411:     AssignedParameterBlock const& getAssignedParameterBlock(uint32_t resourceRangeIndex, uint32_t arrayIndex) const;\n  412  \n  413      size_t getFlatIndex(const BindLocation& bindLocation) const;\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramReflection.cpp:\n 1063          ParameterBlockReflection::SharedPtr pDefaultBlock = ParameterBlockReflection::createEmpty(pProgramVersion);\n 1064          pDefaultBlock->setElementType(pGlobalStruct);\n 1065:         setDefaultParameterBlock(pDefaultBlock);\n 1066      }\n 1067  \n ....\n 1251  \n 1252          pDefaultBlock->finalize();\n 1253:         setDefaultParameterBlock(pDefaultBlock);\n 1254  \n 1255          auto pProgram = pProgramVersion->getProgram();\n ....\n 1297      }\n 1298  \n 1299:     void ProgramReflection::setDefaultParameterBlock(const ParameterBlockReflection::SharedPtr& pBlock)\n 1300      {\n 1301          mpDefaultBlock = pBlock;\n ....\n 1815      }\n 1816  \n 1817:     ParameterBlockReflection::SharedConstPtr ProgramReflection::getParameterBlock(const std::string& name) const\n 1818      {\n 1819          if(name == \"\")\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramReflection.h:\n 1447      /** Get parameter block by name\n 1448      */\n 1449:     ParameterBlockReflection::SharedConstPtr getParameterBlock(const std::string& name) const;\n 1450  \n 1451      /** Get the default (unnamed) parameter block.\n 1452      */\n 1453:     ParameterBlockReflection::SharedConstPtr getDefaultParameterBlock() const { return mpDefaultBlock; }\n 1454  \n 1455      /** For compute-shaders, return the required thread-group size\n ....\n 1496      ProgramReflection(ProgramVersion const* pProgramVersion);\n 1497      ProgramReflection(const ProgramReflection&) = default;\n 1498:     void setDefaultParameterBlock(const ParameterBlockReflection::SharedPtr& pBlock);\n 1499  \n 1500      ProgramVersion const* mpProgramVersion;\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramVars.cpp:\n   56  \n   57      ProgramVars::ProgramVars(std::shared_ptr<Device> pDevice, const ProgramReflection::SharedConstPtr& pReflector)\n   58:         : ParameterBlock(pDevice, pReflector->getProgramVersion(), pReflector->getDefaultParameterBlock())\n   59          , mpReflector(pReflector)\n   60      {\n   ..\n  199  \n  200              for(uint32_t i = 0; i < objectCount; ++i) {\n  201:                 auto pSubBlock = pParameterBlock->getParameterBlock(resourceRangeIndex, i);\n  202                  if(!bindParameterBlockSets<forGraphics>(pSubBlock.get(), pSubObjectReflector.get(), pContext, pRootSignature, bindRootSig, descSetIndex, rootConstIndex)) {\n  203                      return false;\n  ...\n  246              //LOG_DBG(\"subloop resourceRangeCount\");\n  247              for (uint32_t i = 0; i < objectCount; ++i) {\n  248:                 auto pSubBlock = pParameterBlock->getParameterBlock(resourceRangeIndex, i);\n  249                  if (!bindParameterBlockRootDescs<forGraphics>(pSubBlock.get(), pSubObjectReflector.get(), pContext, pRootSignature, bindRootSig, rootDescIndex)) {\n  250                      return false;\n  ...\n  307  \n  308          auto pProgramKernels = mpProgramVersion->getKernels(this);\n  309:         mpSpecializedReflector = pProgramKernels->getReflector()->getDefaultParameterBlock();\n  310          return false;\n  311      }\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramVars.h:\n   59   protected:\n   60      EntryPointGroupVars(std::shared_ptr<Device> pDevice, const EntryPointGroupReflection::SharedConstPtr& pReflector, uint32_t groupIndexInProgram)\n   61:         : ParameterBlock(pDevice, pReflector->getProgramVersion(), pReflector)\n   62          , mGroupIndexInProgram(groupIndexInProgram)\n   63      {\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ShaderVar.cpp:\n   52              {\n   53              case ReflectionResourceType::Type::ConstantBuffer:\n   54:                 return getParameterBlock()->getRootVar().findMember(name);\n   55              default:\n   56                  break;\n   ..\n   87              {\n   88              case ReflectionResourceType::Type::ConstantBuffer:\n   89:                 return getParameterBlock()->getRootVar().findMember(index);\n   90              default:\n   91                  break;\n   ..\n  157              {\n  158              case ReflectionResourceType::Type::ConstantBuffer:\n  159:                 return getParameterBlock()->getRootVar()[index];\n  160              default:\n  161                  break;\n  ...\n  204              {\n  205              case ReflectionResourceType::Type::ConstantBuffer:\n  206:                 return getParameterBlock()->getRootVar()[offset];\n  207              default:\n  208                  break;\n  ...\n  229              {\n  230              case ReflectionResourceType::Type::ConstantBuffer:\n  231:                 return getParameterBlock()->getRootVar()[loc];\n  232              default:\n  233                  break;\n  ...\n  309      }\n  310  \n  311:     bool ShaderVar::setParameterBlock(const std::shared_ptr<ParameterBlock>& pBlock) const\n  312      {\n  313:         return mpBlock->setParameterBlock(mOffset, pBlock);\n  314      }\n  315  \n  ...\n  331      bool ShaderVar::setImpl(const std::shared_ptr<ParameterBlock>& pBlock) const\n  332      {\n  333:         return mpBlock->setParameterBlock(mOffset, pBlock);\n  334      }\n  335  \n  ...\n  345              {\n  346              case ReflectionResourceType::Type::ConstantBuffer:\n  347:                 return getParameterBlock()->getRootVar().setBlob(data, size);\n  348              default:\n  349                  break;\n  ...\n  374      }\n  375  \n  376:     std::shared_ptr<ParameterBlock> ShaderVar::getParameterBlock() const\n  377      {\n  378:         return mpBlock->getParameterBlock(mOffset);\n  379      }\n  380  \n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ShaderVar.h:\n  235          Logs an error and returns `false` if this variable doesn't point at a parameter block.\n  236      */\n  237:     bool setParameterBlock(const std::shared_ptr<ParameterBlock>& pBlock) const;\n  238  \n  239      /** Get the parameter block that this variable points to.\n  240          Logs an error and returns null if this variable doesn't point at a parameter block.\n  241      */\n  242:     std::shared_ptr<ParameterBlock> getParameterBlock() const;\n  243  \n  244      /** Set the value of the data pointed to by this shader variable.\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightCollection.cpp:\n  329  \n  330              // Bind scene.\n  331:             mIntegrator.pVars[\"gScene\"] = mpScene->getParameterBlock();\n  332  \n  333              // Bind light collection.\n  ...\n  345          {\n  346              // Bind scene.\n  347:             mpFinalizeIntegration[\"gScene\"] = mpScene->getParameterBlock();\n  348  \n  349              mpFinalizeIntegration[\"gTexelSum\"] = mIntegrator.pResultBuffer;\n  ...\n  407  \n  408          // Bind scene.\n  409:         mpTriangleListBuilder[\"gScene\"] = mpScene->getParameterBlock();\n  410  \n  411          // Bind our output buffers.\n  ...\n  439  \n  440          // Bind scene.\n  441:         mpTrianglePositionUpdater[\"gScene\"] = mpScene->getParameterBlock();\n  442  \n  443          // Bind our resources.\n\n/home/max/dev/Falcor/src/Falcor/Scene/ParticleSystem/ParticleSystem.cpp:\n  154  \n  155          // Save bind locations for resourced updated during draw\n  156:         mBindLocations.simulateCB = pSimulateCs->getReflector()->getDefaultParameterBlock()->getResourceBinding(\"PerFrame\");\n  157:         mBindLocations.drawCB = pDrawProgram->getReflector()->getDefaultParameterBlock()->getResourceBinding(\"PerFrame\");\n  158:         mBindLocations.emitCB = pEmitCs->getReflector()->getDefaultParameterBlock()->getResourceBinding(\"PerEmit\");\n  159      }\n  160  \n  ...\n  183  \n  184          //Send vars and call\n  185:         mEmitResources.pVars->getParameterBlock(mBindLocations.emitCB)->setBlob(&emitData, 0u, sizeof(EmitData));\n  186          uint32_t numGroups = div_round_up(num, kParticleEmitThreads);\n  187          pCtx->dispatch(mEmitResources.pState.get(), mEmitResources.pVars.get(), {1, numGroups, 1});\n  ...\n  202              perFrame.dt = dt;\n  203              perFrame.maxParticles = mMaxParticles;\n  204:             mSimulateResources.pVars->getParameterBlock(mBindLocations.simulateCB)->setBlob(&perFrame, 0u, sizeof(SimulateWithSortPerFrame));\n  205              mpAliveList->setBlob(mSortDataReset.data(), 0, sizeof(SortData) * mMaxParticles);\n  206          } else {\n  ...\n  208              perFrame.dt = dt;\n  209              perFrame.maxParticles = mMaxParticles;\n  210:             mSimulateResources.pVars->getParameterBlock(mBindLocations.simulateCB)->setBlob(&perFrame, 0u, sizeof(SimulatePerFrame));\n  211          }\n  212  \n  ...\n  225          cbuf.view = view;\n  226          cbuf.proj = proj;\n  227:         mDrawResources.pVars->getParameterBlock(mBindLocations.drawCB)->setBlob(&cbuf, 0, sizeof(cbuf));\n  228  \n  229          //particle draw uses many of render context's existing state's properties\n\n/home/max/dev/Falcor/src/Falcor/Scene/Scene.cpp:\n  149  \n  150      pState->setVao(mpVao);\n  151:     pVars->setParameterBlock(\"gScene\", mpSceneBlock);\n  152  \n  153      bool overrideRS = !is_set(flags, RenderFlags::UserRasterizerState);\n  ...\n  192      GraphicsProgram::SharedPtr pProgram = GraphicsProgram::createFromFile(mpDevice, \"Scene/SceneBlock.slang\", \"\", \"main\");\n  193      pProgram->addDefines(getSceneDefines());\n  194:     ParameterBlockReflection::SharedConstPtr pReflection = pProgram->getReflector()->getParameterBlock(kParameterBlockName);\n  195  \n  196      assert(pReflection);\n\n/home/max/dev/Falcor/src/Falcor/Scene/Scene.h:\n  336              Note that the camera is not bound automatically.\n  337          */\n  338:         ParameterBlock::ConstSharedPtrRef getParameterBlock() const { return mpSceneBlock; }\n  339  \n  340  #ifdef FALCOR_D3D12\n\n/home/max/dev/Falcor/src/Falcor/Utils/UI/DebugDrawer.cpp:\n  178  \n  179  void DebugDrawer::render(RenderContext* pContext, GraphicsState* pState, GraphicsVars* pVars, Camera *pCamera) {\n  180: //      ParameterBlock* pCB = pVars->getParameterBlock(\"InternalPerFrameCB\").get();\n  181  //      if (pCB != nullptr) pCamera->setShaderData(pCB, 0);\n  182  \n\n/home/max/dev/Falcor/src/Falcor/Utils/UI/Gui.cpp:\n  217          mpLayout->addBufferLayout(0, pBufLayout);\n  218  \n  219:         mGuiImageLoc = mpProgram->getReflector()->getDefaultParameterBlock()->getResourceBinding(\"guiImage\");\n  220      }\n  221  \n\n/home/max/dev/Falcor/src/RenderPasses/BSDFViewer/BSDFViewer.cpp:\n  111          mpViewerPass->getProgram()->addDefines(mpScene->getSceneDefines());\n  112          mpViewerPass->setVars(nullptr); // Trigger vars creation\n  113:         mpViewerPass[\"gScene\"] = mpScene->getParameterBlock();\n  114  \n  115          // Load and bind environment map.\n\n/home/max/dev/Falcor/src/RenderPasses/CSM/CSM.cpp:\n  163      mVisibilityPass.pFbo = Fbo::create(mpDevice);\n  164      mVisibilityPass.pPass = FullScreenPass::create(mpDevice, kVisibilityPassFile);\n  165:     mVisibilityPass.mPassDataOffset = mVisibilityPass.pPass->getVars()->getParameterBlock(\"PerFrameCB\")->getVariableOffset(\"gPass\");\n  166  }\n  167  \n  ...\n  462  \n  463  void CSM::renderScene(RenderContext* pCtx) {\n  464:     auto pCB = mShadowPass.pVars->getParameterBlock(mPerLightCbLoc);\n  465      check_offset(globalMat);\n  466      check_offset(cascadeScale);\n  ...\n  653  \n  654          const auto& pReflector = mShadowPass.pVars->getReflection();\n  655:         const auto& pDefaultBlock = pReflector->getDefaultParameterBlock();\n  656          mPerLightCbLoc = pDefaultBlock->getResourceBinding(\"PerLightCB\");\n  657      } else {\n\n/home/max/dev/Falcor/src/RenderPasses/MegakernelPathTracer/MegakernelPathTracer.cpp:\n  174      // Create parameter block for shared data.\n  175      ProgramReflection::SharedConstPtr pReflection = mTracer.pProgram->getReflector();\n  176:     ParameterBlockReflection::SharedConstPtr pBlockReflection = pReflection->getParameterBlock(kParameterBlockName);\n  177      assert(pBlockReflection);\n  178      mTracer.pParameterBlock = ParameterBlock::create(pBlockReflection);\n  ...\n  188  \n  189      // Bind the parameter block to the global program variables.\n  190:     mTracer.pVars->setParameterBlock(kParameterBlockName, mTracer.pParameterBlock);\n  191  }\n  192  \n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Core/RootBufferParamBlockTests.cpp:\n   64              auto pReflectionProgram = ComputePass::create(reflDesc, defines);\n   65              EXPECT(pReflectionProgram != nullptr);\n   66:             auto pBlockReflection = pReflectionProgram->getProgram()->getReflector()->getParameterBlock(\"gParamBlock\");\n   67              EXPECT(pBlockReflection != nullptr);\n   68              auto pParamBlock = ParameterBlock::create(pBlockReflection);\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Core/UserConstantBufferTests.cpp:\n   58          // Create a parameter block instead to replace the automatically allocated block.\n   59          //auto vars = ctx[\"params\"]; // TODO: Can we get a ParameterBlockReflector from ShaderVar?\n   60:         auto reflector = ctx.getProgram()->getReflector()->getParameterBlock(\"params\");\n   61          auto pCB = ParameterBlock::create(reflector);\n   62          ctx[\"params\"] = pCB;\n\n88 matches across 23 files\n\n\nSearching 1284 files for \"ParameterBlock(\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Buffer.cpp:\n  124      bool createCounter)\n  125  {\n  126:     const auto& pDefaultBlock = pProgram->getReflector()->getDefaultParameterBlock();\n  127      const ReflectionVar* pVar = pDefaultBlock ? pDefaultBlock->getResource(name).get() : nullptr;\n  128      if (pVar == nullptr) {\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12NvApiExDesc.h:\n   85      inline std::optional<uint32_t> findNvApiShaderRegister(ProgramKernels::SharedConstPtr const& pKernels)\n   86      {\n   87:         auto pBlock = pKernels->getReflector()->getDefaultParameterBlock();\n   88          auto pVar = pBlock->getResource(\"g_NvidiaExt\");\n   89          if (!pVar) return std::optional<uint32_t>();\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12RenderContext.cpp:\n   83                  assert(blitData.pPass && blitData.pFbo);\n   84  \n   85:                 blitData.pSrcRectBuffer = blitData.pPass->getVars()->getParameterBlock(\"SrcRectCB\");\n   86                  blitData.offsetVarOffset = blitData.pSrcRectBuffer->getVariableOffset(\"gOffset\");\n   87                  blitData.scaleVarOffset = blitData.pSrcRectBuffer->getVariableOffset(\"gScale\");\n   ..\n   95                  blitData.pPointSampler = Sampler::create(desc);\n   96  \n   97:                 const auto& pDefaultBlockReflection = blitData.pPass->getProgram()->getReflector()->getDefaultParameterBlock();\n   98                  blitData.texBindLoc = pDefaultBlockReflection->getResourceBinding(\"gTex\");\n   99  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/RootSignature.cpp:\n  175      assert(pReflector);\n  176      RootSignature::Desc d;\n  177:     addParamBlockSets(pReflector->getDefaultParameterBlock().get(), d);\n  178:     addRootDescriptors(pReflector->getDefaultParameterBlock().get(), d);\n  179      return RootSignature::create(device, d);\n  180  }\n\n/home/max/dev/Falcor/src/Falcor/Core/BufferTypes/ParameterBlock.cpp:\n  228  }  // namespace\n  229  \n  230: ParameterBlock::~ParameterBlock() = default;\n  231  \n  232  ParameterBlock::SharedPtr ParameterBlock::create(std::shared_ptr<Device> pDevice, const std::shared_ptr<const ProgramVersion>& pProgramVersion, const ReflectionType::SharedConstPtr& pElementType) {\n  ...\n  240  ParameterBlock::SharedPtr ParameterBlock::create(std::shared_ptr<Device> pDevice, const ParameterBlockReflection::SharedConstPtr& pReflection) {\n  241      assert(pReflection);\n  242:     return SharedPtr(new ParameterBlock(pDevice, pReflection->getProgramVersion(), pReflection));\n  243  }\n  244  \n  ...\n  248  }\n  249  \n  250: ParameterBlock::ParameterBlock(std::shared_ptr<Device> pDevice, const std::shared_ptr<const ProgramVersion>& pProgramVersion, const ParameterBlockReflection::SharedConstPtr& pReflection)\n  251      : mpDevice(pDevice)\n  252      , mpReflector(pReflection)\n  ...\n  319  \n  320                              auto pCB = ParameterBlock::create(mpDevice, pResourceType->getParameterBlockReflector());\n  321:                             var.setParameterBlock(pCB);\n  322                          }\n  323                          break;\n  ...\n  475  }\n  476  \n  477: bool ParameterBlock::setParameterBlock(const std::string& name, const ParameterBlock::SharedPtr& pCB) {\n  478      auto var = getBufferBindLocation(this, name, ReflectionResourceType::Type::ConstantBuffer);\n  479      if (!var.isValid()) {\n  480:         logError(\"Parameter block \\\"\" + name + \"\\\" was not found. Ignoring setParameterBlock() call.\");\n  481          return false;\n  482      }\n  483:     return var.setParameterBlock(pCB);\n  484  }\n  485  \n  ...\n  514  }\n  515  \n  516: bool ParameterBlock::setParameterBlock(const BindLocation& bindLocation, const ParameterBlock::SharedPtr& pBlock) {\n  517      if (!checkResourceIndices(bindLocation, \"setParameterBlock\")) return false;\n  518      if (!checkDescriptorType(bindLocation, kCbvDescriptorType, \"setParameterBlock\")) return false;\n  ...\n  533  }\n  534  \n  535: ParameterBlock::SharedPtr ParameterBlock::getParameterBlock(const std::string& name) const {\n  536      auto var = getBufferBindLocation(this, name, ReflectionResourceType::Type::ConstantBuffer);\n  537      if (!var.isValid()) {\n  538:         logError(\"Parameter block \\\"\" + name + \"\\\" was not found. Ignoring getParameterBlock() call.\");\n  539          return nullptr;\n  540      }\n  541:     return var.getParameterBlock();\n  542  }\n  543  \n  544: ParameterBlock::SharedPtr ParameterBlock::getParameterBlock(const BindLocation& bindLocation) const {\n  545      if (!checkResourceIndices(bindLocation, \"getParameterBlock\")) return nullptr;\n  546      if (!checkDescriptorType(bindLocation, kCbvDescriptorType, \"getParameterBlock\")) return nullptr;\n  ...\n  870          auto rangeInfo = pReflector->getResourceRange(r);\n  871          for (uint32_t i = 0; i < rangeInfo.count; ++i) {\n  872:             auto& assigned = getAssignedParameterBlock(r, i);\n  873              auto& pSubObject = assigned.pBlock;\n  874  \n  ...\n  890              auto pSubObjectReflector = pReflector->getResourceRangeBindingInfo(resourceRangeIndex).pSubObjectReflector.get();\n  891              for (uint32_t i = 0; i < subObjectCount; ++i) {\n  892:                 auto& assigned = getAssignedParameterBlock(resourceRangeIndex, i);\n  893                  auto& pSubObject = assigned.pBlock;\n  894  \n  ...\n  917          auto rangeInfo = pReflector->getResourceRange(r);\n  918          for (uint32_t i = 0; i < rangeInfo.count; ++i) {\n  919:             auto& assigned = getAssignedParameterBlock(r, i);\n  920              auto& pSubObject = assigned.pBlock;\n  921  \n  ...\n  948          auto rangeInfo = pReflector->getResourceRange(r);\n  949          for (uint32_t i = 0; i < rangeInfo.count; ++i) {\n  950:             auto& assigned = getAssignedParameterBlock(r, i);\n  951              auto& pSubObject = assigned.pBlock;\n  952  \n  ...\n 1021          for (uint32_t ii = 0; ii < rangeInfo.count; ++ii) {\n 1022              assert(ii == 0);\n 1023:             auto pSubObject = getParameterBlock(rr, ii);\n 1024  \n 1025              size_t subObjectOffset = rangeBindingInfo.regIndex;\n ....\n 1175  }\n 1176  \n 1177: ParameterBlock::SharedPtr const& ParameterBlock::getParameterBlock(uint32_t resourceRangeIndex, uint32_t arrayIndex) const {\n 1178      auto rangeInfo = mpReflector->getElementType()->getResourceRange(resourceRangeIndex);\n 1179      return mParameterBlocks[rangeInfo.baseIndex + arrayIndex].pBlock;\n 1180  }\n 1181  \n 1182: ParameterBlock::AssignedParameterBlock const& ParameterBlock::getAssignedParameterBlock(uint32_t resourceRangeIndex, uint32_t arrayIndex) const {\n 1183      auto rangeInfo = mpReflector->getElementType()->getResourceRange(resourceRangeIndex);\n 1184      return mParameterBlocks[rangeInfo.baseIndex + arrayIndex];\n ....\n 1312                  assert(subObjectCount == 1);\n 1313  \n 1314:                 auto pSubObject = getParameterBlock(resourceRangeIndex, i);\n 1315                  if( pReflector->getResourceRangeBindingInfo(resourceRangeIndex).flavor == ParameterBlockReflection::ResourceRangeBindingInfo::Flavor::Interface ) {\n 1316                      pSubObject->bindResourcesIntoDescriptorSet(\n ....\n 1370                          assert(rangeInfo.count == 1);\n 1371  \n 1372:                         auto pSubObject = getParameterBlock(r, 0);\n 1373  \n 1374                          // TODO: We should actually be querying the specialized element type\n ....\n 1387                  case ParameterBlockReflection::ResourceRangeBindingInfo::Flavor::ParameterBlock: {\n 1388                          assert(rangeInfo.count == 1);\n 1389:                         auto pSubObject = getParameterBlock(r, 0);\n 1390                          pSubObject->collectSpecializationArgs(ioArgs);\n 1391                      }\n ....\n 1473  \n 1474              for (uint32_t i = 0; i < objectCount; ++i) {\n 1475:                 auto& assigned = getAssignedParameterBlock(resourceRangeIndex, i);\n 1476                  auto pSubBlock = assigned.pBlock;\n 1477  \n\n/home/max/dev/Falcor/src/Falcor/Core/BufferTypes/ParameterBlock.h:\n   56      /** Implicitly convert a `ShaderVar` to a `ParameterBlock` pointer.\n   57      */\n   58:     ParameterBlockSharedPtr(const ShaderVar& var) : std::shared_ptr<T>(var.getParameterBlock()) {}\n   59  \n   60      /** Get a shader variable that points to the root/contents of the parameter block.\n   ..\n  100      using SharedConstPtr = std::shared_ptr<const ParameterBlock>;\n  101      using ConstSharedPtrRef = const SharedPtr&;\n  102:     ~ParameterBlock();\n  103  \n  104      using BindLocation = ParameterBlockReflection::BindLocation;\n  ...\n  182          \\return false is the call failed, otherwise true\n  183      */\n  184:     bool setParameterBlock(const std::string& name, const ParameterBlock::SharedPtr& pBlock);\n  185  \n  186      /** Bind a parameter block by index.\n  ...\n  190          \\return false is the call failed, otherwise true\n  191      */\n  192:     bool setParameterBlock(const BindLocation& bindLocation, const ParameterBlock::SharedPtr& pBlock);\n  193  \n  194      /** Get a parameter block.\n  ...\n  196          \\return If the name is valid, a shared pointer to the parameter block. Otherwise returns nullptr\n  197      */\n  198:     ParameterBlock::SharedPtr getParameterBlock(const std::string& name) const;\n  199  \n  200      /** Get a parameter block.\n  ...\n  202          \\return If the indices is valid, a shared pointer to the parameter block. Otherwise returns nullptr\n  203      */\n  204:     ParameterBlock::SharedPtr getParameterBlock(const BindLocation& bindLocation) const;\n  205  \n  206      /** Bind a texture. Based on the shader reflection, it will be bound as either an SRV or a UAV\n  ...\n  314  \n  315      void renderUI(Gui::Widgets& widget);\n  316:     ParameterBlock::ConstSharedPtrRef getParameterBlock(uint32_t resourceRangeIndex, uint32_t arrayIndex) const;\n  317  \n  318      // Delete some functions. If they are not deleted, the compiler will try to convert the uints to string, resulting in runtime error\n  ...\n  343      std::shared_ptr<Device>  mpDevice;\n  344  \n  345:     ParameterBlock(std::shared_ptr<Device> pDevice, const std::shared_ptr<const ProgramVersion>& pProgramVersion, const ParameterBlockReflection::SharedConstPtr& pReflection);\n  346  \n  347      std::shared_ptr<const ProgramVersion> mpProgramVersion;\n  ...\n  409      std::vector<Sampler::SharedPtr>         mSamplers;\n  410  \n  411:     AssignedParameterBlock const& getAssignedParameterBlock(uint32_t resourceRangeIndex, uint32_t arrayIndex) const;\n  412  \n  413      size_t getFlatIndex(const BindLocation& bindLocation) const;\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramReflection.cpp:\n 1063          ParameterBlockReflection::SharedPtr pDefaultBlock = ParameterBlockReflection::createEmpty(pProgramVersion);\n 1064          pDefaultBlock->setElementType(pGlobalStruct);\n 1065:         setDefaultParameterBlock(pDefaultBlock);\n 1066      }\n 1067  \n ....\n 1251  \n 1252          pDefaultBlock->finalize();\n 1253:         setDefaultParameterBlock(pDefaultBlock);\n 1254  \n 1255          auto pProgram = pProgramVersion->getProgram();\n ....\n 1297      }\n 1298  \n 1299:     void ProgramReflection::setDefaultParameterBlock(const ParameterBlockReflection::SharedPtr& pBlock)\n 1300      {\n 1301          mpDefaultBlock = pBlock;\n ....\n 1815      }\n 1816  \n 1817:     ParameterBlockReflection::SharedConstPtr ProgramReflection::getParameterBlock(const std::string& name) const\n 1818      {\n 1819          if(name == \"\")\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramReflection.h:\n 1447      /** Get parameter block by name\n 1448      */\n 1449:     ParameterBlockReflection::SharedConstPtr getParameterBlock(const std::string& name) const;\n 1450  \n 1451      /** Get the default (unnamed) parameter block.\n 1452      */\n 1453:     ParameterBlockReflection::SharedConstPtr getDefaultParameterBlock() const { return mpDefaultBlock; }\n 1454  \n 1455      /** For compute-shaders, return the required thread-group size\n ....\n 1496      ProgramReflection(ProgramVersion const* pProgramVersion);\n 1497      ProgramReflection(const ProgramReflection&) = default;\n 1498:     void setDefaultParameterBlock(const ParameterBlockReflection::SharedPtr& pBlock);\n 1499  \n 1500      ProgramVersion const* mpProgramVersion;\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramVars.cpp:\n   56  \n   57      ProgramVars::ProgramVars(std::shared_ptr<Device> pDevice, const ProgramReflection::SharedConstPtr& pReflector)\n   58:         : ParameterBlock(pDevice, pReflector->getProgramVersion(), pReflector->getDefaultParameterBlock())\n   59          , mpReflector(pReflector)\n   60      {\n   ..\n  199  \n  200              for(uint32_t i = 0; i < objectCount; ++i) {\n  201:                 auto pSubBlock = pParameterBlock->getParameterBlock(resourceRangeIndex, i);\n  202                  if(!bindParameterBlockSets<forGraphics>(pSubBlock.get(), pSubObjectReflector.get(), pContext, pRootSignature, bindRootSig, descSetIndex, rootConstIndex)) {\n  203                      return false;\n  ...\n  246              //LOG_DBG(\"subloop resourceRangeCount\");\n  247              for (uint32_t i = 0; i < objectCount; ++i) {\n  248:                 auto pSubBlock = pParameterBlock->getParameterBlock(resourceRangeIndex, i);\n  249                  if (!bindParameterBlockRootDescs<forGraphics>(pSubBlock.get(), pSubObjectReflector.get(), pContext, pRootSignature, bindRootSig, rootDescIndex)) {\n  250                      return false;\n  ...\n  307  \n  308          auto pProgramKernels = mpProgramVersion->getKernels(this);\n  309:         mpSpecializedReflector = pProgramKernels->getReflector()->getDefaultParameterBlock();\n  310          return false;\n  311      }\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramVars.h:\n   59   protected:\n   60      EntryPointGroupVars(std::shared_ptr<Device> pDevice, const EntryPointGroupReflection::SharedConstPtr& pReflector, uint32_t groupIndexInProgram)\n   61:         : ParameterBlock(pDevice, pReflector->getProgramVersion(), pReflector)\n   62          , mGroupIndexInProgram(groupIndexInProgram)\n   63      {\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ShaderVar.cpp:\n   52              {\n   53              case ReflectionResourceType::Type::ConstantBuffer:\n   54:                 return getParameterBlock()->getRootVar().findMember(name);\n   55              default:\n   56                  break;\n   ..\n   87              {\n   88              case ReflectionResourceType::Type::ConstantBuffer:\n   89:                 return getParameterBlock()->getRootVar().findMember(index);\n   90              default:\n   91                  break;\n   ..\n  157              {\n  158              case ReflectionResourceType::Type::ConstantBuffer:\n  159:                 return getParameterBlock()->getRootVar()[index];\n  160              default:\n  161                  break;\n  ...\n  204              {\n  205              case ReflectionResourceType::Type::ConstantBuffer:\n  206:                 return getParameterBlock()->getRootVar()[offset];\n  207              default:\n  208                  break;\n  ...\n  229              {\n  230              case ReflectionResourceType::Type::ConstantBuffer:\n  231:                 return getParameterBlock()->getRootVar()[loc];\n  232              default:\n  233                  break;\n  ...\n  309      }\n  310  \n  311:     bool ShaderVar::setParameterBlock(const std::shared_ptr<ParameterBlock>& pBlock) const\n  312      {\n  313:         return mpBlock->setParameterBlock(mOffset, pBlock);\n  314      }\n  315  \n  ...\n  331      bool ShaderVar::setImpl(const std::shared_ptr<ParameterBlock>& pBlock) const\n  332      {\n  333:         return mpBlock->setParameterBlock(mOffset, pBlock);\n  334      }\n  335  \n  ...\n  345              {\n  346              case ReflectionResourceType::Type::ConstantBuffer:\n  347:                 return getParameterBlock()->getRootVar().setBlob(data, size);\n  348              default:\n  349                  break;\n  ...\n  374      }\n  375  \n  376:     std::shared_ptr<ParameterBlock> ShaderVar::getParameterBlock() const\n  377      {\n  378:         return mpBlock->getParameterBlock(mOffset);\n  379      }\n  380  \n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ShaderVar.h:\n  235          Logs an error and returns `false` if this variable doesn't point at a parameter block.\n  236      */\n  237:     bool setParameterBlock(const std::shared_ptr<ParameterBlock>& pBlock) const;\n  238  \n  239      /** Get the parameter block that this variable points to.\n  240          Logs an error and returns null if this variable doesn't point at a parameter block.\n  241      */\n  242:     std::shared_ptr<ParameterBlock> getParameterBlock() const;\n  243  \n  244      /** Set the value of the data pointed to by this shader variable.\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightCollection.cpp:\n  329  \n  330              // Bind scene.\n  331:             mIntegrator.pVars[\"gScene\"] = mpScene->getParameterBlock();\n  332  \n  333              // Bind light collection.\n  ...\n  345          {\n  346              // Bind scene.\n  347:             mpFinalizeIntegration[\"gScene\"] = mpScene->getParameterBlock();\n  348  \n  349              mpFinalizeIntegration[\"gTexelSum\"] = mIntegrator.pResultBuffer;\n  ...\n  407  \n  408          // Bind scene.\n  409:         mpTriangleListBuilder[\"gScene\"] = mpScene->getParameterBlock();\n  410  \n  411          // Bind our output buffers.\n  ...\n  439  \n  440          // Bind scene.\n  441:         mpTrianglePositionUpdater[\"gScene\"] = mpScene->getParameterBlock();\n  442  \n  443          // Bind our resources.\n\n/home/max/dev/Falcor/src/Falcor/Scene/ParticleSystem/ParticleSystem.cpp:\n  154  \n  155          // Save bind locations for resourced updated during draw\n  156:         mBindLocations.simulateCB = pSimulateCs->getReflector()->getDefaultParameterBlock()->getResourceBinding(\"PerFrame\");\n  157:         mBindLocations.drawCB = pDrawProgram->getReflector()->getDefaultParameterBlock()->getResourceBinding(\"PerFrame\");\n  158:         mBindLocations.emitCB = pEmitCs->getReflector()->getDefaultParameterBlock()->getResourceBinding(\"PerEmit\");\n  159      }\n  160  \n  ...\n  183  \n  184          //Send vars and call\n  185:         mEmitResources.pVars->getParameterBlock(mBindLocations.emitCB)->setBlob(&emitData, 0u, sizeof(EmitData));\n  186          uint32_t numGroups = div_round_up(num, kParticleEmitThreads);\n  187          pCtx->dispatch(mEmitResources.pState.get(), mEmitResources.pVars.get(), {1, numGroups, 1});\n  ...\n  202              perFrame.dt = dt;\n  203              perFrame.maxParticles = mMaxParticles;\n  204:             mSimulateResources.pVars->getParameterBlock(mBindLocations.simulateCB)->setBlob(&perFrame, 0u, sizeof(SimulateWithSortPerFrame));\n  205              mpAliveList->setBlob(mSortDataReset.data(), 0, sizeof(SortData) * mMaxParticles);\n  206          } else {\n  ...\n  208              perFrame.dt = dt;\n  209              perFrame.maxParticles = mMaxParticles;\n  210:             mSimulateResources.pVars->getParameterBlock(mBindLocations.simulateCB)->setBlob(&perFrame, 0u, sizeof(SimulatePerFrame));\n  211          }\n  212  \n  ...\n  225          cbuf.view = view;\n  226          cbuf.proj = proj;\n  227:         mDrawResources.pVars->getParameterBlock(mBindLocations.drawCB)->setBlob(&cbuf, 0, sizeof(cbuf));\n  228  \n  229          //particle draw uses many of render context's existing state's properties\n\n/home/max/dev/Falcor/src/Falcor/Scene/Scene.cpp:\n  149  \n  150      pState->setVao(mpVao);\n  151:     pVars->setParameterBlock(\"gScene\", mpSceneBlock);\n  152  \n  153      bool overrideRS = !is_set(flags, RenderFlags::UserRasterizerState);\n  ...\n  192      GraphicsProgram::SharedPtr pProgram = GraphicsProgram::createFromFile(mpDevice, \"Scene/SceneBlock.slang\", \"\", \"main\");\n  193      pProgram->addDefines(getSceneDefines());\n  194:     ParameterBlockReflection::SharedConstPtr pReflection = pProgram->getReflector()->getParameterBlock(kParameterBlockName);\n  195  \n  196      assert(pReflection);\n\n/home/max/dev/Falcor/src/Falcor/Scene/Scene.h:\n  336              Note that the camera is not bound automatically.\n  337          */\n  338:         ParameterBlock::ConstSharedPtrRef getParameterBlock() const { return mpSceneBlock; }\n  339  \n  340  #ifdef FALCOR_D3D12\n\n/home/max/dev/Falcor/src/Falcor/Utils/UI/DebugDrawer.cpp:\n  178  \n  179  void DebugDrawer::render(RenderContext* pContext, GraphicsState* pState, GraphicsVars* pVars, Camera *pCamera) {\n  180: //      ParameterBlock* pCB = pVars->getParameterBlock(\"InternalPerFrameCB\").get();\n  181  //      if (pCB != nullptr) pCamera->setShaderData(pCB, 0);\n  182  \n\n/home/max/dev/Falcor/src/Falcor/Utils/UI/Gui.cpp:\n  217          mpLayout->addBufferLayout(0, pBufLayout);\n  218  \n  219:         mGuiImageLoc = mpProgram->getReflector()->getDefaultParameterBlock()->getResourceBinding(\"guiImage\");\n  220      }\n  221  \n\n/home/max/dev/Falcor/src/RenderPasses/BSDFViewer/BSDFViewer.cpp:\n  111          mpViewerPass->getProgram()->addDefines(mpScene->getSceneDefines());\n  112          mpViewerPass->setVars(nullptr); // Trigger vars creation\n  113:         mpViewerPass[\"gScene\"] = mpScene->getParameterBlock();\n  114  \n  115          // Load and bind environment map.\n\n/home/max/dev/Falcor/src/RenderPasses/CSM/CSM.cpp:\n  163      mVisibilityPass.pFbo = Fbo::create(mpDevice);\n  164      mVisibilityPass.pPass = FullScreenPass::create(mpDevice, kVisibilityPassFile);\n  165:     mVisibilityPass.mPassDataOffset = mVisibilityPass.pPass->getVars()->getParameterBlock(\"PerFrameCB\")->getVariableOffset(\"gPass\");\n  166  }\n  167  \n  ...\n  462  \n  463  void CSM::renderScene(RenderContext* pCtx) {\n  464:     auto pCB = mShadowPass.pVars->getParameterBlock(mPerLightCbLoc);\n  465      check_offset(globalMat);\n  466      check_offset(cascadeScale);\n  ...\n  653  \n  654          const auto& pReflector = mShadowPass.pVars->getReflection();\n  655:         const auto& pDefaultBlock = pReflector->getDefaultParameterBlock();\n  656          mPerLightCbLoc = pDefaultBlock->getResourceBinding(\"PerLightCB\");\n  657      } else {\n\n/home/max/dev/Falcor/src/RenderPasses/MegakernelPathTracer/MegakernelPathTracer.cpp:\n  174      // Create parameter block for shared data.\n  175      ProgramReflection::SharedConstPtr pReflection = mTracer.pProgram->getReflector();\n  176:     ParameterBlockReflection::SharedConstPtr pBlockReflection = pReflection->getParameterBlock(kParameterBlockName);\n  177      assert(pBlockReflection);\n  178      mTracer.pParameterBlock = ParameterBlock::create(pBlockReflection);\n  ...\n  188  \n  189      // Bind the parameter block to the global program variables.\n  190:     mTracer.pVars->setParameterBlock(kParameterBlockName, mTracer.pParameterBlock);\n  191  }\n  192  \n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Core/RootBufferParamBlockTests.cpp:\n   64              auto pReflectionProgram = ComputePass::create(reflDesc, defines);\n   65              EXPECT(pReflectionProgram != nullptr);\n   66:             auto pBlockReflection = pReflectionProgram->getProgram()->getReflector()->getParameterBlock(\"gParamBlock\");\n   67              EXPECT(pBlockReflection != nullptr);\n   68              auto pParamBlock = ParameterBlock::create(pBlockReflection);\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Core/UserConstantBufferTests.cpp:\n   58          // Create a parameter block instead to replace the automatically allocated block.\n   59          //auto vars = ctx[\"params\"]; // TODO: Can we get a ParameterBlockReflector from ShaderVar?\n   60:         auto reflector = ctx.getProgram()->getReflector()->getParameterBlock(\"params\");\n   61          auto pCB = ParameterBlock::create(reflector);\n   62          ctx[\"params\"] = pCB;\n\n88 matches across 23 files\n\n\nSearching 1284 files for \"setDefaultParameterBlock\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramReflection.cpp:\n 1063          ParameterBlockReflection::SharedPtr pDefaultBlock = ParameterBlockReflection::createEmpty(pProgramVersion);\n 1064          pDefaultBlock->setElementType(pGlobalStruct);\n 1065:         setDefaultParameterBlock(pDefaultBlock);\n 1066      }\n 1067  \n ....\n 1251  \n 1252          pDefaultBlock->finalize();\n 1253:         setDefaultParameterBlock(pDefaultBlock);\n 1254  \n 1255          auto pProgram = pProgramVersion->getProgram();\n ....\n 1297      }\n 1298  \n 1299:     void ProgramReflection::setDefaultParameterBlock(const ParameterBlockReflection::SharedPtr& pBlock) {\n 1300          mpDefaultBlock = pBlock;\n 1301      }\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramReflection.h:\n 1494      ProgramReflection(ProgramVersion const* pProgramVersion);\n 1495      ProgramReflection(const ProgramReflection&) = default;\n 1496:     void setDefaultParameterBlock(const ParameterBlockReflection::SharedPtr& pBlock);\n 1497  \n 1498      ProgramVersion const* mpProgramVersion;\n\n4 matches across 2 files\n\n\nSearching 1284 files for \"setDefaultParameterBlock\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramReflection.cpp:\n 1019          ParameterBlockReflection::SharedPtr pDefaultBlock = ParameterBlockReflection::createEmpty(pProgramVersion);\n 1020          pDefaultBlock->setElementType(pGlobalStruct);\n 1021:         setDefaultParameterBlock(pDefaultBlock);\n 1022      }\n 1023  \n ....\n 1204  \n 1205          pDefaultBlock->finalize();\n 1206:         setDefaultParameterBlock(pDefaultBlock);\n 1207  \n 1208          auto pProgram = pProgramVersion->getProgram();\n ....\n 1250      }\n 1251  \n 1252:     void ProgramReflection::setDefaultParameterBlock(const ParameterBlockReflection::SharedPtr& pBlock) {\n 1253          mpDefaultBlock = pBlock;\n 1254      }\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramReflection.h:\n 1494      ProgramReflection(ProgramVersion const* pProgramVersion);\n 1495      ProgramReflection(const ProgramReflection&) = default;\n 1496:     void setDefaultParameterBlock(const ParameterBlockReflection::SharedPtr& pBlock);\n 1497  \n 1498      ProgramVersion const* mpProgramVersion;\n\n4 matches across 2 files\n\n\nSearching 1284 files for \"getDefaultParameterBlock\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Buffer.cpp:\n  124      bool createCounter)\n  125  {\n  126:     const auto& pDefaultBlock = pProgram->getReflector()->getDefaultParameterBlock();\n  127      const ReflectionVar* pVar = pDefaultBlock ? pDefaultBlock->getResource(name).get() : nullptr;\n  128      if (pVar == nullptr) {\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12NvApiExDesc.h:\n   85      inline std::optional<uint32_t> findNvApiShaderRegister(ProgramKernels::SharedConstPtr const& pKernels)\n   86      {\n   87:         auto pBlock = pKernels->getReflector()->getDefaultParameterBlock();\n   88          auto pVar = pBlock->getResource(\"g_NvidiaExt\");\n   89          if (!pVar) return std::optional<uint32_t>();\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12RenderContext.cpp:\n   95                  blitData.pPointSampler = Sampler::create(desc);\n   96  \n   97:                 const auto& pDefaultBlockReflection = blitData.pPass->getProgram()->getReflector()->getDefaultParameterBlock();\n   98                  blitData.texBindLoc = pDefaultBlockReflection->getResourceBinding(\"gTex\");\n   99  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/RootSignature.cpp:\n  175      assert(pReflector);\n  176      RootSignature::Desc d;\n  177:     addParamBlockSets(pReflector->getDefaultParameterBlock().get(), d);\n  178:     addRootDescriptors(pReflector->getDefaultParameterBlock().get(), d);\n  179      return RootSignature::create(device, d);\n  180  }\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramReflection.h:\n 1449      /** Get the default (unnamed) parameter block.\n 1450      */\n 1451:     ParameterBlockReflection::SharedConstPtr getDefaultParameterBlock() const { return mpDefaultBlock; }\n 1452  \n 1453      /** For compute-shaders, return the required thread-group size\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramVars.cpp:\n   56  \n   57      ProgramVars::ProgramVars(std::shared_ptr<Device> pDevice, const ProgramReflection::SharedConstPtr& pReflector)\n   58:         : ParameterBlock(pDevice, pReflector->getProgramVersion(), pReflector->getDefaultParameterBlock())\n   59          , mpReflector(pReflector)\n   60      {\n   ..\n  307  \n  308          auto pProgramKernels = mpProgramVersion->getKernels(this);\n  309:         mpSpecializedReflector = pProgramKernels->getReflector()->getDefaultParameterBlock();\n  310          return false;\n  311      }\n\n/home/max/dev/Falcor/src/Falcor/Scene/ParticleSystem/ParticleSystem.cpp:\n  154  \n  155          // Save bind locations for resourced updated during draw\n  156:         mBindLocations.simulateCB = pSimulateCs->getReflector()->getDefaultParameterBlock()->getResourceBinding(\"PerFrame\");\n  157:         mBindLocations.drawCB = pDrawProgram->getReflector()->getDefaultParameterBlock()->getResourceBinding(\"PerFrame\");\n  158:         mBindLocations.emitCB = pEmitCs->getReflector()->getDefaultParameterBlock()->getResourceBinding(\"PerEmit\");\n  159      }\n  160  \n\n/home/max/dev/Falcor/src/Falcor/Utils/UI/Gui.cpp:\n  217          mpLayout->addBufferLayout(0, pBufLayout);\n  218  \n  219:         mGuiImageLoc = mpProgram->getReflector()->getDefaultParameterBlock()->getResourceBinding(\"guiImage\");\n  220      }\n  221  \n\n/home/max/dev/Falcor/src/RenderPasses/CSM/CSM.cpp:\n  653  \n  654          const auto& pReflector = mShadowPass.pVars->getReflection();\n  655:         const auto& pDefaultBlock = pReflector->getDefaultParameterBlock();\n  656          mPerLightCbLoc = pDefaultBlock->getResourceBinding(\"PerLightCB\");\n  657      } else {\n\n13 matches across 9 files\n\n\nSearching 1284 files for \"ProgramVars(\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramVars.cpp:\n   55      }\n   56  \n   57:     ProgramVars::ProgramVars(std::shared_ptr<Device> pDevice, const ProgramReflection::SharedConstPtr& pReflector)\n   58          : ParameterBlock(pDevice, pReflector->getProgramVersion() , pReflector->getDefaultParameterBlock())\n   59          , mpReflector(pReflector)\n   ..\n   74  \n   75      GraphicsVars::GraphicsVars(std::shared_ptr<Device> pDevice, const ProgramReflection::SharedConstPtr& pReflector)\n   76:         : ProgramVars(pDevice, pReflector)\n   77      {\n   78          addSimpleEntryPointGroups();\n   ..\n  107      }\n  108  \n  109:     ComputeVars::ComputeVars(std::shared_ptr<Device> pDevice, const ProgramReflection::SharedConstPtr& pReflector) : ProgramVars(pDevice, pReflector) {\n  110          addSimpleEntryPointGroups();\n  111      }\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramVars.h:\n   91  \n   92   protected:\n   93:     ProgramVars(std::shared_ptr<Device> pDevice, const ProgramReflection::SharedConstPtr& pReflector);\n   94  \n   95      ProgramReflection::SharedConstPtr mpReflector;\n\n/home/max/dev/Falcor/src/Falcor/Raytracing/RtProgramVars.cpp:\n   52      }\n   53      \n   54:     RtProgramVars::RtProgramVars(\n   55          const RtProgram::SharedPtr& pProgram,\n   56          const Scene::SharedPtr& pScene)\n   57:         : ProgramVars(pProgram->getReflector())\n   58          , mpScene(pScene)\n   59      {\n   ..\n   69      RtProgramVars::SharedPtr RtProgramVars::create(const RtProgram::SharedPtr& pProgram, const Scene::SharedPtr& pScene)\n   70      {\n   71:         return SharedPtr(new RtProgramVars(pProgram, pScene));\n   72      }\n   73  \n   ..\n  148      }\n  149  \n  150:     bool applyRtProgramVars(\n  151          uint8_t*                        pRecord,\n  152          const RtEntryPointGroupKernels* pKernels,\n  ...\n  246                  uint8_t* pRecord = mpShaderTable->getRecordPtr(ShaderTable::SubTableType::RayGen, r);\n  247  \n  248:                 if (!applyRtProgramVars(pRecord, pGroupKernels, uniqueGroupIndex, pRtso, pBlock, mpRtVarsHelper.get()))\n  249                  {\n  250                      return false;\n  ...\n  268                  uint8_t* pRecord = mpShaderTable->getRecordPtr(ShaderTable::SubTableType::Hit, h);\n  269  \n  270:                 if (!applyRtProgramVars(pRecord, pGroupKernels, uniqueGroupIndex, pRtso, pBlock, mpRtVarsHelper.get()))\n  271                  {\n  272                      return false;\n  ...\n  288                  uint8_t* pRecord = mpShaderTable->getRecordPtr(ShaderTable::SubTableType::Miss, m);\n  289  \n  290:                 if (!applyRtProgramVars(pRecord, pGroupKernels, uniqueGroupIndex, pRtso, pBlock, mpRtVarsHelper.get()))\n  291                  {\n  292                      return false;\n\n/home/max/dev/Falcor/src/Falcor/Raytracing/RtProgramVars.h:\n   77          using VarsVector = std::vector<EntryPointGroupInfo>;\n   78  \n   79:         RtProgramVars(\n   80              const RtProgram::SharedPtr& pProgram,\n   81              const Scene::SharedPtr& pScene);\n\n12 matches across 4 files\n\n\nSearching 1284 files for \"GraphicsVars::create\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramVars.cpp:\n   77      }\n   78  \n   79:     GraphicsVars::SharedPtr GraphicsVars::create(std::shared_ptr<Device> pDevice, const ProgramReflection::SharedConstPtr& pReflector) {\n   80          if (pReflector == nullptr) {\n   81              throw std::runtime_error(\"Can't create a GraphicsVars object without a program reflector\");\n   ..\n   84      }\n   85  \n   86:     GraphicsVars::SharedPtr GraphicsVars::create(std::shared_ptr<Device> pDevice, const GraphicsProgram* pProg) {\n   87          if (pProg == nullptr) {\n   88              throw std::runtime_error(\"Can't create a GraphicsVars object without a program\");\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightCollection.cpp:\n  326  \n  327              // Specialize the program and re-create the vars.\n  328:             mIntegrator.pVars = GraphicsVars::create(mpDevice, mIntegrator.pProgram.get());\n  329  \n  330              // Bind scene.\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/BasePasses/BaseGraphicsPass.cpp:\n   37      mpState->setProgram(pProg);\n   38  \n   39:     mpVars = GraphicsVars::create(device, pProg.get());\n   40  }\n   41  \n   42  void BaseGraphicsPass::addDefine(const std::string& name, const std::string& value, bool updateVars) {\n   43      mpState->getProgram()->addDefine(name, value);\n   44:     if (updateVars) mpVars = GraphicsVars::create(mpDevice, mpState->getProgram().get());\n   45  }\n   46  \n   47  void BaseGraphicsPass::removeDefine(const std::string& name, bool updateVars) {\n   48      mpState->getProgram()->removeDefine(name);\n   49:     if (updateVars) mpVars = GraphicsVars::create(mpDevice, mpState->getProgram().get());\n   50  }\n   51  \n   52  void BaseGraphicsPass::setVars(const GraphicsVars::SharedPtr& pVars) {\n   53:     mpVars = pVars ? pVars : GraphicsVars::create(mpDevice, mpState->getProgram().get());\n   54  }\n   55  \n\n/home/max/dev/Falcor/src/Falcor/Scene/ParticleSystem/ParticleSystem.cpp:\n  135  \n  136          //draw\n  137:         mDrawResources.pVars = GraphicsVars::create(device, pDrawProgram->getReflector());\n  138          mDrawResources.pVars->setBuffer(\"aliveList\", mpAliveList);\n  139          mDrawResources.pVars->setBuffer(\"particlePool\", mpParticlePool);\n\n/home/max/dev/Falcor/src/Falcor/Utils/UI/Gui.cpp:\n  187          // Create the program\n  188          mpProgram = GraphicsProgram::createFromFile(mpDevice, \"Utils/UI/Gui.slang\", \"vs\", \"ps\");\n  189:         mpProgramVars = GraphicsVars::create(mpDevice, mpProgram->getReflector());\n  190          mpPipelineState->setProgram(mpProgram);\n  191  \n\n/home/max/dev/Falcor/src/RenderPasses/CSM/CSM.cpp:\n  647      if (mpScene) {\n  648          mDepthPass.pProgram->addDefines(mpScene->getSceneDefines());\n  649:         mDepthPass.pVars = GraphicsVars::create(mpDevice, mDepthPass.pProgram->getReflector());\n  650  \n  651          mShadowPass.pProgram->addDefines(mpScene->getSceneDefines());\n  652:         mShadowPass.pVars = GraphicsVars::create(mpDevice, mShadowPass.pProgram->getReflector());\n  653  \n  654          const auto& pReflector = mShadowPass.pVars->getReflection();\n\n/home/max/dev/Falcor/src/RenderPasses/DepthPass/DepthPass.cpp:\n   87      mpScene = pScene;\n   88      if (mpScene) mpState->getProgram()->addDefines(mpScene->getSceneDefines());\n   89:     mpVars = GraphicsVars::create(mpDevice, mpState->getProgram()->getReflector());\n   90  }\n   91  \n\n/home/max/dev/Falcor/src/RenderPasses/ForwardLightingPass/ForwardLightingPass.cpp:\n  111      if (mpScene) mpState->getProgram()->addDefines(mpScene->getSceneDefines());\n  112  \n  113:     mpVars = GraphicsVars::create(pRenderContext->device(), mpState->getProgram()->getReflector());\n  114  \n  115      Sampler::Desc samplerDesc;\n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/GBuffer/GBufferRaster.cpp:\n  184      // Create program vars.\n  185      if (!mRaster.pVars) {\n  186:         mRaster.pVars = GraphicsVars::create(mpDevice, mRaster.pProgram.get());\n  187      }\n  188  \n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/VBuffer/VBufferRaster.cpp:\n  115      // Create program vars.\n  116      if (!mRaster.pVars) {\n  117:         mRaster.pVars = GraphicsVars::create(mpDevice, mRaster.pProgram.get());\n  118      }\n  119  \n\n/home/max/dev/Falcor/src/RenderPasses/SkyBox/SkyBox.cpp:\n   69      mpProgram = GraphicsProgram::createFromFile(pDevice, \"RenderPasses/SkyBox/SkyBox.slang\", \"vs\", \"ps\");\n   70      mpProgram->addDefines(mpCubeScene->getSceneDefines());\n   71:     mpVars = GraphicsVars::create(pDevice, mpProgram->getReflector());\n   72      mpFbo = Fbo::create(pDevice);\n   73  \n\n/home/max/dev/Falcor/src/Samples/ModelViewer/ModelViewer.cpp:\n   67  \n   68      mpProgram->addDefines(mpScene->getSceneDefines());\n   69:     mpProgramVars = GraphicsVars::create(mpProgram->getReflector());\n   70      mpScene->bindSamplerToMaterials(mUseTriLinearFiltering ? mpLinearSampler : mpPointSampler);\n   71      setCamController();\n\n17 matches across 12 files\n\n\nSearching 1284 files for \"getPasses\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraph.h:\n  194          /** Get the dictionary objects used to communicate app data to the render-passes\n  195          */\n  196:         const Dictionary::SharedPtr& getPassesDictionary() const { return mpPassDictionary; }\n  197  \n  198          /** Get the name\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderPassLibrary.cpp:\n  186          DllHandle l = loadDll(fullpath + kPassTempLibSuffix);\n  187          mLibs[fullpath] = { l, getFileModifiedTime(fullpath) };\n  188:         auto func = (LibraryFunc)getDllProcAddress(l, \"getPasses\");\n  189  \n  190          // Add the DLL project directory to the search paths\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderPassLibrary.h:\n   89          void reloadLibraries(RenderContext* pRenderContext);\n   90  \n   91:         /** A render-pass library should implement a function called `getPasses` with the following signature\n   92          */\n   93          using LibraryFunc = void(*)(RenderPassLibrary& lib);\n\n/home/max/dev/Falcor/src/Mogwai/Mogwai.cpp:\n  465  \n  466      // Execute graph.\n  467:     (*pGraph->getPassesDictionary())[kRenderPassRefreshFlags] = (uint32_t)RenderPassRefreshFlags::None;\n  468      pGraph->execute(pRenderContext);\n  469  }\n\n/home/max/dev/Falcor/src/RenderPasses/AccumulatePass/AccumulatePass.cpp:\n   40  }\n   41  \n   42: extern \"C\" falcorexport void getPasses(Falcor::RenderPassLibrary& lib) {\n   43      lib.registerClass(\"AccumulatePass\", \"Temporal accumulation\", AccumulatePass::create);\n   44      ScriptBindings::registerBinding(regAccumulatePass);\n\n/home/max/dev/Falcor/src/RenderPasses/Antialiasing/Antialiasing.cpp:\n   47  }\n   48  \n   49: extern \"C\" falcorexport void getPasses(Falcor::RenderPassLibrary& lib) {\n   50      lib.registerClass(\"FXAA\", \"Fast Approximate Anti-Aliasing\", FXAA::create);\n   51      lib.registerClass(\"TAA\", \"Temporal Anti-Aliasing\", TAA::create);\n\n/home/max/dev/Falcor/src/RenderPasses/BlitPass/BlitPass.cpp:\n   33  }\n   34  \n   35: extern \"C\" falcorexport void getPasses(Falcor::RenderPassLibrary& lib) {\n   36      lib.registerClass(\"BlitPass\", \"Blit a texture into a different texture\", BlitPass::create);\n   37  }\n\n/home/max/dev/Falcor/src/RenderPasses/BSDFViewer/BSDFViewer.cpp:\n   34  }\n   35  \n   36: extern \"C\" falcorexport void getPasses(Falcor::RenderPassLibrary& lib) {\n   37      lib.registerClass(\"BSDFViewer\", BSDFViewer::sDesc, BSDFViewer::create);\n   38  }\n\n/home/max/dev/Falcor/src/RenderPasses/CSM/CSM.cpp:\n   58  }\n   59  \n   60: extern \"C\" falcorexport void getPasses(Falcor::RenderPassLibrary& lib) {\n   61      lib.registerClass(\"CSM\", \"Generates a visibility map for a single light source using the CSM technique\", CSM::create);\n   62      ScriptBindings::registerBinding(regCSM);\n\n/home/max/dev/Falcor/src/RenderPasses/DebugPasses/DebugPasses.cpp:\n   37  }\n   38  \n   39: extern \"C\" falcorexport void getPasses(Falcor::RenderPassLibrary& lib)\n   40  {\n   41      lib.registerClass(\"SplitScreenPass\", \"Allows the user to split the screen between two inputs.\", SplitScreenPass::create);\n\n/home/max/dev/Falcor/src/RenderPasses/DepthPass/DepthPass.cpp:\n   33  }\n   34  \n   35: extern \"C\" falcorexport void getPasses(Falcor::RenderPassLibrary& lib) {\n   36      lib.registerClass(\"DepthPass\", \"Creates a depth-buffer using the scene's active camera\", DepthPass::create);\n   37  }\n\n/home/max/dev/Falcor/src/RenderPasses/ErrorMeasurePass/ErrorMeasurePass.cpp:\n   59  }\n   60  \n   61: extern \"C\" falcorexport void getPasses(Falcor::RenderPassLibrary& lib) {\n   62      lib.registerClass(\"ErrorMeasurePass\", \"Error Measurement Pass\", ErrorMeasurePass::create);\n   63  }\n\n/home/max/dev/Falcor/src/RenderPasses/ForwardLightingPass/ForwardLightingPass.cpp:\n   35  }\n   36  \n   37: extern \"C\" falcorexport void getPasses(Falcor::RenderPassLibrary& lib) {\n   38      lib.registerClass(\"ForwardLightingPass\", \"Computes direct and indirect illumination and applies shadows for the current scene\", ForwardLightingPass::create);\n   39  }\n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/GBuffer/GBufferRaster.h:\n   64  \n   65      static const char* kDesc;\n   66:     friend void getPasses(Falcor::RenderPassLibrary& lib);\n   67  };\n   68  \n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/GBuffer/GBufferRT.h:\n   78      static const char* kDesc;\n   79      static void registerBindings(ScriptBindings::Module& m);\n   80:     friend void getPasses(Falcor::RenderPassLibrary& lib);\n   81  };\n   82  \n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/GBufferBase.cpp:\n   40  }\n   41  \n   42: extern \"C\" falcorexport void getPasses(Falcor::RenderPassLibrary& lib) {\n   43      lib.registerClass(\"GBufferRaster\", GBufferRaster::kDesc, GBufferRaster::create);\n   44      lib.registerClass(\"VBufferRaster\", VBufferRaster::kDesc, VBufferRaster::create);\n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/GBufferBase.h:\n   33  using namespace Falcor;\n   34  \n   35: extern \"C\" falcorexport void getPasses(Falcor::RenderPassLibrary& lib);\n   36  \n   37  /** Base class for the different types of G-buffer passes (including V-buffer).\n   ..\n   69  \n   70      static void registerBindings(ScriptBindings::Module& m);\n   71:     friend void getPasses(Falcor::RenderPassLibrary& lib);\n   72  };\n   73  \n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/VBuffer/VBufferRaster.h:\n   63  \n   64      static const char* kDesc;\n   65:     friend void getPasses(Falcor::RenderPassLibrary& lib);\n   66  };\n   67  \n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/VBuffer/VBufferRT.h:\n   67  \n   68      static const char* kDesc;\n   69:     friend void getPasses(Falcor::RenderPassLibrary& lib);\n   70  };\n   71  \n\n/home/max/dev/Falcor/src/RenderPasses/ImageLoader/ImageLoader.cpp:\n   33  }\n   34  \n   35: extern \"C\" falcorexport void getPasses(Falcor::RenderPassLibrary& lib) {\n   36      lib.registerClass(\"ImageLoader\", \"Load an image into a texture\", ImageLoader::create);\n   37  }\n\n/home/max/dev/Falcor/src/RenderPasses/MegakernelPathTracer/MegakernelPathTracer.cpp:\n   63  }\n   64  \n   65: extern \"C\" __declspec(dllexport) void getPasses(Falcor::RenderPassLibrary& lib)\n   66  {\n   67      lib.registerClass(\"MegakernelPathTracer\", MegakernelPathTracer::sDesc, MegakernelPathTracer::create);\n\n/home/max/dev/Falcor/src/RenderPasses/MinimalPathTracer/MinimalPathTracer.cpp:\n   35  }\n   36  \n   37: extern \"C\" __declspec(dllexport) void getPasses(Falcor::RenderPassLibrary& lib)\n   38  {\n   39      lib.registerClass(\"MinimalPathTracer\", \"Minimal path tracer\", MinimalPathTracer::create);\n\n/home/max/dev/Falcor/src/RenderPasses/PassLibraryTemplate/PassLibraryTemplate.cpp:\n   34  }\n   35  \n   36: extern \"C\" __declspec(dllexport) void getPasses(Falcor::RenderPassLibrary& lib)\n   37  {\n   38      lib.registerClass(\"RenderPassTemplate\", \"Render Pass Template\", RenderPassTemplate::create);\n\n/home/max/dev/Falcor/src/RenderPasses/PixelInspectorPass/PixelInspectorPass.cpp:\n   35  }\n   36  \n   37: extern \"C\" falcorexport void getPasses(Falcor::RenderPassLibrary& lib) {\n   38      lib.registerClass(\"PixelInspectorPass\", \"Per pixel surface attributes inspector\", PixelInspectorPass::create);\n   39  }\n\n/home/max/dev/Falcor/src/RenderPasses/SkyBox/SkyBox.cpp:\n   40  }\n   41  \n   42: extern \"C\" falcorexport void getPasses(Falcor::RenderPassLibrary& lib) {\n   43      lib.registerClass(\"SkyBox\", \"Render an environment map\", SkyBox::create);\n   44      ScriptBindings::registerBinding(regSkyBox);\n\n/home/max/dev/Falcor/src/RenderPasses/SSAO/SSAO.cpp:\n   46  }\n   47  \n   48: extern \"C\" falcorexport void getPasses(Falcor::RenderPassLibrary& lib) {\n   49      lib.registerClass(\"SSAO\", \"Screen-space ambient occlusion\", SSAO::create);\n   50      ScriptBindings::registerBinding(regSSAO);\n\n/home/max/dev/Falcor/src/RenderPasses/SVGFPass/SVGFPass.cpp:\n   79  }\n   80  \n   81: extern \"C\" falcorexport void getPasses(Falcor::RenderPassLibrary& lib) {\n   82      lib.registerClass(\"SVGFPass\", \"SVGF Denoising Pass\", SVGFPass::create);\n   83  }\n\n/home/max/dev/Falcor/src/RenderPasses/TemporalDelayPass/TemporalDelayPass.cpp:\n   37  }\n   38  \n   39: extern \"C\" falcorexport void getPasses(RenderPassLibrary& lib) {\n   40      lib.registerClass(\"TemporalDelayPass\", TemporalDelayPass::kDesc, TemporalDelayPass::create);\n   41      ScriptBindings::registerBinding(regTemporalDelayPass);\n\n/home/max/dev/Falcor/src/RenderPasses/ToneMapper/ToneMapper.cpp:\n  102  }\n  103  \n  104: extern \"C\" falcorexport void getPasses(Falcor::RenderPassLibrary& lib) {\n  105      lib.registerClass(\"ToneMapper\", \"Tone-map a color-buffer\", ToneMapper::create);\n  106      ScriptBindings::registerBinding(regToneMapper);\n\n/home/max/dev/Falcor/src/RenderPasses/Utils/GaussianBlur/GaussianBlur.h:\n   41  #endif\n   42  \n   43: extern \"C\" falcorexport void getPasses(Falcor::RenderPassLibrary& lib);\n   44  \n   45  class dllpassdecl GaussianBlur : public RenderPass, public inherit_shared_from_this<RenderPass, GaussianBlur> {\n   ..\n   79      static const char* kDesc;\n   80      static void registerBindings(ScriptBindings::Module& m);\n   81:     friend void getPasses(Falcor::RenderPassLibrary& lib);\n   82  };\n   83  \n\n/home/max/dev/Falcor/src/RenderPasses/Utils/Utils.cpp:\n   35  }\n   36  \n   37: extern \"C\" falcorexport void getPasses(Falcor::RenderPassLibrary& lib)\n   38  {\n   39      lib.registerClass(\"Composite\", Composite::kDesc, Composite::create);\n\n/home/max/dev/Falcor/src/RenderPasses/WhittedRayTracer/WhittedRayTracer.cpp:\n   65  }\n   66  \n   67: extern \"C\" __declspec(dllexport) void getPasses(Falcor::RenderPassLibrary & lib)\n   68  {\n   69      lib.registerClass(\"WhittedRayTracer\", \"Simple Whitted ray tracer\", WhittedRayTracer::create);\n\n/home/max/dev/Falcor/src/Tools/RenderGraphEditor/RenderGraphEditor.cpp:\n  385              // check for addPasses()\n  386              DllHandle l = loadDll(filename);\n  387:             auto pGetPass = (RenderPassLibrary::LibraryFunc)getDllProcAddress(l, \"getPasses\");\n  388  \n  389              if (pGetPass) {\n\n35 matches across 33 files\n\n\nSearching 1284 files for \"compile\" (case sensitive)\n\n/home/max/dev/Falcor/src/Externals/GLM/CMakeLists.txt:\n   68  \tset(CMAKE_CXX_EXTENSIONS ON)\n   69  \tif((CMAKE_CXX_COMPILER_ID MATCHES \"Clang\") OR (CMAKE_CXX_COMPILER_ID MATCHES \"GNU\"))\n   70: \t\tadd_compile_options(-fms-extensions)\n   71  \tendif()\n   72  \tmessage(STATUS \"GLM: Build with C++ language extensions\")\n   ..\n   74  \tset(CMAKE_CXX_EXTENSIONS OFF)\n   75  \tif(CMAKE_CXX_COMPILER_ID MATCHES \"MSVC\")\n   76: \t\tadd_compile_options(/Za)\n   77  \t\tif(MSVC15)\n   78: \t\t\tadd_compile_options(/permissive-)\n   79  \t\tendif()\n   80  \tendif()\n   ..\n   88  \n   89  \tif((CMAKE_CXX_COMPILER_ID MATCHES \"Clang\") OR (CMAKE_CXX_COMPILER_ID MATCHES \"GNU\"))\n   90: \t\tadd_compile_options(-ffast-math)\n   91  \n   92  \telseif(CMAKE_CXX_COMPILER_ID MATCHES \"MSVC\")\n   93: \t\tadd_compile_options(/fp:fast)\n   94  \tendif()\n   95  else()\n   96  \tif(CMAKE_CXX_COMPILER_ID MATCHES \"MSVC\")\n   97: \t\tadd_compile_options(/fp:precise)\n   98  \tendif()\n   99  endif()\n  ...\n  113  \n  114  \tif(CMAKE_CXX_COMPILER_ID MATCHES \"GNU\")\n  115: \t\tadd_compile_options(-mfpmath=387)\n  116  \tendif()\n  117  \tmessage(STATUS \"GLM: No SIMD instruction set\")\n  ...\n  119  elseif(GLM_TEST_ENABLE_SIMD_AVX2)\n  120  \tif((CMAKE_CXX_COMPILER_ID MATCHES \"GNU\") OR (CMAKE_CXX_COMPILER_ID MATCHES \"Clang\"))\n  121: \t\tadd_compile_options(-mavx2)\n  122  \telseif(CMAKE_CXX_COMPILER_ID MATCHES \"Intel\")\n  123: \t\tadd_compile_options(/QxAVX2)\n  124  \telseif(CMAKE_CXX_COMPILER_ID MATCHES \"MSVC\")\n  125: \t\tadd_compile_options(/arch:AVX2)\n  126  \tendif()\n  127  \tmessage(STATUS \"GLM: AVX2 instruction set\")\n  ...\n  129  elseif(GLM_TEST_ENABLE_SIMD_AVX)\n  130  \tif((CMAKE_CXX_COMPILER_ID MATCHES \"GNU\") OR (CMAKE_CXX_COMPILER_ID MATCHES \"Clang\"))\n  131: \t\tadd_compile_options(-mavx)\n  132  \telseif(CMAKE_CXX_COMPILER_ID MATCHES \"Intel\")\n  133: \t\tadd_compile_options(/QxAVX)\n  134  \telseif(CMAKE_CXX_COMPILER_ID MATCHES \"MSVC\")\n  135: \t\tadd_compile_options(/arch:AVX)\n  136  \tendif()\n  137  \tmessage(STATUS \"GLM: AVX instruction set\")\n  ...\n  139  elseif(GLM_TEST_ENABLE_SIMD_SSE4_2)\n  140  \tif((CMAKE_CXX_COMPILER_ID MATCHES \"GNU\") OR (CMAKE_CXX_COMPILER_ID MATCHES \"Clang\"))\n  141: \t\tadd_compile_options(-msse4.2)\n  142  \telseif(CMAKE_CXX_COMPILER_ID MATCHES \"Intel\")\n  143: \t\tadd_compile_options(/QxSSE4.2)\n  144  \telseif((CMAKE_CXX_COMPILER_ID MATCHES \"MSVC\") AND NOT CMAKE_CL_64)\n  145: \t\tadd_compile_options(/arch:SSE2) # VC doesn't support SSE4.2\n  146  \tendif()\n  147  \tmessage(STATUS \"GLM: SSE4.2 instruction set\")\n  ...\n  149  elseif(GLM_TEST_ENABLE_SIMD_SSE4_1)\n  150  \tif((CMAKE_CXX_COMPILER_ID MATCHES \"GNU\") OR (CMAKE_CXX_COMPILER_ID MATCHES \"Clang\"))\n  151: \t\tadd_compile_options(-msse4.1)\n  152  \telseif(CMAKE_CXX_COMPILER_ID MATCHES \"Intel\")\n  153: \t\tadd_compile_options(/QxSSE4.1)\n  154  \telseif((CMAKE_CXX_COMPILER_ID MATCHES \"MSVC\") AND NOT CMAKE_CL_64)\n  155: \t\tadd_compile_options(/arch:SSE2) # VC doesn't support SSE4.1\n  156  \tendif()\n  157  \tmessage(STATUS \"GLM: SSE4.1 instruction set\")\n  ...\n  159  elseif(GLM_TEST_ENABLE_SIMD_SSSE3)\n  160  \tif((CMAKE_CXX_COMPILER_ID MATCHES \"GNU\") OR (CMAKE_CXX_COMPILER_ID MATCHES \"Clang\"))\n  161: \t\tadd_compile_options(-mssse3)\n  162  \telseif(CMAKE_CXX_COMPILER_ID MATCHES \"Intel\")\n  163: \t\tadd_compile_options(/QxSSSE3)\n  164  \telseif((CMAKE_CXX_COMPILER_ID MATCHES \"MSVC\") AND NOT CMAKE_CL_64)\n  165: \t\tadd_compile_options(/arch:SSE2) # VC doesn't support SSSE3\n  166  \tendif()\n  167  \tmessage(STATUS \"GLM: SSSE3 instruction set\")\n  ...\n  169  elseif(GLM_TEST_ENABLE_SIMD_SSE3)\n  170  \tif((CMAKE_CXX_COMPILER_ID MATCHES \"GNU\") OR (CMAKE_CXX_COMPILER_ID MATCHES \"Clang\"))\n  171: \t\tadd_compile_options(-msse3)\n  172  \telseif(CMAKE_CXX_COMPILER_ID MATCHES \"Intel\")\n  173: \t\tadd_compile_options(/QxSSE3)\n  174  \telseif((CMAKE_CXX_COMPILER_ID MATCHES \"MSVC\") AND NOT CMAKE_CL_64)\n  175: \t\tadd_compile_options(/arch:SSE2) # VC doesn't support SSE3\n  176  \tendif()\n  177  \tmessage(STATUS \"GLM: SSE3 instruction set\")\n  ...\n  179  elseif(GLM_TEST_ENABLE_SIMD_SSE2)\n  180  \tif((CMAKE_CXX_COMPILER_ID MATCHES \"GNU\") OR (CMAKE_CXX_COMPILER_ID MATCHES \"Clang\"))\n  181: \t\tadd_compile_options(-msse2)\n  182  \telseif(CMAKE_CXX_COMPILER_ID MATCHES \"Intel\")\n  183: \t\tadd_compile_options(/QxSSE2)\n  184  \telseif((CMAKE_CXX_COMPILER_ID MATCHES \"MSVC\") AND NOT CMAKE_CL_64)\n  185: \t\tadd_compile_options(/arch:SSE2)\n  186  \tendif()\n  187  \tmessage(STATUS \"GLM: SSE2 instruction set\")\n  ...\n  192  if(CMAKE_CXX_COMPILER_ID MATCHES \"Clang\")\n  193  \tif(NOT GLM_QUIET)\n  194: \t\tmessage(\"GLM: Clang - ${CMAKE_CXX_COMPILER_ID} compiler\")\n  195  \tendif()\n  196  \n  197: \tadd_compile_options(-Werror -Weverything)\n  198: \tadd_compile_options(-Wno-c++98-compat -Wno-c++98-compat-pedantic -Wno-c++11-long-long -Wno-padded -Wno-gnu-anonymous-struct -Wno-nested-anon-types)\n  199: \tadd_compile_options(-Wno-undefined-reinterpret-cast -Wno-sign-conversion -Wno-unused-variable -Wno-missing-prototypes -Wno-unreachable-code -Wno-missing-variable-declarations -Wno-sign-compare -Wno-global-constructors -Wno-unused-macros -Wno-format-nonliteral)\n  200  \n  201  elseif(CMAKE_CXX_COMPILER_ID MATCHES \"GNU\")\n  202  \tif(NOT GLM_QUIET)\n  203: \t\tmessage(\"GLM: GCC - ${CMAKE_CXX_COMPILER_ID} compiler\")\n  204  \tendif()\n  205  \n  206: \tadd_compile_options(-O2)\n  207: \tadd_compile_options(-Wno-long-long)\n  208  \n  209  elseif(CMAKE_CXX_COMPILER_ID MATCHES \"Intel\")\n  210  \tif(NOT GLM_QUIET)\n  211: \t\tmessage(\"GLM: Intel - ${CMAKE_CXX_COMPILER_ID} compiler\")\n  212  \tendif()\n  213  \n  214  elseif(CMAKE_CXX_COMPILER_ID MATCHES \"MSVC\")\n  215  \tif(NOT GLM_QUIET)\n  216: \t\tmessage(\"GLM: Visual C++ - ${CMAKE_CXX_COMPILER_ID} compiler\")\n  217  \tendif()\n  218  \n  219: \tadd_compile_options(/W4 /WX)\n  220: \tadd_compile_options(/wd4309 /wd4324 /wd4389 /wd4127 /wd4267 /wd4146 /wd4201 /wd4464 /wd4514 /wd4701 /wd4820 /wd4365)\n  221  \tadd_definitions(-D_CRT_SECURE_NO_WARNINGS)\n  222  endif()\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/common.hpp:\n  373  \t/// representations.\n  374  \t///\n  375: \t/// /!\\ When using compiler fast math, this function may fail.\n  376  \t///\n  377  \t/// @tparam L Integer between 1 and 4 included that qualify the dimension of the vector\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/_swizzle.hpp:\n   12  \t\tGLM_FUNC_QUALIFIER T const& elem(size_t i) const{ return (reinterpret_cast<const T*>(_buffer))[i]; }\n   13  \n   14: \t\t// Use an opaque buffer to *ensure* the compiler doesn't call a constructor.\n   15  \t\t// The size 1 buffer is assumed to aligned to the actual members so that the\n   16  \t\t// elem()\n   ..\n  286  \t// Swizzles are distinct types from the unswizzled type.  The below macros will\n  287  \t// provide template specializations for the swizzle types for the given functions\n  288: \t// so that the compiler does not have any ambiguity to choosing how to handle\n  289  \t// the function.\n  290  \t//\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/func_common.inl:\n  401  \t{\n  402  #\t\tif GLM_COMPILER & GLM_COMPILER_CUDA\n  403: \t\t\t// Another Cuda compiler bug https://github.com/g-truc/glm/issues/530\n  404  \t\t\tvec<1, genType, defaultp> Result(mod(vec<1, genType, defaultp>(x), y));\n  405  \t\t\treturn Result.x;\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/setup.hpp:\n   45  \n   46  #if !defined(GLM_MODEL) && GLM_COMPILER != 0\n   47: #\terror \"GLM_MODEL undefined, your compiler may not be supported by GLM. Add #define GLM_MODEL 0 to ignore this message.\"\n   48  #endif//GLM_MODEL\n   49  \n   ..\n  616  \t\ttypedef unsigned long long\t\t\t\t\tuint64;\n  617  \t\ttypedef signed long long\t\t\t\t\tint64;\n  618: #\telse//unknown compiler\n  619  \t\ttypedef unsigned long long\t\t\t\t\tuint64;\n  620  \t\ttypedef signed long long\t\t\t\t\tint64;\n  ...\n  882  #\tendif//GLM_LANG\n  883  \n  884: \t// Report compiler detection\n  885  #\tif GLM_COMPILER & GLM_COMPILER_CUDA\n  886: #\t\tpragma message(\"GLM: CUDA compiler detected\")\n  887  #\telif GLM_COMPILER & GLM_COMPILER_VC\n  888: #\t\tpragma message(\"GLM: Visual C++ compiler detected\")\n  889  #\telif GLM_COMPILER & GLM_COMPILER_CLANG\n  890: #\t\tpragma message(\"GLM: Clang compiler detected\")\n  891  #\telif GLM_COMPILER & GLM_COMPILER_INTEL\n  892  #\t\tpragma message(\"GLM: Intel Compiler detected\")\n  893  #\telif GLM_COMPILER & GLM_COMPILER_GCC\n  894: #\t\tpragma message(\"GLM: GCC compiler detected\")\n  895  #\telse\n  896  #\t\tpragma message(\"GLM: Compiler not detected\")\n  ...\n  995  #\t\tpragma message(\"GLM: GLM_FORCE_SWIZZLE is defined, swizzling operators enabled\")\n  996  #\telif GLM_CONFIG_SWIZZLE == GLM_SWIZZLE_FUNCTION\n  997: #\t\tpragma message(\"GLM: GLM_FORCE_SWIZZLE is defined, swizzling functions enabled. Enable compiler C++ language extensions to enable swizzle operators.\")\n  998  #\telse\n  999  #\t\tpragma message(\"GLM: GLM_FORCE_SWIZZLE is undefined. swizzling functions or operators are disabled.\")\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/quaternion_common.hpp:\n   97  \t/// representations.\n   98  \t///\n   99: \t/// /!\\ When using compiler fast math, this function may fail.\n  100  \t///\n  101  \t/// @tparam T A floating-point scalar type\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/fast_square_root.inl:\n   22  \tGLM_FUNC_QUALIFIER genType fastInverseSqrt(genType x)\n   23  \t{\n   24: #\t\tifdef __CUDACC__ // Wordaround for a CUDA compiler bug up to CUDA6\n   25  \t\t\tvec<1, T, Q> tmp(detail::compute_inversesqrt<tvec1, genType, lowp, detail::is_aligned<lowp>::value>::call(vec<1, genType, lowp>(x)));\n   26  \t\t\treturn tmp.x;\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/gtx/string_cast.hpp:\n   30  \n   31  #if(GLM_COMPILER & GLM_COMPILER_CUDA)\n   32: #\terror \"GLM_GTX_string_cast is not supported on CUDA compiler\"\n   33  #endif\n   34  \n\n/home/max/dev/Falcor/src/Externals/GLM/glm/simd/platform.h:\n   95  #define GLM_MODEL_64\t\t\t\t0x00000020\n   96  \n   97: // Force generic C++ compiler\n   98  #ifdef GLM_FORCE_COMPILER_UNKNOWN\n   99  #\tdefine GLM_COMPILER GLM_COMPILER_UNKNOWN\n  ...\n  212  \n  213  #ifndef GLM_COMPILER\n  214: #\terror \"GLM_COMPILER undefined, your compiler may not be supported by GLM. Add #define GLM_COMPILER 0 to ignore this message.\"\n  215  #endif//GLM_COMPILER\n  216  \n\n/home/max/dev/Falcor/src/Externals/GLM/readme.md:\n    9  This library works perfectly with *[OpenGL](https://www.opengl.org)* but it also ensures interoperability with other third party libraries and SDK. It is a good candidate for software rendering (raytracing / rasterisation), image processing, physic simulations and any development context that requires a simple and convenient mathematics library.\n   10  \n   11: *GLM* is written in C++98 but can take advantage of C++11 when supported by the compiler. It is a platform independent library with no dependence and it officially supports the following compilers:\n   12  - [Apple Clang 6.0](https://developer.apple.com/library/mac/documentation/CompilerTools/Conceptual/LLVMCompilerOverview/index.html) and higher\n   13  - [GCC](http://gcc.gnu.org/) 4.7 and higher\n   14: - [Intel C++ Composer](https://software.intel.com/en-us/intel-compilers) XE 2013 and higher\n   15  - [LLVM](http://llvm.org/) 3.4 and higher\n   16  - [Visual C++](http://www.visualstudio.com/) 2013 and higher\n   17  - [CUDA](https://developer.nvidia.com/about-cuda) 7.0 and higher (experimental)\n   18: - Any C++11 compiler\n   19  \n   20  For more information about *GLM*, please have a look at the [manual](manual.md) and the [API reference documentation](http://glm.g-truc.net/0.9.8/api/index.html).\n   ..\n   95  - Added RGBM encoding in GTC_packing #420\n   96  - Added GTX_color_encoding extension\n   97: - Added GTX_vec_swizzle, faster compile time swizzling then swizzle operator #558\n   98  - Added GTX_exterior_product with a vec2 cross implementation #621\n   99  - Added GTX_matrix_factorisation to factor matrices in various forms #654\n  ...\n  154  \n  155  #### Deprecation:\n  156: - Requires Visual Studio 2013, GCC 4.7, Clang 3.4, Cuda 7, ICC 2013 or a C++11 compiler\n  157  - Removed GLM_GTX_simd_vec4 extension\n  158  - Removed GLM_GTX_simd_mat4 extension\n  ...\n  182  - Fixed POPCNT optimization build in Clang #512\n  183  - Fixed intersectRayPlane returns true in parallel case #578\n  184: - Fixed GCC 6.2 compiler warnings #580\n  185  - Fixed GTX_matrix_decompose decompose #582 #448\n  186  - Fixed GCC 4.5 and older build #566\n  ...\n  194  \n  195  #### Fixes:\n  196: - Fixed Android build error with C++11 compiler but C++98 STL #284 #564\n  197  - Fixed GTX_transform2 shear* functions #403\n  198  - Fixed interaction between GLM_FORCE_UNRESTRICTED_GENTYPE and ortho function #568\n  ...\n  205  - Added Visual C++ 15 detection\n  206  - Added Clang 4.0 detection\n  207: - Added warning messages when using GLM_FORCE_CXX** but the compiler\n  208    is known to not fully support the requested C++ version #555\n  209  - Refactored GLM_COMPILER_VC values\n  ...\n  256  - Added MIPS CPUs detection\n  257  - Added PowerPC CPUs detection\n  258: - Use Cuda built-in function for abs function implementation with Cuda compiler\n  259  - Factorized GLM_COMPILER_LLVM and GLM_COMPILER_APPLE_CLANG into GLM_COMPILER_CLANG\n  260  - No more warnings for use of long long\n  ...\n  284  #### Improvements:\n  285  - Added pkg-config file #509\n  286: - Updated list of compiler versions detected\n  287  - Improved C++ 11 STL detection #523\n  288  \n  ...\n  352  #### Fixes:\n  353  - Fixed strict alignment warnings #235 #370\n  354: - Fixed link errors on compilers not supported default function #377\n  355  - Fixed compilation warnings in vec4\n  356  - Fixed non-identity quaternions for equal vectors #234\n  ...\n  374  \n  375  #### Improvements:\n  376: - Changed usage of __has_include to support Intel compiler #307\n  377  - Specialized integer implementation of YCoCg-R #310\n  378  - Don't show status message in 'FindGLM' if 'QUIET' option is set. #317\n  379  - Added master branch continuous integration service on Linux 64 #332\n  380  - Clarified manual regarding angle unit in GLM, added FAQ 11 #326\n  381: - Updated list of compiler versions\n  382  \n  383  #### Fixes:\n  ...\n  388  - Fixed perspective fovy argument documentation #327\n  389  - Removed -m64 causing build issues on Linux 32 #331\n  390: - Fixed isfinite with C++98 compilers #343\n  391: - Fixed Intel compiler build error on Linux #354\n  392  - Fixed use of libstdc++ with Clang #351\n  393  - Fixed quaternion pow #346\n  ...\n  441  - Fixed C++11 explicit conversion operators detection #282\n  442  - Fixed missing explicit conversion when using integer log2 with *vec1 types\n  443: - Fixed 64 bits integer GTX_string_cast to_string on VC 32 bit compiler\n  444  - Fixed Android build issue, STL C++11 is not supported by the NDK #284\n  445  - Fixed unsupported _BitScanForward64 and _BitScanReverse64 in VC10\n  ...\n  454  #### Features:\n  455  - Exposed template vector and matrix types in 'glm' namespace #239, #244\n  456: - Added GTX_scalar_multiplication for C++ 11 compiler only #242\n  457: - Added GTX_range for C++ 11 compiler only #240\n  458  - Added closestPointOnLine function for tvec2 to GTX_closest_point #238\n  459  - Added GTC_vec1 extension, *vec1 support to *vec* types\n  ...\n  475  - Rely on C++11 to implement isinf and isnan\n  476  - Removed GLM_FORCE_CUDA, Cuda is implicitly detected\n  477: - Separated Apple Clang and LLVM compiler detection\n  478  - Used pragma once\n  479: - Undetected C++ compiler automatically compile with GLM_FORCE_CXX98 and \n  480    GLM_FORCE_PURE\n  481  - Added not function (from GLSL specification) on VC12\n  ...\n  497  - Fixed return type of dual quaternion length\n  498  - Fixed infinite loop in isfinite function with GCC #221\n  499: - Fixed Visual Studio 14 compiler warnings\n  500  - Fixed implicit conversion from another tvec2 type to another tvec2 #241\n  501  - Fixed lack of consistency of quat and dualquat constructors\n  ...\n  504  \n  505  #### Deprecation:\n  506: - Requires Visual Studio 2010, GCC 4.2, Apple Clang 4.0, LLVM 3.0, Cuda 4, ICC 2013 or a C++98 compiler\n  507  - Removed degrees for function parameters\n  508  - Removed GLM_FORCE_RADIANS, active by default\n  ...\n  537  ### GLM 0.9.5.3 - 2014-04-02\n  538  - Added instruction set auto detection with Visual C++ using _M_IX86_FP - /arch\n  539:   compiler argument\n  540  - Fixed GTX_raw_data code dependency\n  541  - Fixed GCC instruction set detection\n  ...\n  548  - Fixed eulerAngle*** not consistent for right-handed coordinate system (#173)\n  549  - Added full tests for eulerAngle*** functions (#173)\n  550: - Added workaround for a CUDA compiler bug (#186, #185)\n  551  \n  552  ---\n  ...\n  592  - Fixed perspective with zNear == 0 (#71)\n  593  - Removed l-value swizzle operators\n  594: - Cleaned up compiler detection code for unsupported compilers\n  595  - Replaced C cast by C++ casts\n  596  - Fixed .length() that should return a int and not a size_t\n  ...\n  616  ---\n  617  ### [GLM 0.9.4.6](https://github.com/g-truc/glm/releases/tag/0.9.4.6) - 2013-09-20\n  618: - Fixed detection to select the last known compiler if newer version #106\n  619  - Fixed is_int and is_uint code duplication with GCC and C++11 #107 \n  620  - Fixed test suite build while using Clang in C++11 mode\n  ...\n  624  - Added use of GCC frontend on Unix for ICC and Visual C++ fronted on Windows\n  625    for ICC\n  626: - Added compilation errors for unsupported compiler versions\n  627  - Fixed glm::orientation with GLM_FORCE_RADIANS defined #112\n  628  - Fixed const ref issue on assignment operator taking a scalar parameter #116\n  ...\n  667  ### GLM 0.9.4.2 - 2013-02-14\n  668  - Fixed compAdd from GTX_component_wise\n  669: - Fixed SIMD support for Intel compiler on Windows\n  670: - Fixed isnan and isinf for CUDA compiler\n  671  - Fixed GLM_FORCE_RADIANS on glm::perspective\n  672  - Fixed GCC warnings\n  ...\n  699  - Fixed detection of Clang and LLVM GCC on MacOS X\n  700  - Added debugger visualizers for Visual C++ 2012\n  701: - Requires Visual Studio 2005, GCC 4.2, Clang 2.6, Cuda 3, ICC 2013 or a C++98 compiler\n  702  \n  703  ---\n  ...\n  705  - Added SSE4 and AVX2 detection.\n  706  - Removed VIRTREV_xstream and the incompatibility generated with GCC\n  707: - Fixed C++11 compiler option for GCC\n  708  - Removed MS language extension option for GCC (not fonctionnal)\n  709  - Fixed bitfieldExtract for vector types\n  ...\n  714  ### GLM 0.9.3.3 - 2012-05-10\n  715  - Fixed isinf and isnan\n  716: - Improved compatibility with Intel compiler\n  717  - Added CMake test build options: SIMD, C++11, fast math and MS land ext\n  718  - Fixed SIMD mat4 test on GCC\n  ...\n  757  ### GLM 0.9.3.A - 2011-11-11\n  758  - Improved doxygen documentation\n  759: - Added new swizzle operators for C++11 compilers\n  760  - Added new swizzle operators declared as functions\n  761  - Added GLSL 4.20 length for vector and matrix types\n  ...\n  798  - Expend matrix constructors flexibility\n  799  - Improved quaternion implementation\n  800: - Fixed many warnings across platforms and compilers\n  801  \n  802  ---\n  803  ### GLM 0.9.2.1 - 2011-05-24\n  804  - Automatically detect CUDA support\n  805: - Improved compiler detection\n  806  - Fixed errors and warnings in VC with C++ extensions disabled\n  807  - Fixed and tested GLM_GTX_vector_angle\n  ...\n 1056  ### GLM 0.6.0 : 2007-09-16\n 1057  - Added new extension namespace mecanium\n 1058: - Added Automatic compiler detection\n 1059  \n 1060  ---\n\n/home/max/dev/Falcor/src/Falcor/CMakeLists.txt:\n   87  PKG_CHECK_MODULES(GTK3 REQUIRED gtk+-3.0)\n   88  \n   89: # Setup CMake to use GTK+, tell the compiler where to look for headers\n   90  # and to the linker where to look for libraries\n   91  INCLUDE_DIRECTORIES(${GTK3_INCLUDE_DIRS})\n   92  LINK_DIRECTORIES(${GTK3_LIBRARY_DIRS})\n   93  \n   94: # Add other flags to the compiler\n   95  ADD_DEFINITIONS(${GTK3_CFLAGS_OTHER})\n   96  \n\n/home/max/dev/Falcor/src/Falcor/Core/BufferTypes/ParameterBlock.h:\n  316      ParameterBlock::ConstSharedPtrRef getParameterBlock(uint32_t resourceRangeIndex, uint32_t arrayIndex) const;\n  317  \n  318:     // Delete some functions. If they are not deleted, the compiler will try to convert the uints to string, resulting in runtime error\n  319      Sampler::SharedPtr getSampler(uint32_t) = delete;\n  320      bool setSampler(uint32_t, const Sampler::SharedPtr&) = delete;\n\n/home/max/dev/Falcor/src/Falcor/Core/Framework.h:\n   29  #define SRC_FALCOR_CORE_FRAMEWORK_H_\n   30  \n   31: // save compiler switches\n   32  #pragma GCC diagnostic push\n   33  #pragma GCC diagnostic ignored \"-Wpedantic\"\n   ..\n  374  #endif\n  375  \n  376: // restore compiler switches\n  377  #pragma GCC diagnostic pop\n  378  \n\n/home/max/dev/Falcor/src/Falcor/Core/Program/Program.cpp:\n  280          if (it == mProgramVersions.end()) {\n  281              // Note that link() updates mActiveProgram only if the operation was successful.\n  282:             // On error we get false, and mActiveProgram points to the last successfully compiled version.\n  283              if (link() == false) {\n  284                  throw std::runtime_error(\"Program linkage failed\");\n  ...\n  367      }\n  368  \n  369:     // Set floating point mode. If no shader compiler flags for this were set, we use Slang's default mode.\n  370      bool flagFast = is_set(mDesc.getCompilerFlags(), Shader::CompilerFlags::FloatingPointModeFast);\n  371      bool flagPrecise = is_set(mDesc.getCompilerFlags(), Shader::CompilerFlags::FloatingPointModePrecise);\n  372      \n  373      if (flagFast && flagPrecise) {\n  374:         logWarning(\"Shader compiler flags 'FloatingPointModeFast' and 'FloatingPointModePrecise' can't be used simultaneously. Ignoring 'FloatingPointModeFast'.\");\n  375          flagFast = false;\n  376      }\n  ...\n  465      SlangCompileFlags slangFlags = 0;\n  466  \n  467:     // When we invoke the Slang compiler front-end, skip code generation step\n  468:     // so that the compiler does not complain about missing arguments for\n  469      // specialization parameters.\n  470      //\n  ...\n  694          auto entryPointGroupDesc = mDesc.mGroups[gg];\n  695  \n  696:         // For each entry-point group we will collect the compiled kernel\n  697          // code for its constituent entry points, using the \"linked\"\n  698          // version of the entry-point group.\n  ...\n  905  \n  906          // If any files have changed, then we need to reset\n  907:         // the caches of compiled information for the program.\n  908          //\n  909          pProgram->reset();\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/Program.h:\n   94  \n   95          /** Set the shader model string. This depends on the API you are using.\n   96:             For DirectX it should be `4_0`, `4_1`, `5_0`, `5_1`, `6_0`, `6_1`, `6_2`, or `6_3`. The default is `6_0`. Shader model `6.x` will use dxcompiler, previous shader models use fxc.\n   97              For Vulkan, it should be `400`, `410`, `420`, `430`, `440` or `450`. The default is `450`\n   98          */\n   99          Desc& setShaderModel(const std::string& sm);\n  100  \n  101:         /** Get the compiler flags\n  102          */\n  103          Shader::CompilerFlags getCompilerFlags() const { return mShaderFlags; }\n  104  \n  105:         /** Set the compiler flags. Replaces any previously set flags.\n  106          */\n  107          Desc& setCompilerFlags(Shader::CompilerFlags flags) { mShaderFlags = flags; return *this; }\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramVersion.h:\n  259          std::vector<ComPtr<slang::IComponentType>> mpSlangEntryPoints;\n  260  \n  261:         // Cached version of compiled kernels for this program version\n  262          mutable std::unordered_map<std::string, ProgramKernels::SharedPtr> mpKernels;\n  263      };\n\n/home/max/dev/Falcor/src/Falcor/Core/type.h:\n   50  \n   51  //DUPLICATED CODE (1/2). It is obviously possible to get rid of duplicates, \n   52: //                       but it is currently unclear how it may affect performance of the compiled code, so for now we prefer it this way \n   53  template<class TA, class TB>\n   54  inline constexpr bool lt(TA a, TB b) {\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/EmissiveLightSampler.h:\n   48          virtual bool update(RenderContext* pRenderContext) { return false; }\n   49  \n   50:         /** Add compile-time specialization to program to use this light sampler.\n   51              This function must be called every frame before the sampler is bound.\n   52              Note that ProgramVars may need to be re-created after this call, check the return value.\n   53:             \\param[in] pProgram The Program to add compile-time specialization to.\n   54              \\return True if the ProgramVars needs to be re-created.\n   55          */\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVH.cpp:\n  361  \n  362      void LightBVH::verifyStaticParams() {\n  363:         // Check at compile time all the offsets defined in LightBVHStaticParams for InternalNode.\n  364          static_assert(kNodeTypeOffset            == offsetof(InternalNode, nodeType));\n  365          static_assert(kNodeAABBMinOffset         == offsetof(InternalNode, aabbMin));\n  ...\n  371          static_assert(kNodeRightByteOffsetOffset == offsetof(InternalNode, rightNodeOffset));\n  372  \n  373:         // Check at compile time all the offsets defined in LightBVHStaticParams for LeafNode.\n  374          static_assert(kNodeTypeOffset            == offsetof(LeafNode, nodeType));\n  375          static_assert(kNodeAABBMinOffset         == offsetof(LeafNode, aabbMin));\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVHSampler.h:\n   86          virtual bool update(RenderContext* pRenderContext) override;\n   87  \n   88:         /** Add compile-time specialization to program to use this light sampler.\n   89              This function must be called every frame before the sampler is bound.\n   90              Note that ProgramVars may need to be re-created after this call, check the return value.\n   91:             \\param[in] pProgram The Program to add compile-time specialization to.\n   92              \\return True if the ProgramVars needs to be re-created.\n   93          */\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVHSampler.slang:\n   40  // TODO: Use precise keyword at appropriate places.\n   41  \n   42: // Make sure the implementation compiles even when sampler is not used.\n   43  #ifndef _ACTUAL_MAX_TRIANGLES_PER_NODE\n   44  #define _ACTUAL_MAX_TRIANGLES_PER_NODE 1\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Material/MaterialShading.slang:\n   92      Note: The evaluated pdf for the generated sample is expensive to compute, as the pdf is a weighted\n   93      combination of two sampling strategies. If the caller doesn't explicitly need the probability, they\n   94:     should be careful not to touch the value so that the compiler can do dead code elimination.\n   95  \n   96      \\param[in] sd Shading point data.\n   ..\n  523      Note: The evaluated pdf for the generated sample is expensive to compute, as the pdf is a weighted\n  524      combination of two sampling strategies. If the caller doesn't explicitly need the probability, they\n  525:     should be careful not to touch the value so that the compiler can do dead code elimination.\n  526  \n  527      \\param[in] sd Shading point data.\n\n/home/max/dev/Falcor/src/Falcor/Falcor.vcxproj:\n  287    <ItemGroup>\n  288      <ClCompile Include=\"..\\Externals\\.packman\\dear_imgui\\imgui.cpp\">\n  289:       <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseD3D12|x64'\">NotUsing</PrecompiledHeader>\n  290:       <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugVK|x64'\">NotUsing</PrecompiledHeader>\n  291:       <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseVK|x64'\">NotUsing</PrecompiledHeader>\n  292:       <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugD3D12|x64'\">NotUsing</PrecompiledHeader>\n  293      </ClCompile>\n  294      <ClCompile Include=\"..\\Externals\\.packman\\dear_imgui\\imgui_draw.cpp\">\n  295:       <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseD3D12|x64'\">NotUsing</PrecompiledHeader>\n  296:       <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugVK|x64'\">NotUsing</PrecompiledHeader>\n  297:       <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseVK|x64'\">NotUsing</PrecompiledHeader>\n  298:       <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugD3D12|x64'\">NotUsing</PrecompiledHeader>\n  299      </ClCompile>\n  300      <ClCompile Include=\"..\\Externals\\.packman\\dear_imgui\\imgui_widgets.cpp\">\n  301:       <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseD3D12|x64'\">NotUsing</PrecompiledHeader>\n  302:       <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugVK|x64'\">NotUsing</PrecompiledHeader>\n  303:       <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseVK|x64'\">NotUsing</PrecompiledHeader>\n  304:       <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugD3D12|x64'\">NotUsing</PrecompiledHeader>\n  305      </ClCompile>\n  306      <ClCompile Include=\"..\\Externals\\dear_imgui_addons\\imguinodegrapheditor\\imguinodegrapheditor.cpp\">\n  307:       <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseD3D12|x64'\">NotUsing</PrecompiledHeader>\n  308:       <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugVK|x64'\">NotUsing</PrecompiledHeader>\n  309:       <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseVK|x64'\">NotUsing</PrecompiledHeader>\n  310:       <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugD3D12|x64'\">NotUsing</PrecompiledHeader>\n  311      </ClCompile>\n  312      <ClCompile Include=\"..\\Externals\\mikktspace\\mikktspace.c\">\n  313:       <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseD3D12|x64'\">NotUsing</PrecompiledHeader>\n  314:       <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugVK|x64'\">NotUsing</PrecompiledHeader>\n  315:       <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseVK|x64'\">NotUsing</PrecompiledHeader>\n  316:       <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugD3D12|x64'\">NotUsing</PrecompiledHeader>\n  317      </ClCompile>\n  318      <ClCompile Include=\"Core\\API\\BlendState.cpp\" />\n  ...\n  624      <ClCompile Include=\"Scene\\Scene.cpp\" />\n  625      <ClCompile Include=\"stdafx.cpp\">\n  626:       <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseD3D12|x64'\">Create</PrecompiledHeader>\n  627:       <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugVK|x64'\">Create</PrecompiledHeader>\n  628:       <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseVK|x64'\">Create</PrecompiledHeader>\n  629:       <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugD3D12|x64'\">Create</PrecompiledHeader>\n  630      </ClCompile>\n  631      <ClCompile Include=\"Testing\\UnitTest.cpp\" />\n  ...\n  783        <LanguageStandard>stdcpp17</LanguageStandard>\n  784        <ConformanceMode>true</ConformanceMode>\n  785:       <PrecompiledHeader>Use</PrecompiledHeader>\n  786        <AdditionalOptions>/bigobj</AdditionalOptions>\n  787      </ClCompile>\n  ...\n  821        <LanguageStandard>stdcpp17</LanguageStandard>\n  822        <ConformanceMode>true</ConformanceMode>\n  823:       <PrecompiledHeader>Use</PrecompiledHeader>\n  824        <AdditionalOptions>/bigobj</AdditionalOptions>\n  825      </ClCompile>\n  ...\n  862        <LanguageStandard>stdcpp17</LanguageStandard>\n  863        <ConformanceMode>true</ConformanceMode>\n  864:       <PrecompiledHeader>Use</PrecompiledHeader>\n  865        <AdditionalOptions>/bigobj</AdditionalOptions>\n  866      </ClCompile>\n  ...\n  904        <LanguageStandard>stdcpp17</LanguageStandard>\n  905        <ConformanceMode>true</ConformanceMode>\n  906:       <PrecompiledHeader>Use</PrecompiledHeader>\n  907        <AdditionalOptions>/bigobj</AdditionalOptions>\n  908      </ClCompile>\n\n/home/max/dev/Falcor/src/Falcor/Raytracing/RtProgram/RtProgram.h:\n   78              Desc& addDefines(const DefineList& defines);\n   79  \n   80:             /** Set the compiler flags. Replaces any previously set flags.\n   81              */\n   82              Desc& setCompilerFlags(Shader::CompilerFlags flags) { mBaseDesc.setCompilerFlags(flags); return *this; }\n\n/home/max/dev/Falcor/src/Falcor/Raytracing/ShaderTable.h:\n   64          /** Update the shader table.\n   65              This function doesn't do any early out. If it's called, it will always update the table.\n   66:             Call it only when the RtStateObject changed or when the program was recompiled\n   67          */\n   68          void update(\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraph.cpp:\n   77          it.second.pPass->setScene(mpDevice->getRenderContext(), pScene);\n   78      }\n   79:     mRecompile = true;\n   80  }\n   81  \n   ..\n   91      }\n   92  \n   93:     pPass->mPassChangedCB = [this]() { mRecompile = true; };\n   94      pPass->mName = passName;\n   95  \n   96      if (mpScene) pPass->setScene(mpDevice->getRenderContext(), mpScene);\n   97      mNodeData[passIndex] = { passName, pPass };\n   98:     mRecompile = true;\n   99      return passIndex;\n  100  }\n  ...\n  122      const auto& removedEdges = mpGraph->removeNode(index);\n  123      for (const auto& e : removedEdges) mEdgeData.erase(e);\n  124:     mRecompile = true;\n  125  }\n  126  \n  ...\n  139      auto pPass = RenderPassLibrary::instance(mpDevice).createPass(pRenderContext, passTypeName.c_str(), dict);\n  140      pPassIt->second.pPass = pPass;\n  141:     pPass->mPassChangedCB = [this]() { mRecompile = true; };\n  142      pPass->mName = pOldPass->getName();\n  143  \n  144      if (mpScene) pPass->setScene(mpDevice->getRenderContext(), mpScene);\n  145:     mRecompile = true;\n  146  }\n  147  \n  ...\n  252      uint32_t e = mpGraph->addEdge(srcIndex, dstIndex);\n  253      mEdgeData[e] = newEdge;\n  254:     mRecompile = true;\n  255      return e;\n  256  }\n  ...\n  288      mEdgeData.erase(edgeID);\n  289      mpGraph->removeEdge(edgeID);\n  290:     mRecompile = true;\n  291  }\n  292  \n  ...\n  330  }\n  331  \n  332: bool RenderGraph::compile(RenderContext* pContext, std::string& log) {\n  333:     if (!mRecompile) return true;\n  334      mpExe = nullptr;\n  335  \n  336      try {\n  337:         mpExe = RenderGraphCompiler::compile(*this, pContext, mCompilerDeps);\n  338:         mRecompile = false;\n  339          return true;\n  340      } catch (const std::exception& e) {\n  ...\n  346  void RenderGraph::execute(RenderContext* pContext) {\n  347      std::string log;\n  348:     if (!compile(pContext, log)) {\n  349:         logError(\"Failed to compile RenderGraph\\n\" + log + \"Ignoring RenderGraph::execute() call\");\n  350          return;\n  351      }\n  ...\n  448  \n  449      mOutputs.push_back(newOut);\n  450:     mRecompile = true;\n  451  }\n  452  \n  ...\n  463          if (mOutputs[i].nodeId == removeMe.nodeId && mOutputs[i].field == removeMe.field) {\n  464              mOutputs.erase(mOutputs.begin() + i);\n  465:             mRecompile = true;\n  466              return;\n  467          }\n  ...\n  479  \n  480  Resource::SharedPtr RenderGraph::getOutput(const std::string& name) {\n  481:     if (mRecompile) {\n  482:         logError(\"RenderGraph::getOutput() - can't fetch an output resource because the graph wasn't successfuly compiled yet\");\n  483          return nullptr;\n  484      }\n  ...\n  522  \n  523      // Invalidate the graph. Render-passes might change their reflection based on the resize information\n  524:     mRecompile = true;\n  525  }\n  526  \n  ...\n  555                  uint32_t e = mpGraph->addEdge(srcIndex, dstIndex);\n  556                  mEdgeData[e] = { true, srcField.getName(), dstFieldIt->getName() };\n  557:                 mRecompile = true;\n  558                  inputSatisfied = true; // If connection was found, continue to next unsatisfied input\n  559                  break;\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraph.h:\n  206          /** Compile the graph\n  207          */\n  208:         bool compile(RenderContext* pContext, std::string& log);\n  209:         bool compile(RenderContext* pContext) { std::string s; return compile(pContext, s); }\n  210  \n  211       private:\n  ...\n  257          Dictionary::SharedPtr mpPassDictionary;\n  258          RenderGraphExe::SharedPtr mpExe;\n  259:         bool mRecompile = false;\n  260          RenderGraphCompiler::Dependencies mCompilerDeps;\n  261  \n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraphCompiler.cpp:\n   41  RenderGraphCompiler::RenderGraphCompiler(RenderGraph& graph, const Dependencies& dependencies) : mGraph(graph), mDependencies(dependencies) {}\n   42  \n   43: RenderGraphExe::SharedPtr RenderGraphCompiler::compile(RenderGraph& graph, RenderContext* pContext, const Dependencies& dependencies) {\n   44      RenderGraphCompiler c = RenderGraphCompiler(graph, dependencies);\n   45  \n   ..\n   49  \n   50      c.resolveExecutionOrder();\n   51:     c.compilePasses(pContext);\n   52      if (c.insertAutoPasses()) c.resolveExecutionOrder();\n   53      c.validateGraph();\n   ..\n  294  \n  295  RenderPass::CompileData RenderGraphCompiler::prepPassCompilationData(const PassData& passData) {\n  296:     RenderPass::CompileData compileData;\n  297:     compileData.defaultTexDims = mDependencies.defaultResourceProps.dims;\n  298:     compileData.defaultTexFormat = mDependencies.defaultResourceProps.format;\n  299  \n  300      auto isExecutionEdge = [this](uint32_t edgeId) {\n  ...\n  314                  const auto& fIn = *passData.reflector.getField(mGraph.mEdgeData[e].dstField);\n  315                  f.name(fIn.getName()).visibility(fIn.getVisibility()).desc(fIn.getDesc());\n  316:                 compileData.connectedResources.addField(f);\n  317                  break;\n  318              }\n  ...\n  326              auto pTex = pRes->asTexture();\n  327              std::string resName = name.substr((passData.name + \".\").size());\n  328:             compileData.connectedResources.addInput(resName, \"External input resource\").format(pTex->getFormat()).resourceType(resourceTypeToFieldType(pTex->getType()), pTex->getWidth(), pTex->getHeight(), pTex->getDepth(), pTex->getSampleCount(), pTex->getMipCount(), pTex->getArraySize());\n  329          }\n  330      }\n  ...\n  339              if (otherPass.index == outgoingPass) {\n  340                  auto f = *otherPass.reflector.getField(mGraph.mEdgeData[e].dstField);\n  341:                 auto pField = compileData.connectedResources.getField(mGraph.mEdgeData[e].srcField);\n  342                  if (pField) {\n  343                      const_cast<RenderPassReflection::Field*>(pField)->merge(f);\n  ...\n  345                      const auto& fOut = *passData.reflector.getField(mGraph.mEdgeData[e].srcField);\n  346                      f.name(fOut.getName()).visibility(fOut.getVisibility()).desc(fOut.getDesc());\n  347:                     compileData.connectedResources.addField(f);\n  348                  }\n  349              }\n  ...\n  351      }\n  352  \n  353:     return compileData;\n  354  }\n  355  \n  356: void RenderGraphCompiler::compilePasses(RenderContext* pContext) {\n  357      while(1) {\n  358          std::string log;\n  ...\n  360          for (auto& p : mExecutionList) {\n  361              try {\n  362:                 p.pPass->compile(pContext, prepPassCompilationData(p));\n  363              } catch (const std::exception& e) {\n  364                  log += std::string(e.what()) + \"\\n\";\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraphCompiler.h:\n   42              ResourceCache::ResourcesMap externalResources;\n   43          };\n   44:         static RenderGraphExe::SharedPtr compile(RenderGraph& graph, RenderContext* pContext, const Dependencies& dependencies);\n   45  \n   46      private:\n   ..\n   66  \n   67          void resolveExecutionOrder();\n   68:         void compilePasses(RenderContext* pContext);\n   69          bool insertAutoPasses();\n   70          void allocateResources(ResourceCache* pResourceCache);\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraphUI.cpp:\n  576  \n  577          // only send updates that we know are valid.\n  578:         if (mpRenderGraph->compile(pContext) == false) mLogString += \"Graph is currently invalid\\n\";\n  579          mShouldUpdate = false;\n  580          mRebuildDisplayData = true;\n  ...\n  588  \n  589          // only send delta of updates once the graph is valid\n  590:         if (mpRenderGraph->compile(pContext) == false) return;\n  591          std::ofstream outputFileStream(filePath, std::ios_base::out);\n  592          outputFileStream << mUpdateCommands;\n  ...\n 1295          }\n 1296  \n 1297:         mpRenderGraph->compile(pContext);\n 1298          mRenderPassUI.clear();\n 1299          mInputPinStringToLinkID.clear();\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderPass.h:\n   83          Render passes are inserted in a render graph, which is executed at runtime.\n   84          Each render pass declares its I/O requirements in the reflect() function,\n   85:         and as part of the render graph compilation their compile() function is called.\n   86          At runtime, execute() is called each frame to generate the pass outputs.\n   87      */\n   ..\n   98  \n   99          /** Called once before compilation. Describes I/O requirements of the pass.\n  100:             The requirements can't change after the graph is compiled. If the IO requests are dynamic, you'll need to trigger compilation of the render-graph yourself.\n  101          */\n  102:         virtual RenderPassReflection reflect(const CompileData& compileData) = 0;\n  103  \n  104          /** Will be called during graph compilation. You should throw an exception in case the compilation failed\n  105          */\n  106:         virtual void compile(RenderContext* pContext, const CompileData& compileData) {}\n  107  \n  108          /** Executes the pass.\n\n/home/max/dev/Falcor/src/Falcor/RenderPasses/ResolvePass.cpp:\n   38  ResolvePass::ResolvePass(Device::SharedPtr pDevice): RenderPass(pDevice) {}\n   39  \n   40: RenderPassReflection ResolvePass::reflect(const CompileData& compileData) {\n   41      RenderPassReflection reflector;\n   42      reflector.addInput(kSrc, \"Multi-sampled texture\").format(mFormat).texture2D(0, 0, 0);\n\n/home/max/dev/Falcor/src/Falcor/RenderPasses/ResolvePass.h:\n   42  \n   43      void setFormat(ResourceFormat format) { mFormat = format; }\n   44:     virtual RenderPassReflection reflect(const CompileData& compileData) override;\n   45      virtual void execute(RenderContext* pContext, const RenderData& renderData) override;\n   46      virtual std::string getDesc() override { return kDesc; }\n\n/home/max/dev/Falcor/src/Falcor/RenderPasses/Shared/PathTracer/PathTracer.cpp:\n  103      }\n  104  \n  105:     RenderPassReflection PathTracer::reflect(const CompileData& compileData)\n  106      {\n  107          RenderPassReflection reflector;\n  ...\n  113      }\n  114  \n  115:     void PathTracer::compile(RenderContext* pRenderContext, const CompileData& compileData)\n  116      {\n  117:         mSharedParams.frameDim = compileData.defaultTexDims;\n  118      }\n  119  \n  ...\n  568      void PathTracer::setStaticParams(Program* pProgram) const\n  569      {\n  570:         // Set compile-time constants on the given program.\n  571          // TODO: It's unnecessary to set these every frame. It should be done lazily, but the book-keeping is complicated.\n  572          Program::DefineList defines;\n\n/home/max/dev/Falcor/src/Falcor/RenderPasses/Shared/PathTracer/PathTracer.h:\n   48  \n   49          virtual Dictionary getScriptingDictionary() override;\n   50:         virtual RenderPassReflection reflect(const CompileData& compileData) override;\n   51:         virtual void compile(RenderContext* pRenderContext, const CompileData& compileData) override;\n   52          virtual void setScene(RenderContext* pRenderContext, const Scene::SharedPtr& pScene) override;\n   53          virtual void renderUI(Gui::Widgets& widget) override;\n   ..\n   96          // Runtime data\n   97          bool                                mOptionsChanged = false;        ///< True if the config has changed since last frame.\n   98:         bool                                mUseAnalyticLights = false;     ///< True if analytic lights should be used for the current frame. See compile-time constant in StaticParams.slang.\n   99:         bool                                mUseEnvLight = false;           ///< True if env map light should be used for the current frame. See compile-time constant in StaticParams.slang.\n  100:         bool                                mUseEmissiveLights = false;     ///< True if emissive lights should be taken into account. See compile-time constant in StaticParams.slang.\n  101:         bool                                mUseEmissiveSampler = false;    ///< True if emissive light sampler should be used for the current frame. See compile-time constant in StaticParams.slang.\n  102          uint32_t                            mMaxRaysPerPixel = 0;           ///< Maximum number of rays per pixel that will be traced. This is computed based on the current configuration.\n  103  \n\n/home/max/dev/Falcor/src/Falcor/RenderPasses/Shared/PathTracer/PathTracerHelpers.slang:\n  215      float u = sampleNext1D(sg);\n  216  \n  217:     // We use explicit checks for which light types are enabled so that the compiler\n  218:     // can remove the unused code. It won't otherwise since u is unknown at compile time.\n  219      if (kUseEnvLight)\n  220      {\n\n/home/max/dev/Falcor/src/Falcor/RenderPasses/Shared/PathTracer/PathTracerParams.slang:\n   68  \n   69      // General\n   70:     uint    samplesPerPixel = 1;            ///< Number of samples (paths) per pixel. Use compile-time constant SAMPLES_PER_PIXEL in shader.\n   71:     uint    lightSamplesPerVertex = 1;      ///< Number of light samples per path vertex. Use compile-time constant LIGHT_SAMPLES_PER_VERTEX in shader. Note: This option is only supported in the WavefrontPathTracer.\n   72:     uint    maxBounces = 3;                 ///< Max number of indirect bounces (0 = none), up to kMaxPathLength. Use compile-time constant MAX_BOUNCES in shader.\n   73:     int     useVBuffer = 1;                 ///< Use a V-buffer as input. Use compile-time constant USE_VBUFFER in shader.\n   74  \n   75:     int     forceAlphaOne = true;           ///< Force the alpha channel to 1.0. Otherwise background will have alpha 0.0 and covered samples 1.0 to allow compositing. Use compile-time constant FORCE_ALPHA_ONE in shader.\n   76      int     clampSamples = false;           ///< Clamp the per-path contribution to 'clampThreshold' to reduce fireflys.\n   77      float   clampThreshold = 10.f;\n   ..\n   81      int     useAnalyticLights = true;       ///< Use built-in analytic lights.\n   82      int     useEmissiveLights = true;       ///< Use emissive geometry as light sources.\n   83:     int     useEnvLight = true;             ///< Use environment map as light source (if loaded). Use compile-time constant USE_ENV_LIGHT in shader.\n   84:     int     useEnvBackground = true;        ///< Use environment map as background (if loaded). Use compile-time constant USE_ENV_BACKGROUND in shader.\n   85  \n   86      // Sampling\n   87:     int     useBRDFSampling = true;         ///< Use BRDF importance sampling (otherwise cosine-weighted hemisphere sampling). Use compile-time constant USE_BRDF_SAMPLING in shader.\n   88:     int     useMIS = true;                  ///< Use multiple importance sampling (MIS). Use compile-time constant USE_MIS in shader.\n   89:     uint    misHeuristic = 1; /* (uint)MISHeuristic::PowerTwoHeuristic */   ///< MIS heuristic. Use compile-time constant MIS_HEURISTIC in shader. TODO: Replace initializer value by enum when Slang supports it.\n   90      float   misPowerExponent = 2.f;         ///< MIS exponent for the power heuristic. This is only used when 'PowerExpHeuristic' is chosen.\n   91  \n   92      int     useEmissiveLightSampling = true;///< Use emissive light importance sampling.\n   93:     int     useRussianRoulette = false;     ///< Use Russian roulette. Use compile-time constant USE_RUSSIAN_ROULETTE in shader.\n   94      float   probabilityAbsorption = 0.2f;   ///< Probability of absorption for Russian roulette.\n   95      int     useFixedSeed = false;           ///< Use fixed random seed for the sample generator. This is useful for print() debugging.\n\n/home/max/dev/Falcor/src/Falcor/RenderPasses/Shared/PathTracer/StaticParams.slang:\n   27   **************************************************************************/\n   28  \n   29: /** Translation of defines set by the host to compile-time constants used to\n   30      configure the path tracer without overhead from dynamic control flow.\n   31      This will eventually be replaced by specialization constants in Slang.\n\n/home/max/dev/Falcor/src/Falcor/Testing/UnitTest.h:\n  104              given path.  The entrypoint is assumed to be |main()| unless\n  105              otherwise specified with the |csEntry| parameter.  Preprocessor\n  106:             defines and compiler flags can also be optionally provided.\n  107          */\n  108          void createProgram( const std::string& path,\n\n/home/max/dev/Falcor/src/Falcor/Utils/Algorithm/BitonicSort.cpp:\n   65  \n   66          // Configure the shader for the specified chunk size.\n   67:         // This will trigger a re-compile if a new chunk size is encountered.\n   68          mSort.pProgram->addDefine(\"CHUNK_SIZE\", std::to_string(chunkSize));\n   69          mSort.pProgram->addDefine(\"GROUP_SIZE\", std::to_string(groupSize));\n   ..\n   75          assert(groupsX * groupsY * groupSize >= totalSize);\n   76  \n   77:         // Constants. The buffer size as a runtime constant as it may be variable and we don't want to recompile each time it changes.\n   78          mSort.pVars[\"CB\"][\"gTotalSize\"] = totalSize;\n   79          mSort.pVars[\"CB\"][\"gDispatchX\"] = groupsX;\n\n/home/max/dev/Falcor/src/Falcor/Utils/Algorithm/ComputeParallelReduction.cpp:\n   39      ComputeParallelReduction::ComputeParallelReduction(std::shared_ptr<Device> pDevice): mpDevice(pDevice) {\n   40          // Create the programs.\n   41:         // Set defines to avoid compiler warnings about undefined macros. Proper values will be assigned at runtime.\n   42          Program::DefineList defines = { { \"FORMAT_CHANNELS\", \"1\" }, { \"FORMAT_TYPE\", \"1\" } };\n   43          mpInitialProgram = ComputeProgram::createFromFile(pDevice, kShaderFile, \"initialPass\", defines, Shader::CompilerFlags::None);\n\n/home/max/dev/Falcor/src/Falcor/Utils/HostDeviceShared.slangh:\n   32  *******************************************************************/\n   33  \n   34: #if (defined(__STDC_HOSTED__) || defined(__cplusplus))   // we're in C-compliant compiler, probably host\n   35  #define HOST_CODE 1\n   36  #endif\n\n/home/max/dev/Falcor/src/Falcor/Utils/Math/BitTricks.slang:\n   34      So, deinterleave_16bit(interleave_16bit(x)) == x should hold true.\n   35  \n   36:     TODO: Make this a host/device shared header, ensure code compiles on the host.\n   37      TODO: Add optimized 8-bit and 2x8-bit interleaving functions.\n   38      TODO: Use NvApi intrinsics to optimize the code on NV.\n\n/home/max/dev/Falcor/src/Falcor/Utils/Math/MathConstants.slangh:\n   35  \n   36      Note the possible differences between declaring constants using static\n   37:     float vs macro definitions. The compiler may treat these differently with\n   38:     respect to what precision is used for compile-time constant propagation.\n   39      Slang currently uses fp32 for constant propagation. We get higher\n   40      precision using the pre-evaluated constants below. Ideally, all\n   41:     compile-time constants should be evaluated at fp64 or higher precision.\n   42  */\n   43  \n\n/home/max/dev/Falcor/src/Falcor/Utils/Sampling/SampleGenerator.slang:\n   34      size of the 'SampleGenerator' type may vary depending on their state size.\n   35  \n   36:     If SAMPLE_GENERATOR_TYPE is not defined, a compile-time error is printed.\n   37  \n   38      The 'SampleGeneratorPadded' type holds a SampleGenerator plus additional\n\n/home/max/dev/Falcor/src/Falcor/Utils/StringUtils.h:\n  303          auto v = splitString(typeName.substr(6), \"::\");\n  304  #else\n  305:         int status = -4; // some arbitrary value to eliminate the compiler warning\n  306          char * demangled = abi::__cxa_demangle(typeid(*ptr).name(), NULL, NULL, &status);\n  307          if(!demangled) {\n  ...\n  323          auto v = splitString(typeName.substr(5), \"::\");\n  324  #else\n  325:         int status = -4; // some arbitrary value to eliminate the compiler warning\n  326          char * demangled = abi::__cxa_demangle(typeid(e).name(), NULL, NULL, &status);\n  327          if(!demangled) {\n\n/home/max/dev/Falcor/src/Falcor/Utils/UI/Gui.cpp:\n   47          void init(Gui* pGui, float scaleFactor);\n   48          void createVao(uint32_t vertexCount, uint32_t indexCount);\n   49:         void compileFonts();\n   50  \n   51          // Helper to create multiple inline text boxes\n   ..\n  243      }\n  244  \n  245:     void GuiImpl::compileFonts() {\n  246          uint8_t* pFontData;\n  247          int32_t width, height;\n  ...\n  786          ImFont* pFont = ImGui::GetIO().Fonts->AddFontFromFileTTF(fullpath.c_str(), size);\n  787          mpWrapper->mFontMap[name] = pFont;\n  788:         mpWrapper->compileFonts();\n  789      }\n  790  \n\n/home/max/dev/Falcor/src/Mogwai/Mogwai.vcxproj:\n   21      <ClCompile Include=\"MogwaiSettings.cpp\" />\n   22      <ClCompile Include=\"stdafx.cpp\">\n   23:       <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">Create</PrecompiledHeader>\n   24      </ClCompile>\n   25    </ItemGroup>\n   ..\n   85    <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n   86      <ClCompile>\n   87:       <PrecompiledHeader>NotUsing</PrecompiledHeader>\n   88        <WarningLevel>Level3</WarningLevel>\n   89        <Optimization>Disabled</Optimization>\n   ..\n  101      <ClCompile>\n  102        <WarningLevel>Level3</WarningLevel>\n  103:       <PrecompiledHeader>Use</PrecompiledHeader>\n  104        <Optimization>MaxSpeed</Optimization>\n  105        <FunctionLevelLinking>true</FunctionLevelLinking>\n\n/home/max/dev/Falcor/src/RenderPasses/AccumulatePass/Accumulate.cs.slang:\n   30  \n   31      There are entry points for each of the three supported accumulation modes.\n   32:     Note that for the compensated summation mode the shader _must_ be compiled\n   33      for precise floating-point operations (no reordering).\n   34  \n\n/home/max/dev/Falcor/src/RenderPasses/AccumulatePass/AccumulatePass.cpp:\n   93  }\n   94  \n   95: RenderPassReflection AccumulatePass::reflect(const CompileData& compileData) {\n   96      RenderPassReflection reflector;\n   97      reflector.addInput(kInputChannel, \"Input data to be temporally accumulated\").bindFlags(ResourceBindFlags::ShaderResource);\n   ..\n  100  }\n  101  \n  102: void AccumulatePass::compile(RenderContext* pContext, const CompileData& compileData) {\n  103      assert(mpDevice == pContext->device());\n  104  \n  105      // Reset accumulation when resolution changes.\n  106:     if (compileData.defaultTexDims != mFrameDim) {\n  107          mFrameCount = 0;\n  108:         mFrameDim = compileData.defaultTexDims;\n  109      }\n  110  }\n\n/home/max/dev/Falcor/src/RenderPasses/AccumulatePass/AccumulatePass.h:\n   50      virtual std::string getDesc() override { return \"Temporal accumulation pass\"; }\n   51      virtual Dictionary getScriptingDictionary() override;\n   52:     virtual RenderPassReflection reflect(const CompileData& compileData) override;\n   53:     virtual void compile(RenderContext* pContext, const CompileData& compileData) override;\n   54      virtual void execute(RenderContext* pRenderContext, const RenderData& renderData) override;\n   55      virtual void renderUI(Gui::Widgets& widget) override;\n\n/home/max/dev/Falcor/src/RenderPasses/AccumulatePass/AccumulatePass.vcxproj:\n   66    <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n   67      <ClCompile>\n   68:       <PrecompiledHeader>\n   69:       </PrecompiledHeader>\n   70        <WarningLevel>Level3</WarningLevel>\n   71        <Optimization>Disabled</Optimization>\n   ..\n   83      <ClCompile>\n   84        <WarningLevel>Level3</WarningLevel>\n   85:       <PrecompiledHeader>\n   86:       </PrecompiledHeader>\n   87        <Optimization>MaxSpeed</Optimization>\n   88        <FunctionLevelLinking>true</FunctionLevelLinking>\n\n/home/max/dev/Falcor/src/RenderPasses/Antialiasing/Antialiasing.vcxproj:\n   70    <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n   71      <ClCompile>\n   72:       <PrecompiledHeader>\n   73:       </PrecompiledHeader>\n   74        <WarningLevel>Level3</WarningLevel>\n   75        <Optimization>Disabled</Optimization>\n   ..\n   87      <ClCompile>\n   88        <WarningLevel>Level3</WarningLevel>\n   89:       <PrecompiledHeader>\n   90:       </PrecompiledHeader>\n   91        <Optimization>MaxSpeed</Optimization>\n   92        <FunctionLevelLinking>true</FunctionLevelLinking>\n\n/home/max/dev/Falcor/src/RenderPasses/Antialiasing/FXAA/FXAA.cpp:\n   73  }\n   74  \n   75: RenderPassReflection FXAA::reflect(const CompileData& compileData) {\n   76      RenderPassReflection reflector;\n   77      reflector.addInput(kSrc, \"Source color-buffer\");\n\n/home/max/dev/Falcor/src/RenderPasses/Antialiasing/FXAA/FXAA.h:\n   44      std::string getDesc() override { return kDesc; }\n   45      virtual Dictionary getScriptingDictionary() override;\n   46:     virtual RenderPassReflection reflect(const CompileData& compileData) override;\n   47      virtual void execute(RenderContext* pContext, const RenderData& renderData) override;\n   48      virtual void renderUI(Gui::Widgets& widget) override;\n\n/home/max/dev/Falcor/src/RenderPasses/Antialiasing/TAA/TAA.cpp:\n   67  }\n   68  \n   69: RenderPassReflection TAA::reflect(const CompileData& compileData) {\n   70      RenderPassReflection reflection;\n   71      reflection.addInput(kMotionVec, \"Screen-space motion vectors\");\n\n/home/max/dev/Falcor/src/RenderPasses/Antialiasing/TAA/TAA.h:\n   46      std::string getDesc() override { return kDesc; }\n   47      virtual Dictionary getScriptingDictionary() override;\n   48:     virtual RenderPassReflection reflect(const CompileData& compileData) override;\n   49      virtual void execute(RenderContext* pContext, const RenderData& renderData) override;\n   50      virtual void renderUI(Gui::Widgets& widget) override;\n\n/home/max/dev/Falcor/src/RenderPasses/BlitPass/BlitPass.cpp:\n   43  static const std::string kFilter = \"filter\";\n   44  \n   45: RenderPassReflection BlitPass::reflect(const CompileData& compileData) {\n   46      RenderPassReflection reflector;\n   47  \n\n/home/max/dev/Falcor/src/RenderPasses/BlitPass/BlitPass.h:\n   45      static SharedPtr create(RenderContext* pRenderContext = nullptr, const Dictionary& dict = {});\n   46  \n   47:     virtual RenderPassReflection reflect(const CompileData& compileData) override;\n   48      virtual void execute(RenderContext* pContext, const RenderData& renderData) override;\n   49      virtual void renderUI(Gui::Widgets& widget) override;\n\n/home/max/dev/Falcor/src/RenderPasses/BlitPass/BlitPass.vcxproj:\n   63    <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n   64      <ClCompile>\n   65:       <PrecompiledHeader>\n   66:       </PrecompiledHeader>\n   67        <WarningLevel>Level3</WarningLevel>\n   68        <Optimization>Disabled</Optimization>\n   ..\n   80      <ClCompile>\n   81        <WarningLevel>Level3</WarningLevel>\n   82:       <PrecompiledHeader>\n   83:       </PrecompiledHeader>\n   84        <Optimization>MaxSpeed</Optimization>\n   85        <FunctionLevelLinking>true</FunctionLevelLinking>\n\n/home/max/dev/Falcor/src/RenderPasses/BSDFViewer/BSDFViewer.cpp:\n   77  }\n   78  \n   79: RenderPassReflection BSDFViewer::reflect(const CompileData& compileData) {\n   80      RenderPassReflection r;\n   81      r.addOutput(kOutput, \"Output buffer\").format(ResourceFormat::RGBA32Float).bindFlags(ResourceBindFlags::UnorderedAccess);\n   ..\n   83  }\n   84  \n   85: void BSDFViewer::compile(RenderContext* pContext, const CompileData& compileData) {\n   86:     mParams.frameDim = compileData.defaultTexDims;\n   87  \n   88      // Place a square viewport centered in the frame.\n   ..\n  141      }\n  142  \n  143:     // Set compile-time constants.\n  144      mpViewerPass->addDefine(\"_USE_LEGACY_SHADING_CODE\", mParams.useLegacyBSDF ? \"1\" : \"0\");\n  145  \n\n/home/max/dev/Falcor/src/RenderPasses/BSDFViewer/BSDFViewer.h:\n   48      virtual std::string getDesc() override { return sDesc; }\n   49      virtual Dictionary getScriptingDictionary() override;\n   50:     virtual RenderPassReflection reflect(const CompileData& compileData) override;\n   51:     virtual void compile(RenderContext* pContext, const CompileData& compileData) override;\n   52      virtual void execute(RenderContext* pRenderContext, const RenderData& renderData) override;\n   53      virtual void renderUI(Gui::Widgets& widget) override;\n\n/home/max/dev/Falcor/src/RenderPasses/BSDFViewer/BSDFViewer.vcxproj:\n   65    <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n   66      <ClCompile>\n   67:       <PrecompiledHeader>\n   68:       </PrecompiledHeader>\n   69        <WarningLevel>Level3</WarningLevel>\n   70        <Optimization>Disabled</Optimization>\n   ..\n   82      <ClCompile>\n   83        <WarningLevel>Level3</WarningLevel>\n   84:       <PrecompiledHeader>\n   85:       </PrecompiledHeader>\n   86        <Optimization>MaxSpeed</Optimization>\n   87        <FunctionLevelLinking>true</FunctionLevelLinking>\n\n/home/max/dev/Falcor/src/RenderPasses/CSM/CSM.cpp:\n  281  }\n  282  \n  283: RenderPassReflection CSM::reflect(const CompileData& compileData) {\n  284      RenderPassReflection reflector;\n  285      reflector.addOutput(kVisibility, \"Visibility map. Values are [0,1] where 0 means the pixel is completely shadowed and 1 means it's not shadowed at all\")\n  ...\n  290  }\n  291  \n  292: void CSM::compile(RenderContext* pContext, const CompileData& compileData) {\n  293      mpBlurGraph = RenderGraph::create(mpDevice, \"Gaussian Blur\");\n  294      GaussianBlur::SharedPtr pBlurPass = GaussianBlur::create(pContext, mBlurDict);\n\n/home/max/dev/Falcor/src/RenderPasses/CSM/CSM.h:\n   52      virtual std::string getDesc() override { return kDesc; }\n   53      virtual Dictionary getScriptingDictionary() override;\n   54:     virtual RenderPassReflection reflect(const CompileData& compileData) override;\n   55:     virtual void compile(RenderContext* pContext, const CompileData& compileData) override;\n   56      virtual void execute(RenderContext* pContext, const RenderData& renderData) override;\n   57      virtual void setScene(RenderContext* pRenderContext, const Scene::SharedPtr& pScene) override;\n\n/home/max/dev/Falcor/src/RenderPasses/CSM/CSM.vcxproj:\n   73    <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n   74      <ClCompile>\n   75:       <PrecompiledHeader>\n   76:       </PrecompiledHeader>\n   77        <WarningLevel>Level3</WarningLevel>\n   78        <Optimization>Disabled</Optimization>\n   ..\n   90      <ClCompile>\n   91        <WarningLevel>Level3</WarningLevel>\n   92:       <PrecompiledHeader>\n   93:       </PrecompiledHeader>\n   94        <Optimization>MaxSpeed</Optimization>\n   95        <FunctionLevelLinking>true</FunctionLevelLinking>\n\n/home/max/dev/Falcor/src/RenderPasses/DebugPasses/ComparisonPass.cpp:\n   74  }\n   75  \n   76: RenderPassReflection ComparisonPass::reflect(const CompileData& compileData) {\n   77      RenderPassReflection r;\n   78      r.addInput(kLeftInput, \"Left side image\").bindFlags(Falcor::Resource::BindFlags::ShaderResource).texture2D(0, 0);\n\n/home/max/dev/Falcor/src/RenderPasses/DebugPasses/ComparisonPass.h:\n   38  \n   39      virtual Dictionary getScriptingDictionary() override;\n   40:     virtual RenderPassReflection reflect(const CompileData& compileData) override;\n   41      virtual void execute(RenderContext* pContext, const RenderData& renderData) override;\n   42      virtual void renderUI(Gui::Widgets& widget) override;\n\n/home/max/dev/Falcor/src/RenderPasses/DebugPasses/DebugPasses.vcxproj:\n   76    <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n   77      <ClCompile>\n   78:       <PrecompiledHeader>\n   79:       </PrecompiledHeader>\n   80        <WarningLevel>Level3</WarningLevel>\n   81        <Optimization>Disabled</Optimization>\n   ..\n   93      <ClCompile>\n   94        <WarningLevel>Level3</WarningLevel>\n   95:       <PrecompiledHeader>\n   96:       </PrecompiledHeader>\n   97        <Optimization>MaxSpeed</Optimization>\n   98        <FunctionLevelLinking>true</FunctionLevelLinking>\n\n/home/max/dev/Falcor/src/RenderPasses/DebugPasses/InvalidPixelDetectionPass/InvalidPixelDetectionPass.cpp:\n   45  }\n   46  \n   47: RenderPassReflection InvalidPixelDetectionPass::reflect(const CompileData& compileData) {\n   48      RenderPassReflection r;\n   49      mReady = false;\n   50:     if (compileData.connectedResources.getFieldCount() > 0) {\n   51:         const RenderPassReflection::Field* edge = compileData.connectedResources.getField(kSrc);\n   52          RenderPassReflection::Field::Type srcType = edge->getType();\n   53          ResourceFormat srcFormat = edge->getFormat();\n   ..\n   73  }\n   74  \n   75: void InvalidPixelDetectionPass::compile(RenderContext* pContext, const CompileData& compileData) {\n   76      assert(mpDevice == pContext->device());\n   77:     if (!mReady) throw std::runtime_error(\"InvalidPixelDetectionPass::compile - missing incoming reflection data\");\n   78  }\n   79  \n\n/home/max/dev/Falcor/src/RenderPasses/DebugPasses/InvalidPixelDetectionPass/InvalidPixelDetectionPass.h:\n   42  \n   43      virtual std::string getDesc() override { return \"Pass that marks all NaN pixels red and Inf pixels green in an image\"; }\n   44:     virtual RenderPassReflection reflect(const CompileData& compileData) override;\n   45:     virtual void compile(RenderContext* pContext, const CompileData& compileData) override;\n   46      virtual void execute(RenderContext* pRenderContext, const RenderData& renderData) override;\n   47  \n\n/home/max/dev/Falcor/src/RenderPasses/DepthPass/DepthPass.cpp:\n   78  }\n   79  \n   80: RenderPassReflection DepthPass::reflect(const CompileData& compileData) {\n   81      RenderPassReflection reflector;\n   82      reflector.addOutput(kDepth, \"Depth-buffer\").bindFlags(Resource::BindFlags::DepthStencil).format(mDepthFormat).texture2D(0, 0, 0);\n\n/home/max/dev/Falcor/src/RenderPasses/DepthPass/DepthPass.h:\n   53      static SharedPtr create(RenderContext* pRenderContext = nullptr, const Dictionary& dict = {});\n   54  \n   55:     virtual RenderPassReflection reflect(const CompileData& compileData) override;\n   56      virtual void execute(RenderContext* pContext, const RenderData& renderData) override;\n   57      virtual void setScene(RenderContext* pRenderContext, const Scene::SharedPtr& pScene) override;\n\n/home/max/dev/Falcor/src/RenderPasses/DepthPass/DepthPass.vcxproj:\n   66    <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n   67      <ClCompile>\n   68:       <PrecompiledHeader>\n   69:       </PrecompiledHeader>\n   70        <WarningLevel>Level3</WarningLevel>\n   71        <Optimization>Disabled</Optimization>\n   ..\n   83      <ClCompile>\n   84        <WarningLevel>Level3</WarningLevel>\n   85:       <PrecompiledHeader>\n   86:       </PrecompiledHeader>\n   87        <Optimization>MaxSpeed</Optimization>\n   88        <FunctionLevelLinking>true</FunctionLevelLinking>\n\n/home/max/dev/Falcor/src/RenderPasses/ErrorMeasurePass/ErrorMeasurePass.cpp:\n  114  }\n  115  \n  116: RenderPassReflection ErrorMeasurePass::reflect(const CompileData& compileData) {\n  117      RenderPassReflection reflector;\n  118      reflector.addInput(kInputChannelSourceImage, \"Source image\");\n  119      reflector.addInput(kInputChannelReferenceImage, \"Reference image (optional)\").flags(RenderPassReflection::Field::Flags::Optional);\n  120      reflector.addInput(kInputChannelWorldPosition, \"World-space position\").flags(RenderPassReflection::Field::Flags::Optional);\n  121:     // TODO: when compile() is available, match the format of the source image?\n  122      reflector.addOutput(kOutputChannelImage, \"Output image\").format(ResourceFormat::RGBA32Float);\n  123      return reflector;\n\n/home/max/dev/Falcor/src/RenderPasses/ErrorMeasurePass/ErrorMeasurePass.h:\n   42      virtual std::string getDesc() override { return \"Measures error with respect to a reference image\"; }\n   43      virtual Dictionary getScriptingDictionary() override;\n   44:     virtual RenderPassReflection reflect(const CompileData& compileData) override;\n   45      virtual void execute(RenderContext* pRenderContext, const RenderData& renderData) override;\n   46      virtual void renderUI(Gui::Widgets& widget) override;\n\n/home/max/dev/Falcor/src/RenderPasses/ErrorMeasurePass/ErrorMeasurePass.vcxproj:\n   66    <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n   67      <ClCompile>\n   68:       <PrecompiledHeader>\n   69:       </PrecompiledHeader>\n   70        <WarningLevel>Level3</WarningLevel>\n   71        <Optimization>Disabled</Optimization>\n   ..\n   83      <ClCompile>\n   84        <WarningLevel>Level3</WarningLevel>\n   85:       <PrecompiledHeader>\n   86:       </PrecompiledHeader>\n   87        <Optimization>MaxSpeed</Optimization>\n   88        <FunctionLevelLinking>true</FunctionLevelLinking>\n\n/home/max/dev/Falcor/src/RenderPasses/ForwardLightingPass/ForwardLightingPass.cpp:\n   86  }\n   87  \n   88: RenderPassReflection ForwardLightingPass::reflect(const CompileData& compileData) {\n   89      RenderPassReflection reflector;\n   90  \n\n/home/max/dev/Falcor/src/RenderPasses/ForwardLightingPass/ForwardLightingPass.h:\n   45      static SharedPtr create(RenderContext* pRenderContext = nullptr, const Dictionary& dict = {});\n   46  \n   47:     virtual RenderPassReflection reflect(const CompileData& compileData) override;\n   48      virtual void execute(RenderContext* pContext, const RenderData& renderData) override;\n   49  \n\n/home/max/dev/Falcor/src/RenderPasses/ForwardLightingPass/ForwardLightingPass.vcxproj:\n   66    <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n   67      <ClCompile>\n   68:       <PrecompiledHeader>\n   69:       </PrecompiledHeader>\n   70        <WarningLevel>Level3</WarningLevel>\n   71        <Optimization>Disabled</Optimization>\n   ..\n   83      <ClCompile>\n   84        <WarningLevel>Level3</WarningLevel>\n   85:       <PrecompiledHeader>\n   86:       </PrecompiledHeader>\n   87        <Optimization>MaxSpeed</Optimization>\n   88        <FunctionLevelLinking>true</FunctionLevelLinking>\n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/GBuffer.vcxproj:\n   84    <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n   85      <ClCompile>\n   86:       <PrecompiledHeader>\n   87:       </PrecompiledHeader>\n   88        <WarningLevel>Level3</WarningLevel>\n   89        <Optimization>Disabled</Optimization>\n   ..\n  101      <ClCompile>\n  102        <WarningLevel>Level3</WarningLevel>\n  103:       <PrecompiledHeader>\n  104:       </PrecompiledHeader>\n  105        <Optimization>MaxSpeed</Optimization>\n  106        <FunctionLevelLinking>true</FunctionLevelLinking>\n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/GBuffer/GBuffer.cpp:\n  104  }\n  105  \n  106: void GBuffer::compile(RenderContext* pContext, const CompileData& compileData) {\n  107:     GBufferBase::compile(pContext, compileData);\n  108  \n  109      mGBufferParams.frameSize = mFrameDim;\n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/GBuffer/GBuffer.h:\n   41   public:\n   42      virtual void renderUI(Gui::Widgets& widget) override;\n   43:     virtual void compile(RenderContext* pContext, const CompileData& compileData) override;\n   44      virtual Dictionary getScriptingDictionary() override;\n   45      virtual void setScene(RenderContext* pRenderContext, const Scene::SharedPtr& pScene) override;\n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/GBuffer/GBufferRaster.cpp:\n   61  }\n   62  \n   63: RenderPassReflection GBufferRaster::reflect(const CompileData& compileData) {\n   64      RenderPassReflection reflector;\n   65  \n   ..\n  105  }\n  106  \n  107: void GBufferRaster::compile(RenderContext* pContext, const CompileData& compileData) {\n  108:     GBuffer::compile(pContext, compileData);\n  109  \n  110      assert(pContext->device());\n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/GBuffer/GBufferRaster.h:\n   42      static SharedPtr create(RenderContext* pRenderContext = nullptr, const Dictionary& dict = {});\n   43  \n   44:     RenderPassReflection reflect(const CompileData& compileData) override;\n   45      void execute(RenderContext* pRenderContext, const RenderData& renderData) override;\n   46      void setScene(RenderContext* pRenderContext, const Scene::SharedPtr& pScene) override;\n   47      std::string getDesc(void) override { return kDesc; }\n   48:     virtual void compile(RenderContext* pContext, const CompileData& compileData) override;\n   49  \n   50   private:\n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/GBuffer/GBufferRT.cpp:\n   71  }\n   72  \n   73: RenderPassReflection GBufferRT::reflect(const CompileData& compileData)\n   74  {\n   75      RenderPassReflection reflector;\n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/GBuffer/GBufferRT.h:\n   45      static SharedPtr create(RenderContext* pRenderContext = nullptr, const Dictionary& dict = {});\n   46  \n   47:     RenderPassReflection reflect(const CompileData& compileData) override;\n   48      void execute(RenderContext* pRenderContext, const RenderData& renderData) override;\n   49      void renderUI(Gui::Widgets& widget) override;\n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/GBuffer/GBufferRT.rt.slang:\n   56  struct RayData\n   57  {\n   58:     int dummy; // TODO: Passing in an empty payload struct doesn't work. Declare a dummy variable so that the compiler doesn't remove the declaration.\n   59  };\n   60  \n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/GBufferBase.cpp:\n  120  }\n  121  \n  122: void GBufferBase::compile(RenderContext* pContext, const CompileData& compileData) {\n  123      assert(mpDevice);\n  124      assert(pContext->device());\n  ...\n  127      assert(mpDevice == pContext->device());\n  128  \n  129:     mFrameDim = compileData.defaultTexDims;\n  130      mInvFrameDim = 1.f / float2(mFrameDim);\n  131  \n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/GBufferBase.h:\n   47  \n   48      virtual void renderUI(Gui::Widgets& widget) override;\n   49:     virtual void compile(RenderContext* pContext, const CompileData& compileData) override;\n   50      virtual Dictionary getScriptingDictionary() override;\n   51      virtual void setScene(RenderContext* pRenderContext, const Scene::SharedPtr& pScene) override;\n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/VBuffer/VBufferRaster.cpp:\n   41  }  // namespace\n   42  \n   43: RenderPassReflection VBufferRaster::reflect(const CompileData& compileData) {\n   44      RenderPassReflection reflector;\n   45  \n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/VBuffer/VBufferRaster.h:\n   45      static SharedPtr create(RenderContext* pRenderContext, const Dictionary& dict);\n   46  \n   47:     RenderPassReflection reflect(const CompileData& compileData) override;\n   48      void setScene(RenderContext* pRenderContext, const Scene::SharedPtr& pScene) override;\n   49      void execute(RenderContext* pRenderContext, const RenderData& renderData) override;\n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/VBuffer/VBufferRT.cpp:\n   46  };\n   47  \n   48: RenderPassReflection VBufferRT::reflect(const CompileData& compileData)\n   49  {\n   50      RenderPassReflection reflector;\n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/VBuffer/VBufferRT.h:\n   48      static SharedPtr create(RenderContext* pRenderContext, const Dictionary& dict);\n   49  \n   50:     RenderPassReflection reflect(const CompileData& compileData) override;\n   51      void setScene(RenderContext* pRenderContext, const Scene::SharedPtr& pScene) override;\n   52      void execute(RenderContext* pRenderContext, const RenderData& renderData) override;\n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/VBuffer/VBufferRT.rt.slang:\n   42  struct RayData\n   43  {\n   44:     int dummy; // TODO: Passing in an empty payload struct doesn't work. Declare a dummy variable so that the compiler doesn't remove the declaration.\n   45  };\n   46  \n\n/home/max/dev/Falcor/src/RenderPasses/ImageLoader/ImageLoader.cpp:\n   48  }\n   49  \n   50: RenderPassReflection ImageLoader::reflect(const CompileData& compileData) {\n   51      RenderPassReflection reflector;\n   52      reflector.addOutput(kDst, \"Destination texture\");\n   ..\n   85  ImageLoader::ImageLoader(Device::SharedPtr pDevice): RenderPass(pDevice) {}\n   86  \n   87: void ImageLoader::compile(RenderContext* pContext, const CompileData& compileData) {\n   88:     if (!mpTex) throw std::runtime_error(\"ImageLoader::compile - No image loaded!\");\n   89  }\n   90  \n\n/home/max/dev/Falcor/src/RenderPasses/ImageLoader/ImageLoader.h:\n   44      static SharedPtr create(RenderContext* pRenderContext = nullptr, const Dictionary& dict = {});\n   45  \n   46:     virtual RenderPassReflection reflect(const CompileData& compileData) override;\n   47:     virtual void compile(RenderContext* pContext, const CompileData& compileData) override;\n   48      virtual void execute(RenderContext* pContext, const RenderData& renderData) override;\n   49      virtual void renderUI(Gui::Widgets& widget) override;\n\n/home/max/dev/Falcor/src/RenderPasses/ImageLoader/ImageLoader.vcxproj:\n   63    <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n   64      <ClCompile>\n   65:       <PrecompiledHeader>\n   66:       </PrecompiledHeader>\n   67        <WarningLevel>Level3</WarningLevel>\n   68        <Optimization>Disabled</Optimization>\n   ..\n   80      <ClCompile>\n   81        <WarningLevel>Level3</WarningLevel>\n   82:       <PrecompiledHeader>\n   83:       </PrecompiledHeader>\n   84        <Optimization>MaxSpeed</Optimization>\n   85        <FunctionLevelLinking>true</FunctionLevelLinking>\n\n/home/max/dev/Falcor/src/RenderPasses/MegakernelPathTracer/MegakernelPathTracer.cpp:\n  102      if (!beginFrame(pRenderContext, renderData)) return;\n  103  \n  104:     // Set compile-time constants.\n  105      RtProgram::SharedPtr pProgram = mTracer.pProgram;\n  106      setStaticParams(pProgram.get());\n\n/home/max/dev/Falcor/src/RenderPasses/MegakernelPathTracer/MegakernelPathTracer.vcxproj:\n   67    <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n   68      <ClCompile>\n   69:       <PrecompiledHeader>\n   70:       </PrecompiledHeader>\n   71        <WarningLevel>Level3</WarningLevel>\n   72        <Optimization>Disabled</Optimization>\n   ..\n   84      <ClCompile>\n   85        <WarningLevel>Level3</WarningLevel>\n   86:       <PrecompiledHeader>\n   87:       </PrecompiledHeader>\n   88        <Optimization>MaxSpeed</Optimization>\n   89        <FunctionLevelLinking>true</FunctionLevelLinking>\n\n/home/max/dev/Falcor/src/RenderPasses/MegakernelPathTracer/PathTracer.rt.slang:\n   32      We import the path tracer utility functions defined in PathTracer.slang.\n   33  \n   34:     The host sets the compile-time constants in StaticParams.slang.\n   35      It also sets the following defines for optional I/O buffers:\n   36  \n   ..\n  167  \n  168              // Accumulate after clamping.\n  169:             // Note the comparison is written so that NaNs propagate (unless the compiler rewrites it).\n  170              // TODO: Check the generated code that this is the case.\n  171              outColor += gData.params.clampSamples && path.L > gData.params.clampThreshold ? gData.params.clampThreshold : path.L;\n  ...\n  190  \n  191      // Write outputs.\n  192:     // These are all optional so using compile-time checks to decide which ones to write.\n  193      if (isValid(gOutputColor)) gOutputColor[launchIndex] = float4(outColor, outAlpha);\n  194      if (isValid(gOutputAlbedo)) gOutputAlbedo[launchIndex] = float4(outAlbedo, 1);\n\n/home/max/dev/Falcor/src/RenderPasses/MinimalPathTracer/MinimalPathTracer.cpp:\n  102  }\n  103  \n  104: RenderPassReflection MinimalPathTracer::reflect(const CompileData& compileData)\n  105  {\n  106      RenderPassReflection reflector;\n\n/home/max/dev/Falcor/src/RenderPasses/MinimalPathTracer/MinimalPathTracer.h:\n   49      virtual std::string getDesc() override { return \"Minimal path tracer\"; }\n   50      virtual Dictionary getScriptingDictionary() override;\n   51:     virtual RenderPassReflection reflect(const CompileData& compileData) override;\n   52      virtual void execute(RenderContext* pRenderContext, const RenderData& renderData) override;\n   53      virtual void renderUI(Gui::Widgets& widget) override;\n\n/home/max/dev/Falcor/src/RenderPasses/MinimalPathTracer/MinimalPathTracer.vcxproj:\n   66    <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n   67      <ClCompile>\n   68:       <PrecompiledHeader>\n   69:       </PrecompiledHeader>\n   70        <WarningLevel>Level3</WarningLevel>\n   71        <Optimization>Disabled</Optimization>\n   ..\n   83      <ClCompile>\n   84        <WarningLevel>Level3</WarningLevel>\n   85:       <PrecompiledHeader>\n   86:       </PrecompiledHeader>\n   87        <Optimization>MaxSpeed</Optimization>\n   88        <FunctionLevelLinking>true</FunctionLevelLinking>\n\n/home/max/dev/Falcor/src/RenderPasses/PassLibraryTemplate/PassLibraryTemplate.cpp:\n   50  }\n   51  \n   52: RenderPassReflection RenderPassTemplate::reflect(const CompileData& compileData)\n   53  {\n   54      // Define the required resources here\n\n/home/max/dev/Falcor/src/RenderPasses/PassLibraryTemplate/PassLibraryTemplate.h:\n   47      virtual std::string getDesc() override { return \"Insert pass description here\"; }\n   48      virtual Dictionary getScriptingDictionary() override;\n   49:     virtual RenderPassReflection reflect(const CompileData& compileData) override;\n   50:     virtual void compile(RenderContext* pContext, const CompileData& compileData) override {}\n   51      virtual void execute(RenderContext* pRenderContext, const RenderData& renderData) override;\n   52      virtual void renderUI(Gui::Widgets& widget) override;\n\n/home/max/dev/Falcor/src/RenderPasses/PassLibraryTemplate/PassLibraryTemplate.vcxproj:\n   63    <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n   64      <ClCompile>\n   65:       <PrecompiledHeader>\n   66:       </PrecompiledHeader>\n   67        <WarningLevel>Level3</WarningLevel>\n   68        <Optimization>Disabled</Optimization>\n   ..\n   80      <ClCompile>\n   81        <WarningLevel>Level3</WarningLevel>\n   82:       <PrecompiledHeader>\n   83:       </PrecompiledHeader>\n   84        <Optimization>MaxSpeed</Optimization>\n   85        <FunctionLevelLinking>true</FunctionLevelLinking>\n\n/home/max/dev/Falcor/src/RenderPasses/PixelInspectorPass/PixelInspectorPass.cpp:\n   88  }\n   89  \n   90: RenderPassReflection PixelInspectorPass::reflect(const CompileData& compileData) {\n   91      // Define the required resources here\n   92      RenderPassReflection reflector;\n\n/home/max/dev/Falcor/src/RenderPasses/PixelInspectorPass/PixelInspectorPass.h:\n   44  \n   45      virtual std::string getDesc() override;\n   46:     virtual RenderPassReflection reflect(const CompileData& compileData) override;\n   47      virtual void execute(RenderContext* pRenderContext, const RenderData& renderData) override;\n   48      virtual void renderUI(Gui::Widgets& widget) override;\n\n/home/max/dev/Falcor/src/RenderPasses/PixelInspectorPass/PixelInspectorPass.vcxproj:\n   67    <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n   68      <ClCompile>\n   69:       <PrecompiledHeader>\n   70:       </PrecompiledHeader>\n   71        <WarningLevel>Level3</WarningLevel>\n   72        <Optimization>Disabled</Optimization>\n   ..\n   84      <ClCompile>\n   85        <WarningLevel>Level3</WarningLevel>\n   86:       <PrecompiledHeader>\n   87:       </PrecompiledHeader>\n   88        <Optimization>MaxSpeed</Optimization>\n   89        <FunctionLevelLinking>true</FunctionLevelLinking>\n\n/home/max/dev/Falcor/src/RenderPasses/SkyBox/SkyBox.cpp:\n  125  }\n  126  \n  127: RenderPassReflection SkyBox::reflect(const CompileData& compileData) {\n  128      RenderPassReflection reflector;\n  129      reflector.addOutput(kTarget, \"Color buffer\").format(ResourceFormat::RGBA32Float);\n\n/home/max/dev/Falcor/src/RenderPasses/SkyBox/SkyBox.h:\n   45      std::string getDesc() override { return kDesc; }\n   46      virtual Dictionary getScriptingDictionary() override;\n   47:     virtual RenderPassReflection reflect(const CompileData& compileData) override;\n   48      virtual void execute(RenderContext* pRenderContext, const RenderData& renderData) override;\n   49      virtual void setScene(RenderContext* pRenderContext, const Scene::SharedPtr& pScene) override;\n\n/home/max/dev/Falcor/src/RenderPasses/SkyBox/SkyBox.vcxproj:\n   66    <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n   67      <ClCompile>\n   68:       <PrecompiledHeader>\n   69:       </PrecompiledHeader>\n   70        <WarningLevel>Level3</WarningLevel>\n   71        <Optimization>Disabled</Optimization>\n   ..\n   83      <ClCompile>\n   84        <WarningLevel>Level3</WarningLevel>\n   85:       <PrecompiledHeader>\n   86:       </PrecompiledHeader>\n   87        <Optimization>MaxSpeed</Optimization>\n   88        <FunctionLevelLinking>true</FunctionLevelLinking>\n\n/home/max/dev/Falcor/src/RenderPasses/SSAO/SSAO.cpp:\n  126  }\n  127  \n  128: RenderPassReflection SSAO::reflect(const CompileData& compileData) {\n  129      RenderPassReflection reflector;\n  130      reflector.addInput(kColorIn, \"Color buffer\");\n  ...\n  136  }\n  137  \n  138: void SSAO::compile(RenderContext* pRenderContext, const CompileData& compileData) {\n  139      auto pDevice = pRenderContext->device();\n  140      Fbo::Desc fboDesc(pDevice);\n\n/home/max/dev/Falcor/src/RenderPasses/SSAO/SSAO.h:\n   52      std::string getDesc() override { return kDesc; }\n   53      virtual Dictionary getScriptingDictionary() override;\n   54:     virtual RenderPassReflection reflect(const CompileData& compileData) override;\n   55:     virtual void compile(RenderContext* pRenderContext, const CompileData& compileData) override;\n   56      virtual void execute(RenderContext* pRenderContext, const RenderData& renderData) override;\n   57      virtual void setScene(RenderContext* pRenderContext, const Scene::SharedPtr& pScene) override { mpScene = pScene; }\n\n/home/max/dev/Falcor/src/RenderPasses/SSAO/SSAO.vcxproj:\n   71    <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n   72      <ClCompile>\n   73:       <PrecompiledHeader>\n   74:       </PrecompiledHeader>\n   75        <WarningLevel>Level3</WarningLevel>\n   76        <Optimization>Disabled</Optimization>\n   ..\n   88      <ClCompile>\n   89        <WarningLevel>Level3</WarningLevel>\n   90:       <PrecompiledHeader>\n   91:       </PrecompiledHeader>\n   92        <Optimization>MaxSpeed</Optimization>\n   93        <FunctionLevelLinking>true</FunctionLevelLinking>\n\n/home/max/dev/Falcor/src/RenderPasses/SVGFPass/SVGFAtrous.ps.slang:\n   77      const float kernelWeights[3] = { 1.0, 2.0 / 3.0, 1.0 / 6.0 };\n   78  \n   79:     // constant samplers to prevent the compiler from generating code which\n   80      // fetches the sampler descriptor from memory for each texture access\n   81      const float4 illuminationCenter = gIllumination.Load(int3(ipos, 0));\n\n/home/max/dev/Falcor/src/RenderPasses/SVGFPass/SVGFPass.cpp:\n  135  */\n  136  \n  137: RenderPassReflection SVGFPass::reflect(const CompileData& compileData) {\n  138      RenderPassReflection reflector;\n  139  \n  ...\n  165  }\n  166  \n  167: void SVGFPass::compile(RenderContext* pRenderContext, const CompileData& compileData) {\n  168:     allocateFbos(compileData.defaultTexDims, pRenderContext);\n  169      mBuffersNeedClear = true;\n  170  }\n\n/home/max/dev/Falcor/src/RenderPasses/SVGFPass/SVGFPass.h:\n   42      virtual std::string getDesc() override { return \"SVGF Denoising Pass\"; }\n   43      virtual Dictionary getScriptingDictionary() override;\n   44:     virtual RenderPassReflection reflect(const CompileData& compileData) override;\n   45      virtual void execute(RenderContext* pRenderContext, const RenderData& renderData) override;\n   46:     virtual void compile(RenderContext* pContext, const CompileData& compileData) override;\n   47      virtual void renderUI(Gui::Widgets& widget) override;\n   48  \n\n/home/max/dev/Falcor/src/RenderPasses/SVGFPass/SVGFPass.vcxproj:\n   71    <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n   72      <ClCompile>\n   73:       <PrecompiledHeader>\n   74:       </PrecompiledHeader>\n   75        <WarningLevel>Level3</WarningLevel>\n   76        <Optimization>Disabled</Optimization>\n   ..\n   88      <ClCompile>\n   89        <WarningLevel>Level3</WarningLevel>\n   90:       <PrecompiledHeader>\n   91:       </PrecompiledHeader>\n   92        <Optimization>MaxSpeed</Optimization>\n   93        <FunctionLevelLinking>true</FunctionLevelLinking>\n\n/home/max/dev/Falcor/src/RenderPasses/TemporalDelayPass/TemporalDelayPass.cpp:\n   63  }\n   64  \n   65: RenderPassReflection TemporalDelayPass::reflect(const CompileData& compileData) {\n   66      RenderPassReflection r;\n   67      mReady = false;\n   68:     if (compileData.connectedResources.getFieldCount() > 0) {\n   69:         const RenderPassReflection::Field* edge = compileData.connectedResources.getField(kSrc);\n   70          RenderPassReflection::Field::Type srcType = edge->getType();\n   71          ResourceFormat srcFormat = edge->getFormat();\n   ..\n  101  }\n  102  \n  103: void TemporalDelayPass::compile(RenderContext* pContext, const CompileData& compileData) {\n  104:     if (!mReady) throw(std::runtime_error(\"TemporalDelayPass::compile - missing incoming reflection information\"));\n  105  }\n  106  \n\n/home/max/dev/Falcor/src/RenderPasses/TemporalDelayPass/TemporalDelayPass.h:\n   42      static SharedPtr create(RenderContext* pRenderContext = nullptr, const Dictionary& dict = {});\n   43  \n   44:     virtual RenderPassReflection reflect(const CompileData& compileData) override;\n   45:     virtual void compile(RenderContext* pContext, const CompileData& compileData) override;\n   46      virtual void execute(RenderContext* pRenderContext, const RenderData& renderData) override;\n   47      virtual Dictionary getScriptingDictionary() override;\n\n/home/max/dev/Falcor/src/RenderPasses/TemporalDelayPass/TemporalDelayPass.vcxproj:\n   61    <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n   62      <ClCompile>\n   63:       <PrecompiledHeader>\n   64:       </PrecompiledHeader>\n   65        <WarningLevel>Level3</WarningLevel>\n   66        <Optimization>Disabled</Optimization>\n   ..\n   78      <ClCompile>\n   79        <WarningLevel>Level3</WarningLevel>\n   80:       <PrecompiledHeader>\n   81:       </PrecompiledHeader>\n   82        <Optimization>MaxSpeed</Optimization>\n   83        <FunctionLevelLinking>true</FunctionLevelLinking>\n\n/home/max/dev/Falcor/src/RenderPasses/ToneMapper/ToneMapper.cpp:\n  166  }\n  167  \n  168: RenderPassReflection ToneMapper::reflect(const CompileData& compileData) {\n  169      RenderPassReflection reflector;\n  170      reflector.addInput(kSrc, \"Source texture\");\n\n/home/max/dev/Falcor/src/RenderPasses/ToneMapper/ToneMapper.h:\n   49      std::string getDesc() override { return kDesc; }\n   50      virtual Dictionary getScriptingDictionary() override;\n   51:     virtual RenderPassReflection reflect(const CompileData& compileData) override;\n   52      virtual void execute(RenderContext* pRenderContext, const RenderData& renderData) override;\n   53      virtual void renderUI(Gui::Widgets& widget) override;\n\n/home/max/dev/Falcor/src/RenderPasses/ToneMapper/ToneMapper.vcxproj:\n   68    <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n   69      <ClCompile>\n   70:       <PrecompiledHeader>\n   71:       </PrecompiledHeader>\n   72        <WarningLevel>Level3</WarningLevel>\n   73        <Optimization>Disabled</Optimization>\n   ..\n   85      <ClCompile>\n   86        <WarningLevel>Level3</WarningLevel>\n   87:       <PrecompiledHeader>\n   88:       </PrecompiledHeader>\n   89        <Optimization>MaxSpeed</Optimization>\n   90        <FunctionLevelLinking>true</FunctionLevelLinking>\n\n/home/max/dev/Falcor/src/RenderPasses/Utils/Composite/Composite.cpp:\n   72  }\n   73  \n   74: RenderPassReflection Composite::reflect(const CompileData& compileData) {\n   75      RenderPassReflection reflector;\n   76      reflector.addInput(kInputA, \"Input A\").bindFlags(ResourceBindFlags::ShaderResource);\n   ..\n   80  }\n   81  \n   82: void Composite::compile(RenderContext* pContext, const CompileData& compileData) {\n   83:     mFrameDim = compileData.defaultTexDims;\n   84      mCompositePass[\"CB\"][\"frameDim\"] = mFrameDim;\n   85  }\n\n/home/max/dev/Falcor/src/RenderPasses/Utils/Composite/Composite.h:\n   43      virtual std::string getDesc() override { return kDesc; }\n   44      virtual Dictionary getScriptingDictionary() override;\n   45:     virtual RenderPassReflection reflect(const CompileData& compileData) override;\n   46:     virtual void compile(RenderContext* pContext, const CompileData& compileData) override;\n   47      virtual void execute(RenderContext* pRenderContext, const RenderData& renderData) override;\n   48      virtual void renderUI(Gui::Widgets& widget) override;\n\n/home/max/dev/Falcor/src/RenderPasses/Utils/GaussianBlur/GaussianBlur.cpp:\n   72  }\n   73  \n   74: RenderPassReflection GaussianBlur::reflect(const CompileData& compileData) {\n   75      RenderPassReflection reflector;\n   76      mReady = false;\n   77:     if (compileData.connectedResources.getFieldCount() > 0) {\n   78:         const RenderPassReflection::Field* edge = compileData.connectedResources.getField(kSrc);\n   79          RenderPassReflection::Field::Type srcType = edge->getType();\n   80          ResourceFormat srcFormat = edge->getFormat();\n   ..\n  100  }\n  101  \n  102: void GaussianBlur::compile(RenderContext* pContext, const CompileData& compileData) {\n  103:     if (!mReady) throw std::runtime_error(\"GaussianBlur::compile - missing incoming reflection information\");\n  104  \n  105:     uint32_t arraySize = compileData.connectedResources.getField(kSrc)->getArraySize();\n  106      Program::DefineList defines;\n  107      defines.add(\"_KERNEL_WIDTH\", std::to_string(mKernelWidth));\n\n/home/max/dev/Falcor/src/RenderPasses/Utils/GaussianBlur/GaussianBlur.h:\n   52      std::string getDesc() override { return kDesc; }\n   53      virtual Dictionary getScriptingDictionary() override;\n   54:     virtual RenderPassReflection reflect(const CompileData& compileData) override;\n   55:     virtual void compile(RenderContext* pContext, const CompileData& compileData) override;\n   56      virtual void execute(RenderContext* pRenderContext, const RenderData& renderData) override;\n   57      virtual void renderUI(Gui::Widgets& widget) override;\n\n/home/max/dev/Falcor/src/RenderPasses/Utils/Utils.vcxproj:\n   70    <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n   71      <ClCompile>\n   72:       <PrecompiledHeader>\n   73:       </PrecompiledHeader>\n   74        <WarningLevel>Level3</WarningLevel>\n   75        <Optimization>Disabled</Optimization>\n   ..\n   87      <ClCompile>\n   88        <WarningLevel>Level3</WarningLevel>\n   89:       <PrecompiledHeader>\n   90:       </PrecompiledHeader>\n   91        <Optimization>MaxSpeed</Optimization>\n   92        <FunctionLevelLinking>true</FunctionLevelLinking>\n\n/home/max/dev/Falcor/src/RenderPasses/WhittedRayTracer/WhittedRayTracer.cpp:\n  154  }\n  155  \n  156: RenderPassReflection WhittedRayTracer::reflect(const CompileData& compileData)\n  157  {\n  158      RenderPassReflection reflector;\n\n/home/max/dev/Falcor/src/RenderPasses/WhittedRayTracer/WhittedRayTracer.h:\n   51      virtual std::string getDesc() override { return \"Whitted ray tracer\"; }\n   52      virtual Dictionary getScriptingDictionary() override;\n   53:     virtual RenderPassReflection reflect(const CompileData& compileData) override;\n   54      virtual void execute(RenderContext* pRenderContext, const RenderData& renderData) override;\n   55      virtual void renderUI(Gui::Widgets& widget) override;\n\n/home/max/dev/Falcor/src/RenderPasses/WhittedRayTracer/WhittedRayTracer.vcxproj:\n   66    <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n   67      <ClCompile>\n   68:       <PrecompiledHeader>\n   69:       </PrecompiledHeader>\n   70        <WarningLevel>Level3</WarningLevel>\n   71        <Optimization>Disabled</Optimization>\n   ..\n   83      <ClCompile>\n   84        <WarningLevel>Level3</WarningLevel>\n   85:       <PrecompiledHeader>\n   86:       </PrecompiledHeader>\n   87        <Optimization>MaxSpeed</Optimization>\n   88        <FunctionLevelLinking>true</FunctionLevelLinking>\n\n/home/max/dev/Falcor/src/Samples/HelloDXR/HelloDXR.vcxproj:\n   67    <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n   68      <ClCompile>\n   69:       <PrecompiledHeader>\n   70:       </PrecompiledHeader>\n   71        <WarningLevel>Level3</WarningLevel>\n   72        <Optimization>Disabled</Optimization>\n   ..\n   84      <ClCompile>\n   85        <WarningLevel>Level3</WarningLevel>\n   86:       <PrecompiledHeader>\n   87:       </PrecompiledHeader>\n   88        <Optimization>MaxSpeed</Optimization>\n   89        <FunctionLevelLinking>true</FunctionLevelLinking>\n\n/home/max/dev/Falcor/src/Samples/ModelViewer/ModelViewer.vcxproj:\n   65    <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n   66      <ClCompile>\n   67:       <PrecompiledHeader>\n   68:       </PrecompiledHeader>\n   69        <WarningLevel>Level3</WarningLevel>\n   70        <Optimization>Disabled</Optimization>\n   ..\n   81      <ClCompile>\n   82        <WarningLevel>Level3</WarningLevel>\n   83:       <PrecompiledHeader>\n   84:       </PrecompiledHeader>\n   85        <Optimization>MaxSpeed</Optimization>\n   86        <FunctionLevelLinking>true</FunctionLevelLinking>\n\n/home/max/dev/Falcor/src/Samples/ProjectTemplate/ProjectTemplate.vcxproj:\n   62    <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n   63      <ClCompile>\n   64:       <PrecompiledHeader>\n   65:       </PrecompiledHeader>\n   66        <WarningLevel>Level3</WarningLevel>\n   67        <Optimization>Disabled</Optimization>\n   ..\n   78      <ClCompile>\n   79        <WarningLevel>Level3</WarningLevel>\n   80:       <PrecompiledHeader>\n   81:       </PrecompiledHeader>\n   82        <Optimization>MaxSpeed</Optimization>\n   83        <FunctionLevelLinking>true</FunctionLevelLinking>\n\n/home/max/dev/Falcor/src/Samples/ShaderToy/ShaderToy.vcxproj:\n   66    <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n   67      <ClCompile>\n   68:       <PrecompiledHeader>\n   69:       </PrecompiledHeader>\n   70        <WarningLevel>Level3</WarningLevel>\n   71        <Optimization>Disabled</Optimization>\n   ..\n   82      <ClCompile>\n   83        <WarningLevel>Level3</WarningLevel>\n   84:       <PrecompiledHeader>\n   85:       </PrecompiledHeader>\n   86        <Optimization>MaxSpeed</Optimization>\n   87        <FunctionLevelLinking>true</FunctionLevelLinking>\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/FalcorTest.vcxproj:\n  119    <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n  120      <ClCompile>\n  121:       <PrecompiledHeader>\n  122:       </PrecompiledHeader>\n  123        <WarningLevel>Level3</WarningLevel>\n  124        <Optimization>Disabled</Optimization>\n  ...\n  136      <ClCompile>\n  137        <WarningLevel>Level3</WarningLevel>\n  138:       <PrecompiledHeader>\n  139:       </PrecompiledHeader>\n  140        <Optimization>MaxSpeed</Optimization>\n  141        <FunctionLevelLinking>true</FunctionLevelLinking>\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Core/RootBufferParamBlockTests.cpp:\n   49          {\n   50              Program::DefineList defines = { {\"USE_UAV\", useUav ? \"1\" : \"0\"} };\n   51:             Shader::CompilerFlags compilerFlags = Shader::CompilerFlags::None; // Shader::CompilerFlags::DumpIntermediates;\n   52  \n   53              // Create parameter block based on reflection of a dummy program.\n   ..\n  109              // Create test program and bind the parameter block.\n  110              LOG_DBG(\"Create test program\");\n  111:             ctx.createProgram(kTestProgram, \"main\", defines, compilerFlags, shaderModel);\n  112              ctx.allocateStructuredBuffer(\"result\", kNumElems);\n  113  \n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Core/RootBufferStructTests.cpp:\n   43          {\n   44              Program::DefineList defines = { {\"USE_UAV\", useUav ? \"1\" : \"0\"} };\n   45:             Shader::CompilerFlags compilerFlags = Shader::CompilerFlags::None; // Shader::CompilerFlags::DumpIntermediates;\n   46  \n   47:             ctx.createProgram(\"Tests/Core/RootBufferStructTests.cs.slang\", \"main\", defines, compilerFlags, shaderModel);\n   48              ctx.allocateStructuredBuffer(\"result\", kNumElems);\n   49  \n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Core/RootBufferTests.cpp:\n   52          {\n   53              Program::DefineList defines = { {\"USE_UAV\", useUav ? \"1\" : \"0\"} };\n   54:             Shader::CompilerFlags compilerFlags = Shader::CompilerFlags::None; // Shader::CompilerFlags::DumpIntermediates;\n   55  \n   56:             ctx.createProgram(\"Tests/Core/RootBufferTests.cs.slang\", \"main\", defines, compilerFlags, shaderModel);\n   57              ctx.allocateStructuredBuffer(\"result\", kNumElems);\n   58  \n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Scene/EnvProbeTests.cpp:\n   41          // Test loading a light probe.\n   42          // This call runs setup code on the GPU to precompute the importance map.\n   43:         // If it succeeds, we at least know the code compiles and run.\n   44          EnvProbe::SharedPtr pEnvProbe = EnvProbe::create(ctx.getRenderContext(), kLightProbeFile);\n   45          EXPECT_NE(pEnvProbe, nullptr);\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Slang/TraceRayInline.cpp:\n   32  \n   33  GPU_TEST(testTraceRayInlineAPI, \"Requires shader model 6.5\") {\n   34:     // We don't actually run the program, just make sure it compiles.\n   35      ctx.createProgram(\"Tests/Slang/TraceRayInline.cs.slang\", \"testTraceRayInlineAPI\", Program::DefineList(), Shader::CompilerFlags::None, \"6_5\");\n   36  }\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Slang/TraceRayInline.cs.slang:\n   27   **************************************************************************/\n   28  \n   29: /** This is a test that all related API functions compile.\n   30:     The program is not actually executed, just compiled.\n   31  */\n   32  \n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Utils/HalfUtilsTests.cpp:\n  278      /** Test our GPU-side utils for f32tof16 conversion with conservative rounding.\n  279          The test is written so that the conversion to fp16 is done on the GPU and the conversion\n  280:         back to fp32 on the CPU, to avoid shader compiler optimizations for interfering with the results.\n  281      */\n  282      GPU_TEST(FP32ToFP16ConservativeRoundingGPU)\n\n/home/max/dev/Falcor/src/Tools/ImageCompare/ImageCompare.vcxproj:\n   61    <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n   62      <ClCompile>\n   63:       <PrecompiledHeader>\n   64:       </PrecompiledHeader>\n   65        <WarningLevel>Level3</WarningLevel>\n   66        <Optimization>Disabled</Optimization>\n   ..\n   79      <ClCompile>\n   80        <WarningLevel>Level3</WarningLevel>\n   81:       <PrecompiledHeader>\n   82:       </PrecompiledHeader>\n   83        <Optimization>MaxSpeed</Optimization>\n   84        <FunctionLevelLinking>true</FunctionLevelLinking>\n\n/home/max/dev/Falcor/src/Tools/RenderGraphEditor/RenderGraphEditor.cpp:\n  182          try {\n  183              std::string s;\n  184:             mpGraphs[mCurrentGraphIndex]->compile(pRenderContext, s);\n  185          } catch (const std::exception&) {\n  186              MsgBoxButton msgBoxButton = msgBox(\"Attempting to save invalid graph.\\nGraph may not execute correctly when loaded\\nAre you sure you want to save the graph?\"\n  ...\n  280      if (settingsWindow.button(\"Validate Graph\")) {\n  281          std::string s;\n  282:         bool valid = mpGraphs[mCurrentGraphIndex]->compile(pRenderContext, s);\n  283          if (valid) s += \"The graph is valid\";\n  284          else s += std::string(\"The graph is invalid.\");\n  ...\n  318          try {\n  319              std::string s;\n  320:             mpGraphs[mCurrentGraphIndex]->compile(pRenderContext, s);\n  321          }\n  322          catch (const std::exception& e)\n\n/home/max/dev/Falcor/src/USD/hgiVk/device.h:\n  117      VkPipelineCache GetVulkanPipelineCache() const;\n  118  \n  119:     /// Returns the glsl to SPIRV shader compiler\n  120      HGIVK_API\n  121      HgiVkShaderCompiler* GetShaderCompiler();\n  ...\n  193      std::mutex _queuelock;\n  194  \n  195:     // glsl SPIRV shader compiler\n  196      HgiVkShaderCompiler _shaderCompiler;\n  197  \n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/GenericCodeGen/CodeGen.cpp:\n   43  public:\n   44      TGenericCompiler(EShLanguage l, int dOptions) : TCompiler(l, infoSink), debugOptions(dOptions) { }\n   45:     virtual bool compile(TIntermNode* root, int version = 0, EProfile profile = ENoProfile);\n   46      TInfoSink infoSink;\n   47      int debugOptions;\n   ..\n   50  //\n   51  // This function must be provided to create the actual\n   52: // compile object used by higher level code.  It returns\n   53  // a subclass of TCompiler.\n   54  //\n   ..\n   59  \n   60  //\n   61: // Delete the compiler made by ConstructCompiler\n   62  //\n   63: void DeleteCompiler(TCompiler* compiler)\n   64  {\n   65:     delete compiler;\n   66  }\n   67  \n   ..\n   69  //  Generate code from the given parse tree\n   70  //\n   71: bool TGenericCompiler::compile(TIntermNode* /*root*/, int /*version*/, EProfile /*profile*/)\n   72  {\n   73      haveValidObjectCode = true;\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/Include/arrays.h:\n  329      TArraySizes(const TArraySizes&);\n  330  \n  331:     // For tracking maximum referenced compile-time constant index.\n  332      // Applies only to the outer-most dimension. Potentially becomes\n  333      // the implicit size of the array, if not variably indexed and\n  334      // otherwise legal.\n  335      int implicitArraySize;\n  336:     bool variablyIndexed;  // true if array is indexed with a non compile-time constant\n  337  };\n  338  \n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/Include/Common.h:\n  198  //\n  199  // Persistent string memory.  Should only be used for strings that survive\n  200: // across compiles/links.\n  201  //\n  202  typedef std::basic_string<char> TPersistString;\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/Include/intermediate.h:\n  772  \n  773      // Can apply to arrays, vectors, or matrices.\n  774:     // Can be decomposed to a constant at compile time, but this does not always happen,\n  775      // due to link-time effects. So, consumer can expect either a link-time sized or\n  776      // run-time sized array.\n  ...\n 1221  public:\n 1222      // if symbol is initialized as symbol(sym), the memory comes from the pool allocator of sym. If sym comes from\n 1223:     // per process threadPoolAllocator, then it causes increased memory usage per compile\n 1224      // it is essential to use \"symbol = sym\" to assign to symbol\n 1225      TIntermSymbol(int i, const TString& n, const TType& t)\n ....\n 1255  #endif\n 1256      TString name;                // the name of the symbol this node represents\n 1257:     TConstUnionArray constArray; // if the symbol is a front-end compile-time constant, this is its value\n 1258      TIntermTyped* constSubtree;\n 1259  };\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/Include/PoolAlloc.h:\n   80          //    [allocationHeader][initialGuardBlock][userData][finalGuardBlock]\n   81          // This would be cleaner with if (guardBlockSize)..., but that\n   82:         // makes the compiler print warnings about 0 length memsets,\n   83          // even with the if() protecting them.\n   84  #       ifdef GUARD_BLOCKS\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/Include/ShHandle.h:\n   37  \n   38  //\n   39: // Machine independent part of the compiler private objects\n   40  // sent as ShHandle to the driver.\n   41  //\n   ..\n   84  \n   85  //\n   86: // The base class for the machine dependent compiler to derive from\n   87: // for managing object code from the compile.\n   88  //\n   89  class TCompiler : public TShHandleBase {\n   ..\n   94      virtual TInfoSink& getInfoSink() { return infoSink; }\n   95  \n   96:     virtual bool compile(TIntermNode* root, int version = 0, EProfile profile = ENoProfile) = 0;\n   97  \n   98      virtual TCompiler* getAsCompiler() { return this; }\n   ..\n  108  \n  109  //\n  110: // Link operations are based on a list of compile results...\n  111  //\n  112  typedef glslang::TVector<TCompiler*> TCompilerList;\n  ...\n  138      virtual void setExcludedAttributes(const int* attributes, int count) { excludedAttributes = attributes; excludedCount = count; }\n  139      virtual ShBindingTable* getUniformBindings() const  { return uniformBindings; }\n  140:     virtual const void* getObjectCode() const { return 0; } // a real compiler would be returning object code here\n  141      virtual TInfoSink& getInfoSink() { return infoSink; }\n  142      TInfoSink& infoSink;\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/Include/Types.h:\n  221          case EbtInt64:  s.append(\"i64\"); break;\n  222          case EbtUint64: s.append(\"u64\"); break;\n  223:         default:  break;  // some compilers want this\n  224          }\n  225          if (image) {\n  ...\n  248          case EsdBuffer:  s.append(\"Buffer\");  break;\n  249          case EsdSubpass: s.append(\"Input\"); break;\n  250:         default:  break;  // some compilers want this\n  251          }\n  252          if (ms)\n  ...\n 1709  \n 1710      // Recursively make the implicit array size the explicit array size.\n 1711:     // Expicit arrays are compile-time or link-time sized, never run-time sized.\n 1712      // Sometimes, policy calls for an array to be run-time sized even if it was\n 1713      // never variably indexed: Don't turn a 'skipNonvariablyIndexed' array into\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/Constant.cpp:\n  400      // First, size the result, which is mostly the same as the argument's size,\n  401      // but not always, and classify what is componentwise.\n  402:     // Also, eliminate cases that can't be compile-time constant.\n  403      int resultSize;\n  404      bool componentWise = true;\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/glslang.y:\n  513              case EOpLogicalNot: errorOp[0] = '!'; break;\n  514              case EOpBitwiseNot: errorOp[0] = '~'; break;\n  515:             default: break; // some compilers want this\n  516              }\n  517              $$ = parseContext.handleUnaryMath($1.loc, errorOp, $1.op, $2);\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/glslang_tab.cpp:\n  750         and a page size can be as small as 4096 bytes.  So we cannot safely\n  751         invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number\n  752:        to allow for a few compiler-allocated temporary stack slots.  */\n  753  #   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */\n  754  #  endif\n  ...\n 3912  /* The semantic value of the lookahead symbol.  */\n 3913  /* Default value used for initialization, for pacifying older GCCs\n 3914:    or non-GCC compilers.  */\n 3915  YY_INITIAL_VALUE (static YYSTYPE yyval_default;)\n 3916  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n ....\n 4516              case EOpLogicalNot: errorOp[0] = '!'; break;\n 4517              case EOpBitwiseNot: errorOp[0] = '~'; break;\n 4518:             default: break; // some compilers want this\n 4519              }\n 4520              (yyval.interm.intermTypedNode) = parseContext.handleUnaryMath((yyvsp[-1].interm).loc, errorOp, (yyvsp[-1].interm).op, (yyvsp[0].interm.intermTypedNode));\n ....\n 10353  yyerrorlab:\n 10354  \n 10355:   /* Pacify compilers like GCC when the user code never invokes\n 10356       YYERROR and the label yyerrorlab therefore never appears in user\n 10357       code.  */\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/Intermediate.cpp:\n  376          if (child->getType().getBasicType() == EbtStruct || child->getType().isArray())\n  377              return nullptr;\n  378:     default: break; // some compilers want this\n  379      }\n  380  \n  ...\n  396      case EOpConstructDouble: newType = EbtDouble; break;\n  397      case EOpConstructFloat16: newType = EbtFloat16; break;\n  398:     default: break; // some compilers want this\n  399      }\n  400  \n  ...\n  427      case EOpConstructFloat16:\n  428          return child;\n  429:     default: break; // some compilers want this\n  430      }\n  431  \n  ...\n 2005                  case 3: op = EOpConstructMat2x3; break;\n 2006                  case 4: op = EOpConstructMat2x4; break;\n 2007:                 default: break; // some compilers want this\n 2008                  }\n 2009                  break;\n ....\n 2013                  case 3: op = EOpConstructMat3x3; break;\n 2014                  case 4: op = EOpConstructMat3x4; break;\n 2015:                 default: break; // some compilers want this\n 2016                  }\n 2017                  break;\n ....\n 2021                  case 3: op = EOpConstructMat4x3; break;\n 2022                  case 4: op = EOpConstructMat4x4; break;\n 2023:                 default: break; // some compilers want this\n 2024                  }\n 2025                  break;\n 2026:             default: break; // some compilers want this\n 2027              }\n 2028          } else {\n ....\n 2032              case 3: op = EOpConstructVec3;  break;\n 2033              case 4: op = EOpConstructVec4;  break;\n 2034:             default: break; // some compilers want this\n 2035              }\n 2036          }\n ....\n 2044                  case 3: op = EOpConstructDMat2x3; break;\n 2045                  case 4: op = EOpConstructDMat2x4; break;\n 2046:                 default: break; // some compilers want this\n 2047                  }\n 2048                  break;\n ....\n 2052                  case 3: op = EOpConstructDMat3x3; break;\n 2053                  case 4: op = EOpConstructDMat3x4; break;\n 2054:                 default: break; // some compilers want this\n 2055                  }\n 2056                  break;\n ....\n 2060                  case 3: op = EOpConstructDMat4x3; break;\n 2061                  case 4: op = EOpConstructDMat4x4; break;\n 2062:                 default: break; // some compilers want this\n 2063                  }\n 2064                  break;\n ....\n 2070              case 3: op = EOpConstructDVec3;  break;\n 2071              case 4: op = EOpConstructDVec4;  break;\n 2072:             default: break; // some compilers want this\n 2073              }\n 2074          }\n ....\n 2082                  case 3: op = EOpConstructF16Mat2x3; break;\n 2083                  case 4: op = EOpConstructF16Mat2x4; break;\n 2084:                 default: break; // some compilers want this\n 2085                  }\n 2086                  break;\n ....\n 2090                  case 3: op = EOpConstructF16Mat3x3; break;\n 2091                  case 4: op = EOpConstructF16Mat3x4; break;\n 2092:                 default: break; // some compilers want this\n 2093                  }\n 2094                  break;\n ....\n 2098                  case 3: op = EOpConstructF16Mat4x3; break;\n 2099                  case 4: op = EOpConstructF16Mat4x4; break;\n 2100:                 default: break; // some compilers want this\n 2101                  }\n 2102                  break;\n ....\n 2109              case 3: op = EOpConstructF16Vec3;  break;\n 2110              case 4: op = EOpConstructF16Vec4;  break;\n 2111:             default: break; // some compilers want this\n 2112              }\n 2113          }\n ....\n 2119          case 3: op = EOpConstructI8Vec3; break;\n 2120          case 4: op = EOpConstructI8Vec4; break;\n 2121:         default: break; // some compilers want this\n 2122          }\n 2123          break;\n ....\n 2128          case 3: op = EOpConstructU8Vec3; break;\n 2129          case 4: op = EOpConstructU8Vec4; break;\n 2130:         default: break; // some compilers want this\n 2131          }\n 2132          break;\n ....\n 2137          case 3: op = EOpConstructI16Vec3; break;\n 2138          case 4: op = EOpConstructI16Vec4; break;\n 2139:         default: break; // some compilers want this\n 2140          }\n 2141          break;\n ....\n 2146          case 3: op = EOpConstructU16Vec3; break;\n 2147          case 4: op = EOpConstructU16Vec4; break;\n 2148:         default: break; // some compilers want this\n 2149          }\n 2150          break;\n ....\n 2157                  case 3: op = EOpConstructIMat2x3; break;\n 2158                  case 4: op = EOpConstructIMat2x4; break;\n 2159:                 default: break; // some compilers want this\n 2160                  }\n 2161                  break;\n ....\n 2165                  case 3: op = EOpConstructIMat3x3; break;\n 2166                  case 4: op = EOpConstructIMat3x4; break;\n 2167:                 default: break; // some compilers want this\n 2168                  }\n 2169                  break;\n ....\n 2173                  case 3: op = EOpConstructIMat4x3; break;\n 2174                  case 4: op = EOpConstructIMat4x4; break;\n 2175:                 default: break; // some compilers want this\n 2176                  }\n 2177                  break;\n ....\n 2183              case 3: op = EOpConstructIVec3; break;\n 2184              case 4: op = EOpConstructIVec4; break;\n 2185:             default: break; // some compilers want this\n 2186              }\n 2187          }\n ....\n 2195                  case 3: op = EOpConstructUMat2x3; break;\n 2196                  case 4: op = EOpConstructUMat2x4; break;\n 2197:                 default: break; // some compilers want this\n 2198                  }\n 2199                  break;\n ....\n 2203                  case 3: op = EOpConstructUMat3x3; break;\n 2204                  case 4: op = EOpConstructUMat3x4; break;\n 2205:                 default: break; // some compilers want this\n 2206                  }\n 2207                  break;\n ....\n 2211                  case 3: op = EOpConstructUMat4x3; break;\n 2212                  case 4: op = EOpConstructUMat4x4; break;\n 2213:                 default: break; // some compilers want this\n 2214                  }\n 2215                  break;\n ....\n 2221              case 3: op = EOpConstructUVec3; break;\n 2222              case 4: op = EOpConstructUVec4; break;\n 2223:             default: break; // some compilers want this\n 2224              }\n 2225          }\n ....\n 2231          case 3: op = EOpConstructI64Vec3; break;\n 2232          case 4: op = EOpConstructI64Vec4; break;\n 2233:         default: break; // some compilers want this\n 2234          }\n 2235          break;\n ....\n 2240          case 3: op = EOpConstructU64Vec3; break;\n 2241          case 4: op = EOpConstructU64Vec4; break;\n 2242:         default: break; // some compilers want this\n 2243          }\n 2244          break;\n ....\n 2251                  case 3: op = EOpConstructBMat2x3; break;\n 2252                  case 4: op = EOpConstructBMat2x4; break;\n 2253:                 default: break; // some compilers want this\n 2254                  }\n 2255                  break;\n ....\n 2259                  case 3: op = EOpConstructBMat3x3; break;\n 2260                  case 4: op = EOpConstructBMat3x4; break;\n 2261:                 default: break; // some compilers want this\n 2262                  }\n 2263                  break;\n ....\n 2267                  case 3: op = EOpConstructBMat4x3; break;\n 2268                  case 4: op = EOpConstructBMat4x4; break;\n 2269:                 default: break; // some compilers want this\n 2270                  }\n 2271                  break;\n ....\n 2277              case 3:  op = EOpConstructBVec3; break;\n 2278              case 4:  op = EOpConstructBVec4; break;\n 2279:             default: break; // some compilers want this\n 2280              }\n 2281          }\n ....\n 2377  {\n 2378      //\n 2379:     // Don't prune the false path for compile-time constants; it's needed\n 2380      // for static access analysis.\n 2381      //\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/linkValidate.cpp:\n   40  //\n   41  // Basic model is that during compilation, each compilation unit (shader) is\n   42: // compiled into one TIntermediate instance.  Then, at link time, multiple\n   43  // units for the same stage can be merged together, which can generate errors.\n   44  // Then, after all merging, a single instance of TIntermediate represents\n   ..\n  650  #endif\n  651  \n  652:         // \"It is a compile-time or link-time error to have\n  653          // any xfb_offset that overflows xfb_stride, whether stated on declarations before or after the xfb_stride, or\n  654          // in different compilation units. While xfb_stride can be declared multiple times for the same buffer, it is a\n  655:         // compile-time or link-time error to have different values specified for the stride for the same buffer.\"\n  656          if (xfbBuffers[b].stride != TQualifier::layoutXfbStrideEnd && xfbBuffers[b].implicitStride > xfbBuffers[b].stride) {\n  657              error(infoSink, \"xfb_stride is too small to hold all buffer entries:\");\n  ...\n  664          // \"If the buffer is capturing any\n  665          // outputs with double-precision or 64-bit integer components, the stride must be a multiple of 8, otherwise it must be a\n  666:         // multiple of 4, or a compile-time or link-time error results.\"\n  667          if (xfbBuffers[b].contains64BitType && ! IsMultipleOfPow2(xfbBuffers[b].stride, 8)) {\n  668              error(infoSink, \"xfb_stride must be multiple of 8 for buffer holding a double or 64-bit integer:\");\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/ParseContextBase.cpp:\n  277  \n  278  // Make a shared symbol have a non-shared version that can be edited by the current\n  279: // compile, such that editing its type will not change the shared version and will\n  280  // effect all nodes already sharing it (non-shallow type),\n  281  // or adopting its full type after being edited (shallow type).\n  ...\n  293  //\n  294  // Return nullptr if 'name' is not found.  This should mean\n  295: // something is seriously wrong (e.g., compiler asking self for\n  296  // built-in that doesn't exist).\n  297  TVariable* TParseContextBase::getEditableVariable(const char* name)\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/ParseHelper.cpp:\n  514  \n  515  // Make a shared symbol have a non-shared version that can be edited by the current\n  516: // compile, such that editing its type will not change the shared version and will\n  517  // effect all nodes sharing it.\n  518  void TParseContext::makeEditable(TSymbol*& symbol)\n  ...\n 1184                          requireInt8Arithmetic(arguments->getLoc(), \"built-in function\", \"(u)int8 types can only be in uniform block or buffer storage\");\n 1185  \n 1186:                     // TODO 4.5 functionality:  A shader will fail to compile\n 1187                      // if the value passed to the memargument of an atomic memory function does not correspond to a buffer or\n 1188                      // shared variable. It is acceptable to pass an element of an array or a single component of a vector to the\n ....\n 1816              // check for constant offsets\n 1817              if (! (*argp)[fnCandidate[0].type->getSampler().shadow ? 3 : 2]->getAsConstantUnion())\n 1818:                 error(loc, \"must be a compile-time constant:\", feature, \"offsets argument\");\n 1819              break;\n 1820          default:\n ....\n 1828                      error(loc, \"must be 0, 1, 2, or 3:\", feature, \"component argument\");\n 1829              } else\n 1830:                 error(loc, \"must be a compile-time constant:\", feature, \"component argument\");\n 1831          }\n 1832  \n ....\n 1885      {\n 1886          if (! (*argp)[1]->getAsConstantUnion())\n 1887:             error(loc, \"argument must be compile-time constant\", \"offset\", \"\");\n 1888          else {\n 1889              unsigned offset[4] = {};\n ....\n 1902      {\n 1903          if (! (*argp)[1]->getAsConstantUnion())\n 1904:             error(loc, \"argument must be compile-time constant\", \"mask\", \"\");\n 1905          else {\n 1906              unsigned mask[3] = {};\n ....\n 1948  #endif\n 1949              if (! (*argp)[arg]->getAsConstantUnion())\n 1950:                 error(loc, \"argument must be compile-time constant\", \"texel offset\", \"\");\n 1951              else {\n 1952                  const TType& type = (*argp)[arg]->getAsTyped()->getType();\n ....\n 1965      case EOpTraceNV:\n 1966          if (!(*argp)[10]->getAsConstantUnion())\n 1967:             error(loc, \"argument must be compile-time constant\", \"payload number\", \"\");\n 1968          break;\n 1969      case EOpExecuteCallableNV:\n 1970          if (!(*argp)[1]->getAsConstantUnion())\n 1971:             error(loc, \"argument must be compile-time constant\", \"callable data number\", \"\");\n 1972          break;\n 1973  #endif\n ....\n 2064              else {\n 2065                  if (! (*argp)[1]->getAsConstantUnion())\n 2066:                     error(loc, \"argument must be compile-time constant\", \"vertex index\", \"\");\n 2067                  else {\n 2068                      unsigned vertexIdx = (*argp)[1]->getAsConstantUnion()->getConstArray()[0].getUConst();\n ....\n 2093          // - A power of 2.\n 2094          if ((*argp)[1]->getAsConstantUnion() == nullptr)\n 2095:             error(loc, \"argument must be compile-time constant\", \"cluster size\", \"\");\n 2096          else {\n 2097              int size = (*argp)[1]->getAsConstantUnion()->getConstArray()[0].getIConst();\n ....\n 2106          // <id> must be an integral constant expression.\n 2107          if ((*argp)[1]->getAsConstantUnion() == nullptr)\n 2108:             error(loc, \"argument must be compile-time constant\", \"id\", \"\");\n 2109          break;\n 2110  \n ....\n 2204                  int offsetArg = fnCandidate[0].type->getSampler().shadow ? 3 : 2;\n 2205                  if (! callNode.getSequence()[offsetArg]->getAsConstantUnion())\n 2206:                     error(loc, \"must be a compile-time constant:\", feature, \"offsets argument\");\n 2207              } else if (fnCandidate.getName().compare(\"textureGather\") == 0) {\n 2208                  // More than two arguments needs gpu_shader5, and rectangular or shadow needs gpu_shader5,\n ....\n 2222                          error(loc, \"must be 0, 1, 2, or 3:\", feature, \"component argument\");\n 2223                  } else\n 2224:                     error(loc, \"must be a compile-time constant:\", feature, \"component argument\");\n 2225              }\n 2226          } else {\n ....\n 2247                  if (arg > 0) {\n 2248                      if (! callNode.getSequence()[arg]->getAsConstantUnion())\n 2249:                         error(loc, \"argument must be compile-time constant\", \"texel offset\", \"\");\n 2250                      else {\n 2251                          const TType& type = callNode.getSequence()[arg]->getAsTyped()->getType();\n ....\n 2407              profileRequires(symbol->getLoc(), ENoProfile, 120, nullptr, \"gl_PointCoord\");\n 2408              break;\n 2409:         default: break; // some compilers want this\n 2410          }\n 2411      }\n ....\n 2430              // ...  tessellation control shader ...\n 2431              // If a per-vertex output variable is used as an l-value, it is a\n 2432:             // compile-time or link-time error if the expression indicating the\n 2433              // vertex index is not the identifier gl_InvocationID.\n 2434              if (language == EShLangTessControl) {\n ....\n 2583  {\n 2584      // \"Identifiers starting with \"gl_\" are reserved for use by OpenGL, and may not be\n 2585:     // declared in a shader; this results in a compile-time error.\"\n 2586      if (! symbolTable.atBuiltInLevel()) {\n 2587          if (builtInName(identifier))\n ....\n 2612      // undefined behavior.  All macro names prefixed with \"GL_\" (\"GL\" followed by a\n 2613      // single underscore) are also reserved, and defining such a name results in a\n 2614:     // compile-time error.\"\n 2615      // however, before that, ES tests required an error.\n 2616      if (strncmp(identifier, \"GL_\", 3) == 0)\n ....\n 2938  \n 2939          // \"If a matrix argument is given to a matrix constructor,\n 2940:         // it is a compile-time error to have any other arguments.\"\n 2941          if (function.getParamCount() != 1)\n 2942              error(loc, \"matrix constructed from matrix can only have one argument\", \"constructor\", \"\");\n ....\n 4785          return;\n 4786      }\n 4787:     // TODO: compile-time performance: may need to stop doing linear searches\n 4788      for (TLayoutFormat format = (TLayoutFormat)(ElfNone + 1); format < ElfCount; format = (TLayoutFormat)(format + 1)) {\n 4789          if (id == TQualifier::getLayoutFormatString(format)) {\n ....\n 5054              profileRequires(loc, ECoreProfile | ECompatibilityProfile, 440, E_GL_ARB_enhanced_layouts, feature);\n 5055          }\n 5056:         // \"The specified alignment must be a power of 2, or a compile-time error results.\"\n 5057          if (! IsPow2(value))\n 5058              error(loc, \"must be a power of 2\", \"align\", \"\");\n ....\n 5114          profileRequires(loc, ECoreProfile | ECompatibilityProfile, 440, E_GL_ARB_enhanced_layouts, feature);\n 5115          if (id == \"xfb_buffer\") {\n 5116:             // \"It is a compile-time error to specify an *xfb_buffer* that is greater than\n 5117              // the implementation-dependent constant gl_MaxTransformFeedbackBuffers.\"\n 5118              if (value >= resources.maxTransformFeedbackBuffers)\n ....\n 5263              profileRequires(loc, ECompatibilityProfile | ECoreProfile, 330, 2, exts, \"index layout qualifier on fragment output\");\n 5264  \n 5265:             // \"It is also a compile-time error if a fragment shader sets a layout index to less than 0 or greater than 1.\"\n 5266              if (value < 0 || value > 1) {\n 5267                  value = 0;\n ....\n 5513  // \"For some blocks declared as arrays, the location can only be applied at the block level:\n 5514  // When a block is declared as an array where additional locations are needed for each member\n 5515: // for each block array element, it is a compile-time error to specify locations on the block\n 5516  // members.  That is, when locations would be under specified by applying them on block members,\n 5517  // they are not allowed on block members.  For arrayed interfaces (those generally having an\n ....\n 5546          }\n 5547          if (qualifier.hasComponent()) {\n 5548:             // \"It is a compile-time error if this sequence of components gets larger than 3.\"\n 5549              if (qualifier.layoutComponent + type.getVectorSize() * (type.getBasicType() == EbtDouble ? 2 : 1) > 4)\n 5550                  error(loc, \"type overflows the available 4 components\", \"component\", \"\");\n 5551  \n 5552:             // \"It is a compile-time error to apply the component qualifier to a matrix, a structure, a block, or an array containing any of these.\"\n 5553              if (type.isMatrix() || type.getBasicType() == EbtBlock || type.getBasicType() == EbtStruct)\n 5554                  error(loc, \"cannot apply to a matrix, structure, or block\", \"component\", \"\");\n 5555  \n 5556:             // \" It is a compile-time error to use component 1 or 3 as the beginning of a double or dvec2.\"\n 5557              if (type.getBasicType() == EbtDouble)\n 5558                  if (qualifier.layoutComponent & 1)\n ....\n 5604  \n 5605          // \"The offset must be a multiple of the size of the first component of the first\n 5606:         // qualified variable or block member, or a compile-time error results. Further, if applied to an aggregate\n 5607          // containing a double or 64-bit integer, the offset must also be a multiple of 8...\"\n 5608          if ((type.containsBasicType(EbtDouble) || type.containsBasicType(EbtInt64) || type.containsBasicType(EbtUint64)) &&\n ....\n 5633          //\n 5634          // \"If the binding point for any uniform or shader storage block instance is less than zero, or greater than or\n 5635:         // equal to the implementation-dependent maximum number of uniform buffer bindings, a compile-time\n 5636          // error will occur. When the binding identifier is used with a uniform or shader storage block instanced as\n 5637          // an array of size N, all elements of the array from binding through binding + N - 1 must be within this\n ....\n 5651                          lastBinding += 1;\n 5652                          if (spvVersion.vulkan == 0)\n 5653:                             warn(loc, \"assuming binding count of one for compile-time checking of binding numbers for unsized array\", \"[]\", \"\");\n 5654                      }\n 5655                  }\n ....\n 5783          error(loc, \"cannot apply layout qualifiers to a shared variable\", \"shared\", \"\");\n 5784  \n 5785:     // \"It is a compile-time error to use *component* without also specifying the location qualifier (order does not matter).\"\n 5786      if (qualifier.hasComponent() && ! qualifier.hasLocation())\n 5787          error(loc, \"must specify 'location' to use 'component'\", \"component\", \"\");\n ....\n 5966                      numOffsets *= symbol.getType().getCumulativeArraySize();\n 5967                  else {\n 5968:                     // \"It is a compile-time error to declare an unsized array of atomic_uint.\"\n 5969                      error(loc, \"array must be explicitly sized\", \"atomic_uint\", \"\");\n 5970                  }\n ....\n 6122  // \"If a single function declaration is considered a better match than every\n 6123  // other matching function declaration, it will be used. Otherwise, a\n 6124: // compile-time semantic error for an ambiguous overloaded function call occurs.\n 6125  //\n 6126  // \"To determine whether the conversion for a single argument in one match is\n ....\n 6540      }\n 6541  \n 6542:     // Uniforms require a compile-time constant initializer\n 6543      if (qualifier == EvqUniform && ! initializer->getType().getQualifier().isFrontEndConstant()) {\n 6544          error(loc, \"uniform initializers must be constant\", \"=\", \"'%s'\", variable->getType().getCompleteString().c_str());\n ....\n 7274          //\n 7275          // \"Block names have no other use within a shader\n 7276:         // beyond interface matching; it is a compile-time error to use a block name at global scope for anything\n 7277          // other than as a block name (e.g., use of a block name for a global variable name or function name is\n 7278          // currently reserved).\"\n ....\n 7345      case EvqVaryingIn:\n 7346          profileRequires(loc, ~EEsProfile, 150, E_GL_ARB_separate_shader_objects, \"input block\");\n 7347:         // It is a compile-time error to have an input block in a vertex shader or an output block in a fragment shader\n 7348          // \"Compute shaders do not permit user-defined input variables...\"\n 7349          requireStage(loc, (EShLanguageMask)(EShLangTessControlMask|EShLangTessEvaluationMask|EShLangGeometryMask|EShLangFragmentMask\n ....\n 7460  {\n 7461      // \"If a block has no block-level location layout qualifier, it is required that either all or none of its members\n 7462:     // have a location layout qualifier, or a compile-time error results.\"\n 7463      if (! qualifier.hasLocation() && memberWithLocation && memberWithoutLocation)\n 7464          error(loc, \"either the block needs a location, or all members need a location, or no members have a location\", \"location\", \"\");\n ....\n 7471                  qualifier.layoutLocation = TQualifier::layoutLocationEnd;\n 7472                  if (qualifier.hasComponent()) {\n 7473:                     // \"It is a compile-time error to apply the *component* qualifier to a ... block\"\n 7474                      error(loc, \"cannot apply to a block\", \"component\", \"\");\n 7475                  }\n ....\n 7565          if (memberQualifier.hasOffset()) {\n 7566              // \"The specified offset must be a multiple\n 7567:             // of the base alignment of the type of the block member it qualifies, or a compile-time error results.\"\n 7568              if (! IsMultipleOfPow2(memberQualifier.layoutOffset, memberAlignment))\n 7569                  error(memberLoc, \"must be a multiple of the member's alignment\", \"offset\", \"\");\n 7570  \n 7571:             // GLSL: \"It is a compile-time error to specify an offset that is smaller than the offset of the previous\n 7572              // member in the block or that lies within the previous member of the block\"\n 7573              if (spvVersion.spv == 0) {\n ....\n 7581                  offset = std::max(offset, memberQualifier.layoutOffset);\n 7582              } else {\n 7583:                 // TODO: Vulkan: \"It is a compile-time error to have any offset, explicit or assigned,\n 7584                  // that lies within another member of the block.\"\n 7585  \n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/parseVersions.h:\n  147      TMap<TString, TExtensionBehavior> extensionBehavior;    // for each extension string, what its current behavior is set to\n  148      EShMessages messages;        // errors/warnings/rule-sets\n  149:     int numErrors;               // number of compile-time errors encountered\n  150      TInputScanner* currentScanner;\n  151  \n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/reflection.cpp:\n   52  // 1. Put the entry point on the list of live functions.\n   53  //\n   54: // 2. Traverse any live function, while skipping if-tests with a compile-time constant\n   55  //    condition of false, and while adding any encountered function calls to the live\n   56  //    function list.\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/Scan.cpp:\n   56  #include \"preprocessor/PpTokens.h\"\n   57  \n   58: // Required to avoid missing prototype warnings for some compilers\n   59  int yylex(YYSTYPE*, glslang::TParseContext&);\n   60  \n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/ShaderLang.cpp:\n   37  \n   38  //\n   39: // Implement the top-level of interface to the compiler/linker,\n   40  // as defined in ShaderLang.h\n   41  // This is the platform independent interface between an OGL driver\n   42: // and the shading language compiler/linker.\n   43  //\n   44  #include <cstring>\n   ..\n  222  //\n  223  // Each has a different set of built-ins, and we want to preserve that from\n  224: // compile to compile.\n  225  //\n  226  TSymbolTable* CommonSymbolTable[VersionCount][SpvVersionCount][ProfileCount][SourceCount][EPcCount] = {};\n  ...\n  774  template<typename ProcessingContext>\n  775  bool ProcessDeferred(\n  776:     TCompiler* compiler,\n  777      const char* const shaderStrings[],\n  778      const int numStrings,\n  ...\n  836      EShSource source = (messages & EShMsgReadHlsl) != 0 ? EShSourceHlsl : EShSourceGlsl;\n  837      SpvVersion spvVersion;\n  838:     EShLanguage stage = compiler->getLanguage();\n  839      TranslateEnvironment(environment, messages, source, stage, spvVersion);\n  840      if (environment != nullptr && environment->target.hlslFunctionality1)\n  ...\n  855          if (! (messages & EShMsgSuppressWarnings) && ! versionNotFound &&\n  856              (version != defaultVersion || profile != defaultProfile)) {\n  857:             compiler->infoSink.info << \"Warning, (version, profile) forced to be (\"\n  858                                      << defaultVersion << \", \" << ProfileName(defaultProfile)\n  859                                      << \"), while in source code it is (\"\n  ...\n  870      }\n  871  \n  872:     bool goodVersion = DeduceVersionProfile(compiler->infoSink, stage,\n  873                                              versionNotFirst, defaultVersion, source, version, profile, spvVersion);\n  874      bool versionWillBeError = (versionNotFound || (profile == EEsProfile && version >= 300 && versionNotFirst));\n  ...\n  913      // Add built-in symbols that are potentially context dependent;\n  914      // they get popped again further down.\n  915:     if (! AddContextSpecificSymbols(resources, compiler->infoSink, *symbolTable, version, profile, spvVersion,\n  916                                      stage, source)) {\n  917          return false;\n  ...\n  919  \n  920      if (messages & EShMsgBuiltinSymbolTable)\n  921:         DumpBuiltinSymbolTable(compiler->infoSink, *symbolTable);\n  922  \n  923      //\n  ...\n  926  \n  927      std::unique_ptr<TParseContextBase> parseContext(CreateParseContext(*symbolTable, intermediate, version, profile, source,\n  928:                                                     stage, compiler->infoSink,\n  929                                                      spvVersion, forwardCompatible, messages, false, sourceEntryPointName));\n  930      TPpContext ppContext(*parseContext, names[numPre] ? names[numPre] : \"\", includer);\n  ...\n 1208  // is not an officially supported or fully working path.\n 1209  bool PreprocessDeferred(\n 1210:     TCompiler* compiler,\n 1211      const char* const shaderStrings[],\n 1212      const int numStrings,\n ....\n 1226  {\n 1227      DoPreprocessing parser(outputString);\n 1228:     return ProcessDeferred(compiler, shaderStrings, numStrings, inputLengths, stringNames,\n 1229                             preamble, optLevel, resources, defaultVersion,\n 1230                             defaultProfile, forceDefaultVersionAndProfile,\n ....\n 1234  \n 1235  //\n 1236: // do a partial compile on the given strings for a single compilation unit\n 1237: // for a potential deferred link into a single stage (and deferred full compile of that\n 1238  // stage through machine-dependent compilation).\n 1239  //\n ....\n 1245  //\n 1246  bool CompileDeferred(\n 1247:     TCompiler* compiler,\n 1248      const char* const shaderStrings[],\n 1249      const int numStrings,\n ....\n 1264  {\n 1265      DoFullParse parser;\n 1266:     return ProcessDeferred(compiler, shaderStrings, numStrings, inputLengths, stringNames,\n 1267                             preamble, optLevel, resources, defaultVersion,\n 1268                             defaultProfile, forceDefaultVersionAndProfile,\n ....\n 1299  \n 1300  //\n 1301: // Driver calls these to create and destroy compiler/linker\n 1302  // objects.\n 1303  //\n ....\n 1401  \n 1402  //\n 1403: // Do a full compile on the given strings for a single compilation unit\n 1404  // forming a complete stage.  The result of the machine dependent compilation\n 1405: // is left in the provided compile object.\n 1406  //\n 1407  // Return:  The return value is really boolean, indicating\n ....\n 1426  \n 1427      TShHandleBase* base = reinterpret_cast<TShHandleBase*>(handle);\n 1428:     TCompiler* compiler = base->getAsCompiler();\n 1429:     if (compiler == 0)\n 1430          return 0;\n 1431  \n 1432:     SetThreadPoolAllocator(compiler->getPool());\n 1433  \n 1434:     compiler->infoSink.info.erase();\n 1435:     compiler->infoSink.debug.erase();\n 1436  \n 1437:     TIntermediate intermediate(compiler->getLanguage());\n 1438      TShader::ForbidIncluder includer;\n 1439:     bool success = CompileDeferred(compiler, shaderStrings, numStrings, inputLengths, nullptr,\n 1440                                     \"\", optLevel, resources, defaultVersion, ENoProfile, false,\n 1441                                     forwardCompatible, messages, intermediate, includer);\n 1442  \n 1443      //\n 1444:     // Call the machine dependent compiler\n 1445      //\n 1446      if (success && intermediate.getTreeRoot() && optLevel != EShOptNoGeneration)\n 1447:         success = compiler->compile(intermediate.getTreeRoot(), intermediate.getVersion(), intermediate.getProfile());\n 1448  \n 1449      intermediate.removeTree();\n ....\n 1457  \n 1458  //\n 1459: // Link the given compile objects.\n 1460  //\n 1461  // Return:  The return value of is really boolean, indicating\n ....\n 1521  \n 1522  //\n 1523: // Return any compiler/linker/uniformmap log of messages for the application.\n 1524  //\n 1525  const char* ShGetInfoLog(const ShHandle handle)\n ....\n 1685  public:\n 1686      TDeferredCompiler(EShLanguage s, TInfoSink& i) : TCompiler(s, i) { }\n 1687:     virtual bool compile(TIntermNode*, int = 0, EProfile = ENoProfile) { return true; }\n 1688  };\n 1689  \n ....\n 1693      pool = new TPoolAllocator;\n 1694      infoSink = new TInfoSink;\n 1695:     compiler = new TDeferredCompiler(stage, *infoSink);\n 1696      intermediate = new TIntermediate(s);\n 1697  \n ....\n 1707  {\n 1708      delete infoSink;\n 1709:     delete compiler;\n 1710      delete intermediate;\n 1711      delete pool;\n ....\n 1810          preamble = \"\";\n 1811  \n 1812:     return CompileDeferred(compiler, strings, numStrings, lengths, stringNames,\n 1813                             preamble, EShOptNone, builtInResources, defaultVersion,\n 1814                             defaultProfile, forceDefaultVersionAndProfile,\n ....\n 1836          preamble = \"\";\n 1837  \n 1838:     return PreprocessDeferred(compiler, strings, numStrings, lengths, stringNames, preamble,\n 1839                                EShOptNone, builtInResources, defaultVersion,\n 1840                                defaultProfile, forceDefaultVersionAndProfile,\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/SymbolTable.cpp:\n   84          case EbtInt:   mangledName += \"i\"; break;\n   85          case EbtUint:  mangledName += \"u\"; break;\n   86:         default: break; // some compilers want this\n   87          }\n   88          if (sampler.image)\n   ..\n  110          case EsdBuffer:   mangledName += \"B\";  break;\n  111          case EsdSubpass:  mangledName += \"P\";  break;\n  112:         default: break; // some compilers want this\n  113          }\n  114  \n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/SymbolTable.h:\n   42  // Symbol table for parsing.  Has these design characteristics:\n   43  //\n   44: // * Same symbol table can be used to compile many shaders, to preserve\n   45  //   effort of creating and loading with the large numbers of built-in\n   46  //   symbols.\n   ..\n  206      // when this object is destroyed\n  207  \n  208:     TConstUnionArray constArray;               // for compile-time constant value\n  209      TIntermTyped* constSubtree;                // for specialization constant computation\n  210      TVector<TExtensionList>* memberExtensions; // per-member extension list, allocated only when needed\n  ...\n  596      // While level adopting is generic, the methods below enact a the following\n  597      // convention for levels:\n  598:     //   0: common built-ins shared across all stages, all compiles, only one copy for all symbol tables\n  599:     //   1: per-stage built-ins, shared across all compiles, but a different copy per stage\n  600:     //   2: built-ins specific to a compile, like resources that are context-dependent, or redeclared built-ins\n  601      //   3: user-shader globals\n  602      //\n  603  protected:\n  604      static const int globalLevel = 3;\n  605:     bool isSharedLevel(int level)  { return level <= 1; }              // exclude all per-compile levels\n  606      bool isBuiltInLevel(int level) { return level <= 2; }              // exclude user globals\n  607      bool isGlobalLevel(int level)  { return level <= globalLevel; }    // include user globals\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/Versions.cpp:\n  566                  okay = true;\n  567                  break;\n  568:             default: break; // some compilers want this\n  569              }\n  570          }\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/Versions.h:\n  104  //\n  105  // Symbolic names for extensions.  Strings may be directly used when calling the\n  106: // functions, but better to have the compiler do spelling checks.\n  107  //\n  108  const char* const E_GL_OES_texture_3D                   = \"GL_OES_texture_3D\";\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/OSDependent/Unix/ossource.cpp:\n  201          printf(\"Working set size: %ld\\n\", usage.ru_maxrss * 1024);\n  202  #else\n  203:     printf(\"Recompile with DUMP_COUNTERS defined to see counters.\\n\");\n  204  #endif\n  205  }\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/OSDependent/Windows/ossource.cpp:\n  141      printf(\"Working set size: %d\\n\", counters.WorkingSetSize);\n  142  #else\n  143:     printf(\"Recompile with DUMP_COUNTERS defined to see counters.\\n\");\n  144  #endif\n  145  }\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/Public/ShaderLang.h:\n   59  //\n   60  // This is the platform independent interface between an OGL driver\n   61: // and the shading language compiler/linker.\n   62  //\n   63  \n   ..\n   72  \n   73  //\n   74: // Call before doing any other compiler/linker operations.\n   75  //\n   76  // (Call once per process, not once per thread.)\n   ..\n   84  \n   85  //\n   86: // Types of languages the compiler can consume.\n   87  //\n   88  typedef enum {\n   ..\n  199  \n  200  //\n  201: // Optimization level for the compiler.\n  202  //\n  203  typedef enum {\n  ...\n  267  //\n  268  // ShHandle held by but opaque to the driver.  It is allocated,\n  269: // managed, and de-allocated by the compiler/linker. It's contents\n  270: // are defined by and used by the compiler and linker.  For example,\n  271: // symbol table information and object code passed from the compiler\n  272  // to the linker can be stored where ShHandle points.\n  273  //\n  ...\n  277  \n  278  //\n  279: // Driver calls these to create and destroy compiler/linker\n  280  // objects.\n  281  //\n  ...\n  307  SH_IMPORT_EXPORT int ShLinkExt(\n  308      const ShHandle,               // linker object\n  309:     const ShHandle h[],           // compiler objects to link together\n  310      const int numHandles);\n  311  \n  ...\n  350  // the intermediate results, including the parse tree, are preserved until link time,\n  351  // rather than the above interface which is designed to have each compilation unit\n  352: // lowered at compile time.  In the above model, linking occurs on the lowered results,\n  353  // whereas in this model intra-stage linking can occur at the parse tree\n  354  // (treeRoot in TIntermediate) level, and then a full stage can be lowered.\n  ...\n  582      TPoolAllocator* pool;\n  583      EShLanguage stage;\n  584:     TCompiler* compiler;\n  585      TIntermediate* intermediate;\n  586      TInfoSink* infoSink;\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/SPIRV/bitutils.h:\n   48  };\n   49  \n   50: // This is all compile-time so we can put our tests right here.\n   51  static_assert(SetBits<uint32_t, 0, 0>::get == uint32_t(0x00000000),\n   52                \"SetBits failed\");\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/SPIRV/GlslangToSpv.cpp:\n 3533      }\n 3534  \n 3535:     // Otherwise, need a compile-time (front end) size, get it:\n 3536      int size = arraySizes.getDimSize(dim);\n 3537      assert(size > 0);\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/SPIRV/hex_float.h:\n  264  \n  265    // These are all written like this because it is convenient to have\n  266:   // compile-time constants for all of these values.\n  267  \n  268    // Pass-through values to save typing.\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/SPIRV/SpvBuilder.cpp:\n 2316  \n 2317      // Otherwise, will use a two step process\n 2318:     // 1. make a compile-time 2D array of values\n 2319      // 2. construct a matrix from that array\n 2320  \n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/SPIRV/SpvBuilder.h:\n  532      // r-values should only be computed when they are needed, not speculatively.\n  533      //\n  534:     // Computing an l-value means saving away information for later use in the compiler,\n  535      // no code is generated until the l-value is later dereferenced.  It is okay\n  536      // to speculatively generate an l-value, just not okay to speculatively dereference it.\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/SPIRV/SPVRemapper.cpp:\n  242      // g++ doesn't like these defined in the class proper in an anonymous namespace.\n  243      // Dunno why.  Also MSVC doesn't like the constexpr keyword.  Also dunno why.\n  244:     // Defining them externally seems to please both compilers, so, here they are.\n  245      const spv::Id spirvbin_t::unmapped    = spv::Id(-10000);\n  246      const spv::Id spirvbin_t::unused      = spv::Id(-10001);\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/SPIRV/SPVRemapper.h:\n   87      void remap(std::vector<std::uint32_t>& /*spv*/, unsigned int /*opts = 0*/)\n   88      {\n   89:         printf(\"Tool not compiled for C++11, which is required for SPIR-V remapping.\\n\");\n   90          exit(5);\n   91      }\n\n/home/max/dev/Falcor/src/USD/hgiVk/pipeline.cpp:\n  324      // xxx we need to add a pipeline cache to avoid app having to keep compiling\n  325      // shader micro-code for every pipeline combination. We except that the\n  326:     // spir-V shader code is not compiled for the target device until this point\n  327      // where we create the pipeline. So a pipeline cache can be helpful.\n  328      // https://zeux.io/2019/07/17/serializing-pipeline-cache/\n\n/home/max/dev/Falcor/src/USD/hgiVk/shaderCompiler.cpp:\n   70      if (numShaderCodes==0 || !spirvOUT) {\n   71          if (errors) {\n   72:             errors->append(\"No shader to compile %s\", name);\n   73          }\n   74          return false;\n   ..\n  102  \n  103      //\n  104:     // Setup compiler limits/caps\n  105      //\n  106  \n\n/home/max/dev/Falcor/src/USD/hgiVk/shaderCompiler.h:\n   19  /// \\class HgiVkShaderCompiler\n   20  ///\n   21: /// Wrapper for glslang - a glsl compiler, validator and SPIRV backend.\n   22  ///\n   23  class HgiVkShaderCompiler final {\n   ..\n   38      /// For #include statements to be resolved, AddIncludeDir() must be called\n   39      /// before compiling shaders.\n   40:     /// 'name' is purely for debugging compile errors. It can be anything.\n   41      HGIVK_API\n   42      bool CompileGLSL(\n\n/home/max/dev/Falcor/src/USD/hgiVk/shaderFunction.h:\n   27      virtual ~HgiVkShaderFunction();\n   28  \n   29:     /// Returns false if any shader compile errors occured.\n   30      HGIVK_API\n   31      bool IsValid() const override;\n   32  \n   33:     /// Returns shader compile errors\n   34      HGIVK_API\n   35      std::string const& GetCompileErrors() override;\n\n/home/max/dev/Falcor/src/USD/hgiVk/vulkanMemoryAllocator/vk_mem_alloc.h:\n  136  Note on language: This library is written in C++, but has C-compatible interface.\n  137  Thus you can include and use vk_mem_alloc.h in C or C++ code, but full\n  138: implementation with `VMA_IMPLEMENTATION` macro must be compiled as C++, NOT as C.\n  139  \n  140  Please note that this library includes header `<vulkan/vulkan.h>`, which in turn\n  ...\n 1399  \n 1400  <b>To replay file:</b> Use VmaReplay - standalone command-line program.\n 1401: Precompiled binary can be found in \"bin\" directory.\n 1402  Its source can be found in \"src/VmaReplay\" directory.\n 1403  Its project is generated by Premake.\n ....\n 1753    and handled gracefully, because that would complicate code significantly and\n 1754    is usually not needed in desktop PC applications anyway.\n 1755: - Code free of any compiler warnings. Maintaining the library to compile and\n 1756    work correctly on so many different platforms is hard enough. Being free of \n 1757:   any warnings, on any version of any compiler, is simply not feasible.\n 1758  - This is a C++ library with C interface.\n 1759    Bindings or ports to any other programming languages are welcomed as external projects and\n ....\n 3607  #endif\n 3608  \n 3609: // If your compiler is not compatible with C++11 and definition of\n 3610  // aligned_alloc() function is missing, uncommeting following line may help:\n 3611  \n\n735 matches across 186 files\n\n\nSearching 1284 files for \"updateGraph\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraphImportExport.cpp:\n   36  namespace {\n   37  \n   38: void updateGraphStrings(std::string& graph, std::string& file, std::string& func) {\n   39      graph = graph.empty() ? \"renderGraph\" : graph;\n   40      file = file.empty() ? graph + \".py\" : file;\n   ..\n   63      while(true) {\n   64          try {\n   65:             updateGraphStrings(graphName, filename, funcName);\n   66              std::string custom;\n   67              if (funcName.size()) custom += \"\\n\" + graphName + '=' + funcName + \"()\";\n   ..\n  141      std::string funcName;\n  142      std::string graphName = pGraph->getName();\n  143:     updateGraphStrings(graphName, filename, funcName);\n  144  \n  145      // Save it to file\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraphUI.cpp:\n  560      }\n  561  \n  562:     void RenderGraphUI::updateGraph(RenderContext* pContext)\n  563      {\n  564          if (!mShouldUpdate) return;\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraphUI.h:\n  144          /** Update change for the graph based on script\n  145          */\n  146:         void updateGraph(RenderContext* pContext);\n  147  \n  148          /** Get name of reference graph\n\n/home/max/dev/Falcor/src/Tools/RenderGraphEditor/RenderGraphEditor.cpp:\n  476      const float4 clearColor(0.25, 0.25, 0.25 , 1);\n  477      pRenderContext->clearFbo(pTargetFbo.get(), clearColor, 1.0f, 0, FboAttachmentType::All);\n  478:     mRenderGraphUIs[mCurrentGraphIndex].updateGraph(pRenderContext);\n  479  }\n  480  \n\n6 matches across 4 files\n\n\nSearching 1284 files for \"executeActiveGraph\" (case sensitive)\n\n/home/max/dev/Falcor/src/Mogwai/Mogwai.cpp:\n  460  }\n  461  \n  462: void Renderer::executeActiveGraph(RenderContext* pRenderContext) {\n  463      if (mGraphs.empty()) return;\n  464      auto& pGraph = mGraphs[mActiveGraph].pGraph;\n  ...\n  499          }\n  500  \n  501:         executeActiveGraph(pRenderContext);\n  502  \n  503          // Blit main graph output to frame buffer.\n\n/home/max/dev/Falcor/src/Mogwai/Mogwai.h:\n  155      void setScene(Scene::ConstSharedPtrRef pScene);\n  156      Scene::SharedPtr getScene() const;\n  157:     void executeActiveGraph(RenderContext* pRenderContext);\n  158      void beginFrame(RenderContext* pRenderContext, const Fbo::SharedPtr& pTargetFbo);\n  159      void endFrame(RenderContext* pRenderContext, const Fbo::SharedPtr& pTargetFbo);\n\n3 matches across 2 files\n\n\nSearching 1284 files for \"onFrameRender\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/Renderer.h:\n  137      /** Called on each frame render.\n  138      */\n  139:     virtual void onFrameRender(RenderContext* pRenderContext, const std::shared_ptr<Fbo>& pTargetFbo) {}\n  140  \n  141      /** Called right before the context is destroyed.\n  ...\n  164      virtual bool onMouseEvent(const MouseEvent& mouseEvent) { return false; }\n  165  \n  166:     /** Called after onFrameRender().\n  167      It is highly recommended to use onGuiRender() exclusively for GUI handling. onGuiRender() will not be called when the GUI is hidden, which should help reduce CPU overhead.\n  168:     You could also ignore this and render the GUI directly in your onFrameRender() function, but that is discouraged.\n  169      */\n  170      virtual void onGuiRender(Gui* pGui) {};\n\n/home/max/dev/Falcor/src/Falcor/Core/Sample.cpp:\n  444  \n  445          {\n  446:             PROFILE(mpDevice, \"onFrameRender\");\n  447  \n  448              // The swap-chain FBO might have changed between frames, so get it\n  449              if (!mRendererPaused) {\n  450                  RenderContext* pRenderContext = mpDevice ? mpDevice->getRenderContext() : nullptr;\n  451:                 mpRenderer->onFrameRender(pRenderContext, mpTargetFBO);\n  452              }\n  453          }\n\n/home/max/dev/Falcor/src/Mogwai/Mogwai.cpp:\n  477  }\n  478  \n  479: void Renderer::onFrameRender(RenderContext* pRenderContext, const Fbo::SharedPtr& pTargetFbo) {\n  480      if (mScriptFilename.size()) {\n  481          std::string s = mScriptFilename;\n\n/home/max/dev/Falcor/src/Mogwai/Mogwai.h:\n  100  \n  101      void onLoad(RenderContext* pRenderContext) override;\n  102:     void onFrameRender(RenderContext* pRenderContext, const Fbo::SharedPtr& pTargetFbo) override;\n  103      void onResizeSwapChain(uint32_t width, uint32_t height) override;\n  104      bool onKeyEvent(const KeyboardEvent& e) override;\n\n/home/max/dev/Falcor/src/Samples/CudaInterop/CudaInterop.cpp:\n   56  }\n   57  \n   58: void CudaInterop::onFrameRender(RenderContext* pRenderContext, const Fbo::SharedPtr& pTargetFbo)\n   59  {\n   60      const float4 clearColor(0.38f, 0.52f, 0.10f, 1);\n\n/home/max/dev/Falcor/src/Samples/CudaInterop/CudaInterop.h:\n   37  public:\n   38      void onLoad(RenderContext* pRenderContext) override;\n   39:     void onFrameRender(RenderContext* pRenderContext, const Fbo::SharedPtr& pTargetFbo) override;\n   40  \n   41  private:\n\n/home/max/dev/Falcor/src/Samples/HelloDXR/HelloDXR.cpp:\n  118  }\n  119  \n  120: void HelloDXR::onFrameRender(RenderContext* pRenderContext, const Fbo::SharedPtr& pTargetFbo)\n  121  {\n  122      pRenderContext->clearFbo(pTargetFbo.get(), kClearColor, 1.0f, 0, FboAttachmentType::All);\n\n/home/max/dev/Falcor/src/Samples/HelloDXR/HelloDXR.h:\n   35  public:\n   36      void onLoad(RenderContext* pRenderContext) override;\n   37:     void onFrameRender(RenderContext* pRenderContext, const Fbo::SharedPtr& pTargetFbo) override;\n   38      void onResizeSwapChain(uint32_t width, uint32_t height) override;\n   39      bool onKeyEvent(const KeyboardEvent& keyEvent) override;\n\n/home/max/dev/Falcor/src/Samples/ModelViewer/ModelViewer.cpp:\n  158  }\n  159  \n  160: void ModelViewer::onFrameRender(RenderContext* pRenderContext, const Fbo::SharedPtr& pTargetFbo) {\n  161  \n  162      const float4 clearColor(0.38f, 0.52f, 0.10f, 1);\n\n/home/max/dev/Falcor/src/Samples/ModelViewer/ModelViewer.h:\n   35  public:\n   36      void onLoad(RenderContext* pRenderContext) override;\n   37:     void onFrameRender(RenderContext* pRenderContext, const Fbo::SharedPtr& pTargetFbo) override;\n   38      void onResizeSwapChain(uint32_t width, uint32_t height) override;\n   39      bool onKeyEvent(const KeyboardEvent& keyEvent) override;\n\n/home/max/dev/Falcor/src/Samples/ProjectTemplate/ProjectTemplate.cpp:\n   47  }\n   48  \n   49: void ProjectTemplate::onFrameRender(RenderContext* pRenderContext, const Fbo::SharedPtr& pTargetFbo)\n   50  {\n   51      const float4 clearColor(0.38f, 0.52f, 0.10f, 1);\n\n/home/max/dev/Falcor/src/Samples/ProjectTemplate/ProjectTemplate.h:\n   35  public:\n   36      void onLoad(RenderContext* pRenderContext) override;\n   37:     void onFrameRender(RenderContext* pRenderContext, const Fbo::SharedPtr& pTargetFbo) override;\n   38      void onShutdown() override;\n   39      void onResizeSwapChain(uint32_t width, uint32_t height) override;\n\n/home/max/dev/Falcor/src/Samples/ShaderToy/ShaderToy.cpp:\n   53  }\n   54  \n   55: void ShaderToy::onFrameRender(RenderContext* pRenderContext, const Fbo::SharedPtr& pTargetFbo) {\n   56      // iResolution\n   57      float width = (float)pTargetFbo->getWidth();\n\n/home/max/dev/Falcor/src/Samples/ShaderToy/ShaderToy.h:\n   37  \n   38      void onLoad(RenderContext* pRenderContext) override;\n   39:     void onFrameRender(RenderContext* pRenderContext, const Fbo::SharedPtr& pTargetFbo) override;\n   40      void onShutdown() override;\n   41      void onResizeSwapChain(uint32_t width, uint32_t height) override;\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/FalcorTest.cpp:\n   53  }\n   54  \n   55: void FalcorTest::onFrameRender(RenderContext* pRenderContext, const Fbo::SharedPtr& pTargetFbo) {\n   56      const char* kTestFilterSwitch = \"test_filter\";\n   57      ArgList argList = gpFramework->getArgList();\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/FalcorTest.h:\n   37   public:\n   38      void onLoad(RenderContext* pRenderContext) override;\n   39:     void onFrameRender(RenderContext* pRenderContext, const Fbo::SharedPtr& pTargetFbo) override;\n   40  };\n   41  \n\n/home/max/dev/Falcor/src/Tools/RenderGraphEditor/RenderGraphEditor.cpp:\n  473  }\n  474  \n  475: void RenderGraphEditor::onFrameRender(RenderContext* pRenderContext, const Fbo::SharedPtr& pTargetFbo) {\n  476      const float4 clearColor(0.25, 0.25, 0.25 , 1);\n  477      pRenderContext->clearFbo(pTargetFbo.get(), clearColor, 1.0f, 0, FboAttachmentType::All);\n\n/home/max/dev/Falcor/src/Tools/RenderGraphEditor/RenderGraphEditor.h:\n   39   public:\n   40      void onLoad(RenderContext* pRenderContext) override;\n   41:     void onFrameRender(RenderContext* pRenderContext, const Fbo::SharedPtr& pTargetFbo) override;\n   42      void onResizeSwapChain(uint32_t width, uint32_t height) override;\n   43      void onGuiRender(Gui* pGui) override;\n\n21 matches across 18 files\n\n\nSearching 1284 files for \"IRenderer\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/Renderer.h:\n  125  dlldecl extern IFramework* gpFramework;\n  126  \n  127: class IRenderer {\n  128   public:\n  129:     using UniquePtr = std::unique_ptr<IRenderer>;\n  130:     IRenderer(std::shared_ptr<Device> pDevice) { mpDevice = pDevice; }\n  131:     virtual ~IRenderer() {};\n  132  \n  133  \n  ...\n  187  \n  188      // Deleted copy operators (copy a pointer type!)\n  189:     IRenderer(const IRenderer&) = delete;\n  190:     IRenderer& operator=(const IRenderer &) = delete;\n  191  \n  192   protected:\n\n/home/max/dev/Falcor/src/Falcor/Core/Sample.cpp:\n   50  }\n   51  \n   52: Sample::Sample(IRenderer::UniquePtr& pRenderer) : mpRenderer(std::move(pRenderer)), mpDevice(nullptr) {\n   53      mClock = nullptr;\n   54      mFrameRate = nullptr;\n   ..\n  186      }\n  187  \n  188:     void Sample::run(const SampleConfig& config, IRenderer::UniquePtr& pRenderer, uint32_t argc, char** argv) {\n  189          Sample s(pRenderer);\n  190  \n  ...\n  197      }\n  198  \n  199:     void Sample::run(const std::string& filename, IRenderer::UniquePtr& pRenderer, uint32_t argc, char** argv) {\n  200          Sample s(pRenderer);\n  201          \n\n/home/max/dev/Falcor/src/Falcor/Core/Sample.h:\n   61          Note that when running a Windows application (with WinMain()), the command line arguments will be retrieved and parsed even if argc and argv are nullptr.\n   62      */\n   63:     static void run(const SampleConfig& config, IRenderer::UniquePtr& pRenderer, uint32_t argc = 0, char** argv = nullptr);\n   64  \n   65      /** Entry-point to Sample. User should call this to start processing.\n   ..\n   70          Note that when running a Windows application (with WinMain()), the command line arguments will be retrieved and parsed even if argc and argv are nullptr.\n   71      */\n   72:     static void run(const std::string& filename, IRenderer::UniquePtr& pRenderer, uint32_t argc = 0, char** argv = nullptr);\n   73  \n   74      virtual ~Sample();\n   ..\n  140      Clock *mClock;\n  141  \n  142:     IRenderer::UniquePtr mpRenderer;\n  143  \n  144      struct VideoCaptureData {\n  ...\n  154      PixelZoom::SharedPtr mpPixelZoom;\n  155  \n  156:     Sample(IRenderer::UniquePtr& pRenderer);\n  157      Sample(const Sample&) = delete;\n  158      Sample& operator=(const Sample&) = delete;\n\n/home/max/dev/Falcor/src/Mogwai/Mogwai.cpp:\n   70  \n   71  \n   72: Renderer::Renderer(Falcor::Device::SharedPtr pDevice): IRenderer(pDevice), mAppData(kAppDataPath) {}\n   73  \n   74  void Renderer::extend(Extension::CreateFunc func, const std::string& name) {\n   ..\n  598          device_desc.height = 720;\n  599          //auto pNullWindow = Falcor::Window::SharedPtr(nullptr);\n  600:         //IRenderer::UniquePtr pRenderer = std::make_unique<Mogwai::Renderer>(Device::create(pNullWindow, device_desc));\n  601:         IRenderer::UniquePtr pRenderer = std::make_unique<Mogwai::Renderer>(DeviceManager::instance().createRenderingDevice(0, device_desc));\n  602  \n  603          ArgList args;\n\n/home/max/dev/Falcor/src/Mogwai/Mogwai.h:\n   97  class Device;\n   98  \n   99: class Renderer : public IRenderer {\n  100   public:\n  101      Renderer(Falcor::Device::SharedPtr pDevice);\n\n/home/max/dev/Falcor/src/Samples/CudaInterop/CudaInterop.h:\n   33  using namespace Falcor;\n   34  \n   35: class CudaInterop : public IRenderer\n   36  {\n   37  public:\n\n/home/max/dev/Falcor/src/Samples/HelloDXR/HelloDXR.h:\n   31  using namespace Falcor;\n   32  \n   33: class HelloDXR : public IRenderer\n   34  {\n   35  public:\n\n/home/max/dev/Falcor/src/Samples/ModelViewer/ModelViewer.h:\n   31  using namespace Falcor;\n   32  \n   33: class ModelViewer : public IRenderer\n   34  {\n   35  public:\n\n/home/max/dev/Falcor/src/Samples/ProjectTemplate/ProjectTemplate.h:\n   31  using namespace Falcor;\n   32  \n   33: class ProjectTemplate : public IRenderer\n   34  {\n   35  public:\n\n/home/max/dev/Falcor/src/Samples/ShaderToy/ShaderToy.h:\n   31  using namespace Falcor;\n   32  \n   33: class ShaderToy : public IRenderer\n   34  {\n   35  public:\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/FalcorTest.h:\n   34  using namespace Falcor;\n   35  \n   36: class FalcorTest : public IRenderer {\n   37   public:\n   38      void onLoad(RenderContext* pRenderContext) override;\n\n/home/max/dev/Falcor/src/Tools/RenderGraphEditor/RenderGraphEditor.h:\n   36  using namespace Falcor;\n   37  \n   38: class RenderGraphEditor : public IRenderer {\n   39   public:\n   40      void onLoad(RenderContext* pRenderContext) override;\n\n26 matches across 12 files\n\n\nSearching 1315 files for \"copyHeaderForBuild\" (case sensitive)\n\n0 matches\n\nSearching 22431 files for \"copyHeaderForBuild\" (case sensitive)\n\n/home/max/dev/Falcor/build/debug/lib/libassimp.so.5:\n    File too large, skipping\n\n/home/max/dev/Falcor/build/debug/lib/libassimp.so.5.0.0:\n    File too large, skipping\n\n/home/max/dev/Falcor/build/src/pxr/imaging/plugin/hdLava/CMakeFiles/hdLava.dir/build.make:\n   78  \t@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --blue --bold --progress-dir=/home/max/dev/Falcor/build/CMakeFiles --progress-num=$(CMAKE_PROGRESS_1) \"Copying boostIncludePath.h ...\"\n   79  \tcd /home/max/dev/Falcor/build/src/pxr/imaging/plugin/hdLava && /usr/local/bin/cmake -E make_directory /home/max/dev/Falcor/build/include/src/pxr/imaging/plugin/hdLava\n   80: \tcd /home/max/dev/Falcor/build/src/pxr/imaging/plugin/hdLava && /usr/local/bin/cmake -Dinfile=\\\"/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/boostIncludePath.h\\\" -Doutfile=\\\"/home/max/dev/Falcor/build//include/src/pxr/imaging/plugin/hdLava/boostIncludePath.h\\\" -P /home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/cmake/macros/copyHeaderForBuild.cmake\n   81  \n   82  include/src/pxr/imaging/plugin/hdLava/api.h: ../src/pxr/imaging/plugin/hdLava/api.h\n   83  \t@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --blue --bold --progress-dir=/home/max/dev/Falcor/build/CMakeFiles --progress-num=$(CMAKE_PROGRESS_2) \"Copying api.h ...\"\n   84  \tcd /home/max/dev/Falcor/build/src/pxr/imaging/plugin/hdLava && /usr/local/bin/cmake -E make_directory /home/max/dev/Falcor/build/include/src/pxr/imaging/plugin/hdLava\n   85: \tcd /home/max/dev/Falcor/build/src/pxr/imaging/plugin/hdLava && /usr/local/bin/cmake -Dinfile=\\\"/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/api.h\\\" -Doutfile=\\\"/home/max/dev/Falcor/build//include/src/pxr/imaging/plugin/hdLava/api.h\\\" -P /home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/cmake/macros/copyHeaderForBuild.cmake\n   86  \n   87  include/src/pxr/imaging/plugin/hdLava/rendererPlugin.h: ../src/pxr/imaging/plugin/hdLava/rendererPlugin.h\n   88  \t@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --blue --bold --progress-dir=/home/max/dev/Falcor/build/CMakeFiles --progress-num=$(CMAKE_PROGRESS_3) \"Copying rendererPlugin.h ...\"\n   89  \tcd /home/max/dev/Falcor/build/src/pxr/imaging/plugin/hdLava && /usr/local/bin/cmake -E make_directory /home/max/dev/Falcor/build/include/src/pxr/imaging/plugin/hdLava\n   90: \tcd /home/max/dev/Falcor/build/src/pxr/imaging/plugin/hdLava && /usr/local/bin/cmake -Dinfile=\\\"/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/rendererPlugin.h\\\" -Doutfile=\\\"/home/max/dev/Falcor/build//include/src/pxr/imaging/plugin/hdLava/rendererPlugin.h\\\" -P /home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/cmake/macros/copyHeaderForBuild.cmake\n   91  \n   92  include/src/pxr/imaging/plugin/hdLava/renderParam.h: ../src/pxr/imaging/plugin/hdLava/renderParam.h\n   93  \t@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --blue --bold --progress-dir=/home/max/dev/Falcor/build/CMakeFiles --progress-num=$(CMAKE_PROGRESS_4) \"Copying renderParam.h ...\"\n   94  \tcd /home/max/dev/Falcor/build/src/pxr/imaging/plugin/hdLava && /usr/local/bin/cmake -E make_directory /home/max/dev/Falcor/build/include/src/pxr/imaging/plugin/hdLava\n   95: \tcd /home/max/dev/Falcor/build/src/pxr/imaging/plugin/hdLava && /usr/local/bin/cmake -Dinfile=\\\"/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/renderParam.h\\\" -Doutfile=\\\"/home/max/dev/Falcor/build//include/src/pxr/imaging/plugin/hdLava/renderParam.h\\\" -P /home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/cmake/macros/copyHeaderForBuild.cmake\n   96  \n   97  include/src/pxr/imaging/plugin/hdLava/renderDelegate.h: ../src/pxr/imaging/plugin/hdLava/renderDelegate.h\n   98  \t@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --blue --bold --progress-dir=/home/max/dev/Falcor/build/CMakeFiles --progress-num=$(CMAKE_PROGRESS_5) \"Copying renderDelegate.h ...\"\n   99  \tcd /home/max/dev/Falcor/build/src/pxr/imaging/plugin/hdLava && /usr/local/bin/cmake -E make_directory /home/max/dev/Falcor/build/include/src/pxr/imaging/plugin/hdLava\n  100: \tcd /home/max/dev/Falcor/build/src/pxr/imaging/plugin/hdLava && /usr/local/bin/cmake -Dinfile=\\\"/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/renderDelegate.h\\\" -Doutfile=\\\"/home/max/dev/Falcor/build//include/src/pxr/imaging/plugin/hdLava/renderDelegate.h\\\" -P /home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/cmake/macros/copyHeaderForBuild.cmake\n  101  \n  102  include/src/pxr/imaging/plugin/hdLava/renderPass.h: ../src/pxr/imaging/plugin/hdLava/renderPass.h\n  103  \t@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --blue --bold --progress-dir=/home/max/dev/Falcor/build/CMakeFiles --progress-num=$(CMAKE_PROGRESS_6) \"Copying renderPass.h ...\"\n  104  \tcd /home/max/dev/Falcor/build/src/pxr/imaging/plugin/hdLava && /usr/local/bin/cmake -E make_directory /home/max/dev/Falcor/build/include/src/pxr/imaging/plugin/hdLava\n  105: \tcd /home/max/dev/Falcor/build/src/pxr/imaging/plugin/hdLava && /usr/local/bin/cmake -Dinfile=\\\"/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/renderPass.h\\\" -Doutfile=\\\"/home/max/dev/Falcor/build//include/src/pxr/imaging/plugin/hdLava/renderPass.h\\\" -P /home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/cmake/macros/copyHeaderForBuild.cmake\n  106  \n  107  src/pxr/imaging/plugin/hdLava/CMakeFiles/hdLava.dir/rendererPlugin.cpp.o: src/pxr/imaging/plugin/hdLava/CMakeFiles/hdLava.dir/flags.make\n\n/home/max/dev/Falcor/build/src/pxr/imaging/plugin/hdLava/CMakeFiles/hdLava_headerfiles.dir/build.make:\n   82  \t@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --blue --bold --progress-dir=/home/max/dev/Falcor/build/CMakeFiles --progress-num=$(CMAKE_PROGRESS_1) \"Copying boostIncludePath.h ...\"\n   83  \tcd /home/max/dev/Falcor/build/src/pxr/imaging/plugin/hdLava && /usr/local/bin/cmake -E make_directory /home/max/dev/Falcor/build/include/src/pxr/imaging/plugin/hdLava\n   84: \tcd /home/max/dev/Falcor/build/src/pxr/imaging/plugin/hdLava && /usr/local/bin/cmake -Dinfile=\\\"/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/boostIncludePath.h\\\" -Doutfile=\\\"/home/max/dev/Falcor/build//include/src/pxr/imaging/plugin/hdLava/boostIncludePath.h\\\" -P /home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/cmake/macros/copyHeaderForBuild.cmake\n   85  \n   86  include/src/pxr/imaging/plugin/hdLava/api.h: ../src/pxr/imaging/plugin/hdLava/api.h\n   87  \t@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --blue --bold --progress-dir=/home/max/dev/Falcor/build/CMakeFiles --progress-num=$(CMAKE_PROGRESS_2) \"Copying api.h ...\"\n   88  \tcd /home/max/dev/Falcor/build/src/pxr/imaging/plugin/hdLava && /usr/local/bin/cmake -E make_directory /home/max/dev/Falcor/build/include/src/pxr/imaging/plugin/hdLava\n   89: \tcd /home/max/dev/Falcor/build/src/pxr/imaging/plugin/hdLava && /usr/local/bin/cmake -Dinfile=\\\"/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/api.h\\\" -Doutfile=\\\"/home/max/dev/Falcor/build//include/src/pxr/imaging/plugin/hdLava/api.h\\\" -P /home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/cmake/macros/copyHeaderForBuild.cmake\n   90  \n   91  include/src/pxr/imaging/plugin/hdLava/rendererPlugin.h: ../src/pxr/imaging/plugin/hdLava/rendererPlugin.h\n   92  \t@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --blue --bold --progress-dir=/home/max/dev/Falcor/build/CMakeFiles --progress-num=$(CMAKE_PROGRESS_3) \"Copying rendererPlugin.h ...\"\n   93  \tcd /home/max/dev/Falcor/build/src/pxr/imaging/plugin/hdLava && /usr/local/bin/cmake -E make_directory /home/max/dev/Falcor/build/include/src/pxr/imaging/plugin/hdLava\n   94: \tcd /home/max/dev/Falcor/build/src/pxr/imaging/plugin/hdLava && /usr/local/bin/cmake -Dinfile=\\\"/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/rendererPlugin.h\\\" -Doutfile=\\\"/home/max/dev/Falcor/build//include/src/pxr/imaging/plugin/hdLava/rendererPlugin.h\\\" -P /home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/cmake/macros/copyHeaderForBuild.cmake\n   95  \n   96  include/src/pxr/imaging/plugin/hdLava/renderParam.h: ../src/pxr/imaging/plugin/hdLava/renderParam.h\n   97  \t@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --blue --bold --progress-dir=/home/max/dev/Falcor/build/CMakeFiles --progress-num=$(CMAKE_PROGRESS_4) \"Copying renderParam.h ...\"\n   98  \tcd /home/max/dev/Falcor/build/src/pxr/imaging/plugin/hdLava && /usr/local/bin/cmake -E make_directory /home/max/dev/Falcor/build/include/src/pxr/imaging/plugin/hdLava\n   99: \tcd /home/max/dev/Falcor/build/src/pxr/imaging/plugin/hdLava && /usr/local/bin/cmake -Dinfile=\\\"/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/renderParam.h\\\" -Doutfile=\\\"/home/max/dev/Falcor/build//include/src/pxr/imaging/plugin/hdLava/renderParam.h\\\" -P /home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/cmake/macros/copyHeaderForBuild.cmake\n  100  \n  101  include/src/pxr/imaging/plugin/hdLava/renderDelegate.h: ../src/pxr/imaging/plugin/hdLava/renderDelegate.h\n  102  \t@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --blue --bold --progress-dir=/home/max/dev/Falcor/build/CMakeFiles --progress-num=$(CMAKE_PROGRESS_5) \"Copying renderDelegate.h ...\"\n  103  \tcd /home/max/dev/Falcor/build/src/pxr/imaging/plugin/hdLava && /usr/local/bin/cmake -E make_directory /home/max/dev/Falcor/build/include/src/pxr/imaging/plugin/hdLava\n  104: \tcd /home/max/dev/Falcor/build/src/pxr/imaging/plugin/hdLava && /usr/local/bin/cmake -Dinfile=\\\"/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/renderDelegate.h\\\" -Doutfile=\\\"/home/max/dev/Falcor/build//include/src/pxr/imaging/plugin/hdLava/renderDelegate.h\\\" -P /home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/cmake/macros/copyHeaderForBuild.cmake\n  105  \n  106  include/src/pxr/imaging/plugin/hdLava/renderPass.h: ../src/pxr/imaging/plugin/hdLava/renderPass.h\n  107  \t@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --blue --bold --progress-dir=/home/max/dev/Falcor/build/CMakeFiles --progress-num=$(CMAKE_PROGRESS_6) \"Copying renderPass.h ...\"\n  108  \tcd /home/max/dev/Falcor/build/src/pxr/imaging/plugin/hdLava && /usr/local/bin/cmake -E make_directory /home/max/dev/Falcor/build/include/src/pxr/imaging/plugin/hdLava\n  109: \tcd /home/max/dev/Falcor/build/src/pxr/imaging/plugin/hdLava && /usr/local/bin/cmake -Dinfile=\\\"/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/renderPass.h\\\" -Doutfile=\\\"/home/max/dev/Falcor/build//include/src/pxr/imaging/plugin/hdLava/renderPass.h\\\" -P /home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava/cmake/macros/copyHeaderForBuild.cmake\n  110  \n  111  hdLava_headerfiles: src/pxr/imaging/plugin/hdLava/CMakeFiles/hdLava_headerfiles\n\n/home/max/dev/Falcor/third_party/USD/cmake/macros/Private.cmake:\n   56                  OUTPUT ${outfile}\n   57                  COMMAND ${CMAKE_COMMAND} -E make_directory \"${dir_to_create}\"\n   58:                 COMMAND ${CMAKE_COMMAND} -Dinfile=\"${infile}\" -Doutfile=\"${outfile}\" -P \"${PROJECT_SOURCE_DIR}/cmake/macros/copyHeaderForBuild.cmake\"\n   59                  MAIN_DEPENDENCY \"${infile}\"\n   60                  COMMENT \"Copying ${f} ...\"\n\n/home/max/dev/Falcor/venv/lib/python3.7/site-packages/PySide2/Qt/lib/libQt5WebEngineCore.so.5:\n    File too large, skipping\n\n13 matches across 3 files\n\n\nSearching 2069 files for \"config.h\" (case sensitive)\n\n/home/max/dev/RadeonProRenderUSD/cmake/modules/FindHoudiniUSD.cmake:\n   40  \n   41  find_path(Houdini_Python_INCLUDE_DIR\n   42:     \"pyconfig.h\"\n   43      PATHS ${HOUDINI_ROOT}\n   44      PATH_SUFFIXES\n\n/home/max/dev/RadeonProRenderUSD/deps/MaterialX/source/MaterialXFormat/PugiXML/pugixml.hpp:\n   18  \n   19  // Include user configuration file (this can define various configuration macros)\n   20: #include \"pugiconfig.hpp\"\n   21  \n   22  #ifndef HEADER_PUGIXML_HPP\n\n/home/max/dev/RadeonProRenderUSD/deps/MaterialX/source/MaterialXTest/Catch/catch.hpp:\n 3144  #define TWOBLUECUBES_CATCH_COMMANDLINE_HPP_INCLUDED\n 3145  \n 3146: // #included from: catch_config.hpp\n 3147  #define TWOBLUECUBES_CATCH_CONFIG_HPP_INCLUDED\n 3148  \n ....\n 3414  #endif\n 3415  \n 3416: // #included from: catch_interfaces_config.h\n 3417  #define TWOBLUECUBES_CATCH_INTERFACES_CONFIG_H_INCLUDED\n 3418  \n\n/home/max/dev/RadeonProRenderUSD/deps/RIF/CentOS7/libMIOpen.so.2:\n    <binary>\n\n/home/max/dev/RadeonProRenderUSD/deps/RIF/CentOS7/libMIOpen.so.2.0.1:\n    <binary>\n\n/home/max/dev/RadeonProRenderUSD/deps/RIF/CentOS7/libOpenImageDenoise.so.0:\n    <binary>\n\n/home/max/dev/RadeonProRenderUSD/deps/RIF/CentOS7/libOpenImageDenoise.so.0.9.0:\n    <binary>\n\n/home/max/dev/RadeonProRenderUSD/deps/RIF/Ubuntu18/libMIOpen.so.2:\n    <binary>\n\n/home/max/dev/RadeonProRenderUSD/deps/RIF/Ubuntu18/libMIOpen.so.2.0.1:\n    <binary>\n\n/home/max/dev/RadeonProRenderUSD/deps/RIF/Ubuntu18/libOpenImageDenoise.so.0:\n    <binary>\n\n/home/max/dev/RadeonProRenderUSD/deps/RIF/Ubuntu18/libOpenImageDenoise.so.0.9.0:\n    <binary>\n\n/home/max/dev/RadeonProRenderUSD/pxr/imaging/plugin/hdRpr/CMakeLists.txt:\n   34  set(GEN_SCRIPT_ARGS \\\"${GENERATION_SCRIPTS_DIR}\\\" \\\"${CMAKE_CURRENT_BINARY_DIR}\\\")\n   35  set(GENERATED_FILES\n   36:     ${CMAKE_CURRENT_BINARY_DIR}/config.h\n   37      ${CMAKE_CURRENT_BINARY_DIR}/config.cpp)\n   38  set(GENERATION_DEPENDENT_FILES ${GEN_SCRIPT}\n\n/home/max/dev/RadeonProRenderUSD/pxr/imaging/plugin/hdRpr/python/generateRenderSettingFiles.py:\n  403      cpp_template = (\n  404  '''\n  405: #include \"config.h\"\n  406  #include \"rprApi.h\"\n  407  #include \"pxr/base/arch/fileSystem.h\"\n  ...\n  643      rs_tokens_declaration += '\\nTF_DECLARE_PUBLIC_TOKENS(HdRprRenderSettingsTokens, HDRPR_RENDER_SETTINGS_TOKENS);'\n  644  \n  645:     header_dst_path = os.path.join(install_path, 'config.h')\n  646      header_file = open(header_dst_path, 'w')\n  647      header_file.write(header_template.format(\n\n/home/max/dev/RadeonProRenderUSD/pxr/imaging/plugin/hdRpr/renderDelegate.cpp:\n   21  \n   22  #include \"camera.h\"\n   23: #include \"config.h\"\n   24  #include \"renderPass.h\"\n   25  #include \"renderParam.h\"\n\n/home/max/dev/RadeonProRenderUSD/pxr/imaging/plugin/hdRpr/renderPass.cpp:\n   14  #include \"renderPass.h\"\n   15  #include \"renderDelegate.h\"\n   16: #include \"config.h\"\n   17  #include \"rprApi.h\"\n   18  #include \"renderBuffer.h\"\n\n/home/max/dev/RadeonProRenderUSD/pxr/imaging/plugin/hdRpr/rprApi.cpp:\n   20  #include \"rifcpp/rifError.h\"\n   21  \n   22: #include \"config.h\"\n   23  #include \"camera.h\"\n   24  #include \"renderDelegate.h\"\n\n170 matches across 16 files\n\n\nSearching 2069 files for \"GetRenderSettingDescriptors\" (case sensitive)\n\n/home/max/dev/RadeonProRenderUSD/pxr/imaging/plugin/hdRpr/python/generateRenderSettingFiles.py:\n  357      }};\n  358  \n  359:     static HdRenderSettingDescriptorList GetRenderSettingDescriptors();\n  360      static std::unique_lock<std::mutex> GetInstance(HdRprConfig** instance);\n  361  \n  ...\n  420  }} // namespace anonymous\n  421  \n  422: HdRenderSettingDescriptorList HdRprConfig::GetRenderSettingDescriptors() {{\n  423      HdRenderSettingDescriptorList settingDescs;\n  424  {rs_list_initialization}\n\n/home/max/dev/RadeonProRenderUSD/pxr/imaging/plugin/hdRpr/renderDelegate.cpp:\n  165      m_renderParam.reset(new HdRprRenderParam(m_rprApi.get(), &m_renderThread));\n  166  \n  167:     m_settingDescriptors = HdRprConfig::GetRenderSettingDescriptors();\n  168      _PopulateDefaultSettings(m_settingDescriptors);\n  169  \n  ...\n  346  }\n  347  \n  348: HdRenderSettingDescriptorList HdRprDelegate::GetRenderSettingDescriptors() const {\n  349      return m_settingDescriptors;\n  350  }\n\n/home/max/dev/RadeonProRenderUSD/pxr/imaging/plugin/hdRpr/renderDelegate.h:\n   72      HdAovDescriptor GetDefaultAovDescriptor(TfToken const& name) const override;\n   73  \n   74:     HdRenderSettingDescriptorList GetRenderSettingDescriptors() const override;\n   75  \n   76      VtDictionary GetRenderStats() const override;\n\n5 matches across 3 files\n",
			"settings":
			{
				"buffer_size": 810075,
				"line_ending": "Unix",
				"name": "Find Results",
				"scratch": true
			}
		},
		{
			"file": "/home/max/dev/RadeonProRenderUSD/pxr/imaging/plugin/hdRpr/python/generateRenderSettingFiles.py",
			"settings":
			{
				"buffer_size": 24851,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/USD/cmake/macros/Private.cmake",
			"settings":
			{
				"buffer_size": 50720,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/D3D12/D3D12NvApiExDesc.h",
			"settings":
			{
				"buffer_size": 4956,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VkResource.cpp",
			"settings":
			{
				"buffer_size": 1884,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/Data/ForwardRenderer.py",
			"settings":
			{
				"buffer_size": 1872,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/Data/BSDFViewer.py",
			"settings":
			{
				"buffer_size": 634,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/glslang/glslang/Include/BaseTypes.h",
			"settings":
			{
				"buffer_size": 18643,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/glslang/glslang/MachineIndependent/Initialize.cpp",
			"settings":
			{
				"buffer_size": 477356,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Raster.slang",
			"settings":
			{
				"buffer_size": 4526,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/GBuffer/GBufferRaster.3d.slang",
			"settings":
			{
				"buffer_size": 7187,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/ShadingData.slang",
			"settings":
			{
				"buffer_size": 15181,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/Antialiasing/TAA/TAA.ps.slang",
			"settings":
			{
				"buffer_size": 5743,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Experimental/Scene/Lights/LightBVH.cpp",
			"settings":
			{
				"buffer_size": 18635,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Experimental/Scene/Lights/LightBVHBuilder.h",
			"settings":
			{
				"buffer_size": 11295,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Experimental/Scene/Lights/LightBVHBuilder.cpp",
			"settings":
			{
				"buffer_size": 41661,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Experimental/Scene/Lights/LightBVH.h",
			"settings":
			{
				"buffer_size": 12420,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Algorithm/ParallelReduction.ps.slang",
			"settings":
			{
				"buffer_size": 4191,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/BSDFViewer/BSDFViewerParams.slang",
			"settings":
			{
				"buffer_size": 6511,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/glslang/glslang/MachineIndependent/ParseHelper.cpp",
			"settings":
			{
				"buffer_size": 364782,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/glslang/SPIRV/SpvBuilder.cpp",
			"settings":
			{
				"buffer_size": 105150,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/source/slang/slang-ir.cpp",
			"settings":
			{
				"buffer_size": 150177,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/glslang/SPIRV/SpvBuilder.h",
			"settings":
			{
				"buffer_size": 35460,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/source/slang-glslang/slang-glslang.cpp",
			"settings":
			{
				"buffer_size": 18679,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/spirv-tools/source/spirv_target_env.cpp",
			"settings":
			{
				"buffer_size": 10524,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/spirv-tools/CHANGES",
			"settings":
			{
				"buffer_size": 47890,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/SceneBuilder.cpp",
			"settings":
			{
				"buffer_size": 23587,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/SceneTypes.slang",
			"settings":
			{
				"buffer_size": 5249,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/source/slang/slang-type-layout.cpp",
			"settings":
			{
				"buffer_size": 149248,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/source/slang/slang-type-layout.h",
			"settings":
			{
				"buffer_size": 34158,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/slang.h",
			"settings":
			{
				"buffer_size": 132132,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/glm/test/core/core_type_aligned.cpp",
			"settings":
			{
				"buffer_size": 5440,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Formats.cpp",
			"settings":
			{
				"buffer_size": 19719,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/glm/glm/gtx/compatibility.hpp",
			"settings":
			{
				"buffer_size": 14979,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKFormats.cpp",
			"settings":
			{
				"buffer_size": 10446,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/glslang/glslang/Include/intermediate.h",
			"settings":
			{
				"buffer_size": 54763,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/docs/language-reference/04-types.md",
			"settings":
			{
				"buffer_size": 14365,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/glslang/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 4705,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/glslang/SPIRV/GlslangToSpv.cpp",
			"settings":
			{
				"buffer_size": 339007,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/glslang/Test/100.frag",
			"settings":
			{
				"buffer_size": 4744,
				"line_ending": "Windows"
			}
		},
		{
			"file": "third_party/slang/external/glext.h",
			"settings":
			{
				"buffer_size": 811328,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/docs/wave-intrinsics.md",
			"settings":
			{
				"buffer_size": 13145,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/DebugPasses/InvalidPixelDetectionPass/InvalidPixelDetectionPass.cpp",
			"settings":
			{
				"buffer_size": 4322,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Core/RootBufferParamBlockTests.cpp",
			"settings":
			{
				"buffer_size": 8904,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Core/RootBufferParamBlockTests.cs.slang",
			"settings":
			{
				"buffer_size": 3086,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Core/ParamBlockDefinition.slang",
			"settings":
			{
				"buffer_size": 2225,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/ProgramVersion.cpp",
			"settings":
			{
				"buffer_size": 8252,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderGraphIR.cpp",
			"settings":
			{
				"buffer_size": 5845,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderGraphIR.h",
			"settings":
			{
				"buffer_size": 3409,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Importers/AssimpImporter.cpp",
			"settings":
			{
				"buffer_size": 44987,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Importers/AssimpImporter.h",
			"settings":
			{
				"buffer_size": 2484,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Importers/PythonImporter.h",
			"settings":
			{
				"buffer_size": 2145,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Camera/Camera.h",
			"settings":
			{
				"buffer_size": 11607,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Sampling/SampleGenerator.h",
			"settings":
			{
				"buffer_size": 4312,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/SampleGenerators/StratifiedSamplePattern.h",
			"settings":
			{
				"buffer_size": 3466,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/SampleGenerators/HaltonSamplePattern.h",
			"settings":
			{
				"buffer_size": 3159,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/SampleGenerators/CPUSampleGenerator.h",
			"settings":
			{
				"buffer_size": 2791,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/GraphicsStateObject.h",
			"settings":
			{
				"buffer_size": 6433,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/GraphicsStateObject.cpp",
			"settings":
			{
				"buffer_size": 4274,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKFbo.cpp",
			"settings":
			{
				"buffer_size": 5380,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/ComputeStateObject.h",
			"settings":
			{
				"buffer_size": 3496,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Experimental/Scene/Lights/EnvProbe.cpp",
			"settings":
			{
				"buffer_size": 6616,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/ComputeContext.h",
			"settings":
			{
				"buffer_size": 3969,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/GpuTimer.h",
			"settings":
			{
				"buffer_size": 3787,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/LowLevelContextData.h",
			"settings":
			{
				"buffer_size": 3656,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Timing/Profiler.h",
			"settings":
			{
				"buffer_size": 8484,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Platform/Windows/Windows.cpp",
			"settings":
			{
				"buffer_size": 26025,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/tools/gfx/d3d12/render-d3d12.cpp",
			"settings":
			{
				"buffer_size": 139342,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/tools/gfx/vulkan/render-vk.cpp",
			"settings":
			{
				"buffer_size": 99401,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Raytracing/RtProgramVarsHelper.cpp",
			"settings":
			{
				"buffer_size": 6214,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/D3D12/FalcorD3D12.h",
			"settings":
			{
				"buffer_size": 9709,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Platform/OS.cpp",
			"settings":
			{
				"buffer_size": 8771,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/SkyBox/SkyBox.slang",
			"settings":
			{
				"buffer_size": 2520,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/CSM/VisibilityPass.ps.slang",
			"settings":
			{
				"buffer_size": 2953,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/ToneMapper/ToneMapping.ps.slang",
			"settings":
			{
				"buffer_size": 5616,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/ToneMapper/Luminance.ps.slang",
			"settings":
			{
				"buffer_size": 2106,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Importers/PythonImporter.cpp",
			"settings":
			{
				"buffer_size": 3931,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Importers/SceneImporter.cpp",
			"settings":
			{
				"buffer_size": 36435,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Importers/SceneImporter.h",
			"settings":
			{
				"buffer_size": 2157,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/Program.h",
			"settings":
			{
				"buffer_size": 12423,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/GraphicsProgram.h",
			"settings":
			{
				"buffer_size": 3809,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/ComputeProgram.h",
			"settings":
			{
				"buffer_size": 3818,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/GraphicsProgram.cpp",
			"settings":
			{
				"buffer_size": 2616,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Camera/Camera.slang",
			"settings":
			{
				"buffer_size": 5388,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/ArgList.h",
			"settings":
			{
				"buffer_size": 4051,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "/***************************************************************************\n # Copyright (c) 2020, NVIDIA CORPORATION. All rights reserved.\n #\n # Redistribution and use in source and binary forms, with or without\n # modification, are permitted provided that the following conditions\n # are met:\n #  * Redistributions of source code must retain the above copyright\n #    notice, this list of conditions and the following disclaimer.\n #  * Redistributions in binary form must reproduce the above copyright\n #    notice, this list of conditions and the following disclaimer in the\n #    documentation and/or other materials provided with the distribution.\n #  * Neither the name of NVIDIA CORPORATION nor the names of its\n #    contributors may be used to endorse or promote products derived\n #    from this software without specific prior written permission.\n #\n # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY\n # EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n # IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n # PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n # CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n # EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n # PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n # PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n **************************************************************************/\n#include <algorithm>\n#include <iostream>\n#include <chrono>\n#include <ctime>  \n\n#include <execinfo.h>\n#include <signal.h>\n\n#ifdef _WIN32\n  #include <filesystem>\n  namespace fs = std::filesystem;\n#else\n  #include \"boost/filesystem.hpp\"\n  namespace fs = boost::filesystem;\n#endif\n\n#include \"stdafx.h\"\n#include \"Mogwai.h\"\n#include \"MogwaiSettings.h\"\n\n#include \"Falcor/Core/API/DeviceManager.h\"\n#include \"Falcor/Core/Window.h\"\n#include \"Falcor/Utils/Debug/debug.h\"\n\nnamespace Mogwai {\n\nnamespace {\n\nstd::map<std::string, Extension::CreateFunc>* gExtensions;  // Map ensures ordering\n\nconst char* kEditorExecutableName = \"RenderGraphEditor\";\nconst char* kEditorSwitch = \"editor\";\n// const char* kOutfileDirSwitch = \"outputdir\"; // TODO: remove\nconst char* kScriptSwitch = \"script\";\nconst char* kGraphFileSwitch = \"graphFile\";\nconst char* kGraphNameSwitch = \"graphName\";\n\nconst std::string kAppDataPath = getAppDataDirectory() + \"/NVIDIA/Falcor/Mogwai.json\";\n\n}  // namespace\n\nsize_t Renderer::DebugWindow::index = 0;\n\n\nRenderer::Renderer(std::shared_ptr<Falcor::Device> pDevice): IRenderer(pDevice), mAppData(kAppDataPath) {}\n\nvoid Renderer::extend(Extension::CreateFunc func, const std::string& name) {\n    if (!gExtensions) gExtensions = new std::map<std::string, Extension::CreateFunc>();\n    if (gExtensions->find(name) != gExtensions->end()) {\n        logError(\"Extension \" + name + \" already registered. If you continue the new extension will be discarded\");\n        return;\n    }\n    (*gExtensions)[name] = func;\n}\n\nvoid Renderer::onShutdown() {\n    resetEditor();\n    mpDevice->flushAndSync(); // Need to do that because clearing the graphs will try to release some state objects which might be in use\n    mGraphs.clear();\n}\n\nvoid Renderer::onLoad(RenderContext* pRenderContext) {\n//void Renderer::onLoad() {\n    //auto pRenderContext = mpDevice->getRenderContext();\n    mpExtensions.push_back(MogwaiSettings::create(this));\n    if (gExtensions) {\n        for (auto& f : (*gExtensions)) mpExtensions.push_back(f.second(this));\n        safe_delete(gExtensions);\n    }\n\n    auto regBinding = [this](ScriptBindings::Module& m) {this->registerScriptBindings(m); };\n    ScriptBindings::registerBinding(regBinding);\n\n    // If editor opened from running render graph, get the name of the file to read\n    if (gpFramework->getArgList().argExists(kScriptSwitch)) loadScript(gpFramework->getArgList()[kScriptSwitch].asString());\n}\n\nRenderGraph* Renderer::getActiveGraph() const {\n    return mGraphs.size() ? mGraphs[mActiveGraph].pGraph.get() : nullptr;\n}\n\nvoid Renderer::onGuiRender(Gui* pGui) {\n    for (auto& pe : mpExtensions)  pe->renderUI(pGui);\n}\n\nbool isInVector(const std::vector<std::string>& strVec, const std::string& str) {\n    return std::find(strVec.begin(), strVec.end(), str) != strVec.end();\n}\n\nGui::DropdownList createDropdownFromVec(const std::vector<std::string>& strVec, const std::string& currentLabel) {\n    Gui::DropdownList dropdown;\n    for (size_t i = 0; i < strVec.size(); i++) dropdown.push_back({ (uint32_t)i, strVec[i] });\n    return dropdown;\n}\n\nvoid Renderer::addDebugWindow() {\n    DebugWindow window;\n    window.windowName = \"Debug Window \" + std::to_string(DebugWindow::index++);\n    window.currentOutput = mGraphs[mActiveGraph].mainOutput;\n    markOutput(window.currentOutput);\n    mGraphs[mActiveGraph].debugWindows.push_back(window);\n}\n\nvoid Renderer::unmarkOutput(const std::string& name) {\n    auto& graphData = mGraphs[mActiveGraph];\n    // Skip the original outputs\n    if (isInVector(graphData.originalOutputs, name)) return;\n\n    // Decrease the reference counter\n    auto& ref = graphData.graphOutputRefs.at(name);\n    ref--;\n    if (ref == 0) {\n        graphData.graphOutputRefs.erase(name);\n        graphData.pGraph->unmarkOutput(name);\n    }\n}\n\nvoid Renderer::markOutput(const std::string& name) {\n    auto& graphData = mGraphs[mActiveGraph];\n    // Skip the original outputs\n    if (isInVector(graphData.originalOutputs, name)) return;\n    auto& refVec = mGraphs[mActiveGraph].graphOutputRefs;\n    refVec[name]++;\n    if (refVec[name] == 1) mGraphs[mActiveGraph].pGraph->markOutput(name);\n}\n\nvoid Renderer::renderOutputUI(Gui::Widgets& widget, const Gui::DropdownList& dropdown, std::string& selectedOutput) {\n    uint32_t activeOut = -1;\n    for (size_t i = 0; i < dropdown.size(); i++) {\n        if (dropdown[i].label == selectedOutput) {\n            activeOut = (uint32_t)i;\n            break;\n        }\n    }\n\n    // This can happen when `showAllOutputs` changes to false, and the chosen output is not an original output. We will force an output change\n    bool forceOutputChange = activeOut == -1;\n    if (forceOutputChange) activeOut = 0;\n\n    if (widget.dropdown(\"Output\", dropdown, activeOut) || forceOutputChange) {\n        // Unmark old output, set new output, mark new output\n        unmarkOutput(selectedOutput);\n        selectedOutput = dropdown[activeOut].label;\n        markOutput(selectedOutput);\n    }\n}\n\nbool Renderer::renderDebugWindow(Gui::Widgets& widget, const Gui::DropdownList& dropdown, DebugWindow& data, const uint2& winSize) {\n    // Get the current output, in case `renderOutputUI()` unmarks it\n    Texture::SharedPtr pTex = std::dynamic_pointer_cast<Texture>(mGraphs[mActiveGraph].pGraph->getOutput(data.currentOutput));\n    std::string label = data.currentOutput + \"##\" + mGraphs[mActiveGraph].pGraph->getName();\n    if (!pTex) { logError(\"Invalid output resource. Is not a texture.\"); }\n\n    uint2 debugSize = (uint2)(float2(winSize) * float2(0.4f, 0.55f));\n    uint2 debugPos = winSize - debugSize;\n    debugPos -= 10;\n\n    // Display the dropdown\n    Gui::Window debugWindow(widget.gui(), data.windowName.c_str(), debugSize, debugPos);\n    if (debugWindow.gui()) {\n        if (debugWindow.button(\"Save To File\", true)) Bitmap::saveImageDialog(pTex.get());\n        renderOutputUI(widget, dropdown, data.currentOutput);\n        debugWindow.separator();\n\n        debugWindow.image(label.c_str(), pTex);\n        debugWindow.release();\n        return true;\n    }\n    return false;\n}\n\nvoid Renderer::eraseDebugWindow(size_t id) {\n    unmarkOutput(mGraphs[mActiveGraph].debugWindows[id].currentOutput);\n    mGraphs[mActiveGraph].debugWindows.erase(mGraphs[mActiveGraph].debugWindows.begin() + id);\n}\n\nvoid Renderer::graphOutputsGui(Gui::Widgets& widget) {\n    RenderGraph::SharedPtr pGraph = mGraphs[mActiveGraph].pGraph;\n    if (mGraphs[mActiveGraph].debugWindows.size()) mGraphs[mActiveGraph].showAllOutputs = true;\n    auto strVec = mGraphs[mActiveGraph].showAllOutputs ? pGraph->getAvailableOutputs() : mGraphs[mActiveGraph].originalOutputs;\n    Gui::DropdownList graphOuts = createDropdownFromVec(strVec, mGraphs[mActiveGraph].mainOutput);\n\n    widget.checkbox(\"List All Outputs\", mGraphs[mActiveGraph].showAllOutputs);\n    widget.tooltip(\"Display every possible output in the render-graph, even if it wasn't explicitly marked as one. If there's a debug window open, you won't be able to uncheck this\");\n\n    if (graphOuts.size()) {\n        uint2 dims(gpFramework->getTargetFbo()->getWidth(), gpFramework->getTargetFbo()->getHeight());\n\n        for (size_t i = 0; i < mGraphs[mActiveGraph].debugWindows.size();) {\n            if (renderDebugWindow(widget, graphOuts, mGraphs[mActiveGraph].debugWindows[i], dims) == false) {\n                eraseDebugWindow(i);\n            } else {\n                i++;\n            }\n        }\n\n        renderOutputUI(widget, graphOuts, mGraphs[mActiveGraph].mainOutput);\n\n        // Render the debug windows *before* adding/removing debug windows\n        if (widget.button(\"Show In Debug Window\")) addDebugWindow();\n        if (mGraphs[mActiveGraph].debugWindows.size()) {\n            if (widget.button(\"Close all debug windows\")) {\n                while (mGraphs[mActiveGraph].debugWindows.size()) eraseDebugWindow(0);\n            }\n        }\n    }\n}\n\nvoid Renderer::onDroppedFile(const std::string& filename) {\n    std::string ext = getExtensionFromFile(filename);\n    if (ext == \"py\") {\n        loadScript(filename);\n        mAppData.addRecentScript(filename);\n    } else if (std::any_of(Scene::kFileExtensionFilters.begin(), Scene::kFileExtensionFilters.end(), [&ext](FileDialogFilter f) {return f.ext == ext; })) {\n        loadScene(filename);\n        mAppData.addRecentScene(filename);\n    } else {\n        logWarning(\"RenderGraphViewer::onDroppedFile() - Unknown file extension `\" + ext + \"`\");\n    }\n}\n\nvoid Renderer::editorFileChangeCB() {\n    mEditorScript = readFile(mEditorTempFile);\n}\n\nvoid Renderer::openEditor() {\n    bool unmarkOut = (isInVector(mGraphs[mActiveGraph].originalOutputs, mGraphs[mActiveGraph].mainOutput) == false);\n    // If the current graph output is not an original output, unmark it\n    if (unmarkOut) mGraphs[mActiveGraph].pGraph->unmarkOutput(mGraphs[mActiveGraph].mainOutput);\n\n    mEditorTempFile = getTempFilename();\n\n    // Save the graph\n    RenderGraphExporter::save(mGraphs[mActiveGraph].pGraph, mEditorTempFile);\n\n    // Register an update callback\n    monitorFileUpdates(mEditorTempFile, std::bind(&Renderer::editorFileChangeCB, this));\n\n    // Run the process\n    std::string commandLineArgs = '-' + std::string(kEditorSwitch) + \" -\" + std::string(kGraphFileSwitch);\n    commandLineArgs += ' ' + mEditorTempFile + \" -\" + std::string(kGraphNameSwitch) + ' ' + mGraphs[mActiveGraph].pGraph->getName();\n    mEditorProcess = executeProcess(kEditorExecutableName, commandLineArgs);\n\n    // Mark the output if it's required\n    if (unmarkOut) mGraphs[mActiveGraph].pGraph->markOutput(mGraphs[mActiveGraph].mainOutput);\n}\n\nvoid Renderer::resetEditor() {\n    if (mEditorProcess) {\n        closeSharedFile(mEditorTempFile);\n        std::remove(mEditorTempFile.c_str());\n\n        if (mEditorProcess != kInvalidProcessId) {\n            terminateProcess(mEditorProcess);\n            mEditorProcess = 0;\n        }\n    }\n}\n\nvoid Renderer::setActiveGraph(uint32_t active) {\n    RenderGraph* pOld = getActiveGraph();\n    mActiveGraph = active;\n    RenderGraph* pNew = getActiveGraph();\n\n    if (pOld != pNew) {\n        for (auto& e : mpExtensions) e->activeGraphChanged(pNew, pOld);\n    }\n}\n\nvoid Renderer::removeGraph(const RenderGraph::SharedPtr& pGraph) {\n    for (auto& e : mpExtensions) e->removeGraph(pGraph.get());\n    size_t i = 0;\n    for (; i < mGraphs.size(); i++) {\n        if (mGraphs[i].pGraph == pGraph) break;\n    }\n    assert(i < mGraphs.size());\n    mGraphs.erase(mGraphs.begin() + i);\n    if (mActiveGraph >= i && mActiveGraph > 0) mActiveGraph--;\n    setActiveGraph(mActiveGraph);\n}\n\nvoid Renderer::removeGraph(const std::string& graphName) {\n    auto pGraph = getGraph(graphName);\n    if (pGraph) {\n        removeGraph(pGraph);\n    } else {\n        logError(\"Can't find a graph named `\" + graphName + \"`. There's nothing to remove.\");\n    }\n}\n\nRenderGraph::SharedPtr Renderer::getGraph(const std::string& graphName) const {\n    for (const auto& g : mGraphs) {\n        if (g.pGraph->getName() == graphName) return g.pGraph;\n    }\n    return nullptr;\n}\n\nvoid Renderer::removeActiveGraph() {\n    if (mGraphs.size()) removeGraph(mGraphs[mActiveGraph].pGraph);\n}\n\nstd::vector<std::string> Renderer::getGraphOutputs(const RenderGraph::SharedPtr& pGraph) {\n    std::vector<std::string> outputs;\n    for (size_t i = 0; i < pGraph->getOutputCount(); i++) outputs.push_back(pGraph->getOutputName(i));\n    return outputs;\n}\n\nvoid Renderer::initGraph(const RenderGraph::SharedPtr& pGraph, GraphData* pData) {\n    if (!pData) {\n        mGraphs.push_back({});\n        pData = &mGraphs.back();\n    }\n\n    GraphData& data = *pData;\n    // Set input image if it exists\n    data.pGraph = pGraph;\n    data.pGraph->setScene(mpScene);\n    if (data.pGraph->getOutputCount() != 0) data.mainOutput = data.pGraph->getOutputName(0);\n\n    // Store the original outputs\n    data.originalOutputs = getGraphOutputs(pGraph);\n\n    for (auto& e : mpExtensions) e->addGraph(pGraph.get());\n}\n\nvoid Renderer::loadScriptDialog() {\n    std::string filename;\n    if (openFileDialog(Scripting::kFileExtensionFilters, filename)) {\n        mAppData.addRecentScript(filename);\n        loadScriptDeferred(filename);\n    }\n}\n\nvoid Renderer::loadScriptDeferred(const std::string& filename) {\n    mScriptFilename = filename;\n}\n\nvoid Renderer::loadScript(const std::string& filename) {\n    assert(filename.size());\n\n    try {\n        if (ProgressBar::isActive()) ProgressBar::show(\"Loading Configuration\");\n        auto c = Scripting::getGlobalContext();\n        Scripting::runScriptFromFile(filename, c);\n    } catch (const std::exception& e) {\n        logError(\"Error when loading configuration file: \" + filename + \"\\n\" + std::string(e.what()));\n    }\n}\n\nvoid Renderer::addGraph(const RenderGraph::SharedPtr& pGraph) {\n    if (pGraph == nullptr) {\n        logError(\"Can't add an empty graph\");\n        return;\n    }\n\n    // If a graph with the same name already exists, remove it\n    GraphData* pGraphData = nullptr;\n    for (size_t i = 0; i < mGraphs.size(); i++) {\n        if (mGraphs[i].pGraph->getName() == pGraph->getName()) {\n            logWarning(\"Replacing existing graph `\" + pGraph->getName() + \"` with new graph.\");\n            pGraphData = &mGraphs[i];\n            break;\n        }\n    }\n    initGraph(pGraph, pGraphData);\n}\n\nvoid Renderer::loadSceneDialog() {\n    std::string filename;\n    if (openFileDialog(Scene::kFileExtensionFilters, filename)) {\n        mAppData.addRecentScene(filename);\n        loadScene(filename);\n    }\n}\n\nvoid Renderer::loadScene(std::string filename, SceneBuilder::Flags buildFlags) {\n    LOG_DBG(\"Loading scene on device uid: %u\", mpDevice->uid());\n    setScene(SceneBuilder::create(mpDevice, filename, buildFlags)->getScene());\n}\n\nvoid Renderer::setScene(Scene::ConstSharedPtrRef pScene) {\n    mpScene = pScene;\n\n    if (mpScene) {\n        const auto& pFbo = gpFramework->getTargetFbo();\n        float ratio = static_cast<float>(pFbo->getWidth()) / static_cast<float>(pFbo->getHeight());\n        mpScene->setCameraAspectRatio(ratio);\n\n        if (mpSampler == nullptr) {\n            // create common texture sampler\n            Sampler::Desc desc;\n            desc.setFilterMode(Sampler::Filter::Linear, Sampler::Filter::Linear, Sampler::Filter::Linear);\n            desc.setMaxAnisotropy(8);\n            mpSampler = Sampler::create(mpDevice, desc);\n        }\n        mpScene->bindSamplerToMaterials(mpSampler);\n    }\n\n    for (auto& g : mGraphs) g.pGraph->setScene(mpScene);\n    gpFramework->getClock().setTime(0);\n}\n\nScene::SharedPtr Renderer::getScene() const {\n    return mpScene;\n}\n\nvoid Renderer::applyEditorChanges() {\n    if (!mEditorProcess) return;\n    // If the editor was closed, reset the handles\n    if ((mEditorProcess != kInvalidProcessId) && isProcessRunning(mEditorProcess) == false) resetEditor();\n\n    if (mEditorScript.empty()) return;\n\n    // Unmark the current output if it wasn't originally marked\n    auto pActiveGraph = mGraphs[mActiveGraph].pGraph;\n    bool hasUnmarkedOut = (isInVector(mGraphs[mActiveGraph].originalOutputs, mGraphs[mActiveGraph].mainOutput) == false);\n    if (hasUnmarkedOut) pActiveGraph->unmarkOutput(mGraphs[mActiveGraph].mainOutput);\n\n    // Run the scripting\n    Scripting::getGlobalContext().setObject(\"g\", pActiveGraph);\n    Scripting::runScript(mEditorScript);\n\n    // Update the list of marked outputs\n    mGraphs[mActiveGraph].originalOutputs = getGraphOutputs(pActiveGraph);\n\n    // If the output before the update was not initially marked but still exists, re-mark it.\n    // If it no longer exists, mark a new output from the list of currently marked outputs.\n    if (hasUnmarkedOut && isInVector(pActiveGraph->getAvailableOutputs(), mGraphs[mActiveGraph].mainOutput)) {\n        pActiveGraph->markOutput(mGraphs[mActiveGraph].mainOutput);\n    } else if (isInVector(mGraphs[mActiveGraph].originalOutputs, mGraphs[mActiveGraph].mainOutput) == false) {\n        mGraphs[mActiveGraph].mainOutput = mGraphs[mActiveGraph].originalOutputs[0];\n    }\n\n    mEditorScript.clear();\n}\n\nvoid Renderer::executeActiveGraph(RenderContext* pRenderContext) {\n    if (mGraphs.empty()) return;\n    auto& pGraph = mGraphs[mActiveGraph].pGraph;\n\n    // Execute graph.\n    (*pGraph->getPassesDictionary())[kRenderPassRefreshFlags] = (uint32_t)RenderPassRefreshFlags::None;\n    pGraph->execute(pRenderContext);\n}\n\nvoid Renderer::beginFrame(RenderContext* pRenderContext, const Fbo::SharedPtr& pTargetFbo) {\n    for (auto& pe : mpExtensions)  pe->beginFrame(pRenderContext, pTargetFbo);\n}\n\nvoid Renderer::endFrame(RenderContext* pRenderContext, const Fbo::SharedPtr& pTargetFbo) {\n    for (auto& pe : mpExtensions) pe->endFrame(pRenderContext, pTargetFbo);\n}\n\nvoid Renderer::onFrameRender(RenderContext* pRenderContext, const Fbo::SharedPtr& pTargetFbo) {\n//void Renderer::onFrameRender(const Fbo::SharedPtr& pTargetFbo) {\n//    auto pRenderContext = mpDevice->getRenderContext();\n\n    LOG_DBG(\"Renderer::onFrameRender\");\n\n    if (mScriptFilename.size()) {\n        std::string s = mScriptFilename;\n        mScriptFilename.clear();\n        loadScript(s);\n    }\n\n    beginFrame(pRenderContext, pTargetFbo);\n    applyEditorChanges();\n\n    // Clear frame buffer.\n    const float4 clearColor(0.52f, 0.38f, 0.10f, 1);\n    pRenderContext->clearFbo(pTargetFbo.get(), clearColor, 1.0f, 0, FboAttachmentType::All);\n\n    if (mGraphs.size()) {\n        LOG_DBG(\"mGraphs\");\n        auto& pGraph = mGraphs[mActiveGraph].pGraph;\n\n        // Update scene and camera.\n        if (mpScene) {\n            mpScene->update(pRenderContext, gpFramework->getClock().getTime());\n        }\n\n        executeActiveGraph(pRenderContext);\n\n        \n        // Blit main graph output to frame buffer.\n        if (mGraphs[mActiveGraph].mainOutput.size()) {\n            Texture::SharedPtr pOutTex = std::dynamic_pointer_cast<Texture>(pGraph->getOutput(mGraphs[mActiveGraph].mainOutput));\n            assert(pOutTex);\n\n            if (mpDevice == pTargetFbo->device()) {\n                LOG_DBG(\"blit local\");\n                pRenderContext->blit(pOutTex->getSRV(), pTargetFbo->getRenderTargetView(0));\n\n            } else {\n                LOG_DBG(\"blit remote\");\n                uint32_t channels;\n                ResourceFormat format;\n                std::vector<uint8_t> textureData;\n                pOutTex->readTextureData(0, 0, textureData, format, channels);\n\n                Texture* pTex = Texture::create2D()\n                pRenderContext->blit(pTex->getSRV(), pTargetFbo->getRenderTargetView(0));\n            }\n            // image save test\n            //Texture* pTex = pOutTex.get();//pGraph->getOutput(i)->asTexture().get();\n            //assert(pTex);\n            //std::string filename = \"/home/max/test/render_test.\";\n            //auto ext = Bitmap::getFileExtFromResourceFormat(pTex->getFormat());\n            //filename += ext;\n            //auto format = Bitmap::getFormatFromFileExtension(ext);\n            //pTex->captureToFile(0, 0, filename, format);\n        }\n\n    }\n\n    endFrame(pRenderContext, pTargetFbo);\n}\n\nbool Renderer::onMouseEvent(const MouseEvent& mouseEvent) {\n    for (auto& pe : mpExtensions) {\n        if (pe->mouseEvent(mouseEvent)) return true;\n    }\n\n    if (mGraphs.size()) mGraphs[mActiveGraph].pGraph->onMouseEvent(mouseEvent);\n    return mpScene ? mpScene->onMouseEvent(mouseEvent) : false;\n}\n\nbool Renderer::onKeyEvent(const KeyboardEvent& keyEvent) {\n    for (auto& pe : mpExtensions) {\n        if (pe->keyboardEvent(keyEvent)) return true;\n    }\n    if (mGraphs.size()) mGraphs[mActiveGraph].pGraph->onKeyEvent(keyEvent);\n    return mpScene ? mpScene->onKeyEvent(keyEvent) : false;\n}\n\nvoid Renderer::onResizeSwapChain(uint32_t width, uint32_t height) {\n    // recreate fbo\n    //auto pBackBufferFBO = mpDevice->resizeSwapChain(width, height);\n    //auto pCurrentFbo = mpTargetFBO;\n    //mpTargetFBO = Fbo::create2D(mpDevice, width, height, pBackBufferFBO->getDesc());\n    //mpDevice->getRenderContext()->blit(pCurrentFbo->getColorTexture(0)->getSRV(), mpTargetFBO->getRenderTargetView(0));\n\n    for (auto& g : mGraphs) {\n        g.pGraph->onResize(gpFramework->getTargetFbo().get());\n        Scene::SharedPtr graphScene = g.pGraph->getScene();\n        if (graphScene) graphScene->setCameraAspectRatio(static_cast<float>(width) / static_cast<float>(height));\n    }\n    if (mpScene) mpScene->setCameraAspectRatio(static_cast<float>(width) / static_cast<float>(height));\n}\n\nvoid Renderer::onHotReload(HotReloadFlags reloaded) {\n    RenderPassLibrary::instance(mpDevice).reloadLibraries(gpFramework->getRenderContext());\n    RenderGraph* pActiveGraph = getActiveGraph();\n    if (pActiveGraph) pActiveGraph->onHotReload(reloaded);\n}\n\nsize_t Renderer::findGraph(std::string_view name) {\n    for (size_t i = 0; i < mGraphs.size(); i++) {\n        if (mGraphs[i].pGraph->getName() == name) return i;\n    }\n    return -1;\n}\n\nstd::string Renderer::getVersionString() {\n    return \"Mogwai \" + to_string(kMajorVersion) + \".\" + to_string(kMinorVersion);\n}\n\n}  // namespace Mogwai\n\nvoid handler(int sig) {\n  void *array[10];\n  size_t size;\n\n  // get void*'s for all entries on the stack\n  size = backtrace(array, 10);\n\n  // print out all the frames to stderr\n\n  std::cout << std::chrono::system_clock::to_time_t(std::chrono::system_clock::now()) << std::endl;\n  fprintf(stderr, \"Error: signal %d:\\n\", sig);\n  backtrace_symbols_fd(array, size, STDERR_FILENO);\n  exit(1);\n}\n\n#ifdef _WIN32\nint WINAPI WinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPSTR lpCmdLine, _In_ int nShowCmd)\n#else\nint main(int argc, char** argv)\n#endif\n{\n\n#ifdef DEBUG\n    signal(SIGSEGV, handler);   // install our debug handler\n#endif\n\n    try {\n        msgBoxTitle(\"Mogwai\");\n\n        SampleConfig config;\n        config.windowDesc.title = \"Mogwai\";\n\n        // offscreen renderer\n        Device::Desc device_desc;\n        device_desc.width = 1280;\n        device_desc.height = 720;\n        //auto pNullWindow = Falcor::Window::SharedPtr(nullptr);\n        //IRenderer::UniquePtr pRenderer = std::make_unique<Mogwai::Renderer>(Device::create(pNullWindow, device_desc));\n        IRenderer::UniquePtr pRenderer = std::make_unique<Mogwai::Renderer>(DeviceManager::instance().createRenderingDevice(0, device_desc));\n\n        ArgList args;\n#ifdef _WIN32\n        args.parseCommandLine(GetCommandLineA());\n        int argc = 0;\n        char** argv = nullptr;\n#else\n        args.parseCommandLine(argc, argv);\n        // config.argc = argc;\n        // config.argv = argv;\n#endif\n\n        if (args.argExists(\"silent\")) {\n            config.suppressInput = true;\n            config.showMessageBoxOnError = false;\n            config.windowDesc.mode = Falcor::Window::WindowMode::Minimized;\n\n            // Set early to not show message box on errors that occur before setting the sample configuration.\n            Logger::showBoxOnError(false);\n        }\n\n        if (args.argExists(\"logfile\")) {\n            auto values = args.getValues(\"logfile\");\n            if (!values.empty()) Logger::setLogFilePath(values.front().asString());\n        }\n\n        Sample::run(config, pRenderer, argc, argv);\n    } catch (const std::exception& e) {\n        // Note: This can only trigger from the setup code above. Sample::run() handles all exceptions internally.\n        logFatal(\"Mogwai crashed unexpectedly...\\n\" + std::string(e.what()));\n    }\n    return 0;\n}\n",
			"file": "src/Mogwai/Mogwai.cpp",
			"file_size": 24909,
			"file_write_time": 132418349596620569,
			"settings":
			{
				"buffer_size": 25052,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/stdafx.h",
			"settings":
			{
				"buffer_size": 1851,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Renderer.h",
			"settings":
			{
				"buffer_size": 7238,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderPassLibrary.cpp",
			"settings":
			{
				"buffer_size": 11374,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderPassLibrary.h",
			"settings":
			{
				"buffer_size": 5360,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/UserInput.h",
			"settings":
			{
				"buffer_size": 7116,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Externals/GLM/glm/gtx/compatibility.hpp",
			"settings":
			{
				"buffer_size": 14969,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Sample.h",
			"settings":
			{
				"buffer_size": 7395,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/Gui.h",
			"settings":
			{
				"buffer_size": 26357,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Window.cpp",
			"settings":
			{
				"buffer_size": 17937,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Window.h",
			"settings":
			{
				"buffer_size": 5627,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/ArgList.cpp",
			"settings":
			{
				"buffer_size": 6269,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/AlignedAllocator.h",
			"settings":
			{
				"buffer_size": 6544,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Resource.h",
			"settings":
			{
				"buffer_size": 7622,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Core/BufferTests.cpp",
			"settings":
			{
				"buffer_size": 6996,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/DebugPasses/InvalidPixelDetectionTests.cpp",
			"settings":
			{
				"buffer_size": 3746,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/ShadingUtils/ShadingUtilsTests.cpp",
			"settings":
			{
				"buffer_size": 12331,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Testing/UnitTest.h",
			"settings":
			{
				"buffer_size": 18208,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Testing/UnitTest.cpp",
			"settings":
			{
				"buffer_size": 11972,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/ComputeProgram.cpp",
			"settings":
			{
				"buffer_size": 2634,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Core/BufferAccessTests.cpp",
			"settings":
			{
				"buffer_size": 6233,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Core/BufferAccessTests.cs.slang",
			"settings":
			{
				"buffer_size": 1913,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Resource.cpp",
			"settings":
			{
				"buffer_size": 5154,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/RenderContext.h",
			"settings":
			{
				"buffer_size": 11441,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/RenderContext.cpp",
			"settings":
			{
				"buffer_size": 5362,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/RasterizerState.h",
			"settings":
			{
				"buffer_size": 7490,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/RasterizerState.cpp",
			"settings":
			{
				"buffer_size": 2247,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKRasterizerState.cpp",
			"settings":
			{
				"buffer_size": 2034,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/QueryHeap.h",
			"settings":
			{
				"buffer_size": 3579,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Formats.h",
			"settings":
			{
				"buffer_size": 13822,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Buffer.h",
			"settings":
			{
				"buffer_size": 19243,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Experimental/Scene/Lights/EnvProbe.h",
			"settings":
			{
				"buffer_size": 3717,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 1908,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/Extensions/Capture/CaptureTrigger.cpp",
			"settings":
			{
				"buffer_size": 7579,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/Extensions/Capture/VideoCapture.cpp",
			"settings":
			{
				"buffer_size": 9661,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/Extensions/Capture/FrameCapture.cpp",
			"settings":
			{
				"buffer_size": 6569,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/Extensions/Capture/FrameCapture.h",
			"settings":
			{
				"buffer_size": 2710,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/RenderGraphEditor/RenderGraphEditor.cpp",
			"settings":
			{
				"buffer_size": 20776,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Externals/dear_imgui_addons/imguinodegrapheditor/imguinodegrapheditor.h",
			"settings":
			{
				"buffer_size": 47853,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/ImageCompare/ImageCompare.cpp",
			"settings":
			{
				"buffer_size": 14050,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/Mogwai.h",
			"settings":
			{
				"buffer_size": 8364,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderGraphImportExport.cpp",
			"settings":
			{
				"buffer_size": 6264,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/ResourceCache.cpp",
			"settings":
			{
				"buffer_size": 8382,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Animation/AnimationController.cpp",
			"settings":
			{
				"buffer_size": 13034,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderPassReflection.cpp",
			"settings":
			{
				"buffer_size": 12090,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderPass.cpp",
			"settings":
			{
				"buffer_size": 2471,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderPasses/ResolvePass.h",
			"settings":
			{
				"buffer_size": 2717,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderPasses/ResolvePass.cpp",
			"settings":
			{
				"buffer_size": 3142,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 5056,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "file( GLOB SOURCES"
			}
		},
		{
			"file": "src/Falcor/Scene/ParticleSystem/ParticleSystem.h",
			"settings":
			{
				"buffer_size": 10438,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/ParticleSystem/ParticleSystem.cpp",
			"settings":
			{
				"buffer_size": 16405,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/HitInfo.h",
			"settings":
			{
				"buffer_size": 3622,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Samples/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 1201,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/RenderGraphEditor/RenderGraphEditor.h",
			"settings":
			{
				"buffer_size": 3325,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/DebugPasses/DebugPasses.cpp",
			"settings":
			{
				"buffer_size": 2422,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/DebugPasses/SplitScreenPass/SplitScreenPass.h",
			"settings":
			{
				"buffer_size": 3241,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/DebugPasses/SplitScreenPass/SplitScreenPass.cpp",
			"settings":
			{
				"buffer_size": 6309,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/DebugPasses/SideBySidePass/SideBySidePass.h",
			"settings":
			{
				"buffer_size": 2670,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/DebugPasses/SideBySidePass/SideBySidePass.cpp",
			"settings":
			{
				"buffer_size": 3143,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/DebugPasses/InvalidPixelDetectionPass/InvalidPixelDetectionPass.h",
			"settings":
			{
				"buffer_size": 2841,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/CSM/CSM.h",
			"settings":
			{
				"buffer_size": 9053,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/CSM/CSM.cpp",
			"settings":
			{
				"buffer_size": 35619,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/Gui.slang",
			"settings":
			{
				"buffer_size": 2501,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/TextRenderer.slang",
			"settings":
			{
				"buffer_size": 2282,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/ErrorMeasurePass/ErrorMeasurePass.cpp",
			"settings":
			{
				"buffer_size": 16583,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/VBuffer/VBufferRaster.h",
			"settings":
			{
				"buffer_size": 3145,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/ErrorMeasurePass/ErrorMeasurePass.h",
			"settings":
			{
				"buffer_size": 4985,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/PixelInspectorPass/PixelInspectorPass.h",
			"settings":
			{
				"buffer_size": 3691,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderPass.h",
			"settings":
			{
				"buffer_size": 7147,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/PixelInspectorPass/PixelInspectorPass.cpp",
			"settings":
			{
				"buffer_size": 15137,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/SSAO/SSAO.h",
			"settings":
			{
				"buffer_size": 4594,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/SkyBox/SkyBox.h",
			"settings":
			{
				"buffer_size": 3515,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/SkyBox/SkyBox.cpp",
			"settings":
			{
				"buffer_size": 8117,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/Antialiasing/FXAA/FXAA.h",
			"settings":
			{
				"buffer_size": 3484,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/Antialiasing/TAA/TAA.h",
			"settings":
			{
				"buffer_size": 3271,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/Antialiasing/TAA/TAA.cpp",
			"settings":
			{
				"buffer_size": 5491,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/Antialiasing/FXAA/FXAA.cpp",
			"settings":
			{
				"buffer_size": 4663,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/SkyBox/Data/cube.obj",
			"settings":
			{
				"buffer_size": 401,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/ForwardLightingPass/ForwardLightingPass.h",
			"settings":
			{
				"buffer_size": 4770,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/ForwardLightingPass/ForwardLightingPass.cpp",
			"settings":
			{
				"buffer_size": 9795,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/ImageLoader/ImageLoader.h",
			"settings":
			{
				"buffer_size": 3059,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/ImageLoader/ImageLoader.cpp",
			"settings":
			{
				"buffer_size": 5146,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/ToneMapper/ToneMapper.h",
			"settings":
			{
				"buffer_size": 5743,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/ToneMapper/ToneMapper.cpp",
			"settings":
			{
				"buffer_size": 16343,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "/***************************************************************************\n # Copyright (c) 2020, NVIDIA CORPORATION. All rights reserved.\n #\n # Redistribution and use in source and binary forms, with or without\n # modification, are permitted provided that the following conditions\n # are met:\n #  * Redistributions of source code must retain the above copyright\n #    notice, this list of conditions and the following disclaimer.\n #  * Redistributions in binary form must reproduce the above copyright\n #    notice, this list of conditions and the following disclaimer in the\n #    documentation and/or other materials provided with the distribution.\n #  * Neither the name of NVIDIA CORPORATION nor the names of its\n #    contributors may be used to endorse or promote products derived\n #    from this software without specific prior written permission.\n #\n # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY\n # EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n # IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n # PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n # CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n # EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n # PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n # PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n **************************************************************************/\n#include \"AccumulatePass.h\"\n\n// Don't remove this. it's required for hot-reload to function properly\nextern \"C\" falcorexport const char* getProjDir() {\n    return PROJECT_DIR;\n}\n\nstatic void regAccumulatePass(ScriptBindings::Module& m) {\n    auto e = m.enum_<AccumulatePass::Precision>(\"AccumulatePrecision\");\n    e.regEnumVal(AccumulatePass::Precision::Double);\n    e.regEnumVal(AccumulatePass::Precision::Single);\n    e.regEnumVal(AccumulatePass::Precision::SingleCompensated);\n}\n\nextern \"C\" falcorexport void getPasses(Falcor::RenderPassLibrary& lib) {\n    lib.registerClass(\"AccumulatePass\", \"Temporal accumulation\", AccumulatePass::create);\n    ScriptBindings::registerBinding(regAccumulatePass);\n}\n\nnamespace {\n\nconst char kShaderFile[] = \"RenderPasses/AccumulatePass/Accumulate.cs.slang\";\n\nconst char kInputChannel[] = \"input\";\nconst char kOutputChannel[] = \"output\";\n\n// Serialized parameters\nconst char kEnableAccumulation[] = \"enableAccumulation\";\nconst char kPrecisionMode[] = \"precisionMode\";\n\nconst Gui::DropdownList kModeSelectorList = {\n    { (uint32_t)AccumulatePass::Precision::Double, \"Double precision\" },\n    { (uint32_t)AccumulatePass::Precision::Single, \"Single precision\" },\n    { (uint32_t)AccumulatePass::Precision::SingleCompensated, \"Single precision (compensated)\" },\n};\n\n}\n\nAccumulatePass::SharedPtr AccumulatePass::create(RenderContext* pRenderContext, const Dictionary& dict) {\n    return SharedPtr(new AccumulatePass(pRenderContext->device(), dict));\n}\n\nAccumulatePass::AccumulatePass(Device::SharedPtr pDevice, const Dictionary& dict): RenderPass(pDevice) {\n    // Deserialize pass from dictionary.\n    for (const auto& v : dict) {\n        if (v.key() == kEnableAccumulation) mEnableAccumulation = v.val();\n        else if (v.key() == kPrecisionMode) mPrecisionMode = v.val();\n        else logWarning(\"Unknown field `\" + v.key() + \"` in AccumulatePass dictionary\");\n    }\n\n    // Create accumulation programs.\n    // Note only compensated summation needs precise floating-point mode.\n    mpProgram[Precision::Double] = ComputeProgram::createFromFile(pDevice, kShaderFile, \"accumulateDouble\", Program::DefineList(), Shader::CompilerFlags::TreatWarningsAsErrors);\n    mpProgram[Precision::Single] = ComputeProgram::createFromFile(pDevice, kShaderFile, \"accumulateSingle\", Program::DefineList(), Shader::CompilerFlags::TreatWarningsAsErrors);\n    mpProgram[Precision::SingleCompensated] = ComputeProgram::createFromFile(pDevice, kShaderFile, \"accumulateSingleCompensated\", Program::DefineList(), Shader::CompilerFlags::FloatingPointModePrecise | Shader::CompilerFlags::TreatWarningsAsErrors);\n    mpVars = ComputeVars::create(pDevice, mpProgram[Precision::Single]->getReflector());\n\n    mpState = ComputeState::create(pDevice);\n}\n\nDictionary AccumulatePass::getScriptingDictionary() {\n    Dictionary dict;\n    dict[kEnableAccumulation] = mEnableAccumulation;\n    dict[kPrecisionMode] = mPrecisionMode;\n    return dict;\n}\n\nRenderPassReflection AccumulatePass::reflect(const CompileData& compileData) {\n    RenderPassReflection reflector;\n    reflector.addInput(kInputChannel, \"Input data to be temporally accumulated\").bindFlags(ResourceBindFlags::ShaderResource);\n    reflector.addOutput(kOutputChannel, \"Output data that is temporally accumulated\").bindFlags(ResourceBindFlags::RenderTarget | ResourceBindFlags::UnorderedAccess | ResourceBindFlags::ShaderResource).format(ResourceFormat::RGBA32Float);\n    return reflector;\n}\n\nvoid AccumulatePass::compile(RenderContext* pContext, const CompileData& compileData) {\n    assert(mpDevice == pContext->device());\n\n    // Reset accumulation when resolution changes.\n    if (compileData.defaultTexDims != mFrameDim) {\n        mFrameCount = 0;\n        mFrameDim = compileData.defaultTexDims;\n    }\n}\n\nvoid AccumulatePass::execute(RenderContext* pRenderContext, const RenderData& renderData) {\n    // Query refresh flags passed down from the application and other passes.\n    auto& dict = renderData.getDictionary();\n    RenderPassRefreshFlags refreshFlags = (RenderPassRefreshFlags)(dict.keyExists(kRenderPassRefreshFlags) ? dict[kRenderPassRefreshFlags] : 0u);\n\n    // If any refresh flag is set, we reset frame accumulation.\n    if (refreshFlags != RenderPassRefreshFlags::None) mFrameCount = 0;\n\n    // Reset accumulation upon all scene changes, except camera jitter and history changes.\n    // TODO: Add UI options to select which changes should trigger reset\n    if (mpScene) {\n        auto sceneUpdates = mpScene->getUpdates();\n        if ((sceneUpdates & ~Scene::UpdateFlags::CameraPropertiesChanged) != Scene::UpdateFlags::None) {\n            mFrameCount = 0;\n        }\n\n        if (is_set(sceneUpdates, Scene::UpdateFlags::CameraPropertiesChanged)) {\n            auto excluded = Camera::Changes::Jitter | Camera::Changes::History;\n            auto cameraChanges = mpScene->getCamera()->getChanges();\n            if ((cameraChanges & ~excluded) != Camera::Changes::None) mFrameCount = 0;\n        }\n    }\n\n    // Grab our input/output buffers.\n    Texture::SharedPtr pSrc = renderData[kInputChannel]->asTexture();\n    Texture::SharedPtr pDst = renderData[kOutputChannel]->asTexture();\n\n    assert(pSrc && pDst);\n    assert(pSrc->getWidth() == pDst->getWidth() && pSrc->getHeight() == pDst->getHeight());\n    const uint2 resolution = uint2(pSrc->getWidth(), pSrc->getHeight());\n\n    // If accumulation is disabled, just blit the source to the destination and return.\n    if (!mEnableAccumulation) {\n        // Only blit mip 0 and array slice 0, because that's what the accumulation uses otherwise otherwise.\n        pRenderContext->blit(pSrc->getSRV(0, 1, 0, 1), pDst->getRTV(0, 0, 1));\n        return;\n    }\n\n    // Setup accumulation.\n    prepareAccumulation(pRenderContext, resolution.x, resolution.y);\n\n    // Set shader parameters.\n    mpVars[\"PerFrameCB\"][\"gResolution\"] = resolution;\n    mpVars[\"PerFrameCB\"][\"gAccumCount\"] = mFrameCount++;\n    mpVars[\"gCurFrame\"] = pSrc;\n    mpVars[\"gOutputFrame\"] = pDst;\n\n    // Bind accumulation buffers. Some of these may be nullptr's.\n    mpVars[\"gLastFrameSum\"] = mpLastFrameSum;\n    mpVars[\"gLastFrameCorr\"] = mpLastFrameCorr;\n    mpVars[\"gLastFrameSumLo\"] = mpLastFrameSumLo;\n    mpVars[\"gLastFrameSumHi\"] = mpLastFrameSumHi;\n\n    // Run the accumulation program.\n    auto pProgram = mpProgram[mPrecisionMode];\n    assert(pProgram);\n    uint3 numGroups = div_round_up(uint3(resolution.x, resolution.y, 1u), pProgram->getReflector()->getThreadGroupSize());\n    mpState->setProgram(pProgram);\n    pRenderContext->dispatch(mpState.get(), mpVars.get(), numGroups);\n}\n\nvoid AccumulatePass::renderUI(Gui::Widgets& widget) {\n    if (widget.checkbox(\"Accumulate temporally\", mEnableAccumulation)) {\n        // Reset accumulation when it is toggled.\n        mFrameCount = 0;\n    }\n\n    if (mEnableAccumulation) {\n        if (widget.dropdown(\"Mode\", kModeSelectorList, (uint32_t&)mPrecisionMode)) {\n            // Reset accumulation when mode changes.\n            mFrameCount = 0;\n        }\n\n        const std::string text = std::string(\"Frames accumulated \") + std::to_string(mFrameCount);\n        widget.text(text.c_str());\n    }\n}\n\nvoid AccumulatePass::setScene(RenderContext* pRenderContext, const Scene::SharedPtr& pScene) {\n    assert(mpDevice == pRenderContext->device());\n    assert(mpDevice == pScene->device());\n    \n    // Reset accumulation when the scene changes.\n    mFrameCount = 0;\n    mpScene = pScene;\n}\n\nvoid AccumulatePass::onHotReload(HotReloadFlags reloaded) {\n    // Reset accumulation if programs changed.\n    if (is_set(reloaded, HotReloadFlags::Program)) mFrameCount = 0;\n}\n\nvoid AccumulatePass::prepareAccumulation(RenderContext* pRenderContext, uint32_t width, uint32_t height) {\n    // Allocate/resize/clear buffers for intermedate data. These are different depending on accumulation mode.\n    // Buffers that are not used in the current mode are released.\n    auto prepareBuffer = [&](Texture::SharedPtr& pBuf, ResourceFormat format, bool bufUsed) {\n        if (!bufUsed) {\n            pBuf = nullptr;\n            return;\n        }\n        // (Re-)create buffer if needed.\n        if (!pBuf || pBuf->getWidth() != width || pBuf->getHeight() != height) {\n            pBuf = Texture::create2D(pRenderContext->device(), width, height, format, 1, 1, nullptr, Resource::BindFlags::ShaderResource | Resource::BindFlags::UnorderedAccess);\n            assert(pBuf);\n            mFrameCount = 0;\n        }\n        // Clear data if accumulation has been reset (either above or somewhere else).\n        if (mFrameCount == 0) {\n            if (getFormatType(format) == FormatType::Float) pRenderContext->clearUAV(pBuf->getUAV().get(), float4(0.f));\n            else pRenderContext->clearUAV(pBuf->getUAV().get(), uint4(0));\n        }\n    };\n\n    prepareBuffer(mpLastFrameSum, ResourceFormat::RGBA32Float, mPrecisionMode == Precision::Single || mPrecisionMode == Precision::SingleCompensated);\n    prepareBuffer(mpLastFrameCorr, ResourceFormat::RGBA32Float, mPrecisionMode == Precision::SingleCompensated);\n    prepareBuffer(mpLastFrameSumLo, ResourceFormat::RGBA32Uint, mPrecisionMode == Precision::Double);\n    prepareBuffer(mpLastFrameSumHi, ResourceFormat::RGBA32Uint, mPrecisionMode == Precision::Double);\n}\n",
			"file": "src/RenderPasses/AccumulatePass/AccumulatePass.cpp",
			"file_size": 10957,
			"file_write_time": 132416570859865874,
			"settings":
			{
				"buffer_size": 10962,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/GBufferBase.h",
			"settings":
			{
				"buffer_size": 3832,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/GBufferBase.cpp",
			"settings":
			{
				"buffer_size": 6981,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/SampleGenerators/HaltonSamplePattern.cpp",
			"settings":
			{
				"buffer_size": 2647,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/VBuffer/VBufferRT.h",
			"settings":
			{
				"buffer_size": 2997,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/GBuffer/GBufferRaster.cpp",
			"settings":
			{
				"buffer_size": 10032,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/GBuffer/GBufferRaster.h",
			"settings":
			{
				"buffer_size": 3272,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/GBuffer/GBuffer.h",
			"settings":
			{
				"buffer_size": 3324,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/GBuffer/GBuffer.cpp",
			"settings":
			{
				"buffer_size": 5817,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/DepthPass/DepthPass.cpp",
			"settings":
			{
				"buffer_size": 5276,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/Utils/GaussianBlur/GaussianBlur.cpp",
			"settings":
			{
				"buffer_size": 8197,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/SSAO/SSAO.cpp",
			"settings":
			{
				"buffer_size": 11813,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/Utils/GaussianBlur/GaussianBlur.h",
			"settings":
			{
				"buffer_size": 3739,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/Utils/Composite/Composite.cpp",
			"settings":
			{
				"buffer_size": 4310,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/TemporalDelayPass/TemporalDelayPass.h",
			"settings":
			{
				"buffer_size": 2910,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/Utils/Composite/Composite.h",
			"settings":
			{
				"buffer_size": 3098,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/DepthPass/DepthPass.h",
			"settings":
			{
				"buffer_size": 3513,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/GBuffer/GBufferRT.h",
			"settings":
			{
				"buffer_size": 3771,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/VBuffer/VBufferRT.cpp",
			"settings":
			{
				"buffer_size": 5767,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/VBuffer/VBufferRaster.cpp",
			"settings":
			{
				"buffer_size": 5672,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/GBuffer/GBufferRT.cpp",
			"settings":
			{
				"buffer_size": 9623,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/Antialiasing/Antialiasing.cpp",
			"settings":
			{
				"buffer_size": 2797,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/BlitPass/BlitPass.cpp",
			"settings":
			{
				"buffer_size": 3995,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/BSDFViewer/BSDFViewer.h",
			"settings":
			{
				"buffer_size": 4475,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/SVGFPass/SVGFPass.cpp",
			"settings":
			{
				"buffer_size": 19004,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/TemporalDelayPass/TemporalDelayPass.cpp",
			"settings":
			{
				"buffer_size": 6201,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/SVGFPass/SVGFPass.h",
			"settings":
			{
				"buffer_size": 4664,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/BSDFViewer/BSDFViewer.cpp",
			"settings":
			{
				"buffer_size": 18949,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/DebugPasses/ComparisonPass.h",
			"settings":
			{
				"buffer_size": 3286,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/DebugPasses/ComparisonPass.cpp",
			"settings":
			{
				"buffer_size": 5212,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/BlitPass/BlitPass.h",
			"settings":
			{
				"buffer_size": 2955,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/AccumulatePass/AccumulatePass.h",
			"settings":
			{
				"buffer_size": 5448,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "CMakeLists.txt",
			"settings":
			{
				"buffer_size": 3791,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 291,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 1250,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/renderBuffer.h",
			"settings":
			{
				"buffer_size": 2239,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "/*************************************************"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/renderBuffer.cpp",
			"settings":
			{
				"buffer_size": 3529,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "/*************************************************"
			}
		},
		{
			"file": "src/pxr/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 1818,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "cmake/modules/FindTBB.cmake",
			"settings":
			{
				"buffer_size": 12566,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "cmake/defaults/Packages.cmake",
			"settings":
			{
				"buffer_size": 7991,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/renderDelegate.h",
			"settings":
			{
				"buffer_size": 3280,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/renderParam.h",
			"settings":
			{
				"buffer_size": 1756,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/rendererPlugin.h",
			"settings":
			{
				"buffer_size": 1809,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/renderPass.cpp",
			"settings":
			{
				"buffer_size": 2971,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/camera.h",
			"settings":
			{
				"buffer_size": 2562,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "/*************************************************"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/camera.cpp",
			"settings":
			{
				"buffer_size": 6546,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "/*************************************************"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/renderParam.cpp",
			"settings":
			{
				"buffer_size": 1800,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/renderDelegate.cpp",
			"settings":
			{
				"buffer_size": 14313,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/config.cpp",
			"settings":
			{
				"buffer_size": 26025,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "//"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/config.h",
			"settings":
			{
				"buffer_size": 7104,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "//"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/renderPass.h",
			"settings":
			{
				"buffer_size": 679,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/lavaApi.h.old",
			"settings":
			{
				"buffer_size": 6854,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "/*************************************************"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/lavaApi.cpp.old",
			"settings":
			{
				"buffer_size": 113965,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "/*************************************************"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/lavaApi.h",
			"settings":
			{
				"buffer_size": 2382,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/pxr/imaging/plugin/hdLava/lavaApi.cpp",
			"settings":
			{
				"buffer_size": 21681,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/StringUtils.h",
			"settings":
			{
				"buffer_size": 12635,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Samples/ModelViewer/ModelViewer.cpp",
			"settings":
			{
				"buffer_size": 9979,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Samples/ModelViewer/ModelViewer.ps.slang.bak",
			"settings":
			{
				"buffer_size": 2408,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Samples/ModelViewer/ModelViewer.ps.slang",
			"settings":
			{
				"buffer_size": 2391,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Lights/LightProbeIntegration.ps.slang",
			"settings":
			{
				"buffer_size": 7921,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 1429,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Samples/ShaderToy/ShaderToy.cpp",
			"settings":
			{
				"buffer_size": 4229,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/BasePasses/FullScreenPass.cpp",
			"settings":
			{
				"buffer_size": 5700,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/BasePasses/ComputePass.h",
			"settings":
			{
				"buffer_size": 6377,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/BasePasses/FullScreenPass.h",
			"settings":
			{
				"buffer_size": 4028,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/BasePasses/ComputePass.cpp",
			"settings":
			{
				"buffer_size": 4043,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/BasePasses/BaseGraphicsPass.cpp",
			"settings":
			{
				"buffer_size": 2824,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Timing/FrameRate.h",
			"settings":
			{
				"buffer_size": 3811,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Timing/FrameRate.cpp",
			"settings":
			{
				"buffer_size": 2265,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Experimental/Scene/Lights/LightBVHSampler.h",
			"settings":
			{
				"buffer_size": 6356,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Experimental/Scene/Lights/LightBVHSampler.cpp",
			"settings":
			{
				"buffer_size": 7714,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Experimental/Scene/Lights/LightCollection.cpp",
			"settings":
			{
				"buffer_size": 29489,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/BasePasses/BaseGraphicsPass.h",
			"settings":
			{
				"buffer_size": 3726,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Experimental/Scene/Lights/LightCollection.h",
			"settings":
			{
				"buffer_size": 12783,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/BufferTypes/ParameterBlock.cpp",
			"settings":
			{
				"buffer_size": 67261,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/BSDFViewer/BSDFViewer.cs.slang",
			"settings":
			{
				"buffer_size": 15202,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Core/BufferTests.cs.slang",
			"settings":
			{
				"buffer_size": 2850,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/ShaderVar.cpp",
			"settings":
			{
				"buffer_size": 15515,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Lights/LightProbe.cpp",
			"settings":
			{
				"buffer_size": 11503,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "/***************************************************************************\n # Copyright (c) 2020, NVIDIA CORPORATION. All rights reserved.\n #\n # Redistribution and use in source and binary forms, with or without\n # modification, are permitted provided that the following conditions\n # are met:\n #  * Redistributions of source code must retain the above copyright\n #    notice, this list of conditions and the following disclaimer.\n #  * Redistributions in binary form must reproduce the above copyright\n #    notice, this list of conditions and the following disclaimer in the\n #    documentation and/or other materials provided with the distribution.\n #  * Neither the name of NVIDIA CORPORATION nor the names of its\n #    contributors may be used to endorse or promote products derived\n #    from this software without specific prior written permission.\n #\n # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY\n # EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n # IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n # PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n # CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n # EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n # PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n # PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n **************************************************************************/\n#ifndef SRC_FALCOR_SCENE_LIGHTS_LIGHTPROBE_H_\n#define SRC_FALCOR_SCENE_LIGHTS_LIGHTPROBE_H_\n\n#include \"LightProbeData.slang\"\n#include \"Falcor/Core/API/Texture.h\"\n#include \"Falcor/Core/API/Sampler.h\"\n\nnamespace Falcor {\n\nclass Device;\nclass RenderContext;\nclass Gui;\nclass ProgramVars;\nclass ParameterBlock;\n\nclass dlldecl LightProbe {\n public:\n    using SharedPtr = std::shared_ptr<LightProbe>;\n    using SharedConstPtr = std::shared_ptr<const LightProbe>;\n    using ConstSharedPtrRef = const SharedPtr&;\n\n    static const uint32_t kDataSize = sizeof(LightProbeData) - sizeof(LightProbeResources);\n    static const uint32_t kDefaultDiffSamples = 4096;\n    static const uint32_t kDefaultSpecSamples = 1024;\n    static const uint32_t kDefaultDiffSize = 128;\n    static const uint32_t kDefaultSpecSize = 1024;\n\n    /** Create a light-probe from a file\n        \\param[in] pContext The current render context to be used for pre-integration.\n        \\param[in] filename Texture filename\n        \\param[in] loadAsSrgb Indicates whether the source texture is in sRGB or linear color space\n        \\param[in] overrideFormat Override the format of the original texture. ResourceFormat::Unknown means keep the original format. Useful in cases where generateMips is true, but the original format doesn't support automatic mip generation\n        \\param[in] diffSampleCount How many times to sample when generating diffuse texture.\n        \\param[in] specSampleCount How many times to sample when generating specular texture.\n        \\param[in] diffSize The width and height of the pre-filtered diffuse texture. We always create a square texture.\n        \\param[in] specSize The width and height of the pre-filtered specular texture. We always create a square texture.\n        \\param[in] preFilteredFormat The format of the pre-filtered texture\n    */\n    static SharedPtr create(RenderContext* pContext, const std::string& filename, bool loadAsSrgb, ResourceFormat overrideFormat = ResourceFormat::Unknown, uint32_t diffSampleCount = kDefaultDiffSamples, uint32_t specSampleCount = kDefaultSpecSamples, uint32_t diffSize = kDefaultDiffSize, uint32_t specSize = kDefaultSpecSize, ResourceFormat preFilteredFormat = ResourceFormat::RGBA16Float);\n\n    /** Create a light-probe from a texture\n        \\param[in] pContext The current render context to be used for pre-integration.\n        \\param[in] pTexture The source texture\n        \\param[in] diffSampleCount How many times to sample when generating diffuse texture.\n        \\param[in] specSampleCount How many times to sample when generating specular texture.\n        \\param[in] diffSize The width and height of the pre-filtered diffuse texture. We always create a square texture.\n        \\param[in] specSize The width and height of the pre-filtered specular texture. We always create a square texture.\n        \\param[in] preFilteredFormat The format of the pre-filtered texture\n    */\n    static SharedPtr create(RenderContext* pContext, const Texture::SharedPtr& pTexture, uint32_t diffSampleCount = kDefaultDiffSamples, uint32_t specSampleCount = kDefaultSpecSamples, uint32_t diffSize = kDefaultDiffSize, uint32_t specSize = kDefaultSpecSize, ResourceFormat preFilteredFormat = ResourceFormat::RGBA16Float);\n\n    ~LightProbe();\n\n    /** Render UI elements for this light.\n        \\param[in] pGui The GUI to create the elements with\n        \\param[in] group Optional. If specified, creates a UI group to display elements within\n    */\n    void renderUI(Gui* pGui, const char* group = nullptr);\n\n    /** Set the light probe's world-space position\n    */\n    void setPosW(const float3& posW) { mData.posW = posW; }\n\n    /** Get the light probe's world-space position\n    */\n    const float3& getPosW() const { return mData.posW; }\n\n    /** Set the spherical radius the light probe encompasses. Set radius to negative to sample as an infinite-distance global light probe.\n    */\n    void setRadius(float radius) { mData.radius = radius; }\n\n    /** Get the light probe's radius.\n    */\n    float getRadius() const { return mData.radius; }\n\n    /** Get the sample count used to generate the diffuse texture.\n    */\n    uint32_t getDiffSampleCount() const { return mDiffSampleCount; }\n\n    /** Get the sample count used to generate the specular texture.\n    */\n    uint32_t getSpecSampleCount() const { return mSpecSampleCount; }\n\n    /** Set the light probe's light intensity\n    */\n    void setIntensity(const float3& intensity) { mData.intensity = intensity; }\n\n    /** Get the light probe's light intensity\n    */\n    const float3& getIntensity() const { return mData.intensity; }\n\n    /** Attach a sampler to the light probe\n    */\n    void setSampler(const Sampler::SharedPtr& pSampler) { mData.resources.sampler = pSampler; }\n\n    /** Get the sampler state\n    */\n    const Sampler::SharedPtr& getSampler() const { return mData.resources.sampler; }\n\n    /** Get the light probe's source texture.\n    */\n    const Texture::SharedPtr& getOrigTexture() const { return mData.resources.origTexture; }\n\n    /** Get the light probe's diffuse texture.\n    */\n    const Texture::SharedPtr& getDiffuseTexture() const { return mData.resources.diffuseTexture; }\n\n    /** Get the light probe's specular texture.\n    */\n    const Texture::SharedPtr& getSpecularTexture() const { return mData.resources.specularTexture; }\n\n    /** Get the texture storing the pre-integrated DFG term shared by all light probes.\n    */\n    static const Texture::SharedPtr& getDfgTexture() { return sSharedResources.dfgTexture; }\n\n    /** Bind the light data into a shader var\n    */\n    void setShaderData(const ShaderVar& var);\n\n private:\n    static uint32_t sLightProbeCount;\n    static LightProbeSharedResources sSharedResources;\n\n    LightProbeData mData;\n    uint32_t mDiffSampleCount;\n    uint32_t mSpecSampleCount;\n\n    LightProbe(RenderContext* pContext, const Texture::SharedPtr& pTexture, uint32_t diffSamples, uint32_t specSamples, uint32_t diffSize, uint32_t specSize, ResourceFormat preFilteredFormat);\n};\n\n}  // namespace Falcor\n\n#endif  // SRC_FALCOR_SCENE_LIGHTS_LIGHTPROBE_H_\n",
			"file": "src/Falcor/Scene/Lights/LightProbe.h",
			"file_size": 7852,
			"file_write_time": 132406993613157651,
			"settings":
			{
				"buffer_size": 7813,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/BasePasses/RasterScenePass.cpp",
			"settings":
			{
				"buffer_size": 3402,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderGraphCompiler.cpp",
			"settings":
			{
				"buffer_size": 18153,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderGraph.cpp",
			"settings":
			{
				"buffer_size": 30158,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderGraphExe.cpp",
			"settings":
			{
				"buffer_size": 4177,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderGraphExe.h",
			"settings":
			{
				"buffer_size": 4072,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Scripting/Dictionary.h",
			"settings":
			{
				"buffer_size": 4523,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderGraphUI.cpp",
			"settings":
			{
				"buffer_size": 64727,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Debug/PixelDebug.cpp",
			"settings":
			{
				"buffer_size": 9625,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Algorithm/ParallelReduction.cpp",
			"settings":
			{
				"buffer_size": 6148,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Utils/ParallelReductionTests.cpp",
			"settings":
			{
				"buffer_size": 11656,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Utils/PrefixSumTests.cpp",
			"settings":
			{
				"buffer_size": 4850,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Algorithm/PrefixSum.cpp",
			"settings":
			{
				"buffer_size": 7112,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Algorithm/BitonicSort.cpp",
			"settings":
			{
				"buffer_size": 4470,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Algorithm/ComputeParallelReduction.h",
			"settings":
			{
				"buffer_size": 4901,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Algorithm/ParallelReduction.h",
			"settings":
			{
				"buffer_size": 3575,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Algorithm/BitonicSort.h",
			"settings":
			{
				"buffer_size": 4169,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Algorithm/PrefixSum.h",
			"settings":
			{
				"buffer_size": 4191,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Algorithm/ComputeParallelReduction.cpp",
			"settings":
			{
				"buffer_size": 9541,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Scripting/Console.cpp",
			"settings":
			{
				"buffer_size": 4108,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Scripting/ScriptBindings.cpp",
			"settings":
			{
				"buffer_size": 4848,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Sampling/SampleGenerator.cpp",
			"settings":
			{
				"buffer_size": 3452,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Timing/Clock.cpp",
			"settings":
			{
				"buffer_size": 9831,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Timing/Clock.h",
			"settings":
			{
				"buffer_size": 8564,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/TextureLoader.cpp",
			"settings":
			{
				"buffer_size": 24304,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/assimp/include/assimp/Bitmap.h",
			"settings":
			{
				"buffer_size": 4295,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/VAO.h",
			"settings":
			{
				"buffer_size": 5144,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Logger.h",
			"settings":
			{
				"buffer_size": 5549,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Logger.cpp",
			"settings":
			{
				"buffer_size": 5968,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/BinaryFileStream.h",
			"settings":
			{
				"buffer_size": 5898,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Scripting/Scripting.cpp",
			"settings":
			{
				"buffer_size": 5721,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Timing/Profiler.cpp",
			"settings":
			{
				"buffer_size": 10754,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/Gui.cpp",
			"settings":
			{
				"buffer_size": 56184,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/PixelZoom.cpp",
			"settings":
			{
				"buffer_size": 5190,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/TextRenderer.cpp",
			"settings":
			{
				"buffer_size": 7231,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/TextRenderer.h",
			"settings":
			{
				"buffer_size": 3353,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/PixelZoom.h",
			"settings":
			{
				"buffer_size": 3368,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/DebugDrawer.h",
			"settings":
			{
				"buffer_size": 4027,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/DebugDrawer.cpp",
			"settings":
			{
				"buffer_size": 8927,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/Font.h",
			"settings":
			{
				"buffer_size": 4060,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/tools/render-test/bind-location.h",
			"settings":
			{
				"buffer_size": 19257,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/Font.cpp",
			"settings":
			{
				"buffer_size": 5156,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/ProgramReflection.cpp",
			"settings":
			{
				"buffer_size": 85087,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKGraphicsStateObject.cpp",
			"settings":
			{
				"buffer_size": 5776,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/source/slang/slang-reflection.cpp",
			"settings":
			{
				"buffer_size": 50216,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/source/slang/slang-compiler.h",
			"settings":
			{
				"buffer_size": 90183,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/source/slang/slang-name.cpp",
			"settings":
			{
				"buffer_size": 800,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/source/core/slang-dictionary.h",
			"settings":
			{
				"buffer_size": 13988,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/ProgramVars.cpp",
			"settings":
			{
				"buffer_size": 14440,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Raytracing/RtProgramVarsHelper.h",
			"settings":
			{
				"buffer_size": 14339,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/ProgramVars.h",
			"settings":
			{
				"buffer_size": 6798,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/ShaderVar.h",
			"settings":
			{
				"buffer_size": 17036,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/ProgramReflection.h",
			"settings":
			{
				"buffer_size": 54816,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/Program.cpp",
			"settings":
			{
				"buffer_size": 34062,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Buffer.cpp",
			"settings":
			{
				"buffer_size": 13450,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/FBO.cpp",
			"settings":
			{
				"buffer_size": 18040,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/BlendState.h",
			"settings":
			{
				"buffer_size": 9346,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/BlendState.cpp",
			"settings":
			{
				"buffer_size": 3664,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/FBO.h",
			"settings":
			{
				"buffer_size": 13546,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hdLava/rendererPlugin.cpp",
			"settings":
			{
				"buffer_size": 734,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hdLava/renderDelegate.h",
			"settings":
			{
				"buffer_size": 3463,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hdLava/renderDelegate.cpp",
			"settings":
			{
				"buffer_size": 14534,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hdLava/renderThread.h",
			"settings":
			{
				"buffer_size": 2169,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "/*************************************************"
			}
		},
		{
			"file": "src/USD/hdLava/renderThread.cpp",
			"settings":
			{
				"buffer_size": 4673,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "/*************************************************"
			}
		},
		{
			"file": "src/USD/hdLava/rendererPlugin.h",
			"settings":
			{
				"buffer_size": 1809,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Texture.h",
			"settings":
			{
				"buffer_size": 15518,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/ShadingUtils/RaytracingTests.cpp",
			"settings":
			{
				"buffer_size": 4882,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Slang/SlangTests.cpp",
			"settings":
			{
				"buffer_size": 8055,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Slang/SlangTests.cs.slang",
			"settings":
			{
				"buffer_size": 6527,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Slang/SlangShared.slang",
			"settings":
			{
				"buffer_size": 2435,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Slang/ShaderModel.cpp",
			"settings":
			{
				"buffer_size": 3182,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Slang/Int64Tests.cpp",
			"settings":
			{
				"buffer_size": 3694,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Slang/TraceRayFlags.cpp",
			"settings":
			{
				"buffer_size": 3163,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Slang/TraceRayInline.cpp",
			"settings":
			{
				"buffer_size": 2113,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Slang/WaveOps.cpp",
			"settings":
			{
				"buffer_size": 6067,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Utils/AABBTests.cpp",
			"settings":
			{
				"buffer_size": 7752,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/prelude/slang-cpp-types.h",
			"settings":
			{
				"buffer_size": 28997,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/FalcorTest.h",
			"settings":
			{
				"buffer_size": 2143,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/FalcorTest.cpp",
			"settings":
			{
				"buffer_size": 3605,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Sampling/SampleGeneratorTests.cpp",
			"settings":
			{
				"buffer_size": 7287,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Core/RootBufferTests.cpp",
			"settings":
			{
				"buffer_size": 8005,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Core/RootBufferStructTests.cpp",
			"settings":
			{
				"buffer_size": 5631,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VkGpuMemoryHeap.cpp",
			"settings":
			{
				"buffer_size": 2413,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Platform/Linux/Linux.cpp",
			"settings":
			{
				"buffer_size": 15074,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Platform/Windows/ProgressBarWin.cpp",
			"settings":
			{
				"buffer_size": 4513,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Platform/OS.h",
			"settings":
			{
				"buffer_size": 15995,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKState.h",
			"settings":
			{
				"buffer_size": 3960,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Texture.cpp",
			"settings":
			{
				"buffer_size": 16435,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 638,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hdLava/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 1179,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hdLava/api.h",
			"settings":
			{
				"buffer_size": 788,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hdLava/pch.h",
			"settings":
			{
				"buffer_size": 5431,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hdLava/boostIncludePath.h",
			"settings":
			{
				"buffer_size": 1114,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "/*************************************************"
			}
		},
		{
			"file": "src/USD/hdLava/plugInfo.json",
			"settings":
			{
				"buffer_size": 604,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hdLava/renderPass.h",
			"settings":
			{
				"buffer_size": 715,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hdLava/renderPass.cpp",
			"settings":
			{
				"buffer_size": 2970,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hdLava/renderParam.h",
			"settings":
			{
				"buffer_size": 2361,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hdLava/renderParam.cpp",
			"settings":
			{
				"buffer_size": 2251,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "/*************************************************"
			}
		},
		{
			"file": "src/USD/hgiVk/commandBuffer.cpp",
			"settings":
			{
				"buffer_size": 8461,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/commandBufferManager.cpp",
			"settings":
			{
				"buffer_size": 13416,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/commandPool.cpp",
			"settings":
			{
				"buffer_size": 1629,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/computeEncoder.cpp",
			"settings":
			{
				"buffer_size": 1791,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/conversions.cpp",
			"settings":
			{
				"buffer_size": 9785,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/device.cpp",
			"settings":
			{
				"buffer_size": 17769,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/diagnostic.cpp",
			"settings":
			{
				"buffer_size": 6577,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/frame.cpp",
			"settings":
			{
				"buffer_size": 2455,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/garbageCollector.cpp",
			"settings":
			{
				"buffer_size": 3957,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/graphicsEncoder.cpp",
			"settings":
			{
				"buffer_size": 6479,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/hgi.cpp",
			"settings":
			{
				"buffer_size": 14444,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/instance.cpp",
			"settings":
			{
				"buffer_size": 1940,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/parallelGraphicsEncoder.cpp",
			"settings":
			{
				"buffer_size": 3913,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/pipeline.cpp",
			"settings":
			{
				"buffer_size": 15055,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/renderPass.cpp",
			"settings":
			{
				"buffer_size": 15805,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/pipeline.h",
			"settings":
			{
				"buffer_size": 1831,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/renderPassPipelineCache.cpp",
			"settings":
			{
				"buffer_size": 8095,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/resourceBindings.cpp",
			"settings":
			{
				"buffer_size": 16563,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/shaderCompiler.cpp",
			"settings":
			{
				"buffer_size": 10186,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/shaderFunction.cpp",
			"settings":
			{
				"buffer_size": 2509,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/shaderProgram.cpp",
			"settings":
			{
				"buffer_size": 437,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/surface.cpp",
			"settings":
			{
				"buffer_size": 3812,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/swapchain.cpp",
			"settings":
			{
				"buffer_size": 17443,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/texture.cpp",
			"settings":
			{
				"buffer_size": 15437,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/buffer.cpp",
			"settings":
			{
				"buffer_size": 9825,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/blitEncoder.cpp",
			"settings":
			{
				"buffer_size": 6180,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/blitEncoder.h",
			"settings":
			{
				"buffer_size": 1319,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/buffer.h",
			"settings":
			{
				"buffer_size": 1965,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/commandBuffer.h",
			"settings":
			{
				"buffer_size": 3844,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/commandBufferManager.h",
			"settings":
			{
				"buffer_size": 5853,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/commandPool.h",
			"settings":
			{
				"buffer_size": 1102,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/computeEncoder.h",
			"settings":
			{
				"buffer_size": 1631,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/conversions.h",
			"settings":
			{
				"buffer_size": 1688,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/device.h",
			"settings":
			{
				"buffer_size": 6599,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/diagnostic.h",
			"settings":
			{
				"buffer_size": 1085,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/frame.h",
			"settings":
			{
				"buffer_size": 2289,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/garbageCollector.h",
			"settings":
			{
				"buffer_size": 1637,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/graphicsEncoder.h",
			"settings":
			{
				"buffer_size": 2732,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/hgi.h",
			"settings":
			{
				"buffer_size": 4470,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/instance.h",
			"settings":
			{
				"buffer_size": 693,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/parallelGraphicsEncoder.h",
			"settings":
			{
				"buffer_size": 1608,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/MogwaiSettings.h",
			"settings":
			{
				"buffer_size": 2575,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/MogwaiSettings.cpp",
			"settings":
			{
				"buffer_size": 10806,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/MogwaiScripting.cpp",
			"settings":
			{
				"buffer_size": 6767,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Shader.h",
			"settings":
			{
				"buffer_size": 8437,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Sampler.h",
			"settings":
			{
				"buffer_size": 7871,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Sampler.cpp",
			"settings":
			{
				"buffer_size": 3887,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKShader.cpp",
			"settings":
			{
				"buffer_size": 2775,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/stdafx.h",
			"settings":
			{
				"buffer_size": 1831,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/CopyContext.cpp",
			"settings":
			{
				"buffer_size": 6896,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/VAO.cpp",
			"settings":
			{
				"buffer_size": 3603,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKBuffer.cpp",
			"settings":
			{
				"buffer_size": 6579,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/ComputeContext.cpp",
			"settings":
			{
				"buffer_size": 3000,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/D3D12/D3D12ComputeContext.cpp",
			"settings":
			{
				"buffer_size": 6740,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/D3D12/D3D12LowLevelContextData.cpp",
			"settings":
			{
				"buffer_size": 4664,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKLowLevelContextData.cpp",
			"settings":
			{
				"buffer_size": 5608,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/FencedPool.h",
			"settings":
			{
				"buffer_size": 4321,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKComputeContext.cpp",
			"settings":
			{
				"buffer_size": 8062,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Utils/MathHelpersTests.cpp",
			"settings":
			{
				"buffer_size": 12262,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKRenderContext.cpp",
			"settings":
			{
				"buffer_size": 16727,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/BasePasses/RasterPass.cpp",
			"settings":
			{
				"buffer_size": 3029,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/BasePasses/RasterPass.h",
			"settings":
			{
				"buffer_size": 4410,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKResourceViews.cpp",
			"settings":
			{
				"buffer_size": 13407,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 3482,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/max/Desktop/gbuffer.py",
			"settings":
			{
				"buffer_size": 574,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/GBuffer/GBufferParams.slang",
			"settings":
			{
				"buffer_size": 2388,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Threading.cpp",
			"settings":
			{
				"buffer_size": 2799,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/TermColor.cpp",
			"settings":
			{
				"buffer_size": 3484,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/TermColor.h",
			"settings":
			{
				"buffer_size": 2499,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Threading.h",
			"settings":
			{
				"buffer_size": 3003,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "/***************************************************************************\n # Copyright (c) 2020, NVIDIA CORPORATION. All rights reserved.\n #\n # Redistribution and use in source and binary forms, with or without\n # modification, are permitted provided that the following conditions\n # are met:\n #  * Redistributions of source code must retain the above copyright\n #    notice, this list of conditions and the following disclaimer.\n #  * Redistributions in binary form must reproduce the above copyright\n #    notice, this list of conditions and the following disclaimer in the\n #    documentation and/or other materials provided with the distribution.\n #  * Neither the name of NVIDIA CORPORATION nor the names of its\n #    contributors may be used to endorse or promote products derived\n #    from this software without specific prior written permission.\n #\n # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY\n # EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n # IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n # PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n # CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n # EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n # PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n # PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n **************************************************************************/\n#include \"Utils/Math/MathConstants.slangh\"\n#include \"Scene/Material/MaterialDefines.slangh\"\n\nimport Scene.Scene;\nimport Scene.TextureSampler;\nimport Experimental.Scene.Material.MaterialShading;\nimport Experimental.Scene.Lights.EnvProbe;\nimport Utils.Sampling.SampleGenerator;\nimport Utils.Debug.PixelDebug;\nimport Utils.Math.BitTricks;\nimport Utils.Math.MathHelpers;\nimport BSDFViewerParams;\n\ncbuffer PerFrameCB\n{\n    BSDFViewerParams gParams;\n    EnvProbe gEnvProbe;\n}\n\nRWTexture2D<float4> gOutput;\nRWStructuredBuffer<PixelData> gPixelData;\n\nstatic const float3 kGroundPlaneColor = float3(0.05f);\n\nstruct SurfaceData\n{\n    ShadingData sd;\n\n    // Additional fields we want to inspect that are not part of Falcor's ShadingData.\n    float3 baseColor;\n    float3 wi;\n};\n\n\n/** Get normalized viewport coordinate.\n    The viewport is centered on the image with square aspect and height 1.0. The y-axis points down.\n    TODO: Change to a more standard definition.\n    \\return Viewport coordinate.\n*/\nfloat2 getViewportCoord(uint2 pixel)\n{\n    float2 p = pixel + float2(0.5f);\n    return (p - gParams.viewportOffset) * gParams.viewportScale;\n}\n\n/** Setup geometric frame of reference for BRDF slice.\n    \\param[in] uv Viewport coordinate in [0,1].\n    \\param[out] v Interpolated attributes for the point on the sphere.\n    \\param[out] viewDir View direction.\n    \\return Normalized incident direction (light vector).\n*/\nfloat3 calculateSliceGeometry(float2 uv, out VertexData v, out float3 viewDir)\n{\n    // Setup local surface frame as T,B,N (right-handed).\n    v.posW = float3(0, 0, 0);\n    v.normalW = float3(0, 0, 1);\n    v.bitangentW = float3(0, 1, 0);\n    v.texC = gParams.texCoords;\n    v.faceNormalW = v.normalW;\n\n    // Compute dot products.\n    // These are based on the axes in the 2D slice (theta_h, theta_d) with origin in lower-left corner.\n    // This is the same format as the slices in Burley et al. 2012, 2015.\n    float theta_h = uv.x * (M_PI / 2);\n    float theta_d = (1.f - uv.y) * (M_PI / 2);\n\n    float NdotH = cos(theta_h);\n    float HdotL = cos(theta_d);     // Note: HdotL = HdotV\n\n    // Place the H vector at (0,0,1) to start.\n    // Compute L, V that are mirrored about the yz-plane.\n    float3 L = float3(sqrt(1.f - HdotL * HdotL), 0, HdotL);\n    float3 V = float3(-L.x, 0.f, L.z);\n\n    // Rotate L, V about the x-axis by an angle theta_h.\n    float cos_h = NdotH;\n    float sin_h = sqrt(1 - NdotH * NdotH);\n    L = float3(L.x, cos_h * L.y - sin_h * L.z, sin_h * L.y + cos_h * L.z);\n    V = float3(V.x, cos_h * V.y - sin_h * V.z, sin_h * V.y + cos_h * V.z);\n\n    // Return vectors.\n    viewDir = V;\n    return normalize(L);\n}\n\n/** Ray-sphere intersection.\n    This function implements the standard analytic test and returns the closest hit.\n    \\param[in] rayOrigin Ray origin.\n    \\param[in] rayDir Ray direction (does not have to be normalized).\n    \\param[in] center Sphere center.\n    \\param[in] radius Sphere radius.\n    \\param[in] intersectionPos Position on the sphere for the closest intersection (if any).\n    \\return True if the ray intersects the sphere.\n*/\nbool raySphereIntersection(float3 rayOrigin, float3 rayDir, float3 center, float radius, out float3 intersectionPos)\n{\n    // The sphere equation is ||P-C||^2 = r^2 and the ray P = A+tB.\n    // Solve for minimum positive t to find the closest intersection.\n    float3 oc = rayOrigin - center;\n    float a = dot(rayDir, rayDir); // = 1.0 if direction is normalized\n    float b = 2.f * dot(rayDir, oc);\n    float c = dot(oc, oc) - radius * radius;\n    float discriminant = b * b - 4.f * a * c;\n\n    // Negative discriminant means ray missed sphere.\n    if (discriminant < 0.f) return false;\n\n    // There are two solutions t0 and t1, but one or both may be negative.\n    float t0 = -b - sqrt(discriminant);\n    float t1 = -b + sqrt(discriminant);\n    float tc = t0 < 0.f ? t1 : t0; // tc is the closest hit we care about\n    if (tc < 0.f) return false;\n\n    float t = tc / (2.f * a);\n    intersectionPos = rayOrigin + t * rayDir;\n    return true;\n}\n\n/** Calculate sphere geometry for the given viewport coordinate.\n    \\param[in] uv Viewport coordinate in [0,1].\n    \\param[out] v Interpolated attributes for the point on the sphere (if hit).\n    \\param[out] rayDir Ray direction for the camera ray (normalized).\n    \\return True if we're on the sphere.\n*/\nbool calculateSphereGeometry(float2 uv, out VertexData v, out float3 rayDir)\n{\n    const float2 ndc = float2(2.f * uv.x - 1.f, -2.f * uv.y + 1.f);\n\n    if (gParams.orthographicCamera)\n    {\n        // Calculate intersection with the unit sphere.\n        // The orthographic camera's viewport is +-1 units vertically so the sphere fits exactly.\n        float3 p = float3(ndc, 0);\n        float d = 1.f - p.x * p.x - p.y * p.y;\n        rayDir = float3(0, 0, -1);\n\n        if (d < 0.f) return false;\n        p.z = sqrt(d);\n        v.posW = p;\n    }\n    else // Projective camera\n    {\n        // Setup camera ray and calculate ray-sphere intersection.\n        float3 origin = { 0, 0, gParams.cameraDistance };\n        float3 target = float3(ndc * gParams.cameraViewportScale, 0);\n        rayDir = normalize(target - origin);\n\n        float3 p;\n        if (!raySphereIntersection(origin, rayDir, float3(0), 1.f, p)) return false;\n        v.posW = p;\n    }\n\n    // Setup surface attributes for the unit sphere.\n    v.normalW = v.posW;\n    v.bitangentW = perp_stark(v.normalW); // Make up a bitangent\n    v.faceNormalW = v.normalW;\n\n    if (gParams.useFixedTexCoords)\n    {\n        v.texC = gParams.texCoords;\n    }\n    else\n    {\n        // Compute texture coords using cylindrical mapping of the visible hemisphere.\n        // We place u=0 on the left side and and u=1 on the right, and v=0 at the bottom and v=1 at the top.\n        float3 p = v.posW;\n        float texU = atan2(p.z, -p.x) / M_PI;\n        float texV = acos(-p.y) / M_PI;\n        v.texC = float2(texU, texV);\n    }\n\n    return true;\n}\n\n/** Prepare SurfaceData struct with material parameters.\n    All unused fields are initialized to their default values.\n*/\nSurfaceData prepareMaterial(VertexData v, float3 viewDir)\n{\n    SurfaceData data = {};\n\n    if (gParams.useSceneMaterial)\n    {\n        // Setup Falcor's ShadingData based on scene material.\n        ExplicitLodTextureSampler lod = { 0.f };\n        data.sd = _prepareShadingData(v, gParams.materialID, gScene.materials[gParams.materialID], gScene.materialResources[gParams.materialID], viewDir, lod, gParams.useNormalMapping);\n\n        // Setup additional fields not currently available in ShadingData.\n        MaterialData md = gScene.getMaterial(gParams.materialID);\n        MaterialResources mr = gScene.materialResources[gParams.materialID];\n        data.baseColor = sampleTexture(mr.baseColor, mr.samplerState, v.texC, md.baseColor, EXTRACT_DIFFUSE_TYPE(md.flags), lod).rgb;\n    }\n    else\n    {\n        ShadingData sd = {};\n\n        // Set geometric parameters.\n        sd.posW = v.posW;\n        sd.uv = v.texC;\n        sd.V = normalize(viewDir);\n        sd.N = normalize(v.normalW);\n        sd.B = normalize(v.bitangentW - sd.N * (dot(v.bitangentW, sd.N)));\n        sd.T = normalize(cross(sd.B, sd.N));\n        sd.NdotV = dot(sd.N, sd.V);\n        sd.faceN = v.faceNormalW;\n        sd.frontFacing = dot(sd.V, sd.faceN) >= 0.f;\n        sd.doubleSided = false;\n\n        // Set material parameters.\n        // Calculate the specular reflectance for dielectrics from the IoR.\n        sd.IoR = gParams.IoR;\n        float f = (sd.IoR - 1.f) / (sd.IoR + 1.f);\n        float F0 = f * f;\n        sd.diffuse = lerp(gParams.baseColor.rgb, float3(0), gParams.metallic);\n        sd.specular = lerp(float3(F0), gParams.baseColor.rgb, gParams.metallic);\n        sd.linearRoughness = gParams.linearRoughness;\n        sd.ggxAlpha = sd.linearRoughness * sd.linearRoughness;\n        sd.metallic = gParams.metallic;\n\n        // Unused\n        sd.opacity = 1;\n        sd.occlusion = 1;\n\n        // Store outputs\n        data.sd = sd;\n        data.baseColor = gParams.baseColor;\n    }\n\n    return data;\n}\n\n/** Returns the color to use for background pixels.\n    \\param[in] uv Viewport coordinates.\n    \\param[in] dir Normalized ray direction.\n*/\nfloat3 evalBackground(float2 uv, float3 dir)\n{\n    if (gParams.useGroundPlane)\n    {\n        bool hitGround = gParams.orthographicCamera ? (uv.y >= 0.5f) : (dir.y < 0.f);\n        if (hitGround) return kGroundPlaneColor;\n    }\n    if (gParams.useDirectionalLight) return float3(0);\n\n    float3 L = gParams.useEnvMap ? evalEnvProbe(gEnvProbe, dir) : gParams.lightColor;\n    return L * gParams.lightIntensity;\n}\n\n/** Evaluates the incident lighting from a given direction.\n    If directional lighting is enabled, it can be assumed 'dir' is light's direction.\n*/\nfloat3 evalLighting(float3 dir)\n{\n    if (gParams.useGroundPlane && dir.y < 0.f)\n    {\n        return float3(0.f);\n    }\n\n    float3 L = gParams.useEnvMap ? evalEnvProbe(gEnvProbe, dir) : gParams.lightColor;\n    return L * gParams.lightIntensity;\n}\n\n/** Returns the BSDF lobe mask for the currently enabled lobes.\n*/\nuint getActiveLobes()\n{\n    uint lobes = 0;\n    if (gParams.enableDiffuse) lobes |= (uint)LobeType::DiffuseReflection;\n    if (gParams.enableSpecular) lobes |= (uint)LobeType::SpecularReflection;\n    // TODO: Viewer doesn't support transmission lobes yet\n    return lobes;\n}\n\n/** Evaluates the BSDF slice for a given viewport coordinate.\n    \\return Evaluated BSDF value.\n*/\nfloat3 evalBSDFSlice(float2 uv, inout SurfaceData data)\n{\n    // Calculate geometry and incident/outgoing directions.\n    VertexData v;\n    float3 viewDir;\n    float3 lightDir = calculateSliceGeometry(uv, v, viewDir);\n\n    // Setup shading data based on the current material.\n    data = prepareMaterial(v, viewDir);\n    data.wi = lightDir;\n\n    // Evaluate BRDF at this point.\n    float3 f = evalBSDFCosine(data.sd, data.wi, getActiveLobes());\n\n    // Remove cosine term if it's disabled in the viewer.\n    if (!gParams.applyNdotL)\n    {\n        float NdotL = dot(data.sd.N, data.wi);\n        f = NdotL > 0.f ? f / NdotL : float3(0);\n    }\n\n    return f;\n}\n\n/** Samples the BSDF to evaluate incident illumination.\n    This is done differently depending on the configuration.\n    \\param[in] sd Shading point data.\n    \\param[in] sg Sample generator.\n    \\param[out] s Generated sample. Only valid if true is returned.\n    \\return True if a sample was generated, false otherwise.\n*/\nbool generateBSDFSample(const ShadingData sd, inout SampleGenerator sg, out BSDFSample s)\n{\n    if (gParams.useDirectionalLight)\n    {\n        // With directional light, disable BSDF sampling and just return a sample in the light's direction.\n        s.wi = -normalize(gParams.lightDir);\n        s.weight = evalBSDFCosine(sd, s.wi);\n        s.pdf = 1.f;\n        return dot(sd.N, s.wi) > 0.f;\n    }\n    else\n    {\n        if (gParams.useBrdfSampling) return sampleBSDF(sd, sg, s);\n        else return sampleBSDF_Reference(sd, sg, s);\n    }\n}\n\n/** Evaluates the lit sphere for a given viewport coordinate.\n    The viewport shows an analytic sphere of the specified material at infinite distance.\n    When each pixel is evaluated using a random light direction and omnidirectional white light,\n    the result converges to the total reflectance (integral of BSDF times the dot(N,L) factor.\n    \\return Outgoing radiance value.\n*/\nfloat3 evalSphere(float2 uv, inout SurfaceData data, inout SampleGenerator sg)\n{\n    // Calculate the local surface frame.\n    VertexData v;\n    float3 rayDir;\n    if (!calculateSphereGeometry(uv, v, rayDir)) return evalBackground(uv, rayDir);\n\n    // Setup shading data based on the current material.\n    data = prepareMaterial(v, -rayDir);\n\n    float3 output = 0;\n    \n    BSDFSample s = {};\n    \n    if (generateBSDFSample(data.sd, sg, s)) {\n        data.wi = s.wi;\n        float3 L = evalLighting(s.wi);\n\n        // Use computed pdf explicitly (for debugging).\n        if (gParams.usePdf) {\n            output = L * evalBSDFCosine(data.sd, s.wi) / s.pdf;\n        } else {\n            output = L * s.weight;\n        }\n    }\n\n    return output;\n}\n\n/** BSDF viewer pass entry point.\n*/\n[numthreads(16, 16, 1)]\nvoid main(uint3 dispatchThreadID : SV_DispatchThreadID)\n{\n    const uint2 pixel = dispatchThreadID.xy;\n    if (any(pixel >= gParams.frameDim)) return;\n\n    printSetPixel(pixel);\n\n    SurfaceData data = {};\n    float3 output = 0;\n    float2 uv = getViewportCoord(pixel);\n\n    if (gParams.sliceViewer)\n    {\n        if (all(uv >= 0.f && uv < 1.f))\n        {\n            output = evalBSDFSlice(uv, data);\n        }\n    }\n    else\n    {\n        // Create pseudorandom number generator.\n        SampleGenerator sg = SampleGenerator.create(pixel, gParams.frameCount);\n        output = evalSphere(uv, data, sg);\n    }\n\n    // DEBUG\n    //if (gParams.debugSwitch0)\n    //{\n    //    if (sd.N.z < 0.f) output = float3(1, 0, 0);\n    //}\n\n    // Write output data.\n    gOutput[pixel] = float4(output, 1);\n\n    if (gParams.readback && all(pixel == gParams.selectedPixel))\n    {\n        PixelData px;\n        px.texC = data.sd.uv;\n        px.baseColor = data.baseColor;\n        px.diffuse = data.sd.diffuse;\n        px.specular = data.sd.specular;\n        px.linearRoughness = data.sd.linearRoughness;\n        px.metallic = data.sd.metallic;\n        px.N = data.sd.N;\n        px.T = data.sd.T;\n        px.B = data.sd.B;\n        px.wo = data.sd.V;\n        px.wi = data.wi;\n        px.output = output;\n        gPixelData[0] = px;\n    }\n}\n",
			"file": "build/bin/Shaders/RenderPasses/BSDFViewer/BSDFViewer.cs.slang",
			"file_size": 15202,
			"file_write_time": 132389801358286917,
			"settings":
			{
				"buffer_size": 15202,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/Utils/Utils.cpp",
			"settings":
			{
				"buffer_size": 2234,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/tools/render-test/cuda/cuda-compute-util.cpp",
			"settings":
			{
				"buffer_size": 53192,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VkSmartHandle.cpp",
			"settings":
			{
				"buffer_size": 6726,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKRootSignature.cpp",
			"settings":
			{
				"buffer_size": 8750,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/ProgramVersion.h",
			"settings":
			{
				"buffer_size": 10447,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/examples/model-viewer/main.cpp",
			"settings":
			{
				"buffer_size": 86920,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/ResourceViews.h",
			"settings":
			{
				"buffer_size": 9621,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/RootSignature.h",
			"settings":
			{
				"buffer_size": 6716,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/RootSignature.cpp",
			"settings":
			{
				"buffer_size": 8993,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKSampler.cpp",
			"settings":
			{
				"buffer_size": 2442,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/tools/gfx/render.h",
			"settings":
			{
				"buffer_size": 28476,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/FalcorVK.h",
			"settings":
			{
				"buffer_size": 5196,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Device.h",
			"settings":
			{
				"buffer_size": 11497,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/GpuMemoryHeap.h",
			"settings":
			{
				"buffer_size": 4090,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/GpuMemoryHeap.cpp",
			"settings":
			{
				"buffer_size": 5126,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKComputeStateObject.cpp",
			"settings":
			{
				"buffer_size": 2823,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKCopyContext.cpp",
			"settings":
			{
				"buffer_size": 22034,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKDescriptorPool.cpp",
			"settings":
			{
				"buffer_size": 5083,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKDescriptorSet.cpp",
			"settings":
			{
				"buffer_size": 7835,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKDevice.h",
			"settings":
			{
				"buffer_size": 3020,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKDeviceManager.cpp",
			"settings":
			{
				"buffer_size": 2844,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/DeviceManager.h",
			"settings":
			{
				"buffer_size": 3635,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKDevice.cpp",
			"settings":
			{
				"buffer_size": 28452,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKGpuFence.cpp",
			"settings":
			{
				"buffer_size": 10228,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKGpuTimer.cpp",
			"settings":
			{
				"buffer_size": 2646,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/D3D12/D3D12GpuFence.cpp",
			"settings":
			{
				"buffer_size": 3766,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/GpuFence.h",
			"settings":
			{
				"buffer_size": 3526,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKSmartHandle.h",
			"settings":
			{
				"buffer_size": 9756,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKState.cpp",
			"settings":
			{
				"buffer_size": 27538,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKTexture.cpp",
			"settings":
			{
				"buffer_size": 7857,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "falcor.sublime-project",
			"settings":
			{
				"buffer_size": 2453,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/vulkan/include/vulkan/vulkan.hpp",
			"settings":
			{
				"buffer_size": 2369181,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/usr/include/vulkan/vulkan.hpp",
			"settings":
			{
				"buffer_size": 4010350,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/vulkan/include/vulkan/vulkan_core.h",
			"settings":
			{
				"buffer_size": 451013,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Math/FalcorMath.h",
			"settings":
			{
				"buffer_size": 8456,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Framework.h",
			"settings":
			{
				"buffer_size": 13038,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/type.h",
			"settings":
			{
				"buffer_size": 6550,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Framework.cpp",
			"settings":
			{
				"buffer_size": 2253,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/CopyContext.h",
			"settings":
			{
				"buffer_size": 7677,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/VertexLayout.cpp",
			"settings":
			{
				"buffer_size": 1862,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/FalcorConfig.h",
			"settings":
			{
				"buffer_size": 2544,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderPassStandardFlags.h",
			"settings":
			{
				"buffer_size": 2479,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Falcor.h",
			"settings":
			{
				"buffer_size": 6959,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Debug/PixelDebug.h",
			"settings":
			{
				"buffer_size": 5769,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Image/Bitmap.h",
			"settings":
			{
				"buffer_size": 6060,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Image/Bitmap.cpp",
			"settings":
			{
				"buffer_size": 21119,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Scripting/ScriptBindings.h",
			"settings":
			{
				"buffer_size": 10241,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/max/Desktop/compos.py",
			"settings":
			{
				"buffer_size": 1267,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Scripting/Console.h",
			"settings":
			{
				"buffer_size": 2101,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Scripting/Scripting.h",
			"settings":
			{
				"buffer_size": 5726,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/DescriptorPool.h",
			"settings":
			{
				"buffer_size": 5596,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/DescriptorPool.cpp",
			"settings":
			{
				"buffer_size": 2683,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/State/GraphicsState.h",
			"settings":
			{
				"buffer_size": 10063,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/State/GraphicsState.cpp",
			"settings":
			{
				"buffer_size": 8458,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/State/ComputeState.cpp",
			"settings":
			{
				"buffer_size": 3405,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/ComputeStateObject.cpp",
			"settings":
			{
				"buffer_size": 2465,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/GpuTimer.cpp",
			"settings":
			{
				"buffer_size": 4479,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/State/ComputeState.h",
			"settings":
			{
				"buffer_size": 3782,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/State/StateGraph.h",
			"settings":
			{
				"buffer_size": 4323,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Raytracing/RtProgram/RtProgram.cpp",
			"settings":
			{
				"buffer_size": 7986,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Raytracing/RtProgram/RtProgram.h",
			"settings":
			{
				"buffer_size": 6561,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/AppData.h",
			"settings":
			{
				"buffer_size": 2896,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Platform/Linux/ProgressBarLinux.cpp",
			"settings":
			{
				"buffer_size": 5059,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/AppData.cpp",
			"settings":
			{
				"buffer_size": 5386,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/Extensions/Capture/CaptureTrigger.h",
			"settings":
			{
				"buffer_size": 3842,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Sample.cpp",
			"settings":
			{
				"buffer_size": 25053,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/VertexLayout.h",
			"settings":
			{
				"buffer_size": 7327,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/DeviceManager.cpp",
			"settings":
			{
				"buffer_size": 5194,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VkQueryHeap.cpp",
			"settings":
			{
				"buffer_size": 2779,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/D3D12/D3D12Device.cpp",
			"settings":
			{
				"buffer_size": 15156,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/DescriptorSet.h",
			"settings":
			{
				"buffer_size": 5856,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/DescriptorSet.cpp",
			"settings":
			{
				"buffer_size": 2618,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/ResourceViews.cpp",
			"settings":
			{
				"buffer_size": 5611,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "Falcor.sln",
			"settings":
			{
				"buffer_size": 19418,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Scene.h",
			"settings":
			{
				"buffer_size": 25118,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderGraphUI.h",
			"settings":
			{
				"buffer_size": 8554,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderGraph.h",
			"settings":
			{
				"buffer_size": 11413,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/ResourceCache.h",
			"settings":
			{
				"buffer_size": 5357,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/BasePasses/RasterScenePass.h",
			"settings":
			{
				"buffer_size": 4425,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Debug/DebugConsole.h",
			"settings":
			{
				"buffer_size": 4292,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/SceneBuilder.h",
			"settings":
			{
				"buffer_size": 11802,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Debug/debug.h",
			"settings":
			{
				"buffer_size": 2463,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "#ifndef __FALCOR_DEBUG_H__"
			}
		},
		{
			"file": "src/Falcor/Core/BufferTypes/ParameterBlock.h",
			"settings":
			{
				"buffer_size": 20403,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Scene.cpp",
			"settings":
			{
				"buffer_size": 49096,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Camera/CameraController.cpp",
			"settings":
			{
				"buffer_size": 9863,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Camera/Camera.cpp",
			"settings":
			{
				"buffer_size": 13365,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/D3D12/D3D12Resource.cpp",
			"settings":
			{
				"buffer_size": 6227,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"Package Control: ",
				"Package Control: Install Package"
			]
		],
		"width": 0.0
	},
	"console":
	{
		"height": 320.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/max/dev/Falcor",
		"/home/max/dev/Falcor/src",
		"/home/max/dev/Falcor/src/Mogwai",
		"/home/max/dev/Falcor/src/pxr",
		"/home/max/dev/Falcor/src/pxr/imaging",
		"/home/max/dev/Falcor/src/pxr/imaging/plugin",
		"/home/max/dev/Falcor/src/pxr/imaging/plugin/hdLava",
		"/home/max/dev/Falcor/src/RenderPasses",
		"/home/max/dev/Falcor/third_party"
	],
	"file_history":
	[
		"/home/max/dev/Falcor/src/USD/hdLava/context.h",
		"/home/max/dev/Falcor/src/USD/hdLava/config.h",
		"/home/max/dev/Falcor/src/USD/hdLava/config.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKDeviceManager.h",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Engine.h",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Engine.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKGpuFence.cpp",
		"/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Utils/AABB_VKTests.cs.slang",
		"/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Utils/AABB_VKTests.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKFbo.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKTexture.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKState.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKGraphicsStateObject.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKGpuTimer.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/API/GpuTimer.cpp",
		"/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Utils/HalfUtilsTests.cpp",
		"/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Slang/SlangMutatingTests.cpp",
		"/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Slang/WaveOps.cs.slang",
		"/home/max/dev/Falcor/src/Falcor/Scene/SceneBuilder.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/BufferTypes/ParameterBlock.cpp",
		"/home/max/dev/Falcor/src/Falcor/Data/LightProbes/20050806-03_hd.hdr",
		"/home/max/dev/Falcor/build/bin/Data/cube.obj",
		"/home/max/.config/sublime-text-3/Packages/SublimeLinter-gcc/miscellaneous/demo.cpp",
		"/home/max/.config/sublime-text-3/Packages/Package Control/Package Control.sublime-settings",
		"/home/max/Downloads/Telegram Desktop/scene.v001.usda",
		"/home/max/dev/blender/source/blender/draw/engines/eevee/eevee_occlusion_trace.c",
		"/home/max/dev/blender/release/scripts/startup/bl_ui/__init__.py",
		"/home/max/dev/blender/source/blender/draw/engines/eevee/shaders/common_fullscreen_embree_vert.glsl",
		"/home/max/dev/blender/source/blender/draw/engines/eevee/shaders/common_uniforms_embree_lib.glsl",
		"/home/max/dev/blender/source/blender/draw/engines/eevee/eevee_objects_map.h",
		"/home/max/dev/blender/source/blender/blenlib/intern/winstuff_dir.c",
		"/home/max/dev/blender/source/blender/draw/intern/draw_cache_extract.h",
		"/home/max/dev/blender/source/blender/draw/engines/workbench/workbench_engine.c",
		"/home/max/dev/blender/source/blender/draw/DRW_engine_types.h",
		"/home/max/dev/blender/source/blender/blenlib/BLI_hash.h",
		"/home/max/dev/blender/source/blender/blenlib/BLI_index_range.h",
		"/home/max/dev/blender/source/blender/bmesh/intern/bmesh_operators_private.h",
		"/home/max/dev/blender/source/blender/bmesh/intern/bmesh_operators.h",
		"/home/max/dev/blender/source/blender/python/intern/CMakeLists.txt",
		"/home/max/dev/blender/source/blender/blenlib/intern/BLI_ghash_utils.c",
		"/home/max/dev/blender/source/blender/blenlib/intern/BLI_ghash.c",
		"/home/max/dev/blender/source/blender/blenloader/intern/versioning_280.c",
		"/home/max/dev/blender/source/blender/draw/engines/eevee/shaders/ambient_occlusion_trace_lib.glsl",
		"/home/max/dev/bivis/src/blender/addon/ui.py",
		"/home/max/dev/bivis/src/blender/addon/presets.py",
		"/home/max/dev/bivis/src/blender/addon/properties.py",
		"/home/max/dev/bivis/src/blender/addon/osl.py",
		"/home/max/dev/bivis/src/blender/addon/operators.py",
		"/home/max/dev/bivis/src/blender/blender_python.cpp",
		"/home/max/dev/bivis/src/blender/addon/engine.py",
		"/home/max/dev/bivis/src/blender/addon/__init__.py",
		"/home/max/dev/bivis/src/blender/CMakeLists.txt",
		"/home/max/dev/blender/intern/CMakeLists.txt",
		"/home/max/dev/unity/scripts/mesh_smoother.cs",
		"/home/max/dev/unity/scripts/mesh_helper.cs",
		"/home/max/dev/fasta/src/fasta_lib/renderer.h",
		"/home/max/dev/fasta/CMakeLists.txt",
		"/home/max/dev/fasta/third_party/glad/include/KHR/khrplatform.h",
		"/home/max/dev/fasta/third_party/glad/include/glad/glad.h",
		"/home/max/dev/fasta/src/locomotive_lib/logging.h",
		"/home/max/dev/fasta/src/locomotive_lib/CMakeLists.txt",
		"/home/max/dev/fasta/src/locomotive_lib/logging.cpp",
		"/home/max/dev/fasta/src/xenon_lib/XN_RendererIPR.h",
		"/home/max/dev/fasta/src/xenon_py/CMakeLists.txt",
		"/home/max/dev/fasta/src/xenon_lib/XN_Shader.h",
		"/home/max/dev/fasta/src/xenon_lib/CMakeLists.txt",
		"/home/max/dev/fasta/src/xenon_cmd/CMakeLists.txt",
		"/home/max/dev/fasta/src/xenon_lib/XN_Mesh.h",
		"/home/max/dev/fasta/src/xenon_lib/XN_Shader.cpp",
		"/home/max/dev/fasta/src/xenon_lib/XN_GBuffer.cpp",
		"/home/max/dev/fasta/src/xenon_lib/XN_GBuffer.h",
		"/home/max/dev/fasta/src/xenon_lib/XN_Renderer.h",
		"/home/max/dev/fasta/src/xenon_lib/XN_Renderer.cpp",
		"/home/max/dev/fasta/src/xenon_cmd/fsquad.h",
		"/home/max/dev/fasta/src/xenon_cmd/xenon.cpp",
		"/home/max/dev/fasta/src/xenon_lib/XN_RendererIPR.cpp",
		"/home/max/projects/Xenon/xenon.sublime-project",
		"/home/max/projects/Xenon/src/ROP_Xenon.h",
		"/home/max/projects/Xenon/src/ROP_Xenon.cpp",
		"/home/max/projects/Xenon/makefile"
	],
	"find":
	{
		"height": 39.0
	},
	"find_in_files":
	{
		"height": 125.0,
		"where_history":
		[
			"/home/max/dev/RadeonProRenderUSD",
			"/home/max/dev/Falcor",
			"/home/max/dev/Falcor/src",
			"/home/max/dev/Falcor/src,/home/max/dev/Falcor/third_party/slang",
			"/home/max/dev/Falcor/src",
			"/home/max/dev/Falcor/src/Falcor",
			"/home/max/dev/Falcor/src/Falcor,/home/max/dev/Falcor/third_party/slang",
			"/home/max/dev/Falcor/src/Falcor",
			"/home/max/dev/Falcor/third_party/slang/source",
			"/home/max/dev/Falcor/src",
			"/home/max/dev/Falcor/third_party/slang",
			"/home/max/dev/Falcor/src",
			"/home/max/dev/Falcor/third_party/slang",
			"/home/max/dev/Falcor/src",
			"/home/max/dev/Falcor/Build",
			"/home/max/dev/Falcor/",
			"/home/max/dev/Falcor/src/",
			"/home/max/dev/Falcor/src/Mogwai",
			"/home/max/dev/Falcor/src/Falcor",
			"/home/max/dev/Falcor/",
			"/home/max/dev/Falcor/src/Falcor",
			"/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan",
			"/home/max/dev/Falcor/src",
			"/home/max/dev/Falcor/src/Falcor",
			"/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan",
			"/home/max/dev/Falcor"
		]
	},
	"find_state":
	{
		"case_sensitive": true,
		"find_history":
		[
			"HDRPR",
			"HdRpr",
			"GetRenderSettingDescriptors",
			"config.h",
			"HdOSPRay",
			"HdRpr",
			"HDRPR",
			"HdRpr",
			"HDRPR",
			"HdRpr",
			"copyHeaderForBuild",
			"HDRPR",
			"HdRpr",
			"HDRPR",
			"HdRpr",
			"HDRPR",
			"HdRpr",
			"OSPRay",
			"_sceneVersion",
			"_modelVersion",
			"_sceneVersion",
			"_renderer",
			"opp::Renderer",
			"OSPRay",
			"OSPRAY",
			"OSPRay",
			"OSPRAY",
			"HDOSPRAY",
			"_sceneVersion",
			"_sce",
			"_settingDescriptors",
			"_lastCommittedModelVersion",
			"_renderParam",
			"mRenderParam",
			"OSPRAY",
			"OSPRay",
			"OSPRAY",
			"OSPRay",
			"IRenderer",
			"onFrameRender",
			"executeActiveGraph",
			"updateGraph",
			"compile",
			"getPasses",
			"GraphicsVars::create",
			"ProgramVars(",
			"getDefaultParameterBlock",
			"setDefaultParameterBlock",
			"mpDefaultBlock",
			"ParameterBlock(",
			"ParameterBlock::create",
			"mGraphs",
			"gpFramework",
			"debugReportCallback",
			"singleton",
			"staticFunc_",
			"PYBIND11_MODULE",
			"loadRenderPassLibrary",
			"Device uid",
			"smartDevicePtr",
			"SharedPtr(this)",
			"mDeferredReleases",
			"setResourceSrvUavCommon",
			"Resource(",
			"ResourceViewInfo",
			"std::unordered_map",
			"std::unordered_map<Falcor::ResourceViewInfo",
			"resizeSwapChain",
			"getClientAreaSize",
			"ConstTextureSharedPtrRef",
			"VkDeviceData",
			"DeviceHandle",
			"createSurface",
			"allocateDeviceMemory",
			"mapBufferApi",
			"device",
			"mapBufferApi",
			"VkResource",
			"ResourceHandle",
			"mapBufferApi",
			"getBufferDataAlignment",
			"createDescriptorSetLayout",
			"_profileEvent",
			"getGlobalClock",
			"FrameRate",
			"UnitTestContext",
			"Scene* pScene",
			"LightCollection",
			"= delete",
			"GraphicsState",
			"gpDevice",
			"ResourceHandle",
			"gpDevice",
			"mpDevice",
			"kSwapChainBuffersCount",
			"gpDevice",
			"mpSwapChainFbos",
			"gpDevice",
			"IFramework",
			"IRenderer",
			"_pass",
			"dso",
			"D3D12_DRAW_INDEXED_ARGUMENTS",
			"createDrawList",
			"uavBarrier",
			"initGeomDesc",
			"PixelData",
			"ShadingData",
			"getCurrentBackBufferIndex",
			"vkAcquireNextImageKHR",
			"AMD_EXTENSIONS",
			"gl_BaryCoordSmoothAMD",
			"setDefines",
			"gl_BaryCoordSmoothAMD",
			"vulkan",
			"availableFor",
			"SV_Barycentrics",
			"GL_AMD_shader_explicit_vertex_parameter",
			"SV_Barycentrics",
			"SV_PrimitiveID",
			"SV_Barycentrics",
			"register(",
			"asTexture",
			"DebugConsole",
			"unordered_set",
			"gProfileEnabled",
			"FrameRate",
			"gProfileEnabled"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"HDLAVA",
			"HdLava",
			"HDLAVA",
			"HdLava",
			"HDLAVA",
			"HdLava",
			"HDLAVA",
			"HdLava",
			"HDLAVA",
			"HdLava",
			"HDLAVA",
			"HdLava",
			"Lava",
			"mSceneVersion",
			"mModelVersion",
			"mSceneVersion",
			"mRenderer",
			"Falcor::LavaRenderer",
			"Lava",
			"LAVA",
			"Lava",
			"LAVA",
			"mSceneVersion",
			"mSettingDescriptors",
			"mLastCommittedModelVersion",
			"mRenderParam",
			"LAVA",
			"Lava",
			"LAVA",
			"Lava",
			"mpDevice",
			"kPassTempLibSuffix",
			"PROJECT_DIR",
			"spData"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 217,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "src/Falcor/Core/API/D3D12/D3D12ResourceViews.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 18914,
						"regions":
						{
						},
						"selection":
						[
							[
								11151,
								11151
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4150.0,
						"zoom_level": 1.0
					},
					"stack_index": 301,
					"type": "text"
				},
				{
					"buffer": 1,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 810075,
						"regions":
						{
							"match":
							{
								"flags": 112,
								"regions":
								[
									[
										323,
										331
									],
									[
										397,
										405
									],
									[
										677,
										685
									],
									[
										753,
										761
									],
									[
										998,
										1006
									],
									[
										1088,
										1096
									],
									[
										1290,
										1298
									],
									[
										1351,
										1359
									],
									[
										1557,
										1565
									],
									[
										1611,
										1619
									],
									[
										1911,
										1919
									],
									[
										1978,
										1986
									],
									[
										2152,
										2160
									],
									[
										2216,
										2224
									],
									[
										2601,
										2609
									],
									[
										2938,
										2946
									],
									[
										3001,
										3009
									],
									[
										3166,
										3174
									],
									[
										3555,
										3563
									],
									[
										3713,
										3721
									],
									[
										3767,
										3775
									],
									[
										3989,
										3997
									],
									[
										4041,
										4049
									],
									[
										4111,
										4119
									],
									[
										4176,
										4184
									],
									[
										4346,
										4354
									],
									[
										4421,
										4429
									],
									[
										4484,
										4492
									],
									[
										4613,
										4621
									],
									[
										4678,
										4686
									],
									[
										4731,
										4739
									],
									[
										4874,
										4882
									],
									[
										4954,
										4962
									],
									[
										5021,
										5029
									],
									[
										5230,
										5238
									],
									[
										5340,
										5348
									],
									[
										5437,
										5445
									],
									[
										5631,
										5639
									],
									[
										5707,
										5715
									],
									[
										5770,
										5778
									],
									[
										5915,
										5923
									],
									[
										5996,
										6004
									],
									[
										6065,
										6073
									],
									[
										6194,
										6202
									],
									[
										6259,
										6267
									],
									[
										6312,
										6320
									],
									[
										6509,
										6517
									],
									[
										6584,
										6592
									],
									[
										6647,
										6655
									],
									[
										6836,
										6844
									],
									[
										6909,
										6917
									],
									[
										7295,
										7303
									],
									[
										7383,
										7391
									],
									[
										7596,
										7604
									],
									[
										7679,
										7687
									],
									[
										7750,
										7758
									],
									[
										7894,
										7902
									],
									[
										7935,
										7943
									],
									[
										8128,
										8136
									],
									[
										8243,
										8251
									],
									[
										8346,
										8354
									],
									[
										8479,
										8487
									],
									[
										8548,
										8556
									],
									[
										8605,
										8613
									],
									[
										8802,
										8810
									],
									[
										8875,
										8883
									],
									[
										8936,
										8944
									],
									[
										9207,
										9215
									],
									[
										9294,
										9302
									],
									[
										9443,
										9451
									],
									[
										9528,
										9536
									],
									[
										9601,
										9609
									],
									[
										9784,
										9792
									],
									[
										9853,
										9861
									],
									[
										9998,
										10006
									],
									[
										10079,
										10087
									],
									[
										10148,
										10156
									],
									[
										10291,
										10299
									],
									[
										10370,
										10378
									],
									[
										10437,
										10445
									],
									[
										10568,
										10576
									],
									[
										10635,
										10643
									],
									[
										10690,
										10698
									],
									[
										10825,
										10833
									],
									[
										10896,
										10904
									],
									[
										10955,
										10963
									],
									[
										11128,
										11136
									],
									[
										11195,
										11203
									],
									[
										11250,
										11258
									],
									[
										11481,
										11489
									],
									[
										11551,
										11559
									],
									[
										11674,
										11682
									],
									[
										11986,
										12001
									],
									[
										12194,
										12209
									],
									[
										12323,
										12338
									],
									[
										12341,
										12356
									],
									[
										12644,
										12659
									],
									[
										12814,
										12829
									],
									[
										13057,
										13072
									],
									[
										13300,
										13315
									],
									[
										13535,
										13550
									],
									[
										13879,
										13894
									],
									[
										14315,
										14330
									],
									[
										14554,
										14569
									],
									[
										14838,
										14853
									],
									[
										15055,
										15070
									],
									[
										15230,
										15245
									],
									[
										15664,
										15679
									],
									[
										16016,
										16031
									],
									[
										16252,
										16267
									],
									[
										16286,
										16301
									],
									[
										16359,
										16374
									],
									[
										16519,
										16534
									],
									[
										16859,
										16874
									],
									[
										17184,
										17199
									],
									[
										17218,
										17233
									],
									[
										17257,
										17272
									],
									[
										17274,
										17289
									],
									[
										17529,
										17544
									],
									[
										17737,
										17752
									],
									[
										17905,
										17920
									],
									[
										17939,
										17954
									],
									[
										18167,
										18182
									],
									[
										18201,
										18216
									],
									[
										18331,
										18346
									],
									[
										18365,
										18380
									],
									[
										18690,
										18705
									],
									[
										18753,
										18768
									],
									[
										19030,
										19045
									],
									[
										19093,
										19108
									],
									[
										19568,
										19583
									],
									[
										19885,
										19900
									],
									[
										20177,
										20192
									],
									[
										20366,
										20381
									],
									[
										20764,
										20779
									],
									[
										21036,
										21051
									],
									[
										21466,
										21481
									],
									[
										21502,
										21517
									],
									[
										21627,
										21642
									],
									[
										21654,
										21669
									],
									[
										21794,
										21809
									],
									[
										21924,
										21939
									],
									[
										22034,
										22049
									],
									[
										22150,
										22165
									],
									[
										22363,
										22378
									],
									[
										22563,
										22578
									],
									[
										22963,
										22978
									],
									[
										23201,
										23216
									],
									[
										23358,
										23373
									],
									[
										23611,
										23626
									],
									[
										24014,
										24029
									],
									[
										24293,
										24308
									],
									[
										24532,
										24547
									],
									[
										24715,
										24730
									],
									[
										25095,
										25110
									],
									[
										25282,
										25297
									],
									[
										25811,
										25826
									],
									[
										26039,
										26054
									],
									[
										26152,
										26167
									],
									[
										26283,
										26298
									],
									[
										26449,
										26464
									],
									[
										26858,
										26873
									],
									[
										27008,
										27023
									],
									[
										27422,
										27437
									],
									[
										27576,
										27591
									],
									[
										27856,
										27871
									],
									[
										27914,
										27929
									],
									[
										28261,
										28276
									],
									[
										28410,
										28425
									],
									[
										28464,
										28479
									],
									[
										28544,
										28559
									],
									[
										28621,
										28636
									],
									[
										28696,
										28711
									],
									[
										28803,
										28818
									],
									[
										28947,
										28962
									],
									[
										29127,
										29142
									],
									[
										29192,
										29207
									],
									[
										29435,
										29450
									],
									[
										29645,
										29660
									],
									[
										29807,
										29822
									],
									[
										30243,
										30258
									],
									[
										30682,
										30697
									],
									[
										31006,
										31021
									],
									[
										31375,
										31390
									],
									[
										31762,
										31777
									],
									[
										32159,
										32174
									],
									[
										32550,
										32565
									],
									[
										32793,
										32808
									],
									[
										33044,
										33059
									],
									[
										33300,
										33315
									],
									[
										33650,
										33665
									],
									[
										33817,
										33832
									],
									[
										33862,
										33877
									],
									[
										33923,
										33938
									],
									[
										33959,
										33974
									],
									[
										33977,
										33992
									],
									[
										34049,
										34064
									],
									[
										34147,
										34162
									],
									[
										34250,
										34265
									],
									[
										34271,
										34286
									],
									[
										34331,
										34346
									],
									[
										34469,
										34484
									],
									[
										34630,
										34645
									],
									[
										34939,
										34954
									],
									[
										35262,
										35277
									],
									[
										35524,
										35539
									],
									[
										35562,
										35577
									],
									[
										35898,
										35913
									],
									[
										35927,
										35942
									],
									[
										36385,
										36400
									],
									[
										36563,
										36578
									],
									[
										36938,
										36951
									],
									[
										37163,
										37176
									],
									[
										37558,
										37571
									],
									[
										37949,
										37962
									],
									[
										38221,
										38234
									],
									[
										38580,
										38593
									],
									[
										39037,
										39050
									],
									[
										39205,
										39218
									],
									[
										39429,
										39442
									],
									[
										39616,
										39629
									],
									[
										39778,
										39791
									],
									[
										39954,
										39967
									],
									[
										40137,
										40150
									],
									[
										40282,
										40295
									],
									[
										40521,
										40534
									],
									[
										40688,
										40701
									],
									[
										40851,
										40864
									],
									[
										41010,
										41023
									],
									[
										41328,
										41341
									],
									[
										41387,
										41400
									],
									[
										41446,
										41459
									],
									[
										41504,
										41517
									],
									[
										41800,
										41815
									],
									[
										41842,
										41857
									],
									[
										42051,
										42066
									],
									[
										42325,
										42340
									],
									[
										42536,
										42551
									],
									[
										42856,
										42871
									],
									[
										43051,
										43066
									],
									[
										43263,
										43278
									],
									[
										43549,
										43564
									],
									[
										43586,
										43601
									],
									[
										43767,
										43782
									],
									[
										43844,
										43859
									],
									[
										44187,
										44202
									],
									[
										44366,
										44381
									],
									[
										44391,
										44406
									],
									[
										44448,
										44463
									],
									[
										44473,
										44488
									],
									[
										44529,
										44544
									],
									[
										44897,
										44912
									],
									[
										45095,
										45110
									],
									[
										45333,
										45348
									],
									[
										45489,
										45504
									],
									[
										45734,
										45749
									],
									[
										46044,
										46059
									],
									[
										46354,
										46369
									],
									[
										46664,
										46679
									],
									[
										46973,
										46988
									],
									[
										47283,
										47298
									],
									[
										47514,
										47529
									],
									[
										47809,
										47824
									],
									[
										48260,
										48275
									],
									[
										48552,
										48567
									],
									[
										49003,
										49018
									],
									[
										49357,
										49372
									],
									[
										49619,
										49634
									],
									[
										50020,
										50035
									],
									[
										50390,
										50405
									],
									[
										50699,
										50714
									],
									[
										51021,
										51036
									],
									[
										51308,
										51323
									],
									[
										51633,
										51648
									],
									[
										51988,
										52003
									],
									[
										52334,
										52349
									],
									[
										52771,
										52786
									],
									[
										53103,
										53118
									],
									[
										53337,
										53352
									],
									[
										53603,
										53618
									],
									[
										53781,
										53796
									],
									[
										54075,
										54090
									],
									[
										54340,
										54355
									],
									[
										54693,
										54708
									],
									[
										55040,
										55049
									],
									[
										55183,
										55192
									],
									[
										55233,
										55242
									],
									[
										55247,
										55256
									],
									[
										55548,
										55557
									],
									[
										55741,
										55750
									],
									[
										55909,
										55918
									],
									[
										56098,
										56107
									],
									[
										56219,
										56228
									],
									[
										56500,
										56509
									],
									[
										56749,
										56758
									],
									[
										56763,
										56772
									],
									[
										56794,
										56803
									],
									[
										57021,
										57030
									],
									[
										57033,
										57042
									],
									[
										57253,
										57262
									],
									[
										57564,
										57573
									],
									[
										57860,
										57869
									],
									[
										58167,
										58176
									],
									[
										58358,
										58367
									],
									[
										58650,
										58659
									],
									[
										58750,
										58759
									],
									[
										58961,
										58970
									],
									[
										59113,
										59122
									],
									[
										59151,
										59160
									],
									[
										59328,
										59337
									],
									[
										59451,
										59460
									],
									[
										59713,
										59722
									],
									[
										59873,
										59882
									],
									[
										60299,
										60308
									],
									[
										60525,
										60534
									],
									[
										60842,
										60851
									],
									[
										61132,
										61146
									],
									[
										61647,
										61661
									],
									[
										62019,
										62033
									],
									[
										62296,
										62310
									],
									[
										62695,
										62709
									],
									[
										63003,
										63017
									],
									[
										63262,
										63276
									],
									[
										63451,
										63465
									],
									[
										63633,
										63647
									],
									[
										63892,
										63906
									],
									[
										64362,
										64376
									],
									[
										64682,
										64696
									],
									[
										64890,
										64904
									],
									[
										65224,
										65238
									],
									[
										65552,
										65566
									],
									[
										65853,
										65867
									],
									[
										66186,
										66200
									],
									[
										66463,
										66477
									],
									[
										66862,
										66876
									],
									[
										67170,
										67184
									],
									[
										67429,
										67443
									],
									[
										67618,
										67632
									],
									[
										67800,
										67814
									],
									[
										68059,
										68073
									],
									[
										68529,
										68543
									],
									[
										68849,
										68863
									],
									[
										69057,
										69071
									],
									[
										69391,
										69405
									],
									[
										69719,
										69733
									],
									[
										70020,
										70034
									],
									[
										70423,
										70437
									],
									[
										70731,
										70745
									],
									[
										70990,
										71004
									],
									[
										71179,
										71193
									],
									[
										71361,
										71375
									],
									[
										71620,
										71634
									],
									[
										72090,
										72104
									],
									[
										72410,
										72424
									],
									[
										72618,
										72632
									],
									[
										72952,
										72966
									],
									[
										73280,
										73294
									],
									[
										73580,
										73594
									],
									[
										73903,
										73917
									],
									[
										74162,
										74176
									],
									[
										74351,
										74365
									],
									[
										74533,
										74547
									],
									[
										74792,
										74806
									],
									[
										75262,
										75276
									],
									[
										75582,
										75596
									],
									[
										75790,
										75804
									],
									[
										76124,
										76138
									],
									[
										76452,
										76466
									],
									[
										76762,
										76775
									],
									[
										76864,
										76877
									],
									[
										77192,
										77217
									],
									[
										77411,
										77436
									],
									[
										77711,
										77736
									],
									[
										77996,
										78021
									],
									[
										78303,
										78328
									],
									[
										78347,
										78372
									],
									[
										78688,
										78713
									],
									[
										78940,
										78965
									],
									[
										79250,
										79275
									],
									[
										79535,
										79560
									],
									[
										79842,
										79867
									],
									[
										79886,
										79911
									],
									[
										80227,
										80252
									],
									[
										80479,
										80504
									],
									[
										80789,
										80814
									],
									[
										81075,
										81100
									],
									[
										81382,
										81407
									],
									[
										81426,
										81451
									],
									[
										81726,
										81748
									],
									[
										81976,
										81998
									],
									[
										82220,
										82242
									],
									[
										82482,
										82504
									],
									[
										82732,
										82754
									],
									[
										83136,
										83158
									],
									[
										83413,
										83435
									],
									[
										83667,
										83689
									],
									[
										83929,
										83951
									],
									[
										84179,
										84201
									],
									[
										84583,
										84605
									],
									[
										84833,
										84855
									],
									[
										85077,
										85099
									],
									[
										85339,
										85361
									],
									[
										85589,
										85611
									],
									[
										85995,
										86017
									],
									[
										86245,
										86267
									],
									[
										86489,
										86511
									],
									[
										86751,
										86773
									],
									[
										87001,
										87023
									],
									[
										87417,
										87429
									],
									[
										87823,
										87835
									],
									[
										88083,
										88095
									],
									[
										88292,
										88304
									],
									[
										88714,
										88728
									],
									[
										88904,
										88918
									],
									[
										89192,
										89206
									],
									[
										89482,
										89496
									],
									[
										89860,
										89874
									],
									[
										90169,
										90183
									],
									[
										90609,
										90623
									],
									[
										90818,
										90832
									],
									[
										91094,
										91108
									],
									[
										91453,
										91467
									],
									[
										91837,
										91851
									],
									[
										91984,
										91998
									],
									[
										92338,
										92352
									],
									[
										92709,
										92723
									],
									[
										92741,
										92755
									],
									[
										92982,
										92996
									],
									[
										93168,
										93182
									],
									[
										93184,
										93198
									],
									[
										93458,
										93472
									],
									[
										93689,
										93703
									],
									[
										94126,
										94140
									],
									[
										94450,
										94464
									],
									[
										94540,
										94554
									],
									[
										94761,
										94775
									],
									[
										95185,
										95199
									],
									[
										95468,
										95482
									],
									[
										95697,
										95711
									],
									[
										96035,
										96045
									],
									[
										96102,
										96112
									],
									[
										96177,
										96187
									],
									[
										96252,
										96262
									],
									[
										96327,
										96337
									],
									[
										96402,
										96412
									],
									[
										96800,
										96810
									],
									[
										97207,
										97217
									],
									[
										97579,
										97589
									],
									[
										97806,
										97816
									],
									[
										98110,
										98120
									],
									[
										98360,
										98370
									],
									[
										98689,
										98699
									],
									[
										99065,
										99075
									],
									[
										99425,
										99435
									],
									[
										99569,
										99579
									],
									[
										99766,
										99776
									],
									[
										99983,
										99993
									],
									[
										100162,
										100172
									],
									[
										100439,
										100449
									],
									[
										100634,
										100644
									],
									[
										100922,
										100932
									],
									[
										101141,
										101151
									],
									[
										101389,
										101399
									],
									[
										101667,
										101677
									],
									[
										101865,
										101875
									],
									[
										102167,
										102177
									],
									[
										102386,
										102396
									],
									[
										102615,
										102625
									],
									[
										102647,
										102657
									],
									[
										102769,
										102779
									],
									[
										102878,
										102888
									],
									[
										103115,
										103125
									],
									[
										103360,
										103370
									],
									[
										103565,
										103575
									],
									[
										103605,
										103615
									],
									[
										103727,
										103737
									],
									[
										103847,
										103857
									],
									[
										104076,
										104086
									],
									[
										104320,
										104330
									],
									[
										104352,
										104362
									],
									[
										104386,
										104396
									],
									[
										104426,
										104436
									],
									[
										104580,
										104590
									],
									[
										104716,
										104726
									],
									[
										104802,
										104812
									],
									[
										104907,
										104917
									],
									[
										105036,
										105046
									],
									[
										105095,
										105105
									],
									[
										105297,
										105307
									],
									[
										105530,
										105540
									],
									[
										105627,
										105637
									],
									[
										105851,
										105861
									],
									[
										105967,
										105977
									],
									[
										106138,
										106148
									],
									[
										106210,
										106220
									],
									[
										106289,
										106299
									],
									[
										106362,
										106372
									],
									[
										106500,
										106510
									],
									[
										106613,
										106623
									],
									[
										106695,
										106705
									],
									[
										106810,
										106820
									],
									[
										106891,
										106901
									],
									[
										106914,
										106924
									],
									[
										107116,
										107126
									],
									[
										107148,
										107158
									],
									[
										107180,
										107190
									],
									[
										107220,
										107230
									],
									[
										107452,
										107462
									],
									[
										107836,
										107846
									],
									[
										108265,
										108275
									],
									[
										108508,
										108518
									],
									[
										108547,
										108557
									],
									[
										108814,
										108824
									],
									[
										109089,
										109099
									],
									[
										109128,
										109138
									],
									[
										109277,
										109287
									],
									[
										109316,
										109326
									],
									[
										109521,
										109531
									],
									[
										109723,
										109733
									],
									[
										110016,
										110026
									],
									[
										110254,
										110264
									],
									[
										110316,
										110326
									],
									[
										110565,
										110575
									],
									[
										110627,
										110637
									],
									[
										110862,
										110872
									],
									[
										110885,
										110895
									],
									[
										111018,
										111028
									],
									[
										111042,
										111052
									],
									[
										111175,
										111185
									],
									[
										111332,
										111342
									],
									[
										111492,
										111502
									],
									[
										111627,
										111637
									],
									[
										111785,
										111795
									],
									[
										111924,
										111934
									],
									[
										112080,
										112090
									],
									[
										112229,
										112239
									],
									[
										112409,
										112419
									],
									[
										112600,
										112610
									],
									[
										112706,
										112716
									],
									[
										112867,
										112877
									],
									[
										113008,
										113018
									],
									[
										113053,
										113063
									],
									[
										113093,
										113103
									],
									[
										113138,
										113148
									],
									[
										113166,
										113176
									],
									[
										113483,
										113493
									],
									[
										113550,
										113560
									],
									[
										113625,
										113635
									],
									[
										113700,
										113710
									],
									[
										113775,
										113785
									],
									[
										113850,
										113860
									],
									[
										114248,
										114258
									],
									[
										114655,
										114665
									],
									[
										115027,
										115037
									],
									[
										115254,
										115264
									],
									[
										115558,
										115568
									],
									[
										115808,
										115818
									],
									[
										116137,
										116147
									],
									[
										116513,
										116523
									],
									[
										116873,
										116883
									],
									[
										117017,
										117027
									],
									[
										117214,
										117224
									],
									[
										117431,
										117441
									],
									[
										117610,
										117620
									],
									[
										117887,
										117897
									],
									[
										118082,
										118092
									],
									[
										118370,
										118380
									],
									[
										118589,
										118599
									],
									[
										118837,
										118847
									],
									[
										119115,
										119125
									],
									[
										119313,
										119323
									],
									[
										119615,
										119625
									],
									[
										119834,
										119844
									],
									[
										120063,
										120073
									],
									[
										120095,
										120105
									],
									[
										120217,
										120227
									],
									[
										120326,
										120336
									],
									[
										120563,
										120573
									],
									[
										120808,
										120818
									],
									[
										121013,
										121023
									],
									[
										121053,
										121063
									],
									[
										121175,
										121185
									],
									[
										121295,
										121305
									],
									[
										121524,
										121534
									],
									[
										121768,
										121778
									],
									[
										121800,
										121810
									],
									[
										121834,
										121844
									],
									[
										121874,
										121884
									],
									[
										122028,
										122038
									],
									[
										122164,
										122174
									],
									[
										122250,
										122260
									],
									[
										122355,
										122365
									],
									[
										122484,
										122494
									],
									[
										122543,
										122553
									],
									[
										122745,
										122755
									],
									[
										122978,
										122988
									],
									[
										123075,
										123085
									],
									[
										123299,
										123309
									],
									[
										123415,
										123425
									],
									[
										123586,
										123596
									],
									[
										123658,
										123668
									],
									[
										123737,
										123747
									],
									[
										123810,
										123820
									],
									[
										123948,
										123958
									],
									[
										124061,
										124071
									],
									[
										124143,
										124153
									],
									[
										124258,
										124268
									],
									[
										124339,
										124349
									],
									[
										124362,
										124372
									],
									[
										124564,
										124574
									],
									[
										124596,
										124606
									],
									[
										124628,
										124638
									],
									[
										124668,
										124678
									],
									[
										124900,
										124910
									],
									[
										125284,
										125294
									],
									[
										125713,
										125723
									],
									[
										125956,
										125966
									],
									[
										125995,
										126005
									],
									[
										126262,
										126272
									],
									[
										126537,
										126547
									],
									[
										126576,
										126586
									],
									[
										126725,
										126735
									],
									[
										126764,
										126774
									],
									[
										126969,
										126979
									],
									[
										127171,
										127181
									],
									[
										127464,
										127474
									],
									[
										127702,
										127712
									],
									[
										127764,
										127774
									],
									[
										128013,
										128023
									],
									[
										128075,
										128085
									],
									[
										128310,
										128320
									],
									[
										128333,
										128343
									],
									[
										128466,
										128476
									],
									[
										128490,
										128500
									],
									[
										128623,
										128633
									],
									[
										128780,
										128790
									],
									[
										128940,
										128950
									],
									[
										129075,
										129085
									],
									[
										129233,
										129243
									],
									[
										129372,
										129382
									],
									[
										129528,
										129538
									],
									[
										129677,
										129687
									],
									[
										129857,
										129867
									],
									[
										130048,
										130058
									],
									[
										130154,
										130164
									],
									[
										130315,
										130325
									],
									[
										130456,
										130466
									],
									[
										130501,
										130511
									],
									[
										130541,
										130551
									],
									[
										130586,
										130596
									],
									[
										130614,
										130624
									],
									[
										130893,
										130905
									],
									[
										131299,
										131311
									],
									[
										131559,
										131571
									],
									[
										131768,
										131780
									],
									[
										132199,
										132205
									],
									[
										132254,
										132260
									],
									[
										132571,
										132577
									],
									[
										132900,
										132906
									],
									[
										133228,
										133234
									],
									[
										133558,
										133564
									],
									[
										133886,
										133892
									],
									[
										134289,
										134295
									],
									[
										134660,
										134666
									],
									[
										134818,
										134824
									],
									[
										135190,
										135196
									],
									[
										135348,
										135354
									],
									[
										135621,
										135627
									],
									[
										135895,
										135901
									],
									[
										136169,
										136175
									],
									[
										136444,
										136450
									],
									[
										136809,
										136815
									],
									[
										137175,
										137181
									],
									[
										137491,
										137497
									],
									[
										137649,
										137655
									],
									[
										137966,
										137972
									],
									[
										138124,
										138130
									],
									[
										138431,
										138437
									],
									[
										138801,
										138807
									],
									[
										139169,
										139175
									],
									[
										139538,
										139544
									],
									[
										139997,
										140003
									],
									[
										140457,
										140463
									],
									[
										140869,
										140875
									],
									[
										141027,
										141033
									],
									[
										141438,
										141444
									],
									[
										141596,
										141602
									],
									[
										141989,
										141995
									],
									[
										142315,
										142321
									],
									[
										142639,
										142645
									],
									[
										142964,
										142970
									],
									[
										143362,
										143368
									],
									[
										143761,
										143767
									],
									[
										144111,
										144117
									],
									[
										144269,
										144275
									],
									[
										144618,
										144624
									],
									[
										144776,
										144782
									],
									[
										145154,
										145160
									],
									[
										145478,
										145484
									],
									[
										145801,
										145807
									],
									[
										146138,
										146144
									],
									[
										146433,
										146439
									],
									[
										146451,
										146457
									],
									[
										146519,
										146525
									],
									[
										146702,
										146708
									],
									[
										146935,
										146941
									],
									[
										147023,
										147029
									],
									[
										147400,
										147406
									],
									[
										147565,
										147571
									],
									[
										147960,
										147966
									],
									[
										147997,
										148003
									],
									[
										148147,
										148153
									],
									[
										148226,
										148232
									],
									[
										148474,
										148480
									],
									[
										148660,
										148666
									],
									[
										148891,
										148897
									],
									[
										149027,
										149033
									],
									[
										149106,
										149112
									],
									[
										149205,
										149211
									],
									[
										149311,
										149317
									],
									[
										149525,
										149531
									],
									[
										149761,
										149767
									],
									[
										150096,
										150102
									],
									[
										150253,
										150259
									],
									[
										150700,
										150706
									],
									[
										150976,
										150982
									],
									[
										151089,
										151095
									],
									[
										151340,
										151346
									],
									[
										151597,
										151603
									],
									[
										151808,
										151814
									],
									[
										151849,
										151855
									],
									[
										152022,
										152028
									],
									[
										152316,
										152322
									],
									[
										152549,
										152555
									],
									[
										152736,
										152742
									],
									[
										153136,
										153142
									],
									[
										153246,
										153252
									],
									[
										153349,
										153355
									],
									[
										153686,
										153692
									],
									[
										153791,
										153797
									],
									[
										154030,
										154036
									],
									[
										154338,
										154344
									],
									[
										154431,
										154437
									],
									[
										154535,
										154541
									],
									[
										154758,
										154764
									],
									[
										154856,
										154862
									],
									[
										155004,
										155010
									],
									[
										155119,
										155125
									],
									[
										155275,
										155281
									],
									[
										155456,
										155462
									],
									[
										155565,
										155571
									],
									[
										155689,
										155695
									],
									[
										155816,
										155822
									],
									[
										155952,
										155958
									],
									[
										155997,
										156003
									],
									[
										156164,
										156170
									],
									[
										156295,
										156301
									],
									[
										156635,
										156641
									],
									[
										156931,
										156937
									],
									[
										157060,
										157066
									],
									[
										157211,
										157217
									],
									[
										157657,
										157663
									],
									[
										157901,
										157907
									],
									[
										158393,
										158399
									],
									[
										158605,
										158611
									],
									[
										158808,
										158814
									],
									[
										159015,
										159021
									],
									[
										159072,
										159078
									],
									[
										159405,
										159411
									],
									[
										159642,
										159648
									],
									[
										159661,
										159667
									],
									[
										159982,
										159988
									],
									[
										160194,
										160200
									],
									[
										160286,
										160292
									],
									[
										160487,
										160493
									],
									[
										160925,
										160931
									],
									[
										161055,
										161061
									],
									[
										161298,
										161304
									],
									[
										161501,
										161507
									],
									[
										161519,
										161525
									],
									[
										161593,
										161599
									],
									[
										161686,
										161692
									],
									[
										161736,
										161742
									],
									[
										161829,
										161835
									],
									[
										161954,
										161960
									],
									[
										162178,
										162184
									],
									[
										162330,
										162336
									],
									[
										162480,
										162486
									],
									[
										162841,
										162847
									],
									[
										162977,
										162983
									],
									[
										163243,
										163249
									],
									[
										163694,
										163700
									],
									[
										163994,
										164000
									],
									[
										164337,
										164343
									],
									[
										164460,
										164466
									],
									[
										164623,
										164629
									],
									[
										165049,
										165055
									],
									[
										165337,
										165343
									],
									[
										165446,
										165452
									],
									[
										165558,
										165564
									],
									[
										165751,
										165757
									],
									[
										165807,
										165813
									],
									[
										166072,
										166078
									],
									[
										166281,
										166287
									],
									[
										166646,
										166652
									],
									[
										167005,
										167011
									],
									[
										167385,
										167391
									],
									[
										167827,
										167833
									],
									[
										168143,
										168149
									],
									[
										168340,
										168346
									],
									[
										168669,
										168675
									],
									[
										168813,
										168819
									],
									[
										168948,
										168954
									],
									[
										169169,
										169175
									],
									[
										169212,
										169218
									],
									[
										169515,
										169521
									],
									[
										169834,
										169840
									],
									[
										170018,
										170024
									],
									[
										170051,
										170057
									],
									[
										170247,
										170253
									],
									[
										170443,
										170449
									],
									[
										170601,
										170607
									],
									[
										170724,
										170730
									],
									[
										170991,
										170997
									],
									[
										171217,
										171223
									],
									[
										171526,
										171532
									],
									[
										171577,
										171583
									],
									[
										171654,
										171660
									],
									[
										171672,
										171678
									],
									[
										171700,
										171706
									],
									[
										171780,
										171786
									],
									[
										172106,
										172112
									],
									[
										172310,
										172316
									],
									[
										172581,
										172587
									],
									[
										172709,
										172715
									],
									[
										172907,
										172913
									],
									[
										172944,
										172950
									],
									[
										173130,
										173136
									],
									[
										173443,
										173449
									],
									[
										173523,
										173529
									],
									[
										173620,
										173626
									],
									[
										173638,
										173644
									],
									[
										173825,
										173831
									],
									[
										174034,
										174040
									],
									[
										174221,
										174227
									],
									[
										174502,
										174508
									],
									[
										174681,
										174687
									],
									[
										175009,
										175015
									],
									[
										175077,
										175083
									],
									[
										175258,
										175264
									],
									[
										175536,
										175542
									],
									[
										175622,
										175628
									],
									[
										175872,
										175878
									],
									[
										176023,
										176029
									],
									[
										176354,
										176360
									],
									[
										176419,
										176425
									],
									[
										176592,
										176598
									],
									[
										176658,
										176664
									],
									[
										176931,
										176937
									],
									[
										177003,
										177009
									],
									[
										177072,
										177078
									],
									[
										177146,
										177152
									],
									[
										177223,
										177229
									],
									[
										177295,
										177301
									],
									[
										177358,
										177364
									],
									[
										177439,
										177445
									],
									[
										177530,
										177536
									],
									[
										177621,
										177627
									],
									[
										177709,
										177715
									],
									[
										177874,
										177880
									],
									[
										177960,
										177966
									],
									[
										178053,
										178059
									],
									[
										178143,
										178149
									],
									[
										178239,
										178245
									],
									[
										178342,
										178348
									],
									[
										178513,
										178519
									],
									[
										178562,
										178568
									],
									[
										178721,
										178727
									],
									[
										178802,
										178808
									],
									[
										178914,
										178920
									],
									[
										179171,
										179177
									],
									[
										179337,
										179343
									],
									[
										179648,
										179654
									],
									[
										179760,
										179766
									],
									[
										179947,
										179953
									],
									[
										180188,
										180194
									],
									[
										180402,
										180408
									],
									[
										180658,
										180664
									],
									[
										180938,
										180944
									],
									[
										181154,
										181160
									],
									[
										181360,
										181366
									],
									[
										181410,
										181416
									],
									[
										181561,
										181567
									],
									[
										181682,
										181688
									],
									[
										181966,
										181972
									],
									[
										182190,
										182196
									],
									[
										182266,
										182272
									],
									[
										182425,
										182431
									],
									[
										182687,
										182693
									],
									[
										182869,
										182875
									],
									[
										183313,
										183319
									],
									[
										183553,
										183559
									],
									[
										183888,
										183894
									],
									[
										184108,
										184114
									],
									[
										184463,
										184469
									],
									[
										184736,
										184742
									],
									[
										184904,
										184910
									],
									[
										185037,
										185043
									],
									[
										185300,
										185306
									],
									[
										185485,
										185491
									],
									[
										185618,
										185624
									],
									[
										185886,
										185892
									],
									[
										186082,
										186088
									],
									[
										186215,
										186221
									],
									[
										186481,
										186487
									],
									[
										186666,
										186672
									],
									[
										186801,
										186807
									],
									[
										187073,
										187079
									],
									[
										187241,
										187247
									],
									[
										187366,
										187372
									],
									[
										187607,
										187613
									],
									[
										187803,
										187809
									],
									[
										188212,
										188218
									],
									[
										188587,
										188593
									],
									[
										189016,
										189022
									],
									[
										189424,
										189430
									],
									[
										189849,
										189855
									],
									[
										190293,
										190299
									],
									[
										190734,
										190740
									],
									[
										191125,
										191131
									],
									[
										191403,
										191409
									],
									[
										191862,
										191868
									],
									[
										192241,
										192247
									],
									[
										192706,
										192712
									],
									[
										193056,
										193062
									],
									[
										193473,
										193479
									],
									[
										193837,
										193843
									],
									[
										194307,
										194313
									],
									[
										194598,
										194604
									],
									[
										194947,
										194953
									],
									[
										195174,
										195180
									],
									[
										195479,
										195485
									],
									[
										195606,
										195612
									],
									[
										195768,
										195774
									],
									[
										196119,
										196125
									],
									[
										196271,
										196277
									],
									[
										196477,
										196483
									],
									[
										196801,
										196807
									],
									[
										197010,
										197016
									],
									[
										197287,
										197293
									],
									[
										197371,
										197377
									],
									[
										197418,
										197424
									],
									[
										197464,
										197470
									],
									[
										197495,
										197501
									],
									[
										197567,
										197573
									],
									[
										197691,
										197697
									],
									[
										197940,
										197946
									],
									[
										198106,
										198112
									],
									[
										198382,
										198388
									],
									[
										198569,
										198575
									],
									[
										198670,
										198676
									],
									[
										198758,
										198764
									],
									[
										198867,
										198873
									],
									[
										199097,
										199103
									],
									[
										199189,
										199195
									],
									[
										199411,
										199417
									],
									[
										199946,
										199952
									],
									[
										200268,
										200274
									],
									[
										200495,
										200501
									],
									[
										200765,
										200771
									],
									[
										201061,
										201067
									],
									[
										201172,
										201178
									],
									[
										201459,
										201465
									],
									[
										201586,
										201592
									],
									[
										201785,
										201791
									],
									[
										202093,
										202099
									],
									[
										202321,
										202327
									],
									[
										202619,
										202625
									],
									[
										202859,
										202865
									],
									[
										203066,
										203072
									],
									[
										203282,
										203288
									],
									[
										203310,
										203316
									],
									[
										203337,
										203343
									],
									[
										203587,
										203593
									],
									[
										203647,
										203653
									],
									[
										203774,
										203780
									],
									[
										203953,
										203959
									],
									[
										204187,
										204193
									],
									[
										204278,
										204284
									],
									[
										204513,
										204519
									],
									[
										204628,
										204634
									],
									[
										204685,
										204691
									],
									[
										204839,
										204845
									],
									[
										204848,
										204854
									],
									[
										204970,
										204976
									],
									[
										205045,
										205051
									],
									[
										205076,
										205082
									],
									[
										205290,
										205296
									],
									[
										205497,
										205503
									],
									[
										205558,
										205564
									],
									[
										205598,
										205604
									],
									[
										205769,
										205775
									],
									[
										205794,
										205800
									],
									[
										205992,
										205998
									],
									[
										206176,
										206182
									],
									[
										206248,
										206254
									],
									[
										206294,
										206300
									],
									[
										206367,
										206373
									],
									[
										206473,
										206479
									],
									[
										206551,
										206557
									],
									[
										207113,
										207119
									],
									[
										207592,
										207598
									],
									[
										207830,
										207836
									],
									[
										207968,
										207974
									],
									[
										208066,
										208072
									],
									[
										208409,
										208415
									],
									[
										208546,
										208552
									],
									[
										208682,
										208688
									],
									[
										208841,
										208847
									],
									[
										208869,
										208875
									],
									[
										208937,
										208943
									],
									[
										209011,
										209017
									],
									[
										209072,
										209078
									],
									[
										209151,
										209157
									],
									[
										209222,
										209228
									],
									[
										209299,
										209305
									],
									[
										209364,
										209370
									],
									[
										209386,
										209392
									],
									[
										209455,
										209461
									],
									[
										209728,
										209734
									],
									[
										209855,
										209861
									],
									[
										209951,
										209957
									],
									[
										210078,
										210084
									],
									[
										210169,
										210175
									],
									[
										210381,
										210387
									],
									[
										210561,
										210567
									],
									[
										210803,
										210809
									],
									[
										211023,
										211029
									],
									[
										211197,
										211203
									],
									[
										211362,
										211368
									],
									[
										211380,
										211386
									],
									[
										211399,
										211405
									],
									[
										211468,
										211474
									],
									[
										211586,
										211592
									],
									[
										211618,
										211624
									],
									[
										211868,
										211874
									],
									[
										211989,
										211995
									],
									[
										212380,
										212386
									],
									[
										212558,
										212564
									],
									[
										212710,
										212716
									],
									[
										212765,
										212771
									],
									[
										212878,
										212884
									],
									[
										212932,
										212938
									],
									[
										213052,
										213058
									],
									[
										213262,
										213268
									],
									[
										213424,
										213430
									],
									[
										213491,
										213497
									],
									[
										213642,
										213648
									],
									[
										213763,
										213769
									],
									[
										213894,
										213900
									],
									[
										214046,
										214052
									],
									[
										214067,
										214073
									],
									[
										214251,
										214257
									],
									[
										214318,
										214324
									],
									[
										214380,
										214386
									],
									[
										214623,
										214629
									],
									[
										214955,
										214961
									],
									[
										215221,
										215227
									],
									[
										215423,
										215429
									],
									[
										215519,
										215525
									],
									[
										215663,
										215669
									],
									[
										215810,
										215816
									],
									[
										215918,
										215924
									],
									[
										216258,
										216264
									],
									[
										216380,
										216386
									],
									[
										216644,
										216650
									],
									[
										216812,
										216818
									],
									[
										217154,
										217160
									],
									[
										217487,
										217493
									],
									[
										217578,
										217584
									],
									[
										217816,
										217822
									],
									[
										217882,
										217888
									],
									[
										218251,
										218257
									],
									[
										218487,
										218493
									],
									[
										218606,
										218612
									],
									[
										218694,
										218700
									],
									[
										218944,
										218950
									],
									[
										219030,
										219036
									],
									[
										219209,
										219215
									],
									[
										219310,
										219316
									],
									[
										219469,
										219475
									],
									[
										219551,
										219557
									],
									[
										219668,
										219674
									],
									[
										219745,
										219751
									],
									[
										219865,
										219871
									],
									[
										219952,
										219958
									],
									[
										220265,
										220271
									],
									[
										220415,
										220421
									],
									[
										220671,
										220677
									],
									[
										220851,
										220857
									],
									[
										221085,
										221091
									],
									[
										221402,
										221408
									],
									[
										221575,
										221581
									],
									[
										221888,
										221894
									],
									[
										222206,
										222212
									],
									[
										222379,
										222385
									],
									[
										222669,
										222675
									],
									[
										222884,
										222890
									],
									[
										222922,
										222928
									],
									[
										223061,
										223067
									],
									[
										223143,
										223149
									],
									[
										223320,
										223326
									],
									[
										223423,
										223429
									],
									[
										223624,
										223630
									],
									[
										223673,
										223679
									],
									[
										223884,
										223890
									],
									[
										223992,
										223998
									],
									[
										224013,
										224019
									],
									[
										224272,
										224278
									],
									[
										224330,
										224336
									],
									[
										224554,
										224560
									],
									[
										224608,
										224614
									],
									[
										224899,
										224905
									],
									[
										225019,
										225025
									],
									[
										225241,
										225247
									],
									[
										225340,
										225346
									],
									[
										225681,
										225687
									],
									[
										225754,
										225760
									],
									[
										225839,
										225845
									],
									[
										225875,
										225881
									],
									[
										226019,
										226025
									],
									[
										226092,
										226098
									],
									[
										226155,
										226161
									],
									[
										226235,
										226241
									],
									[
										226569,
										226575
									],
									[
										226690,
										226696
									],
									[
										226800,
										226806
									],
									[
										226923,
										226929
									],
									[
										227069,
										227075
									],
									[
										227132,
										227138
									],
									[
										227264,
										227270
									],
									[
										227329,
										227335
									],
									[
										227658,
										227664
									],
									[
										227739,
										227745
									],
									[
										227941,
										227947
									],
									[
										228011,
										228017
									],
									[
										228385,
										228391
									],
									[
										228755,
										228761
									],
									[
										229125,
										229131
									],
									[
										229551,
										229557
									],
									[
										229838,
										229844
									],
									[
										230110,
										230116
									],
									[
										230250,
										230256
									],
									[
										230651,
										230657
									],
									[
										230834,
										230840
									],
									[
										230912,
										230918
									],
									[
										231183,
										231189
									],
									[
										231578,
										231584
									],
									[
										231697,
										231703
									],
									[
										231847,
										231853
									],
									[
										232001,
										232007
									],
									[
										232179,
										232185
									],
									[
										232337,
										232343
									],
									[
										232644,
										232650
									],
									[
										232927,
										232933
									],
									[
										233212,
										233218
									],
									[
										233581,
										233587
									],
									[
										233845,
										233851
									],
									[
										234239,
										234245
									],
									[
										234474,
										234480
									],
									[
										234678,
										234684
									],
									[
										234970,
										234976
									],
									[
										235343,
										235349
									],
									[
										235476,
										235482
									],
									[
										235638,
										235644
									],
									[
										235939,
										235945
									],
									[
										236365,
										236371
									],
									[
										236662,
										236668
									],
									[
										236906,
										236912
									],
									[
										237078,
										237084
									],
									[
										237354,
										237360
									],
									[
										237624,
										237630
									],
									[
										237943,
										237949
									],
									[
										238308,
										238314
									],
									[
										238529,
										238535
									],
									[
										238753,
										238759
									],
									[
										238895,
										238901
									],
									[
										239105,
										239111
									],
									[
										239348,
										239354
									],
									[
										239441,
										239447
									],
									[
										239665,
										239671
									],
									[
										239755,
										239761
									],
									[
										239933,
										239939
									],
									[
										240217,
										240223
									],
									[
										240340,
										240346
									],
									[
										240566,
										240572
									],
									[
										240697,
										240703
									],
									[
										240979,
										240985
									],
									[
										241100,
										241106
									],
									[
										241324,
										241330
									],
									[
										241437,
										241443
									],
									[
										241527,
										241533
									],
									[
										241816,
										241822
									],
									[
										242008,
										242014
									],
									[
										242160,
										242166
									],
									[
										242291,
										242297
									],
									[
										242496,
										242502
									],
									[
										242786,
										242792
									],
									[
										243068,
										243074
									],
									[
										243295,
										243301
									],
									[
										243537,
										243543
									],
									[
										243818,
										243824
									],
									[
										244044,
										244050
									],
									[
										244280,
										244286
									],
									[
										244533,
										244539
									],
									[
										244609,
										244615
									],
									[
										244817,
										244823
									],
									[
										245164,
										245170
									],
									[
										245206,
										245212
									],
									[
										245570,
										245576
									],
									[
										245844,
										245850
									],
									[
										246067,
										246073
									],
									[
										246173,
										246179
									],
									[
										246239,
										246245
									],
									[
										246519,
										246525
									],
									[
										246635,
										246641
									],
									[
										246789,
										246795
									],
									[
										247116,
										247122
									],
									[
										247407,
										247413
									],
									[
										247425,
										247431
									],
									[
										247707,
										247713
									],
									[
										247751,
										247757
									],
									[
										247958,
										247964
									],
									[
										248160,
										248166
									],
									[
										248178,
										248184
									],
									[
										248193,
										248199
									],
									[
										248253,
										248259
									],
									[
										248522,
										248528
									],
									[
										248567,
										248573
									],
									[
										248770,
										248776
									],
									[
										249231,
										249237
									],
									[
										249623,
										249629
									],
									[
										250023,
										250029
									],
									[
										250363,
										250369
									],
									[
										250557,
										250563
									],
									[
										250893,
										250899
									],
									[
										251309,
										251315
									],
									[
										251421,
										251427
									],
									[
										251551,
										251557
									],
									[
										251627,
										251633
									],
									[
										251946,
										251952
									],
									[
										252041,
										252047
									],
									[
										252243,
										252249
									],
									[
										252521,
										252527
									],
									[
										252783,
										252789
									],
									[
										253064,
										253070
									],
									[
										253339,
										253345
									],
									[
										253585,
										253591
									],
									[
										253967,
										253973
									],
									[
										254163,
										254169
									],
									[
										254354,
										254360
									],
									[
										254732,
										254738
									],
									[
										255303,
										255309
									],
									[
										255686,
										255692
									],
									[
										255965,
										255971
									],
									[
										256057,
										256063
									],
									[
										256115,
										256121
									],
									[
										256201,
										256207
									],
									[
										256298,
										256304
									],
									[
										256562,
										256568
									],
									[
										256859,
										256865
									],
									[
										256957,
										256963
									],
									[
										257014,
										257020
									],
									[
										257080,
										257086
									],
									[
										257184,
										257190
									],
									[
										257361,
										257367
									],
									[
										257592,
										257598
									],
									[
										257716,
										257722
									],
									[
										257850,
										257856
									],
									[
										258140,
										258146
									],
									[
										258524,
										258530
									],
									[
										258807,
										258813
									],
									[
										259152,
										259158
									],
									[
										259380,
										259386
									],
									[
										259599,
										259605
									],
									[
										259699,
										259705
									],
									[
										259892,
										259898
									],
									[
										260111,
										260117
									],
									[
										260489,
										260495
									],
									[
										260605,
										260611
									],
									[
										260813,
										260819
									],
									[
										261092,
										261098
									],
									[
										261429,
										261435
									],
									[
										261688,
										261694
									],
									[
										261967,
										261973
									],
									[
										262083,
										262089
									],
									[
										262197,
										262203
									],
									[
										262456,
										262462
									],
									[
										262548,
										262554
									],
									[
										262649,
										262655
									],
									[
										262937,
										262943
									],
									[
										263310,
										263316
									],
									[
										263539,
										263545
									],
									[
										263819,
										263825
									],
									[
										263952,
										263958
									],
									[
										264131,
										264137
									],
									[
										264501,
										264507
									],
									[
										264632,
										264638
									],
									[
										264930,
										264936
									],
									[
										265223,
										265229
									],
									[
										265581,
										265587
									],
									[
										265993,
										265999
									],
									[
										266412,
										266418
									],
									[
										266491,
										266497
									],
									[
										266580,
										266586
									],
									[
										266636,
										266642
									],
									[
										266884,
										266890
									],
									[
										267148,
										267154
									],
									[
										267446,
										267452
									],
									[
										267633,
										267639
									],
									[
										267886,
										267892
									],
									[
										268078,
										268084
									],
									[
										268340,
										268346
									],
									[
										268666,
										268672
									],
									[
										268818,
										268824
									],
									[
										269181,
										269187
									],
									[
										269322,
										269328
									],
									[
										269567,
										269573
									],
									[
										269725,
										269731
									],
									[
										270047,
										270053
									],
									[
										270208,
										270214
									],
									[
										270624,
										270630
									],
									[
										271146,
										271152
									],
									[
										271475,
										271481
									],
									[
										271743,
										271749
									],
									[
										272085,
										272091
									],
									[
										272399,
										272405
									],
									[
										272746,
										272752
									],
									[
										273088,
										273094
									],
									[
										273580,
										273586
									],
									[
										273788,
										273794
									],
									[
										274216,
										274222
									],
									[
										274400,
										274406
									],
									[
										274780,
										274786
									],
									[
										274799,
										274805
									],
									[
										275029,
										275035
									],
									[
										275403,
										275409
									],
									[
										275754,
										275760
									],
									[
										275773,
										275779
									],
									[
										275947,
										275953
									],
									[
										275977,
										275983
									],
									[
										276214,
										276220
									],
									[
										276435,
										276441
									],
									[
										277012,
										277018
									],
									[
										277031,
										277037
									],
									[
										277079,
										277085
									],
									[
										277285,
										277291
									],
									[
										277410,
										277416
									],
									[
										277694,
										277700
									],
									[
										277831,
										277837
									],
									[
										277959,
										277965
									],
									[
										278137,
										278143
									],
									[
										278286,
										278292
									],
									[
										278448,
										278454
									],
									[
										278653,
										278659
									],
									[
										278797,
										278803
									],
									[
										279012,
										279018
									],
									[
										279027,
										279033
									],
									[
										279252,
										279258
									],
									[
										279466,
										279472
									],
									[
										279820,
										279826
									],
									[
										280120,
										280126
									],
									[
										280239,
										280245
									],
									[
										280381,
										280387
									],
									[
										280523,
										280529
									],
									[
										280727,
										280733
									],
									[
										281008,
										281014
									],
									[
										281301,
										281307
									],
									[
										281671,
										281677
									],
									[
										281964,
										281970
									],
									[
										282248,
										282254
									],
									[
										282380,
										282386
									],
									[
										282517,
										282523
									],
									[
										282801,
										282807
									],
									[
										282982,
										282988
									],
									[
										283353,
										283359
									],
									[
										283728,
										283734
									],
									[
										284157,
										284163
									],
									[
										284423,
										284429
									],
									[
										284806,
										284812
									],
									[
										285020,
										285026
									],
									[
										285258,
										285264
									],
									[
										285704,
										285710
									],
									[
										286021,
										286027
									],
									[
										286311,
										286317
									],
									[
										286552,
										286558
									],
									[
										286614,
										286620
									],
									[
										286664,
										286670
									],
									[
										286734,
										286740
									],
									[
										286892,
										286898
									],
									[
										287082,
										287088
									],
									[
										287257,
										287263
									],
									[
										287611,
										287617
									],
									[
										288185,
										288191
									],
									[
										288547,
										288553
									],
									[
										288742,
										288748
									],
									[
										288809,
										288815
									],
									[
										289124,
										289130
									],
									[
										289467,
										289473
									],
									[
										289734,
										289740
									],
									[
										290091,
										290097
									],
									[
										290442,
										290448
									],
									[
										290715,
										290721
									],
									[
										290919,
										290925
									],
									[
										291320,
										291326
									],
									[
										291781,
										291787
									],
									[
										292108,
										292114
									],
									[
										292527,
										292533
									],
									[
										292878,
										292884
									],
									[
										293181,
										293187
									],
									[
										293505,
										293511
									],
									[
										293890,
										293896
									],
									[
										294153,
										294159
									],
									[
										294354,
										294360
									],
									[
										294802,
										294808
									],
									[
										295092,
										295098
									],
									[
										295381,
										295387
									],
									[
										295568,
										295574
									],
									[
										295839,
										295845
									],
									[
										296188,
										296194
									],
									[
										296448,
										296454
									],
									[
										296708,
										296714
									],
									[
										297149,
										297155
									],
									[
										297461,
										297467
									],
									[
										297780,
										297786
									],
									[
										298122,
										298128
									],
									[
										298342,
										298348
									],
									[
										298774,
										298780
									],
									[
										299074,
										299080
									],
									[
										299315,
										299321
									],
									[
										299568,
										299574
									],
									[
										299916,
										299922
									],
									[
										300218,
										300224
									],
									[
										300391,
										300397
									],
									[
										300482,
										300488
									],
									[
										300489,
										300495
									],
									[
										300731,
										300737
									],
									[
										300774,
										300780
									],
									[
										300983,
										300989
									],
									[
										301156,
										301162
									],
									[
										301380,
										301386
									],
									[
										301574,
										301580
									],
									[
										301707,
										301713
									],
									[
										301969,
										301975
									],
									[
										302084,
										302090
									],
									[
										302330,
										302336
									],
									[
										302460,
										302466
									],
									[
										302549,
										302555
									],
									[
										302556,
										302562
									],
									[
										302680,
										302686
									],
									[
										302886,
										302892
									],
									[
										303077,
										303083
									],
									[
										303345,
										303351
									],
									[
										303597,
										303603
									],
									[
										303791,
										303797
									],
									[
										303935,
										303941
									],
									[
										304170,
										304176
									],
									[
										304347,
										304353
									],
									[
										304537,
										304543
									],
									[
										304590,
										304596
									],
									[
										304767,
										304773
									],
									[
										304881,
										304887
									],
									[
										305124,
										305130
									],
									[
										305306,
										305312
									],
									[
										305412,
										305418
									],
									[
										305419,
										305425
									],
									[
										305581,
										305587
									],
									[
										305765,
										305771
									],
									[
										305968,
										305974
									],
									[
										306175,
										306181
									],
									[
										306345,
										306351
									],
									[
										306592,
										306598
									],
									[
										306829,
										306835
									],
									[
										307031,
										307037
									],
									[
										307257,
										307263
									],
									[
										307518,
										307524
									],
									[
										307772,
										307778
									],
									[
										307928,
										307934
									],
									[
										308205,
										308211
									],
									[
										308385,
										308391
									],
									[
										308407,
										308413
									],
									[
										308414,
										308420
									],
									[
										308567,
										308573
									],
									[
										308728,
										308734
									],
									[
										308917,
										308923
									],
									[
										309151,
										309157
									],
									[
										309355,
										309361
									],
									[
										309593,
										309599
									],
									[
										309771,
										309777
									],
									[
										309980,
										309986
									],
									[
										310217,
										310223
									],
									[
										310310,
										310316
									],
									[
										310519,
										310525
									],
									[
										310655,
										310661
									],
									[
										310677,
										310683
									],
									[
										310684,
										310690
									],
									[
										310961,
										310967
									],
									[
										311089,
										311095
									],
									[
										311253,
										311259
									],
									[
										311428,
										311434
									],
									[
										311648,
										311654
									],
									[
										311886,
										311892
									],
									[
										311979,
										311985
									],
									[
										312174,
										312180
									],
									[
										312351,
										312357
									],
									[
										312441,
										312447
									],
									[
										312448,
										312454
									],
									[
										312667,
										312673
									],
									[
										312778,
										312784
									],
									[
										312989,
										312995
									],
									[
										313180,
										313186
									],
									[
										313330,
										313336
									],
									[
										313461,
										313467
									],
									[
										313718,
										313724
									],
									[
										313882,
										313888
									],
									[
										314150,
										314156
									],
									[
										314280,
										314286
									],
									[
										314393,
										314399
									],
									[
										314541,
										314547
									],
									[
										314715,
										314721
									],
									[
										315048,
										315054
									],
									[
										315325,
										315331
									],
									[
										315685,
										315691
									],
									[
										315878,
										315884
									],
									[
										316026,
										316032
									],
									[
										316295,
										316301
									],
									[
										316500,
										316506
									],
									[
										316647,
										316653
									],
									[
										316804,
										316810
									],
									[
										316925,
										316931
									],
									[
										317049,
										317055
									],
									[
										317189,
										317195
									],
									[
										317367,
										317373
									],
									[
										317557,
										317563
									],
									[
										317753,
										317759
									],
									[
										317899,
										317905
									],
									[
										318140,
										318146
									],
									[
										318331,
										318337
									],
									[
										318500,
										318506
									],
									[
										318656,
										318662
									],
									[
										318885,
										318891
									],
									[
										319014,
										319020
									],
									[
										319231,
										319237
									],
									[
										319355,
										319361
									],
									[
										319587,
										319593
									],
									[
										319807,
										319813
									],
									[
										320184,
										320190
									],
									[
										320453,
										320459
									],
									[
										320594,
										320600
									],
									[
										320674,
										320680
									],
									[
										320855,
										320861
									],
									[
										321059,
										321065
									],
									[
										321275,
										321281
									],
									[
										321432,
										321438
									],
									[
										321669,
										321675
									],
									[
										321864,
										321870
									],
									[
										321960,
										321966
									],
									[
										322086,
										322092
									],
									[
										322308,
										322314
									],
									[
										322472,
										322478
									],
									[
										322494,
										322500
									],
									[
										322501,
										322507
									],
									[
										322544,
										322550
									],
									[
										322670,
										322676
									],
									[
										322852,
										322858
									],
									[
										323005,
										323011
									],
									[
										323162,
										323168
									],
									[
										323361,
										323367
									],
									[
										323597,
										323603
									],
									[
										323701,
										323707
									],
									[
										323918,
										323924
									],
									[
										324118,
										324124
									],
									[
										324356,
										324362
									],
									[
										324616,
										324622
									],
									[
										324984,
										324990
									],
									[
										325164,
										325170
									],
									[
										325211,
										325217
									],
									[
										325569,
										325575
									],
									[
										325615,
										325621
									],
									[
										325952,
										325958
									],
									[
										326015,
										326021
									],
									[
										326389,
										326395
									],
									[
										326621,
										326627
									],
									[
										326871,
										326877
									],
									[
										327179,
										327185
									],
									[
										327476,
										327482
									],
									[
										327776,
										327782
									],
									[
										328079,
										328085
									],
									[
										328381,
										328387
									],
									[
										328605,
										328611
									],
									[
										328683,
										328689
									],
									[
										328782,
										328788
									],
									[
										328852,
										328858
									],
									[
										328919,
										328925
									],
									[
										328990,
										328996
									],
									[
										329055,
										329061
									],
									[
										329315,
										329321
									],
									[
										329619,
										329625
									],
									[
										330022,
										330028
									],
									[
										330416,
										330422
									],
									[
										330646,
										330652
									],
									[
										330743,
										330749
									],
									[
										330954,
										330960
									],
									[
										331051,
										331057
									],
									[
										331400,
										331406
									],
									[
										331794,
										331800
									],
									[
										331841,
										331847
									],
									[
										332415,
										332421
									],
									[
										332596,
										332602
									],
									[
										332633,
										332639
									],
									[
										332750,
										332756
									],
									[
										332901,
										332907
									],
									[
										333209,
										333215
									],
									[
										333550,
										333556
									],
									[
										333887,
										333893
									],
									[
										334014,
										334020
									],
									[
										334202,
										334208
									],
									[
										334344,
										334350
									],
									[
										334488,
										334494
									],
									[
										334606,
										334612
									],
									[
										334897,
										334903
									],
									[
										335184,
										335190
									],
									[
										335212,
										335218
									],
									[
										335636,
										335642
									],
									[
										335988,
										335994
									],
									[
										336242,
										336248
									],
									[
										336481,
										336487
									],
									[
										336524,
										336530
									],
									[
										337031,
										337037
									],
									[
										337071,
										337077
									],
									[
										337465,
										337471
									],
									[
										337701,
										337707
									],
									[
										337961,
										337967
									],
									[
										337998,
										338004
									],
									[
										338325,
										338331
									],
									[
										338702,
										338708
									],
									[
										338923,
										338929
									],
									[
										339149,
										339155
									],
									[
										339186,
										339192
									],
									[
										339513,
										339519
									],
									[
										339855,
										339861
									],
									[
										340079,
										340085
									],
									[
										340348,
										340354
									],
									[
										340372,
										340378
									],
									[
										340700,
										340706
									],
									[
										340886,
										340892
									],
									[
										341024,
										341030
									],
									[
										341031,
										341037
									],
									[
										341177,
										341183
									],
									[
										341379,
										341385
									],
									[
										341510,
										341516
									],
									[
										341517,
										341523
									],
									[
										341713,
										341719
									],
									[
										341911,
										341917
									],
									[
										342098,
										342104
									],
									[
										342245,
										342251
									],
									[
										342508,
										342514
									],
									[
										342679,
										342685
									],
									[
										342827,
										342833
									],
									[
										343019,
										343025
									],
									[
										343172,
										343178
									],
									[
										343330,
										343336
									],
									[
										343648,
										343654
									],
									[
										343877,
										343883
									],
									[
										343950,
										343956
									],
									[
										344114,
										344120
									],
									[
										344305,
										344311
									],
									[
										344378,
										344384
									],
									[
										344584,
										344590
									],
									[
										344754,
										344760
									],
									[
										344827,
										344833
									],
									[
										344994,
										345000
									],
									[
										345120,
										345126
									],
									[
										345193,
										345199
									],
									[
										345345,
										345351
									],
									[
										345580,
										345586
									],
									[
										345777,
										345783
									],
									[
										345937,
										345943
									],
									[
										346151,
										346157
									],
									[
										346333,
										346339
									],
									[
										346406,
										346412
									],
									[
										346490,
										346496
									],
									[
										346715,
										346721
									],
									[
										346912,
										346918
									],
									[
										347074,
										347080
									],
									[
										347288,
										347294
									],
									[
										347477,
										347483
									],
									[
										347542,
										347548
									],
									[
										347677,
										347683
									],
									[
										347895,
										347901
									],
									[
										348098,
										348104
									],
									[
										348171,
										348177
									],
									[
										348314,
										348320
									],
									[
										348578,
										348584
									],
									[
										348776,
										348782
									],
									[
										348847,
										348853
									],
									[
										348999,
										349005
									],
									[
										349268,
										349274
									],
									[
										349486,
										349492
									],
									[
										349751,
										349757
									],
									[
										349978,
										349984
									],
									[
										350031,
										350037
									],
									[
										350064,
										350070
									],
									[
										350104,
										350110
									],
									[
										350265,
										350271
									],
									[
										350318,
										350324
									],
									[
										350351,
										350357
									],
									[
										350398,
										350404
									],
									[
										350545,
										350551
									],
									[
										350598,
										350604
									],
									[
										350631,
										350637
									],
									[
										350678,
										350684
									],
									[
										350794,
										350800
									],
									[
										350846,
										350852
									],
									[
										350977,
										350983
									],
									[
										351052,
										351058
									],
									[
										351189,
										351195
									],
									[
										351379,
										351385
									],
									[
										351575,
										351581
									],
									[
										351641,
										351647
									],
									[
										351791,
										351797
									],
									[
										351987,
										351993
									],
									[
										352155,
										352161
									],
									[
										352165,
										352171
									],
									[
										352198,
										352204
									],
									[
										352231,
										352237
									],
									[
										352404,
										352410
									],
									[
										352417,
										352423
									],
									[
										352623,
										352629
									],
									[
										352828,
										352834
									],
									[
										353065,
										353071
									],
									[
										353293,
										353299
									],
									[
										353494,
										353500
									],
									[
										353501,
										353507
									],
									[
										353786,
										353792
									],
									[
										354092,
										354098
									],
									[
										354342,
										354348
									],
									[
										354600,
										354606
									],
									[
										354794,
										354800
									],
									[
										355098,
										355104
									],
									[
										355354,
										355360
									],
									[
										355514,
										355520
									],
									[
										355780,
										355786
									],
									[
										355945,
										355951
									],
									[
										356038,
										356044
									],
									[
										356045,
										356051
									],
									[
										356250,
										356256
									],
									[
										356436,
										356442
									],
									[
										356794,
										356800
									],
									[
										357051,
										357057
									],
									[
										357098,
										357104
									],
									[
										357336,
										357342
									],
									[
										357544,
										357550
									],
									[
										357591,
										357597
									],
									[
										357828,
										357834
									],
									[
										358070,
										358076
									],
									[
										358186,
										358192
									],
									[
										358445,
										358451
									],
									[
										358616,
										358622
									],
									[
										358685,
										358691
									],
									[
										358692,
										358698
									],
									[
										358886,
										358892
									],
									[
										359020,
										359026
									],
									[
										359260,
										359266
									],
									[
										359460,
										359466
									],
									[
										359700,
										359706
									],
									[
										359881,
										359887
									],
									[
										360029,
										360035
									],
									[
										360239,
										360245
									],
									[
										360576,
										360582
									],
									[
										360712,
										360718
									],
									[
										360835,
										360841
									],
									[
										361054,
										361060
									],
									[
										361259,
										361265
									],
									[
										361335,
										361341
									],
									[
										361554,
										361560
									],
									[
										361709,
										361715
									],
									[
										361718,
										361724
									],
									[
										361810,
										361816
									],
									[
										361967,
										361973
									],
									[
										362222,
										362228
									],
									[
										362461,
										362467
									],
									[
										362708,
										362714
									],
									[
										362952,
										362958
									],
									[
										363141,
										363147
									],
									[
										363250,
										363256
									],
									[
										363257,
										363263
									],
									[
										363488,
										363494
									],
									[
										363693,
										363699
									],
									[
										363942,
										363948
									],
									[
										364164,
										364170
									],
									[
										364403,
										364409
									],
									[
										364616,
										364622
									],
									[
										364872,
										364878
									],
									[
										365086,
										365092
									],
									[
										365303,
										365309
									],
									[
										365494,
										365500
									],
									[
										365741,
										365747
									],
									[
										365937,
										365943
									],
									[
										366097,
										366103
									],
									[
										366299,
										366305
									],
									[
										366464,
										366470
									],
									[
										366797,
										366803
									],
									[
										367024,
										367030
									],
									[
										367148,
										367154
									],
									[
										367345,
										367351
									],
									[
										367528,
										367534
									],
									[
										367633,
										367639
									],
									[
										367640,
										367646
									],
									[
										367842,
										367848
									],
									[
										368020,
										368026
									],
									[
										368283,
										368289
									],
									[
										368509,
										368515
									],
									[
										368745,
										368751
									],
									[
										368867,
										368873
									],
									[
										369080,
										369086
									],
									[
										369268,
										369274
									],
									[
										369450,
										369456
									],
									[
										369504,
										369510
									],
									[
										369727,
										369733
									],
									[
										369894,
										369900
									],
									[
										370120,
										370126
									],
									[
										370291,
										370297
									],
									[
										370442,
										370448
									],
									[
										370658,
										370664
									],
									[
										370855,
										370861
									],
									[
										371014,
										371020
									],
									[
										371195,
										371201
									],
									[
										371359,
										371365
									],
									[
										371502,
										371508
									],
									[
										371652,
										371658
									],
									[
										371825,
										371831
									],
									[
										371886,
										371892
									],
									[
										371893,
										371899
									],
									[
										372054,
										372060
									],
									[
										372205,
										372211
									],
									[
										372366,
										372372
									],
									[
										372544,
										372550
									],
									[
										372840,
										372846
									],
									[
										373049,
										373055
									],
									[
										373324,
										373330
									],
									[
										373543,
										373549
									],
									[
										373748,
										373754
									],
									[
										373928,
										373934
									],
									[
										374102,
										374108
									],
									[
										374339,
										374345
									],
									[
										374541,
										374547
									],
									[
										374778,
										374784
									],
									[
										374992,
										374998
									],
									[
										375228,
										375234
									],
									[
										375465,
										375471
									],
									[
										375678,
										375684
									],
									[
										375873,
										375879
									],
									[
										376050,
										376056
									],
									[
										376253,
										376259
									],
									[
										376456,
										376462
									],
									[
										376571,
										376577
									],
									[
										376698,
										376704
									],
									[
										376866,
										376872
									],
									[
										376993,
										376999
									],
									[
										377000,
										377006
									],
									[
										377142,
										377148
									],
									[
										377241,
										377247
									],
									[
										377371,
										377377
									],
									[
										377548,
										377554
									],
									[
										377733,
										377739
									],
									[
										377843,
										377849
									],
									[
										378081,
										378087
									],
									[
										378265,
										378271
									],
									[
										378494,
										378500
									],
									[
										378695,
										378701
									],
									[
										378924,
										378930
									],
									[
										379122,
										379128
									],
									[
										379262,
										379268
									],
									[
										379269,
										379275
									],
									[
										379404,
										379410
									],
									[
										379558,
										379564
									],
									[
										379709,
										379715
									],
									[
										379928,
										379934
									],
									[
										380100,
										380106
									],
									[
										380260,
										380266
									],
									[
										380514,
										380520
									],
									[
										380523,
										380529
									],
									[
										380655,
										380661
									],
									[
										381084,
										381090
									],
									[
										381439,
										381445
									],
									[
										381897,
										381903
									],
									[
										382242,
										382248
									],
									[
										382525,
										382531
									],
									[
										382859,
										382865
									],
									[
										382934,
										382940
									],
									[
										383326,
										383332
									],
									[
										383433,
										383439
									],
									[
										383782,
										383788
									],
									[
										384086,
										384092
									],
									[
										384324,
										384330
									],
									[
										384551,
										384557
									],
									[
										384729,
										384735
									],
									[
										385002,
										385008
									],
									[
										385229,
										385235
									],
									[
										385407,
										385413
									],
									[
										385804,
										385810
									],
									[
										386244,
										386250
									],
									[
										386513,
										386519
									],
									[
										386849,
										386855
									],
									[
										387186,
										387192
									],
									[
										387384,
										387390
									],
									[
										387637,
										387643
									],
									[
										387666,
										387672
									],
									[
										388192,
										388198
									],
									[
										388534,
										388540
									],
									[
										388827,
										388833
									],
									[
										388997,
										389003
									],
									[
										389080,
										389086
									],
									[
										389132,
										389138
									],
									[
										389262,
										389268
									],
									[
										389322,
										389328
									],
									[
										389636,
										389642
									],
									[
										389715,
										389721
									],
									[
										389756,
										389762
									],
									[
										389977,
										389983
									],
									[
										390056,
										390062
									],
									[
										390097,
										390103
									],
									[
										390240,
										390246
									],
									[
										390601,
										390607
									],
									[
										390758,
										390764
									],
									[
										390869,
										390875
									],
									[
										391324,
										391330
									],
									[
										391709,
										391715
									],
									[
										391929,
										391935
									],
									[
										391966,
										391972
									],
									[
										392015,
										392021
									],
									[
										392236,
										392242
									],
									[
										392380,
										392386
									],
									[
										392769,
										392775
									],
									[
										393045,
										393051
									],
									[
										393264,
										393270
									],
									[
										393695,
										393701
									],
									[
										393953,
										393959
									],
									[
										394280,
										394286
									],
									[
										394591,
										394597
									],
									[
										394783,
										394789
									],
									[
										394980,
										394986
									],
									[
										395028,
										395034
									],
									[
										395096,
										395102
									],
									[
										395489,
										395495
									],
									[
										395793,
										395799
									],
									[
										395910,
										395916
									],
									[
										396058,
										396064
									],
									[
										396216,
										396222
									],
									[
										396465,
										396471
									],
									[
										396687,
										396693
									],
									[
										397056,
										397062
									],
									[
										397081,
										397087
									],
									[
										397136,
										397142
									],
									[
										397163,
										397169
									],
									[
										397220,
										397226
									],
									[
										397247,
										397253
									],
									[
										397646,
										397652
									],
									[
										397891,
										397897
									],
									[
										398107,
										398113
									],
									[
										398422,
										398428
									],
									[
										398741,
										398747
									],
									[
										399140,
										399152
									],
									[
										399546,
										399558
									],
									[
										399806,
										399818
									],
									[
										400015,
										400027
									],
									[
										400450,
										400462
									],
									[
										400856,
										400868
									],
									[
										401116,
										401128
									],
									[
										401325,
										401337
									],
									[
										401762,
										401774
									],
									[
										402168,
										402180
									],
									[
										402428,
										402440
									],
									[
										402637,
										402649
									],
									[
										403072,
										403084
									],
									[
										403478,
										403490
									],
									[
										403738,
										403750
									],
									[
										403947,
										403959
									],
									[
										404372,
										404384
									],
									[
										404811,
										404823
									],
									[
										405081,
										405093
									],
									[
										405290,
										405302
									],
									[
										405710,
										405730
									],
									[
										406077,
										406097
									],
									[
										406441,
										406461
									],
									[
										406769,
										406789
									],
									[
										407246,
										407266
									],
									[
										407613,
										407633
									],
									[
										407977,
										407997
									],
									[
										408338,
										408358
									],
									[
										408825,
										408845
									],
									[
										409193,
										409213
									],
									[
										409560,
										409580
									],
									[
										409921,
										409941
									],
									[
										410408,
										410428
									],
									[
										410776,
										410796
									],
									[
										411143,
										411163
									],
									[
										411504,
										411524
									],
									[
										411991,
										412011
									],
									[
										412359,
										412379
									],
									[
										412726,
										412746
									],
									[
										413087,
										413107
									],
									[
										413544,
										413557
									],
									[
										413798,
										413811
									],
									[
										414246,
										414258
									],
									[
										414457,
										414469
									],
									[
										414697,
										414709
									],
									[
										415075,
										415087
									],
									[
										415243,
										415255
									],
									[
										415490,
										415502
									],
									[
										415850,
										415862
									],
									[
										416057,
										416069
									],
									[
										416266,
										416278
									],
									[
										416525,
										416537
									],
									[
										416655,
										416667
									],
									[
										416946,
										416958
									],
									[
										417325,
										417337
									],
									[
										417340,
										417352
									],
									[
										417641,
										417653
									],
									[
										417729,
										417741
									],
									[
										417813,
										417825
									],
									[
										417921,
										417933
									],
									[
										417960,
										417972
									],
									[
										418192,
										418204
									],
									[
										418335,
										418347
									],
									[
										418386,
										418398
									],
									[
										418444,
										418456
									],
									[
										418525,
										418537
									],
									[
										419109,
										419133
									],
									[
										419408,
										419432
									],
									[
										419687,
										419711
									],
									[
										420007,
										420031
									],
									[
										420325,
										420349
									],
									[
										420623,
										420647
									],
									[
										421129,
										421153
									],
									[
										421472,
										421496
									],
									[
										422008,
										422032
									],
									[
										422399,
										422423
									],
									[
										422715,
										422739
									],
									[
										423011,
										423035
									],
									[
										423301,
										423325
									],
									[
										423781,
										423798
									],
									[
										423851,
										423868
									],
									[
										424272,
										424289
									],
									[
										424305,
										424322
									],
									[
										424590,
										424607
									],
									[
										424636,
										424653
									],
									[
										425018,
										425035
									],
									[
										425312,
										425329
									],
									[
										425592,
										425609
									],
									[
										425804,
										425821
									],
									[
										426045,
										426062
									],
									[
										426463,
										426478
									],
									[
										426698,
										426713
									],
									[
										426913,
										426928
									],
									[
										427235,
										427250
									],
									[
										427579,
										427594
									],
									[
										427722,
										427737
									],
									[
										427986,
										428001
									],
									[
										428045,
										428060
									],
									[
										428258,
										428273
									],
									[
										428552,
										428567
									],
									[
										428792,
										428807
									],
									[
										429154,
										429169
									],
									[
										429397,
										429412
									],
									[
										429638,
										429653
									],
									[
										430072,
										430090
									],
									[
										430326,
										430344
									],
									[
										430438,
										430456
									],
									[
										430548,
										430566
									],
									[
										430658,
										430676
									],
									[
										430887,
										430905
									],
									[
										431272,
										431290
									],
									[
										431524,
										431542
									],
									[
										431888,
										431906
									],
									[
										432221,
										432239
									],
									[
										432531,
										432549
									],
									[
										432833,
										432851
									],
									[
										433037,
										433055
									],
									[
										433339,
										433357
									],
									[
										433588,
										433606
									],
									[
										433708,
										433726
									],
									[
										433773,
										433791
									],
									[
										434101,
										434119
									],
									[
										434484,
										434502
									],
									[
										434717,
										434735
									],
									[
										434975,
										434993
									],
									[
										435106,
										435124
									],
									[
										435296,
										435314
									],
									[
										435381,
										435399
									],
									[
										435569,
										435587
									],
									[
										435931,
										435949
									],
									[
										435994,
										436012
									],
									[
										436277,
										436295
									],
									[
										436496,
										436514
									],
									[
										436783,
										436801
									],
									[
										437095,
										437113
									],
									[
										437700,
										437718
									],
									[
										437950,
										437968
									],
									[
										438008,
										438026
									],
									[
										438225,
										438243
									],
									[
										438420,
										438438
									],
									[
										438665,
										438683
									],
									[
										438784,
										438802
									],
									[
										438897,
										438915
									],
									[
										439143,
										439161
									],
									[
										439469,
										439487
									],
									[
										439543,
										439561
									],
									[
										439931,
										439949
									],
									[
										440250,
										440268
									],
									[
										440513,
										440531
									],
									[
										440765,
										440783
									],
									[
										441101,
										441119
									],
									[
										441399,
										441417
									],
									[
										441741,
										441759
									],
									[
										441808,
										441826
									],
									[
										442272,
										442290
									],
									[
										442457,
										442475
									],
									[
										442872,
										442890
									],
									[
										443094,
										443112
									],
									[
										443505,
										443523
									],
									[
										443690,
										443708
									],
									[
										444112,
										444130
									],
									[
										444334,
										444352
									],
									[
										444620,
										444638
									],
									[
										444958,
										444976
									],
									[
										445214,
										445232
									],
									[
										445452,
										445470
									],
									[
										445842,
										445860
									],
									[
										446174,
										446192
									],
									[
										446615,
										446633
									],
									[
										446852,
										446870
									],
									[
										447150,
										447168
									],
									[
										447225,
										447243
									],
									[
										447415,
										447433
									],
									[
										447487,
										447505
									],
									[
										447696,
										447714
									],
									[
										447863,
										447881
									],
									[
										448262,
										448280
									],
									[
										448395,
										448413
									],
									[
										448532,
										448550
									],
									[
										448773,
										448791
									],
									[
										449042,
										449060
									],
									[
										449247,
										449265
									],
									[
										449436,
										449454
									],
									[
										449739,
										449757
									],
									[
										449867,
										449885
									],
									[
										450041,
										450059
									],
									[
										450298,
										450316
									],
									[
										450436,
										450454
									],
									[
										450659,
										450677
									],
									[
										450804,
										450822
									],
									[
										451159,
										451177
									],
									[
										451340,
										451358
									],
									[
										451590,
										451608
									],
									[
										452085,
										452101
									],
									[
										452109,
										452125
									],
									[
										452393,
										452409
									],
									[
										452654,
										452670
									],
									[
										452696,
										452712
									],
									[
										453175,
										453191
									],
									[
										453521,
										453537
									],
									[
										454054,
										454070
									],
									[
										454366,
										454382
									],
									[
										454478,
										454494
									],
									[
										454588,
										454604
									],
									[
										454698,
										454714
									],
									[
										454951,
										454967
									],
									[
										454981,
										454997
									],
									[
										455022,
										455038
									],
									[
										455278,
										455294
									],
									[
										455520,
										455536
									],
									[
										455755,
										455771
									],
									[
										455948,
										455964
									],
									[
										456147,
										456163
									],
									[
										456171,
										456187
									],
									[
										456502,
										456518
									],
									[
										456928,
										456944
									],
									[
										457434,
										457443
									],
									[
										457851,
										457860
									],
									[
										458089,
										458098
									],
									[
										458517,
										458526
									],
									[
										458829,
										458838
									],
									[
										459205,
										459214
									],
									[
										459608,
										459617
									],
									[
										459812,
										459821
									],
									[
										460039,
										460048
									],
									[
										460405,
										460414
									],
									[
										460574,
										460583
									],
									[
										460966,
										460975
									],
									[
										461404,
										461413
									],
									[
										461686,
										461695
									],
									[
										461955,
										461964
									],
									[
										462186,
										462195
									],
									[
										462437,
										462446
									],
									[
										462746,
										462755
									],
									[
										463055,
										463064
									],
									[
										463408,
										463417
									],
									[
										463849,
										463858
									],
									[
										463944,
										463953
									],
									[
										464103,
										464112
									],
									[
										464501,
										464510
									],
									[
										464733,
										464742
									],
									[
										464875,
										464884
									],
									[
										465279,
										465288
									],
									[
										465578,
										465587
									],
									[
										465808,
										465817
									],
									[
										466050,
										466059
									],
									[
										466300,
										466309
									],
									[
										466451,
										466460
									],
									[
										466962,
										466971
									],
									[
										467266,
										467275
									],
									[
										467475,
										467484
									],
									[
										467853,
										467862
									],
									[
										468318,
										468327
									],
									[
										468631,
										468640
									],
									[
										469023,
										469032
									],
									[
										469334,
										469343
									],
									[
										469689,
										469698
									],
									[
										469956,
										469965
									],
									[
										470172,
										470181
									],
									[
										470411,
										470420
									],
									[
										470845,
										470854
									],
									[
										471121,
										471130
									],
									[
										471539,
										471548
									],
									[
										471918,
										471927
									],
									[
										471971,
										471980
									],
									[
										472075,
										472084
									],
									[
										472349,
										472358
									],
									[
										472424,
										472433
									],
									[
										472882,
										472891
									],
									[
										472957,
										472966
									],
									[
										473159,
										473168
									],
									[
										473507,
										473516
									],
									[
										473536,
										473545
									],
									[
										473718,
										473727
									],
									[
										473758,
										473767
									],
									[
										474008,
										474017
									],
									[
										474048,
										474057
									],
									[
										474341,
										474350
									],
									[
										474415,
										474424
									],
									[
										474567,
										474576
									],
									[
										474751,
										474760
									],
									[
										474946,
										474955
									],
									[
										475305,
										475314
									],
									[
										475377,
										475386
									],
									[
										475665,
										475674
									],
									[
										475970,
										475979
									],
									[
										476123,
										476132
									],
									[
										476409,
										476418
									],
									[
										476549,
										476558
									],
									[
										476787,
										476796
									],
									[
										476994,
										477003
									],
									[
										477088,
										477097
									],
									[
										477294,
										477303
									],
									[
										477468,
										477477
									],
									[
										477648,
										477657
									],
									[
										477820,
										477829
									],
									[
										478013,
										478022
									],
									[
										478260,
										478269
									],
									[
										478677,
										478686
									],
									[
										478716,
										478725
									],
									[
										479309,
										479318
									],
									[
										479704,
										479713
									],
									[
										480336,
										480345
									],
									[
										481475,
										481484
									],
									[
										481928,
										481937
									],
									[
										482257,
										482266
									],
									[
										482461,
										482470
									],
									[
										482585,
										482594
									],
									[
										482776,
										482785
									],
									[
										482993,
										483002
									],
									[
										483219,
										483228
									],
									[
										483295,
										483304
									],
									[
										483608,
										483617
									],
									[
										483830,
										483839
									],
									[
										484119,
										484128
									],
									[
										484349,
										484358
									],
									[
										484726,
										484735
									],
									[
										485028,
										485037
									],
									[
										485251,
										485260
									],
									[
										485743,
										485752
									],
									[
										486176,
										486185
									],
									[
										486469,
										486478
									],
									[
										486847,
										486856
									],
									[
										487201,
										487210
									],
									[
										487606,
										487615
									],
									[
										487875,
										487884
									],
									[
										488033,
										488042
									],
									[
										488163,
										488172
									],
									[
										488510,
										488519
									],
									[
										488831,
										488840
									],
									[
										489162,
										489171
									],
									[
										489507,
										489530
									],
									[
										489769,
										489792
									],
									[
										489989,
										490012
									],
									[
										490294,
										490317
									],
									[
										490772,
										490789
									],
									[
										490798,
										490815
									],
									[
										491001,
										491018
									],
									[
										491189,
										491206
									],
									[
										491217,
										491234
									],
									[
										491279,
										491296
									],
									[
										491526,
										491543
									],
									[
										491555,
										491572
									],
									[
										491758,
										491775
									],
									[
										491959,
										491976
									],
									[
										491988,
										492005
									],
									[
										492156,
										492173
									],
									[
										492345,
										492362
									],
									[
										492373,
										492390
									],
									[
										492465,
										492482
									],
									[
										492698,
										492715
									],
									[
										492908,
										492925
									],
									[
										493421,
										493431
									],
									[
										493536,
										493546
									],
									[
										493726,
										493736
									],
									[
										494115,
										494125
									],
									[
										494230,
										494240
									],
									[
										494623,
										494644
									],
									[
										494934,
										494955
									],
									[
										494985,
										495006
									],
									[
										495230,
										495251
									],
									[
										495279,
										495300
									],
									[
										495324,
										495345
									],
									[
										495364,
										495385
									],
									[
										495410,
										495431
									],
									[
										495466,
										495487
									],
									[
										495507,
										495528
									],
									[
										495754,
										495775
									],
									[
										495809,
										495830
									],
									[
										495854,
										495875
									],
									[
										495914,
										495935
									],
									[
										495961,
										495982
									],
									[
										496009,
										496030
									],
									[
										496060,
										496081
									],
									[
										496110,
										496131
									],
									[
										496154,
										496175
									],
									[
										496203,
										496224
									],
									[
										496585,
										496606
									],
									[
										496640,
										496661
									],
									[
										496688,
										496709
									],
									[
										496739,
										496760
									],
									[
										497105,
										497126
									],
									[
										497160,
										497181
									],
									[
										497208,
										497229
									],
									[
										497259,
										497280
									],
									[
										497639,
										497660
									],
									[
										497694,
										497715
									],
									[
										497742,
										497763
									],
									[
										497800,
										497821
									],
									[
										498221,
										498242
									],
									[
										498269,
										498290
									],
									[
										498326,
										498347
									],
									[
										498849,
										498870
									],
									[
										498897,
										498918
									],
									[
										498954,
										498975
									],
									[
										499659,
										499670
									],
									[
										499873,
										499884
									],
									[
										500315,
										500324
									],
									[
										500752,
										500761
									],
									[
										501257,
										501276
									],
									[
										501484,
										501503
									],
									[
										501675,
										501694
									],
									[
										501872,
										501891
									],
									[
										502085,
										502104
									],
									[
										502318,
										502337
									],
									[
										502355,
										502374
									],
									[
										502479,
										502498
									],
									[
										502532,
										502551
									],
									[
										502732,
										502751
									],
									[
										502804,
										502823
									],
									[
										502982,
										503001
									],
									[
										503293,
										503304
									],
									[
										503442,
										503453
									],
									[
										503615,
										503626
									],
									[
										503890,
										503901
									],
									[
										504386,
										504397
									],
									[
										504752,
										504763
									],
									[
										505014,
										505025
									],
									[
										505276,
										505287
									],
									[
										505642,
										505653
									],
									[
										506035,
										506046
									],
									[
										506337,
										506348
									],
									[
										506720,
										506731
									],
									[
										507038,
										507049
									],
									[
										507101,
										507112
									],
									[
										507247,
										507258
									],
									[
										507288,
										507299
									],
									[
										507497,
										507508
									],
									[
										507775,
										507786
									],
									[
										507958,
										507969
									],
									[
										508171,
										508182
									],
									[
										508535,
										508546
									],
									[
										508836,
										508847
									],
									[
										509089,
										509100
									],
									[
										509337,
										509348
									],
									[
										509429,
										509440
									],
									[
										509663,
										509674
									],
									[
										510074,
										510085
									],
									[
										510368,
										510379
									],
									[
										510659,
										510670
									],
									[
										510694,
										510705
									],
									[
										510817,
										510828
									],
									[
										511156,
										511167
									],
									[
										511397,
										511408
									],
									[
										511751,
										511762
									],
									[
										512019,
										512030
									],
									[
										512339,
										512350
									],
									[
										512846,
										512857
									],
									[
										513096,
										513107
									],
									[
										513225,
										513236
									],
									[
										513367,
										513378
									],
									[
										513627,
										513638
									],
									[
										513867,
										513878
									],
									[
										514037,
										514048
									],
									[
										514269,
										514280
									],
									[
										514635,
										514646
									],
									[
										514964,
										514975
									],
									[
										515156,
										515167
									],
									[
										515383,
										515394
									],
									[
										515666,
										515677
									],
									[
										515927,
										515938
									],
									[
										516143,
										516154
									],
									[
										516445,
										516456
									],
									[
										516594,
										516605
									],
									[
										516767,
										516778
									],
									[
										517042,
										517053
									],
									[
										517538,
										517549
									],
									[
										517904,
										517915
									],
									[
										518166,
										518177
									],
									[
										518428,
										518439
									],
									[
										518794,
										518805
									],
									[
										519187,
										519198
									],
									[
										519489,
										519500
									],
									[
										519872,
										519883
									],
									[
										520190,
										520201
									],
									[
										520253,
										520264
									],
									[
										520399,
										520410
									],
									[
										520440,
										520451
									],
									[
										520649,
										520660
									],
									[
										520927,
										520938
									],
									[
										521110,
										521121
									],
									[
										521323,
										521334
									],
									[
										521687,
										521698
									],
									[
										521988,
										521999
									],
									[
										522241,
										522252
									],
									[
										522489,
										522500
									],
									[
										522581,
										522592
									],
									[
										522815,
										522826
									],
									[
										523226,
										523237
									],
									[
										523520,
										523531
									],
									[
										523811,
										523822
									],
									[
										523846,
										523857
									],
									[
										523969,
										523980
									],
									[
										524308,
										524319
									],
									[
										524549,
										524560
									],
									[
										524903,
										524914
									],
									[
										525171,
										525182
									],
									[
										525491,
										525502
									],
									[
										525998,
										526009
									],
									[
										526248,
										526259
									],
									[
										526377,
										526388
									],
									[
										526519,
										526530
									],
									[
										526779,
										526790
									],
									[
										527019,
										527030
									],
									[
										527189,
										527200
									],
									[
										527421,
										527432
									],
									[
										527787,
										527798
									],
									[
										528116,
										528127
									],
									[
										528308,
										528319
									],
									[
										528535,
										528546
									],
									[
										528818,
										528829
									],
									[
										529079,
										529090
									],
									[
										529295,
										529306
									],
									[
										529718,
										529725
									],
									[
										529839,
										529846
									],
									[
										529856,
										529863
									],
									[
										530077,
										530084
									],
									[
										530167,
										530174
									],
									[
										530329,
										530336
									],
									[
										530563,
										530570
									],
									[
										530720,
										530727
									],
									[
										530820,
										530827
									],
									[
										531179,
										531186
									],
									[
										531300,
										531307
									],
									[
										531521,
										531528
									],
									[
										531587,
										531594
									],
									[
										531628,
										531635
									],
									[
										531800,
										531807
									],
									[
										531845,
										531852
									],
									[
										531888,
										531895
									],
									[
										531958,
										531965
									],
									[
										532029,
										532036
									],
									[
										532139,
										532146
									],
									[
										532229,
										532236
									],
									[
										532629,
										532636
									],
									[
										532735,
										532742
									],
									[
										532944,
										532951
									],
									[
										533164,
										533171
									],
									[
										533306,
										533313
									],
									[
										533499,
										533506
									],
									[
										533538,
										533545
									],
									[
										533688,
										533695
									],
									[
										533731,
										533738
									],
									[
										533896,
										533903
									],
									[
										534243,
										534250
									],
									[
										534449,
										534456
									],
									[
										534490,
										534497
									],
									[
										534665,
										534672
									],
									[
										534707,
										534714
									],
									[
										534778,
										534785
									],
									[
										534806,
										534813
									],
									[
										534820,
										534827
									],
									[
										535086,
										535093
									],
									[
										535253,
										535260
									],
									[
										535281,
										535288
									],
									[
										535465,
										535472
									],
									[
										535512,
										535519
									],
									[
										535703,
										535710
									],
									[
										535745,
										535752
									],
									[
										535934,
										535941
									],
									[
										536042,
										536049
									],
									[
										536252,
										536259
									],
									[
										536327,
										536334
									],
									[
										536366,
										536373
									],
									[
										536469,
										536476
									],
									[
										536617,
										536624
									],
									[
										536977,
										536984
									],
									[
										537054,
										537061
									],
									[
										537122,
										537129
									],
									[
										537161,
										537168
									],
									[
										537222,
										537229
									],
									[
										537257,
										537264
									],
									[
										537423,
										537430
									],
									[
										537474,
										537481
									],
									[
										537670,
										537677
									],
									[
										537718,
										537725
									],
									[
										537890,
										537897
									],
									[
										538034,
										538041
									],
									[
										538244,
										538251
									],
									[
										538260,
										538267
									],
									[
										538491,
										538498
									],
									[
										538507,
										538514
									],
									[
										538744,
										538751
									],
									[
										538999,
										539006
									],
									[
										539041,
										539048
									],
									[
										539238,
										539245
									],
									[
										539440,
										539447
									],
									[
										539529,
										539536
									],
									[
										539877,
										539884
									],
									[
										540169,
										540176
									],
									[
										540237,
										540244
									],
									[
										540482,
										540489
									],
									[
										540661,
										540668
									],
									[
										540759,
										540766
									],
									[
										541099,
										541121
									],
									[
										541459,
										541481
									],
									[
										541765,
										541787
									],
									[
										541968,
										541990
									],
									[
										542123,
										542145
									],
									[
										542475,
										542497
									],
									[
										542766,
										542788
									],
									[
										543522,
										543544
									],
									[
										543922,
										543944
									],
									[
										544333,
										544355
									],
									[
										544671,
										544693
									],
									[
										545031,
										545053
									],
									[
										545337,
										545359
									],
									[
										545540,
										545562
									],
									[
										545695,
										545717
									],
									[
										546047,
										546069
									],
									[
										546338,
										546360
									],
									[
										547094,
										547116
									],
									[
										547494,
										547516
									],
									[
										547905,
										547927
									],
									[
										548243,
										548265
									],
									[
										548603,
										548625
									],
									[
										548909,
										548931
									],
									[
										549112,
										549134
									],
									[
										549267,
										549289
									],
									[
										549619,
										549641
									],
									[
										549910,
										549932
									],
									[
										550666,
										550688
									],
									[
										551066,
										551088
									],
									[
										551477,
										551499
									],
									[
										551814,
										551829
									],
									[
										552231,
										552246
									],
									[
										552595,
										552610
									],
									[
										553034,
										553049
									],
									[
										553335,
										553350
									],
									[
										553415,
										553430
									],
									[
										553629,
										553644
									],
									[
										554092,
										554107
									],
									[
										554228,
										554243
									],
									[
										554677,
										554692
									],
									[
										554823,
										554838
									],
									[
										555124,
										555139
									],
									[
										555217,
										555232
									],
									[
										555309,
										555324
									],
									[
										555669,
										555684
									],
									[
										555938,
										555953
									],
									[
										556033,
										556048
									],
									[
										556120,
										556135
									],
									[
										556556,
										556571
									],
									[
										556898,
										556913
									],
									[
										557186,
										557201
									],
									[
										557453,
										557468
									],
									[
										557687,
										557702
									],
									[
										557872,
										557887
									],
									[
										558216,
										558231
									],
									[
										558566,
										558581
									],
									[
										558974,
										558989
									],
									[
										559329,
										559344
									],
									[
										559587,
										559602
									],
									[
										559937,
										559952
									],
									[
										560206,
										560221
									],
									[
										560407,
										560422
									],
									[
										560648,
										560663
									],
									[
										560957,
										560972
									],
									[
										561225,
										561240
									],
									[
										561505,
										561520
									],
									[
										561799,
										561814
									],
									[
										562174,
										562189
									],
									[
										562604,
										562619
									],
									[
										562737,
										562752
									],
									[
										562910,
										562925
									],
									[
										563130,
										563145
									],
									[
										563398,
										563413
									],
									[
										563587,
										563602
									],
									[
										563886,
										563901
									],
									[
										564222,
										564237
									],
									[
										564301,
										564316
									],
									[
										564510,
										564525
									],
									[
										564959,
										564974
									],
									[
										565380,
										565395
									],
									[
										565692,
										565707
									],
									[
										566018,
										566033
									],
									[
										566255,
										566270
									],
									[
										566493,
										566508
									],
									[
										566720,
										566735
									],
									[
										566948,
										566963
									],
									[
										567100,
										567115
									],
									[
										567215,
										567230
									],
									[
										567410,
										567425
									],
									[
										567594,
										567609
									],
									[
										567788,
										567803
									],
									[
										567858,
										567873
									],
									[
										568098,
										568113
									],
									[
										568403,
										568418
									],
									[
										568695,
										568710
									],
									[
										568888,
										568903
									],
									[
										569102,
										569117
									],
									[
										569280,
										569295
									],
									[
										569580,
										569595
									],
									[
										569709,
										569724
									],
									[
										569833,
										569848
									],
									[
										569993,
										570008
									],
									[
										570407,
										570422
									],
									[
										570782,
										570797
									],
									[
										571012,
										571027
									],
									[
										571294,
										571309
									],
									[
										571704,
										571719
									],
									[
										571967,
										571982
									],
									[
										572284,
										572299
									],
									[
										572586,
										572601
									],
									[
										572930,
										572945
									],
									[
										573286,
										573301
									],
									[
										573471,
										573486
									],
									[
										573733,
										573748
									],
									[
										574172,
										574187
									],
									[
										574440,
										574455
									],
									[
										574843,
										574858
									],
									[
										575365,
										575380
									],
									[
										575747,
										575762
									],
									[
										576164,
										576179
									],
									[
										576528,
										576543
									],
									[
										576967,
										576982
									],
									[
										577268,
										577283
									],
									[
										577348,
										577363
									],
									[
										577562,
										577577
									],
									[
										578025,
										578040
									],
									[
										578161,
										578176
									],
									[
										578582,
										578597
									],
									[
										578728,
										578743
									],
									[
										579029,
										579044
									],
									[
										579122,
										579137
									],
									[
										579214,
										579229
									],
									[
										579574,
										579589
									],
									[
										579843,
										579858
									],
									[
										579938,
										579953
									],
									[
										580025,
										580040
									],
									[
										580461,
										580476
									],
									[
										580803,
										580818
									],
									[
										581091,
										581106
									],
									[
										581358,
										581373
									],
									[
										581592,
										581607
									],
									[
										581777,
										581792
									],
									[
										582121,
										582136
									],
									[
										582471,
										582486
									],
									[
										582879,
										582894
									],
									[
										583234,
										583249
									],
									[
										583492,
										583507
									],
									[
										583842,
										583857
									],
									[
										584111,
										584126
									],
									[
										584312,
										584327
									],
									[
										584553,
										584568
									],
									[
										584862,
										584877
									],
									[
										585130,
										585145
									],
									[
										585410,
										585425
									],
									[
										585704,
										585719
									],
									[
										586079,
										586094
									],
									[
										586509,
										586524
									],
									[
										586642,
										586657
									],
									[
										586815,
										586830
									],
									[
										587035,
										587050
									],
									[
										587303,
										587318
									],
									[
										587492,
										587507
									],
									[
										587791,
										587806
									],
									[
										588127,
										588142
									],
									[
										588206,
										588221
									],
									[
										588415,
										588430
									],
									[
										588864,
										588879
									],
									[
										589285,
										589300
									],
									[
										589597,
										589612
									],
									[
										589923,
										589938
									],
									[
										590160,
										590175
									],
									[
										590398,
										590413
									],
									[
										590625,
										590640
									],
									[
										590853,
										590868
									],
									[
										591005,
										591020
									],
									[
										591120,
										591135
									],
									[
										591315,
										591330
									],
									[
										591499,
										591514
									],
									[
										591693,
										591708
									],
									[
										591763,
										591778
									],
									[
										592003,
										592018
									],
									[
										592308,
										592323
									],
									[
										592600,
										592615
									],
									[
										592793,
										592808
									],
									[
										593007,
										593022
									],
									[
										593185,
										593200
									],
									[
										593485,
										593500
									],
									[
										593614,
										593629
									],
									[
										593738,
										593753
									],
									[
										593898,
										593913
									],
									[
										594312,
										594327
									],
									[
										594687,
										594702
									],
									[
										594917,
										594932
									],
									[
										595199,
										595214
									],
									[
										595609,
										595624
									],
									[
										595872,
										595887
									],
									[
										596189,
										596204
									],
									[
										596491,
										596506
									],
									[
										596835,
										596850
									],
									[
										597191,
										597206
									],
									[
										597376,
										597391
									],
									[
										597638,
										597653
									],
									[
										598077,
										598092
									],
									[
										598345,
										598360
									],
									[
										598748,
										598763
									],
									[
										599270,
										599285
									],
									[
										599760,
										599784
									],
									[
										599893,
										599917
									],
									[
										600066,
										600090
									],
									[
										600415,
										600439
									],
									[
										600916,
										600940
									],
									[
										601049,
										601073
									],
									[
										601222,
										601246
									],
									[
										601571,
										601595
									],
									[
										601963,
										601987
									],
									[
										602380,
										602404
									],
									[
										602789,
										602813
									],
									[
										603090,
										603114
									],
									[
										603170,
										603194
									],
									[
										603460,
										603484
									],
									[
										603881,
										603905
									],
									[
										604124,
										604148
									],
									[
										604420,
										604444
									],
									[
										604549,
										604573
									],
									[
										604673,
										604697
									],
									[
										604926,
										604950
									],
									[
										605198,
										605222
									],
									[
										605521,
										605533
									],
									[
										605930,
										605942
									],
									[
										606171,
										606183
									],
									[
										606362,
										606374
									],
									[
										606643,
										606655
									],
									[
										606773,
										606785
									],
									[
										607042,
										607054
									],
									[
										607145,
										607157
									],
									[
										607429,
										607441
									],
									[
										607742,
										607754
									],
									[
										608056,
										608068
									],
									[
										608368,
										608380
									],
									[
										608703,
										608723
									],
									[
										609029,
										609049
									],
									[
										609451,
										609471
									],
									[
										609698,
										609718
									],
									[
										609962,
										609982
									],
									[
										610217,
										610237
									],
									[
										610409,
										610429
									],
									[
										610629,
										610649
									],
									[
										611066,
										611086
									],
									[
										611376,
										611396
									],
									[
										611565,
										611585
									],
									[
										611919,
										611939
									],
									[
										612206,
										612226
									],
									[
										612512,
										612532
									],
									[
										612762,
										612782
									],
									[
										613096,
										613116
									],
									[
										613363,
										613383
									],
									[
										613848,
										613857
									],
									[
										614215,
										614224
									],
									[
										614523,
										614532
									],
									[
										614752,
										614761
									],
									[
										615022,
										615031
									],
									[
										615349,
										615358
									],
									[
										615670,
										615679
									],
									[
										615945,
										615954
									],
									[
										616186,
										616195
									],
									[
										616533,
										616542
									],
									[
										616834,
										616843
									],
									[
										617138,
										617147
									],
									[
										617430,
										617439
									],
									[
										617792,
										617801
									],
									[
										618049,
										618058
									],
									[
										618227,
										618236
									],
									[
										618592,
										618601
									],
									[
										618835,
										618844
									],
									[
										619036,
										619045
									],
									[
										619233,
										619242
									],
									[
										619415,
										619424
									],
									[
										619714,
										619723
									],
									[
										620020,
										620029
									],
									[
										620318,
										620327
									],
									[
										620608,
										620617
									],
									[
										620894,
										620903
									],
									[
										621185,
										621194
									],
									[
										621483,
										621492
									],
									[
										621752,
										621761
									],
									[
										622077,
										622086
									],
									[
										622403,
										622412
									],
									[
										622707,
										622716
									],
									[
										622877,
										622886
									],
									[
										623148,
										623157
									],
									[
										623563,
										623572
									],
									[
										623900,
										623907
									],
									[
										624121,
										624128
									],
									[
										624176,
										624183
									],
									[
										624359,
										624366
									],
									[
										624462,
										624469
									],
									[
										624580,
										624587
									],
									[
										624715,
										624722
									],
									[
										624969,
										624976
									],
									[
										625060,
										625067
									],
									[
										625151,
										625158
									],
									[
										625399,
										625406
									],
									[
										625489,
										625496
									],
									[
										625579,
										625586
									],
									[
										625828,
										625835
									],
									[
										625921,
										625928
									],
									[
										626036,
										626043
									],
									[
										626317,
										626324
									],
									[
										626410,
										626417
									],
									[
										626525,
										626532
									],
									[
										626805,
										626812
									],
									[
										626897,
										626904
									],
									[
										627011,
										627018
									],
									[
										627288,
										627295
									],
									[
										627379,
										627386
									],
									[
										627492,
										627499
									],
									[
										627767,
										627774
									],
									[
										627858,
										627865
									],
									[
										627971,
										627978
									],
									[
										628204,
										628211
									],
									[
										628251,
										628258
									],
									[
										628301,
										628308
									],
									[
										628457,
										628464
									],
									[
										628853,
										628860
									],
									[
										628900,
										628907
									],
									[
										628933,
										628940
									],
									[
										629108,
										629115
									],
									[
										629282,
										629289
									],
									[
										629329,
										629336
									],
									[
										629366,
										629373
									],
									[
										629669,
										629676
									],
									[
										630053,
										630060
									],
									[
										630402,
										630409
									],
									[
										630651,
										630658
									],
									[
										630978,
										630985
									],
									[
										631220,
										631227
									],
									[
										631379,
										631386
									],
									[
										631479,
										631486
									],
									[
										631586,
										631593
									],
									[
										631691,
										631698
									],
									[
										631897,
										631904
									],
									[
										632237,
										632244
									],
									[
										632566,
										632573
									],
									[
										632867,
										632874
									],
									[
										633239,
										633246
									],
									[
										633410,
										633417
									],
									[
										633597,
										633604
									],
									[
										634224,
										634231
									],
									[
										634331,
										634338
									],
									[
										634612,
										634619
									],
									[
										634865,
										634872
									],
									[
										635190,
										635197
									],
									[
										635520,
										635527
									],
									[
										635771,
										635778
									],
									[
										635973,
										635980
									],
									[
										636295,
										636302
									],
									[
										636574,
										636581
									],
									[
										636814,
										636821
									],
									[
										636999,
										637006
									],
									[
										637249,
										637256
									],
									[
										637577,
										637584
									],
									[
										637783,
										637790
									],
									[
										637819,
										637826
									],
									[
										638163,
										638170
									],
									[
										638486,
										638493
									],
									[
										638541,
										638548
									],
									[
										638862,
										638869
									],
									[
										638931,
										638938
									],
									[
										638954,
										638961
									],
									[
										639229,
										639236
									],
									[
										639538,
										639545
									],
									[
										639788,
										639795
									],
									[
										640085,
										640092
									],
									[
										640248,
										640255
									],
									[
										640288,
										640295
									],
									[
										640560,
										640567
									],
									[
										640889,
										640896
									],
									[
										641187,
										641194
									],
									[
										641247,
										641254
									],
									[
										641543,
										641550
									],
									[
										641714,
										641721
									],
									[
										641974,
										641981
									],
									[
										642229,
										642236
									],
									[
										642506,
										642513
									],
									[
										642632,
										642639
									],
									[
										642881,
										642888
									],
									[
										643068,
										643075
									],
									[
										643293,
										643300
									],
									[
										643617,
										643624
									],
									[
										643947,
										643954
									],
									[
										644097,
										644104
									],
									[
										644463,
										644470
									],
									[
										644677,
										644684
									],
									[
										645048,
										645055
									],
									[
										645329,
										645336
									],
									[
										645401,
										645408
									],
									[
										645651,
										645658
									],
									[
										645908,
										645915
									],
									[
										646305,
										646312
									],
									[
										646569,
										646576
									],
									[
										646724,
										646731
									],
									[
										647086,
										647093
									],
									[
										647470,
										647477
									],
									[
										647799,
										647806
									],
									[
										648120,
										648127
									],
									[
										648402,
										648409
									],
									[
										648810,
										648817
									],
									[
										649249,
										649256
									],
									[
										649570,
										649577
									],
									[
										649883,
										649890
									],
									[
										650386,
										650393
									],
									[
										650769,
										650776
									],
									[
										651024,
										651031
									],
									[
										651115,
										651122
									],
									[
										651148,
										651155
									],
									[
										651234,
										651241
									],
									[
										651267,
										651274
									],
									[
										651355,
										651362
									],
									[
										651388,
										651395
									],
									[
										651477,
										651484
									],
									[
										651615,
										651622
									],
									[
										651706,
										651713
									],
									[
										651739,
										651746
									],
									[
										651825,
										651832
									],
									[
										651858,
										651865
									],
									[
										651946,
										651953
									],
									[
										651979,
										651986
									],
									[
										652068,
										652075
									],
									[
										652209,
										652216
									],
									[
										652300,
										652307
									],
									[
										652333,
										652340
									],
									[
										652419,
										652426
									],
									[
										652452,
										652459
									],
									[
										652540,
										652547
									],
									[
										652573,
										652580
									],
									[
										652662,
										652669
									],
									[
										652829,
										652836
									],
									[
										652920,
										652927
									],
									[
										652953,
										652960
									],
									[
										653039,
										653046
									],
									[
										653072,
										653079
									],
									[
										653160,
										653167
									],
									[
										653193,
										653200
									],
									[
										653282,
										653289
									],
									[
										653409,
										653416
									],
									[
										653500,
										653507
									],
									[
										653533,
										653540
									],
									[
										653619,
										653626
									],
									[
										653652,
										653659
									],
									[
										653740,
										653747
									],
									[
										653773,
										653780
									],
									[
										653862,
										653869
									],
									[
										654079,
										654086
									],
									[
										654168,
										654175
									],
									[
										654201,
										654208
									],
									[
										654285,
										654292
									],
									[
										654318,
										654325
									],
									[
										654404,
										654411
									],
									[
										654437,
										654444
									],
									[
										654524,
										654531
									],
									[
										654755,
										654762
									],
									[
										654778,
										654785
									],
									[
										655013,
										655020
									],
									[
										655036,
										655043
									],
									[
										655271,
										655278
									],
									[
										655294,
										655301
									],
									[
										655529,
										655536
									],
									[
										655552,
										655559
									],
									[
										655822,
										655829
									],
									[
										656319,
										656326
									],
									[
										656543,
										656550
									],
									[
										656652,
										656659
									],
									[
										656864,
										656871
									],
									[
										657070,
										657077
									],
									[
										657318,
										657325
									],
									[
										657486,
										657493
									],
									[
										657636,
										657643
									],
									[
										657778,
										657785
									],
									[
										657859,
										657866
									],
									[
										657931,
										657938
									],
									[
										658050,
										658057
									],
									[
										658109,
										658116
									],
									[
										658311,
										658318
									],
									[
										658372,
										658379
									],
									[
										658547,
										658554
									],
									[
										658764,
										658771
									],
									[
										658933,
										658940
									],
									[
										659064,
										659071
									],
									[
										659264,
										659271
									],
									[
										659494,
										659501
									],
									[
										659784,
										659791
									],
									[
										659856,
										659863
									],
									[
										659913,
										659920
									],
									[
										660098,
										660105
									],
									[
										660469,
										660476
									],
									[
										660708,
										660715
									],
									[
										660980,
										660987
									],
									[
										661004,
										661011
									],
									[
										661085,
										661092
									],
									[
										661455,
										661462
									],
									[
										661709,
										661716
									],
									[
										662213,
										662220
									],
									[
										662652,
										662659
									],
									[
										662787,
										662794
									],
									[
										662850,
										662857
									],
									[
										663056,
										663063
									],
									[
										663418,
										663425
									],
									[
										663613,
										663620
									],
									[
										663929,
										663936
									],
									[
										664201,
										664208
									],
									[
										664427,
										664434
									],
									[
										664836,
										664843
									],
									[
										665141,
										665148
									],
									[
										665337,
										665344
									],
									[
										665530,
										665537
									],
									[
										665582,
										665589
									],
									[
										665866,
										665873
									],
									[
										666228,
										666235
									],
									[
										666588,
										666595
									],
									[
										666716,
										666723
									],
									[
										666774,
										666781
									],
									[
										666840,
										666847
									],
									[
										666999,
										667006
									],
									[
										667444,
										667451
									],
									[
										667495,
										667502
									],
									[
										667553,
										667560
									],
									[
										668083,
										668090
									],
									[
										668280,
										668287
									],
									[
										668471,
										668478
									],
									[
										668677,
										668684
									],
									[
										669144,
										669151
									],
									[
										669236,
										669243
									],
									[
										669507,
										669514
									],
									[
										669659,
										669666
									],
									[
										669906,
										669913
									],
									[
										670036,
										670043
									],
									[
										670268,
										670275
									],
									[
										670784,
										670791
									],
									[
										670938,
										670945
									],
									[
										671159,
										671166
									],
									[
										671310,
										671317
									],
									[
										671458,
										671465
									],
									[
										671903,
										671910
									],
									[
										672432,
										672439
									],
									[
										672873,
										672880
									],
									[
										673183,
										673190
									],
									[
										673586,
										673593
									],
									[
										674007,
										674014
									],
									[
										674570,
										674577
									],
									[
										674850,
										674857
									],
									[
										675210,
										675217
									],
									[
										675301,
										675308
									],
									[
										675499,
										675506
									],
									[
										675808,
										675815
									],
									[
										676134,
										676141
									],
									[
										676435,
										676442
									],
									[
										676779,
										676786
									],
									[
										676917,
										676924
									],
									[
										677186,
										677193
									],
									[
										677387,
										677394
									],
									[
										677471,
										677478
									],
									[
										677666,
										677673
									],
									[
										677694,
										677701
									],
									[
										677905,
										677912
									],
									[
										677928,
										677935
									],
									[
										678304,
										678311
									],
									[
										678549,
										678556
									],
									[
										678792,
										678799
									],
									[
										678844,
										678851
									],
									[
										678991,
										678998
									],
									[
										679093,
										679100
									],
									[
										679438,
										679445
									],
									[
										679485,
										679492
									],
									[
										679537,
										679544
									],
									[
										679933,
										679940
									],
									[
										679967,
										679974
									],
									[
										680178,
										680185
									],
									[
										680212,
										680219
									],
									[
										680543,
										680550
									],
									[
										680577,
										680584
									],
									[
										680788,
										680795
									],
									[
										680822,
										680829
									],
									[
										681097,
										681104
									],
									[
										681472,
										681479
									],
									[
										681799,
										681806
									],
									[
										682188,
										682195
									],
									[
										682560,
										682567
									],
									[
										682867,
										682874
									],
									[
										683245,
										683252
									],
									[
										683279,
										683286
									],
									[
										683490,
										683497
									],
									[
										683524,
										683531
									],
									[
										683804,
										683811
									],
									[
										684033,
										684040
									],
									[
										684085,
										684092
									],
									[
										684130,
										684137
									],
									[
										684272,
										684279
									],
									[
										684667,
										684674
									],
									[
										684714,
										684721
									],
									[
										684766,
										684773
									],
									[
										685154,
										685161
									],
									[
										685188,
										685195
									],
									[
										685399,
										685406
									],
									[
										685433,
										685440
									],
									[
										685692,
										685699
									],
									[
										685954,
										685961
									],
									[
										686006,
										686013
									],
									[
										686434,
										686441
									],
									[
										686481,
										686488
									],
									[
										686533,
										686540
									],
									[
										686942,
										686949
									],
									[
										686976,
										686983
									],
									[
										687187,
										687194
									],
									[
										687221,
										687228
									],
									[
										687510,
										687517
									],
									[
										687894,
										687901
									],
									[
										688278,
										688285
									],
									[
										688312,
										688319
									],
									[
										688523,
										688530
									],
									[
										688557,
										688564
									],
									[
										688894,
										688901
									],
									[
										688986,
										688993
									],
									[
										689097,
										689104
									],
									[
										689343,
										689350
									],
									[
										689395,
										689402
									],
									[
										689538,
										689545
									],
									[
										689914,
										689921
									],
									[
										689961,
										689968
									],
									[
										690013,
										690020
									],
									[
										690294,
										690301
									],
									[
										690736,
										690743
									],
									[
										691157,
										691164
									],
									[
										691191,
										691198
									],
									[
										691402,
										691409
									],
									[
										691436,
										691443
									],
									[
										691734,
										691741
									],
									[
										692167,
										692174
									],
									[
										692684,
										692691
									],
									[
										693084,
										693091
									],
									[
										693118,
										693125
									],
									[
										693329,
										693336
									],
									[
										693363,
										693370
									],
									[
										693670,
										693677
									],
									[
										693999,
										694006
									],
									[
										694342,
										694349
									],
									[
										694376,
										694383
									],
									[
										694587,
										694594
									],
									[
										694621,
										694628
									],
									[
										694942,
										694949
									],
									[
										694976,
										694983
									],
									[
										695187,
										695194
									],
									[
										695221,
										695228
									],
									[
										695457,
										695464
									],
									[
										695509,
										695516
									],
									[
										695548,
										695555
									],
									[
										695566,
										695573
									],
									[
										695808,
										695815
									],
									[
										695860,
										695867
									],
									[
										696215,
										696222
									],
									[
										696331,
										696338
									],
									[
										696383,
										696390
									],
									[
										696418,
										696425
									],
									[
										696436,
										696443
									],
									[
										696742,
										696749
									],
									[
										697046,
										697053
									],
									[
										697098,
										697105
									],
									[
										697299,
										697306
									],
									[
										697605,
										697612
									],
									[
										698003,
										698010
									],
									[
										698168,
										698175
									],
									[
										698220,
										698227
									],
									[
										698391,
										698398
									],
									[
										698637,
										698644
									],
									[
										698689,
										698696
									],
									[
										699058,
										699065
									],
									[
										699354,
										699361
									],
									[
										699724,
										699731
									],
									[
										700015,
										700022
									],
									[
										700454,
										700461
									],
									[
										700666,
										700673
									],
									[
										700907,
										700914
									],
									[
										700959,
										700966
									],
									[
										701036,
										701043
									],
									[
										701330,
										701337
									],
									[
										701377,
										701384
									],
									[
										701429,
										701436
									],
									[
										701813,
										701820
									],
									[
										701847,
										701854
									],
									[
										702058,
										702065
									],
									[
										702092,
										702099
									],
									[
										702398,
										702405
									],
									[
										702744,
										702751
									],
									[
										702778,
										702785
									],
									[
										702989,
										702996
									],
									[
										703023,
										703030
									],
									[
										703355,
										703362
									],
									[
										703632,
										703639
									],
									[
										703957,
										703964
									],
									[
										704363,
										704370
									],
									[
										704722,
										704729
									],
									[
										705124,
										705131
									],
									[
										705158,
										705165
									],
									[
										705369,
										705376
									],
									[
										705403,
										705410
									],
									[
										705709,
										705716
									],
									[
										706087,
										706094
									],
									[
										706134,
										706141
									],
									[
										706186,
										706193
									],
									[
										706594,
										706601
									],
									[
										706628,
										706635
									],
									[
										706839,
										706846
									],
									[
										706873,
										706880
									],
									[
										707177,
										707184
									],
									[
										707490,
										707497
									],
									[
										707894,
										707901
									],
									[
										707928,
										707935
									],
									[
										708139,
										708146
									],
									[
										708173,
										708180
									],
									[
										708441,
										708448
									],
									[
										708840,
										708847
									],
									[
										709261,
										709268
									],
									[
										709295,
										709302
									],
									[
										709506,
										709513
									],
									[
										709540,
										709547
									],
									[
										709802,
										709809
									],
									[
										709958,
										709965
									],
									[
										710016,
										710023
									],
									[
										710366,
										710373
									],
									[
										710413,
										710420
									],
									[
										710471,
										710478
									],
									[
										710909,
										710916
									],
									[
										710943,
										710950
									],
									[
										711154,
										711161
									],
									[
										711188,
										711195
									],
									[
										711515,
										711522
									],
									[
										711857,
										711864
									],
									[
										711968,
										711975
									],
									[
										712026,
										712033
									],
									[
										712065,
										712072
									],
									[
										712432,
										712439
									],
									[
										712582,
										712589
									],
									[
										712634,
										712641
									],
									[
										712923,
										712930
									],
									[
										712957,
										712964
									],
									[
										713168,
										713175
									],
									[
										713202,
										713209
									],
									[
										713503,
										713510
									],
									[
										713595,
										713602
									],
									[
										713706,
										713713
									],
									[
										713944,
										713951
									],
									[
										713996,
										714003
									],
									[
										714080,
										714087
									],
									[
										714410,
										714417
									],
									[
										714457,
										714464
									],
									[
										714509,
										714516
									],
									[
										714911,
										714918
									],
									[
										714945,
										714952
									],
									[
										715156,
										715163
									],
									[
										715190,
										715197
									],
									[
										715470,
										715477
									],
									[
										715839,
										715846
									],
									[
										716227,
										716234
									],
									[
										716261,
										716268
									],
									[
										716472,
										716479
									],
									[
										716506,
										716513
									],
									[
										716789,
										716796
									],
									[
										716989,
										716996
									],
									[
										717041,
										717048
									],
									[
										717079,
										717086
									],
									[
										717441,
										717448
									],
									[
										717488,
										717495
									],
									[
										717540,
										717547
									],
									[
										717893,
										717900
									],
									[
										717993,
										718000
									],
									[
										718104,
										718111
									],
									[
										718337,
										718344
									],
									[
										718389,
										718396
									],
									[
										718468,
										718475
									],
									[
										718561,
										718568
									],
									[
										719001,
										719008
									],
									[
										719048,
										719055
									],
									[
										719100,
										719107
									],
									[
										719478,
										719485
									],
									[
										719512,
										719519
									],
									[
										719723,
										719730
									],
									[
										719757,
										719764
									],
									[
										720055,
										720062
									],
									[
										720411,
										720418
									],
									[
										720811,
										720818
									],
									[
										720845,
										720852
									],
									[
										721056,
										721063
									],
									[
										721090,
										721097
									],
									[
										721408,
										721415
									],
									[
										721442,
										721449
									],
									[
										721653,
										721660
									],
									[
										721687,
										721694
									],
									[
										722011,
										722018
									],
									[
										722045,
										722052
									],
									[
										722256,
										722263
									],
									[
										722290,
										722297
									],
									[
										722622,
										722629
									],
									[
										722656,
										722663
									],
									[
										722867,
										722874
									],
									[
										722901,
										722908
									],
									[
										723221,
										723228
									],
									[
										723255,
										723262
									],
									[
										723466,
										723473
									],
									[
										723500,
										723507
									],
									[
										723820,
										723827
									],
									[
										723854,
										723861
									],
									[
										724065,
										724072
									],
									[
										724099,
										724106
									],
									[
										724458,
										724465
									],
									[
										724838,
										724845
									],
									[
										725170,
										725177
									],
									[
										725367,
										725374
									],
									[
										725693,
										725700
									],
									[
										725884,
										725891
									],
									[
										726260,
										726267
									],
									[
										726650,
										726657
									],
									[
										727051,
										727058
									],
									[
										727114,
										727121
									],
									[
										727468,
										727475
									],
									[
										727788,
										727795
									],
									[
										727822,
										727829
									],
									[
										728033,
										728040
									],
									[
										728067,
										728074
									],
									[
										728374,
										728381
									],
									[
										728780,
										728787
									],
									[
										729034,
										729041
									],
									[
										729287,
										729294
									],
									[
										729450,
										729457
									],
									[
										729744,
										729751
									],
									[
										729968,
										729975
									],
									[
										730112,
										730119
									],
									[
										730195,
										730202
									],
									[
										730232,
										730239
									],
									[
										730356,
										730363
									],
									[
										730642,
										730649
									],
									[
										730959,
										730966
									],
									[
										731178,
										731185
									],
									[
										731449,
										731456
									],
									[
										731856,
										731863
									],
									[
										732181,
										732188
									],
									[
										732536,
										732543
									],
									[
										732804,
										732811
									],
									[
										732956,
										732963
									],
									[
										733024,
										733031
									],
									[
										733194,
										733201
									],
									[
										733418,
										733425
									],
									[
										733820,
										733827
									],
									[
										734182,
										734189
									],
									[
										734412,
										734419
									],
									[
										734599,
										734606
									],
									[
										735116,
										735123
									],
									[
										735457,
										735464
									],
									[
										735865,
										735872
									],
									[
										736159,
										736166
									],
									[
										736465,
										736472
									],
									[
										736734,
										736741
									],
									[
										737141,
										737148
									],
									[
										737353,
										737360
									],
									[
										737501,
										737508
									],
									[
										737721,
										737728
									],
									[
										737975,
										737982
									],
									[
										738229,
										738236
									],
									[
										738347,
										738354
									],
									[
										738577,
										738584
									],
									[
										738816,
										738823
									],
									[
										739072,
										739079
									],
									[
										739328,
										739335
									],
									[
										739570,
										739577
									],
									[
										739813,
										739820
									],
									[
										740073,
										740080
									],
									[
										740333,
										740340
									],
									[
										740579,
										740586
									],
									[
										740792,
										740799
									],
									[
										741006,
										741013
									],
									[
										741222,
										741229
									],
									[
										741438,
										741445
									],
									[
										741678,
										741685
									],
									[
										741934,
										741941
									],
									[
										742190,
										742197
									],
									[
										742430,
										742437
									],
									[
										742669,
										742676
									],
									[
										742925,
										742932
									],
									[
										743181,
										743188
									],
									[
										743421,
										743428
									],
									[
										743636,
										743643
									],
									[
										743852,
										743859
									],
									[
										744092,
										744099
									],
									[
										744348,
										744355
									],
									[
										744604,
										744611
									],
									[
										744846,
										744853
									],
									[
										744978,
										744985
									],
									[
										745263,
										745270
									],
									[
										745557,
										745564
									],
									[
										745868,
										745875
									],
									[
										746426,
										746433
									],
									[
										746890,
										746897
									],
									[
										747236,
										747243
									],
									[
										747573,
										747580
									],
									[
										748001,
										748008
									],
									[
										748484,
										748491
									],
									[
										748762,
										748769
									],
									[
										748966,
										748973
									],
									[
										749193,
										749200
									],
									[
										749427,
										749434
									],
									[
										749717,
										749724
									],
									[
										749926,
										749933
									],
									[
										750166,
										750173
									],
									[
										750507,
										750514
									],
									[
										750852,
										750859
									],
									[
										751147,
										751154
									],
									[
										751586,
										751593
									],
									[
										751876,
										751883
									],
									[
										752228,
										752235
									],
									[
										752450,
										752457
									],
									[
										752809,
										752816
									],
									[
										753124,
										753131
									],
									[
										753374,
										753381
									],
									[
										753646,
										753653
									],
									[
										754122,
										754129
									],
									[
										754449,
										754456
									],
									[
										754868,
										754875
									],
									[
										755301,
										755308
									],
									[
										755659,
										755666
									],
									[
										755988,
										755995
									],
									[
										756365,
										756372
									],
									[
										756733,
										756740
									],
									[
										757281,
										757288
									],
									[
										757733,
										757740
									],
									[
										757992,
										757999
									],
									[
										758422,
										758429
									],
									[
										758780,
										758787
									],
									[
										759013,
										759020
									],
									[
										759425,
										759432
									],
									[
										759818,
										759825
									],
									[
										760335,
										760342
									],
									[
										760777,
										760784
									],
									[
										761169,
										761176
									],
									[
										761436,
										761443
									],
									[
										761829,
										761836
									],
									[
										762314,
										762321
									],
									[
										762629,
										762636
									],
									[
										762967,
										762974
									],
									[
										763197,
										763204
									],
									[
										763361,
										763368
									],
									[
										763523,
										763530
									],
									[
										763534,
										763541
									],
									[
										763767,
										763774
									],
									[
										764023,
										764030
									],
									[
										764397,
										764404
									],
									[
										764727,
										764734
									],
									[
										765182,
										765189
									],
									[
										765440,
										765447
									],
									[
										765709,
										765716
									],
									[
										766078,
										766085
									],
									[
										766265,
										766272
									],
									[
										766538,
										766545
									],
									[
										766676,
										766683
									],
									[
										766825,
										766832
									],
									[
										766994,
										767001
									],
									[
										767295,
										767302
									],
									[
										767384,
										767391
									],
									[
										767562,
										767569
									],
									[
										767765,
										767772
									],
									[
										767814,
										767821
									],
									[
										767896,
										767903
									],
									[
										767937,
										767944
									],
									[
										767981,
										767988
									],
									[
										768061,
										768068
									],
									[
										768174,
										768181
									],
									[
										768495,
										768502
									],
									[
										768631,
										768638
									],
									[
										768641,
										768648
									],
									[
										768827,
										768834
									],
									[
										768968,
										768975
									],
									[
										769222,
										769229
									],
									[
										769403,
										769410
									],
									[
										769572,
										769579
									],
									[
										769716,
										769723
									],
									[
										770021,
										770028
									],
									[
										770492,
										770499
									],
									[
										770730,
										770737
									],
									[
										770987,
										770994
									],
									[
										771239,
										771246
									],
									[
										771671,
										771678
									],
									[
										771775,
										771782
									],
									[
										771859,
										771866
									],
									[
										772148,
										772155
									],
									[
										772561,
										772568
									],
									[
										772844,
										772851
									],
									[
										773160,
										773167
									],
									[
										773430,
										773437
									],
									[
										773703,
										773710
									],
									[
										773800,
										773807
									],
									[
										773951,
										773958
									],
									[
										774066,
										774073
									],
									[
										774238,
										774245
									],
									[
										774310,
										774317
									],
									[
										774412,
										774419
									],
									[
										774567,
										774574
									],
									[
										774759,
										774766
									],
									[
										775045,
										775052
									],
									[
										775373,
										775380
									],
									[
										775557,
										775564
									],
									[
										775842,
										775849
									],
									[
										776120,
										776127
									],
									[
										776375,
										776382
									],
									[
										776719,
										776726
									],
									[
										777224,
										777231
									],
									[
										777586,
										777593
									],
									[
										777949,
										777956
									],
									[
										778328,
										778335
									],
									[
										778442,
										778449
									],
									[
										778628,
										778635
									],
									[
										778898,
										778905
									],
									[
										779132,
										779139
									],
									[
										779257,
										779264
									],
									[
										779655,
										779662
									],
									[
										779881,
										779888
									],
									[
										780219,
										780226
									],
									[
										780265,
										780272
									],
									[
										780408,
										780415
									],
									[
										780637,
										780644
									],
									[
										780986,
										780997
									],
									[
										781249,
										781260
									],
									[
										781535,
										781546
									],
									[
										781740,
										781751
									],
									[
										781996,
										782007
									],
									[
										782367,
										782378
									],
									[
										782588,
										782606
									],
									[
										782782,
										782800
									],
									[
										783048,
										783066
									],
									[
										783501,
										783514
									],
									[
										783785,
										783798
									],
									[
										784059,
										784072
									],
									[
										784288,
										784301
									],
									[
										784583,
										784596
									],
									[
										784749,
										784762
									],
									[
										785050,
										785063
									],
									[
										785382,
										785395
									],
									[
										785686,
										785699
									],
									[
										785895,
										785908
									],
									[
										786234,
										786247
									],
									[
										786573,
										786586
									],
									[
										786878,
										786891
									],
									[
										787229,
										787242
									],
									[
										787541,
										787554
									],
									[
										787845,
										787858
									],
									[
										788153,
										788166
									],
									[
										788458,
										788471
									],
									[
										788806,
										788819
									],
									[
										789034,
										789047
									],
									[
										789440,
										789453
									],
									[
										789857,
										789866
									],
									[
										789930,
										789939
									],
									[
										789953,
										789962
									],
									[
										790040,
										790049
									],
									[
										790157,
										790166
									],
									[
										790173,
										790182
									],
									[
										790206,
										790215
									],
									[
										790233,
										790242
									],
									[
										790372,
										790381
									],
									[
										790606,
										790615
									],
									[
										790797,
										790806
									],
									[
										791198,
										791207
									],
									[
										791608,
										791617
									],
									[
										791773,
										791782
									],
									[
										791928,
										791937
									],
									[
										792182,
										792191
									],
									[
										792456,
										792465
									],
									[
										792582,
										792591
									],
									[
										792856,
										792865
									],
									[
										793074,
										793083
									],
									[
										793233,
										793242
									],
									[
										793401,
										793410
									],
									[
										793581,
										793590
									],
									[
										793743,
										793752
									],
									[
										793906,
										793915
									],
									[
										794148,
										794157
									],
									[
										795386,
										795404
									],
									[
										796186,
										796204
									],
									[
										797041,
										797059
									],
									[
										797881,
										797899
									],
									[
										798736,
										798754
									],
									[
										799571,
										799589
									],
									[
										800567,
										800585
									],
									[
										801367,
										801385
									],
									[
										802222,
										802240
									],
									[
										803062,
										803080
									],
									[
										803917,
										803935
									],
									[
										804752,
										804770
									],
									[
										805195,
										805213
									],
									[
										805665,
										805673
									],
									[
										805944,
										805952
									],
									[
										806184,
										806192
									],
									[
										806328,
										806336
									],
									[
										807339,
										807347
									],
									[
										807604,
										807612
									],
									[
										807880,
										807888
									],
									[
										808127,
										808135
									],
									[
										808358,
										808366
									],
									[
										808560,
										808568
									],
									[
										808903,
										808930
									],
									[
										809123,
										809150
									],
									[
										809464,
										809491
									],
									[
										809637,
										809664
									],
									[
										809938,
										809965
									]
								],
								"scope": ""
							}
						},
						"selection":
						[
							[
								809136,
								809136
							]
						],
						"settings":
						{
							"detect_indentation": false,
							"line_numbers": false,
							"output_tag": 77,
							"result_base_dir": "",
							"result_file_regex": "^([^ \t].*):$",
							"result_line_regex": "^ +([0-9]+):",
							"scroll_past_end": true,
							"syntax": "Packages/Default/Find Results.hidden-tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 305082.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "/home/max/dev/RadeonProRenderUSD/pxr/imaging/plugin/hdRpr/python/generateRenderSettingFiles.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 24851,
						"regions":
						{
						},
						"selection":
						[
							[
								13470,
								13470
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 6889.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "third_party/USD/cmake/macros/Private.cmake",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 50720,
						"regions":
						{
						},
						"selection":
						[
							[
								2462,
								2462
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 385.0,
						"zoom_level": 1.0
					},
					"stack_index": 28,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "src/Falcor/Core/API/D3D12/D3D12NvApiExDesc.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4956,
						"regions":
						{
						},
						"selection":
						[
							[
								4176,
								4176
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1062.0,
						"zoom_level": 1.0
					},
					"stack_index": 153,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "src/Falcor/Core/API/Vulkan/VkResource.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1884,
						"regions":
						{
						},
						"selection":
						[
							[
								1754,
								1754
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 201,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "src/Mogwai/Data/ForwardRenderer.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1872,
						"regions":
						{
						},
						"selection":
						[
							[
								1872,
								1872
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 380,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "src/Mogwai/Data/BSDFViewer.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 634,
						"regions":
						{
						},
						"selection":
						[
							[
								156,
								156
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 381,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "third_party/slang/external/glslang/glslang/Include/BaseTypes.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 18643,
						"regions":
						{
						},
						"selection":
						[
							[
								18403,
								18403
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 8214.0,
						"zoom_level": 1.0
					},
					"stack_index": 393,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "third_party/slang/external/glslang/glslang/MachineIndependent/Initialize.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 477356,
						"regions":
						{
						},
						"selection":
						[
							[
								383248,
								383248
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 141562.0,
						"zoom_level": 1.0
					},
					"stack_index": 394,
					"type": "text"
				},
				{
					"buffer": 10,
					"file": "src/Falcor/Scene/Raster.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4526,
						"regions":
						{
						},
						"selection":
						[
							[
								2674,
								2674
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1173.0,
						"zoom_level": 1.0
					},
					"stack_index": 384,
					"type": "text"
				},
				{
					"buffer": 11,
					"file": "src/RenderPasses/GBuffer/GBuffer/GBufferRaster.3d.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7187,
						"regions":
						{
						},
						"selection":
						[
							[
								5949,
								5949
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 376,
					"type": "text"
				},
				{
					"buffer": 12,
					"file": "src/Falcor/Scene/ShadingData.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15181,
						"regions":
						{
						},
						"selection":
						[
							[
								2978,
								2978
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 510.0,
						"zoom_level": 1.0
					},
					"stack_index": 385,
					"type": "text"
				},
				{
					"buffer": 13,
					"file": "src/RenderPasses/Antialiasing/TAA/TAA.ps.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5743,
						"regions":
						{
						},
						"selection":
						[
							[
								1764,
								1764
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 392,
					"type": "text"
				},
				{
					"buffer": 14,
					"file": "src/Falcor/Experimental/Scene/Lights/LightBVH.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 18635,
						"regions":
						{
						},
						"selection":
						[
							[
								2197,
								2197
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 243,
					"type": "text"
				},
				{
					"buffer": 15,
					"file": "src/Falcor/Experimental/Scene/Lights/LightBVHBuilder.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11295,
						"regions":
						{
						},
						"selection":
						[
							[
								11255,
								11255
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 393.0,
						"zoom_level": 1.0
					},
					"stack_index": 245,
					"type": "text"
				},
				{
					"buffer": 16,
					"file": "src/Falcor/Experimental/Scene/Lights/LightBVHBuilder.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 41661,
						"regions":
						{
						},
						"selection":
						[
							[
								9495,
								9495
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2703.0,
						"zoom_level": 1.0
					},
					"stack_index": 242,
					"type": "text"
				},
				{
					"buffer": 17,
					"file": "src/Falcor/Experimental/Scene/Lights/LightBVH.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 12420,
						"regions":
						{
						},
						"selection":
						[
							[
								5412,
								5412
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1530.0,
						"zoom_level": 1.0
					},
					"stack_index": 244,
					"type": "text"
				},
				{
					"buffer": 18,
					"file": "src/Falcor/Utils/Algorithm/ParallelReduction.ps.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4191,
						"regions":
						{
						},
						"selection":
						[
							[
								1791,
								1791
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 411,
					"type": "text"
				},
				{
					"buffer": 19,
					"file": "src/RenderPasses/BSDFViewer/BSDFViewerParams.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6511,
						"regions":
						{
						},
						"selection":
						[
							[
								6078,
								6078
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1400.0,
						"zoom_level": 1.0
					},
					"stack_index": 389,
					"type": "text"
				},
				{
					"buffer": 20,
					"file": "third_party/slang/external/glslang/glslang/MachineIndependent/ParseHelper.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 364782,
						"regions":
						{
						},
						"selection":
						[
							[
								97986,
								97986
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 35727.0,
						"zoom_level": 1.0
					},
					"stack_index": 416,
					"type": "text"
				},
				{
					"buffer": 21,
					"file": "third_party/slang/external/glslang/SPIRV/SpvBuilder.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 105150,
						"regions":
						{
						},
						"selection":
						[
							[
								1975,
								1975
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 734.0,
						"zoom_level": 1.0
					},
					"stack_index": 413,
					"type": "text"
				},
				{
					"buffer": 22,
					"file": "third_party/slang/source/slang/slang-ir.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 150177,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 14249.0,
						"zoom_level": 1.0
					},
					"stack_index": 415,
					"type": "text"
				},
				{
					"buffer": 23,
					"file": "third_party/slang/external/glslang/SPIRV/SpvBuilder.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 35460,
						"regions":
						{
						},
						"selection":
						[
							[
								2248,
								2248
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 547.0,
						"zoom_level": 1.0
					},
					"stack_index": 414,
					"type": "text"
				},
				{
					"buffer": 24,
					"file": "third_party/slang/source/slang-glslang/slang-glslang.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 18679,
						"regions":
						{
						},
						"selection":
						[
							[
								9729,
								9729
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3760.0,
						"zoom_level": 1.0
					},
					"stack_index": 418,
					"type": "text"
				},
				{
					"buffer": 25,
					"file": "third_party/slang/external/spirv-tools/source/spirv_target_env.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10524,
						"regions":
						{
						},
						"selection":
						[
							[
								6159,
								6159
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2145.0,
						"zoom_level": 1.0
					},
					"stack_index": 419,
					"type": "text"
				},
				{
					"buffer": 26,
					"file": "third_party/slang/external/spirv-tools/CHANGES",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 47890,
						"regions":
						{
						},
						"selection":
						[
							[
								26053,
								26053
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 3,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 969.0,
						"zoom_level": 1.0
					},
					"stack_index": 420,
					"type": "text"
				},
				{
					"buffer": 27,
					"file": "src/Falcor/Scene/SceneBuilder.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 23587,
						"regions":
						{
						},
						"selection":
						[
							[
								20564,
								20564
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3009.0,
						"zoom_level": 1.0
					},
					"stack_index": 155,
					"type": "text"
				},
				{
					"buffer": 28,
					"file": "src/Falcor/Scene/SceneTypes.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5249,
						"regions":
						{
						},
						"selection":
						[
							[
								5227,
								5227
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1842.0,
						"zoom_level": 1.0
					},
					"stack_index": 383,
					"type": "text"
				},
				{
					"buffer": 29,
					"file": "third_party/slang/source/slang/slang-type-layout.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 149248,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3250.0,
						"zoom_level": 1.0
					},
					"stack_index": 426,
					"type": "text"
				},
				{
					"buffer": 30,
					"file": "third_party/slang/source/slang/slang-type-layout.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 34158,
						"regions":
						{
						},
						"selection":
						[
							[
								4752,
								4752
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 7568.0,
						"zoom_level": 1.0
					},
					"stack_index": 425,
					"type": "text"
				},
				{
					"buffer": 31,
					"file": "third_party/slang/slang.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 132132,
						"regions":
						{
						},
						"selection":
						[
							[
								14421,
								14421
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1367.0,
						"zoom_level": 1.0
					},
					"stack_index": 421,
					"type": "text"
				},
				{
					"buffer": 32,
					"file": "third_party/slang/external/glm/test/core/core_type_aligned.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5440,
						"regions":
						{
						},
						"selection":
						[
							[
								1764,
								1764
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 612.0,
						"zoom_level": 1.0
					},
					"stack_index": 427,
					"type": "text"
				},
				{
					"buffer": 33,
					"file": "src/Falcor/Core/API/Formats.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 19719,
						"regions":
						{
						},
						"selection":
						[
							[
								1805,
								1805
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 180.0,
						"zoom_level": 1.0
					},
					"stack_index": 408,
					"type": "text"
				},
				{
					"buffer": 34,
					"file": "third_party/slang/external/glm/glm/gtx/compatibility.hpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14979,
						"regions":
						{
						},
						"selection":
						[
							[
								452,
								452
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 438,
					"type": "text"
				},
				{
					"buffer": 35,
					"file": "src/Falcor/Core/API/Vulkan/VKFormats.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10446,
						"regions":
						{
						},
						"selection":
						[
							[
								8644,
								8644
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1346.0,
						"zoom_level": 1.0
					},
					"stack_index": 327,
					"type": "text"
				},
				{
					"buffer": 36,
					"file": "third_party/slang/external/glslang/glslang/Include/intermediate.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 54763,
						"regions":
						{
						},
						"selection":
						[
							[
								25731,
								25731
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 16441.0,
						"zoom_level": 1.0
					},
					"stack_index": 442,
					"type": "text"
				},
				{
					"buffer": 37,
					"file": "third_party/slang/docs/language-reference/04-types.md",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14365,
						"regions":
						{
						},
						"selection":
						[
							[
								1184,
								1184
							]
						],
						"settings":
						{
							"syntax": "Packages/Markdown/Markdown.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 445,
					"type": "text"
				},
				{
					"buffer": 38,
					"file": "third_party/slang/external/glslang/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4705,
						"regions":
						{
						},
						"selection":
						[
							[
								2012,
								2012
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 446,
					"type": "text"
				},
				{
					"buffer": 39,
					"file": "third_party/slang/external/glslang/SPIRV/GlslangToSpv.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 339007,
						"regions":
						{
						},
						"selection":
						[
							[
								1976,
								1976
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 255.0,
						"zoom_level": 1.0
					},
					"stack_index": 447,
					"type": "text"
				},
				{
					"buffer": 40,
					"file": "third_party/slang/external/glslang/Test/100.frag",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4744,
						"regions":
						{
						},
						"selection":
						[
							[
								1633,
								1633
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1683.0,
						"zoom_level": 1.0
					},
					"stack_index": 448,
					"type": "text"
				},
				{
					"buffer": 41,
					"file": "third_party/slang/external/glext.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 811328,
						"regions":
						{
						},
						"selection":
						[
							[
								91506,
								91506
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 29021.0,
						"zoom_level": 1.0
					},
					"stack_index": 449,
					"type": "text"
				},
				{
					"buffer": 42,
					"file": "third_party/slang/docs/wave-intrinsics.md",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13145,
						"regions":
						{
						},
						"selection":
						[
							[
								370,
								370
							]
						],
						"settings":
						{
							"syntax": "Packages/Markdown/Markdown.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4675.0,
						"zoom_level": 1.0
					},
					"stack_index": 417,
					"type": "text"
				},
				{
					"buffer": 43,
					"file": "src/RenderPasses/DebugPasses/InvalidPixelDetectionPass/InvalidPixelDetectionPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4322,
						"regions":
						{
						},
						"selection":
						[
							[
								3840,
								3840
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 243.0,
						"zoom_level": 1.0
					},
					"stack_index": 72,
					"type": "text"
				},
				{
					"buffer": 44,
					"file": "src/Tools/FalcorTest/Tests/Core/RootBufferParamBlockTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8904,
						"regions":
						{
						},
						"selection":
						[
							[
								7978,
								7978
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 328.0,
						"zoom_level": 1.0
					},
					"stack_index": 431,
					"type": "text"
				},
				{
					"buffer": 45,
					"file": "src/Tools/FalcorTest/Tests/Core/RootBufferParamBlockTests.cs.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3086,
						"regions":
						{
						},
						"selection":
						[
							[
								1883,
								1883
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 434,
					"type": "text"
				},
				{
					"buffer": 46,
					"file": "src/Tools/FalcorTest/Tests/Core/ParamBlockDefinition.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2225,
						"regions":
						{
						},
						"selection":
						[
							[
								2107,
								2107
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 435,
					"type": "text"
				},
				{
					"buffer": 47,
					"file": "src/Falcor/Core/Program/ProgramVersion.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8252,
						"regions":
						{
						},
						"selection":
						[
							[
								4136,
								4136
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1125.0,
						"zoom_level": 1.0
					},
					"stack_index": 311,
					"type": "text"
				},
				{
					"buffer": 48,
					"file": "src/Falcor/RenderGraph/RenderGraphIR.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5845,
						"regions":
						{
						},
						"selection":
						[
							[
								2376,
								2376
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 47.0,
						"zoom_level": 1.0
					},
					"stack_index": 180,
					"type": "text"
				},
				{
					"buffer": 49,
					"file": "src/Falcor/RenderGraph/RenderGraphIR.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3409,
						"regions":
						{
						},
						"selection":
						[
							[
								1773,
								1773
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 432.0,
						"zoom_level": 1.0
					},
					"stack_index": 181,
					"type": "text"
				},
				{
					"buffer": 50,
					"file": "src/Falcor/Scene/Importers/AssimpImporter.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 44987,
						"regions":
						{
						},
						"selection":
						[
							[
								40724,
								40724
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 14260.0,
						"zoom_level": 1.0
					},
					"stack_index": 278,
					"type": "text"
				},
				{
					"buffer": 51,
					"file": "src/Falcor/Scene/Importers/AssimpImporter.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2484,
						"regions":
						{
						},
						"selection":
						[
							[
								1819,
								1819
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 256,
					"type": "text"
				},
				{
					"buffer": 52,
					"file": "src/Falcor/Scene/Importers/PythonImporter.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2145,
						"regions":
						{
						},
						"selection":
						[
							[
								1987,
								1987
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 254,
					"type": "text"
				},
				{
					"buffer": 53,
					"file": "src/Falcor/Scene/Camera/Camera.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11607,
						"regions":
						{
						},
						"selection":
						[
							[
								606,
								606
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 170.0,
						"zoom_level": 1.0
					},
					"stack_index": 249,
					"type": "text"
				},
				{
					"buffer": 54,
					"file": "src/Falcor/Utils/Sampling/SampleGenerator.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4312,
						"regions":
						{
						},
						"selection":
						[
							[
								4312,
								4312
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 277.0,
						"zoom_level": 1.0
					},
					"stack_index": 258,
					"type": "text"
				},
				{
					"buffer": 55,
					"file": "src/Falcor/Utils/SampleGenerators/StratifiedSamplePattern.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3466,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 357.0,
						"zoom_level": 1.0
					},
					"stack_index": 269,
					"type": "text"
				},
				{
					"buffer": 56,
					"file": "src/Falcor/Utils/SampleGenerators/HaltonSamplePattern.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3159,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 268,
					"type": "text"
				},
				{
					"buffer": 57,
					"file": "src/Falcor/Utils/SampleGenerators/CPUSampleGenerator.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2791,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 267,
					"type": "text"
				},
				{
					"buffer": 58,
					"file": "src/Falcor/Core/API/GraphicsStateObject.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6433,
						"regions":
						{
						},
						"selection":
						[
							[
								5115,
								5115
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 918.0,
						"zoom_level": 1.0
					},
					"stack_index": 297,
					"type": "text"
				},
				{
					"buffer": 59,
					"file": "src/Falcor/Core/API/GraphicsStateObject.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4274,
						"regions":
						{
						},
						"selection":
						[
							[
								4227,
								4227
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 734.0,
						"zoom_level": 1.0
					},
					"stack_index": 296,
					"type": "text"
				},
				{
					"buffer": 60,
					"file": "src/Falcor/Core/API/Vulkan/VKFbo.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5380,
						"regions":
						{
						},
						"selection":
						[
							[
								2311,
								2311
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1446.0,
						"zoom_level": 1.0
					},
					"stack_index": 178,
					"type": "text"
				},
				{
					"buffer": 61,
					"file": "src/Falcor/Core/API/ComputeStateObject.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3496,
						"regions":
						{
						},
						"selection":
						[
							[
								3496,
								3496
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 530.0,
						"zoom_level": 1.0
					},
					"stack_index": 300,
					"type": "text"
				},
				{
					"buffer": 62,
					"file": "src/Falcor/Experimental/Scene/Lights/EnvProbe.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6616,
						"regions":
						{
						},
						"selection":
						[
							[
								1791,
								1791
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 253,
					"type": "text"
				},
				{
					"buffer": 63,
					"file": "src/Falcor/Core/API/ComputeContext.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3969,
						"regions":
						{
						},
						"selection":
						[
							[
								3612,
								3612
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1071.0,
						"zoom_level": 1.0
					},
					"stack_index": 164,
					"type": "text"
				},
				{
					"buffer": 64,
					"file": "src/Falcor/Core/API/GpuTimer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3787,
						"regions":
						{
						},
						"selection":
						[
							[
								2467,
								2467
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 597.0,
						"zoom_level": 1.0
					},
					"stack_index": 330,
					"type": "text"
				},
				{
					"buffer": 65,
					"file": "src/Falcor/Core/API/LowLevelContextData.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3656,
						"regions":
						{
						},
						"selection":
						[
							[
								3566,
								3566
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 428.0,
						"zoom_level": 1.0
					},
					"stack_index": 317,
					"type": "text"
				},
				{
					"buffer": 66,
					"file": "src/Falcor/Utils/Timing/Profiler.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8484,
						"regions":
						{
						},
						"selection":
						[
							[
								6832,
								6832
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2244.0,
						"zoom_level": 1.0
					},
					"stack_index": 228,
					"type": "text"
				},
				{
					"buffer": 67,
					"file": "src/Falcor/Core/Platform/Windows/Windows.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 26025,
						"regions":
						{
						},
						"selection":
						[
							[
								25040,
								25040
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 11154.0,
						"zoom_level": 1.0
					},
					"stack_index": 481,
					"type": "text"
				},
				{
					"buffer": 68,
					"file": "third_party/slang/tools/gfx/d3d12/render-d3d12.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 139342,
						"regions":
						{
						},
						"selection":
						[
							[
								17858,
								17858
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 7779.0,
						"zoom_level": 1.0
					},
					"stack_index": 496,
					"type": "text"
				},
				{
					"buffer": 69,
					"file": "third_party/slang/tools/gfx/vulkan/render-vk.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 99401,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 7701.0,
						"zoom_level": 1.0
					},
					"stack_index": 495,
					"type": "text"
				},
				{
					"buffer": 70,
					"file": "src/Falcor/Raytracing/RtProgramVarsHelper.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6214,
						"regions":
						{
						},
						"selection":
						[
							[
								5889,
								5889
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1486.0,
						"zoom_level": 1.0
					},
					"stack_index": 403,
					"type": "text"
				},
				{
					"buffer": 71,
					"file": "src/Falcor/Core/API/D3D12/FalcorD3D12.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9709,
						"regions":
						{
						},
						"selection":
						[
							[
								1759,
								1759
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 497,
					"type": "text"
				},
				{
					"buffer": 72,
					"file": "src/Falcor/Core/Platform/OS.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8771,
						"regions":
						{
						},
						"selection":
						[
							[
								5508,
								5508
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 801.0,
						"zoom_level": 1.0
					},
					"stack_index": 458,
					"type": "text"
				},
				{
					"buffer": 73,
					"file": "src/RenderPasses/SkyBox/SkyBox.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2520,
						"regions":
						{
						},
						"selection":
						[
							[
								1900,
								1900
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 457,
					"type": "text"
				},
				{
					"buffer": 74,
					"file": "src/RenderPasses/CSM/VisibilityPass.ps.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2953,
						"regions":
						{
						},
						"selection":
						[
							[
								2130,
								2130
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 204.0,
						"zoom_level": 1.0
					},
					"stack_index": 377,
					"type": "text"
				},
				{
					"buffer": 75,
					"file": "src/RenderPasses/ToneMapper/ToneMapping.ps.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5616,
						"regions":
						{
						},
						"selection":
						[
							[
								2154,
								2154
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 153.0,
						"zoom_level": 1.0
					},
					"stack_index": 456,
					"type": "text"
				},
				{
					"buffer": 76,
					"file": "src/RenderPasses/ToneMapper/Luminance.ps.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2106,
						"regions":
						{
						},
						"selection":
						[
							[
								1729,
								1729
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 143,
					"type": "text"
				},
				{
					"buffer": 77,
					"file": "src/Falcor/Scene/Importers/PythonImporter.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3931,
						"regions":
						{
						},
						"selection":
						[
							[
								3536,
								3536
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 765.0,
						"zoom_level": 1.0
					},
					"stack_index": 279,
					"type": "text"
				},
				{
					"buffer": 78,
					"file": "src/Falcor/Scene/Importers/SceneImporter.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 36435,
						"regions":
						{
						},
						"selection":
						[
							[
								2727,
								2727
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1573.0,
						"zoom_level": 1.0
					},
					"stack_index": 284,
					"type": "text"
				},
				{
					"buffer": 79,
					"file": "src/Falcor/Scene/Importers/SceneImporter.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2157,
						"regions":
						{
						},
						"selection":
						[
							[
								1980,
								1980
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 255,
					"type": "text"
				},
				{
					"buffer": 80,
					"file": "src/Falcor/Core/Program/Program.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 12423,
						"regions":
						{
						},
						"selection":
						[
							[
								1815,
								1815
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 459.0,
						"zoom_level": 1.0
					},
					"stack_index": 171,
					"type": "text"
				},
				{
					"buffer": 81,
					"file": "src/Falcor/Core/Program/GraphicsProgram.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3809,
						"regions":
						{
						},
						"selection":
						[
							[
								3024,
								3024
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 275.0,
						"zoom_level": 1.0
					},
					"stack_index": 312,
					"type": "text"
				},
				{
					"buffer": 82,
					"file": "src/Falcor/Core/Program/ComputeProgram.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3818,
						"regions":
						{
						},
						"selection":
						[
							[
								2221,
								2221
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 171.0,
						"zoom_level": 1.0
					},
					"stack_index": 294,
					"type": "text"
				},
				{
					"buffer": 83,
					"file": "src/Falcor/Core/Program/GraphicsProgram.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2616,
						"regions":
						{
						},
						"selection":
						[
							[
								2229,
								2229
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 313,
					"type": "text"
				},
				{
					"buffer": 84,
					"file": "src/Falcor/Scene/Camera/Camera.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5388,
						"regions":
						{
						},
						"selection":
						[
							[
								4265,
								4265
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 391,
					"type": "text"
				},
				{
					"buffer": 85,
					"file": "src/Falcor/Utils/ArgList.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4051,
						"regions":
						{
						},
						"selection":
						[
							[
								1841,
								1841
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 396,
					"type": "text"
				},
				{
					"buffer": 86,
					"file": "src/Mogwai/Mogwai.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 25052,
						"regions":
						{
						},
						"selection":
						[
							[
								20090,
								20090
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 8340.0,
						"zoom_level": 1.0
					},
					"stack_index": 50,
					"type": "text"
				},
				{
					"buffer": 87,
					"file": "src/Mogwai/stdafx.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1851,
						"regions":
						{
						},
						"selection":
						[
							[
								1850,
								1850
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 488,
					"type": "text"
				},
				{
					"buffer": 88,
					"file": "src/Falcor/Core/Renderer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7238,
						"regions":
						{
						},
						"selection":
						[
							[
								5232,
								5232
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2509.0,
						"zoom_level": 1.0
					},
					"stack_index": 58,
					"type": "text"
				},
				{
					"buffer": 89,
					"file": "src/Falcor/RenderGraph/RenderPassLibrary.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11374,
						"regions":
						{
						},
						"selection":
						[
							[
								8250,
								8250
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2739.0,
						"zoom_level": 1.0
					},
					"stack_index": 81,
					"type": "text"
				},
				{
					"buffer": 90,
					"file": "src/Falcor/RenderGraph/RenderPassLibrary.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5360,
						"regions":
						{
						},
						"selection":
						[
							[
								3684,
								3684
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 944.0,
						"zoom_level": 1.0
					},
					"stack_index": 179,
					"type": "text"
				},
				{
					"buffer": 91,
					"file": "src/Falcor/Utils/UI/UserInput.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7116,
						"regions":
						{
						},
						"selection":
						[
							[
								1793,
								1793
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 396.0,
						"zoom_level": 1.0
					},
					"stack_index": 250,
					"type": "text"
				},
				{
					"buffer": 92,
					"file": "src/Externals/GLM/glm/gtx/compatibility.hpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14969,
						"regions":
						{
						},
						"selection":
						[
							[
								10757,
								10757
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 1029.0,
						"zoom_level": 1.0
					},
					"stack_index": 252,
					"type": "text"
				},
				{
					"buffer": 93,
					"file": "src/Falcor/Core/Sample.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7395,
						"regions":
						{
						},
						"selection":
						[
							[
								5619,
								5619
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1567.0,
						"zoom_level": 1.0
					},
					"stack_index": 59,
					"type": "text"
				},
				{
					"buffer": 94,
					"file": "src/Falcor/Utils/UI/Gui.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 26357,
						"regions":
						{
						},
						"selection":
						[
							[
								26237,
								26237
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1479.0,
						"zoom_level": 1.0
					},
					"stack_index": 63,
					"type": "text"
				},
				{
					"buffer": 95,
					"file": "src/Falcor/Core/Window.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 17937,
						"regions":
						{
						},
						"selection":
						[
							[
								12930,
								12930
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4933.0,
						"zoom_level": 1.0
					},
					"stack_index": 220,
					"type": "text"
				},
				{
					"buffer": 96,
					"file": "src/Falcor/Core/Window.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5627,
						"regions":
						{
						},
						"selection":
						[
							[
								4740,
								4740
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1282.0,
						"zoom_level": 1.0
					},
					"stack_index": 210,
					"type": "text"
				},
				{
					"buffer": 97,
					"file": "src/Falcor/Utils/ArgList.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6269,
						"regions":
						{
						},
						"selection":
						[
							[
								6268,
								6268
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1893.0,
						"zoom_level": 1.0
					},
					"stack_index": 395,
					"type": "text"
				},
				{
					"buffer": 98,
					"file": "src/Falcor/Utils/AlignedAllocator.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6544,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1479.0,
						"zoom_level": 1.0
					},
					"stack_index": 373,
					"type": "text"
				},
				{
					"buffer": 99,
					"file": "src/Falcor/Core/API/Resource.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7622,
						"regions":
						{
						},
						"selection":
						[
							[
								7023,
								7023
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1720.0,
						"zoom_level": 1.0
					},
					"stack_index": 208,
					"type": "text"
				},
				{
					"buffer": 100,
					"file": "src/Tools/FalcorTest/Tests/Core/BufferTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6996,
						"regions":
						{
						},
						"selection":
						[
							[
								1742,
								1742
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1978.0,
						"zoom_level": 1.0
					},
					"stack_index": 432,
					"type": "text"
				},
				{
					"buffer": 101,
					"file": "src/Tools/FalcorTest/Tests/DebugPasses/InvalidPixelDetectionTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3746,
						"regions":
						{
						},
						"selection":
						[
							[
								2971,
								2971
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 88.0,
						"zoom_level": 1.0
					},
					"stack_index": 382,
					"type": "text"
				},
				{
					"buffer": 102,
					"file": "src/Tools/FalcorTest/Tests/ShadingUtils/ShadingUtilsTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 12331,
						"regions":
						{
						},
						"selection":
						[
							[
								12306,
								12306
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 452,
					"type": "text"
				},
				{
					"buffer": 103,
					"file": "src/Falcor/Testing/UnitTest.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 18208,
						"regions":
						{
						},
						"selection":
						[
							[
								4230,
								4230
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1303.0,
						"zoom_level": 1.0
					},
					"stack_index": 277,
					"type": "text"
				},
				{
					"buffer": 104,
					"file": "src/Falcor/Testing/UnitTest.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11972,
						"regions":
						{
						},
						"selection":
						[
							[
								11972,
								11972
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4227.0,
						"zoom_level": 1.0
					},
					"stack_index": 276,
					"type": "text"
				},
				{
					"buffer": 105,
					"file": "src/Falcor/Core/Program/ComputeProgram.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2634,
						"regions":
						{
						},
						"selection":
						[
							[
								2219,
								2219
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 190,
					"type": "text"
				},
				{
					"buffer": 106,
					"file": "src/Tools/FalcorTest/Tests/Core/BufferAccessTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6233,
						"regions":
						{
						},
						"selection":
						[
							[
								4566,
								4566
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 357.0,
						"zoom_level": 1.0
					},
					"stack_index": 433,
					"type": "text"
				},
				{
					"buffer": 107,
					"file": "src/Tools/FalcorTest/Tests/Core/BufferAccessTests.cs.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1913,
						"regions":
						{
						},
						"selection":
						[
							[
								1913,
								1913
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 437,
					"type": "text"
				},
				{
					"buffer": 108,
					"file": "src/Falcor/Core/API/Resource.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5154,
						"regions":
						{
						},
						"selection":
						[
							[
								4887,
								4887
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 202,
					"type": "text"
				},
				{
					"buffer": 109,
					"file": "src/Falcor/Core/API/RenderContext.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11441,
						"regions":
						{
						},
						"selection":
						[
							[
								11026,
								11026
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2754.0,
						"zoom_level": 1.0
					},
					"stack_index": 165,
					"type": "text"
				},
				{
					"buffer": 110,
					"file": "src/Falcor/Core/API/RenderContext.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5362,
						"regions":
						{
						},
						"selection":
						[
							[
								2053,
								2053
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 520.0,
						"zoom_level": 1.0
					},
					"stack_index": 57,
					"type": "text"
				},
				{
					"buffer": 111,
					"file": "src/Falcor/Core/API/RasterizerState.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7490,
						"regions":
						{
						},
						"selection":
						[
							[
								1841,
								1841
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2300.0,
						"zoom_level": 1.0
					},
					"stack_index": 401,
					"type": "text"
				},
				{
					"buffer": 112,
					"file": "src/Falcor/Core/API/RasterizerState.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2247,
						"regions":
						{
						},
						"selection":
						[
							[
								1768,
								1768
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 402,
					"type": "text"
				},
				{
					"buffer": 113,
					"file": "src/Falcor/Core/API/Vulkan/VKRasterizerState.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2034,
						"regions":
						{
						},
						"selection":
						[
							[
								1761,
								1761
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 409,
					"type": "text"
				},
				{
					"buffer": 114,
					"file": "src/Falcor/Core/API/QueryHeap.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3579,
						"regions":
						{
						},
						"selection":
						[
							[
								2529,
								2529
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 377.0,
						"zoom_level": 1.0
					},
					"stack_index": 204,
					"type": "text"
				},
				{
					"buffer": 115,
					"file": "src/Falcor/Core/API/Formats.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13822,
						"regions":
						{
						},
						"selection":
						[
							[
								12301,
								12301
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 5661.0,
						"zoom_level": 1.0
					},
					"stack_index": 326,
					"type": "text"
				},
				{
					"buffer": 116,
					"file": "src/Falcor/Core/API/Buffer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 19243,
						"regions":
						{
						},
						"selection":
						[
							[
								10640,
								10640
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2043.0,
						"zoom_level": 1.0
					},
					"stack_index": 207,
					"type": "text"
				},
				{
					"buffer": 117,
					"file": "src/Falcor/Experimental/Scene/Lights/EnvProbe.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3717,
						"regions":
						{
						},
						"selection":
						[
							[
								3676,
								3676
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 204.0,
						"zoom_level": 1.0
					},
					"stack_index": 289,
					"type": "text"
				},
				{
					"buffer": 118,
					"file": "src/Mogwai/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1908,
						"regions":
						{
						},
						"selection":
						[
							[
								1509,
								1509
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 153.0,
						"zoom_level": 1.0
					},
					"stack_index": 27,
					"type": "text"
				},
				{
					"buffer": 119,
					"file": "src/Mogwai/Extensions/Capture/CaptureTrigger.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7579,
						"regions":
						{
						},
						"selection":
						[
							[
								7161,
								7161
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1381.0,
						"zoom_level": 1.0
					},
					"stack_index": 69,
					"type": "text"
				},
				{
					"buffer": 120,
					"file": "src/Mogwai/Extensions/Capture/VideoCapture.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9661,
						"regions":
						{
						},
						"selection":
						[
							[
								2501,
								2501
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 340.0,
						"zoom_level": 1.0
					},
					"stack_index": 60,
					"type": "text"
				},
				{
					"buffer": 121,
					"file": "src/Mogwai/Extensions/Capture/FrameCapture.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6569,
						"regions":
						{
						},
						"selection":
						[
							[
								5593,
								5593
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1653.0,
						"zoom_level": 1.0
					},
					"stack_index": 55,
					"type": "text"
				},
				{
					"buffer": 122,
					"file": "src/Mogwai/Extensions/Capture/FrameCapture.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2710,
						"regions":
						{
						},
						"selection":
						[
							[
								1765,
								1765
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 56,
					"type": "text"
				},
				{
					"buffer": 123,
					"file": "src/Tools/RenderGraphEditor/RenderGraphEditor.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 20776,
						"regions":
						{
						},
						"selection":
						[
							[
								20445,
								20445
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 191,
					"type": "text"
				},
				{
					"buffer": 124,
					"file": "src/Externals/dear_imgui_addons/imguinodegrapheditor/imguinodegrapheditor.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 47853,
						"regions":
						{
						},
						"selection":
						[
							[
								23852,
								23852
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 6018.0,
						"zoom_level": 1.0
					},
					"stack_index": 482,
					"type": "text"
				},
				{
					"buffer": 125,
					"file": "src/Tools/ImageCompare/ImageCompare.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14050,
						"regions":
						{
						},
						"selection":
						[
							[
								13223,
								13223
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 6069.0,
						"zoom_level": 1.0
					},
					"stack_index": 478,
					"type": "text"
				},
				{
					"buffer": 126,
					"file": "src/Mogwai/Mogwai.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8364,
						"regions":
						{
						},
						"selection":
						[
							[
								4167,
								4167
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1540.0,
						"zoom_level": 1.0
					},
					"stack_index": 61,
					"type": "text"
				},
				{
					"buffer": 127,
					"file": "src/Falcor/RenderGraph/RenderGraphImportExport.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6264,
						"regions":
						{
						},
						"selection":
						[
							[
								2379,
								2379
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2182.0,
						"zoom_level": 1.0
					},
					"stack_index": 480,
					"type": "text"
				},
				{
					"buffer": 128,
					"file": "src/Falcor/RenderGraph/ResourceCache.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8382,
						"regions":
						{
						},
						"selection":
						[
							[
								1783,
								1783
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 287,
					"type": "text"
				},
				{
					"buffer": 129,
					"file": "src/Falcor/Scene/Animation/AnimationController.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13034,
						"regions":
						{
						},
						"selection":
						[
							[
								11190,
								11190
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3009.0,
						"zoom_level": 1.0
					},
					"stack_index": 237,
					"type": "text"
				},
				{
					"buffer": 130,
					"file": "src/Falcor/RenderGraph/RenderPassReflection.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 12090,
						"regions":
						{
						},
						"selection":
						[
							[
								9644,
								9644
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2113.0,
						"zoom_level": 1.0
					},
					"stack_index": 188,
					"type": "text"
				},
				{
					"buffer": 131,
					"file": "src/Falcor/RenderGraph/RenderPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2471,
						"regions":
						{
						},
						"selection":
						[
							[
								2428,
								2428
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 357.0,
						"zoom_level": 1.0
					},
					"stack_index": 83,
					"type": "text"
				},
				{
					"buffer": 132,
					"file": "src/Falcor/RenderPasses/ResolvePass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2717,
						"regions":
						{
						},
						"selection":
						[
							[
								2610,
								2610
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 154.0,
						"zoom_level": 1.0
					},
					"stack_index": 105,
					"type": "text"
				},
				{
					"buffer": 133,
					"file": "src/Falcor/RenderPasses/ResolvePass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3142,
						"regions":
						{
						},
						"selection":
						[
							[
								2562,
								2562
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 341.0,
						"zoom_level": 1.0
					},
					"stack_index": 104,
					"type": "text"
				},
				{
					"buffer": 134,
					"file": "src/Falcor/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5056,
						"regions":
						{
						},
						"selection":
						[
							[
								1443,
								1443
							]
						],
						"settings":
						{
							"auto_name": "file( GLOB SOURCES",
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2329.0,
						"zoom_level": 1.0
					},
					"stack_index": 26,
					"type": "text"
				},
				{
					"buffer": 135,
					"file": "src/Falcor/Scene/ParticleSystem/ParticleSystem.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10438,
						"regions":
						{
						},
						"selection":
						[
							[
								10145,
								10145
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3060.0,
						"zoom_level": 1.0
					},
					"stack_index": 280,
					"type": "text"
				},
				{
					"buffer": 136,
					"file": "src/Falcor/Scene/ParticleSystem/ParticleSystem.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 16405,
						"regions":
						{
						},
						"selection":
						[
							[
								7935,
								7935
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2235.0,
						"zoom_level": 1.0
					},
					"stack_index": 149,
					"type": "text"
				},
				{
					"buffer": 137,
					"file": "src/Falcor/Scene/HitInfo.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3622,
						"regions":
						{
						},
						"selection":
						[
							[
								3622,
								3622
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 257,
					"type": "text"
				},
				{
					"buffer": 138,
					"file": "src/Samples/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1201,
						"regions":
						{
						},
						"selection":
						[
							[
								1105,
								1105
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 477,
					"type": "text"
				},
				{
					"buffer": 139,
					"file": "src/Tools/RenderGraphEditor/RenderGraphEditor.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3325,
						"regions":
						{
						},
						"selection":
						[
							[
								1883,
								1883
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 357.0,
						"zoom_level": 1.0
					},
					"stack_index": 192,
					"type": "text"
				},
				{
					"buffer": 140,
					"file": "src/RenderPasses/DebugPasses/DebugPasses.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2422,
						"regions":
						{
						},
						"selection":
						[
							[
								2305,
								2305
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 80,
					"type": "text"
				},
				{
					"buffer": 141,
					"file": "src/RenderPasses/DebugPasses/SplitScreenPass/SplitScreenPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3241,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 357.0,
						"zoom_level": 1.0
					},
					"stack_index": 79,
					"type": "text"
				},
				{
					"buffer": 142,
					"file": "src/RenderPasses/DebugPasses/SplitScreenPass/SplitScreenPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6309,
						"regions":
						{
						},
						"selection":
						[
							[
								4169,
								4169
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1721.0,
						"zoom_level": 1.0
					},
					"stack_index": 78,
					"type": "text"
				},
				{
					"buffer": 143,
					"file": "src/RenderPasses/DebugPasses/SideBySidePass/SideBySidePass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2670,
						"regions":
						{
						},
						"selection":
						[
							[
								2484,
								2484
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 255.0,
						"zoom_level": 1.0
					},
					"stack_index": 76,
					"type": "text"
				},
				{
					"buffer": 144,
					"file": "src/RenderPasses/DebugPasses/SideBySidePass/SideBySidePass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3143,
						"regions":
						{
						},
						"selection":
						[
							[
								2603,
								2603
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 459.0,
						"zoom_level": 1.0
					},
					"stack_index": 77,
					"type": "text"
				},
				{
					"buffer": 145,
					"file": "src/RenderPasses/DebugPasses/InvalidPixelDetectionPass/InvalidPixelDetectionPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2841,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 357.0,
						"zoom_level": 1.0
					},
					"stack_index": 75,
					"type": "text"
				},
				{
					"buffer": 146,
					"file": "src/RenderPasses/CSM/CSM.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9053,
						"regions":
						{
						},
						"selection":
						[
							[
								9018,
								9018
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2587.0,
						"zoom_level": 1.0
					},
					"stack_index": 129,
					"type": "text"
				},
				{
					"buffer": 147,
					"file": "src/RenderPasses/CSM/CSM.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 35619,
						"regions":
						{
						},
						"selection":
						[
							[
								34358,
								34358
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3480.0,
						"zoom_level": 1.0
					},
					"stack_index": 128,
					"type": "text"
				},
				{
					"buffer": 148,
					"file": "src/Falcor/Utils/UI/Gui.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2501,
						"regions":
						{
						},
						"selection":
						[
							[
								1773,
								1773
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 484,
					"type": "text"
				},
				{
					"buffer": 149,
					"file": "src/Falcor/Utils/UI/TextRenderer.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2282,
						"regions":
						{
						},
						"selection":
						[
							[
								1872,
								1872
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 374,
					"type": "text"
				},
				{
					"buffer": 150,
					"file": "src/RenderPasses/ErrorMeasurePass/ErrorMeasurePass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 16583,
						"regions":
						{
						},
						"selection":
						[
							[
								4855,
								4855
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1245.0,
						"zoom_level": 1.0
					},
					"stack_index": 87,
					"type": "text"
				},
				{
					"buffer": 151,
					"file": "src/RenderPasses/GBuffer/VBuffer/VBufferRaster.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3145,
						"regions":
						{
						},
						"selection":
						[
							[
								2158,
								2158
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 357.0,
						"zoom_level": 1.0
					},
					"stack_index": 124,
					"type": "text"
				},
				{
					"buffer": 152,
					"file": "src/RenderPasses/ErrorMeasurePass/ErrorMeasurePass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4985,
						"regions":
						{
						},
						"selection":
						[
							[
								2890,
								2890
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 561.0,
						"zoom_level": 1.0
					},
					"stack_index": 88,
					"type": "text"
				},
				{
					"buffer": 153,
					"file": "src/RenderPasses/PixelInspectorPass/PixelInspectorPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3691,
						"regions":
						{
						},
						"selection":
						[
							[
								3621,
								3621
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 561.0,
						"zoom_level": 1.0
					},
					"stack_index": 97,
					"type": "text"
				},
				{
					"buffer": 154,
					"file": "src/Falcor/RenderGraph/RenderPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7147,
						"regions":
						{
						},
						"selection":
						[
							[
								7101,
								7101
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2056.0,
						"zoom_level": 1.0
					},
					"stack_index": 126,
					"type": "text"
				},
				{
					"buffer": 155,
					"file": "src/RenderPasses/PixelInspectorPass/PixelInspectorPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15137,
						"regions":
						{
						},
						"selection":
						[
							[
								3993,
								3993
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 837.0,
						"zoom_level": 1.0
					},
					"stack_index": 120,
					"type": "text"
				},
				{
					"buffer": 156,
					"file": "src/RenderPasses/SSAO/SSAO.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4594,
						"regions":
						{
						},
						"selection":
						[
							[
								4594,
								4594
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 612.0,
						"zoom_level": 1.0
					},
					"stack_index": 112,
					"type": "text"
				},
				{
					"buffer": 157,
					"file": "src/RenderPasses/SkyBox/SkyBox.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3515,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 51.0,
						"zoom_level": 1.0
					},
					"stack_index": 113,
					"type": "text"
				},
				{
					"buffer": 158,
					"file": "src/RenderPasses/SkyBox/SkyBox.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8117,
						"regions":
						{
						},
						"selection":
						[
							[
								2934,
								2934
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1275.0,
						"zoom_level": 1.0
					},
					"stack_index": 119,
					"type": "text"
				},
				{
					"buffer": 159,
					"file": "src/RenderPasses/Antialiasing/FXAA/FXAA.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3484,
						"regions":
						{
						},
						"selection":
						[
							[
								3429,
								3429
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 816.0,
						"zoom_level": 1.0
					},
					"stack_index": 94,
					"type": "text"
				},
				{
					"buffer": 160,
					"file": "src/RenderPasses/Antialiasing/TAA/TAA.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3271,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 102.0,
						"zoom_level": 1.0
					},
					"stack_index": 131,
					"type": "text"
				},
				{
					"buffer": 161,
					"file": "src/RenderPasses/Antialiasing/TAA/TAA.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5491,
						"regions":
						{
						},
						"selection":
						[
							[
								2176,
								2176
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 327.0,
						"zoom_level": 1.0
					},
					"stack_index": 89,
					"type": "text"
				},
				{
					"buffer": 162,
					"file": "src/RenderPasses/Antialiasing/FXAA/FXAA.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4663,
						"regions":
						{
						},
						"selection":
						[
							[
								2273,
								2273
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 408.0,
						"zoom_level": 1.0
					},
					"stack_index": 132,
					"type": "text"
				},
				{
					"buffer": 163,
					"file": "src/RenderPasses/SkyBox/Data/cube.obj",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 401,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 459,
					"type": "text"
				},
				{
					"buffer": 164,
					"file": "src/RenderPasses/ForwardLightingPass/ForwardLightingPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4770,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 102.0,
						"zoom_level": 1.0
					},
					"stack_index": 116,
					"type": "text"
				},
				{
					"buffer": 165,
					"file": "src/RenderPasses/ForwardLightingPass/ForwardLightingPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9795,
						"regions":
						{
						},
						"selection":
						[
							[
								3751,
								3751
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 716.0,
						"zoom_level": 1.0
					},
					"stack_index": 125,
					"type": "text"
				},
				{
					"buffer": 166,
					"file": "src/RenderPasses/ImageLoader/ImageLoader.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3059,
						"regions":
						{
						},
						"selection":
						[
							[
								2992,
								2992
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 408.0,
						"zoom_level": 1.0
					},
					"stack_index": 102,
					"type": "text"
				},
				{
					"buffer": 167,
					"file": "src/RenderPasses/ImageLoader/ImageLoader.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5146,
						"regions":
						{
						},
						"selection":
						[
							[
								3757,
								3757
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 616.0,
						"zoom_level": 1.0
					},
					"stack_index": 103,
					"type": "text"
				},
				{
					"buffer": 168,
					"file": "src/RenderPasses/ToneMapper/ToneMapper.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5743,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 209.0,
						"zoom_level": 1.0
					},
					"stack_index": 107,
					"type": "text"
				},
				{
					"buffer": 169,
					"file": "src/RenderPasses/ToneMapper/ToneMapper.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 16343,
						"regions":
						{
						},
						"selection":
						[
							[
								6646,
								6646
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1653.0,
						"zoom_level": 1.0
					},
					"stack_index": 96,
					"type": "text"
				},
				{
					"buffer": 170,
					"file": "src/RenderPasses/AccumulatePass/AccumulatePass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10962,
						"regions":
						{
						},
						"selection":
						[
							[
								4424,
								4424
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1005.0,
						"zoom_level": 1.0
					},
					"stack_index": 82,
					"type": "text"
				},
				{
					"buffer": 171,
					"file": "src/RenderPasses/GBuffer/GBufferBase.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3832,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 51.0,
						"zoom_level": 1.0
					},
					"stack_index": 95,
					"type": "text"
				},
				{
					"buffer": 172,
					"file": "src/RenderPasses/GBuffer/GBufferBase.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6981,
						"regions":
						{
						},
						"selection":
						[
							[
								5540,
								5540
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1674.0,
						"zoom_level": 1.0
					},
					"stack_index": 71,
					"type": "text"
				},
				{
					"buffer": 173,
					"file": "src/Falcor/Utils/SampleGenerators/HaltonSamplePattern.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2647,
						"regions":
						{
						},
						"selection":
						[
							[
								2237,
								2237
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 271,
					"type": "text"
				},
				{
					"buffer": 174,
					"file": "src/RenderPasses/GBuffer/VBuffer/VBufferRT.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2997,
						"regions":
						{
						},
						"selection":
						[
							[
								2997,
								2997
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 114,
					"type": "text"
				},
				{
					"buffer": 175,
					"file": "src/RenderPasses/GBuffer/GBuffer/GBufferRaster.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10032,
						"regions":
						{
						},
						"selection":
						[
							[
								4532,
								4532
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1428.0,
						"zoom_level": 1.0
					},
					"stack_index": 92,
					"type": "text"
				},
				{
					"buffer": 176,
					"file": "src/RenderPasses/GBuffer/GBuffer/GBufferRaster.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3272,
						"regions":
						{
						},
						"selection":
						[
							[
								2031,
								2031
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 256.0,
						"zoom_level": 1.0
					},
					"stack_index": 121,
					"type": "text"
				},
				{
					"buffer": 177,
					"file": "src/RenderPasses/GBuffer/GBuffer/GBuffer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3324,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 255.0,
						"zoom_level": 1.0
					},
					"stack_index": 91,
					"type": "text"
				},
				{
					"buffer": 178,
					"file": "src/RenderPasses/GBuffer/GBuffer/GBuffer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5817,
						"regions":
						{
						},
						"selection":
						[
							[
								5727,
								5727
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1313.0,
						"zoom_level": 1.0
					},
					"stack_index": 90,
					"type": "text"
				},
				{
					"buffer": 179,
					"file": "src/RenderPasses/DepthPass/DepthPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5276,
						"regions":
						{
						},
						"selection":
						[
							[
								3373,
								3373
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 686.0,
						"zoom_level": 1.0
					},
					"stack_index": 98,
					"type": "text"
				},
				{
					"buffer": 180,
					"file": "src/RenderPasses/Utils/GaussianBlur/GaussianBlur.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8197,
						"regions":
						{
						},
						"selection":
						[
							[
								2361,
								2361
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 412.0,
						"zoom_level": 1.0
					},
					"stack_index": 117,
					"type": "text"
				},
				{
					"buffer": 181,
					"file": "src/RenderPasses/SSAO/SSAO.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11813,
						"regions":
						{
						},
						"selection":
						[
							[
								3849,
								3849
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2452.0,
						"zoom_level": 1.0
					},
					"stack_index": 111,
					"type": "text"
				},
				{
					"buffer": 182,
					"file": "src/RenderPasses/Utils/GaussianBlur/GaussianBlur.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3739,
						"regions":
						{
						},
						"selection":
						[
							[
								3739,
								3739
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 918.0,
						"zoom_level": 1.0
					},
					"stack_index": 106,
					"type": "text"
				},
				{
					"buffer": 183,
					"file": "src/RenderPasses/Utils/Composite/Composite.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4310,
						"regions":
						{
						},
						"selection":
						[
							[
								2255,
								2255
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 157.0,
						"zoom_level": 1.0
					},
					"stack_index": 100,
					"type": "text"
				},
				{
					"buffer": 184,
					"file": "src/RenderPasses/TemporalDelayPass/TemporalDelayPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2910,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 306.0,
						"zoom_level": 1.0
					},
					"stack_index": 108,
					"type": "text"
				},
				{
					"buffer": 185,
					"file": "src/RenderPasses/Utils/Composite/Composite.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3098,
						"regions":
						{
						},
						"selection":
						[
							[
								3040,
								3040
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 408.0,
						"zoom_level": 1.0
					},
					"stack_index": 99,
					"type": "text"
				},
				{
					"buffer": 186,
					"file": "src/RenderPasses/DepthPass/DepthPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3513,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 127,
					"type": "text"
				},
				{
					"buffer": 187,
					"file": "src/RenderPasses/GBuffer/GBuffer/GBufferRT.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3771,
						"regions":
						{
						},
						"selection":
						[
							[
								1726,
								1726
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 51.0,
						"zoom_level": 1.0
					},
					"stack_index": 115,
					"type": "text"
				},
				{
					"buffer": 188,
					"file": "src/RenderPasses/GBuffer/VBuffer/VBufferRT.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5767,
						"regions":
						{
						},
						"selection":
						[
							[
								1771,
								1771
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 153.0,
						"zoom_level": 1.0
					},
					"stack_index": 485,
					"type": "text"
				},
				{
					"buffer": 189,
					"file": "src/RenderPasses/GBuffer/VBuffer/VBufferRaster.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5672,
						"regions":
						{
						},
						"selection":
						[
							[
								2920,
								2920
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 510.0,
						"zoom_level": 1.0
					},
					"stack_index": 123,
					"type": "text"
				},
				{
					"buffer": 190,
					"file": "src/RenderPasses/GBuffer/GBuffer/GBufferRT.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9623,
						"regions":
						{
						},
						"selection":
						[
							[
								9623,
								9623
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2721.0,
						"zoom_level": 1.0
					},
					"stack_index": 122,
					"type": "text"
				},
				{
					"buffer": 191,
					"file": "src/RenderPasses/Antialiasing/Antialiasing.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2797,
						"regions":
						{
						},
						"selection":
						[
							[
								2797,
								2797
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 255.0,
						"zoom_level": 1.0
					},
					"stack_index": 93,
					"type": "text"
				},
				{
					"buffer": 192,
					"file": "src/RenderPasses/BlitPass/BlitPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3995,
						"regions":
						{
						},
						"selection":
						[
							[
								3459,
								3459
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 867.0,
						"zoom_level": 1.0
					},
					"stack_index": 101,
					"type": "text"
				},
				{
					"buffer": 193,
					"file": "src/RenderPasses/BSDFViewer/BSDFViewer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4475,
						"regions":
						{
						},
						"selection":
						[
							[
								4420,
								4420
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1020.0,
						"zoom_level": 1.0
					},
					"stack_index": 85,
					"type": "text"
				},
				{
					"buffer": 194,
					"file": "src/RenderPasses/SVGFPass/SVGFPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 19004,
						"regions":
						{
						},
						"selection":
						[
							[
								4186,
								4186
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1518.0,
						"zoom_level": 1.0
					},
					"stack_index": 118,
					"type": "text"
				},
				{
					"buffer": 195,
					"file": "src/RenderPasses/TemporalDelayPass/TemporalDelayPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6201,
						"regions":
						{
						},
						"selection":
						[
							[
								2572,
								2572
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1245.0,
						"zoom_level": 1.0
					},
					"stack_index": 109,
					"type": "text"
				},
				{
					"buffer": 196,
					"file": "src/RenderPasses/SVGFPass/SVGFPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4664,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 110,
					"type": "text"
				},
				{
					"buffer": 197,
					"file": "src/RenderPasses/BSDFViewer/BSDFViewer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 18949,
						"regions":
						{
						},
						"selection":
						[
							[
								4324,
								4324
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1262.0,
						"zoom_level": 1.0
					},
					"stack_index": 86,
					"type": "text"
				},
				{
					"buffer": 198,
					"file": "src/RenderPasses/DebugPasses/ComparisonPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3286,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 408.0,
						"zoom_level": 1.0
					},
					"stack_index": 74,
					"type": "text"
				},
				{
					"buffer": 199,
					"file": "src/RenderPasses/DebugPasses/ComparisonPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5212,
						"regions":
						{
						},
						"selection":
						[
							[
								4572,
								4572
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 497.0,
						"zoom_level": 1.0
					},
					"stack_index": 73,
					"type": "text"
				},
				{
					"buffer": 200,
					"file": "src/RenderPasses/BlitPass/BlitPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2955,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 408.0,
						"zoom_level": 1.0
					},
					"stack_index": 130,
					"type": "text"
				},
				{
					"buffer": 201,
					"file": "src/RenderPasses/AccumulatePass/AccumulatePass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5448,
						"regions":
						{
						},
						"selection":
						[
							[
								3628,
								3628
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 561.0,
						"zoom_level": 1.0
					},
					"stack_index": 84,
					"type": "text"
				},
				{
					"buffer": 202,
					"file": "CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3791,
						"regions":
						{
						},
						"selection":
						[
							[
								3558,
								3558
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1530.0,
						"zoom_level": 1.0
					},
					"stack_index": 21,
					"type": "text"
				},
				{
					"buffer": 203,
					"file": "src/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 291,
						"regions":
						{
						},
						"selection":
						[
							[
								154,
								154
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 24,
					"type": "text"
				},
				{
					"buffer": 204,
					"file": "src/pxr/imaging/plugin/hdLava/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1250,
						"regions":
						{
						},
						"selection":
						[
							[
								606,
								606
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 11,
					"type": "text"
				},
				{
					"buffer": 205,
					"file": "src/pxr/imaging/plugin/hdLava/renderBuffer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2239,
						"regions":
						{
						},
						"selection":
						[
							[
								859,
								859
							]
						],
						"settings":
						{
							"auto_name": "/*************************************************",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 51.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 206,
					"file": "src/pxr/imaging/plugin/hdLava/renderBuffer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3529,
						"regions":
						{
						},
						"selection":
						[
							[
								1789,
								1789
							]
						],
						"settings":
						{
							"auto_name": "/*************************************************",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 102.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 207,
					"file": "src/pxr/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1818,
						"regions":
						{
						},
						"selection":
						[
							[
								1742,
								1742
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 23,
					"type": "text"
				},
				{
					"buffer": 208,
					"file": "cmake/modules/FindTBB.cmake",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 12566,
						"regions":
						{
						},
						"selection":
						[
							[
								9627,
								9627
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4488.0,
						"zoom_level": 1.0
					},
					"stack_index": 22,
					"type": "text"
				},
				{
					"buffer": 209,
					"file": "cmake/defaults/Packages.cmake",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7991,
						"regions":
						{
						},
						"selection":
						[
							[
								4095,
								4095
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1377.0,
						"zoom_level": 1.0
					},
					"stack_index": 20,
					"type": "text"
				},
				{
					"buffer": 210,
					"file": "src/pxr/imaging/plugin/hdLava/renderDelegate.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3280,
						"regions":
						{
						},
						"selection":
						[
							[
								1870,
								1870
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 153.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 211,
					"file": "src/pxr/imaging/plugin/hdLava/renderParam.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1756,
						"regions":
						{
						},
						"selection":
						[
							[
								690,
								690
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 212,
					"file": "src/pxr/imaging/plugin/hdLava/rendererPlugin.h",
					"semi_transient": true,
					"settings":
					{
						"buffer_size": 1809,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 213,
					"file": "src/pxr/imaging/plugin/hdLava/renderPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2971,
						"regions":
						{
						},
						"selection":
						[
							[
								1552,
								1552
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 357.0,
						"zoom_level": 1.0
					},
					"stack_index": 18,
					"type": "text"
				},
				{
					"buffer": 214,
					"file": "src/pxr/imaging/plugin/hdLava/camera.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2562,
						"regions":
						{
						},
						"selection":
						[
							[
								2562,
								2562
							]
						],
						"settings":
						{
							"auto_name": "/*************************************************",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 17,
					"type": "text"
				},
				{
					"buffer": 215,
					"file": "src/pxr/imaging/plugin/hdLava/camera.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6546,
						"regions":
						{
						},
						"selection":
						[
							[
								2739,
								2739
							]
						],
						"settings":
						{
							"auto_name": "/*************************************************",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 102.0,
						"zoom_level": 1.0
					},
					"stack_index": 16,
					"type": "text"
				},
				{
					"buffer": 216,
					"file": "src/pxr/imaging/plugin/hdLava/renderParam.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1800,
						"regions":
						{
						},
						"selection":
						[
							[
								435,
								435
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 19,
					"type": "text"
				},
				{
					"buffer": 217,
					"file": "src/pxr/imaging/plugin/hdLava/renderDelegate.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14313,
						"regions":
						{
						},
						"selection":
						[
							[
								6800,
								6800
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2958.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 218,
					"file": "src/pxr/imaging/plugin/hdLava/config.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 26025,
						"regions":
						{
						},
						"selection":
						[
							[
								3674,
								3674
							]
						],
						"settings":
						{
							"auto_name": "//",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1479.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 219,
					"file": "src/pxr/imaging/plugin/hdLava/config.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7104,
						"regions":
						{
						},
						"selection":
						[
							[
								188,
								188
							]
						],
						"settings":
						{
							"auto_name": "//",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1683.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 220,
					"file": "src/pxr/imaging/plugin/hdLava/renderPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 679,
						"regions":
						{
						},
						"selection":
						[
							[
								679,
								679
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 10,
					"type": "text"
				},
				{
					"buffer": 221,
					"file": "src/pxr/imaging/plugin/hdLava/lavaApi.h.old",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6854,
						"regions":
						{
						},
						"selection":
						[
							[
								1210,
								1210
							]
						],
						"settings":
						{
							"auto_name": "/*************************************************",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 821.0,
						"zoom_level": 1.0
					},
					"stack_index": 15,
					"type": "text"
				},
				{
					"buffer": 222,
					"file": "src/pxr/imaging/plugin/hdLava/lavaApi.cpp.old",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 113965,
						"regions":
						{
						},
						"selection":
						[
							[
								6793,
								6793
							]
						],
						"settings":
						{
							"auto_name": "/*************************************************",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 22296.0,
						"zoom_level": 1.0
					},
					"stack_index": 14,
					"type": "text"
				},
				{
					"buffer": 223,
					"file": "src/pxr/imaging/plugin/hdLava/lavaApi.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2382,
						"regions":
						{
						},
						"selection":
						[
							[
								2087,
								2087
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 816.0,
						"zoom_level": 1.0
					},
					"stack_index": 13,
					"type": "text"
				},
				{
					"buffer": 224,
					"file": "src/pxr/imaging/plugin/hdLava/lavaApi.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 21681,
						"regions":
						{
						},
						"selection":
						[
							[
								20808,
								20808
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 9979.0,
						"zoom_level": 1.0
					},
					"stack_index": 12,
					"type": "text"
				},
				{
					"buffer": 225,
					"file": "src/Falcor/Utils/StringUtils.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 12635,
						"regions":
						{
						},
						"selection":
						[
							[
								12119,
								12119
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4699.0,
						"zoom_level": 1.0
					},
					"stack_index": 398,
					"type": "text"
				},
				{
					"buffer": 226,
					"file": "src/Samples/ModelViewer/ModelViewer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9979,
						"regions":
						{
						},
						"selection":
						[
							[
								3916,
								3916
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2397.0,
						"zoom_level": 1.0
					},
					"stack_index": 473,
					"type": "text"
				},
				{
					"buffer": 227,
					"file": "src/Samples/ModelViewer/ModelViewer.ps.slang.bak",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2408,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 462,
					"type": "text"
				},
				{
					"buffer": 228,
					"file": "src/Samples/ModelViewer/ModelViewer.ps.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2391,
						"regions":
						{
						},
						"selection":
						[
							[
								2383,
								2383
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 460,
					"type": "text"
				},
				{
					"buffer": 229,
					"file": "src/Falcor/Scene/Lights/LightProbeIntegration.ps.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7921,
						"regions":
						{
						},
						"selection":
						[
							[
								1944,
								1944
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 116.0,
						"zoom_level": 1.0
					},
					"stack_index": 470,
					"type": "text"
				},
				{
					"buffer": 230,
					"file": "src/Tools/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1429,
						"regions":
						{
						},
						"selection":
						[
							[
								1133,
								1133
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 468,
					"type": "text"
				},
				{
					"buffer": 231,
					"file": "src/Samples/ShaderToy/ShaderToy.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4229,
						"regions":
						{
						},
						"selection":
						[
							[
								4138,
								4138
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 482.0,
						"zoom_level": 1.0
					},
					"stack_index": 469,
					"type": "text"
				},
				{
					"buffer": 232,
					"file": "src/Falcor/RenderGraph/BasePasses/FullScreenPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5700,
						"regions":
						{
						},
						"selection":
						[
							[
								4350,
								4350
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1555.0,
						"zoom_level": 1.0
					},
					"stack_index": 142,
					"type": "text"
				},
				{
					"buffer": 233,
					"file": "src/Falcor/RenderGraph/BasePasses/ComputePass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6377,
						"regions":
						{
						},
						"selection":
						[
							[
								6233,
								6233
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1326.0,
						"zoom_level": 1.0
					},
					"stack_index": 139,
					"type": "text"
				},
				{
					"buffer": 234,
					"file": "src/Falcor/RenderGraph/BasePasses/FullScreenPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4028,
						"regions":
						{
						},
						"selection":
						[
							[
								3859,
								3859
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 475.0,
						"zoom_level": 1.0
					},
					"stack_index": 137,
					"type": "text"
				},
				{
					"buffer": 235,
					"file": "src/Falcor/RenderGraph/BasePasses/ComputePass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4043,
						"regions":
						{
						},
						"selection":
						[
							[
								2711,
								2711
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 226.0,
						"zoom_level": 1.0
					},
					"stack_index": 138,
					"type": "text"
				},
				{
					"buffer": 236,
					"file": "src/Falcor/RenderGraph/BasePasses/BaseGraphicsPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2824,
						"regions":
						{
						},
						"selection":
						[
							[
								1949,
								1949
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 290.0,
						"zoom_level": 1.0
					},
					"stack_index": 140,
					"type": "text"
				},
				{
					"buffer": 237,
					"file": "src/Falcor/Utils/Timing/FrameRate.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3811,
						"regions":
						{
						},
						"selection":
						[
							[
								2009,
								2009
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 87.0,
						"zoom_level": 1.0
					},
					"stack_index": 246,
					"type": "text"
				},
				{
					"buffer": 238,
					"file": "src/Falcor/Utils/Timing/FrameRate.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2265,
						"regions":
						{
						},
						"selection":
						[
							[
								1815,
								1815
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 262,
					"type": "text"
				},
				{
					"buffer": 239,
					"file": "src/Falcor/Experimental/Scene/Lights/LightBVHSampler.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6356,
						"regions":
						{
						},
						"selection":
						[
							[
								2964,
								2964
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 816.0,
						"zoom_level": 1.0
					},
					"stack_index": 493,
					"type": "text"
				},
				{
					"buffer": 240,
					"file": "src/Falcor/Experimental/Scene/Lights/LightBVHSampler.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7714,
						"regions":
						{
						},
						"selection":
						[
							[
								7713,
								7713
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1840.0,
						"zoom_level": 1.0
					},
					"stack_index": 241,
					"type": "text"
				},
				{
					"buffer": 241,
					"file": "src/Falcor/Experimental/Scene/Lights/LightCollection.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 29489,
						"regions":
						{
						},
						"selection":
						[
							[
								2921,
								2921
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 422.0,
						"zoom_level": 1.0
					},
					"stack_index": 240,
					"type": "text"
				},
				{
					"buffer": 242,
					"file": "src/Falcor/RenderGraph/BasePasses/BaseGraphicsPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3726,
						"regions":
						{
						},
						"selection":
						[
							[
								3594,
								3594
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 681.0,
						"zoom_level": 1.0
					},
					"stack_index": 141,
					"type": "text"
				},
				{
					"buffer": 243,
					"file": "src/Falcor/Experimental/Scene/Lights/LightCollection.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 12783,
						"regions":
						{
						},
						"selection":
						[
							[
								2005,
								2005
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 293,
					"type": "text"
				},
				{
					"buffer": 244,
					"file": "src/Falcor/Core/BufferTypes/ParameterBlock.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 67261,
						"regions":
						{
						},
						"selection":
						[
							[
								9976,
								9976
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3869.0,
						"zoom_level": 1.0
					},
					"stack_index": 146,
					"type": "text"
				},
				{
					"buffer": 245,
					"file": "src/RenderPasses/BSDFViewer/BSDFViewer.cs.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15202,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 105.0,
						"zoom_level": 1.0
					},
					"stack_index": 390,
					"type": "text"
				},
				{
					"buffer": 246,
					"file": "src/Tools/FalcorTest/Tests/Core/BufferTests.cs.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2850,
						"regions":
						{
						},
						"selection":
						[
							[
								2587,
								2587
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 367.0,
						"zoom_level": 1.0
					},
					"stack_index": 436,
					"type": "text"
				},
				{
					"buffer": 247,
					"file": "src/Falcor/Core/Program/ShaderVar.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15515,
						"regions":
						{
						},
						"selection":
						[
							[
								12657,
								12657
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4745.0,
						"zoom_level": 1.0
					},
					"stack_index": 472,
					"type": "text"
				},
				{
					"buffer": 248,
					"file": "src/Falcor/Scene/Lights/LightProbe.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11503,
						"regions":
						{
						},
						"selection":
						[
							[
								6471,
								6471
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3264.0,
						"zoom_level": 1.0
					},
					"stack_index": 282,
					"type": "text"
				},
				{
					"buffer": 249,
					"file": "src/Falcor/Scene/Lights/LightProbe.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7813,
						"regions":
						{
						},
						"selection":
						[
							[
								3374,
								3374
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 765.0,
						"zoom_level": 1.0
					},
					"stack_index": 281,
					"type": "text"
				},
				{
					"buffer": 250,
					"file": "src/Falcor/RenderGraph/BasePasses/RasterScenePass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3402,
						"regions":
						{
						},
						"selection":
						[
							[
								1991,
								1991
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 255.0,
						"zoom_level": 1.0
					},
					"stack_index": 134,
					"type": "text"
				},
				{
					"buffer": 251,
					"file": "src/Falcor/RenderGraph/RenderGraphCompiler.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 18153,
						"regions":
						{
						},
						"selection":
						[
							[
								1729,
								1729
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 366.0,
						"zoom_level": 1.0
					},
					"stack_index": 288,
					"type": "text"
				},
				{
					"buffer": 252,
					"file": "src/Falcor/RenderGraph/RenderGraph.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 30158,
						"regions":
						{
						},
						"selection":
						[
							[
								2489,
								2489
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 341.0,
						"zoom_level": 1.0
					},
					"stack_index": 158,
					"type": "text"
				},
				{
					"buffer": 253,
					"file": "src/Falcor/RenderGraph/RenderGraphExe.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4177,
						"regions":
						{
						},
						"selection":
						[
							[
								3590,
								3590
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 412.0,
						"zoom_level": 1.0
					},
					"stack_index": 238,
					"type": "text"
				},
				{
					"buffer": 254,
					"file": "src/Falcor/RenderGraph/RenderGraphExe.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4072,
						"regions":
						{
						},
						"selection":
						[
							[
								2042,
								2042
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 239,
					"type": "text"
				},
				{
					"buffer": 255,
					"file": "src/Falcor/Utils/Scripting/Dictionary.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4523,
						"regions":
						{
						},
						"selection":
						[
							[
								2654,
								2654
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1224.0,
						"zoom_level": 1.0
					},
					"stack_index": 175,
					"type": "text"
				},
				{
					"buffer": 256,
					"file": "src/Falcor/RenderGraph/RenderGraphUI.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 64727,
						"regions":
						{
						},
						"selection":
						[
							[
								24936,
								24936
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 9384.0,
						"zoom_level": 1.0
					},
					"stack_index": 70,
					"type": "text"
				},
				{
					"buffer": 257,
					"file": "src/Falcor/Utils/Debug/PixelDebug.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9625,
						"regions":
						{
						},
						"selection":
						[
							[
								1814,
								1814
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1683.0,
						"zoom_level": 1.0
					},
					"stack_index": 266,
					"type": "text"
				},
				{
					"buffer": 258,
					"file": "src/Falcor/Utils/Algorithm/ParallelReduction.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6148,
						"regions":
						{
						},
						"selection":
						[
							[
								1729,
								1729
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 536.0,
						"zoom_level": 1.0
					},
					"stack_index": 234,
					"type": "text"
				},
				{
					"buffer": 259,
					"file": "src/Tools/FalcorTest/Tests/Utils/ParallelReductionTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11656,
						"regions":
						{
						},
						"selection":
						[
							[
								9905,
								9905
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3213.0,
						"zoom_level": 1.0
					},
					"stack_index": 412,
					"type": "text"
				},
				{
					"buffer": 260,
					"file": "src/Tools/FalcorTest/Tests/Utils/PrefixSumTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4850,
						"regions":
						{
						},
						"selection":
						[
							[
								4793,
								4793
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1173.0,
						"zoom_level": 1.0
					},
					"stack_index": 407,
					"type": "text"
				},
				{
					"buffer": 261,
					"file": "src/Falcor/Utils/Algorithm/PrefixSum.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7112,
						"regions":
						{
						},
						"selection":
						[
							[
								3289,
								3289
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 379.0,
						"zoom_level": 1.0
					},
					"stack_index": 233,
					"type": "text"
				},
				{
					"buffer": 262,
					"file": "src/Falcor/Utils/Algorithm/BitonicSort.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4470,
						"regions":
						{
						},
						"selection":
						[
							[
								2970,
								2970
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 906.0,
						"zoom_level": 1.0
					},
					"stack_index": 236,
					"type": "text"
				},
				{
					"buffer": 263,
					"file": "src/Falcor/Utils/Algorithm/ComputeParallelReduction.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4901,
						"regions":
						{
						},
						"selection":
						[
							[
								1906,
								1906
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 612.0,
						"zoom_level": 1.0
					},
					"stack_index": 272,
					"type": "text"
				},
				{
					"buffer": 264,
					"file": "src/Falcor/Utils/Algorithm/ParallelReduction.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3575,
						"regions":
						{
						},
						"selection":
						[
							[
								3574,
								3574
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 357.0,
						"zoom_level": 1.0
					},
					"stack_index": 274,
					"type": "text"
				},
				{
					"buffer": 265,
					"file": "src/Falcor/Utils/Algorithm/BitonicSort.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4169,
						"regions":
						{
						},
						"selection":
						[
							[
								4169,
								4169
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 816.0,
						"zoom_level": 1.0
					},
					"stack_index": 275,
					"type": "text"
				},
				{
					"buffer": 266,
					"file": "src/Falcor/Utils/Algorithm/PrefixSum.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4191,
						"regions":
						{
						},
						"selection":
						[
							[
								4191,
								4191
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 878.0,
						"zoom_level": 1.0
					},
					"stack_index": 273,
					"type": "text"
				},
				{
					"buffer": 267,
					"file": "src/Falcor/Utils/Algorithm/ComputeParallelReduction.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9541,
						"regions":
						{
						},
						"selection":
						[
							[
								4105,
								4105
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 504.0,
						"zoom_level": 1.0
					},
					"stack_index": 235,
					"type": "text"
				},
				{
					"buffer": 268,
					"file": "src/Falcor/Utils/Scripting/Console.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4108,
						"regions":
						{
						},
						"selection":
						[
							[
								1760,
								1760
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 816.0,
						"zoom_level": 1.0
					},
					"stack_index": 193,
					"type": "text"
				},
				{
					"buffer": 269,
					"file": "src/Falcor/Utils/Scripting/ScriptBindings.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4848,
						"regions":
						{
						},
						"selection":
						[
							[
								1751,
								1751
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 486,
					"type": "text"
				},
				{
					"buffer": 270,
					"file": "src/Falcor/Utils/Sampling/SampleGenerator.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3452,
						"regions":
						{
						},
						"selection":
						[
							[
								3451,
								3451
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 306.0,
						"zoom_level": 1.0
					},
					"stack_index": 270,
					"type": "text"
				},
				{
					"buffer": 271,
					"file": "src/Falcor/Utils/Timing/Clock.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9831,
						"regions":
						{
						},
						"selection":
						[
							[
								8210,
								8210
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3482.0,
						"zoom_level": 1.0
					},
					"stack_index": 260,
					"type": "text"
				},
				{
					"buffer": 272,
					"file": "src/Falcor/Utils/Timing/Clock.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8564,
						"regions":
						{
						},
						"selection":
						[
							[
								2111,
								2111
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 51.0,
						"zoom_level": 1.0
					},
					"stack_index": 261,
					"type": "text"
				},
				{
					"buffer": 273,
					"file": "src/Falcor/Core/API/TextureLoader.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 24304,
						"regions":
						{
						},
						"selection":
						[
							[
								23777,
								23777
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 49,
					"type": "text"
				},
				{
					"buffer": 274,
					"file": "third_party/assimp/include/assimp/Bitmap.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4295,
						"regions":
						{
						},
						"selection":
						[
							[
								2138,
								2138
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1162.0,
						"zoom_level": 1.0
					},
					"stack_index": 475,
					"type": "text"
				},
				{
					"buffer": 275,
					"file": "src/Falcor/Core/API/VAO.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5144,
						"regions":
						{
						},
						"selection":
						[
							[
								2540,
								2540
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1395.0,
						"zoom_level": 1.0
					},
					"stack_index": 292,
					"type": "text"
				},
				{
					"buffer": 276,
					"file": "src/Falcor/Utils/Logger.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5549,
						"regions":
						{
						},
						"selection":
						[
							[
								5217,
								5217
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1291.0,
						"zoom_level": 1.0
					},
					"stack_index": 183,
					"type": "text"
				},
				{
					"buffer": 277,
					"file": "src/Falcor/Utils/Logger.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5968,
						"regions":
						{
						},
						"selection":
						[
							[
								5674,
								5674
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2115.0,
						"zoom_level": 1.0
					},
					"stack_index": 386,
					"type": "text"
				},
				{
					"buffer": 278,
					"file": "src/Falcor/Utils/BinaryFileStream.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5898,
						"regions":
						{
						},
						"selection":
						[
							[
								1843,
								1843
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 170.0,
						"zoom_level": 1.0
					},
					"stack_index": 397,
					"type": "text"
				},
				{
					"buffer": 279,
					"file": "src/Falcor/Utils/Scripting/Scripting.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5721,
						"regions":
						{
						},
						"selection":
						[
							[
								1749,
								1749
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 74.0,
						"zoom_level": 1.0
					},
					"stack_index": 194,
					"type": "text"
				},
				{
					"buffer": 280,
					"file": "src/Falcor/Utils/Timing/Profiler.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10754,
						"regions":
						{
						},
						"selection":
						[
							[
								2524,
								2524
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 359.0,
						"zoom_level": 1.0
					},
					"stack_index": 227,
					"type": "text"
				},
				{
					"buffer": 281,
					"file": "src/Falcor/Utils/UI/Gui.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 56184,
						"regions":
						{
						},
						"selection":
						[
							[
								8303,
								8303
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2116.0,
						"zoom_level": 1.0
					},
					"stack_index": 64,
					"type": "text"
				},
				{
					"buffer": 282,
					"file": "src/Falcor/Utils/UI/PixelZoom.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5190,
						"regions":
						{
						},
						"selection":
						[
							[
								2488,
								2488
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 867.0,
						"zoom_level": 1.0
					},
					"stack_index": 223,
					"type": "text"
				},
				{
					"buffer": 283,
					"file": "src/Falcor/Utils/UI/TextRenderer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7231,
						"regions":
						{
						},
						"selection":
						[
							[
								5273,
								5273
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1212.0,
						"zoom_level": 1.0
					},
					"stack_index": 225,
					"type": "text"
				},
				{
					"buffer": 284,
					"file": "src/Falcor/Utils/UI/TextRenderer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3353,
						"regions":
						{
						},
						"selection":
						[
							[
								2192,
								2192
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 408.0,
						"zoom_level": 1.0
					},
					"stack_index": 226,
					"type": "text"
				},
				{
					"buffer": 285,
					"file": "src/Falcor/Utils/UI/PixelZoom.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3368,
						"regions":
						{
						},
						"selection":
						[
							[
								3286,
								3286
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 158.0,
						"zoom_level": 1.0
					},
					"stack_index": 224,
					"type": "text"
				},
				{
					"buffer": 286,
					"file": "src/Falcor/Utils/UI/DebugDrawer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4027,
						"regions":
						{
						},
						"selection":
						[
							[
								3944,
								3944
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 636.0,
						"zoom_level": 1.0
					},
					"stack_index": 232,
					"type": "text"
				},
				{
					"buffer": 287,
					"file": "src/Falcor/Utils/UI/DebugDrawer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8927,
						"regions":
						{
						},
						"selection":
						[
							[
								2050,
								2050
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 51.0,
						"zoom_level": 1.0
					},
					"stack_index": 231,
					"type": "text"
				},
				{
					"buffer": 288,
					"file": "src/Falcor/Utils/UI/Font.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4060,
						"regions":
						{
						},
						"selection":
						[
							[
								2244,
								2244
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 378.0,
						"zoom_level": 1.0
					},
					"stack_index": 230,
					"type": "text"
				},
				{
					"buffer": 289,
					"file": "third_party/slang/tools/render-test/bind-location.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 19257,
						"regions":
						{
						},
						"selection":
						[
							[
								10547,
								10547
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3980.0,
						"zoom_level": 1.0
					},
					"stack_index": 471,
					"type": "text"
				},
				{
					"buffer": 290,
					"file": "src/Falcor/Utils/UI/Font.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5156,
						"regions":
						{
						},
						"selection":
						[
							[
								2559,
								2559
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 255.0,
						"zoom_level": 1.0
					},
					"stack_index": 229,
					"type": "text"
				},
				{
					"buffer": 291,
					"file": "src/Falcor/Core/Program/ProgramReflection.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 85087,
						"regions":
						{
						},
						"selection":
						[
							[
								85086,
								85086
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 35103.0,
						"zoom_level": 1.0
					},
					"stack_index": 148,
					"type": "text"
				},
				{
					"buffer": 292,
					"file": "src/Falcor/Core/API/Vulkan/VKGraphicsStateObject.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5776,
						"regions":
						{
						},
						"selection":
						[
							[
								5776,
								5776
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 921.0,
						"zoom_level": 1.0
					},
					"stack_index": 306,
					"type": "text"
				},
				{
					"buffer": 293,
					"file": "third_party/slang/source/slang/slang-reflection.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 50216,
						"regions":
						{
						},
						"selection":
						[
							[
								2619,
								2619
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1382.0,
						"zoom_level": 1.0
					},
					"stack_index": 466,
					"type": "text"
				},
				{
					"buffer": 294,
					"file": "third_party/slang/source/slang/slang-compiler.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 90183,
						"regions":
						{
						},
						"selection":
						[
							[
								83549,
								83549
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 34736.0,
						"zoom_level": 1.0
					},
					"stack_index": 465,
					"type": "text"
				},
				{
					"buffer": 295,
					"file": "third_party/slang/source/slang/slang-name.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 800,
						"regions":
						{
						},
						"selection":
						[
							[
								630,
								630
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 56.0,
						"zoom_level": 1.0
					},
					"stack_index": 464,
					"type": "text"
				},
				{
					"buffer": 296,
					"file": "third_party/slang/source/core/slang-dictionary.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13988,
						"regions":
						{
						},
						"selection":
						[
							[
								8683,
								8683
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 463,
					"type": "text"
				},
				{
					"buffer": 297,
					"file": "src/Falcor/Core/Program/ProgramVars.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14440,
						"regions":
						{
						},
						"selection":
						[
							[
								3693,
								3693
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 972.0,
						"zoom_level": 1.0
					},
					"stack_index": 145,
					"type": "text"
				},
				{
					"buffer": 298,
					"file": "src/Falcor/Raytracing/RtProgramVarsHelper.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14339,
						"regions":
						{
						},
						"selection":
						[
							[
								2753,
								2753
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 299.0,
						"zoom_level": 1.0
					},
					"stack_index": 404,
					"type": "text"
				},
				{
					"buffer": 299,
					"file": "src/Falcor/Core/Program/ProgramVars.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6798,
						"regions":
						{
						},
						"selection":
						[
							[
								3457,
								3457
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1106.0,
						"zoom_level": 1.0
					},
					"stack_index": 147,
					"type": "text"
				},
				{
					"buffer": 300,
					"file": "src/Falcor/Core/Program/ShaderVar.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 17036,
						"regions":
						{
						},
						"selection":
						[
							[
								17036,
								17036
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 6056.0,
						"zoom_level": 1.0
					},
					"stack_index": 309,
					"type": "text"
				},
				{
					"buffer": 301,
					"file": "src/Falcor/Core/Program/ProgramReflection.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 54816,
						"regions":
						{
						},
						"selection":
						[
							[
								49501,
								49501
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 24131.0,
						"zoom_level": 1.0
					},
					"stack_index": 150,
					"type": "text"
				},
				{
					"buffer": 302,
					"file": "src/Falcor/Core/Program/Program.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 34062,
						"regions":
						{
						},
						"selection":
						[
							[
								27215,
								27215
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 11768.0,
						"zoom_level": 1.0
					},
					"stack_index": 310,
					"type": "text"
				},
				{
					"buffer": 303,
					"file": "src/Falcor/Core/API/Buffer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13450,
						"regions":
						{
						},
						"selection":
						[
							[
								11550,
								11550
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3287.0,
						"zoom_level": 1.0
					},
					"stack_index": 184,
					"type": "text"
				},
				{
					"buffer": 304,
					"file": "src/Falcor/Core/API/FBO.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 18040,
						"regions":
						{
						},
						"selection":
						[
							[
								6037,
								6037
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2397.0,
						"zoom_level": 1.0
					},
					"stack_index": 47,
					"type": "text"
				},
				{
					"buffer": 305,
					"file": "src/Falcor/Core/API/BlendState.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9346,
						"regions":
						{
						},
						"selection":
						[
							[
								9106,
								9106
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2535.0,
						"zoom_level": 1.0
					},
					"stack_index": 303,
					"type": "text"
				},
				{
					"buffer": 306,
					"file": "src/Falcor/Core/API/BlendState.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3664,
						"regions":
						{
						},
						"selection":
						[
							[
								1729,
								1729
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 306.0,
						"zoom_level": 1.0
					},
					"stack_index": 328,
					"type": "text"
				},
				{
					"buffer": 307,
					"file": "src/Falcor/Core/API/FBO.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13546,
						"regions":
						{
						},
						"selection":
						[
							[
								4985,
								4985
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 648.0,
						"zoom_level": 1.0
					},
					"stack_index": 46,
					"type": "text"
				},
				{
					"buffer": 308,
					"file": "src/USD/hdLava/rendererPlugin.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 734,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 31,
					"type": "text"
				},
				{
					"buffer": 309,
					"file": "src/USD/hdLava/renderDelegate.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3463,
						"regions":
						{
						},
						"selection":
						[
							[
								3463,
								3463
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 34,
					"type": "text"
				},
				{
					"buffer": 310,
					"file": "src/USD/hdLava/renderDelegate.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14534,
						"regions":
						{
						},
						"selection":
						[
							[
								14534,
								14534
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 6943.0,
						"zoom_level": 1.0
					},
					"stack_index": 35,
					"type": "text"
				},
				{
					"buffer": 311,
					"file": "src/USD/hdLava/renderThread.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2169,
						"regions":
						{
						},
						"selection":
						[
							[
								1508,
								1508
							]
						],
						"settings":
						{
							"auto_name": "/*************************************************",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 766.0,
						"zoom_level": 1.0
					},
					"stack_index": 43,
					"type": "text"
				},
				{
					"buffer": 312,
					"file": "src/USD/hdLava/renderThread.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4673,
						"regions":
						{
						},
						"selection":
						[
							[
								4673,
								4673
							]
						],
						"settings":
						{
							"auto_name": "/*************************************************",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 42,
					"type": "text"
				},
				{
					"buffer": 313,
					"file": "src/USD/hdLava/rendererPlugin.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1809,
						"regions":
						{
						},
						"selection":
						[
							[
								1233,
								1233
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 7.0,
						"zoom_level": 1.0
					},
					"stack_index": 32,
					"type": "text"
				},
				{
					"buffer": 314,
					"file": "src/Falcor/Core/API/Texture.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15518,
						"regions":
						{
						},
						"selection":
						[
							[
								13663,
								13663
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2788.0,
						"zoom_level": 1.0
					},
					"stack_index": 48,
					"type": "text"
				},
				{
					"buffer": 315,
					"file": "src/Tools/FalcorTest/Tests/ShadingUtils/RaytracingTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4882,
						"regions":
						{
						},
						"selection":
						[
							[
								4881,
								4881
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1315.0,
						"zoom_level": 1.0
					},
					"stack_index": 451,
					"type": "text"
				},
				{
					"buffer": 316,
					"file": "src/Tools/FalcorTest/Tests/Slang/SlangTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8055,
						"regions":
						{
						},
						"selection":
						[
							[
								6777,
								6777
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2518.0,
						"zoom_level": 1.0
					},
					"stack_index": 441,
					"type": "text"
				},
				{
					"buffer": 317,
					"file": "src/Tools/FalcorTest/Tests/Slang/SlangTests.cs.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6527,
						"regions":
						{
						},
						"selection":
						[
							[
								4191,
								4191
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1297.0,
						"zoom_level": 1.0
					},
					"stack_index": 443,
					"type": "text"
				},
				{
					"buffer": 318,
					"file": "src/Tools/FalcorTest/Tests/Slang/SlangShared.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2435,
						"regions":
						{
						},
						"selection":
						[
							[
								1765,
								1765
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 357.0,
						"zoom_level": 1.0
					},
					"stack_index": 444,
					"type": "text"
				},
				{
					"buffer": 319,
					"file": "src/Tools/FalcorTest/Tests/Slang/ShaderModel.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3182,
						"regions":
						{
						},
						"selection":
						[
							[
								2515,
								2515
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 75.0,
						"zoom_level": 1.0
					},
					"stack_index": 439,
					"type": "text"
				},
				{
					"buffer": 320,
					"file": "src/Tools/FalcorTest/Tests/Slang/Int64Tests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3694,
						"regions":
						{
						},
						"selection":
						[
							[
								1882,
								1882
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1060.0,
						"zoom_level": 1.0
					},
					"stack_index": 453,
					"type": "text"
				},
				{
					"buffer": 321,
					"file": "src/Tools/FalcorTest/Tests/Slang/TraceRayFlags.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3163,
						"regions":
						{
						},
						"selection":
						[
							[
								1762,
								1743
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 227.0,
						"zoom_level": 1.0
					},
					"stack_index": 450,
					"type": "text"
				},
				{
					"buffer": 322,
					"file": "src/Tools/FalcorTest/Tests/Slang/TraceRayInline.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2113,
						"regions":
						{
						},
						"selection":
						[
							[
								2113,
								2113
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 455,
					"type": "text"
				},
				{
					"buffer": 323,
					"file": "src/Tools/FalcorTest/Tests/Slang/WaveOps.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6067,
						"regions":
						{
						},
						"selection":
						[
							[
								3182,
								3182
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1122.0,
						"zoom_level": 1.0
					},
					"stack_index": 440,
					"type": "text"
				},
				{
					"buffer": 324,
					"file": "src/Tools/FalcorTest/Tests/Utils/AABBTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7752,
						"regions":
						{
						},
						"selection":
						[
							[
								2261,
								2261
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 262.0,
						"zoom_level": 1.0
					},
					"stack_index": 424,
					"type": "text"
				},
				{
					"buffer": 325,
					"file": "third_party/slang/prelude/slang-cpp-types.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 28997,
						"regions":
						{
						},
						"selection":
						[
							[
								1493,
								1493
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 614.0,
						"zoom_level": 1.0
					},
					"stack_index": 251,
					"type": "text"
				},
				{
					"buffer": 326,
					"file": "src/Tools/FalcorTest/FalcorTest.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2143,
						"regions":
						{
						},
						"selection":
						[
							[
								1866,
								1866
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 467,
					"type": "text"
				},
				{
					"buffer": 327,
					"file": "src/Tools/FalcorTest/FalcorTest.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3605,
						"regions":
						{
						},
						"selection":
						[
							[
								3312,
								3312
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 346.0,
						"zoom_level": 1.0
					},
					"stack_index": 454,
					"type": "text"
				},
				{
					"buffer": 328,
					"file": "src/Tools/FalcorTest/Tests/Sampling/SampleGeneratorTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7287,
						"regions":
						{
						},
						"selection":
						[
							[
								4059,
								4059
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 551.0,
						"zoom_level": 1.0
					},
					"stack_index": 428,
					"type": "text"
				},
				{
					"buffer": 329,
					"file": "src/Tools/FalcorTest/Tests/Core/RootBufferTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8005,
						"regions":
						{
						},
						"selection":
						[
							[
								7231,
								7231
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2098.0,
						"zoom_level": 1.0
					},
					"stack_index": 429,
					"type": "text"
				},
				{
					"buffer": 330,
					"file": "src/Tools/FalcorTest/Tests/Core/RootBufferStructTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5631,
						"regions":
						{
						},
						"selection":
						[
							[
								4710,
								4710
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 430,
					"type": "text"
				},
				{
					"buffer": 331,
					"file": "src/Falcor/Core/API/Vulkan/VkGpuMemoryHeap.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2413,
						"regions":
						{
						},
						"selection":
						[
							[
								2413,
								2413
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 318,
					"type": "text"
				},
				{
					"buffer": 332,
					"file": "src/Falcor/Core/Platform/Linux/Linux.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15074,
						"regions":
						{
						},
						"selection":
						[
							[
								14787,
								14787
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 7551.0,
						"zoom_level": 1.0
					},
					"stack_index": 406,
					"type": "text"
				},
				{
					"buffer": 333,
					"file": "src/Falcor/Core/Platform/Windows/ProgressBarWin.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4513,
						"regions":
						{
						},
						"selection":
						[
							[
								2360,
								2360
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 204.0,
						"zoom_level": 1.0
					},
					"stack_index": 492,
					"type": "text"
				},
				{
					"buffer": 334,
					"file": "src/Falcor/Core/Platform/OS.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15995,
						"regions":
						{
						},
						"selection":
						[
							[
								1983,
								1983
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2550.0,
						"zoom_level": 1.0
					},
					"stack_index": 474,
					"type": "text"
				},
				{
					"buffer": 335,
					"file": "src/Falcor/Core/API/Vulkan/VKState.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3960,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 377.0,
						"zoom_level": 1.0
					},
					"stack_index": 304,
					"type": "text"
				},
				{
					"buffer": 336,
					"file": "src/Falcor/Core/API/Texture.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 16435,
						"regions":
						{
						},
						"selection":
						[
							[
								11982,
								11982
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3706.0,
						"zoom_level": 1.0
					},
					"stack_index": 54,
					"type": "text"
				},
				{
					"buffer": 337,
					"file": "src/USD/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 638,
						"regions":
						{
						},
						"selection":
						[
							[
								549,
								549
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 30,
					"type": "text"
				},
				{
					"buffer": 338,
					"file": "src/USD/hdLava/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1179,
						"regions":
						{
						},
						"selection":
						[
							[
								26,
								26
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 29,
					"type": "text"
				},
				{
					"buffer": 339,
					"file": "src/USD/hdLava/api.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 788,
						"regions":
						{
						},
						"selection":
						[
							[
								788,
								788
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 41,
					"type": "text"
				},
				{
					"buffer": 340,
					"file": "src/USD/hdLava/pch.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5431,
						"regions":
						{
						},
						"selection":
						[
							[
								1419,
								1419
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 1468.0,
						"zoom_level": 1.0
					},
					"stack_index": 36,
					"type": "text"
				},
				{
					"buffer": 341,
					"file": "src/USD/hdLava/boostIncludePath.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1114,
						"regions":
						{
						},
						"selection":
						[
							[
								772,
								772
							]
						],
						"settings":
						{
							"auto_name": "/*************************************************",
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 37,
					"type": "text"
				},
				{
					"buffer": 342,
					"file": "src/USD/hdLava/plugInfo.json",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 604,
						"regions":
						{
						},
						"selection":
						[
							[
								456,
								456
							]
						],
						"settings":
						{
							"syntax": "Packages/JavaScript/JSON.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 44,
					"type": "text"
				},
				{
					"buffer": 343,
					"file": "src/USD/hdLava/renderPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 715,
						"regions":
						{
						},
						"selection":
						[
							[
								226,
								226
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 40,
					"type": "text"
				},
				{
					"buffer": 344,
					"file": "src/USD/hdLava/renderPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2970,
						"regions":
						{
						},
						"selection":
						[
							[
								2970,
								2970
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 39,
					"type": "text"
				},
				{
					"buffer": 345,
					"file": "src/USD/hdLava/renderParam.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2361,
						"regions":
						{
						},
						"selection":
						[
							[
								2361,
								2361
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 459.0,
						"zoom_level": 1.0
					},
					"stack_index": 38,
					"type": "text"
				},
				{
					"buffer": 346,
					"file": "src/USD/hdLava/renderParam.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2251,
						"regions":
						{
						},
						"selection":
						[
							[
								10,
								10
							]
						],
						"settings":
						{
							"auto_name": "/*************************************************",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 33,
					"type": "text"
				},
				{
					"buffer": 347,
					"file": "src/USD/hgiVk/commandBuffer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8461,
						"regions":
						{
						},
						"selection":
						[
							[
								1472,
								1472
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 333,
					"type": "text"
				},
				{
					"buffer": 348,
					"file": "src/USD/hgiVk/commandBufferManager.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13416,
						"regions":
						{
						},
						"selection":
						[
							[
								184,
								184
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 371,
					"type": "text"
				},
				{
					"buffer": 349,
					"file": "src/USD/hgiVk/commandPool.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1629,
						"regions":
						{
						},
						"selection":
						[
							[
								114,
								114
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 370,
					"type": "text"
				},
				{
					"buffer": 350,
					"file": "src/USD/hgiVk/computeEncoder.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1791,
						"regions":
						{
						},
						"selection":
						[
							[
								222,
								222
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 369,
					"type": "text"
				},
				{
					"buffer": 351,
					"file": "src/USD/hgiVk/conversions.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9785,
						"regions":
						{
						},
						"selection":
						[
							[
								150,
								150
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 368,
					"type": "text"
				},
				{
					"buffer": 352,
					"file": "src/USD/hgiVk/device.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 17769,
						"regions":
						{
						},
						"selection":
						[
							[
								209,
								209
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 367,
					"type": "text"
				},
				{
					"buffer": 353,
					"file": "src/USD/hgiVk/diagnostic.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6577,
						"regions":
						{
						},
						"selection":
						[
							[
								239,
								239
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 366,
					"type": "text"
				},
				{
					"buffer": 354,
					"file": "src/USD/hgiVk/frame.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2455,
						"regions":
						{
						},
						"selection":
						[
							[
								113,
								113
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 343,
					"type": "text"
				},
				{
					"buffer": 355,
					"file": "src/USD/hgiVk/garbageCollector.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3957,
						"regions":
						{
						},
						"selection":
						[
							[
								423,
								423
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 365,
					"type": "text"
				},
				{
					"buffer": 356,
					"file": "src/USD/hgiVk/graphicsEncoder.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6479,
						"regions":
						{
						},
						"selection":
						[
							[
								405,
								405
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 364,
					"type": "text"
				},
				{
					"buffer": 357,
					"file": "src/USD/hgiVk/hgi.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14444,
						"regions":
						{
						},
						"selection":
						[
							[
								961,
								961
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 363,
					"type": "text"
				},
				{
					"buffer": 358,
					"file": "src/USD/hgiVk/instance.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1940,
						"regions":
						{
						},
						"selection":
						[
							[
								103,
								103
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 362,
					"type": "text"
				},
				{
					"buffer": 359,
					"file": "src/USD/hgiVk/parallelGraphicsEncoder.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3913,
						"regions":
						{
						},
						"selection":
						[
							[
								387,
								387
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 361,
					"type": "text"
				},
				{
					"buffer": 360,
					"file": "src/USD/hgiVk/pipeline.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15055,
						"regions":
						{
						},
						"selection":
						[
							[
								348,
								348
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 360,
					"type": "text"
				},
				{
					"buffer": 361,
					"file": "src/USD/hgiVk/renderPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15805,
						"regions":
						{
						},
						"selection":
						[
							[
								264,
								264
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 336,
					"type": "text"
				},
				{
					"buffer": 362,
					"file": "src/USD/hgiVk/pipeline.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1831,
						"regions":
						{
						},
						"selection":
						[
							[
								1176,
								1176
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 335,
					"type": "text"
				},
				{
					"buffer": 363,
					"file": "src/USD/hgiVk/renderPassPipelineCache.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8095,
						"regions":
						{
						},
						"selection":
						[
							[
								322,
								322
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 359,
					"type": "text"
				},
				{
					"buffer": 364,
					"file": "src/USD/hgiVk/resourceBindings.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 16563,
						"regions":
						{
						},
						"selection":
						[
							[
								276,
								276
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 358,
					"type": "text"
				},
				{
					"buffer": 365,
					"file": "src/USD/hgiVk/shaderCompiler.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10186,
						"regions":
						{
						},
						"selection":
						[
							[
								285,
								285
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 357,
					"type": "text"
				},
				{
					"buffer": 366,
					"file": "src/USD/hgiVk/shaderFunction.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2509,
						"regions":
						{
						},
						"selection":
						[
							[
								149,
								149
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 356,
					"type": "text"
				},
				{
					"buffer": 367,
					"file": "src/USD/hgiVk/shaderProgram.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 437,
						"regions":
						{
						},
						"selection":
						[
							[
								50,
								50
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 355,
					"type": "text"
				},
				{
					"buffer": 368,
					"file": "src/USD/hgiVk/surface.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3812,
						"regions":
						{
						},
						"selection":
						[
							[
								112,
								112
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 306.0,
						"zoom_level": 1.0
					},
					"stack_index": 53,
					"type": "text"
				},
				{
					"buffer": 369,
					"file": "src/USD/hgiVk/swapchain.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 17443,
						"regions":
						{
						},
						"selection":
						[
							[
								253,
								253
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 354,
					"type": "text"
				},
				{
					"buffer": 370,
					"file": "src/USD/hgiVk/texture.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15437,
						"regions":
						{
						},
						"selection":
						[
							[
								1497,
								1497
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 353,
					"type": "text"
				},
				{
					"buffer": 371,
					"file": "src/USD/hgiVk/buffer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9825,
						"regions":
						{
						},
						"selection":
						[
							[
								182,
								182
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 352,
					"type": "text"
				},
				{
					"buffer": 372,
					"file": "src/USD/hgiVk/blitEncoder.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6180,
						"regions":
						{
						},
						"selection":
						[
							[
								1024,
								1024
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 351,
					"type": "text"
				},
				{
					"buffer": 373,
					"file": "src/USD/hgiVk/blitEncoder.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1319,
						"regions":
						{
						},
						"selection":
						[
							[
								378,
								378
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 332,
					"type": "text"
				},
				{
					"buffer": 374,
					"file": "src/USD/hgiVk/buffer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1965,
						"regions":
						{
						},
						"selection":
						[
							[
								148,
								148
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 350,
					"type": "text"
				},
				{
					"buffer": 375,
					"file": "src/USD/hgiVk/commandBuffer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3844,
						"regions":
						{
						},
						"selection":
						[
							[
								216,
								216
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 334,
					"type": "text"
				},
				{
					"buffer": 376,
					"file": "src/USD/hgiVk/commandBufferManager.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5853,
						"regions":
						{
						},
						"selection":
						[
							[
								292,
								292
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 349,
					"type": "text"
				},
				{
					"buffer": 377,
					"file": "src/USD/hgiVk/commandPool.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1102,
						"regions":
						{
						},
						"selection":
						[
							[
								213,
								213
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 348,
					"type": "text"
				},
				{
					"buffer": 378,
					"file": "src/USD/hgiVk/computeEncoder.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1631,
						"regions":
						{
						},
						"selection":
						[
							[
								252,
								252
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 347,
					"type": "text"
				},
				{
					"buffer": 379,
					"file": "src/USD/hgiVk/conversions.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1688,
						"regions":
						{
						},
						"selection":
						[
							[
								249,
								249
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 346,
					"type": "text"
				},
				{
					"buffer": 380,
					"file": "src/USD/hgiVk/device.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6599,
						"regions":
						{
						},
						"selection":
						[
							[
								357,
								357
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 345,
					"type": "text"
				},
				{
					"buffer": 381,
					"file": "src/USD/hgiVk/diagnostic.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1085,
						"regions":
						{
						},
						"selection":
						[
							[
								135,
								135
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 344,
					"type": "text"
				},
				{
					"buffer": 382,
					"file": "src/USD/hgiVk/frame.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2289,
						"regions":
						{
						},
						"selection":
						[
							[
								270,
								270
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 342,
					"type": "text"
				},
				{
					"buffer": 383,
					"file": "src/USD/hgiVk/garbageCollector.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1637,
						"regions":
						{
						},
						"selection":
						[
							[
								192,
								192
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 341,
					"type": "text"
				},
				{
					"buffer": 384,
					"file": "src/USD/hgiVk/graphicsEncoder.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2732,
						"regions":
						{
						},
						"selection":
						[
							[
								307,
								307
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 340,
					"type": "text"
				},
				{
					"buffer": 385,
					"file": "src/USD/hgiVk/hgi.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4470,
						"regions":
						{
						},
						"selection":
						[
							[
								195,
								195
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 339,
					"type": "text"
				},
				{
					"buffer": 386,
					"file": "src/USD/hgiVk/instance.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 693,
						"regions":
						{
						},
						"selection":
						[
							[
								137,
								137
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 338,
					"type": "text"
				},
				{
					"buffer": 387,
					"file": "src/USD/hgiVk/parallelGraphicsEncoder.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1608,
						"regions":
						{
						},
						"selection":
						[
							[
								280,
								280
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 337,
					"type": "text"
				},
				{
					"buffer": 388,
					"file": "src/Mogwai/MogwaiSettings.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2575,
						"regions":
						{
						},
						"selection":
						[
							[
								1742,
								1742
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 221,
					"type": "text"
				},
				{
					"buffer": 389,
					"file": "src/Mogwai/MogwaiSettings.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10806,
						"regions":
						{
						},
						"selection":
						[
							[
								10629,
								10629
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1751.0,
						"zoom_level": 1.0
					},
					"stack_index": 67,
					"type": "text"
				},
				{
					"buffer": 390,
					"file": "src/Mogwai/MogwaiScripting.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6767,
						"regions":
						{
						},
						"selection":
						[
							[
								5949,
								5949
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1496.0,
						"zoom_level": 1.0
					},
					"stack_index": 222,
					"type": "text"
				},
				{
					"buffer": 391,
					"file": "src/Falcor/Core/API/Shader.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8437,
						"regions":
						{
						},
						"selection":
						[
							[
								7321,
								7321
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2910.0,
						"zoom_level": 1.0
					},
					"stack_index": 321,
					"type": "text"
				},
				{
					"buffer": 392,
					"file": "src/Falcor/Core/API/Sampler.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7871,
						"regions":
						{
						},
						"selection":
						[
							[
								5224,
								5224
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1680.0,
						"zoom_level": 1.0
					},
					"stack_index": 283,
					"type": "text"
				},
				{
					"buffer": 393,
					"file": "src/Falcor/Core/API/Sampler.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3887,
						"regions":
						{
						},
						"selection":
						[
							[
								3190,
								3190
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 139.0,
						"zoom_level": 1.0
					},
					"stack_index": 322,
					"type": "text"
				},
				{
					"buffer": 394,
					"file": "src/Falcor/Core/API/Vulkan/VKShader.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2775,
						"regions":
						{
						},
						"selection":
						[
							[
								2709,
								2709
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 314,
					"type": "text"
				},
				{
					"buffer": 395,
					"file": "src/Falcor/stdafx.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1831,
						"regions":
						{
						},
						"selection":
						[
							[
								1788,
								1788
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 479,
					"type": "text"
				},
				{
					"buffer": 396,
					"file": "src/Falcor/Core/API/CopyContext.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6896,
						"regions":
						{
						},
						"selection":
						[
							[
								2129,
								2129
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 595.0,
						"zoom_level": 1.0
					},
					"stack_index": 161,
					"type": "text"
				},
				{
					"buffer": 397,
					"file": "src/Falcor/Core/API/VAO.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3603,
						"regions":
						{
						},
						"selection":
						[
							[
								3603,
								3603
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 530.0,
						"zoom_level": 1.0
					},
					"stack_index": 291,
					"type": "text"
				},
				{
					"buffer": 398,
					"file": "src/Falcor/Core/API/Vulkan/VKBuffer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6579,
						"regions":
						{
						},
						"selection":
						[
							[
								5086,
								5086
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 408.0,
						"zoom_level": 1.0
					},
					"stack_index": 206,
					"type": "text"
				},
				{
					"buffer": 399,
					"file": "src/Falcor/Core/API/ComputeContext.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3000,
						"regions":
						{
						},
						"selection":
						[
							[
								1989,
								1989
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 411.0,
						"zoom_level": 1.0
					},
					"stack_index": 159,
					"type": "text"
				},
				{
					"buffer": 400,
					"file": "src/Falcor/Core/API/D3D12/D3D12ComputeContext.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6740,
						"regions":
						{
						},
						"selection":
						[
							[
								3585,
								3585
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 852.0,
						"zoom_level": 1.0
					},
					"stack_index": 423,
					"type": "text"
				},
				{
					"buffer": 401,
					"file": "src/Falcor/Core/API/D3D12/D3D12LowLevelContextData.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4664,
						"regions":
						{
						},
						"selection":
						[
							[
								2929,
								2929
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 775.0,
						"zoom_level": 1.0
					},
					"stack_index": 491,
					"type": "text"
				},
				{
					"buffer": 402,
					"file": "src/Falcor/Core/API/Vulkan/VKLowLevelContextData.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5608,
						"regions":
						{
						},
						"selection":
						[
							[
								4399,
								4399
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 663.0,
						"zoom_level": 1.0
					},
					"stack_index": 316,
					"type": "text"
				},
				{
					"buffer": 403,
					"file": "src/Falcor/Core/API/FencedPool.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4321,
						"regions":
						{
						},
						"selection":
						[
							[
								3683,
								3683
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 995.0,
						"zoom_level": 1.0
					},
					"stack_index": 323,
					"type": "text"
				},
				{
					"buffer": 404,
					"file": "src/Falcor/Core/API/Vulkan/VKComputeContext.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8062,
						"regions":
						{
						},
						"selection":
						[
							[
								2892,
								2892
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 309.0,
						"zoom_level": 1.0
					},
					"stack_index": 163,
					"type": "text"
				},
				{
					"buffer": 405,
					"file": "src/Tools/FalcorTest/Tests/Utils/MathHelpersTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 12262,
						"regions":
						{
						},
						"selection":
						[
							[
								9216,
								9216
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2856.0,
						"zoom_level": 1.0
					},
					"stack_index": 422,
					"type": "text"
				},
				{
					"buffer": 406,
					"file": "src/Falcor/Core/API/Vulkan/VKRenderContext.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 16727,
						"regions":
						{
						},
						"selection":
						[
							[
								15648,
								15648
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4464.0,
						"zoom_level": 1.0
					},
					"stack_index": 52,
					"type": "text"
				},
				{
					"buffer": 407,
					"file": "src/Falcor/RenderGraph/BasePasses/RasterPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3029,
						"regions":
						{
						},
						"selection":
						[
							[
								1986,
								1986
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 204.0,
						"zoom_level": 1.0
					},
					"stack_index": 135,
					"type": "text"
				},
				{
					"buffer": 408,
					"file": "src/Falcor/RenderGraph/BasePasses/RasterPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4410,
						"regions":
						{
						},
						"selection":
						[
							[
								4242,
								4242
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 458.0,
						"zoom_level": 1.0
					},
					"stack_index": 136,
					"type": "text"
				},
				{
					"buffer": 409,
					"file": "src/Falcor/Core/API/Vulkan/VKResourceViews.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13407,
						"regions":
						{
						},
						"selection":
						[
							[
								13307,
								13307
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4549.0,
						"zoom_level": 1.0
					},
					"stack_index": 198,
					"type": "text"
				},
				{
					"buffer": 410,
					"file": "src/RenderPasses/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3482,
						"regions":
						{
						},
						"selection":
						[
							[
								3314,
								3314
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1173.0,
						"zoom_level": 1.0
					},
					"stack_index": 25,
					"type": "text"
				},
				{
					"buffer": 411,
					"file": "/home/max/Desktop/gbuffer.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 574,
						"regions":
						{
						},
						"selection":
						[
							[
								141,
								141
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 379,
					"type": "text"
				},
				{
					"buffer": 412,
					"file": "src/RenderPasses/GBuffer/GBuffer/GBufferParams.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2388,
						"regions":
						{
						},
						"selection":
						[
							[
								2363,
								2363
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 375,
					"type": "text"
				},
				{
					"buffer": 413,
					"file": "src/Falcor/Utils/Threading.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2799,
						"regions":
						{
						},
						"selection":
						[
							[
								1945,
								1945
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 388.0,
						"zoom_level": 1.0
					},
					"stack_index": 285,
					"type": "text"
				},
				{
					"buffer": 414,
					"file": "src/Falcor/Utils/TermColor.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3484,
						"regions":
						{
						},
						"selection":
						[
							[
								2669,
								2669
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 663.0,
						"zoom_level": 1.0
					},
					"stack_index": 399,
					"type": "text"
				},
				{
					"buffer": 415,
					"file": "src/Falcor/Utils/TermColor.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2499,
						"regions":
						{
						},
						"selection":
						[
							[
								1843,
								1843
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 400,
					"type": "text"
				},
				{
					"buffer": 416,
					"file": "src/Falcor/Utils/Threading.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3003,
						"regions":
						{
						},
						"selection":
						[
							[
								2415,
								2415
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 507.0,
						"zoom_level": 1.0
					},
					"stack_index": 286,
					"type": "text"
				},
				{
					"buffer": 417,
					"file": "build/bin/Shaders/RenderPasses/BSDFViewer/BSDFViewer.cs.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15202,
						"regions":
						{
						},
						"selection":
						[
							[
								13788,
								13788
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 5865.0,
						"zoom_level": 1.0
					},
					"stack_index": 410,
					"type": "text"
				},
				{
					"buffer": 418,
					"file": "src/RenderPasses/Utils/Utils.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2234,
						"regions":
						{
						},
						"selection":
						[
							[
								2234,
								2234
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 378,
					"type": "text"
				},
				{
					"buffer": 419,
					"file": "third_party/slang/tools/render-test/cuda/cuda-compute-util.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 53192,
						"regions":
						{
						},
						"selection":
						[
							[
								1255,
								1255
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 357.0,
						"zoom_level": 1.0
					},
					"stack_index": 487,
					"type": "text"
				},
				{
					"buffer": 420,
					"file": "src/Falcor/Core/API/Vulkan/VkSmartHandle.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6726,
						"regions":
						{
						},
						"selection":
						[
							[
								3921,
								3921
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1278.0,
						"zoom_level": 1.0
					},
					"stack_index": 199,
					"type": "text"
				},
				{
					"buffer": 421,
					"file": "src/Falcor/Core/API/Vulkan/VKRootSignature.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8750,
						"regions":
						{
						},
						"selection":
						[
							[
								4765,
								4765
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1006.0,
						"zoom_level": 1.0
					},
					"stack_index": 218,
					"type": "text"
				},
				{
					"buffer": 422,
					"file": "src/Falcor/Core/Program/ProgramVersion.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10447,
						"regions":
						{
						},
						"selection":
						[
							[
								6330,
								6330
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3453.0,
						"zoom_level": 1.0
					},
					"stack_index": 152,
					"type": "text"
				},
				{
					"buffer": 423,
					"file": "third_party/slang/examples/model-viewer/main.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 86920,
						"regions":
						{
						},
						"selection":
						[
							[
								7215,
								7215
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3835.0,
						"zoom_level": 1.0
					},
					"stack_index": 498,
					"type": "text"
				},
				{
					"buffer": 424,
					"file": "src/Falcor/Core/API/ResourceViews.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9621,
						"regions":
						{
						},
						"selection":
						[
							[
								4513,
								4513
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1244.0,
						"zoom_level": 1.0
					},
					"stack_index": 170,
					"type": "text"
				},
				{
					"buffer": 425,
					"file": "src/Falcor/Core/API/RootSignature.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6716,
						"regions":
						{
						},
						"selection":
						[
							[
								4554,
								4554
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1386.0,
						"zoom_level": 1.0
					},
					"stack_index": 212,
					"type": "text"
				},
				{
					"buffer": 426,
					"file": "src/Falcor/Core/API/RootSignature.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8993,
						"regions":
						{
						},
						"selection":
						[
							[
								4764,
								4764
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1261.0,
						"zoom_level": 1.0
					},
					"stack_index": 213,
					"type": "text"
				},
				{
					"buffer": 427,
					"file": "src/Falcor/Core/API/Vulkan/VKSampler.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2442,
						"regions":
						{
						},
						"selection":
						[
							[
								2415,
								2415
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 315,
					"type": "text"
				},
				{
					"buffer": 428,
					"file": "third_party/slang/tools/gfx/render.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 28476,
						"regions":
						{
						},
						"selection":
						[
							[
								14530,
								14530
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 9715.0,
						"zoom_level": 1.0
					},
					"stack_index": 490,
					"type": "text"
				},
				{
					"buffer": 429,
					"file": "src/Falcor/Core/API/Vulkan/FalcorVK.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5196,
						"regions":
						{
						},
						"selection":
						[
							[
								2936,
								2936
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 898.0,
						"zoom_level": 1.0
					},
					"stack_index": 187,
					"type": "text"
				},
				{
					"buffer": 430,
					"file": "src/Falcor/Core/API/Device.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11497,
						"regions":
						{
						},
						"selection":
						[
							[
								10048,
								10048
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3739.0,
						"zoom_level": 1.0
					},
					"stack_index": 166,
					"type": "text"
				},
				{
					"buffer": 431,
					"file": "src/Falcor/Core/API/GpuMemoryHeap.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4090,
						"regions":
						{
						},
						"selection":
						[
							[
								3927,
								3927
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 938.0,
						"zoom_level": 1.0
					},
					"stack_index": 320,
					"type": "text"
				},
				{
					"buffer": 432,
					"file": "src/Falcor/Core/API/GpuMemoryHeap.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5126,
						"regions":
						{
						},
						"selection":
						[
							[
								4817,
								4817
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1428.0,
						"zoom_level": 1.0
					},
					"stack_index": 319,
					"type": "text"
				},
				{
					"buffer": 433,
					"file": "src/Falcor/Core/API/Vulkan/VKComputeStateObject.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2823,
						"regions":
						{
						},
						"selection":
						[
							[
								2798,
								2798
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 196,
					"type": "text"
				},
				{
					"buffer": 434,
					"file": "src/Falcor/Core/API/Vulkan/VKCopyContext.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 22034,
						"regions":
						{
						},
						"selection":
						[
							[
								16385,
								16385
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4661.0,
						"zoom_level": 1.0
					},
					"stack_index": 162,
					"type": "text"
				},
				{
					"buffer": 435,
					"file": "src/Falcor/Core/API/Vulkan/VKDescriptorPool.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5083,
						"regions":
						{
						},
						"selection":
						[
							[
								5083,
								5083
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 186,
					"type": "text"
				},
				{
					"buffer": 436,
					"file": "src/Falcor/Core/API/Vulkan/VKDescriptorSet.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7835,
						"regions":
						{
						},
						"selection":
						[
							[
								3804,
								3804
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 632.0,
						"zoom_level": 1.0
					},
					"stack_index": 211,
					"type": "text"
				},
				{
					"buffer": 437,
					"file": "src/Falcor/Core/API/Vulkan/VKDevice.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3020,
						"regions":
						{
						},
						"selection":
						[
							[
								2741,
								2741
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 357.0,
						"zoom_level": 1.0
					},
					"stack_index": 176,
					"type": "text"
				},
				{
					"buffer": 438,
					"file": "src/Falcor/Core/API/Vulkan/VKDeviceManager.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2844,
						"regions":
						{
						},
						"selection":
						[
							[
								2772,
								2772
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 442.0,
						"zoom_level": 1.0
					},
					"stack_index": 168,
					"type": "text"
				},
				{
					"buffer": 439,
					"file": "src/Falcor/Core/API/DeviceManager.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3635,
						"regions":
						{
						},
						"selection":
						[
							[
								3279,
								3279
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 732.0,
						"zoom_level": 1.0
					},
					"stack_index": 169,
					"type": "text"
				},
				{
					"buffer": 440,
					"file": "src/Falcor/Core/API/Vulkan/VKDevice.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 28452,
						"regions":
						{
						},
						"selection":
						[
							[
								2940,
								2940
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 304.0,
						"zoom_level": 1.0
					},
					"stack_index": 177,
					"type": "text"
				},
				{
					"buffer": 441,
					"file": "src/Falcor/Core/API/Vulkan/VKGpuFence.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10228,
						"regions":
						{
						},
						"selection":
						[
							[
								10027,
								10027
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 124.0,
						"zoom_level": 1.0
					},
					"stack_index": 185,
					"type": "text"
				},
				{
					"buffer": 442,
					"file": "src/Falcor/Core/API/Vulkan/VKGpuTimer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2646,
						"regions":
						{
						},
						"selection":
						[
							[
								1791,
								1791
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 153.0,
						"zoom_level": 1.0
					},
					"stack_index": 324,
					"type": "text"
				},
				{
					"buffer": 443,
					"file": "src/Falcor/Core/API/D3D12/D3D12GpuFence.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3766,
						"regions":
						{
						},
						"selection":
						[
							[
								3204,
								3204
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 714.0,
						"zoom_level": 1.0
					},
					"stack_index": 500,
					"type": "text"
				},
				{
					"buffer": 444,
					"file": "src/Falcor/Core/API/GpuFence.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3526,
						"regions":
						{
						},
						"selection":
						[
							[
								2490,
								2490
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 598.0,
						"zoom_level": 1.0
					},
					"stack_index": 325,
					"type": "text"
				},
				{
					"buffer": 445,
					"file": "src/Falcor/Core/API/Vulkan/VKSmartHandle.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9756,
						"regions":
						{
						},
						"selection":
						[
							[
								3141,
								3141
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3335.0,
						"zoom_level": 1.0
					},
					"stack_index": 200,
					"type": "text"
				},
				{
					"buffer": 446,
					"file": "src/Falcor/Core/API/Vulkan/VKState.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 27538,
						"regions":
						{
						},
						"selection":
						[
							[
								2463,
								2463
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 9370.0,
						"zoom_level": 1.0
					},
					"stack_index": 305,
					"type": "text"
				},
				{
					"buffer": 447,
					"file": "src/Falcor/Core/API/Vulkan/VKTexture.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7857,
						"regions":
						{
						},
						"selection":
						[
							[
								7442,
								7442
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1799.0,
						"zoom_level": 1.0
					},
					"stack_index": 216,
					"type": "text"
				},
				{
					"buffer": 448,
					"file": "falcor.sublime-project",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2453,
						"regions":
						{
						},
						"selection":
						[
							[
								2326,
								2326
							]
						],
						"settings":
						{
							"syntax": "Packages/JavaScript/JSON.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 683.0,
						"zoom_level": 1.0
					},
					"stack_index": 45,
					"type": "text"
				},
				{
					"buffer": 449,
					"file": "third_party/slang/external/vulkan/include/vulkan/vulkan.hpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2369181,
						"regions":
						{
						},
						"selection":
						[
							[
								509353,
								509353
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 193521.0,
						"zoom_level": 1.0
					},
					"stack_index": 461,
					"type": "text"
				},
				{
					"buffer": 450,
					"file": "/usr/include/vulkan/vulkan.hpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4010350,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 489,
					"type": "text"
				},
				{
					"buffer": 451,
					"file": "third_party/slang/external/vulkan/include/vulkan/vulkan_core.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 451013,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 476,
					"type": "text"
				},
				{
					"buffer": 452,
					"file": "src/Falcor/Utils/Math/FalcorMath.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8456,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 501,
					"type": "text"
				},
				{
					"buffer": 453,
					"file": "src/Falcor/Core/Framework.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13038,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 5100.0,
						"zoom_level": 1.0
					},
					"stack_index": 66,
					"type": "text"
				},
				{
					"buffer": 454,
					"file": "src/Falcor/Core/type.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6550,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 405,
					"type": "text"
				},
				{
					"buffer": 455,
					"file": "src/Falcor/Core/Framework.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2253,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 65,
					"type": "text"
				},
				{
					"buffer": 456,
					"file": "src/Falcor/Core/API/CopyContext.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7677,
						"regions":
						{
						},
						"selection":
						[
							[
								3015,
								3015
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 820.0,
						"zoom_level": 1.0
					},
					"stack_index": 160,
					"type": "text"
				},
				{
					"buffer": 457,
					"file": "src/Falcor/Core/API/VertexLayout.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1862,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 290,
					"type": "text"
				},
				{
					"buffer": 458,
					"file": "src/Falcor/Core/FalcorConfig.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2544,
						"regions":
						{
						},
						"selection":
						[
							[
								2500,
								2500
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 209,
					"type": "text"
				},
				{
					"buffer": 459,
					"file": "src/Falcor/RenderGraph/RenderPassStandardFlags.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2479,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 483,
					"type": "text"
				},
				{
					"buffer": 460,
					"file": "src/Falcor/Falcor.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6959,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 372,
					"type": "text"
				},
				{
					"buffer": 461,
					"file": "src/Falcor/Utils/Debug/PixelDebug.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5769,
						"regions":
						{
						},
						"selection":
						[
							[
								5769,
								5769
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1326.0,
						"zoom_level": 1.0
					},
					"stack_index": 265,
					"type": "text"
				},
				{
					"buffer": 462,
					"file": "src/Falcor/Utils/Image/Bitmap.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6060,
						"regions":
						{
						},
						"selection":
						[
							[
								3538,
								3538
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1326.0,
						"zoom_level": 1.0
					},
					"stack_index": 264,
					"type": "text"
				},
				{
					"buffer": 463,
					"file": "src/Falcor/Utils/Image/Bitmap.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 21119,
						"regions":
						{
						},
						"selection":
						[
							[
								7400,
								7400
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2612.0,
						"zoom_level": 1.0
					},
					"stack_index": 263,
					"type": "text"
				},
				{
					"buffer": 464,
					"file": "src/Falcor/Utils/Scripting/ScriptBindings.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10241,
						"regions":
						{
						},
						"selection":
						[
							[
								5773,
								5773
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 665.0,
						"zoom_level": 1.0
					},
					"stack_index": 174,
					"type": "text"
				},
				{
					"buffer": 465,
					"file": "/home/max/Desktop/compos.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1267,
						"regions":
						{
						},
						"selection":
						[
							[
								1205,
								1205
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 197,
					"type": "text"
				},
				{
					"buffer": 466,
					"file": "src/Falcor/Utils/Scripting/Console.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2101,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 195,
					"type": "text"
				},
				{
					"buffer": 467,
					"file": "src/Falcor/Utils/Scripting/Scripting.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5726,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 459.0,
						"zoom_level": 1.0
					},
					"stack_index": 173,
					"type": "text"
				},
				{
					"buffer": 468,
					"file": "src/Falcor/Core/API/DescriptorPool.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5596,
						"regions":
						{
						},
						"selection":
						[
							[
								3627,
								3627
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1275.0,
						"zoom_level": 1.0
					},
					"stack_index": 215,
					"type": "text"
				},
				{
					"buffer": 469,
					"file": "src/Falcor/Core/API/DescriptorPool.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2683,
						"regions":
						{
						},
						"selection":
						[
							[
								2157,
								2157
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 214,
					"type": "text"
				},
				{
					"buffer": 470,
					"file": "src/Falcor/Core/State/GraphicsState.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10063,
						"regions":
						{
						},
						"selection":
						[
							[
								9145,
								9145
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3188.0,
						"zoom_level": 1.0
					},
					"stack_index": 298,
					"type": "text"
				},
				{
					"buffer": 471,
					"file": "src/Falcor/Core/State/GraphicsState.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8458,
						"regions":
						{
						},
						"selection":
						[
							[
								2784,
								2784
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 451.0,
						"zoom_level": 1.0
					},
					"stack_index": 295,
					"type": "text"
				},
				{
					"buffer": 472,
					"file": "src/Falcor/Core/State/ComputeState.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3405,
						"regions":
						{
						},
						"selection":
						[
							[
								2529,
								2529
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 153.0,
						"zoom_level": 1.0
					},
					"stack_index": 307,
					"type": "text"
				},
				{
					"buffer": 473,
					"file": "src/Falcor/Core/API/ComputeStateObject.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2465,
						"regions":
						{
						},
						"selection":
						[
							[
								2089,
								2089
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 299,
					"type": "text"
				},
				{
					"buffer": 474,
					"file": "src/Falcor/Core/API/GpuTimer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4479,
						"regions":
						{
						},
						"selection":
						[
							[
								3328,
								3328
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 459.0,
						"zoom_level": 1.0
					},
					"stack_index": 329,
					"type": "text"
				},
				{
					"buffer": 475,
					"file": "src/Falcor/Core/State/ComputeState.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3782,
						"regions":
						{
						},
						"selection":
						[
							[
								2662,
								2662
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 349.0,
						"zoom_level": 1.0
					},
					"stack_index": 308,
					"type": "text"
				},
				{
					"buffer": 476,
					"file": "src/Falcor/Core/State/StateGraph.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4323,
						"regions":
						{
						},
						"selection":
						[
							[
								4098,
								4098
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 102.0,
						"zoom_level": 1.0
					},
					"stack_index": 302,
					"type": "text"
				},
				{
					"buffer": 477,
					"file": "src/Falcor/Raytracing/RtProgram/RtProgram.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7986,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 504,
					"type": "text"
				},
				{
					"buffer": 478,
					"file": "src/Falcor/Raytracing/RtProgram/RtProgram.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6561,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 503,
					"type": "text"
				},
				{
					"buffer": 479,
					"file": "src/Mogwai/AppData.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2896,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 408.0,
						"zoom_level": 1.0
					},
					"stack_index": 259,
					"type": "text"
				},
				{
					"buffer": 480,
					"file": "src/Falcor/Core/Platform/Linux/ProgressBarLinux.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5059,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 494,
					"type": "text"
				},
				{
					"buffer": 481,
					"file": "src/Mogwai/AppData.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5386,
						"regions":
						{
						},
						"selection":
						[
							[
								2276,
								2276
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1071.0,
						"zoom_level": 1.0
					},
					"stack_index": 62,
					"type": "text"
				},
				{
					"buffer": 482,
					"file": "src/Mogwai/Extensions/Capture/CaptureTrigger.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3842,
						"regions":
						{
						},
						"selection":
						[
							[
								2782,
								2782
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 459.0,
						"zoom_level": 1.0
					},
					"stack_index": 68,
					"type": "text"
				},
				{
					"buffer": 483,
					"file": "src/Falcor/Core/Sample.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 25053,
						"regions":
						{
						},
						"selection":
						[
							[
								17955,
								17955
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 7390.0,
						"zoom_level": 1.0
					},
					"stack_index": 51,
					"type": "text"
				},
				{
					"buffer": 484,
					"file": "src/Falcor/Core/API/VertexLayout.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7327,
						"regions":
						{
						},
						"selection":
						[
							[
								7087,
								7087
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1977.0,
						"zoom_level": 1.0
					},
					"stack_index": 189,
					"type": "text"
				},
				{
					"buffer": 485,
					"file": "src/Falcor/Core/API/DeviceManager.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5194,
						"regions":
						{
						},
						"selection":
						[
							[
								4527,
								4527
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1675.0,
						"zoom_level": 1.0
					},
					"stack_index": 167,
					"type": "text"
				},
				{
					"buffer": 486,
					"file": "src/Falcor/Core/API/Vulkan/VkQueryHeap.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2779,
						"regions":
						{
						},
						"selection":
						[
							[
								2659,
								2659
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 190.0,
						"zoom_level": 1.0
					},
					"stack_index": 205,
					"type": "text"
				},
				{
					"buffer": 487,
					"file": "src/Falcor/Core/API/D3D12/D3D12Device.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15156,
						"regions":
						{
						},
						"selection":
						[
							[
								11323,
								11323
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4233.0,
						"zoom_level": 1.0
					},
					"stack_index": 331,
					"type": "text"
				},
				{
					"buffer": 488,
					"file": "src/Falcor/Core/API/DescriptorSet.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5856,
						"regions":
						{
						},
						"selection":
						[
							[
								5033,
								5033
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1173.0,
						"zoom_level": 1.0
					},
					"stack_index": 219,
					"type": "text"
				},
				{
					"buffer": 489,
					"file": "src/Falcor/Core/API/DescriptorSet.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2618,
						"regions":
						{
						},
						"selection":
						[
							[
								2546,
								2546
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 217,
					"type": "text"
				},
				{
					"buffer": 490,
					"file": "src/Falcor/Core/API/ResourceViews.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5611,
						"regions":
						{
						},
						"selection":
						[
							[
								2562,
								2562
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 853.0,
						"zoom_level": 1.0
					},
					"stack_index": 203,
					"type": "text"
				},
				{
					"buffer": 491,
					"file": "Falcor.sln",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 19418,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 502,
					"type": "text"
				},
				{
					"buffer": 492,
					"file": "src/Falcor/Scene/Scene.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 25118,
						"regions":
						{
						},
						"selection":
						[
							[
								7107,
								7107
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 8670.0,
						"zoom_level": 1.0
					},
					"stack_index": 157,
					"type": "text"
				},
				{
					"buffer": 493,
					"file": "src/Falcor/RenderGraph/RenderGraphUI.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8554,
						"regions":
						{
						},
						"selection":
						[
							[
								2602,
								2602
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 697.0,
						"zoom_level": 1.0
					},
					"stack_index": 144,
					"type": "text"
				},
				{
					"buffer": 494,
					"file": "src/Falcor/RenderGraph/RenderGraph.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11413,
						"regions":
						{
						},
						"selection":
						[
							[
								2635,
								2635
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1938.0,
						"zoom_level": 1.0
					},
					"stack_index": 182,
					"type": "text"
				},
				{
					"buffer": 495,
					"file": "src/Falcor/RenderGraph/ResourceCache.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5357,
						"regions":
						{
						},
						"selection":
						[
							[
								5357,
								5357
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1224.0,
						"zoom_level": 1.0
					},
					"stack_index": 172,
					"type": "text"
				},
				{
					"buffer": 496,
					"file": "src/Falcor/RenderGraph/BasePasses/RasterScenePass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4425,
						"regions":
						{
						},
						"selection":
						[
							[
								4186,
								4186
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 561.0,
						"zoom_level": 1.0
					},
					"stack_index": 133,
					"type": "text"
				},
				{
					"buffer": 497,
					"file": "src/Falcor/Utils/Debug/DebugConsole.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4292,
						"regions":
						{
						},
						"selection":
						[
							[
								2156,
								2156
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 143.0,
						"zoom_level": 1.0
					},
					"stack_index": 387,
					"type": "text"
				},
				{
					"buffer": 498,
					"file": "src/Falcor/Scene/SceneBuilder.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11802,
						"regions":
						{
						},
						"selection":
						[
							[
								10308,
								10308
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1221.0,
						"zoom_level": 1.0
					},
					"stack_index": 156,
					"type": "text"
				},
				{
					"buffer": 499,
					"file": "src/Falcor/Utils/Debug/debug.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2463,
						"regions":
						{
						},
						"selection":
						[
							[
								2269,
								2269
							]
						],
						"settings":
						{
							"auto_name": "#ifndef __FALCOR_DEBUG_H__",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 41.0,
						"zoom_level": 1.0
					},
					"stack_index": 388,
					"type": "text"
				},
				{
					"buffer": 500,
					"file": "src/Falcor/Core/BufferTypes/ParameterBlock.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 20403,
						"regions":
						{
						},
						"selection":
						[
							[
								15970,
								15970
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1197.0,
						"zoom_level": 1.0
					},
					"stack_index": 151,
					"type": "text"
				},
				{
					"buffer": 501,
					"file": "src/Falcor/Scene/Scene.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 49096,
						"regions":
						{
						},
						"selection":
						[
							[
								6768,
								6768
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2906.0,
						"zoom_level": 1.0
					},
					"stack_index": 154,
					"type": "text"
				},
				{
					"buffer": 502,
					"file": "src/Falcor/Scene/Camera/CameraController.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9863,
						"regions":
						{
						},
						"selection":
						[
							[
								9668,
								9668
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3353.0,
						"zoom_level": 1.0
					},
					"stack_index": 248,
					"type": "text"
				},
				{
					"buffer": 503,
					"file": "src/Falcor/Scene/Camera/Camera.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13365,
						"regions":
						{
						},
						"selection":
						[
							[
								11054,
								11054
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3829.0,
						"zoom_level": 1.0
					},
					"stack_index": 247,
					"type": "text"
				},
				{
					"buffer": 504,
					"file": "src/Falcor/Core/API/D3D12/D3D12Resource.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6227,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 499,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 38.0
	},
	"input":
	{
		"height": 38.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.SublimeLinter":
	{
		"height": 0.0
	},
	"output.find_results":
	{
		"height": 120.0
	},
	"output.unsaved_changes":
	{
		"height": 120.0
	},
	"pinned_build_system": "Packages/Makefile/Make.sublime-build",
	"project": "falcor.sublime-project",
	"replace":
	{
		"height": 70.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 418.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
