{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"dev",
				"deviceDesc"
			],
			[
				"mp",
				"mpWindow"
			],
			[
				"in",
				"instance"
			],
			[
				"Device",
				"DeviceManager"
			],
			[
				"Devi",
				"DeviceManger"
			],
			[
				"p",
				"pDevice"
			],
			[
				"de",
				"deviceEnumerated"
			],
			[
				"Dev",
				"DeviceID"
			],
			[
				"De",
				"DeviceID"
			],
			[
				"name",
				"namespace"
			],
			[
				"crea",
				"createInstance"
			],
			[
				"str",
				"struct\tstruct"
			],
			[
				"un",
				"unordered_map\tstandard header (since c++11)"
			],
			[
				"i",
				"instance"
			],
			[
				"DE",
				"DeviceManager"
			],
			[
				"s",
				"string"
			],
			[
				"_",
				"_gpDevice"
			],
			[
				"R",
				"RenderGraph"
			],
			[
				"Rend",
				"RenderGraph"
			],
			[
				"def",
				"default"
			],
			[
				"LOG",
				"LOG_WARN"
			],
			[
				"sha",
				"shared_from_this"
			],
			[
				"swap",
				"swapchain"
			],
			[
				"LO",
				"LOG_ERR"
			],
			[
				"get",
				"getResource"
			],
			[
				"VK",
				"VkResource"
			],
			[
				"gN",
				"gNullBufferViews"
			],
			[
				"flat",
				"flatIndex"
			],
			[
				"ass",
				"assignedSRV"
			],
			[
				"ui",
				"uid"
			],
			[
				"GBu",
				"GBufferBase"
			],
			[
				"Render",
				"RenderPasses"
			],
			[
				"Ren",
				"RenderPasses"
			],
			[
				"uint",
				"uint8_t"
			],
			[
				"uin",
				"uint8_t"
			],
			[
				"pRe",
				"pRenderContext"
			],
			[
				"c",
				"ctx"
			],
			[
				"Pro",
				"Profiler"
			],
			[
				"cur",
				"curEventName"
			],
			[
				"shared",
				"shared_ptr"
			],
			[
				"Shader",
				"ShaderVar"
			],
			[
				"Gr",
				"GraphicsStateObject"
			],
			[
				"st",
				"stack\tstandard header"
			],
			[
				"VkB",
				"VkBaseApiHandle"
			],
			[
				"sem",
				"semaphoreQueue"
			],
			[
				"fe",
				"fenceQueue"
			],
			[
				"Fe",
				"FenceApiData"
			],
			[
				"Sha",
				"SharedPtr"
			],
			[
				"rele",
				"release"
			],
			[
				"n",
				"nullptr"
			],
			[
				"re",
				"return"
			],
			[
				"colo",
				"colorFormat"
			],
			[
				"init",
				"initHeadless"
			],
			[
				"hea",
				"headless"
			],
			[
				"render",
				"renderer"
			],
			[
				"g",
				"getWidth"
			],
			[
				"mD",
				"mDrawCounterClockwiseMeshes"
			],
			[
				"FA",
				"FALCOR_VK"
			],
			[
				"FALC",
				"FALCOR_D3D12"
			],
			[
				"fl",
				"float3"
			],
			[
				"mS",
				"mStructSize"
			],
			[
				"RE",
				"ResourceFormat"
			],
			[
				"ins",
				"instanceCount"
			],
			[
				"inde",
				"indexCount"
			],
			[
				"co",
				"common"
			],
			[
				"bin",
				"bind"
			],
			[
				"A",
				"API"
			],
			[
				"desc",
				"descriptor"
			],
			[
				"des",
				"descSetIndex"
			],
			[
				"ad",
				"addRange"
			],
			[
				"reg",
				"regSpace"
			],
			[
				"max",
				"maxIndex"
			],
			[
				"getR",
				"getRootDescriptorCount"
			],
			[
				"mDe",
				"mDesc"
			],
			[
				"Vis",
				"ShaderVisibility"
			],
			[
				"G",
				"GraphicsStateObject"
			],
			[
				"bind",
				"binding"
			],
			[
				"cre",
				"createDescriptorSetLayout"
			],
			[
				"VkP",
				"VkPipelineLayoutCreateInfo"
			],
			[
				"inf",
				"infosOut"
			],
			[
				"Sh",
				"ShaderType"
			],
			[
				"LOG_",
				"LOG_DBG"
			],
			[
				"sp",
				"spaceIndex"
			],
			[
				"add",
				"addRootDescriptor"
			],
			[
				"set",
				"setCount"
			],
			[
				"Roo",
				"RootSignature"
			],
			[
				"ma",
				"map\tstandard header"
			],
			[
				"DESCRIPT",
				"descriptor"
			],
			[
				"e",
				"else"
			],
			[
				"ele",
				"numElems"
			],
			[
				"log_",
				"LOG_ERR"
			],
			[
				"ima",
				"imageLayout"
			],
			[
				"prepare",
				"prepareDescriptorSets"
			],
			[
				"Comp",
				"ComputeVars"
			],
			[
				"ap",
				"applyComputeVars"
			],
			[
				"Lo",
				"LOG_DBG"
			],
			[
				"bi",
				"bindFlags"
			],
			[
				"sw",
				"swapchainCount"
			],
			[
				"se",
				"setUav"
			],
			[
				"strin",
				"string"
			],
			[
				"tex",
				"texFormat"
			],
			[
				"Gp",
				"GpuFence"
			],
			[
				"to",
				"to_string"
			],
			[
				"Scri",
				"ScriptBindings"
			],
			[
				"arg",
				"argv"
			],
			[
				"ar",
				"argc"
			],
			[
				"file",
				"filePath"
			],
			[
				"tr",
				"triangleCount"
			],
			[
				"me",
				"meshInstanceCount"
			],
			[
				"ex",
				"executableDirectory"
			],
			[
				"h",
				"height"
			],
			[
				"wi",
				"width"
			],
			[
				"vect",
				"vector\tstandard header"
			],
			[
				"vec",
				"vector\tstandard header"
			],
			[
				"__F",
				"__FRAMEWORK_H__"
			],
			[
				"Im",
				"ImageType"
			],
			[
				"T",
				"Texture"
			],
			[
				"VkR",
				"VkResourceType"
			],
			[
				"getD",
				"getDepthStencilView"
			],
			[
				"lo",
				"logError"
			],
			[
				"pB",
				"pBackBufferFBO"
			],
			[
				"msg",
				"msgBox"
			],
			[
				"t",
				"type"
			],
			[
				"run",
				"runtime_error"
			],
			[
				"pre",
				"prepareForDraw"
			],
			[
				"REnder",
				"RenderContext"
			],
			[
				"image",
				"imageCount"
			],
			[
				"files",
				"filesystem"
			]
		]
	},
	"buffers":
	[
		{
			"file": "src/Falcor/Core/API/D3D12/D3D12ResourceViews.cpp",
			"settings":
			{
				"buffer_size": 18914,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "Searching 1282 files for \"= delete\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/BufferTypes/ParameterBlock.h:\n  317  \n  318      // Delete some functions. If they are not deleted, the compiler will try to convert the uints to string, resulting in runtime error\n  319:     Sampler::SharedPtr getSampler(uint32_t) = delete;\n  320:     bool setSampler(uint32_t, const Sampler::SharedPtr&) = delete;\n  321  \n  322      using SpecializationArgs = std::vector<slang::SpecializationArg>;\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramVersion.h:\n   58      protected:\n   59          EntryPointGroup() = default;\n   60:         EntryPointGroup(const EntryPointGroup&) = delete;\n   61:         EntryPointGroup& operator=(const EntryPointGroup&) = delete;\n   62  \n   63          Type mType;\n   ..\n   94          EntryPointGroupKernels(Type type, const Shaders& shaders);\n   95          EntryPointGroupKernels() = default;\n   96:         EntryPointGroupKernels(const EntryPointGroupKernels&) = delete;\n   97:         EntryPointGroupKernels& operator=(const EntryPointGroupKernels&) = delete;\n   98  \n   99          Type mType;\n\n/home/max/dev/Falcor/src/Falcor/Core/Renderer.h:\n  172  \n  173      // Deleted copy operators (copy a pointer type!)\n  174:     IRenderer(const IRenderer&) = delete;\n  175:     IRenderer& operator=(const IRenderer &) = delete;\n  176  };\n  177  \n\n/home/max/dev/Falcor/src/Falcor/Core/Sample.h:\n  149  \n  150      Sample(IRenderer::UniquePtr& pRenderer) : mpRenderer(std::move(pRenderer)) {}\n  151:     Sample(const Sample&) = delete;\n  152:     Sample& operator=(const Sample&) = delete;\n  153  \n  154      Device::SharedPtr mpDevice;\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVH.h:\n  102              // Assignment is unsafe given how |triangleIndices| is allocated.\n  103              LeafNode() = default;\n  104:             LeafNode(const LeafNode &) = delete;\n  105:             LeafNode &operator=(const LeafNode &) = delete;\n  106          };\n  107  \n\n/home/max/dev/Falcor/src/Falcor/Raytracing/RtProgram/RtProgram.h:\n  133  \n  134      private:\n  135:         RtProgram(RtProgram const&) = delete;\n  136:         RtProgram& operator=(RtProgram const&) = delete;\n  137  \n  138          RtProgram(const Desc& desc, uint32_t maxPayloadSize = FALCOR_RT_MAX_PAYLOAD_SIZE_IN_BYTES, uint32_t maxAttributesSize = D3D12_RAYTRACING_MAX_ATTRIBUTE_SIZE_IN_BYTES);\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderPassLibrary.h:\n   36       public:\n   37          RenderPassLibrary() = default;\n   38:         RenderPassLibrary(RenderPassLibrary&) = delete;\n   39          ~RenderPassLibrary();\n   40          using CreateFunc = std::function<RenderPass::SharedPtr(RenderContext*, const Dictionary&)>;\n\n/home/max/dev/Falcor/src/Falcor/Scene/Importers/AssimpImporter.h:\n   40      private:\n   41          AssimpImporter() = default;\n   42:         AssimpImporter(const AssimpImporter&) = delete;\n   43:         void operator=(const AssimpImporter&) = delete;\n   44      };\n   45  }\n\n/home/max/dev/Falcor/src/Falcor/Scene/ParticleSystem/ParticleSystem.h:\n  144  \n  145      private:\n  146:         ParticleSystem() = delete;\n  147          ParticleSystem(RenderContext* pCtx, uint32_t maxParticles, uint32_t maxEmitPerFrame,\n  148              std::string drawPixelShader, std::string simulateComputeShader, bool sorted);\n\n/home/max/dev/Falcor/src/Falcor/Utils/Logger.h:\n   99  \n  100          static void log(Level L, const std::string& msg, MsgBox mbox = Logger::MsgBox::Auto);\n  101:         Logger() = delete;\n  102      };\n  103  \n\n/home/max/dev/Falcor/src/Falcor/Utils/UI/Font.h:\n   81      private:\n   82          Font();\n   83:         Font(const Font&) = delete;\n   84:         Font& operator=(const Font&) = delete;\n   85  \n   86          bool loadFromFile(const std::string& fontName, float size);\n\n/home/max/dev/Falcor/src/Tools/ImageCompare/args.h:\n 1646              }\n 1647  \n 1648:             Subparser(const Subparser&) = delete;\n 1649:             Subparser(Subparser&&) = delete;\n 1650:             Subparser &operator = (const Subparser&) = delete;\n 1651:             Subparser &operator = (Subparser&&) = delete;\n 1652  \n 1653              const Command &GetCommand()\n\n/home/max/dev/Falcor/src/USD/hgiVk/blitEncoder.h:\n   45  \n   46  private:\n   47:     HgiVkBlitEncoder() = delete;\n   48:     HgiVkBlitEncoder & operator=(const HgiVkBlitEncoder&) = delete;\n   49:     HgiVkBlitEncoder(const HgiVkBlitEncoder&) = delete;\n   50  \n   51  private:\n\n/home/max/dev/Falcor/src/USD/hgiVk/buffer.h:\n   64  \n   65  private:\n   66:     HgiVkBuffer() = delete;\n   67:     HgiVkBuffer & operator=(const HgiVkBuffer&) = delete;\n   68:     HgiVkBuffer(const HgiVkBuffer&) = delete;\n   69  \n   70  private:\n\n/home/max/dev/Falcor/src/USD/hgiVk/commandBuffer.h:\n  110  \n  111  private:\n  112:     HgiVkCommandBuffer() = delete;\n  113:     HgiVkCommandBuffer & operator= (const HgiVkCommandBuffer&) = delete;\n  114:     HgiVkCommandBuffer(const HgiVkCommandBuffer&) = delete;\n  115  \n  116      // Ensures a command buffer is ready to record commands.\n\n/home/max/dev/Falcor/src/USD/hgiVk/commandBufferManager.h:\n  102  \n  103  private:\n  104:     HgiVkCommandBufferManager() = delete;\n  105      HgiVkCommandBufferManager & operator= (\n  106:         const HgiVkCommandBufferManager&) = delete;\n  107      HgiVkCommandBufferManager(\n  108:         const HgiVkCommandBufferManager&) = delete;\n  109  \n  110      // Create pools and command buffers for parallel recording.\n\n/home/max/dev/Falcor/src/USD/hgiVk/commandPool.h:\n   41  \n   42  private:\n   43:     HgiVkCommandPool() = delete;\n   44:     HgiVkCommandPool & operator= (const HgiVkCommandPool&) = delete;\n   45:     HgiVkCommandPool(const HgiVkCommandPool&) = delete;\n   46  \n   47  private:\n\n/home/max/dev/Falcor/src/USD/hgiVk/computeEncoder.h:\n   55  \n   56  private:\n   57:     HgiVkComputeEncoder() = delete;\n   58:     HgiVkComputeEncoder & operator=(const HgiVkComputeEncoder&) = delete;\n   59:     HgiVkComputeEncoder(const HgiVkComputeEncoder&) = delete;\n   60  \n   61  private:\n\n/home/max/dev/Falcor/src/USD/hgiVk/device.h:\n  167  \n  168  private:\n  169:     HgiVkDevice() = delete;\n  170:     HgiVkDevice & operator=(const HgiVkDevice&) = delete;\n  171:     HgiVkDevice(const HgiVkDevice&) = delete;\n  172  \n  173      // Returns true if the provided extension is supported by the device\n\n/home/max/dev/Falcor/src/USD/hgiVk/frame.h:\n   56  \n   57  private:\n   58:     HgiVkRenderFrame() = delete;\n   59:     HgiVkRenderFrame & operator=(const HgiVkRenderFrame&) = delete;\n   60:     HgiVkRenderFrame(const HgiVkRenderFrame&) = delete;\n   61  \n   62  private:\n\n/home/max/dev/Falcor/src/USD/hgiVk/garbageCollector.h:\n   41  \n   42  private:\n   43:     HgiVkGarbageCollector & operator=(const HgiVkGarbageCollector&) = delete;\n   44:     HgiVkGarbageCollector(const HgiVkGarbageCollector&) = delete;\n   45  \n   46      typedef std::vector<HgiVkObject> VkObjectVector;\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/ShaderLang.cpp:\n  982                             std::string* output)\n  983        : getLastSourceIndex(lastSourceIndex), output(output), lastSource(-1), lastLine(0) {}\n  984: //    SourceLineSynchronizer(const SourceLineSynchronizer&) = delete;\n  985: //    SourceLineSynchronizer& operator=(const SourceLineSynchronizer&) = delete;\n  986  \n  987      // Sets the internally tracked source string index to that of the most\n\n/home/max/dev/Falcor/src/USD/hgiVk/graphicsEncoder.h:\n   94  \n   95  private:\n   96:     HgiVkGraphicsEncoder() = delete;\n   97:     HgiVkGraphicsEncoder & operator=(const HgiVkGraphicsEncoder&) = delete;\n   98:     HgiVkGraphicsEncoder(const HgiVkGraphicsEncoder&) = delete;\n   99  \n  100  private:\n\n/home/max/dev/Falcor/src/USD/hgiVk/hgi.h:\n  150  \n  151  private:\n  152:     HgiVk & operator=(const HgiVk&) = delete;\n  153:     HgiVk(const HgiVk&) = delete;\n  154  \n  155      // Begin a new frame of rendering.\n\n/home/max/dev/Falcor/src/USD/hgiVk/parallelGraphicsEncoder.h:\n   44  \n   45  private:\n   46:     HgiVkParallelGraphicsEncoder() = delete;\n   47      HgiVkParallelGraphicsEncoder & operator=(\n   48:         const HgiVkParallelGraphicsEncoder&) = delete;\n   49      HgiVkParallelGraphicsEncoder(\n   50:         const HgiVkParallelGraphicsEncoder&) = delete;\n   51  \n   52  private:\n\n/home/max/dev/Falcor/src/USD/hgiVk/pipeline.h:\n   46  \n   47  private:\n   48:     HgiVkPipeline() = delete;\n   49:     HgiVkPipeline & operator=(const HgiVkPipeline&) = delete;\n   50:     HgiVkPipeline(const HgiVkPipeline&) = delete;\n   51  \n   52      // In Vulkan pipelines require compatibility with render passes.\n\n/home/max/dev/Falcor/src/USD/hgiVk/renderPass.h:\n  121  \n  122  private:\n  123:     HgiVkRenderPass() = delete;\n  124:     HgiVkRenderPass & operator=(const HgiVkRenderPass&) = delete;\n  125:     HgiVkRenderPass(const HgiVkRenderPass&) = delete;\n  126  \n  127      // Extracts the render pass information for one texture.\n\n/home/max/dev/Falcor/src/USD/hgiVk/renderPassPipelineCache.h:\n   71  private:\n   72      HgiVkRenderPassPipelineCache & operator= (\n   73:         const HgiVkRenderPassPipelineCache&) = delete;\n   74:     HgiVkRenderPassPipelineCache(const HgiVkRenderPassPipelineCache&) = delete;\n   75  \n   76  private:\n\n/home/max/dev/Falcor/src/USD/hgiVk/resourceBindings.h:\n   78  \n   79  private:\n   80:     HgiVkResourceBindings() = delete;\n   81:     HgiVkResourceBindings & operator=(const HgiVkResourceBindings&) = delete;\n   82:     HgiVkResourceBindings(const HgiVkResourceBindings&) = delete;\n   83  \n   84  private:\n\n/home/max/dev/Falcor/src/USD/hgiVk/shaderCompiler.h:\n   50  \n   51  private:\n   52:     HgiVkShaderCompiler & operator=(const HgiVkShaderCompiler&) = delete;\n   53:     HgiVkShaderCompiler(const HgiVkShaderCompiler&) = delete;\n   54  \n   55  private:\n\n/home/max/dev/Falcor/src/USD/hgiVk/shaderFunction.h:\n   48  \n   49  private:\n   50:     HgiVkShaderFunction() = delete;\n   51:     HgiVkShaderFunction & operator=(const HgiVkShaderFunction&) = delete;\n   52:     HgiVkShaderFunction(const HgiVkShaderFunction&) = delete;\n   53  \n   54  private:\n\n/home/max/dev/Falcor/src/USD/hgiVk/shaderProgram.h:\n   29  \n   30  private:\n   31:     HgiVkShaderProgram() = delete;\n   32:     HgiVkShaderProgram & operator=(const HgiVkShaderProgram&) = delete;\n   33:     HgiVkShaderProgram(const HgiVkShaderProgram&) = delete;\n   34  \n   35  private:\n\n/home/max/dev/Falcor/src/USD/hgiVk/surface.h:\n   53  \n   54  private:\n   55:     HgiVkSurface() = delete;\n   56:     HgiVkSurface & operator=(const HgiVkSurface&) = delete;\n   57:     HgiVkSurface(const HgiVkSurface&) = delete;\n   58  \n   59  private:\n\n/home/max/dev/Falcor/src/USD/hgiVk/swapchain.h:\n   58  \n   59  private:\n   60:     HgiVkSwapchain() = delete;\n   61:     HgiVkSwapchain & operator=(const HgiVkSwapchain&) = delete;\n   62:     HgiVkSwapchain(const HgiVkSwapchain&) = delete;\n   63  \n   64      // Create a new swapchain (e.g. during resize)\n\n/home/max/dev/Falcor/src/USD/hgiVk/texture.h:\n   80  \n   81  private:\n   82:     HgiVkTexture() = delete;\n   83:     HgiVkTexture & operator=(const HgiVkTexture&) = delete;\n   84:     HgiVkTexture(const HgiVkTexture&) = delete;\n   85  \n   86  private:\n\n/home/max/dev/Falcor/src/USD/hgiVk/vulkanMemoryAllocator/vk_mem_alloc.h:\n 3842      #define VMA_CLASS_NO_COPY(className) \\\n 3843          private: \\\n 3844:             className(const className&) = delete; \\\n 3845:             className& operator=(const className&) = delete;\n 3846  #endif\n 3847  \n ....\n 4370      }\n 4371  \n 4372:     VmaStlAllocator& operator=(const VmaStlAllocator& x) = delete;\n 4373  };\n 4374  \n\n92 matches across 36 files\n\n\nSearching 1282 files for \"LightCollection\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/BuildTriangleList.cs.slang:\n   30  import Scene.Scene;\n   31  import Utils.Color.ColorHelpers;\n   32: import Experimental.Scene.Lights.LightCollection;\n   33  \n   34  cbuffer CB\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/EmissiveIntegrator.ps.slang:\n   31  */\n   32  import Scene.Scene;\n   33: import Experimental.Scene.Lights.LightCollection;\n   34  \n   35  // Setup NvApi. We need this for fp32 atomics.\n   ..\n   43  #endif\n   44  \n   45: ParameterBlock<LightCollection> gLightCollection;\n   46  \n   47  RWByteAddressBuffer gTexelSum;          ///< Sum over texels (RGB) + number of texels (A) in RGBA32Float format. Using raw buffer for fp32 atomics compatibility.\n   ..\n   65      // Fetch light index\n   66      const uint triIdx = vtxIdx / 3;\n   67:     const uint id = gLightCollection.getLightIdx(triIdx);\n   68  \n   69      VsOut vsOut;\n   ..\n   73  \n   74      // Check if triangle is textured.\n   75:     if (gScene.isEmissiveTextured(gLightCollection.getMaterialID(triIdx)))\n   76      {\n   77          // TODO: We could do these computations in a geometry shader once per triangle,\n   ..\n   82          for (uint j = 0; j < 3; j++)\n   83          {\n   84:             uv[j] = gLightCollection.getVtxTexCoord(triIdx + j);\n   85          }\n   86          const float2 uvMin = min(min(uv[0], uv[1]), uv[2]);\n   ..\n   88  \n   89          // Pass on texture coordinate unmodified for pixel to use.\n   90:         vsOut.uv = gLightCollection.getVtxTexCoord(vtxIdx);                 // Normalized (u,v) coordinate.\n   91  \n   92          // Query texture dimensions.\n   93          float width = 0, height = 0, mips = 0;\n   94:         gScene.materialResources[gLightCollection.meshData[id].materialID].emissive.GetDimensions(0, width, height, mips);\n   95  \n   96          // Compute raster position in texture space.\n   ..\n  125      const float2 uv = vsIn.uv;        // Interpolated texture coordinate.\n  126      const uint lightIdx = vsIn.lightIdx;\n  127:     float3 color = gScene.materialResources[gLightCollection.meshData[lightIdx].materialID].emissive.SampleLevel(gPointSampler, uv, 0.f).rgb;  // Sampler at mip 0\n  128  \n  129      // Compute weighted color. TODO: For now assume full coverage (= 1.0 in weight).\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/EmissiveLightSamplerHelpers.slang:\n   29  /** Shared utility functions for emissive light sampler implementations.\n   30  \n   31:      These functions rely on LightCollection, which is a container holding the\n   32       global list of all emissive triangles in the scene.\n   33  \n   ..\n   41  import Scene.ShadingData;\n   42  import Utils.Math.MathHelpers;\n   43: import Experimental.Scene.Lights.LightCollection;\n   44  import Experimental.Scene.Lights.EmissiveLightSamplerInterface;\n   45  \n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/EmissiveUniformSampler.cpp:\n   41      {\n   42          // Make sure the light collection is created.\n   43:         mpScene->getLightCollection(pRenderContext);\n   44      }\n   45  \n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/EmissiveUniformSampler.h:\n   28  #pragma once\n   29  #include \"EmissiveLightSampler.h\"\n   30: #include \"LightCollection.h\"\n   31  \n   32  namespace Falcor\n   ..\n   34      /** Emissive light sampler using uniform sampling of the lights.\n   35  \n   36:         This class wraps a LightCollection object, which holds the set of lights to sample.\n   37      */\n   38      class dlldecl EmissiveUniformSampler : public EmissiveLightSampler, public inherit_shared_from_this<EmissiveLightSampler, EmissiveUniformSampler>\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/EmissiveUniformSampler.slang:\n   38      EmissiveLightSamplerInterface.slang for usage information).\n   39  \n   40:     The struct wraps a LightCollection that stores the pre-processed lights.\n   41      The program should instantiate the struct below. See EmissiveLightSampler.slang.\n   42  */\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/FinalizeIntegration.cs.slang:\n   30  import Scene.Scene;\n   31  import Utils.Color.ColorHelpers;\n   32: import Experimental.Scene.Lights.LightCollection;\n   33  \n   34  cbuffer CB\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVH.cpp:\n   35  namespace Falcor {\n   36  \n   37:     LightBVH::SharedPtr LightBVH::create(std::shared_ptr<Device> device, const LightCollection::SharedConstPtr& pLightCollection) {\n   38:         return SharedPtr(new LightBVH(device, pLightCollection));\n   39      }\n   40  \n   ..\n   46  \n   47          const ComputeVars::SharedPtr& pLeafUpdaterVars = mLeafUpdater->getVars();\n   48:         mpLightCollection->setShaderData(pLeafUpdaterVars[\"CB\"][\"gLights\"]);\n   49          pLeafUpdaterVars[\"CB\"][\"gLightBVH\"][\"nodes\"] = mpBVHNodesBuffer;\n   50          pLeafUpdaterVars[\"gNodeOffsets\"] = mpNodeOffsetsBuffer;\n   51  \n   52          const ComputeVars::SharedPtr& pInternalUpdaterVars = mInternalUpdater->getVars();\n   53:         mpLightCollection->setShaderData(pInternalUpdaterVars[\"CB\"][\"gLights\"]);\n   54          pInternalUpdaterVars[\"CB\"][\"gLightBVH\"][\"nodes\"] = mpBVHNodesBuffer;\n   55          pInternalUpdaterVars[\"gNodeOffsets\"] = mpNodeOffsetsBuffer;\n   ..\n  178      }\n  179  \n  180:     LightBVH::LightBVH(std::shared_ptr<Device> device, const LightCollection::SharedConstPtr& pLightCollection) : mpDevice(device), mpLightCollection(pLightCollection) {\n  181          verifyStaticParams();\n  182          mAlignedAllocator.setMinimumAlignment(16);\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVH.h:\n   30  \n   31  #include \"LightBVHStaticParams.slang\"\n   32: #include \"LightCollection.h\"\n   33  \n   34  #include \"Utils/AlignedAllocator.h\"\n   ..\n  127  \n  128          /** Creates an empty LightBVH object. Use a LightBVHBuilder to build the BVH.\n  129:             \\param[in] pLightCollection The light collection around which the BVH will be built.\n  130          */\n  131:         static SharedPtr create(std::shared_ptr<Device> device, const LightCollection::SharedConstPtr& pLightCollection);\n  132  \n  133          /** Refit all the BVH nodes to the underlying geometry, without changing the hierarchy.\n  ...\n  195  \n  196       protected:\n  197:         LightBVH(std::shared_ptr<Device> device, const LightCollection::SharedConstPtr& pLightCollection);\n  198  \n  199          void computeStats();\n  ...\n  226  \n  227          // Internal state\n  228:         const LightCollection::SharedConstPtr mpLightCollection;\n  229  \n  230          ComputePass::SharedPtr                mLeafUpdater;             ///< Compute pass for refitting the leaf nodes.\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVHBuilder.cpp:\n  221  \n  222          // Get global list of emissive triangles.\n  223:         assert(bvh.mpLightCollection);\n  224:         const auto& triangles = bvh.mpLightCollection->getMeshLightTriangles();\n  225          if (triangles.empty()) return;\n  226  \n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVHRefit.cs.slang:\n   29  \n   30  import Experimental.Scene.Lights.LightBVH;\n   31: import Experimental.Scene.Lights.LightCollection;\n   32  \n   33  cbuffer CB\n   34  {\n   35:     LightCollection     gLights;              ///< The light sources.\n   36      RWLightBVH          gLightBVH;            ///< The BVH around the light sources.\n   37      uint                gFirstNodeIndex;      ///< The index of the first node to be processed.\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVHSampler.cpp:\n   58  \n   59          // Check if light collection has changed.\n   60:         if (is_set(mpScene->getUpdates(), Scene::UpdateFlags::LightCollectionChanged))\n   61          {\n   62              if (mOptions.buildOptions.allowRefitting && !mNeedsRebuild) needsRefit = true;\n   ..\n  172              throw std::runtime_error(\"Failed to create BVH builder\");\n  173          }\n  174:         mpBVH = LightBVH::create(pRenderContext->device(), pScene->getLightCollection(pRenderContext));\n  175          if (!mpBVH) {\n  176              throw std::runtime_error(\"Failed to create BVH\");\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVHSampler.h:\n   31  #include \"LightBVH.h\"\n   32  #include \"LightBVHBuilder.h\"\n   33: #include \"LightCollection.h\"\n   34  #include \"LightBVHSamplerSharedDefinitions.slang\"\n   35  \n   ..\n   44      /** Emissive light sampler using a light BVH.\n   45  \n   46:         This class wraps a LightCollection object, which holds the set of lights to sample.\n   47          Internally, the class build a BVH over the light sources.\n   48      */\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVHSampler.slang:\n   34  import Experimental.Scene.Lights.LightBVH;\n   35  import Experimental.Scene.Lights.LightBVHSamplerSharedDefinitions;\n   36: import Experimental.Scene.Lights.LightCollection;\n   37  import Experimental.Scene.Lights.EmissiveLightSamplerHelpers;\n   38  import Experimental.Scene.Lights.EmissiveLightSamplerInterface;\n   ..\n   55      EmissiveLightSamplerInterface.slang for usage information).\n   56  \n   57:     The struct wraps a LightCollection that stores the pre-processed lights,\n   58      and a LightBVH that stores the data structure used for sampling.\n   59      The program should instantiate the struct below. See EmissiveLightSampler.slang.\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightCollection.cpp:\n   27   **************************************************************************/\n   28  #include \"stdafx.h\"\n   29: #include \"LightCollection.h\"\n   30: #include \"LightCollectionShared.slang\"\n   31  #include \"Scene/Scene.h\"\n   32  #include <sstream>\n   ..\n   46      }\n   47  \n   48:     LightCollection::SharedPtr LightCollection::create(RenderContext* pRenderContext, const std::shared_ptr<Scene>& pScene) {\n   49:         SharedPtr ptr = SharedPtr(new LightCollection());\n   50          return ptr->init(pRenderContext, pScene) ? ptr : nullptr;\n   51      }\n   52  \n   53:     bool LightCollection::update(RenderContext* pRenderContext, UpdateStatus* pUpdateStatus) {\n   54:         PROFILE(\"LightCollection::update()\");\n   55  \n   56          if (pUpdateStatus) {\n   ..\n   94      }\n   95  \n   96:     void LightCollection::renderUI(Gui::Widgets& widget) {\n   97          // Prints stats about the number of lights etc.\n   98          const MeshLightStats& stats = getStats();\n   ..\n  113      }\n  114  \n  115:     bool LightCollection::init(RenderContext* pRenderContext, const std::shared_ptr<Scene>& pScene) {\n  116          assert(pScene);\n  117          mpScene = pScene;\n  ...\n  138      }\n  139  \n  140:     bool LightCollection::initIntegrator(RenderContext* pRenderContext) {\n  141          // The current algorithm rasterizes emissive triangles in texture space,\n  142          // and uses atomic operations to sum up the contribution from all covered texels.\n  ...\n  146          std::string s;\n  147          if (findFileInShaderDirectories(\"NVAPI/nvHLSLExtns.h\", s) == false) {\n  148:             logError(\"LightCollection relies on NVAPI, which appears to be missing. Please make sure you have NVAPI installed (instructions are in the readme file)\");\n  149              return false;\n  150          }\n  ...\n  187      }\n  188  \n  189:     bool LightCollection::setupMeshLights() {\n  190          mMeshLights.clear();\n  191          mpSamplerState = nullptr;\n  ...\n  228      }\n  229  \n  230:     void LightCollection::build(RenderContext* pRenderContext) {\n  231          if (mTriangleCount == 0) {\n  232              // If there are no emissive triangle, clear everything and mark the CPU data/stats as valid.\n  ...\n  254      }\n  255  \n  256:     void LightCollection::prepareTriangleData(RenderContext* pRenderContext) {\n  257          // Create GPU buffers.\n  258          assert(mTriangleCount > 0);\n  ...\n  261  \n  262          mpMeshLightsVertexPos = Buffer::create(pRenderContext->device(), bufSize, Resource::BindFlags::ShaderResource | Resource::BindFlags::UnorderedAccess, Buffer::CpuAccess::None);\n  263:         mpMeshLightsVertexPos->setName(\"LightCollection_MeshLightsVertexPos\");\n  264          mpMeshLightsTexCoords = Buffer::create(pRenderContext->device(), uvBufSize, Resource::BindFlags::ShaderResource | Resource::BindFlags::UnorderedAccess, Buffer::CpuAccess::None);\n  265:         mpMeshLightsTexCoords->setName(\"LightCollection_MeshLightsTexCoords\");\n  266          mpTriangleData = Buffer::createStructured(pRenderContext->device(), mpTriangleListBuilder->getProgram().get(), \"gTriangleData\", mTriangleCount);\n  267:         mpTriangleData->setName(\"LightCollection_TriangleData\");\n  268  \n  269          // Compute triangle data (vertices, uv-coordinates, materialID) for all mesh lights.\n  ...\n  271      }\n  272  \n  273:     void LightCollection::prepareMeshData(RenderContext* pRenderContext) {\n  274          assert(mMeshLights.size() > 0);\n  275  \n  ...\n  299          // Create the GPU buffer.\n  300          mpPerMeshInstanceOffset = Buffer::createStructured(pRenderContext->device(), sizeof(uint32_t), instanceCount, Resource::BindFlags::ShaderResource);\n  301:         mpPerMeshInstanceOffset->setName(\"LightCollection_PerMeshInstanceOffset\");\n  302  \n  303          const size_t sizeInBytes = triangleOffsets.size() * sizeof(triangleOffsets[0]);\n  ...\n  306      }\n  307  \n  308:     void LightCollection::integrateEmissive(RenderContext* pRenderContext) {\n  309          assert(mTriangleCount > 0);\n  310          assert(mMeshLights.size() > 0);\n  ...\n  317              if (!mIntegrator.pResultBuffer || mIntegrator.pResultBuffer->getSize() < bufSize) {\n  318                  mIntegrator.pResultBuffer = Buffer::create(pRenderContext->device(), bufSize, Resource::BindFlags::ShaderResource | Resource::BindFlags::UnorderedAccess, Buffer::CpuAccess::None);\n  319:                 mIntegrator.pResultBuffer->setName(\"LightCollection_IntegratorResults\");\n  320                  assert(mIntegrator.pResultBuffer);\n  321              }\n  ...\n  331  \n  332              // Bind light collection.\n  333:             setShaderData(mIntegrator.pVars[\"gLightCollection\"]);\n  334  \n  335              // Bind our resources.\n  ...\n  359      }\n  360  \n  361:     void LightCollection::computeStats() const {\n  362          if (mStatsValid) return;\n  363  \n  ...\n  402      }\n  403  \n  404:     void LightCollection::buildTriangleList(RenderContext* pRenderContext) {\n  405          assert(mMeshLights.size() > 0);\n  406  \n  ...\n  429      }\n  430  \n  431:     void LightCollection::updateTrianglePositions(RenderContext* pRenderContext, const std::vector<uint32_t>& updatedLights) {\n  432          // This pass pre-transforms all emissive triangles into world space and updates their area and face normals.\n  433          // It is executed if any geometry in the scene has moved, which is wasteful since it will update also things\n  ...\n  454      }\n  455  \n  456:     bool LightCollection::setShaderData(const ShaderVar& var) const {\n  457          assert(var.isValid());\n  458  \n  ...\n  486      }\n  487  \n  488:     void LightCollection::copyDataToStagingBuffer(RenderContext* pRenderContext) const {\n  489          if (mStagingBufferValid) return;\n  490  \n  ...\n  493          if (!mpStagingBuffer || mpStagingBuffer->getSize() < stagingSize) {\n  494              mpStagingBuffer = Buffer::create(pRenderContext->device(), stagingSize, Resource::BindFlags::None, Buffer::CpuAccess::Read);\n  495:             mpStagingBuffer->setName(\"LightCollection_StagingBuffer\");\n  496              mCPUInvalidData = CPUOutOfDateFlags::All;\n  497          }\n  ...\n  520      }\n  521  \n  522:     void LightCollection::syncCPUData() const {\n  523          if (mCPUInvalidData == CPUOutOfDateFlags::None) return;\n  524  \n  ...\n  526          // This should normally have done by calling prepareSyncCPUData().\n  527          if (!mStagingBufferValid) {\n  528:             logWarning(\"LightCollection::syncCPUData() performance warning - Call LightCollection::prepareSyncCPUData() ahead of time if possible\");\n  529              prepareSyncCPUData(gpDevice->getRenderContext());\n  530          }\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightCollection.h:\n   41  \n   42      This class has utility functions for updating and pre-processing the mesh lights.\n   43:     The LightCollection can be used standalone, but more commonly it will be wrapped\n   44      by an emissive light sampler.\n   45  */\n   46: class dlldecl LightCollection : public std::enable_shared_from_this<LightCollection> {\n   47   public:\n   48:     using SharedPtr = std::shared_ptr<LightCollection>;\n   49:     using ConstSharedPtrRef = const std::shared_ptr<LightCollection>&;\n   50:     using SharedConstPtr = std::shared_ptr<const LightCollection>;\n   51  \n   52      enum class UpdateFlags : uint32_t {\n   ..\n  102  \n  103  \n  104:     ~LightCollection() = default;\n  105  \n  106      /** Creates a light collection for the given scene.\n  ...\n  170  \n  171   protected:\n  172:     LightCollection() = default;\n  173  \n  174      bool init(RenderContext* pRenderContext, const std::shared_ptr<Scene>& pScene);\n  ...\n  227  };\n  228  \n  229: enum_class_operators(LightCollection::CPUOutOfDateFlags);\n  230: enum_class_operators(LightCollection::UpdateFlags);\n  231  \n  232  }  // namespace Falcor\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightCollection.slang:\n   29  \n   30  import Scene.ShadingData;\n   31: __exported import Experimental.Scene.Lights.LightCollectionShared;\n   32  __exported import Experimental.Scene.Lights.MeshLightData;\n   33  \n   ..\n   37      quantities such as emitted flux are pre-computed.\n   38  \n   39:     The user code instantiates LightCollection in e.g. a parameter block and\n   40      calls member functions on the CPU-side class to update/bind it to their program.\n   41  */\n   42: struct LightCollection\n   43  {\n   44      uint                                triangleCount;          ///< Total number of triangles in all mesh lights.\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/MeshLightData.slang:\n   42  {\n   43      uint        meshInstanceID      = kInvalidIndex;    ///< Mesh instance ID in the scene (= getGlobalHitID()).\n   44:     uint        triangleOffset      = kInvalidIndex;    ///< Offset into LightCollection's global list of emissive triangles.\n   45      uint        triangleCount       = 0;                ///< Number of triangles in mesh light.\n   46      uint        materialID          = kInvalidIndex;    ///< Material ID (index into scene.materials array).\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/UpdateTriangleVertices.cs.slang:\n   29  \n   30  import Scene.Scene;\n   31: import Experimental.Scene.Lights.LightCollection;\n   32  \n   33  cbuffer CB\n\n/home/max/dev/Falcor/src/Falcor/Falcor.vcxproj:\n  130      <ClInclude Include=\"Experimental\\Scene\\Lights\\LightBVHSampler.h\" />\n  131      <ShaderSource Include=\"Experimental\\Scene\\Lights\\EmissiveLightSamplerType.slangh\" />\n  132:     <ClInclude Include=\"Experimental\\Scene\\Lights\\LightCollection.h\" />\n  133      <ShaderSource Include=\"Experimental\\Scene\\Lights\\FinalizeIntegration.cs.slang\" />\n  134      <ShaderSource Include=\"Experimental\\Scene\\Lights\\LightBVHSamplerSharedDefinitions.slang\" />\n  135      <ShaderSource Include=\"Experimental\\Scene\\Lights\\LightBVHStaticParams.slang\" />\n  136:     <ShaderSource Include=\"Experimental\\Scene\\Lights\\LightCollectionShared.slang\" />\n  137      <ClInclude Include=\"Raytracing\\RtProgramVars.h\" />\n  138      <ClInclude Include=\"Raytracing\\RtProgramVarsHelper.h\" />\n  ...\n  586      <ClCompile Include=\"Experimental\\Scene\\Lights\\LightBVHBuilder.cpp\" />\n  587      <ClCompile Include=\"Experimental\\Scene\\Lights\\LightBVHSampler.cpp\" />\n  588:     <ClCompile Include=\"Experimental\\Scene\\Lights\\LightCollection.cpp\" />\n  589      <ClCompile Include=\"Raytracing\\RtProgramVars.cpp\" />\n  590      <ClCompile Include=\"Raytracing\\RtProgramVarsHelper.cpp\" />\n  ...\n  672      <ShaderSource Include=\"Experimental\\Scene\\Lights\\LightBVHRefit.cs.slang\" />\n  673      <ShaderSource Include=\"Experimental\\Scene\\Lights\\LightBVHSampler.slang\" />\n  674:     <ShaderSource Include=\"Experimental\\Scene\\Lights\\LightCollection.slang\" />\n  675      <ShaderSource Include=\"Experimental\\Scene\\Lights\\LightHelpers.slang\" />\n  676      <ShaderSource Include=\"Experimental\\Scene\\Material\\MaterialHelpers.slang\" />\n\n/home/max/dev/Falcor/src/Falcor/Falcor.vcxproj.filters:\n  473        <Filter>Experimental\\Scene\\Lights</Filter>\n  474      </ClInclude>\n  475:     <ClInclude Include=\"Experimental\\Scene\\Lights\\LightCollection.h\">\n  476        <Filter>Experimental\\Scene\\Lights</Filter>\n  477      </ClInclude>\n  ...\n 1150        <Filter>Experimental\\Scene\\Lights</Filter>\n 1151      </ClCompile>\n 1152:     <ClCompile Include=\"Experimental\\Scene\\Lights\\LightCollection.cpp\">\n 1153        <Filter>Experimental\\Scene\\Lights</Filter>\n 1154      </ClCompile>\n ....\n 1230        <Filter>Experimental\\Scene\\Lights</Filter>\n 1231      </ShaderSource>\n 1232:     <ShaderSource Include=\"Experimental\\Scene\\Lights\\LightCollection.slang\">\n 1233        <Filter>Experimental\\Scene\\Lights</Filter>\n 1234      </ShaderSource>\n ....\n 1398        <Filter>Experimental\\Scene\\Lights</Filter>\n 1399      </ShaderSource>\n 1400:     <ShaderSource Include=\"Experimental\\Scene\\Lights\\LightCollectionShared.slang\">\n 1401        <Filter>Experimental\\Scene\\Lights</Filter>\n 1402      </ShaderSource>\n\n/home/max/dev/Falcor/src/Falcor/RenderPasses/Shared/PathTracer/PathTracer.cpp:\n  452                  lightingChanged = mpEmissiveSampler->update(pRenderContext);\n  453  \n  454:                 const auto& lightCollection = mpScene->getLightCollection(pRenderContext);\n  455  \n  456                  // Update shared parameters.\n\n/home/max/dev/Falcor/src/Falcor/Scene/Scene.cpp:\n  137  }\n  138  \n  139: LightCollection::ConstSharedPtrRef Scene::getLightCollection(RenderContext* pContext) {\n  140:     if (!mpLightCollection) {\n  141:         mpLightCollection = LightCollection::create(pContext, shared_from_this());\n  142:         mpLightCollection->setShaderData(mpSceneBlock[\"lightCollection\"]);\n  143      }\n  144:     return mpLightCollection;\n  145  }\n  146  \n  ...\n  443  \n  444      // Update light collection\n  445:     if (mpLightCollection && mpLightCollection->update(pContext)) mUpdates |= UpdateFlags::LightCollectionChanged;\n  446  \n  447      return mUpdates;\n  ...\n  521          statsGroup.text(oss.str());\n  522  \n  523:         if (mpLightCollection) {\n  524              auto lightCollectionGroup = Gui::Group(widget, \"Mesh lights\", true);\n  525:             if (lightCollectionGroup.open()) mpLightCollection->renderUI(lightCollectionGroup);\n  526              lightCollectionGroup.release();\n  527          } else {\n\n/home/max/dev/Falcor/src/Falcor/Scene/Scene.h:\n   38  #include \"Animation/AnimationController.h\"\n   39  #include \"Camera/CameraController.h\"\n   40: #include \"Experimental/Scene/Lights/LightCollection.h\"\n   41  #include \"SceneTypes.slang\"\n   42  \n   ..\n  105              LightPropertiesChanged      = 0x20, ///< Other light changes not included in LightIntensityChanged and LightsMoved\n  106              SceneGraphChanged           = 0x40, ///< Any transform in the scene graph changed.\n  107:             LightCollectionChanged      = 0x80, ///< Light collection changed (mesh lights)\n  108              MaterialsChanged            = 0x100,///< Materials changed\n  109  \n  ...\n  241              \\return Returns the light collection.\n  242          */\n  243:         LightCollection::ConstSharedPtrRef getLightCollection(RenderContext* pContext);\n  244  \n  245          /** Get the light probe or nullptr if it doesn't exist.\n  ...\n  470          std::vector<Material::SharedPtr> mMaterials;        ///< Bound to parameter block\n  471          std::vector<AnimatedObject<Light>> mLights;         ///< Bound to parameter block\n  472:         LightCollection::SharedPtr mpLightCollection;       ///< Bound to parameter block\n  473          LightProbe::SharedPtr mpLightProbe;                 ///< Bound to parameter block\n  474          Texture::SharedPtr mpEnvMap;                        ///< Not bound to anything, not rendered automatically. Can be used to render a skybox\n\n/home/max/dev/Falcor/src/Falcor/Scene/Scene.slang:\n   37  import TextureSampler;\n   38  import Utils.Attributes;\n   39: import Experimental.Scene.Lights.LightCollection;\n   40  import Experimental.Scene.Material.TexLODHelpers;\n   41  \n   ..\n   68      // Lights and camera\n   69      StructuredBuffer<LightData> lights;\n   70:     LightCollection lightCollection;\n   71      LightProbeData lightProbe;\n   72      Texture2D envMap;\n\n119 matches across 25 files\n\n\nSearching 1282 files for \"Scene* pScene\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Raytracing/ShaderTable.h:\n   60          /** Create a new object\n   61          */\n   62:         static SharedPtr create();//RtProgram* pProgram, const Scene* pScene);\n   63  \n   64          /** Update the shader table.\n\n/home/max/dev/Falcor/src/Falcor/Scene/Animation/AnimationController.cpp:\n   38  }  // namespace\n   39  \n   40:     AnimationController::AnimationController(Scene* pScene, const StaticVertexVector& staticVertexData, const DynamicVertexVector& dynamicVertexData) :\n   41          mpScene(pScene), mLocalMatrices(pScene->mSceneGraph.size()), mInvTransposeGlobalMatrices(pScene->mSceneGraph.size()), mMatricesChanged(pScene->mSceneGraph.size())\n   42      {\n   ..\n   50      }\n   51  \n   52:     AnimationController::UniquePtr AnimationController::create(Scene* pScene, const StaticVertexVector& staticVertexData, const DynamicVertexVector& dynamicVertexData) {\n   53          return UniquePtr(new AnimationController(pScene, staticVertexData, dynamicVertexData));\n   54      }\n\n/home/max/dev/Falcor/src/Falcor/Scene/Animation/AnimationController.h:\n   63          /** Create a new object\n   64          */\n   65:         static UniquePtr create(Scene* pScene, const StaticVertexVector& staticVertexData, const DynamicVertexVector& dynamicVertexData);\n   66          \n   67          /** Add an animation for a mesh\n   ..\n  116      private:\n  117          friend class SceneBuilder;\n  118:         AnimationController(Scene* pScene, const StaticVertexVector& staticVertexData, const DynamicVertexVector& dynamicVertexData);\n  119  \n  120          void allocatePrevWorldMatrixBuffer();\n\n/home/max/dev/Falcor/src/Falcor/Scene/HitInfo.h:\n   40      /** Returns defines needed packing/unpacking a HitInfo struct.\n   41      */\n   42:     static Shader::DefineList getDefines(const Scene* pScene) {\n   43          // Setup bit allocations for encoding the meshInstanceID and primitive indices.\n   44  \n\n/home/max/dev/Falcor/src/Falcor/Scene/Importers/AssimpImporter.cpp:\n  184          public:\n  185              ImporterData(const aiScene* pAiScene, SceneBuilder& sceneBuilder, const SceneBuilder::InstanceMatrices& modelInstances_) : pScene(pAiScene), modelInstances(modelInstances_), builder(sceneBuilder) {}\n  186:             const aiScene* pScene;\n  187  \n  188              SceneBuilder& builder;\n  ...\n  531          bool createMeshes(ImporterData& data)\n  532          {\n  533:             const aiScene* pScene = data.pScene;\n  534              for (uint32_t i = 0; i < pScene->mNumMeshes; i++)\n  535              {\n  ...\n  661          void createBoneList(ImporterData& data)\n  662          {\n  663:             const aiScene* pScene = data.pScene;\n  664              auto& boneMatrices = data.localToBindPoseMatrices;\n  665  \n  ...\n  927          }\n  928  \n  929:         BoneMeshMap createBoneMap(const aiScene* pScene)\n  930          {\n  931              BoneMeshMap boneMap;\n  ...\n  952          }\n  953  \n  954:         MeshInstanceList countMeshInstances(const aiScene* pScene)\n  955          {\n  956              MeshInstanceList meshInstances(pScene->mNumMeshes);\n  ...\n  973          }\n  974  \n  975:         bool validateBones(const aiScene* pScene)\n  976          {\n  977              // Make sure that each bone is only affecting a single mesh.\n  ...\n 1002          }\n 1003  \n 1004:         void verifyScene(const aiScene* pScene)\n 1005          {\n 1006              bool b = true;\n ....\n 1039  \n 1040          Assimp::Importer importer;\n 1041:         const aiScene* pScene = importer.ReadFile(fullpath, assimpFlags);\n 1042  \n 1043          if (pScene == nullptr)\n\n/home/max/dev/Falcor/src/Falcor/Scene/SceneBuilder.cpp:\n  352      }\n  353  \n  354:     void SceneBuilder::createGlobalMatricesBuffer(Scene* pScene)\n  355      {\n  356          pScene->mSceneGraph.resize(mSceneGraph.size());\n  ...\n  363      }\n  364  \n  365:     uint32_t SceneBuilder::createMeshData(Scene* pScene)\n  366      {\n  367          auto& meshData = pScene->mMeshDesc;\n  ...\n  444      }\n  445  \n  446:     void SceneBuilder::calculateMeshBoundingBoxes(Scene* pScene)\n  447      {\n  448          // Calculate mesh bounding boxes\n  ...\n  474      }\n  475  \n  476:     void SceneBuilder::createAnimationController(Scene* pScene)\n  477      {\n  478          pScene->mpAnimationController = AnimationController::create(pScene, mBuffersData.staticData, mBuffersData.dynamicData);\n\n/home/max/dev/Falcor/src/Falcor/Scene/SceneBuilder.h:\n  221      Vao::SharedPtr createVao(uint16_t drawCount);\n  222  \n  223:     uint32_t createMeshData(Scene* pScene);\n  224:     void createGlobalMatricesBuffer(Scene* pScene);\n  225:     void calculateMeshBoundingBoxes(Scene* pScene);\n  226:     void createAnimationController(Scene* pScene);\n  227      std::string mFilename;\n  228  };\n\n22 matches across 7 files\n\n\nSearching 1282 files for \"UnitTestContext\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Testing/UnitTest.cpp:\n   94          auto startTime = std::chrono::steady_clock::now();\n   95  \n   96:         CPUUnitTestContext cpuCtx;\n   97:         GPUUnitTestContext gpuCtx(pRenderContext);\n   98  \n   99          std::string extraMessage;\n  ...\n  180      ///////////////////////////////////////////////////////////////////////////\n  181  \n  182:     void GPUUnitTestContext::createProgram( const std::string& path,\n  183                                              const std::string& entry,\n  184                                              const Program::DefineList& programDefines,\n  ...\n  196      }\n  197  \n  198:     void GPUUnitTestContext::createVars() {\n  199          // Create shader variables.\n  200          ProgramReflection::SharedConstPtr pReflection = mpProgram->getReflector();\n  ...\n  208      }\n  209  \n  210:     void GPUUnitTestContext::allocateStructuredBuffer(const std::string& name, uint32_t nElements, const void* pInitData, size_t initDataSize) {\n  211          assert(mpVars);\n  212          mStructuredBuffers[name].pBuffer = Buffer::createStructured(mpProgram.get(), name, nElements);\n  ...\n  220      }\n  221  \n  222:     void GPUUnitTestContext::runProgram(const uint3& dimensions) {\n  223          assert(mpVars);\n  224          for (const auto& buffer : mStructuredBuffers) {\n  ...\n  232      }\n  233  \n  234:     void GPUUnitTestContext::unmapBuffer(const char* bufferName) {\n  235          assert(mStructuredBuffers.find(bufferName) != mStructuredBuffers.end());\n  236          \n  ...\n  243      }\n  244  \n  245:     const void* GPUUnitTestContext::mapRawRead(const char* bufferName) {\n  246          assert(mStructuredBuffers.find(bufferName) != mStructuredBuffers.end());\n  247  \n\n/home/max/dev/Falcor/src/Falcor/Testing/UnitTest.h:\n   54      static constexpr int kMaxTestFailures = 25;\n   55  \n   56:     class CPUUnitTestContext;\n   57:     class GPUUnitTestContext;\n   58  \n   59      struct TooManyFailedTestsException : public std::exception { };\n   ..\n   69      };\n   70  \n   71:     using CPUTestFunc = std::function<void(CPUUnitTestContext& ctx)>;\n   72:     using GPUTestFunc = std::function<void(GPUUnitTestContext& ctx)>;\n   73  \n   74      dlldecl void registerCPUTest(const std::string& filename, const std::string& name, const std::string& skipMessage, CPUTestFunc func);\n   ..\n   76      dlldecl int32_t runTests(std::ostream& stream, RenderContext* pRenderContext, const std::string& testFilterRegexp);\n   77  \n   78:     class dlldecl UnitTestContext {\n   79       public:\n   80          /** reportFailure is called with an error message to report a failing\n   ..\n   95      };\n   96  \n   97:     class dlldecl CPUUnitTestContext : public UnitTestContext { };\n   98  \n   99:     class dlldecl GPUUnitTestContext : public UnitTestContext {\n  100       public:\n  101:         GPUUnitTestContext(RenderContext* pContext) : mpContext(pContext) { }\n  102  \n  103          /** createProgram creates a compute program from the source code at the\n  ...\n  207          StreamSink does the former, and if it has passed, it does the latter.)\n  208          In the event of a test failure, passes along the failure message to the\n  209:         provided GPUUnitTestContext's |reportFailure| method.\n  210      */\n  211      class StreamSink {\n  ...\n  218  \n  219          /** Construct a StreamSink for a test context.\n  220:             If a non-nullptr UnitTestContext is provided, the values printed\n  221              will be accumulated and passed to the context's reportFailure()\n  222              method when the StreamSink destructor runs.\n  223          */\n  224:         StreamSink(UnitTestContext* ctx) : mpCtx(ctx) {}\n  225  \n  226          ~StreamSink() {\n  ...\n  268      private:\n  269          std::stringstream mSs;\n  270:         UnitTestContext* mpCtx = nullptr;\n  271      };\n  272  \n  273      template <typename T, typename U>\n  274      inline StreamSink expectEqInternal(T x, const char* xString, U y, const char* yString,\n  275:                                        UnitTestContext& ctx, const char* file, int line) {\n  276          if (x == y) return StreamSink(nullptr);\n  277  \n  ...\n  285      template <typename T, typename U>\n  286      inline StreamSink expectNeInternal(T x, const char* xString, U y, const char* yString,\n  287:                                        UnitTestContext& ctx, const char* file, int line) {\n  288          if (x != y) return StreamSink(nullptr);\n  289  \n  ...\n  297      template <typename T, typename U>\n  298      inline StreamSink expectGeInternal(T x, const char* xString, U y, const char* yString,\n  299:                                        UnitTestContext& ctx, const char* file, int line) {\n  300          if (x >= y) return StreamSink(nullptr);\n  301  \n  ...\n  309      template <typename T, typename U>\n  310      inline StreamSink expectGtInternal(T x, const char* xString, U y, const char* yString,\n  311:                                        UnitTestContext& ctx, const char* file, int line) {\n  312          if (x > y) return StreamSink(nullptr);\n  313  \n  ...\n  321      template <typename T, typename U>\n  322      inline StreamSink expectLeInternal(T x, const char* xString, U y, const char* yString,\n  323:                                        UnitTestContext& ctx, const char* file, int line) {\n  324          if (x <= y) return StreamSink(nullptr);\n  325  \n  ...\n  333      template <typename T, typename U>\n  334      inline StreamSink expectLtInternal(T x, const char* xString, U y, const char* yString,\n  335:                                        UnitTestContext& ctx, const char* file, int line) {\n  336          if (x < y) return StreamSink(nullptr);\n  337  \n  ...\n  344  \n  345      template <typename T>\n  346:     inline StreamSink expectInternal(T x, const char* xString, UnitTestContext& ctx,\n  347                                       const char* file, int line) {\n  348          if (x) return StreamSink(nullptr);\n  ...\n  368  */\n  369  #define CPU_TEST(Name, ...)                                                     \\\n  370:     static void CPUUnitTest##Name(CPUUnitTestContext& ctx);                     \\\n  371      struct CPUUnitTestRegisterer##Name {                                        \\\n  372          CPUUnitTestRegisterer##Name()                                           \\\n  ...\n  376          }                                                                       \\\n  377      } RegisterCPUTest##Name;                                                    \\\n  378:     static void CPUUnitTest##Name(CPUUnitTestContext& ctx) /* over to the user for the braces */\n  379  \n  380  /** Macro to define a GPU unit test. The optional skip message will\n  ...\n  383  */\n  384  #define GPU_TEST(Name, ...)                                                     \\\n  385:     static void GPUUnitTest##Name(GPUUnitTestContext& ctx);                     \\\n  386      struct GPUUnitTestRegisterer##Name {                                        \\\n  387          GPUUnitTestRegisterer##Name()                                           \\\n  ...\n  391          }                                                                       \\\n  392      } RegisterGPUTest##Name;                                                    \\\n  393:     static void GPUUnitTest##Name(GPUUnitTestContext& ctx) /* over to the user for the braces */\n  394  \n  395  /** Macro definitions for the GPU unit testing framework. Note that they\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Core/BufferAccessTests.cpp:\n   47      The test binds the buffer to a compute program which reads back the data.\n   48  */\n   49: void testBufferReadback(GPUUnitTestContext& ctx, Buffer::CpuAccess cpuAccess) {\n   50      auto pBuf = createTestBuffer(cpuAccess);\n   51  \n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Core/BufferTests.cpp:\n   42  \n   43          template <Type type>\n   44:         void testBuffer(GPUUnitTestContext& ctx, uint32_t numElems, uint32_t index = 0, uint32_t count = 0)\n   45          {\n   46              numElems = div_round_up(numElems, 256u) * 256u; // Make sure we run full thread groups.\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Core/RootBufferParamBlockTests.cpp:\n   46          auto r = [&]() -> uint32_t { return dist(rng); };\n   47  \n   48:         void testRootBuffer(GPUUnitTestContext& ctx, const std::string& shaderModel, bool useUav)\n   49          {\n   50              Program::DefineList defines = { {\"USE_UAV\", useUav ? \"1\" : \"0\"} };\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Core/RootBufferStructTests.cpp:\n   40          auto r = [&]() -> uint32_t { return dist(rng); };\n   41  \n   42:         void testRootBufferInStruct(GPUUnitTestContext& ctx, const std::string& shaderModel, bool useUav)\n   43          {\n   44              Program::DefineList defines = { {\"USE_UAV\", useUav ? \"1\" : \"0\"} };\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Core/RootBufferTests.cpp:\n   49          };\n   50  \n   51:         void testRootBuffer(GPUUnitTestContext& ctx, const std::string& shaderModel, bool useUav)\n   52          {\n   53              Program::DefineList defines = { {\"USE_UAV\", useUav ? \"1\" : \"0\"} };\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Sampling/SampleGeneratorTests.cpp:\n   72          }\n   73  \n   74:         void testSampleGenerator(GPUUnitTestContext& ctx, uint32_t type, const double corrThreshold, bool testInstances)\n   75          {\n   76              // Create sample generator.\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Slang/Int64Tests.cpp:\n   50          std::mt19937 r;\n   51  \n   52:         void test(GPUUnitTestContext& ctx, const std::string& shaderModel, bool useUav)\n   53          {\n   54              Program::DefineList defines = { {\"USE_UAV\", useUav ? \"1\" : \"0\"} };\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Slang/ShaderModel.cpp:\n   34          const uint32_t kNumElems = 256;\n   35  \n   36:         void test(GPUUnitTestContext& ctx, const std::string& shaderModel)\n   37          {\n   38              ctx.createProgram(\"Tests/Slang/ShaderModel.cs.slang\", \"main\", Program::DefineList(), Shader::CompilerFlags::None, shaderModel);\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Slang/SlangTests.cpp:\n   45      namespace\n   46      {\n   47:         void testEnum(GPUUnitTestContext& ctx, const std::string& shaderModel)\n   48          {\n   49              ctx.createProgram(\"Tests/Slang/SlangTests.cs.slang\", \"testEnum\", Program::DefineList(), Shader::CompilerFlags::None, shaderModel);\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Slang/TraceRayFlags.cpp:\n   51  }\n   52  #endif\n   53: void testRayFlags(GPUUnitTestContext& ctx, uint32_t expected, const Program::DefineList& defines, const std::string& shaderModel) {\n   54      ctx.createProgram(\"Tests/Slang/TraceRayFlags.cs.slang\", \"testRayFlags\", defines, Shader::CompilerFlags::None, shaderModel);\n   55      ctx.allocateStructuredBuffer(\"result\", 1);\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Utils/BitonicSortTests.cpp:\n   45          }\n   46  \n   47:         void testGpuSort(GPUUnitTestContext& ctx, BitonicSort* pSort, const uint32_t n, const uint32_t chunkSize)\n   48          {\n   49              // Create a buffer of random data to use as test data.\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Utils/HalfUtilsTests.cpp:\n  175          }\n  176  \n  177:         std::vector<float> generateFP16TestData(UnitTestContext& ctx)\n  178          {\n  179              std::vector<float> data;\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Utils/MathHelpersTests.cpp:\n   43          };\n   44  \n   45:         void runBBoxTestComputeShader(GPUUnitTestContext& ctx, const BBoxTestCase* testCases, int nTests, const char* entrypoint)\n   46          {\n   47              Buffer::SharedPtr pOriginBuffer = Buffer::createTyped<float3>(nTests);\n   ..\n   67          }\n   68  \n   69:         void testKnownBBoxes(GPUUnitTestContext& ctx, const char* entrypoint)\n   70          {\n   71              // Generate test data...\n   ..\n  112          }\n  113  \n  114:         void testRandomBBoxes(GPUUnitTestContext& ctx, const char* entrypoint)\n  115          {\n  116              // Generate test data.\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Utils/ParallelReductionTests.cpp:\n   87  \n   88          template<typename DataType, typename RefType>\n   89:         void testReduction(GPUUnitTestContext& ctx, const ComputeParallelReduction::SharedPtr& pReduction, ResourceFormat format, uint32_t width, uint32_t height)\n   90          {\n   91              // Create random test data.\n   ..\n  208          }\n  209  \n  210:         void testReduction(GPUUnitTestContext& ctx, const ComputeParallelReduction::SharedPtr& pReduction, ResourceFormat format, uint32_t width, uint32_t height)\n  211          {\n  212              const FormatType type = getFormatType(format);\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Utils/PrefixSumTests.cpp:\n   49          }\n   50  \n   51:         void testPrefixSum(GPUUnitTestContext& ctx, const PrefixSum::SharedPtr& pPrefixSum, uint32_t numElems)\n   52          {\n   53              // Create a buffer of random data to use as test data.\n\n51 matches across 17 files\n\n\nSearching 1282 files for \"FrameRate\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/Renderer.h:\n   35  \n   36  class Clock;\n   37: class FrameRate;\n   38  \n   39  /** Sample configuration\n   ..\n   64      virtual Clock& getGlobalClock() = 0;\n   65  \n   66:     /** Get the global FrameRate object\n   67      */\n   68:     virtual FrameRate& getFrameRate() = 0;\n   69  \n   70      /** Resize the swap-chain buffers*/\n\n/home/max/dev/Falcor/src/Falcor/Core/Sample.cpp:\n   51  Sample::Sample(Device::SharedPtr pDevice, IRenderer::UniquePtr& pRenderer) : mpRenderer(std::move(pRenderer)), mpDevice(pDevice) {\n   52      mClock = nullptr;\n   53:     mFrameRate = nullptr;\n   54  }\n   55  \n   ..\n  124                          mVsyncOn = !mVsyncOn;\n  125                          mpDevice->toggleVSync(mVsyncOn);\n  126:                         mFrameRate.reset();\n  127                          mClock.setTime(0);\n  128                          break;\n  ...\n  288          pBar = nullptr;\n  289  \n  290:         mFrameRate->reset();\n  291          mpWindow->msgLoop();\n  292  \n  ...\n  418              }\n  419  \n  420:             mpGui->render(getRenderContext(), mpDevice->getSwapChainFbo(), (float)mFrameRate.getLastFrameTime());\n  421          }\n  422      }\n  ...\n  429  \n  430          mClock.tick();\n  431:         mFrameRate.newFrame();\n  432          if (mVideoCapture.fixedTimeDelta) { mClock.setTime(mVideoCapture.currentTime); }\n  433  \n\n/home/max/dev/Falcor/src/Falcor/Core/Sample.h:\n   39  #include \"Renderer.h\"\n   40  #include \"Falcor/Utils/ArgList.h\"\n   41: #include \"Falcor/Utils/Timing/FrameRate.h\"\n   42  #include \"Falcor/Utils/UI/Gui.h\"\n   43  #include \"Falcor/Utils/UI/TextRenderer.h\"\n   ..\n   81      Window* getWindow() override { return mpWindow.get(); }\n   82      Clock& getGlobalClock() override { return mClock; }\n   83:     FrameRate& getFrameRate() override { return mFrameRate; }\n   84      void resizeSwapChain(uint32_t width, uint32_t height) override;\n   85      bool isKeyPressed(const KeyboardEvent::Key& key) override;\n   ..\n  132      bool mCaptureScreen = false;\n  133      \n  134:     FrameRate *mFrameRate;\n  135      Clock *mClock;\n  136  \n\n/home/max/dev/Falcor/src/Falcor/Falcor.h:\n  148  #include \"Falcor/Utils/Timing/CpuTimer.h\"\n  149  #include \"Falcor/Utils/Timing/Clock.h\"\n  150: #include \"Falcor/Utils/Timing/FrameRate.h\"\n  151  #include \"Falcor/Utils/Timing/Profiler.h\"\n  152  #include \"Falcor/Utils/UI/Font.h\"\n\n/home/max/dev/Falcor/src/Falcor/Falcor.vcxproj:\n  271      <ClInclude Include=\"Utils\\Timing\\Clock.h\" />\n  272      <ClInclude Include=\"Utils\\Timing\\CpuTimer.h\" />\n  273:     <ClInclude Include=\"Utils\\Timing\\FrameRate.h\" />\n  274      <ClInclude Include=\"Utils\\Timing\\Profiler.h\" />\n  275      <ClInclude Include=\"Utils\\UI\\DebugDrawer.h\" />\n  ...\n  651      <ClCompile Include=\"Utils\\Threading.cpp\" />\n  652      <ClCompile Include=\"Utils\\Timing\\Clock.cpp\" />\n  653:     <ClCompile Include=\"Utils\\Timing\\FrameRate.cpp\" />\n  654      <ClCompile Include=\"Utils\\Timing\\Profiler.cpp\" />\n  655      <ClCompile Include=\"Utils\\UI\\DebugDrawer.cpp\" />\n\n/home/max/dev/Falcor/src/Falcor/Falcor.vcxproj.filters:\n  196        <Filter>Utils\\Timing</Filter>\n  197      </ClInclude>\n  198:     <ClInclude Include=\"Utils\\Timing\\FrameRate.h\">\n  199        <Filter>Utils\\Timing</Filter>\n  200      </ClInclude>\n  ...\n 1054        <Filter>Utils</Filter>\n 1055      </ClCompile>\n 1056:     <ClCompile Include=\"Utils\\Timing\\FrameRate.cpp\">\n 1057        <Filter>Utils\\Timing</Filter>\n 1058      </ClCompile>\n\n/home/max/dev/Falcor/src/Falcor/Utils/Timing/FrameRate.cpp:\n   27   **************************************************************************/\n   28  #include \"stdafx.h\"\n   29: #include \"Falcor/Utils/Timing/FrameRate.h\"\n   30  #include <sstream>\n   31  \n   32  namespace Falcor {\n   33  \n   34: std::string FrameRate::getMsg(bool vsyncOn) const {\n   35      float msPerFrame = (float)getAverageFrameTime();\n   36      std::stringstream strstr;\n   ..\n   43  }  // namespace Falcor\n   44  \n   45: const uint64_t Falcor::FrameRate::sFrameWindow = 60;\n\n/home/max/dev/Falcor/src/Falcor/Utils/Timing/FrameRate.h:\n   39  /** Framerate calculator\n   40  */\n   41: class dlldecl FrameRate {\n   42  public:\n   43:     FrameRate(std::shared_ptr<Device> pDevice) {\n   44          mClock = new Clock(pDevice);\n   45          mFrameTimes.resize(sFrameWindow);\n   ..\n   47      }\n   48  \n   49:     ~FrameRate() {\n   50          delete mClock;\n   51      }\n   ..\n   99  };\n  100  \n  101: inline std::string to_string(const FrameRate& fr, bool vsyncOn = false) { return fr.getMsg(vsyncOn); }\n  102  \n  103  }  // namespace Falcor\n\n/home/max/dev/Falcor/src/Mogwai/Extensions/Profiler/TimingCapture.cpp:\n   83          if (!mFrameTimeFile.is_open()) return;\n   84  \n   85:         // The FrameRate object is updated at the start of each frame, the first valid time is available on the second frame.\n   86:         auto& frameRate = gpFramework->getFrameRate();\n   87          if (frameRate.getFrameCount() > 1)\n   88              mFrameTimeFile << frameRate.getLastFrameTime() << std::endl;\n\n/home/max/dev/Falcor/src/Mogwai/MogwaiSettings.cpp:\n   57  void showFps(Gui* pGui) {\n   58      Gui::Window w(pGui, \"##FPS\", { 0, 0 }, { 10, 25 }, Gui::WindowFlags::AllowMove | Gui::WindowFlags::AutoResize | Gui::WindowFlags::SetFocus);\n   59:     std::string msg = gpFramework->getFrameRate().getMsg(gpFramework->isVsyncEnabled());\n   60      w.text(msg);\n   61  }\n\n/home/max/dev/Falcor/src/Samples/HelloDXR/HelloDXR.cpp:\n  129      }\n  130  \n  131:     TextRenderer::render(pRenderContext, gpFramework->getFrameRate().getMsg(), pTargetFbo, { 20, 20 });\n  132  }\n  133  \n\n/home/max/dev/Falcor/src/Tools/RenderGraphEditor/RenderGraphEditor.cpp:\n  265  \n  266      if (mUpdateFilePath.size()) {\n  267:         mRenderGraphUIs[mCurrentGraphIndex].writeUpdateScriptToFile(pRenderContext, mUpdateFilePath, (float)gpFramework->getFrameRate().getLastFrameTime());\n  268      }\n  269  \n\n32 matches across 12 files\n\n\nSearching 1282 files for \"getGlobalClock\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/Sample.h:\n   81      Window* getWindow() override { return mpWindow.get(); }\n   82      \n   83:     //Clock& getGlobalClock() override { return mClock; }\n   84  \n   85      Clock& getClock() override { return *mClock; }\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightCollection.cpp:\n   73              if (mpScene->getAnimationController()->getMeshAnimationCount(instanceData.meshID) > 0) {\n   74                  bool hasAnimation = mpScene->getAnimationController()->getActiveAnimation(instanceData.meshID) != AnimationController::kBindPoseAnimationId;\n   75:                 bool isPaused = gpFramework->getGlobalClock().isPaused();\n   76                  if (hasAnimation && !isPaused) updateFlags |= UpdateFlags::AnimationChanged;\n   77              }\n\n/home/max/dev/Falcor/src/Mogwai/Extensions/Capture/CaptureTrigger.cpp:\n  101          RenderGraph* pGraph = mpRenderer->getActiveGraph();\n  102          if (!pGraph) return;\n  103:         uint64_t frameId = gpFramework->getGlobalClock().getFrame();\n  104          if (mGraphRanges.find(pGraph) == mGraphRanges.end()) return;\n  105          const auto& ranges = mGraphRanges.at(pGraph);\n  ...\n  127      {\n  128          if (!mCurrent.pGraph) return;\n  129:         uint64_t frameId = gpFramework->getGlobalClock().getFrame();\n  130          const auto& ranges = mGraphRanges.at(mCurrent.pGraph);\n  131  \n\n/home/max/dev/Falcor/src/Mogwai/Extensions/Capture/FrameCapture.cpp:\n  125              Texture* pTex = pGraph->getOutput(i)->asTexture().get();\n  126              assert(pTex);\n  127:             std::string filename = getOutputNamePrefix(pGraph->getOutputName(i)) + to_string(gpFramework->getGlobalClock().getFrame()) + \".\";;\n  128              auto ext = Bitmap::getFileExtFromResourceFormat(pTex->getFormat());\n  129              filename += ext;\n  ...\n  157          auto pGraph = mpRenderer->getActiveGraph();\n  158          if (!pGraph) return;\n  159:         uint64_t frameID = gpFramework->getGlobalClock().getFrame();\n  160          triggerFrame(gpDevice->getRenderContext(), pGraph, frameID);\n  161      }\n\n/home/max/dev/Falcor/src/Mogwai/Mogwai.cpp:\n  419  \n  420      for (auto& g : mGraphs) g.pGraph->setScene(mpScene);\n  421:     gpFramework->getGlobalClock().setTime(0);\n  422  }\n  423  \n  ...\n  492          // Update scene and camera.\n  493          if (mpScene) {\n  494:             mpScene->update(pRenderContext, gpFramework->getGlobalClock().getTime());\n  495          }\n  496  \n\n/home/max/dev/Falcor/src/Mogwai/MogwaiScripting.cpp:\n  105  \n  106      s += \"# Time Settings\\n\";\n  107:     s += gpFramework->getGlobalClock().getScript(kTimeVar) + \"\\n\";\n  108  \n  109      for (auto& pe : mpExtensions) {\n  ...\n  138      Extension::Bindings b(m, c);\n  139      b.addGlobalObject(kRendererVar, this, \"The engine\");\n  140:     b.addGlobalObject(kTimeVar, &gpFramework->getGlobalClock(), \"Time Utilities\");\n  141      for (auto& pe : mpExtensions) pe->scriptBindings(b);\n  142      mGlobalHelpMessage = prepareHelpMessage(b.mGlobalObjects);\n\n/home/max/dev/Falcor/src/Mogwai/MogwaiSettings.cpp:\n  132      Gui::Window w(pGui, \"Time\", mShowTime, { 0, 0 }, { 350, 25 }, Gui::WindowFlags::AllowMove | Gui::WindowFlags::AutoResize | Gui::WindowFlags::ShowTitleBar | Gui::WindowFlags::CloseButton);\n  133  \n  134:     Clock& clock = gpFramework->getGlobalClock();\n  135      clock.renderUI(w);\n  136      w.separator(2);\n\n/home/max/dev/Falcor/src/RenderPasses/DebugPasses/SplitScreenPass/SplitScreenPass.cpp:\n   61  {\n   62      mpArrowTex = Texture::create2D(16, 16, ResourceFormat::R8Unorm, 1, Texture::kMaxPossible, kArrowArray);\n   63:     mClock = gpFramework->getGlobalClock();\n   64      createProgram();\n   65  }\n\n/home/max/dev/Falcor/src/Samples/HelloDXR/HelloDXR.cpp:\n  124      if(mpScene)\n  125      {\n  126:         mpScene->update(pRenderContext, gpFramework->getGlobalClock().getTime());\n  127          if (mRayTrace) renderRT(pRenderContext, pTargetFbo.get());\n  128          else mpRasterPass->renderScene(pRenderContext, pTargetFbo);\n\n/home/max/dev/Falcor/src/Samples/ModelViewer/ModelViewer.cpp:\n  165  \n  166      if(mpScene) {\n  167:         mpScene->update(pRenderContext, gpFramework->getGlobalClock().getTime());\n  168  \n  169          // Set render state\n\n/home/max/dev/Falcor/src/Samples/ShaderToy/ShaderToy.cpp:\n   58      float height = (float)pTargetFbo->getHeight();\n   59      mpMainPass[\"ToyCB\"][\"iResolution\"] = float2(width, height);\n   60:     mpMainPass[\"ToyCB\"][\"iGlobalTime\"] = (float)gpFramework->getGlobalClock().getTime();\n   61  \n   62      // run final pass\n\n15 matches across 11 files\n\n\nSearching 1282 files for \"getGlobalClock\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/Sample.h:\n   81      Window* getWindow() override { return mpWindow.get(); }\n   82      \n   83:     //Clock& getGlobalClock() override { return mClock; }\n   84  \n   85      Clock& getClock() override { return *mClock; }\n\n/home/max/dev/Falcor/src/Mogwai/Extensions/Capture/CaptureTrigger.cpp:\n  101          RenderGraph* pGraph = mpRenderer->getActiveGraph();\n  102          if (!pGraph) return;\n  103:         uint64_t frameId = gpFramework->getGlobalClock().getFrame();\n  104          if (mGraphRanges.find(pGraph) == mGraphRanges.end()) return;\n  105          const auto& ranges = mGraphRanges.at(pGraph);\n  ...\n  127      {\n  128          if (!mCurrent.pGraph) return;\n  129:         uint64_t frameId = gpFramework->getGlobalClock().getFrame();\n  130          const auto& ranges = mGraphRanges.at(mCurrent.pGraph);\n  131  \n\n/home/max/dev/Falcor/src/Mogwai/Extensions/Capture/FrameCapture.cpp:\n  125              Texture* pTex = pGraph->getOutput(i)->asTexture().get();\n  126              assert(pTex);\n  127:             std::string filename = getOutputNamePrefix(pGraph->getOutputName(i)) + to_string(gpFramework->getGlobalClock().getFrame()) + \".\";;\n  128              auto ext = Bitmap::getFileExtFromResourceFormat(pTex->getFormat());\n  129              filename += ext;\n  ...\n  157          auto pGraph = mpRenderer->getActiveGraph();\n  158          if (!pGraph) return;\n  159:         uint64_t frameID = gpFramework->getGlobalClock().getFrame();\n  160          triggerFrame(gpDevice->getRenderContext(), pGraph, frameID);\n  161      }\n\n/home/max/dev/Falcor/src/Mogwai/Mogwai.cpp:\n  419  \n  420      for (auto& g : mGraphs) g.pGraph->setScene(mpScene);\n  421:     gpFramework->getGlobalClock().setTime(0);\n  422  }\n  423  \n  ...\n  492          // Update scene and camera.\n  493          if (mpScene) {\n  494:             mpScene->update(pRenderContext, gpFramework->getGlobalClock().getTime());\n  495          }\n  496  \n\n/home/max/dev/Falcor/src/Mogwai/MogwaiScripting.cpp:\n  105  \n  106      s += \"# Time Settings\\n\";\n  107:     s += gpFramework->getGlobalClock().getScript(kTimeVar) + \"\\n\";\n  108  \n  109      for (auto& pe : mpExtensions) {\n  ...\n  138      Extension::Bindings b(m, c);\n  139      b.addGlobalObject(kRendererVar, this, \"The engine\");\n  140:     b.addGlobalObject(kTimeVar, &gpFramework->getGlobalClock(), \"Time Utilities\");\n  141      for (auto& pe : mpExtensions) pe->scriptBindings(b);\n  142      mGlobalHelpMessage = prepareHelpMessage(b.mGlobalObjects);\n\n/home/max/dev/Falcor/src/Mogwai/MogwaiSettings.cpp:\n  132      Gui::Window w(pGui, \"Time\", mShowTime, { 0, 0 }, { 350, 25 }, Gui::WindowFlags::AllowMove | Gui::WindowFlags::AutoResize | Gui::WindowFlags::ShowTitleBar | Gui::WindowFlags::CloseButton);\n  133  \n  134:     Clock& clock = gpFramework->getGlobalClock();\n  135      clock.renderUI(w);\n  136      w.separator(2);\n\n/home/max/dev/Falcor/src/RenderPasses/DebugPasses/SplitScreenPass/SplitScreenPass.cpp:\n   61  {\n   62      mpArrowTex = Texture::create2D(16, 16, ResourceFormat::R8Unorm, 1, Texture::kMaxPossible, kArrowArray);\n   63:     mClock = gpFramework->getGlobalClock();\n   64      createProgram();\n   65  }\n\n/home/max/dev/Falcor/src/Samples/HelloDXR/HelloDXR.cpp:\n  124      if(mpScene)\n  125      {\n  126:         mpScene->update(pRenderContext, gpFramework->getGlobalClock().getTime());\n  127          if (mRayTrace) renderRT(pRenderContext, pTargetFbo.get());\n  128          else mpRasterPass->renderScene(pRenderContext, pTargetFbo);\n\n/home/max/dev/Falcor/src/Samples/ModelViewer/ModelViewer.cpp:\n  165  \n  166      if(mpScene) {\n  167:         mpScene->update(pRenderContext, gpFramework->getGlobalClock().getTime());\n  168  \n  169          // Set render state\n\n/home/max/dev/Falcor/src/Samples/ShaderToy/ShaderToy.cpp:\n   58      float height = (float)pTargetFbo->getHeight();\n   59      mpMainPass[\"ToyCB\"][\"iResolution\"] = float2(width, height);\n   60:     mpMainPass[\"ToyCB\"][\"iGlobalTime\"] = (float)gpFramework->getGlobalClock().getTime();\n   61  \n   62      // run final pass\n\n14 matches across 10 files\n\n\nSearching 1282 files for \"getGlobalClock\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/Sample.h:\n   81      Window* getWindow() override { return mpWindow.get(); }\n   82      \n   83:     //Clock& getGlobalClock() override { return mClock; }\n   84  \n   85      Clock& getClock() override { return *mClock; }\n\n/home/max/dev/Falcor/src/Mogwai/Extensions/Capture/FrameCapture.cpp:\n  125              Texture* pTex = pGraph->getOutput(i)->asTexture().get();\n  126              assert(pTex);\n  127:             std::string filename = getOutputNamePrefix(pGraph->getOutputName(i)) + to_string(gpFramework->getGlobalClock().getFrame()) + \".\";;\n  128              auto ext = Bitmap::getFileExtFromResourceFormat(pTex->getFormat());\n  129              filename += ext;\n  ...\n  157          auto pGraph = mpRenderer->getActiveGraph();\n  158          if (!pGraph) return;\n  159:         uint64_t frameID = gpFramework->getGlobalClock().getFrame();\n  160          triggerFrame(gpDevice->getRenderContext(), pGraph, frameID);\n  161      }\n\n/home/max/dev/Falcor/src/Mogwai/Mogwai.cpp:\n  419  \n  420      for (auto& g : mGraphs) g.pGraph->setScene(mpScene);\n  421:     gpFramework->getGlobalClock().setTime(0);\n  422  }\n  423  \n  ...\n  492          // Update scene and camera.\n  493          if (mpScene) {\n  494:             mpScene->update(pRenderContext, gpFramework->getGlobalClock().getTime());\n  495          }\n  496  \n\n/home/max/dev/Falcor/src/Mogwai/MogwaiScripting.cpp:\n  105  \n  106      s += \"# Time Settings\\n\";\n  107:     s += gpFramework->getGlobalClock().getScript(kTimeVar) + \"\\n\";\n  108  \n  109      for (auto& pe : mpExtensions) {\n  ...\n  138      Extension::Bindings b(m, c);\n  139      b.addGlobalObject(kRendererVar, this, \"The engine\");\n  140:     b.addGlobalObject(kTimeVar, &gpFramework->getGlobalClock(), \"Time Utilities\");\n  141      for (auto& pe : mpExtensions) pe->scriptBindings(b);\n  142      mGlobalHelpMessage = prepareHelpMessage(b.mGlobalObjects);\n\n/home/max/dev/Falcor/src/Mogwai/MogwaiSettings.cpp:\n  132      Gui::Window w(pGui, \"Time\", mShowTime, { 0, 0 }, { 350, 25 }, Gui::WindowFlags::AllowMove | Gui::WindowFlags::AutoResize | Gui::WindowFlags::ShowTitleBar | Gui::WindowFlags::CloseButton);\n  133  \n  134:     Clock& clock = gpFramework->getGlobalClock();\n  135      clock.renderUI(w);\n  136      w.separator(2);\n\n/home/max/dev/Falcor/src/RenderPasses/DebugPasses/SplitScreenPass/SplitScreenPass.cpp:\n   61  {\n   62      mpArrowTex = Texture::create2D(16, 16, ResourceFormat::R8Unorm, 1, Texture::kMaxPossible, kArrowArray);\n   63:     mClock = gpFramework->getGlobalClock();\n   64      createProgram();\n   65  }\n\n/home/max/dev/Falcor/src/Samples/HelloDXR/HelloDXR.cpp:\n  124      if(mpScene)\n  125      {\n  126:         mpScene->update(pRenderContext, gpFramework->getGlobalClock().getTime());\n  127          if (mRayTrace) renderRT(pRenderContext, pTargetFbo.get());\n  128          else mpRasterPass->renderScene(pRenderContext, pTargetFbo);\n\n/home/max/dev/Falcor/src/Samples/ModelViewer/ModelViewer.cpp:\n  165  \n  166      if(mpScene) {\n  167:         mpScene->update(pRenderContext, gpFramework->getGlobalClock().getTime());\n  168  \n  169          // Set render state\n\n/home/max/dev/Falcor/src/Samples/ShaderToy/ShaderToy.cpp:\n   58      float height = (float)pTargetFbo->getHeight();\n   59      mpMainPass[\"ToyCB\"][\"iResolution\"] = float2(width, height);\n   60:     mpMainPass[\"ToyCB\"][\"iGlobalTime\"] = (float)gpFramework->getGlobalClock().getTime();\n   61  \n   62      // run final pass\n\n12 matches across 9 files\n\n\nSearching 1282 files for \"getGlobalClock\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/Sample.h:\n   81      Window* getWindow() override { return mpWindow.get(); }\n   82      \n   83:     //Clock& getGlobalClock() override { return mClock; }\n   84  \n   85      Clock& getClock() override { return *mClock; }\n\n/home/max/dev/Falcor/src/Mogwai/Extensions/Capture/FrameCapture.cpp:\n  157          auto pGraph = mpRenderer->getActiveGraph();\n  158          if (!pGraph) return;\n  159:         uint64_t frameID = gpFramework->getGlobalClock().getFrame();\n  160          triggerFrame(gpDevice->getRenderContext(), pGraph, frameID);\n  161      }\n\n/home/max/dev/Falcor/src/Mogwai/Mogwai.cpp:\n  419  \n  420      for (auto& g : mGraphs) g.pGraph->setScene(mpScene);\n  421:     gpFramework->getGlobalClock().setTime(0);\n  422  }\n  423  \n  ...\n  492          // Update scene and camera.\n  493          if (mpScene) {\n  494:             mpScene->update(pRenderContext, gpFramework->getGlobalClock().getTime());\n  495          }\n  496  \n\n/home/max/dev/Falcor/src/Mogwai/MogwaiScripting.cpp:\n  105  \n  106      s += \"# Time Settings\\n\";\n  107:     s += gpFramework->getGlobalClock().getScript(kTimeVar) + \"\\n\";\n  108  \n  109      for (auto& pe : mpExtensions) {\n  ...\n  138      Extension::Bindings b(m, c);\n  139      b.addGlobalObject(kRendererVar, this, \"The engine\");\n  140:     b.addGlobalObject(kTimeVar, &gpFramework->getGlobalClock(), \"Time Utilities\");\n  141      for (auto& pe : mpExtensions) pe->scriptBindings(b);\n  142      mGlobalHelpMessage = prepareHelpMessage(b.mGlobalObjects);\n\n/home/max/dev/Falcor/src/Mogwai/MogwaiSettings.cpp:\n  132      Gui::Window w(pGui, \"Time\", mShowTime, { 0, 0 }, { 350, 25 }, Gui::WindowFlags::AllowMove | Gui::WindowFlags::AutoResize | Gui::WindowFlags::ShowTitleBar | Gui::WindowFlags::CloseButton);\n  133  \n  134:     Clock& clock = gpFramework->getGlobalClock();\n  135      clock.renderUI(w);\n  136      w.separator(2);\n\n/home/max/dev/Falcor/src/RenderPasses/DebugPasses/SplitScreenPass/SplitScreenPass.cpp:\n   61  {\n   62      mpArrowTex = Texture::create2D(16, 16, ResourceFormat::R8Unorm, 1, Texture::kMaxPossible, kArrowArray);\n   63:     mClock = gpFramework->getGlobalClock();\n   64      createProgram();\n   65  }\n\n/home/max/dev/Falcor/src/Samples/HelloDXR/HelloDXR.cpp:\n  124      if(mpScene)\n  125      {\n  126:         mpScene->update(pRenderContext, gpFramework->getGlobalClock().getTime());\n  127          if (mRayTrace) renderRT(pRenderContext, pTargetFbo.get());\n  128          else mpRasterPass->renderScene(pRenderContext, pTargetFbo);\n\n/home/max/dev/Falcor/src/Samples/ModelViewer/ModelViewer.cpp:\n  165  \n  166      if(mpScene) {\n  167:         mpScene->update(pRenderContext, gpFramework->getGlobalClock().getTime());\n  168  \n  169          // Set render state\n\n/home/max/dev/Falcor/src/Samples/ShaderToy/ShaderToy.cpp:\n   58      float height = (float)pTargetFbo->getHeight();\n   59      mpMainPass[\"ToyCB\"][\"iResolution\"] = float2(width, height);\n   60:     mpMainPass[\"ToyCB\"][\"iGlobalTime\"] = (float)gpFramework->getGlobalClock().getTime();\n   61  \n   62      // run final pass\n\n11 matches across 9 files\n\n\nSearching 1282 files for \"_profileEvent\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Utils/Timing/Profiler.h:\n  189  \n  190  #if _PROFILING_ENABLED\n  191: #define PROFILE_ALL_FLAGS(_name) Falcor::ProfilerEvent _profileEvent##__LINE__(_name)\n  192: #define PROFILE_SOME_FLAGS(_name, _flags) Falcor::ProfilerEvent _profileEvent##__LINE__(_name, _flags)\n  193  \n  194  #define GET_PROFILE(_1, _2, NAME, ...) NAME\n\n2 matches in 1 file\n\n\nSearching 1282 files for \"createDescriptorSetLayout\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKDescriptorSet.cpp:\n   37  namespace Falcor {\n   38  \n   39:     VkDescriptorSetLayout createDescriptorSetLayout(const DescriptorSet::Layout& layout);\n   40      VkDescriptorType falcorToVkDescType(DescriptorPool::Type type);\n   41  \n   42      void DescriptorSet::apiInit() {\n   43:         auto layout = createDescriptorSetLayout(mLayout);\n   44          VkDescriptorSetAllocateInfo allocInfo = {};\n   45          allocInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKRootSignature.cpp:\n   67      }\n   68  \n   69:     VkDescriptorSetLayout createDescriptorSetLayout(std::shared_ptr<Device> device, const DescriptorSet::Layout& layout) {\n   70          std::vector<VkDescriptorSetLayoutBinding> bindings(layout.getRangeCount());\n   71  \n   ..\n  120          }\n  121  \n  122:         static VkDescriptorSetLayout emptyLayout = createDescriptorSetLayout(mpDevice, {});   // #VKTODO This gets deleted multiple times on exit\n  123          std::vector<VkDescriptorSetLayout> vkSetLayouts(maxIndex + 1, emptyLayout);\n  124  \n  125          for (const auto& set : mDesc.mSets) {\n  126:             vkSetLayouts[set.getRange(0).regSpace] = createDescriptorSetLayout(mpDevice, set); //createDescriptorSetLayout() verifies that all ranges use the same register space\n  127          }\n  128  \n\n6 matches across 2 files\n\n\nSearching 1282 files for \"createDescriptorSetLayout\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKDescriptorSet.cpp:\n   37  namespace Falcor {\n   38  \n   39:     VkDescriptorSetLayout createDescriptorSetLayout(std::shared_ptr<Device> pDevice, const DescriptorSet::Layout& layout);\n   40      VkDescriptorType falcorToVkDescType(DescriptorPool::Type type);\n   41  \n   42      void DescriptorSet::apiInit() {\n   43:         auto layout = createDescriptorSetLayout(mpDevice, mLayout);\n   44          VkDescriptorSetAllocateInfo allocInfo = {};\n   45          allocInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKRootSignature.cpp:\n   67      }\n   68  \n   69:     VkDescriptorSetLayout createDescriptorSetLayout(std::shared_ptr<Device> device, const DescriptorSet::Layout& layout) {\n   70          std::vector<VkDescriptorSetLayoutBinding> bindings(layout.getRangeCount());\n   71  \n   ..\n  120          }\n  121  \n  122:         static VkDescriptorSetLayout emptyLayout = createDescriptorSetLayout(mpDevice, {});   // #VKTODO This gets deleted multiple times on exit\n  123          std::vector<VkDescriptorSetLayout> vkSetLayouts(maxIndex + 1, emptyLayout);\n  124  \n  125          for (const auto& set : mDesc.mSets) {\n  126:             vkSetLayouts[set.getRange(0).regSpace] = createDescriptorSetLayout(mpDevice, set); //createDescriptorSetLayout() verifies that all ranges use the same register space\n  127          }\n  128  \n\n6 matches across 2 files\n\n\nSearching 1282 files for \"createDescriptorSetLayout\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKDescriptorSet.cpp:\n   37  namespace Falcor {\n   38  \n   39:     VkDescriptorSetLayout createDescriptorSetLayout(std::shared_ptr<Device> pDevice, const DescriptorSet::Layout& layout);\n   40      VkDescriptorType falcorToVkDescType(DescriptorPool::Type type);\n   41  \n   42      void DescriptorSet::apiInit() {\n   43:         auto layout = createDescriptorSetLayout(mpDevice, mLayout);\n   44          VkDescriptorSetAllocateInfo allocInfo = {};\n   45          allocInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKRootSignature.cpp:\n   67      }\n   68  \n   69:     VkDescriptorSetLayout createDescriptorSetLayout(std::shared_ptr<Device> pDevice, const DescriptorSet::Layout& layout) {\n   70          std::vector<VkDescriptorSetLayoutBinding> bindings(layout.getRangeCount());\n   71  \n   ..\n  120          }\n  121  \n  122:         static VkDescriptorSetLayout emptyLayout = createDescriptorSetLayout(mpDevice, {});   // #VKTODO This gets deleted multiple times on exit\n  123          std::vector<VkDescriptorSetLayout> vkSetLayouts(maxIndex + 1, emptyLayout);\n  124  \n  125          for (const auto& set : mDesc.mSets) {\n  126:             vkSetLayouts[set.getRange(0).regSpace] = createDescriptorSetLayout(mpDevice, set); //createDescriptorSetLayout() verifies that all ranges use the same register space\n  127          }\n  128  \n\n6 matches across 2 files\n\n\nSearching 1282 files for \"getBufferDataAlignment\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Buffer.cpp:\n   57  }  // namespace\n   58  \n   59: size_t getBufferDataAlignment(const Buffer* pBuffer);\n   60  void* mapBufferApi(const Buffer::ApiHandle& apiHandle, size_t size);\n   61  \n   ..\n  250  \n  251          mpCBV = nullptr;\n  252:         mDynamicData = mpDevice->getUploadHeap()->allocate(mSize, getBufferDataAlignment(this));\n  253          mApiHandle = mDynamicData.pResourceHandle;\n  254          mGpuVaOffset = mDynamicData.offset;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Buffer.cpp:\n   61      }\n   62  \n   63:     size_t getBufferDataAlignment(const Buffer* pBuffer)\n   64      {\n   65          // This in order of the alignment size\n   ..\n   97              {\n   98                  assert(gpDevice);\n   99:                 mDynamicData = gpDevice->getUploadHeap()->allocate(mSize, getBufferDataAlignment(this));\n  100                  mApiHandle = mDynamicData.pResourceHandle;\n  101                  mGpuVaOffset = mDynamicData.offset;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKBuffer.cpp:\n   80  }\n   81  \n   82: size_t getBufferDataAlignment(Device::SharedPtr device, const Buffer* pBuffer) {\n   83      VkMemoryRequirements reqs;\n   84      vkGetBufferMemoryRequirements(device->getApiHandle(), pBuffer->getApiHandle(), &reqs);\n\n5 matches across 3 files\n\n\nSearching 1282 files for \"getBufferDataAlignment\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Buffer.cpp:\n   57  }  // namespace\n   58  \n   59: size_t getBufferDataAlignment(Device::SharedPtr pDevice, const Buffer* pBuffer);\n   60  void* mapBufferApi(const Buffer::ApiHandle& apiHandle, size_t size);\n   61  \n   ..\n  250  \n  251          mpCBV = nullptr;\n  252:         mDynamicData = mpDevice->getUploadHeap()->allocate(mSize, getBufferDataAlignment(mpDevice, this));\n  253          mApiHandle = mDynamicData.pResourceHandle;\n  254          mGpuVaOffset = mDynamicData.offset;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Buffer.cpp:\n   61      }\n   62  \n   63:     size_t getBufferDataAlignment(const Buffer* pBuffer)\n   64      {\n   65          // This in order of the alignment size\n   ..\n   97              {\n   98                  assert(gpDevice);\n   99:                 mDynamicData = gpDevice->getUploadHeap()->allocate(mSize, getBufferDataAlignment(this));\n  100                  mApiHandle = mDynamicData.pResourceHandle;\n  101                  mGpuVaOffset = mDynamicData.offset;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKBuffer.cpp:\n   80  }\n   81  \n   82: size_t getBufferDataAlignment(Device::SharedPtr device, const Buffer* pBuffer) {\n   83      VkMemoryRequirements reqs;\n   84      vkGetBufferMemoryRequirements(device->getApiHandle(), pBuffer->getApiHandle(), &reqs);\n\n5 matches across 3 files\n\n\nSearching 1282 files for \"getBufferDataAlignment\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Buffer.cpp:\n   57  }  // namespace\n   58  \n   59: size_t getBufferDataAlignment(const Buffer* pBuffer);\n   60  void* mapBufferApi(const Buffer::ApiHandle& apiHandle, size_t size);\n   61  \n   ..\n  250  \n  251          mpCBV = nullptr;\n  252:         mDynamicData = mpDevice->getUploadHeap()->allocate(mSize, getBufferDataAlignment(this));\n  253          mApiHandle = mDynamicData.pResourceHandle;\n  254          mGpuVaOffset = mDynamicData.offset;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Buffer.cpp:\n   61      }\n   62  \n   63:     size_t getBufferDataAlignment(const Buffer* pBuffer)\n   64      {\n   65          // This in order of the alignment size\n   ..\n   97              {\n   98                  assert(gpDevice);\n   99:                 mDynamicData = gpDevice->getUploadHeap()->allocate(mSize, getBufferDataAlignment(this));\n  100                  mApiHandle = mDynamicData.pResourceHandle;\n  101                  mGpuVaOffset = mDynamicData.offset;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKBuffer.cpp:\n   80  }\n   81  \n   82: size_t getBufferDataAlignment(Device::SharedPtr pDevice, const Buffer* pBuffer) {\n   83      VkMemoryRequirements reqs;\n   84      vkGetBufferMemoryRequirements(pDevice->getApiHandle(), pBuffer->getApiHandle(), &reqs);\n\n5 matches across 3 files\n\n\nSearching 1282 files for \"getBufferDataAlignment\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Buffer.cpp:\n   57  }  // namespace\n   58  \n   59: size_t getBufferDataAlignment(const Buffer* pBuffer);\n   60  void* mapBufferApi(const Buffer::ApiHandle& apiHandle, size_t size);\n   61  \n   ..\n  250  \n  251          mpCBV = nullptr;\n  252:         mDynamicData = mpDevice->getUploadHeap()->allocate(mSize, getBufferDataAlignment(this));\n  253          mApiHandle = mDynamicData.pResourceHandle;\n  254          mGpuVaOffset = mDynamicData.offset;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Buffer.cpp:\n   61      }\n   62  \n   63:     size_t getBufferDataAlignment(const Buffer* pBuffer)\n   64      {\n   65          // This in order of the alignment size\n   ..\n   97              {\n   98                  assert(gpDevice);\n   99:                 mDynamicData = gpDevice->getUploadHeap()->allocate(mSize, getBufferDataAlignment(this));\n  100                  mApiHandle = mDynamicData.pResourceHandle;\n  101                  mGpuVaOffset = mDynamicData.offset;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKBuffer.cpp:\n   80  }\n   81  \n   82: size_t getBufferDataAlignment(const Buffer* pBuffer) {\n   83      VkMemoryRequirements reqs;\n   84      vkGetBufferMemoryRequirements(pBuffer->device()->getApiHandle(), pBuffer->getApiHandle(), &reqs);\n\n5 matches across 3 files\n\n\nSearching 1282 files for \"mapBufferApi\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Buffer.cpp:\n   58  \n   59  size_t getBufferDataAlignment(const Buffer* pBuffer);\n   60: void* mapBufferApi(const Buffer::ApiHandle& apiHandle, size_t size);\n   61  \n   62  Buffer::Buffer(std::shared_ptr<Device> pDevice, size_t size, BindFlags bindFlags, CpuAccess cpuAccess): Resource(pDevice, Type::Buffer, bindFlags, size), mCpuAccess(cpuAccess) {}\n   ..\n  263          } else if (mCpuAccess == CpuAccess::Read) {\n  264              assert(mBindFlags == BindFlags::None);\n  265:             return mapBufferApi(mApiHandle, mSize);\n  266          } else {\n  267              // For buffers without CPU access we must copy the contents to a staging buffer.\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Buffer.cpp:\n   71      }\n   72  \n   73:     void* mapBufferApi(const Buffer::ApiHandle& apiHandle, size_t size)\n   74      {\n   75          D3D12_RANGE r{ 0, size };\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKBuffer.cpp:\n   47  }\n   48  \n   49: void* mapBufferApi(Device::SharedPtr device, const Buffer::ApiHandle& apiHandle, size_t size) {\n   50      void* pData;\n   51      vk_call(vkMapMemory(device->getApiHandle(), apiHandle, 0, size, 0, &pData));\n\n4 matches across 3 files\n\n\nSearching 1282 files for \"ResourceHandle\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Buffer.cpp:\n  169      if (mpAliasedResource) return;\n  170  \n  171:     if (mDynamicData.pResourceHandle) {\n  172          mpDevice->getUploadHeap()->release(mDynamicData);\n  173      } else {\n  ...\n  243  \n  244          // Allocate a new buffer\n  245:         if (mDynamicData.pResourceHandle) {\n  246              mpDevice->getUploadHeap()->release(mDynamicData);\n  247          }\n  ...\n  249          mpCBV = nullptr;\n  250          mDynamicData = mpDevice->getUploadHeap()->allocate(mSize, getBufferDataAlignment(this));\n  251:         mApiHandle = mDynamicData.pResourceHandle;\n  252          mGpuVaOffset = mDynamicData.offset;\n  253          invalidateViews();\n  ...\n  258          if (mCpuAccess == CpuAccess::Write) {\n  259              // Buffers on the upload heap are already mapped, just return the ptr.\n  260:             assert(mDynamicData.pResourceHandle);\n  261              assert(mDynamicData.pData);\n  262              return mDynamicData.pData;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Buffer.cpp:\n   98                  assert(gpDevice);\n   99                  mDynamicData = gpDevice->getUploadHeap()->allocate(mSize, getBufferDataAlignment(this));\n  100:                 mApiHandle = mDynamicData.pResourceHandle;\n  101                  mGpuVaOffset = mDynamicData.offset;\n  102              }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Device.cpp:\n  252      }\n  253  \n  254:     bool Device::getApiFboData(uint32_t width, uint32_t height, ResourceFormat colorFormat, ResourceFormat depthFormat, ResourceHandle apiHandles[kSwapChainBuffersCount], uint32_t& currentBackBufferIndex) {\n  255          for (uint32_t i = 0; i < kSwapChainBuffersCount; i++) {\n  256              HRESULT hr = mpApiData->pSwapChain->GetBuffer(i, IID_PPV_ARGS(&apiHandles[i]));\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12GpuMemoryHeap.cpp:\n   71      void GpuMemoryHeap::initBasePageData(BaseData& data, size_t size)\n   72      {\n   73:         data.pResourceHandle = createBuffer(getInitState(mType), size, getHeapProps(mType), Buffer::BindFlags::None);\n   74          data.offset = 0;\n   75          D3D12_RANGE readRange = {};\n   76:         d3d_call(data.pResourceHandle->Map(0, &readRange, (void**)&data.pData));\n   77      }\n   78  }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/FalcorD3D12.h:\n  210      using CommandSignatureHandle = ID3D12CommandSignaturePtr;\n  211      using FenceHandle = ID3D12FencePtr;\n  212:     using ResourceHandle = ID3D12ResourcePtr;\n  213      using RtvHandle = std::shared_ptr<DescriptorSet>;\n  214      using DsvHandle = std::shared_ptr<DescriptorSet>;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Device.cpp:\n  166  \n  167  bool Device::updateDefaultFBO(uint32_t width, uint32_t height, ResourceFormat colorFormat, ResourceFormat depthFormat) {\n  168:     ResourceHandle apiHandles[kSwapChainBuffersCount] = {};\n  169      getApiFboData(width, height, colorFormat, depthFormat, apiHandles, mCurrentBackBufferIndex);\n  170  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Device.h:\n  249  \n  250      // API specific functions\n  251:     bool getApiFboData(uint32_t width, uint32_t height, ResourceFormat colorFormat, ResourceFormat depthFormat, ResourceHandle &apiHandle);\n  252:     bool getApiFboData(uint32_t width, uint32_t height, ResourceFormat colorFormat, ResourceFormat depthFormat, ResourceHandle apiHandles[kSwapChainBuffersCount], uint32_t& currentBackBufferIndex);\n  253      void destroyApiObjects();\n  254      void apiPresent();\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Engine.cpp:\n  131  \n  132  bool Engine::updateDefaultFBO(uint32_t width, uint32_t height, ResourceFormat colorFormat, ResourceFormat depthFormat) {\n  133:     ResourceHandle apiHandles[kSwapChainBuffersCount] = {};\n  134      getApiFboData(width, height, colorFormat, depthFormat, apiHandles, mCurrentBackBufferIndex);\n  135  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/GpuMemoryHeap.cpp:\n   84              data.offset = currentOffset;\n   85              data.pData = mpActivePage->pData + currentOffset;\n   86:             data.pResourceHandle = mpActivePage->pResourceHandle;\n   87              mpActivePage->currentOffset = currentOffset + size;\n   88              mpActivePage->allocationsCount++;\n   ..\n   94  \n   95      void GpuMemoryHeap::release(Allocation& data) {\n   96:         assert(data.pResourceHandle);\n   97          mDeferredReleases.push(data);\n   98      }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/GpuMemoryHeap.h:\n   53  \n   54      struct BaseData {\n   55:         ResourceHandle pResourceHandle;\n   56          GpuAddress offset = 0;\n   57          uint8_t* pData = nullptr;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Resource.h:\n   46  class dlldecl Resource : public std::enable_shared_from_this<Resource> {\n   47   public:\n   48:     using ApiHandle = ResourceHandle;\n   49      using BindFlags = ResourceBindFlags;\n   50  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/FalcorVK.h:\n   91  using CommandSignatureHandle = void*;\n   92  using FenceHandle = VkSemaphore;\n   93: using ResourceHandle = VkResource<VkImage, VkBuffer>::SharedPtr;\n   94  using RtvHandle = VkResource<VkImageView, VkBufferView>::SharedPtr;\n   95  using DsvHandle = VkResource<VkImageView, VkBufferView>::SharedPtr;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKBuffer.cpp:\n  113      if (mCpuAccess == CpuAccess::Write) {\n  114          mDynamicData = mpDevice->getUploadHeap()->allocate(mSize);\n  115:         mApiHandle = mDynamicData.pResourceHandle;\n  116      } else {\n  117          if (mCpuAccess == CpuAccess::Read && mBindFlags == BindFlags::None) {\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKDevice.cpp:\n  124  }\n  125  \n  126: bool Device::getApiFboData(uint32_t width, uint32_t height, ResourceFormat colorFormat, ResourceFormat depthFormat, ResourceHandle &apiHandle) {\n  127      VkImage image;\n  128      \n  129:     apiHandle = ResourceHandle::create(SharedPtr(this), image, nullptr);\n  130      return true;\n  131  }\n  132  \n  133: bool Device::getApiFboData(uint32_t width, uint32_t height, ResourceFormat colorFormat, ResourceFormat depthFormat, ResourceHandle apiHandles[kSwapChainBuffersCount], uint32_t& currentBackBufferIndex) {\n  134      uint32_t imageCount = 0;\n  135      vkGetSwapchainImagesKHR(mApiHandle, mpApiData->swapchain, &imageCount, nullptr);\n  ...\n  140      vkGetSwapchainImagesKHR(mApiHandle, mpApiData->swapchain, &imageCount, swapchainImages.data());\n  141      for (size_t i = 0; i < swapchainImages.size(); i++) {\n  142:         apiHandles[i] = ResourceHandle::create(SharedPtr(this), swapchainImages[i], nullptr);\n  143      }\n  144  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VkGpuMemoryHeap.cpp:\n   37  void GpuMemoryHeap::initBasePageData(BaseData& data, size_t size) {\n   38      // Create a buffer\n   39:     data.pResourceHandle = createBuffer(mpDevice, size, Buffer::BindFlags::Constant | Buffer::BindFlags::Vertex | Buffer::BindFlags::Index, mType);\n   40      data.offset = 0;\n   41:     vk_call(vkMapMemory(mpDevice->getApiHandle(), data.pResourceHandle, 0, VK_WHOLE_SIZE, 0, (void**)&data.pData));\n   42  }\n   43  \n\n27 matches across 15 files\n\n\nSearching 1282 files for \"VkResource\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/FalcorVK.h:\n   91  using CommandSignatureHandle = void*;\n   92  using FenceHandle = VkSemaphore;\n   93: using ResourceHandle = VkResource<VkImage, VkBuffer>::SharedPtr;\n   94: using RtvHandle = VkResource<VkImageView, VkBufferView>::SharedPtr;\n   95: using DsvHandle = VkResource<VkImageView, VkBufferView>::SharedPtr;\n   96: using SrvHandle = VkResource<VkImageView, VkBufferView>::SharedPtr;\n   97: using UavHandle = VkResource<VkImageView, VkBufferView>::SharedPtr;\n   98: using CbvHandle = VkResource<VkImageView, VkBufferView>::SharedPtr;\n   99  using FboHandle = VkFbo::SharedPtr;\n  100  using SamplerHandle = VkHandle<VkSampler>::SharedPtr;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKComputeContext.cpp:\n   96      void clearColorImageCommon(CopyContext* pCtx, const ViewType* pView, const ClearType& clearVal)\n   97      {\n   98:         if(pView->getApiHandle().getType() != VkResourceType::Image)\n   99          {\n  100              logWarning(\"Looks like you are trying to clear a buffer. Vulkan only supports clearing Buffers with a single uint value. Please use the uint version of clearUav(). Call is ignored\");\n  ...\n  127      void ComputeContext::clearUAV(const UnorderedAccessView* pUav, const uint4& value)\n  128      {\n  129:         if(pUav->getApiHandle().getType() == VkResourceType::Buffer)\n  130          {\n  131              if ((value.x != value.y) || ((value.x != value.z) && (value.x != value.w)))\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKCopyContext.cpp:\n  276      bool CopyContext::textureBarrier(const Texture* pTexture, Resource::State newState)\n  277      {\n  278:         assert(pTexture->getApiHandle().getType() == VkResourceType::Image);\n  279  \n  280          VkImageLayout srcLayout = getImageLayout(pTexture->getGlobalState());\n  ...\n  310      {\n  311          assert(pBuffer);\n  312:         assert(pBuffer->getApiHandle().getType() == VkResourceType::Buffer);\n  313  \n  314          VkPipelineStageFlags srcStageMask = getShaderStageMask(pBuffer->getGlobalState(), true);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKDescriptorSet.cpp:\n   69          VkBufferView texelBufferView = {};\n   70  \n   71:         if (handle.getType() == VkResourceType::Buffer) {\n   72              Buffer* pBuffer = dynamic_cast<Buffer*>(pView->getResource());\n   73              if (pBuffer->isTyped()) {\n   ..\n   81              }\n   82          } else {\n   83:             assert(handle.getType() == VkResourceType::Image);\n   84              image.imageLayout = isUav ? VK_IMAGE_LAYOUT_GENERAL : VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;\n   85              image.imageView = handle;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKResourceViews.cpp:\n  133  \n  134  // SharedConstPtr = std::shared_ptr<const Resource>;\n  135: VkResource<VkImageView, VkBufferView>::SharedPtr createViewCommon(const Resource::SharedConstPtr& pSharedPtr, uint32_t mostDetailedMip, uint32_t mipCount, uint32_t firstArraySlice, uint32_t arraySize) {\n  136      const Resource* pResource = pSharedPtr.get();\n  137      assert(pResource);\n  138  \n  139      switch (pResource->getApiHandle().getType()) {\n  140:         case VkResourceType::Image: {\n  141              VkImageViewCreateInfo info = initializeImageViewInfo((const Texture*)pResource, mostDetailedMip, mipCount, firstArraySlice, arraySize);\n  142              VkImageView imageView;\n  143              vk_call(vkCreateImageView(pResource->device()->getApiHandle(), &info, nullptr, &imageView));\n  144:             return VkResource<VkImageView, VkBufferView>::SharedPtr::create(pResource->device(), imageView, nullptr);\n  145          }\n  146  \n  147:         case VkResourceType::Buffer: {\n  148              // We only create views for typed Buffers\n  149              VkBufferView bufferView = {};\n  ...\n  155              }\n  156  \n  157:             return VkResource<VkImageView, VkBufferView>::SharedPtr::create(pResource->device(), bufferView, nullptr);\n  158          }\n  159  \n  160          default:\n  161              should_not_get_here();\n  162:             return VkResource<VkImageView, VkBufferView>::SharedPtr();\n  163      }\n  164  }\n  ...\n  181      if (!pBuffer) {\n  182          VkBufferView bufferView = {};\n  183:         auto view = VkResource<VkImageView, VkBufferView>::SharedPtr::create(pBuffer.get()->device(), bufferView, nullptr);\n  184          return SharedPtr(new ShaderResourceView(pBuffer, view, firstElement, elementCount));\n  185      }\n  186  \n  187:     if (pBuffer->getApiHandle().getType() == VkResourceType::Image) {\n  188          logWarning(\"Cannot create DepthStencilView from a texture!\");\n  189          return getNullBufferView();\n  ...\n  202      }\n  203  \n  204:     auto view = VkResource<VkImageView, VkBufferView>::SharedPtr::create(pBuffer.get()->device(), bufferView, nullptr);\n  205  \n  206      return SharedPtr(new ShaderResourceView(pBuffer, view, firstElement, elementCount));\n  ...\n  213      }\n  214  \n  215:     if (pTexture->getApiHandle().getType() == VkResourceType::Buffer) {\n  216          logWarning(\"Cannot create DepthStencilView from a buffer!\");\n  217          return getNullView();\n  ...\n  227      }\n  228  \n  229:     if (pTexture->getApiHandle().getType() == VkResourceType::Buffer) {\n  230          logWarning(\"Cannot create UnorderedAccessView from a buffer!\");\n  231          return getNullView();;\n  ...\n  243      if (!pBuffer) {\n  244          VkBufferView bufferView = {};\n  245:         auto view = VkResource<VkImageView, VkBufferView>::SharedPtr::create(pBuffer.get()->device(), bufferView, nullptr);\n  246          return SharedPtr(new UnorderedAccessView(pBuffer, view, firstElement, elementCount));\n  247      }\n  248  \n  249:     if (pBuffer->getApiHandle().getType() == VkResourceType::Image) {\n  250          logWarning(\"Cannot create UnorderedAccessView from a texture!\");\n  251          return getNullBufferView();\n  ...\n  264      }\n  265  \n  266:     auto view = VkResource<VkImageView, VkBufferView>::SharedPtr::create(pBuffer.get()->device(), bufferView, nullptr);\n  267      return SharedPtr(new UnorderedAccessView(pBuffer, view, firstElement, elementCount));\n  268  }\n  ...\n  277  \n  278      // Check type\n  279:     if (pTexture->getApiHandle().getType() == VkResourceType::Buffer) {\n  280          logWarning(\"Cannot create RenderTargetView from a buffer!\");\n  281          return getNullView();\n  ...\n  291  \n  292      VkBufferView bufferView = {};\n  293:     auto handle = VkResource<VkImageView, VkBufferView>::SharedPtr::create(pBuffer.get()->device(), bufferView, nullptr);\n  294  \n  295  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VkSmartHandle.cpp:\n   56  \n   57      template<>\n   58:     VkResource<VkImage, VkBuffer>::~VkResource() {\n   59          if (!mpDevice) {\n   60:             // #VKTODO This is here because of the black texture in VkResourceViews.cpp\n   61              return;\n   62          }\n   63:         assert(mDeviceMem || mType == VkResourceType::Image);  // All of our resources are allocated with memory, except for the swap-chain backbuffers that we shouldn't release\n   64          if (mDeviceMem) {\n   65              switch (mType) {\n   66:                 case VkResourceType::Image:\n   67                      if (mImage) {\n   68                          vkDestroyImage(mpDevice->getApiHandle(), mImage, nullptr);\n   69                      }\n   70                      break;\n   71:                 case VkResourceType::Buffer:\n   72                      if (mBuffer) {\n   73                          vkDestroyBuffer(mpDevice->getApiHandle(), mBuffer, nullptr);\n   ..\n   82  \n   83      template<>\n   84:     VkResource<VkImageView, VkBufferView>::~VkResource() {\n   85          if (!mpDevice) {\n   86:             // #VKTODO This is here because of the black texture in VkResourceViews.cpp\n   87              return;\n   88          }\n   89          switch (mType) {\n   90:             case VkResourceType::Image:\n   91                  if (mImage) {\n   92                      vkDestroyImageView(mpDevice->getApiHandle(), mImage, nullptr);\n   93                  }\n   94                  break;\n   95:             case VkResourceType::Buffer:\n   96                  if (mBuffer) {\n   97                      vkDestroyBufferView(mpDevice->getApiHandle(), mBuffer, nullptr);\n   ..\n  127      template VkHandle<VkQueryPool>::~VkHandle();\n  128  \n  129:     template VkResource<VkImage, VkBuffer>::~VkResource();\n  130:     template VkResource<VkImageView, VkBufferView>::~VkResource();\n  131  }  // namespace Falcor\n  132  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKSmartHandle.h:\n  127  };\n  128  \n  129: enum class VkResourceType {\n  130      None,\n  131      Image,\n  ...\n  134  \n  135  template<typename ImageType, typename BufferType>\n  136: class VkResource : public VkBaseApiHandle, public inherit_shared_from_this<VkBaseApiHandle, VkResource<ImageType, BufferType>> {\n  137   public:\n  138:     class SharedPtr : public std::shared_ptr<VkResource<ImageType, BufferType>> {\n  139       public:\n  140          SharedPtr() = default;\n  141:         explicit SharedPtr(VkResource<ImageType, BufferType>* pRes) : std::shared_ptr<VkResource<ImageType, BufferType>>(pRes) {}\n  142  \n  143          static SharedPtr create(std::shared_ptr<Device> device, ImageType image, VkDeviceMemory mem) {\n  144:             return SharedPtr(new VkResource<ImageType, BufferType>(device, image, mem));\n  145          }\n  146  \n  147          static SharedPtr create(std::shared_ptr<Device> device, BufferType buffer, VkDeviceMemory mem) {\n  148:             return SharedPtr(new VkResource<ImageType, BufferType>(device, buffer, mem));\n  149          }\n  150  \n  151:         VkResourceType getType() const { return get()->mType; }\n  152          ImageType getImage() const {\n  153              return get()->mImage;\n  154          }\n  155:         operator ImageType() const {assert(get()->mType == VkResourceType::Image); return get()->mImage; }\n  156:         operator BufferType() const { assert(get()->mType == VkResourceType::Buffer); return get()->mBuffer; }\n  157          operator VkDeviceMemory() const { return get()->mDeviceMem; }\n  158  \n  159       private:\n  160:         VkResource<ImageType, BufferType>* get() const { return std::shared_ptr<VkResource<ImageType, BufferType>>::get(); }\n  161      };\n  162  \n  163:     ~VkResource() {\n  164  #ifdef _WIN32\n  165:         static_assert(false, \"VkResource missing destructor specialization\");\n  166  #endif\n  167      }\n  ...\n  169   private:\n  170      friend SharedPtr;\n  171:     VkResource(std::shared_ptr<Device> device, ImageType image, VkDeviceMemory mem) : VkBaseApiHandle(device), mType(VkResourceType::Image), mImage(image), mDeviceMem(mem) { }\n  172      \n  173:     VkResource(std::shared_ptr<Device> device, BufferType buffer, VkDeviceMemory mem) : VkBaseApiHandle(device), mType(VkResourceType::Buffer), mBuffer(buffer), mDeviceMem(mem) { }\n  174  \n  175:     VkResourceType mType = VkResourceType::None;\n  176      ImageType mImage = VK_NULL_HANDLE;\n  177      BufferType mBuffer = VK_NULL_HANDLE;\n  ...\n  217  template<> VkHandle<VkQueryPool>::~VkHandle();\n  218  \n  219: template<> VkResource<VkImage, VkBuffer>::~VkResource();\n  220: template<> VkResource<VkImageView, VkBufferView>::~VkResource();\n  221  \n  222  }  // namespace Falcor\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKTexture.cpp:\n   38  \n   39      Texture::~Texture() {\n   40:         // #VKTODO the `if` is here because of the black texture in VkResourceView.cpp\n   41          if (mpDevice ) mpDevice->releaseResource(std::static_pointer_cast<VkBaseApiHandle>(mApiHandle));\n   42      }\n\n/home/max/dev/Falcor/src/Falcor/Falcor.vcxproj:\n  508        <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='ReleaseD3D12|x64'\">true</ExcludedFromBuild>\n  509      </ClCompile>\n  510:     <ClCompile Include=\"Core\\API\\Vulkan\\VkResource.cpp\">\n  511        <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='DebugD3D12|x64'\">true</ExcludedFromBuild>\n  512        <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='ReleaseD3D12|x64'\">true</ExcludedFromBuild>\n\n/home/max/dev/Falcor/src/Falcor/Falcor.vcxproj.filters:\n  747        <Filter>Core\\API\\Vulkan</Filter>\n  748      </ClCompile>\n  749:     <ClCompile Include=\"Core\\API\\Vulkan\\VkResource.cpp\">\n  750        <Filter>Core\\API\\Vulkan</Filter>\n  751      </ClCompile>\n\n/home/max/dev/Falcor/src/USD/hgiVk/computeEncoder.cpp:\n   46  HgiVkComputeEncoder::BindResources(HgiResourceBindingsHandle res)\n   47  {\n   48:     if (HgiVkResourceBindings* r = static_cast<HgiVkResourceBindings*>(res)) {\n   49          r->BindResources(_commandBuffer);\n   50      }\n\n/home/max/dev/Falcor/src/USD/hgiVk/garbageCollector.cpp:\n   86                  }\n   87                  case HgiVkObjectTypeResourceBindings: {\n   88:                     HgiVkResourceBindings* r = obj.resourceBindings;\n   89                      delete r;\n   90                      break;\n\n/home/max/dev/Falcor/src/USD/hgiVk/graphicsEncoder.cpp:\n  130  HgiVkGraphicsEncoder::BindResources(HgiResourceBindingsHandle res)\n  131  {\n  132:     if (HgiVkResourceBindings* r = static_cast<HgiVkResourceBindings*>(res)) {\n  133          r->BindResources(_commandBuffer);\n  134      }\n  ...\n  167      const void* data)\n  168  {\n  169:     HgiVkResourceBindings* r = static_cast<HgiVkResourceBindings*>(res);\n  170      if (!TF_VERIFY(r)) return;\n  171  \n\n/home/max/dev/Falcor/src/USD/hgiVk/hgi.cpp:\n  294  {\n  295      HgiVkDevice* device = GetPrimaryDevice();\n  296:     return new HgiVkResourceBindings(device, desc);\n  297  }\n  298  \n  ...\n  305          object.type = HgiVkObjectTypeResourceBindings;\n  306          if (object.resourceBindings =\n  307:                 static_cast<HgiVkResourceBindings*>(*resHandle)) {\n  308              device->DestroyObject(object);\n  309              *resHandle = nullptr;\n\n/home/max/dev/Falcor/src/USD/hgiVk/object.h:\n   34          class HgiVkRenderPass* renderPass;\n   35          class HgiVkPipeline* pipeline;\n   36:         class HgiVkResourceBindings* resourceBindings;\n   37          class HgiVkShaderFunction* shaderFunction;\n   38          class HgiVkShaderProgram* shaderProgram;\n\n/home/max/dev/Falcor/src/USD/hgiVk/pipeline.cpp:\n  133      //\n  134  \n  135:     HgiVkResourceBindings* resources =\n  136:         static_cast<HgiVkResourceBindings*>(_descriptor.resourceBindings);\n  137  \n  138      HgiVertexBufferDescVector const& vbos = resources->GetVertexBuffers();\n  ...\n  387      // This was generated when the resource bindings was created.\n  388      //\n  389:     HgiVkResourceBindings* resources =\n  390:         static_cast<HgiVkResourceBindings*>(_descriptor.resourceBindings);\n  391  \n  392      pipeCreateInfo.layout = resources->GetPipelineLayout();\n\n/home/max/dev/Falcor/src/USD/hgiVk/resourceBindings.cpp:\n   12  PXR_NAMESPACE_OPEN_SCOPE\n   13  \n   14: HgiVkResourceBindings::HgiVkResourceBindings(\n   15      HgiVkDevice* device,\n   16      HgiResourceBindingsDesc const& desc)\n   ..\n  366  }\n  367  \n  368: HgiVkResourceBindings::~HgiVkResourceBindings()\n  369  {\n  370      vkDestroyDescriptorSetLayout(\n  ...\n  396  \n  397  HgiBufferBindDescVector const&\n  398: HgiVkResourceBindings::GetBufferBindings() const\n  399  {\n  400      return _descriptor.buffers;\n  ...\n  402  \n  403  HgiTextureBindDescVector const&\n  404: HgiVkResourceBindings::GetTextureBindings() const\n  405  {\n  406      return _descriptor.textures;\n  ...\n  408  \n  409  HgiVertexBufferDescVector const&\n  410: HgiVkResourceBindings::GetVertexBuffers() const\n  411  {\n  412      return _descriptor.vertexBuffers;\n  ...\n  414  \n  415  void\n  416: HgiVkResourceBindings::BindResources(HgiVkCommandBuffer* cb)\n  417  {\n  418      VkPipelineBindPoint bindPoint =\n  ...\n  438  \n  439  VkPipelineLayout\n  440: HgiVkResourceBindings::GetPipelineLayout() const\n  441  {\n  442      return _vkPipelineLayout;\n  ...\n  444  \n  445  VkDescriptorSet\n  446: HgiVkResourceBindings::GetDescriptorSet() const\n  447  {\n  448      return _vkDescriptorSet;\n  ...\n  450  \n  451  VkDescriptorImageInfoVector const&\n  452: HgiVkResourceBindings::GetImageInfos() const\n  453  {\n  454      return _imageInfos;\n  ...\n  456  \n  457  VkDescriptorBufferInfoVector const&\n  458: HgiVkResourceBindings::GetBufferInfos() const\n  459  {\n  460      return _bufferInfos;\n\n/home/max/dev/Falcor/src/USD/hgiVk/resourceBindings.h:\n   21  \n   22  ///\n   23: /// \\class HgiVkResourceBindings\n   24  ///\n   25  /// Vulkan implementation of HgiResourceBindings.\n   ..\n   35  /// design is to have one descriptor pool per resourceBindings.\n   36  ///\n   37: class HgiVkResourceBindings final : public HgiResourceBindings {\n   38  public:\n   39      HGIVK_API\n   40:     HgiVkResourceBindings(\n   41          HgiVkDevice* device,\n   42          HgiResourceBindingsDesc const& desc);\n   43  \n   44      HGIVK_API\n   45:     virtual ~HgiVkResourceBindings();\n   46  \n   47      /// Returns the list of buffers that needs to be bound.\n   ..\n   78  \n   79  private:\n   80:     HgiVkResourceBindings() = delete;\n   81:     HgiVkResourceBindings & operator=(const HgiVkResourceBindings&) = delete;\n   82:     HgiVkResourceBindings(const HgiVkResourceBindings&) = delete;\n   83  \n   84  private:\n\n106 matches across 18 files\n\n\nSearching 1282 files for \"VkResource\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/FalcorVK.h:\n   91  using CommandSignatureHandle = void*;\n   92  using FenceHandle = VkSemaphore;\n   93: using ResourceHandle = VkResource<VkImage, VkBuffer>::SharedPtr;\n   94: using RtvHandle = VkResource<VkImageView, VkBufferView>::SharedPtr;\n   95: using DsvHandle = VkResource<VkImageView, VkBufferView>::SharedPtr;\n   96: using SrvHandle = VkResource<VkImageView, VkBufferView>::SharedPtr;\n   97: using UavHandle = VkResource<VkImageView, VkBufferView>::SharedPtr;\n   98: using CbvHandle = VkResource<VkImageView, VkBufferView>::SharedPtr;\n   99  using FboHandle = VkFbo::SharedPtr;\n  100  using SamplerHandle = VkHandle<VkSampler>::SharedPtr;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKComputeContext.cpp:\n   96      void clearColorImageCommon(CopyContext* pCtx, const ViewType* pView, const ClearType& clearVal)\n   97      {\n   98:         if(pView->getApiHandle().getType() != VkResourceType::Image)\n   99          {\n  100              logWarning(\"Looks like you are trying to clear a buffer. Vulkan only supports clearing Buffers with a single uint value. Please use the uint version of clearUav(). Call is ignored\");\n  ...\n  127      void ComputeContext::clearUAV(const UnorderedAccessView* pUav, const uint4& value)\n  128      {\n  129:         if(pUav->getApiHandle().getType() == VkResourceType::Buffer)\n  130          {\n  131              if ((value.x != value.y) || ((value.x != value.z) && (value.x != value.w)))\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKCopyContext.cpp:\n  276      bool CopyContext::textureBarrier(const Texture* pTexture, Resource::State newState)\n  277      {\n  278:         assert(pTexture->getApiHandle().getType() == VkResourceType::Image);\n  279  \n  280          VkImageLayout srcLayout = getImageLayout(pTexture->getGlobalState());\n  ...\n  310      {\n  311          assert(pBuffer);\n  312:         assert(pBuffer->getApiHandle().getType() == VkResourceType::Buffer);\n  313  \n  314          VkPipelineStageFlags srcStageMask = getShaderStageMask(pBuffer->getGlobalState(), true);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKDescriptorSet.cpp:\n   69          VkBufferView texelBufferView = {};\n   70  \n   71:         if (handle.getType() == VkResourceType::Buffer) {\n   72              Buffer* pBuffer = dynamic_cast<Buffer*>(pView->getResource());\n   73              if (pBuffer->isTyped()) {\n   ..\n   81              }\n   82          } else {\n   83:             assert(handle.getType() == VkResourceType::Image);\n   84              image.imageLayout = isUav ? VK_IMAGE_LAYOUT_GENERAL : VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;\n   85              image.imageView = handle;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKResourceViews.cpp:\n  133  \n  134  // SharedConstPtr = std::shared_ptr<const Resource>;\n  135: VkResource<VkImageView, VkBufferView>::SharedPtr createViewCommon(const Resource::SharedConstPtr& pSharedPtr, uint32_t mostDetailedMip, uint32_t mipCount, uint32_t firstArraySlice, uint32_t arraySize) {\n  136      const Resource* pResource = pSharedPtr.get();\n  137      assert(pResource);\n  138  \n  139      switch (pResource->getApiHandle().getType()) {\n  140:         case VkResourceType::Image: {\n  141              VkImageViewCreateInfo info = initializeImageViewInfo((const Texture*)pResource, mostDetailedMip, mipCount, firstArraySlice, arraySize);\n  142              VkImageView imageView;\n  143              vk_call(vkCreateImageView(pResource->device()->getApiHandle(), &info, nullptr, &imageView));\n  144:             return VkResource<VkImageView, VkBufferView>::SharedPtr::create(pResource->device(), imageView, nullptr);\n  145          }\n  146  \n  147:         case VkResourceType::Buffer: {\n  148              // We only create views for typed Buffers\n  149              VkBufferView bufferView = {};\n  ...\n  155              }\n  156  \n  157:             return VkResource<VkImageView, VkBufferView>::SharedPtr::create(pResource->device(), bufferView, nullptr);\n  158          }\n  159  \n  160          default:\n  161              should_not_get_here();\n  162:             return VkResource<VkImageView, VkBufferView>::SharedPtr();\n  163      }\n  164  }\n  ...\n  181      if (!pBuffer) {\n  182          VkBufferView bufferView = {};\n  183:         auto view = VkResource<VkImageView, VkBufferView>::SharedPtr::create(pBuffer.get()->device(), bufferView, nullptr);\n  184          return SharedPtr(new ShaderResourceView(pBuffer, view, firstElement, elementCount));\n  185      }\n  186  \n  187:     if (pBuffer->getApiHandle().getType() == VkResourceType::Image) {\n  188          logWarning(\"Cannot create DepthStencilView from a texture!\");\n  189          return getNullBufferView();\n  ...\n  202      }\n  203  \n  204:     auto view = VkResource<VkImageView, VkBufferView>::SharedPtr::create(pBuffer.get()->device(), bufferView, nullptr);\n  205  \n  206      return SharedPtr(new ShaderResourceView(pBuffer, view, firstElement, elementCount));\n  ...\n  213      }\n  214  \n  215:     if (pTexture->getApiHandle().getType() == VkResourceType::Buffer) {\n  216          logWarning(\"Cannot create DepthStencilView from a buffer!\");\n  217          return getNullView();\n  ...\n  227      }\n  228  \n  229:     if (pTexture->getApiHandle().getType() == VkResourceType::Buffer) {\n  230          logWarning(\"Cannot create UnorderedAccessView from a buffer!\");\n  231          return getNullView();;\n  ...\n  243      if (!pBuffer) {\n  244          VkBufferView bufferView = {};\n  245:         auto view = VkResource<VkImageView, VkBufferView>::SharedPtr::create(pBuffer.get()->device(), bufferView, nullptr);\n  246          return SharedPtr(new UnorderedAccessView(pBuffer, view, firstElement, elementCount));\n  247      }\n  248  \n  249:     if (pBuffer->getApiHandle().getType() == VkResourceType::Image) {\n  250          logWarning(\"Cannot create UnorderedAccessView from a texture!\");\n  251          return getNullBufferView();\n  ...\n  264      }\n  265  \n  266:     auto view = VkResource<VkImageView, VkBufferView>::SharedPtr::create(pBuffer.get()->device(), bufferView, nullptr);\n  267      return SharedPtr(new UnorderedAccessView(pBuffer, view, firstElement, elementCount));\n  268  }\n  ...\n  277  \n  278      // Check type\n  279:     if (pTexture->getApiHandle().getType() == VkResourceType::Buffer) {\n  280          logWarning(\"Cannot create RenderTargetView from a buffer!\");\n  281          return getNullView();\n  ...\n  291  \n  292      VkBufferView bufferView = {};\n  293:     auto handle = VkResource<VkImageView, VkBufferView>::SharedPtr::create(pBuffer.get()->device(), bufferView, nullptr);\n  294  \n  295  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VkSmartHandle.cpp:\n   56  \n   57      template<>\n   58:     VkResource<VkImage, VkBuffer>::~VkResource() {\n   59          if (!mpDevice) {\n   60:             // #VKTODO This is here because of the black texture in VkResourceViews.cpp\n   61              return;\n   62          }\n   63:         assert(mDeviceMem || mType == VkResourceType::Image);  // All of our resources are allocated with memory, except for the swap-chain backbuffers that we shouldn't release\n   64          if (mDeviceMem) {\n   65              switch (mType) {\n   66:                 case VkResourceType::Image:\n   67                      if (mImage) {\n   68                          vkDestroyImage(mpDevice->getApiHandle(), mImage, nullptr);\n   69                      }\n   70                      break;\n   71:                 case VkResourceType::Buffer:\n   72                      if (mBuffer) {\n   73                          vkDestroyBuffer(mpDevice->getApiHandle(), mBuffer, nullptr);\n   ..\n   82  \n   83      template<>\n   84:     VkResource<VkImageView, VkBufferView>::~VkResource() {\n   85          if (!mpDevice) {\n   86:             // #VKTODO This is here because of the black texture in VkResourceViews.cpp\n   87              return;\n   88          }\n   89          switch (mType) {\n   90:             case VkResourceType::Image:\n   91                  if (mImage) {\n   92                      vkDestroyImageView(mpDevice->getApiHandle(), mImage, nullptr);\n   93                  }\n   94                  break;\n   95:             case VkResourceType::Buffer:\n   96                  if (mBuffer) {\n   97                      vkDestroyBufferView(mpDevice->getApiHandle(), mBuffer, nullptr);\n   ..\n  127      template VkHandle<VkQueryPool>::~VkHandle();\n  128  \n  129:     template VkResource<VkImage, VkBuffer>::~VkResource();\n  130:     template VkResource<VkImageView, VkBufferView>::~VkResource();\n  131  }  // namespace Falcor\n  132  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKSmartHandle.h:\n  130  };\n  131  \n  132: enum class VkResourceType {\n  133      None,\n  134      Image,\n  ...\n  137  \n  138  template<typename ImageType, typename BufferType>\n  139: class VkResource : public VkBaseApiHandle, public inherit_shared_from_this<VkBaseApiHandle, VkResource<ImageType, BufferType>> {\n  140   public:\n  141:     class SharedPtr : public std::shared_ptr<VkResource<ImageType, BufferType>> {\n  142       public:\n  143          SharedPtr() = default;\n  144:         explicit SharedPtr(VkResource<ImageType, BufferType>* pRes) : std::shared_ptr<VkResource<ImageType, BufferType>>(pRes) {}\n  145  \n  146          static SharedPtr create(std::shared_ptr<Device> device, ImageType image, VkDeviceMemory mem) {\n  147:             return SharedPtr(new VkResource<ImageType, BufferType>(device, image, mem));\n  148          }\n  149  \n  150          static SharedPtr create(std::shared_ptr<Device> device, BufferType buffer, VkDeviceMemory mem) {\n  151:             return SharedPtr(new VkResource<ImageType, BufferType>(device, buffer, mem));\n  152          }\n  153  \n  154:         VkResourceType getType() const { return get()->mType; }\n  155          ImageType getImage() const {\n  156              return get()->mImage;\n  157          }\n  158:         operator ImageType() const {assert(get()->mType == VkResourceType::Image); return get()->mImage; }\n  159:         operator BufferType() const { assert(get()->mType == VkResourceType::Buffer); return get()->mBuffer; }\n  160          operator VkDeviceMemory() const { return get()->mDeviceMem; }\n  161  \n  162       private:\n  163:         VkResource<ImageType, BufferType>* get() const { return std::shared_ptr<VkResource<ImageType, BufferType>>::get(); }\n  164      };\n  165  \n  166:     ~VkResource() {\n  167  #ifdef _WIN32\n  168:         static_assert(false, \"VkResource missing destructor specialization\");\n  169  #endif\n  170      }\n  ...\n  172   private:\n  173      friend SharedPtr;\n  174:     VkResource(std::shared_ptr<Device> device, ImageType image, VkDeviceMemory mem) : VkBaseApiHandle(device), mType(VkResourceType::Image), mImage(image), mDeviceMem(mem) { }\n  175      \n  176:     VkResource(std::shared_ptr<Device> device, BufferType buffer, VkDeviceMemory mem) : VkBaseApiHandle(device), mType(VkResourceType::Buffer), mBuffer(buffer), mDeviceMem(mem) { }\n  177  \n  178:     VkResourceType mType = VkResourceType::None;\n  179      ImageType mImage = VK_NULL_HANDLE;\n  180      BufferType mBuffer = VK_NULL_HANDLE;\n  ...\n  220  template<> VkHandle<VkQueryPool>::~VkHandle();\n  221  \n  222: template<> VkResource<VkImage, VkBuffer>::~VkResource();\n  223: template<> VkResource<VkImageView, VkBufferView>::~VkResource();\n  224  \n  225  }  // namespace Falcor\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKTexture.cpp:\n   38  \n   39      Texture::~Texture() {\n   40:         // #VKTODO the `if` is here because of the black texture in VkResourceView.cpp\n   41          if (mpDevice ) mpDevice->releaseResource(std::static_pointer_cast<VkBaseApiHandle>(mApiHandle));\n   42      }\n\n/home/max/dev/Falcor/src/Falcor/Falcor.vcxproj:\n  508        <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='ReleaseD3D12|x64'\">true</ExcludedFromBuild>\n  509      </ClCompile>\n  510:     <ClCompile Include=\"Core\\API\\Vulkan\\VkResource.cpp\">\n  511        <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='DebugD3D12|x64'\">true</ExcludedFromBuild>\n  512        <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='ReleaseD3D12|x64'\">true</ExcludedFromBuild>\n\n/home/max/dev/Falcor/src/Falcor/Falcor.vcxproj.filters:\n  747        <Filter>Core\\API\\Vulkan</Filter>\n  748      </ClCompile>\n  749:     <ClCompile Include=\"Core\\API\\Vulkan\\VkResource.cpp\">\n  750        <Filter>Core\\API\\Vulkan</Filter>\n  751      </ClCompile>\n\n/home/max/dev/Falcor/src/USD/hgiVk/computeEncoder.cpp:\n   46  HgiVkComputeEncoder::BindResources(HgiResourceBindingsHandle res)\n   47  {\n   48:     if (HgiVkResourceBindings* r = static_cast<HgiVkResourceBindings*>(res)) {\n   49          r->BindResources(_commandBuffer);\n   50      }\n\n/home/max/dev/Falcor/src/USD/hgiVk/garbageCollector.cpp:\n   86                  }\n   87                  case HgiVkObjectTypeResourceBindings: {\n   88:                     HgiVkResourceBindings* r = obj.resourceBindings;\n   89                      delete r;\n   90                      break;\n\n/home/max/dev/Falcor/src/USD/hgiVk/graphicsEncoder.cpp:\n  130  HgiVkGraphicsEncoder::BindResources(HgiResourceBindingsHandle res)\n  131  {\n  132:     if (HgiVkResourceBindings* r = static_cast<HgiVkResourceBindings*>(res)) {\n  133          r->BindResources(_commandBuffer);\n  134      }\n  ...\n  167      const void* data)\n  168  {\n  169:     HgiVkResourceBindings* r = static_cast<HgiVkResourceBindings*>(res);\n  170      if (!TF_VERIFY(r)) return;\n  171  \n\n/home/max/dev/Falcor/src/USD/hgiVk/hgi.cpp:\n  294  {\n  295      HgiVkDevice* device = GetPrimaryDevice();\n  296:     return new HgiVkResourceBindings(device, desc);\n  297  }\n  298  \n  ...\n  305          object.type = HgiVkObjectTypeResourceBindings;\n  306          if (object.resourceBindings =\n  307:                 static_cast<HgiVkResourceBindings*>(*resHandle)) {\n  308              device->DestroyObject(object);\n  309              *resHandle = nullptr;\n\n/home/max/dev/Falcor/src/USD/hgiVk/object.h:\n   34          class HgiVkRenderPass* renderPass;\n   35          class HgiVkPipeline* pipeline;\n   36:         class HgiVkResourceBindings* resourceBindings;\n   37          class HgiVkShaderFunction* shaderFunction;\n   38          class HgiVkShaderProgram* shaderProgram;\n\n/home/max/dev/Falcor/src/USD/hgiVk/pipeline.cpp:\n  133      //\n  134  \n  135:     HgiVkResourceBindings* resources =\n  136:         static_cast<HgiVkResourceBindings*>(_descriptor.resourceBindings);\n  137  \n  138      HgiVertexBufferDescVector const& vbos = resources->GetVertexBuffers();\n  ...\n  387      // This was generated when the resource bindings was created.\n  388      //\n  389:     HgiVkResourceBindings* resources =\n  390:         static_cast<HgiVkResourceBindings*>(_descriptor.resourceBindings);\n  391  \n  392      pipeCreateInfo.layout = resources->GetPipelineLayout();\n\n/home/max/dev/Falcor/src/USD/hgiVk/resourceBindings.cpp:\n   12  PXR_NAMESPACE_OPEN_SCOPE\n   13  \n   14: HgiVkResourceBindings::HgiVkResourceBindings(\n   15      HgiVkDevice* device,\n   16      HgiResourceBindingsDesc const& desc)\n   ..\n  366  }\n  367  \n  368: HgiVkResourceBindings::~HgiVkResourceBindings()\n  369  {\n  370      vkDestroyDescriptorSetLayout(\n  ...\n  396  \n  397  HgiBufferBindDescVector const&\n  398: HgiVkResourceBindings::GetBufferBindings() const\n  399  {\n  400      return _descriptor.buffers;\n  ...\n  402  \n  403  HgiTextureBindDescVector const&\n  404: HgiVkResourceBindings::GetTextureBindings() const\n  405  {\n  406      return _descriptor.textures;\n  ...\n  408  \n  409  HgiVertexBufferDescVector const&\n  410: HgiVkResourceBindings::GetVertexBuffers() const\n  411  {\n  412      return _descriptor.vertexBuffers;\n  ...\n  414  \n  415  void\n  416: HgiVkResourceBindings::BindResources(HgiVkCommandBuffer* cb)\n  417  {\n  418      VkPipelineBindPoint bindPoint =\n  ...\n  438  \n  439  VkPipelineLayout\n  440: HgiVkResourceBindings::GetPipelineLayout() const\n  441  {\n  442      return _vkPipelineLayout;\n  ...\n  444  \n  445  VkDescriptorSet\n  446: HgiVkResourceBindings::GetDescriptorSet() const\n  447  {\n  448      return _vkDescriptorSet;\n  ...\n  450  \n  451  VkDescriptorImageInfoVector const&\n  452: HgiVkResourceBindings::GetImageInfos() const\n  453  {\n  454      return _imageInfos;\n  ...\n  456  \n  457  VkDescriptorBufferInfoVector const&\n  458: HgiVkResourceBindings::GetBufferInfos() const\n  459  {\n  460      return _bufferInfos;\n\n/home/max/dev/Falcor/src/USD/hgiVk/resourceBindings.h:\n   21  \n   22  ///\n   23: /// \\class HgiVkResourceBindings\n   24  ///\n   25  /// Vulkan implementation of HgiResourceBindings.\n   ..\n   35  /// design is to have one descriptor pool per resourceBindings.\n   36  ///\n   37: class HgiVkResourceBindings final : public HgiResourceBindings {\n   38  public:\n   39      HGIVK_API\n   40:     HgiVkResourceBindings(\n   41          HgiVkDevice* device,\n   42          HgiResourceBindingsDesc const& desc);\n   43  \n   44      HGIVK_API\n   45:     virtual ~HgiVkResourceBindings();\n   46  \n   47      /// Returns the list of buffers that needs to be bound.\n   ..\n   78  \n   79  private:\n   80:     HgiVkResourceBindings() = delete;\n   81:     HgiVkResourceBindings & operator=(const HgiVkResourceBindings&) = delete;\n   82:     HgiVkResourceBindings(const HgiVkResourceBindings&) = delete;\n   83  \n   84  private:\n\n106 matches across 18 files\n\n\nSearching 1282 files for \"mapBufferApi\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Buffer.cpp:\n   58  \n   59  size_t getBufferDataAlignment(const Buffer* pBuffer);\n   60: void* mapBufferApi(const Buffer::ApiHandle& apiHandle, size_t size);\n   61  \n   62  Buffer::Buffer(std::shared_ptr<Device> pDevice, size_t size, BindFlags bindFlags, CpuAccess cpuAccess): Resource(pDevice, Type::Buffer, bindFlags, size), mCpuAccess(cpuAccess) {}\n   ..\n  263          } else if (mCpuAccess == CpuAccess::Read) {\n  264              assert(mBindFlags == BindFlags::None);\n  265:             return mapBufferApi(mApiHandle, mSize);\n  266          } else {\n  267              // For buffers without CPU access we must copy the contents to a staging buffer.\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Buffer.cpp:\n   71      }\n   72  \n   73:     void* mapBufferApi(const Buffer::ApiHandle& apiHandle, size_t size)\n   74      {\n   75          D3D12_RANGE r{ 0, size };\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKBuffer.cpp:\n   47  }\n   48  \n   49: void* mapBufferApi(Device::SharedPtr device, const Buffer::ApiHandle& apiHandle, size_t size) {\n   50      void* pData;\n   51      vk_call(vkMapMemory(device->getApiHandle(), apiHandle, 0, size, 0, &pData));\n\n4 matches across 3 files\n\n\nSearching 1282 files for \"device\" (case sensitive)\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/detail/setup.hpp:\n  387  \n  388  #if GLM_COMPILER & GLM_COMPILER_CUDA\n  389: #\tdefine GLM_CUDA_FUNC_DEF __device__ __host__\n  390: #\tdefine GLM_CUDA_FUNC_DECL __device__ __host__\n  391  #else\n  392  #\tdefine GLM_CUDA_FUNC_DEF\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/matrix_clip_space.hpp:\n   45  \n   46  \t/// Creates a matrix for an orthographic parallel viewing volume, using left-handed coordinates.\n   47: \t/// The near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n   48  \t///\n   49  \t/// @tparam T A floating-point scalar type\n   ..\n   55  \n   56  \t/// Creates a matrix for an orthographic parallel viewing volume using right-handed coordinates.\n   57: \t/// The near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n   58  \t///\n   59  \t/// @tparam T A floating-point scalar type\n   ..\n   65  \n   66  \t/// Creates a matrix for an orthographic parallel viewing volume, using left-handed coordinates.\n   67: \t/// The near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n   68  \t///\n   69  \t/// @tparam T A floating-point scalar type\n   ..\n   75  \n   76  \t/// Creates a matrix for an orthographic parallel viewing volume, using right-handed coordinates.\n   77: \t/// The near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n   78  \t///\n   79  \t/// @tparam T A floating-point scalar type\n   ..\n   85  \n   86  \t/// Creates a matrix for an orthographic parallel viewing volume, using left-handed coordinates.\n   87: \t/// The near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n   88  \t///\n   89  \t/// @tparam T A floating-point scalar type\n   ..\n   95  \n   96  \t/// Creates a matrix for an orthographic parallel viewing volume, using left-handed coordinates if GLM_FORCE_LEFT_HANDED if defined or right-handed coordinates otherwise.\n   97: \t/// The near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n   98  \t///\n   99  \t/// @tparam T A floating-point scalar type\n  ...\n  105  \n  106  \t/// Creates a matrix for an orthographic parallel viewing volume, using left-handed coordinates.\n  107: \t/// If GLM_FORCE_DEPTH_ZERO_TO_ONE is defined, the near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n  108: \t/// Otherwise, the near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n  109  \t///\n  110  \t/// @tparam T A floating-point scalar type\n  ...\n  116  \n  117  \t/// Creates a matrix for an orthographic parallel viewing volume, using right-handed coordinates.\n  118: \t/// If GLM_FORCE_DEPTH_ZERO_TO_ONE is defined, the near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n  119: \t/// Otherwise, the near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n  120  \t///\n  121  \t/// @tparam T A floating-point scalar type\n  ...\n  138  \n  139  \t/// Creates a left handed frustum matrix.\n  140: \t/// The near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n  141  \t///\n  142  \t/// @tparam T A floating-point scalar type\n  ...\n  146  \n  147  \t/// Creates a left handed frustum matrix.\n  148: \t/// The near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n  149  \t///\n  150  \t/// @tparam T A floating-point scalar type\n  ...\n  154  \n  155  \t/// Creates a right handed frustum matrix.\n  156: \t/// The near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n  157  \t///\n  158  \t/// @tparam T A floating-point scalar type\n  ...\n  162  \n  163  \t/// Creates a right handed frustum matrix.\n  164: \t/// The near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n  165  \t///\n  166  \t/// @tparam T A floating-point scalar type\n  ...\n  170  \n  171  \t/// Creates a frustum matrix using left-handed coordinates if GLM_FORCE_LEFT_HANDED if defined or right-handed coordinates otherwise.\n  172: \t/// The near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n  173  \t///\n  174  \t/// @tparam T A floating-point scalar type\n  ...\n  178  \n  179  \t/// Creates a frustum matrix using left-handed coordinates if GLM_FORCE_LEFT_HANDED if defined or right-handed coordinates otherwise.\n  180: \t/// The near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n  181  \t///\n  182  \t/// @tparam T A floating-point scalar type\n  ...\n  186  \n  187  \t/// Creates a left handed frustum matrix.\n  188: \t/// If GLM_FORCE_DEPTH_ZERO_TO_ONE is defined, the near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n  189: \t/// Otherwise, the near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n  190  \t///\n  191  \t/// @tparam T A floating-point scalar type\n  ...\n  195  \n  196  \t/// Creates a right handed frustum matrix.\n  197: \t/// If GLM_FORCE_DEPTH_ZERO_TO_ONE is defined, the near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n  198: \t/// Otherwise, the near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n  199  \t///\n  200  \t/// @tparam T A floating-point scalar type\n  ...\n  214  \n  215  \t/// Creates a matrix for a right handed, symetric perspective-view frustum.\n  216: \t/// The near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n  217  \t///\n  218  \t/// @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.\n  ...\n  227  \n  228  \t/// Creates a matrix for a right handed, symetric perspective-view frustum.\n  229: \t/// The near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n  230  \t///\n  231  \t/// @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.\n  ...\n  240  \n  241  \t/// Creates a matrix for a left handed, symetric perspective-view frustum.\n  242: \t/// The near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n  243  \t///\n  244  \t/// @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.\n  ...\n  253  \n  254  \t/// Creates a matrix for a left handed, symetric perspective-view frustum.\n  255: \t/// The near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n  256  \t///\n  257  \t/// @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.\n  ...\n  266  \n  267  \t/// Creates a matrix for a symetric perspective-view frustum using left-handed coordinates if GLM_FORCE_LEFT_HANDED if defined or right-handed coordinates otherwise.\n  268: \t/// The near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n  269  \t///\n  270  \t/// @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.\n  ...\n  279  \n  280  \t/// Creates a matrix for a symetric perspective-view frustum using left-handed coordinates if GLM_FORCE_LEFT_HANDED if defined or right-handed coordinates otherwise.\n  281: \t/// The near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n  282  \t///\n  283  \t/// @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.\n  ...\n  292  \n  293  \t/// Creates a matrix for a right handed, symetric perspective-view frustum.\n  294: \t/// If GLM_FORCE_DEPTH_ZERO_TO_ONE is defined, the near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n  295: \t/// Otherwise, the near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n  296  \t///\n  297  \t/// @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.\n  ...\n  306  \n  307  \t/// Creates a matrix for a left handed, symetric perspective-view frustum.\n  308: \t/// If GLM_FORCE_DEPTH_ZERO_TO_ONE is defined, the near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n  309: \t/// Otherwise, the near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n  310  \t///\n  311  \t/// @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.\n  ...\n  334  \n  335  \t/// Builds a perspective projection matrix based on a field of view using right-handed coordinates.\n  336: \t/// The near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n  337  \t///\n  338  \t/// @param fov Expressed in radians.\n  ...\n  348  \n  349  \t/// Builds a perspective projection matrix based on a field of view using right-handed coordinates.\n  350: \t/// The near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n  351  \t///\n  352  \t/// @param fov Expressed in radians.\n  ...\n  362  \n  363  \t/// Builds a perspective projection matrix based on a field of view using left-handed coordinates.\n  364: \t/// The near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n  365  \t///\n  366  \t/// @param fov Expressed in radians.\n  ...\n  376  \n  377  \t/// Builds a perspective projection matrix based on a field of view using left-handed coordinates.\n  378: \t/// The near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n  379  \t///\n  380  \t/// @param fov Expressed in radians.\n  ...\n  390  \n  391  \t/// Builds a perspective projection matrix based on a field of view using left-handed coordinates if GLM_FORCE_LEFT_HANDED if defined or right-handed coordinates otherwise.\n  392: \t/// The near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n  393  \t///\n  394  \t/// @param fov Expressed in radians.\n  ...\n  404  \n  405  \t/// Builds a perspective projection matrix based on a field of view using left-handed coordinates if GLM_FORCE_LEFT_HANDED if defined or right-handed coordinates otherwise.\n  406: \t/// The near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n  407  \t///\n  408  \t/// @param fov Expressed in radians.\n  ...\n  418  \n  419  \t/// Builds a right handed perspective projection matrix based on a field of view.\n  420: \t/// If GLM_FORCE_DEPTH_ZERO_TO_ONE is defined, the near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n  421: \t/// Otherwise, the near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n  422  \t///\n  423  \t/// @param fov Expressed in radians.\n  ...\n  433  \n  434  \t/// Builds a left handed perspective projection matrix based on a field of view.\n  435: \t/// If GLM_FORCE_DEPTH_ZERO_TO_ONE is defined, the near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n  436: \t/// Otherwise, the near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n  437  \t///\n  438  \t/// @param fov Expressed in radians.\n\n/home/max/dev/Falcor/src/Externals/GLM/glm/ext/matrix_projection.hpp:\n   36  \n   37  \t/// Map the specified object coordinates (obj.x, obj.y, obj.z) into window coordinates.\n   38: \t/// The near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n   39  \t///\n   40  \t/// @param obj Specify the object coordinates.\n   ..\n   52  \n   53  \t/// Map the specified object coordinates (obj.x, obj.y, obj.z) into window coordinates.\n   54: \t/// The near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n   55  \t///\n   56  \t/// @param obj Specify the object coordinates.\n   ..\n   84  \n   85  \t/// Map the specified window coordinates (win.x, win.y, win.z) into object coordinates.\n   86: \t/// The near and far clip planes correspond to z normalized device coordinates of 0 and +1 respectively. (Direct3D clip volume definition)\n   87  \t///\n   88  \t/// @param win Specify the window coordinates to be mapped.\n   ..\n  100  \n  101  \t/// Map the specified window coordinates (win.x, win.y, win.z) into object coordinates.\n  102: \t/// The near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. (OpenGL clip volume definition)\n  103  \t///\n  104  \t/// @param win Specify the window coordinates to be mapped.\n\n/home/max/dev/Falcor/src/Falcor/Core/API/BlendState.cpp:\n   37      }\n   38  \n   39:     BlendState::Desc::Desc(std::shared_ptr<Device> device): mpDevice(device) {\n   40:         mRtDesc.resize(Fbo::getMaxColorTargetCount(device));\n   41      }\n   42  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/BlendState.h:\n   79      class dlldecl Desc {\n   80       public:\n   81:         Desc(std::shared_ptr<Device> device);\n   82          friend class BlendState;\n   83  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/ComputeContext.cpp:\n   33  namespace Falcor {\n   34  \n   35: ComputeContext::SharedPtr ComputeContext::create(std::shared_ptr<Device> device, CommandQueueHandle queue) {\n   36:     auto pCtx = SharedPtr(new ComputeContext(device, LowLevelContextData::CommandQueueType::Compute, queue));\n   37      pCtx->bindDescriptorHeaps(); // TODO: Should this be done here?\n   38      return pCtx;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/ComputeContext.h:\n   47          \\return A new object, or throws an exception if creation failed.\n   48      */\n   49:     static SharedPtr create(std::shared_ptr<Device> device, CommandQueueHandle queue);\n   50  \n   51      /** Dispatch a compute task\n   ..\n   81  \n   82   protected:\n   83:     ComputeContext(std::shared_ptr<Device> device, LowLevelContextData::CommandQueueType type, CommandQueueHandle queue);\n   84      bool prepareForDispatch(ComputeState* pState, ComputeVars* pVars);\n   85      bool applyComputeVars(ComputeVars* pVars, RootSignature* pRootSignature);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/ComputeStateObject.cpp:\n   43  }\n   44  \n   45: ComputeStateObject::ComputeStateObject(std::shared_ptr<Device> device, const Desc& desc) : mpDevice(device), mDesc(desc) {\n   46      apiInit();\n   47  }\n   48  \n   49: ComputeStateObject::SharedPtr ComputeStateObject::create(std::shared_ptr<Device> device, const Desc& desc) {\n   50:     return SharedPtr(new ComputeStateObject(device, desc));\n   51  }\n   52  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/ComputeStateObject.h:\n   61          \\return New object, or throws an exception if creation failed.\n   62      */\n   63:     static SharedPtr create(std::shared_ptr<Device> device, const Desc& desc);\n   64  \n   65      const ApiHandle& getApiHandle() { return mApiHandle; }\n   ..\n   67  \n   68   private:\n   69:     ComputeStateObject(std::shared_ptr<Device> device, const Desc& desc);\n   70      void apiInit();\n   71  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/CopyContext.cpp:\n   36  CopyContext::~CopyContext() = default;\n   37  \n   38: CopyContext::CopyContext(std::shared_ptr<Device> device, LowLevelContextData::CommandQueueType type, CommandQueueHandle queue) {\n   39:     mpLowLevelData = LowLevelContextData::create(device, type, queue);\n   40      assert(mpLowLevelData);\n   41:     mpDevice = device;\n   42  }\n   43  \n   44: CopyContext::SharedPtr CopyContext::create(std::shared_ptr<Device> device, CommandQueueHandle queue) {\n   45      assert(queue);\n   46:     return SharedPtr(new CopyContext(device, LowLevelContextData::CommandQueueType::Copy, queue));\n   47  }\n   48  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/CopyContext.h:\n   69      virtual ~CopyContext();\n   70  \n   71:     std::shared_ptr<Device> device() { return mpDevice; };\n   72  \n   73      /** Create a copy context.\n   ..\n   75          \\return A new object, or throws an exception if creation failed.\n   76      */\n   77:     static SharedPtr create(std::shared_ptr<Device> device, CommandQueueHandle queue);\n   78  \n   79      /** Flush the command list. This doesn't reset the command allocator, just submits the commands\n   ..\n  147      void setLowLevelContextData(LowLevelContextData::SharedPtr pLowLevelData) { mpLowLevelData = pLowLevelData; }\n  148  \n  149:     /** Bind the descriptor heaps from the device into the command list.\n  150      */\n  151      void bindDescriptorHeaps();\n  152  \n  153   protected:\n  154:     CopyContext(std::shared_ptr<Device> device, LowLevelContextData::CommandQueueType type, CommandQueueHandle queue);\n  155  \n  156      bool textureBarrier(const Texture* pTexture, Resource::State newState);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Device.cpp:\n  125      DeviceHandle createDevice(IDXGIFactory4* pFactory, D3D_FEATURE_LEVEL requestedFeatureLevel, const std::vector<UUID>& experimentalFeatures)\n  126      {\n  127:         // Feature levels to try creating devices. Listed in descending order so the highest supported level is used.\n  128          const static D3D_FEATURE_LEVEL kFeatureLevels[] =\n  129          {\n  ...\n  142          IDXGIAdapter1Ptr pAdapter;\n  143          DeviceHandle pDevice;\n  144:         D3D_FEATURE_LEVEL deviceFeatureLevel;\n  145  \n  146:         // Read FALCOR_GPU_DEVICE_ID environment variable or select first GPU device\n  147          const uint32_t selectedGpuDeviceId = ([] ()\n  148          {\n  ...\n  165                  if (SUCCEEDED(D3D12CreateDevice(pAdapter, pFeatureLevels[i], IID_PPV_ARGS(&pDevice))))\n  166                  {\n  167:                     deviceFeatureLevel = pFeatureLevels[i];\n  168                      return true;\n  169                  }\n  ...\n  185              if (selectedGpuVendorId != 0 && desc.VendorId != selectedGpuVendorId) continue;\n  186  \n  187:             // Skip to selected device id\n  188              if (gpuDeviceId++ < selectedGpuDeviceId) continue;\n  189  \n  ...\n  193              if (pDevice != nullptr)\n  194              {\n  195:                 logInfo(\"Successfully created device with feature level: \" + to_string(deviceFeatureLevel));\n  196                  return pDevice;\n  197              }\n  198          }\n  199  \n  200:         logFatal(\"Could not find a GPU that supports D3D12 device\");\n  201          return nullptr;\n  202      }\n  ...\n  210          if (FAILED(hr) || features2.ProgrammableSamplePositionsTier == D3D12_PROGRAMMABLE_SAMPLE_POSITIONS_TIER_NOT_SUPPORTED)\n  211          {\n  212:             logInfo(\"Programmable sample positions is not supported on this device.\");\n  213          }\n  214          else\n  ...\n  222          if (FAILED(hr) || features5.RaytracingTier == D3D12_RAYTRACING_TIER_NOT_SUPPORTED)\n  223          {\n  224:             logInfo(\"Raytracing is not supported on this device.\");\n  225          }\n  226          else\n  ...\n  297          d3d_call(CreateDXGIFactory2(dxgiFlags, IID_PPV_ARGS(&mpApiData->pDxgiFactory)));\n  298  \n  299:         // Create the device\n  300          mApiHandle = createDevice(mpApiData->pDxgiFactory, getD3DFeatureLevel(mDesc.apiMajorVersion, mDesc.apiMinorVersion), mDesc.experimentalFeatures);\n  301          if (mApiHandle == nullptr) return false;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/DescriptorPool.cpp:\n   31  namespace Falcor {\n   32  \n   33: DescriptorPool::SharedPtr DescriptorPool::create(std::shared_ptr<Device> device, const Desc& desc, const GpuFence::SharedPtr& pFence) {\n   34:     return SharedPtr(new DescriptorPool(device, desc, pFence));\n   35  }\n   36  \n   37: DescriptorPool::DescriptorPool(std::shared_ptr<Device> device, const Desc& desc, const GpuFence::SharedPtr& pFence): mDesc(desc), mpFence(pFence) {\n   38      apiInit();\n   39  }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/DescriptorPool.h:\n   96          \\return A new object, or throws an exception if creation failed.\n   97      */\n   98:     static SharedPtr create(std::shared_ptr<Device> device, const Desc& desc, const GpuFence::SharedPtr& pFence);\n   99  \n  100:     std::shared_ptr<Device> device() { return mpDevice; }\n  101  \n  102      uint32_t getDescCount(Type type) const { return mDesc.mDescCount[(uint32_t)type]; }\n  ...\n  109   private:\n  110      friend DescriptorSet;\n  111:     DescriptorPool(std::shared_ptr<Device> device, const Desc& desc, const GpuFence::SharedPtr & pFence);\n  112      void apiInit();\n  113      void releaseAllocation(std::shared_ptr<DescriptorSetApiData> pData);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Device.cpp:\n   33  namespace Falcor {\n   34      \n   35: void createNullViews(Device::SharedPtr device);\n   36  void releaseNullViews();\n   37: void createNullBufferViews(Device::SharedPtr device);\n   38  void releaseNullBufferViews();\n   39: void createNullTypedBufferViews(Device::SharedPtr device);\n   40  void releaseNullTypedBufferViews();\n   41  \n   ..\n   55  Device::SharedPtr Device::create(Window::SharedPtr& pWindow, const Device::Desc& desc) {\n   56      if(pWindow) {\n   57:         // Swapchain enabled device\n   58          if (_gpDevice) {\n   59:             logError(\"Falcor only supports a single device\");\n   60              return nullptr;\n   61          }\n   ..\n   65          return _gpDevice;\n   66      } else {\n   67:         // Headless device\n   68          if (_gpDeviceHeadless) {\n   69:             logError(\"Falcor only supports a single headless device\");\n   70              return nullptr;\n   71          }\n   72  \n   73:         _gpDeviceHeadless = SharedPtr(new Device(nullptr, desc));  // headless device\n   74          if (_gpDeviceHeadless->init() == false) { _gpDeviceHeadless = nullptr;}\n   75          return _gpDeviceHeadless;\n   ..\n   78  \n   79  /**\n   80:  * Initialize device\n   81   */\n   82  bool Device::init() {\n   ..\n  330  \n  331  SCRIPT_BINDING(Device) {\n  332:     auto deviceDesc = m.class_<Device::Desc>(\"DeviceDesc\");\n  333  #define desc_field(f_) rwField(#f_, &Device::Desc::f_)\n  334:     deviceDesc.desc_field(colorFormat).desc_field(depthFormat).desc_field(apiMajorVersion).desc_field(apiMinorVersion);\n  335:     deviceDesc.desc_field(enableVsync).desc_field(enableDebugLayer).desc_field(cmdQueues);\n  336  #undef desc_field\n  337  \n  338:     auto deviceClass = m.regClass(Device);\n  339:     deviceClass.ctor(&Device::create);\n  340  }\n  341  \n  ...\n  363  \n  364      // RenderPassLibrary\n  365:     const auto& createRenderPass = [](std::shared_ptr<Device> device, const std::string& passName, pybind11::dict d = {}) {\n  366:         auto pPass = RenderPassLibrary::instance().createPass(device->getRenderContext(), passName.c_str(), Dictionary(d));\n  367          if (!pPass) { \n  368              throw std::runtime_error((\"Can't create a render pass named `\" + passName + \"`. Make sure the required library was loaded.\").c_str());\n  ...\n  370          return pPass;\n  371      };\n  372:     passClass.ctor(createRenderPass, \"device\"_a, \"name\"_a, \"dict\"_a = pybind11::dict());\n  373  \n  374      const auto& loadPassLibrary = [](const std::string& library) {\n  ...\n  378      m.func_(RenderGraphIR::kLoadPassLibrary, loadPassLibrary, \"name\"_a);\n  379  \n  380:     const auto& updateRenderPass = [](std::shared_ptr<Device> device, const RenderGraph::SharedPtr& pGraph, const std::string& passName, pybind11::dict d) {\n  381:         pGraph->updatePass(device->getRenderContext(), passName, Dictionary(d));\n  382      };\n  383  \n  384:     graphClass.func_(RenderGraphIR::kUpdatePass, updateRenderPass, \"device\"_a, \"name\"_a, \"dict\"_a);\n  385  }\n  386  */\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Device.h:\n   69          ResourceFormat colorFormat = ResourceFormat::BGRA8UnormSrgb;    ///< The color buffer format\n   70          ResourceFormat depthFormat = ResourceFormat::D32Float;          ///< The depth buffer format\n   71:         uint32_t apiMajorVersion = 0;                                   ///< Requested API major version. If specified, device creation will fail if not supported. Otherwise, the highest supported version will be automatically selected.\n   72:         uint32_t apiMinorVersion = 0;                                   ///< Requested API minor version. If specified, device creation will fail if not supported. Otherwise, the highest supported version will be automatically selected.\n   73          bool enableVsync = false;                                       ///< Controls vertical-sync\n   74          bool enableDebugLayer = DEFAULT_ENABLE_DEBUG_LAYER;             ///< Enable the debug layer. The default for release build is false, for debug build it's true.\n   ..\n   99      using MemoryType = GpuMemoryHeap::Type;\n  100  \n  101:     /** Create a new device.\n  102          \\param[in] pWindow a previously-created window object\n  103          \\param[in] desc Device configuration descriptor.\n  104:         \\return nullptr if the function failed, otherwise a new device object\n  105      */\n  106      static SharedPtr create(Window::SharedPtr& pWindow, const Desc& desc);\n  ...\n  121      bool isHeadless() { return headless; };\n  122  \n  123:     /** Get physical device name\n  124      */\n  125      std::string& getPhysicalDeviceName();\n  ...\n  141  \n  142      /** Get the default render-context.\n  143:         The default render-context is managed completely by the device. The user should just queue commands into it, the device will take care of allocation, submission and synchronization\n  144      */\n  145      RenderContext* getRenderContext() const { return mpRenderContext.get(); }\n  ...\n  196      double getGpuTimestampFrequency() const { return mGpuTimestampFrequency; }  // ms/tick\n  197  \n  198:     /** Check if features are supported by the device\n  199      */\n  200      bool isFeatureSupported(SupportedFeatures flags) const;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Engine.cpp:\n   39  Engine::SharedPtr gpEngineHeadless;    \n   40  \n   41: Engine::Engine(Device::SharedPtr device) : mpDevice(device) {\n   42      headless = mpDevice->isHeadless();\n   43  }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Engine.h:\n   57          \\param[in] pWindow a previously-created window object\n   58          \\param[in] desc Device configuration descriptor.\n   59:         \\return nullptr if the function failed, otherwise a new device object\n   60      */\n   61      static SharedPtr create(Window::SharedPtr& pWindow, const Device::Desc& desc);\n   ..\n   73      Fbo::SharedPtr getOffscreenFbo() const;\n   74  \n   75:     Device::SharedPtr device() { return mpDevice; };\n   76  \n   77   private:\n   78:     Engine(Device::SharedPtr device);\n   79  \n   80      void releaseFboData();\n\n/home/max/dev/Falcor/src/Falcor/Core/API/FBO.cpp:\n  114          }\n  115  \n  116:         Texture::SharedPtr createTexture2D(std::shared_ptr<Device> device, uint32_t w, uint32_t h, ResourceFormat format, uint32_t sampleCount, uint32_t arraySize, uint32_t mipLevels, Texture::BindFlags flags) {\n  117              if (format == ResourceFormat::Unknown) {\n  118                  logError(\"Can't create Texture2D with an unknown resource format\");\n  ...\n  122              Texture::SharedPtr pTex;\n  123              if (sampleCount > 1) {\n  124:                 pTex = Texture::create2DMS(device, w, h, format, sampleCount, arraySize, flags);\n  125              } else {\n  126:                 pTex = Texture::create2D(device, w, h, format, arraySize, mipLevels, nullptr, flags);\n  127              }\n  128  \n  ...\n  147          std::hash<uint32_t> u32hash;\n  148          std::hash<bool> bhash;\n  149:         for (uint32_t i = 0; i < getMaxColorTargetCount(d.device()); i++) {\n  150              uint32_t format = (uint32_t)d.getColorTargetFormat(i);\n  151              format <<= i;\n  ...\n  174      }\n  175  \n  176:     Fbo::Desc::Desc(std::shared_ptr<Device> device): mpDevice(device) {\n  177:         mColorTargets.resize(Fbo::getMaxColorTargetCount(device));\n  178      }\n  179  \n  180:     Fbo::SharedPtr Fbo::create(std::shared_ptr<Device> device) {\n  181:         return SharedPtr(new Fbo(device));\n  182      }\n  183  \n  184:     Fbo::SharedPtr Fbo::create(std::shared_ptr<Device> device, const std::vector<Texture::SharedPtr>& colors, const Texture::SharedPtr& pDepth) {\n  185:         auto pFbo = create(device);\n  186          for (uint32_t i = 0 ; i < colors.size() ; i++) {\n  187              pFbo->attachColorTarget(colors[i], i);\n  ...\n  194      }\n  195  \n  196:     Fbo::SharedPtr Fbo::getDefault(std::shared_ptr<Device> device) {\n  197          static Fbo::SharedPtr pDefault;\n  198          if (pDefault == nullptr) {\n  199:             pDefault = Fbo::SharedPtr(new Fbo(device));\n  200          }\n  201          return pDefault;\n  ...\n  344      }\n  345  \n  346:     Fbo::SharedPtr Fbo::create2D(std::shared_ptr<Device> device, uint32_t width, uint32_t height, const Fbo::Desc& fboDesc, uint32_t arraySize, uint32_t mipLevels) {\n  347          uint32_t sampleCount = fboDesc.getSampleCount();\n  348          if (checkParams(\"Create2D\", width, height, arraySize, mipLevels, sampleCount) == false) {\n  ...\n  350          }\n  351          \n  352:         Fbo::SharedPtr pFbo = create(device);\n  353          \n  354          // Create the color targets\n  355:         for (uint32_t i = 0; i < Fbo::getMaxColorTargetCount(device); i++) {\n  356              if (fboDesc.getColorTargetFormat(i) != ResourceFormat::Unknown) {\n  357                  Texture::BindFlags flags = getBindFlags(false, fboDesc.isColorTargetUav(i));\n  358:                 Texture::SharedPtr pTex = createTexture2D(device, width, height, fboDesc.getColorTargetFormat(i), sampleCount, arraySize, mipLevels, flags);\n  359                  pFbo->attachColorTarget(pTex, i, 0, 0, kAttachEntireMipLevel);\n  360              }\n  ...\n  363          if (fboDesc.getDepthStencilFormat() != ResourceFormat::Unknown) {\n  364              Texture::BindFlags flags = getBindFlags(true, fboDesc.isDepthStencilUav());\n  365:             Texture::SharedPtr pDepth = createTexture2D(device, width, height, fboDesc.getDepthStencilFormat(), sampleCount, arraySize, mipLevels, flags);\n  366              pFbo->attachDepthStencilTarget(pDepth, 0, 0, kAttachEntireMipLevel);\n  367          }\n  ...\n  370      }\n  371  \n  372:     Fbo::SharedPtr Fbo::createCubemap(std::shared_ptr<Device> device, uint32_t width, uint32_t height, const Desc& fboDesc, uint32_t arraySize, uint32_t mipLevels) {\n  373          if (fboDesc.getSampleCount() > 1) {\n  374              throw std::runtime_error(\"Can't create cubemap FBO. Multisampled cubemap is not supported.\");\n  ...\n  378          }\n  379  \n  380:         Fbo::SharedPtr pFbo = create(device);\n  381  \n  382          // Create the color targets\n  383:         for (uint32_t i = 0; i < getMaxColorTargetCount(device); i++) {\n  384              Texture::BindFlags flags = getBindFlags(false, fboDesc.isColorTargetUav(i));\n  385:             auto pTex = Texture::createCube(device, width, height, fboDesc.getColorTargetFormat(i), arraySize, mipLevels, nullptr, flags);\n  386              pFbo->attachColorTarget(pTex, i, 0, kAttachEntireMipLevel);\n  387          }\n  ...\n  389          if (fboDesc.getDepthStencilFormat() != ResourceFormat::Unknown) {\n  390              Texture::BindFlags flags = getBindFlags(true, fboDesc.isDepthStencilUav());\n  391:             auto pDepth = Texture::createCube(device, width, height, fboDesc.getDepthStencilFormat(), arraySize, mipLevels, nullptr, flags);\n  392              pFbo->attachDepthStencilTarget(pDepth, 0, kAttachEntireMipLevel);\n  393          }\n  ...\n  396      }\n  397  \n  398:     Fbo::SharedPtr Fbo::create2D(std::shared_ptr<Device> device, uint32_t width, uint32_t height, ResourceFormat color, ResourceFormat depth) {\n  399:         Desc d(device);\n  400          d.setColorTarget(0, color).setDepthStencilTarget(depth);\n  401:         return create2D(device, width, height, d);\n  402      }\n  403  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/FBO.h:\n   49      class dlldecl Desc {\n   50       public:\n   51:         Desc(std::shared_ptr<Device> device);\n   52  \n   53:         std::shared_ptr<Device> device() const { return mpDevice; }        \n   54  \n   55          /** Set a render target to be a color target.\n   ..\n  122      /** Get a FBO representing the default framebuffer object\n  123      */\n  124:     static SharedPtr getDefault(std::shared_ptr<Device> device);\n  125  \n  126      /** Create a new empty FBO.\n  127          \\return A new object, or throws an exception if creation failed.\n  128      */\n  129:     static SharedPtr create(std::shared_ptr<Device> device);\n  130  \n  131      /** Create an FBO from a list of textures. It will bind mip 0 and the all of the array slices.\n  ...\n  134          \\return A new object. An exception is thrown if creation failed, for example due to texture size mismatch, bind flags issues, illegal formats, etc.\n  135      */\n  136:     static SharedPtr create(std::shared_ptr<Device> device, const std::vector<Texture::SharedPtr>& colors, const Texture::SharedPtr& pDepth = nullptr);\n  137  \n  138      /** Create a color-only 2D framebuffer.\n  ...\n  144          \\return A new object. An exception is thrown if creation failed, for example due to invalid parameters.\n  145      */\n  146:     static SharedPtr create2D(std::shared_ptr<Device> device, uint32_t width, uint32_t height, const Desc& fboDesc, uint32_t arraySize = 1, uint32_t mipLevels = 1);\n  147  \n  148      /** Create a color-only cubemap framebuffer.\n  ...\n  154          \\return A new object. An exception is thrown if creation failed, for example due to invalid parameters.\n  155      */\n  156:     static SharedPtr createCubemap(std::shared_ptr<Device> device, uint32_t width, uint32_t height, const Desc& fboDesc, uint32_t arraySize = 1, uint32_t mipLevels = 1);\n  157  \n  158      /** Creates an FBO with a single color texture (single mip, single array slice), and optionally a depth buffer.\n  ...\n  163          \\return A new object. An exception is thrown if creation failed, for example due to invalid parameters.\n  164      */\n  165:     static SharedPtr create2D(std::shared_ptr<Device> device, uint32_t width, uint32_t height, ResourceFormat color, ResourceFormat depth = ResourceFormat::Unknown);\n  166  \n  167      /** Attach a depth-stencil texture.\n  ...\n  190      /** Get the maximum number of color targets\n  191      */\n  192:     static uint32_t getMaxColorTargetCount(std::shared_ptr<Device> device);\n  193  \n  194      /** Get an attached color texture. If no texture is attached will return nullptr.\n  ...\n  271      void finalize() const;\n  272  \n  273:     Fbo(std::shared_ptr<Device> device);\n  274      std::vector<Attachment> mColorAttachments;\n  275      std::vector<SamplePosition> mSamplePositions;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/FencedPool.h:\n   51          \\return A new object, or throws an exception if creation failed.\n   52      */\n   53:     static SharedPtr create(std::shared_ptr<Device> device, GpuFence::SharedConstPtr pFence, NewObjectFuncType newFunc, void* pUserData = nullptr) {\n   54:         return SharedPtr(new FencedPool(device, pFence, newFunc, pUserData));\n   55      }\n   56  \n   ..\n   78  \n   79  private:\n   80:     FencedPool(std::shared_ptr<Device> device, GpuFence::SharedConstPtr pFence, NewObjectFuncType newFunc, void* pUserData)\n   81          : mpUserData(pUserData)\n   82          , mpFence(pFence)\n   83          , mNewObjFunc(newFunc)\n   84:         , mpDevice(device)\n   85      {\n   86:         assert(device);\n   87          assert(pFence && newFunc);\n   88          mActiveObject = createObject();\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Formats.h:\n  355      /** Get the supported bind-flags for a specific format\n  356      */\n  357:     ResourceBindFlags getFormatBindFlags(std::shared_ptr<Device> device, ResourceFormat format);\n  358  \n  359      inline const std::string& to_string(ResourceFormat format) {\n\n/home/max/dev/Falcor/src/Falcor/Core/API/GpuFence.h:\n   53          \\return A new object, or throws an exception if creation failed.\n   54      */\n   55:     static SharedPtr create(std::shared_ptr<Device> device);\n   56  \n   57      /** Get the internal API handle\n   ..\n   79      uint64_t gpuSignal(CommandQueueHandle pQueue);\n   80  private:\n   81:     GpuFence(std::shared_ptr<Device> device) : mCpuValue(0), mpDevice(device) {}\n   82      uint64_t mCpuValue;\n   83  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/GpuMemoryHeap.cpp:\n   36      }\n   37  \n   38:     GpuMemoryHeap::GpuMemoryHeap(std::shared_ptr<Device> device, Type type, size_t pageSize, const GpuFence::SharedPtr& pFence)\n   39          : mType(type)\n   40          , mPageSize(pageSize)\n   41          , mpFence(pFence)\n   42:         , mpDevice(device)\n   43      {\n   44          allocateNewPage();\n   45      }\n   46  \n   47:     GpuMemoryHeap::SharedPtr GpuMemoryHeap::create(std::shared_ptr<Device> device, Type type, size_t pageSize, const GpuFence::SharedPtr& pFence) {\n   48:         return SharedPtr(new GpuMemoryHeap(device, type, pageSize, pFence));\n   49      }\n   50  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/GpuMemoryHeap.h:\n   74          \\return A new object, or throws an exception if creation failed.\n   75      */\n   76:     static SharedPtr create(std::shared_ptr<Device> device, Type type, size_t pageSize, const GpuFence::SharedPtr& pFence);\n   77  \n   78      Allocation allocate(size_t size, size_t alignment = 1);\n   ..\n   82  \n   83  private:\n   84:     GpuMemoryHeap(std::shared_ptr<Device> device, Type type, size_t pageSize, const GpuFence::SharedPtr& pFence);\n   85  \n   86      struct PageData : public BaseData {\n\n/home/max/dev/Falcor/src/Falcor/Core/API/GpuTimer.cpp:\n   40  std::weak_ptr<QueryHeap> GpuTimer::spHeap;\n   41  \n   42: GpuTimer::SharedPtr GpuTimer::create(std::shared_ptr<Device> device) {\n   43:     return SharedPtr(new GpuTimer(device));\n   44  }\n   45  \n   46: GpuTimer::GpuTimer(std::shared_ptr<Device> device): mpDevice(device) {\n   47:     assert(device);\n   48  #ifdef FALCOR_D3D12\n   49:     mpResolveBuffer = Buffer::create(device, sizeof(uint64_t) * 2, Buffer::BindFlags::None, Buffer::CpuAccess::Read, nullptr);\n   50  #endif\n   51      // Create timestamp query heap upon first use.\n   52      // We're allocating pairs of adjacent queries, so need our own heap to meet this requirement.\n   53      if (spHeap.expired()) {\n   54:         spHeap = device->createQueryHeap(QueryHeap::Type::Timestamp, 16 * 1024);\n   55      }\n   56      auto pHeap = spHeap.lock();\n   ..\n   62      }\n   63      assert(mEnd == (mStart + 1));\n   64:     mpLowLevelData = device->getRenderContext()->getLowLevelData();\n   65  }\n   66  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/GpuTimer.h:\n   49          \\return A new object, or throws an exception if creation failed.\n   50      */\n   51:     static SharedPtr create(std::shared_ptr<Device> device);\n   52  \n   53      /** Destroy a new object\n   ..\n   71  \n   72   private:\n   73:     GpuTimer(std::shared_ptr<Device> device);\n   74  \n   75      enum Status {\n\n/home/max/dev/Falcor/src/Falcor/Core/API/GraphicsStateObject.cpp:\n   70  }\n   71  \n   72: GraphicsStateObject::GraphicsStateObject(std::shared_ptr<Device> device, const Desc& desc) : mpDevice(device), mDesc(desc) {\n   73      if (spDefaultBlendState == nullptr) {\n   74          // Create default objects\n   75:         spDefaultBlendState = BlendState::create(BlendState::Desc(device));\n   76          spDefaultDepthStencilState = DepthStencilState::create(DepthStencilState::Desc());\n   77          spDefaultRasterizerState = RasterizerState::create(RasterizerState::Desc());\n   ..\n   86  }\n   87  \n   88: GraphicsStateObject::SharedPtr GraphicsStateObject::create(std::shared_ptr<Device> device, const Desc& desc) {\n   89:     return SharedPtr(new GraphicsStateObject(device, desc));\n   90  }\n   91  \n   92: GraphicsStateObject::Desc::Desc (std::shared_ptr<Device> device): mFboDesc(device) {\n   93  \n   94  }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/GraphicsStateObject.h:\n   91          friend class GraphicsState;\n   92  \n   93:         Desc(std::shared_ptr<Device> device);\n   94  \n   95          Fbo::Desc mFboDesc;\n   ..\n  121          \\return New object, or throws an exception if creation failed.\n  122      */\n  123:     static SharedPtr create(std::shared_ptr<Device> device, const Desc& desc);\n  124  \n  125      const ApiHandle& getApiHandle() { return mApiHandle; }\n  ...\n  128  \n  129   private:\n  130:     GraphicsStateObject(std::shared_ptr<Device> device, const Desc& desc);\n  131      void apiInit();\n  132  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/LowLevelContextData.h:\n   58          \\return A new object, or throws an expception if creation failed.\n   59      */\n   60:     static SharedPtr create(std::shared_ptr<Device> device, CommandQueueType type, CommandQueueHandle queue);\n   61  \n   62      void flush();\n   ..\n   74  \n   75   protected:\n   76:     LowLevelContextData(std::shared_ptr<Device> device, CommandQueueType type, CommandQueueHandle queue);\n   77  \n   78      LowLevelContextApiData* mpApiData = nullptr;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/QueryHeap.h:\n   57          \\return New object, or throws an exception if creation failed.\n   58      */\n   59:     static SharedPtr create(std::shared_ptr<Device> device, Type type, uint32_t count) { return SharedPtr(new QueryHeap(device, type, count)); }\n   60  \n   61      const ApiHandle& getApiHandle() const { return mApiHandle; }\n   ..\n   85  \n   86   private:\n   87:     QueryHeap(std::shared_ptr<Device> device, Type type, uint32_t count);\n   88      ApiHandle mApiHandle;\n   89      uint32_t mCount = 0;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/RenderContext.cpp:\n   35  namespace Falcor {\n   36  \n   37:     RenderContext::SharedPtr RenderContext::create(std::shared_ptr<Device> device, CommandQueueHandle queue) {\n   38:         return SharedPtr(new RenderContext(device, queue));\n   39      }\n   40  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/RenderContext.h:\n   76          \\return A new object, or throws an exception if creation failed.\n   77      */\n   78:     static SharedPtr create(std::shared_ptr<Device> device, CommandQueueHandle queue);\n   79  \n   80      /** Clear an FBO.\n   ..\n  194  \n  195  private:\n  196:     RenderContext(std::shared_ptr<Device> device, CommandQueueHandle queue);\n  197      bool applyGraphicsVars(GraphicsVars* pVars, RootSignature* pRootSignature);\n  198      bool prepareForDraw(GraphicsState* pState, GraphicsVars* pVars);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Resource.h:\n   99      virtual ~Resource() = 0;\n  100  \n  101:     std::shared_ptr<Device> device() { return mpDevice; }\n  102:     std::shared_ptr<Device> device() const { return mpDevice; }\n  103  \n  104      /** Get the bind flags\n  ...\n  177      friend class CopyContext;\n  178  \n  179:     Resource(std::shared_ptr<Device> device, Type type, BindFlags bindFlags, uint64_t size) : mpDevice(device), mType(type), mBindFlags(bindFlags), mSize(size) {}\n  180  \n  181      Type mType;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/ResourceViews.cpp:\n   38  static NullResourceViews gNullTypedBufferViews;\n   39  \n   40: Buffer::SharedPtr getEmptyBuffer(Device::SharedPtr device);\n   41: Buffer::SharedPtr getEmptyTypedBuffer(Device::SharedPtr device);\n   42: Buffer::SharedPtr createZeroBuffer(Device::SharedPtr device);\n   43: Buffer::SharedPtr createZeroTypedBuffer(Device::SharedPtr device);\n   44  \n   45: Texture::SharedPtr getEmptyTexture(Device::SharedPtr device);\n   46: Texture::SharedPtr createBlackTexture(Device::SharedPtr device);\n   47  \n   48: void createNullViews(Device::SharedPtr device) {\n   49:     gNullViews.srv = ShaderResourceView::create(getEmptyTexture(device), 0, 1, 0, 1);\n   50:     gNullViews.dsv = DepthStencilView::create(getEmptyTexture(device), 0, 0, 1);\n   51:     gNullViews.uav = UnorderedAccessView::create(getEmptyTexture(device), 0, 0, 1);\n   52:     gNullViews.rtv = RenderTargetView::create(getEmptyTexture(device), 0, 0, 1);\n   53      gNullViews.cbv = ConstantBufferView::create(Buffer::SharedPtr());\n   54  }\n   55  \n   56: void createNullBufferViews(Device::SharedPtr device) {\n   57:     gNullBufferViews.srv = ShaderResourceView::create(getEmptyBuffer(device), 0, 0);\n   58:     gNullBufferViews.uav = UnorderedAccessView::create(getEmptyBuffer(device), 0, 0);\n   59  }\n   60  \n   61: void createNullTypedBufferViews(Device::SharedPtr device) {\n   62:     gNullTypedBufferViews.srv = ShaderResourceView::create(getEmptyTypedBuffer(device), 0, 0);\n   63:     gNullTypedBufferViews.uav = UnorderedAccessView::create(getEmptyTypedBuffer(device), 0, 0);\n   64  }\n   65  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/RootSignature.cpp:\n   63  }\n   64  \n   65: RootSignature::RootSignature(std::shared_ptr<Device> device, const Desc& desc): mDesc(desc), mpDevice(device) {\n   66      sObjCount++;\n   67      apiInit();\n   ..\n   76  }\n   77  \n   78: RootSignature::SharedPtr RootSignature::getEmpty(std::shared_ptr<Device> device) {\n   79      if (spEmptySig) return spEmptySig;\n   80:     return create(device, Desc());\n   81  }\n   82  \n   83: RootSignature::SharedPtr RootSignature::create(std::shared_ptr<Device> device, const Desc& desc) {\n   84      bool empty = desc.mSets.empty() && desc.mRootDescriptors.empty() && desc.mRootConstants.empty();\n   85      if (empty && spEmptySig) {\n   ..\n   87      }\n   88  \n   89:     SharedPtr pSig = SharedPtr(new RootSignature(device, desc));\n   90      if (empty) spEmptySig = pSig;\n   91  \n   ..\n  172  }\n  173  \n  174: RootSignature::SharedPtr RootSignature::create(std::shared_ptr<Device> device, const ProgramReflection* pReflector) {\n  175      assert(pReflector);\n  176      RootSignature::Desc d;\n  177      addParamBlockSets(pReflector->getDefaultParameterBlock().get(), d);\n  178      addRootDescriptors(pReflector->getDefaultParameterBlock().get(), d);\n  179:     return RootSignature::create(device, d);\n  180  }\n  181  \n  182: RootSignature::SharedPtr RootSignature::createLocal(std::shared_ptr<Device> device, const EntryPointBaseReflection* pReflector) {\n  183      assert(pReflector);\n  184      RootSignature::Desc d;\n  ...\n  193  #endif\n  194  \n  195:     return RootSignature::create(device, d);\n  196  }\n  197  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/RootSignature.h:\n  112          \\return Empty root signtuare, or throws an exception on error.\n  113      */\n  114:     static SharedPtr getEmpty(std::shared_ptr<Device> device);\n  115  \n  116      /** Create a root signature.\n  ...\n  118          \\return New object, or throws an exception if creation failed.\n  119      */\n  120:     static SharedPtr create(std::shared_ptr<Device> device, const Desc& desc);\n  121  \n  122      /** Create a root signature from program reflection.\n  ...\n  124          \\return New object, or throws an exception if creation failed.\n  125      */\n  126:     static SharedPtr create(std::shared_ptr<Device> device, const ProgramReflection* pReflection);\n  127  \n  128      /** Create a local root signature for use with DXR.\n  ...\n  130          \\return New object, or throws an exception if creation failed.\n  131      */\n  132:     static SharedPtr createLocal(std::shared_ptr<Device> device, const EntryPointGroupReflection* pReflector);\n  133  \n  134      const ApiHandle& getApiHandle() const { return mApiHandle; }\n  ...\n  150  \n  151   protected:\n  152:     RootSignature(std::shared_ptr<Device> device, const Desc& desc);\n  153      void apiInit();\n  154  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Sampler.cpp:\n   37  SamplerData gSamplerData;\n   38  \n   39: Sampler::Sampler(std::shared_ptr<Device> device, const Desc& desc) : mDesc(desc), mpDevice(device) {\n   40      gSamplerData.objectCount++;\n   41  }\n   ..\n   82  }\n   83  \n   84: Sampler::SharedPtr Sampler::getDefault(std::shared_ptr<Device> device) {\n   85      if (gSamplerData.pDefaultSampler == nullptr) {\n   86:         gSamplerData.pDefaultSampler = create(device, Desc());\n   87      }\n   88      return gSamplerData.pDefaultSampler;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Sampler.h:\n  129          \\return A new object, or throws an exception if creation failed.\n  130      */\n  131:     static SharedPtr create(std::shared_ptr<Device> device, const Desc& desc);\n  132  \n  133      /** Get the API handle\n  ...\n  189      /** Get an object that represents a default sampler\n  190      */\n  191:     static Sampler::SharedPtr getDefault(std::shared_ptr<Device> device);\n  192  \n  193  private:\n  194:     Sampler(std::shared_ptr<Device> device, const Desc& desc);\n  195      Desc mDesc;\n  196      ApiHandle mApiHandle = {};\n  197:     static uint32_t getApiMaxAnisotropy(std::shared_ptr<Device> device);\n  198  \n  199      std::shared_ptr<Device> mpDevice; \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Shader.h:\n  187          \\return If success, a new shader object, otherwise nullptr\n  188      */\n  189:     static SharedPtr create(std::shared_ptr<Device> device, const Blob& shaderBlob, ShaderType type, std::string const&  entryPointName, CompilerFlags flags, std::string& log) {\n  190:         SharedPtr pShader = SharedPtr(new Shader(device, type));\n  191          pShader->mEntryPointName = entryPointName;\n  192          return pShader->init(shaderBlob, entryPointName, flags, log) ? pShader : nullptr;\n  ...\n  214      // API handle depends on the shader Type, so it stored be stored as part of the private data\n  215      bool init(const Blob& shaderBlob, const std::string&  entryPointName, CompilerFlags flags, std::string& log);\n  216:     Shader(std::shared_ptr<Device> device, ShaderType Type);\n  217      ShaderType mType;\n  218      std::string mEntryPointName;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Texture.cpp:\n   37  \n   38  // namespace {\n   39: Texture::BindFlags updateBindFlags(Device::SharedPtr device, Texture::BindFlags flags, bool hasInitData, uint32_t mipLevels, ResourceFormat format, const std::string& texType) {\n   40      if ((mipLevels == Texture::kMaxPossible) && hasInitData) {\n   41          flags |= Texture::BindFlags::RenderTarget;\n   42      }\n   43  \n   44:     Texture::BindFlags supported = getFormatBindFlags(device, format);\n   45      supported |= ResourceBindFlags::Shared;\n   46      if ((flags & supported) != flags) {\n   ..\n   55  // }\n   56  \n   57: Texture::SharedPtr Texture::createFromApiHandle(std::shared_ptr<Device> device, ApiHandle handle, Type type, uint32_t width, uint32_t height, uint32_t depth, ResourceFormat format, uint32_t sampleCount, uint32_t arraySize, uint32_t mipLevels, State initState, BindFlags bindFlags) {\n   58      assert(handle);\n   59      switch (type) {\n   ..\n   78      }\n   79  \n   80:     Texture::SharedPtr pTexture = SharedPtr(new Texture(device, width, height, depth, arraySize, mipLevels, sampleCount, format, type, bindFlags));\n   81      pTexture->mApiHandle = handle;\n   82      pTexture->mState.global = initState;\n   ..\n   85  }\n   86  \n   87: Texture::SharedPtr Texture::create1D(std::shared_ptr<Device> device, uint32_t width, ResourceFormat format, uint32_t arraySize, uint32_t mipLevels, const void* pData, BindFlags bindFlags) {\n   88:     bindFlags = updateBindFlags(device, bindFlags, pData != nullptr, mipLevels, format, \"Texture1D\");\n   89:     Texture::SharedPtr pTexture = SharedPtr(new Texture(device, width, 1, 1, arraySize, mipLevels, 1, format, Type::Texture1D, bindFlags));\n   90      pTexture->apiInit(pData, (mipLevels == kMaxPossible));\n   91      return pTexture;\n   92  }\n   93  \n   94: Texture::SharedPtr Texture::create2D(std::shared_ptr<Device> device, uint32_t width, uint32_t height, ResourceFormat format, uint32_t arraySize, uint32_t mipLevels, const void* pData, BindFlags bindFlags) {\n   95:     bindFlags = updateBindFlags(device, bindFlags, pData != nullptr, mipLevels, format, \"Texture2D\");\n   96:     Texture::SharedPtr pTexture = SharedPtr(new Texture(device, width, height, 1, arraySize, mipLevels, 1, format, Type::Texture2D, bindFlags));\n   97      pTexture->apiInit(pData, (mipLevels == kMaxPossible));\n   98      return pTexture;\n   99  }\n  100  \n  101: Texture::SharedPtr Texture::create3D(std::shared_ptr<Device> device, uint32_t width, uint32_t height, uint32_t depth, ResourceFormat format, uint32_t mipLevels, const void* pData, BindFlags bindFlags, bool isSparse) {\n  102:     bindFlags = updateBindFlags(device, bindFlags, pData != nullptr, mipLevels, format, \"Texture3D\");\n  103:     Texture::SharedPtr pTexture = SharedPtr(new Texture(device, width, height, depth, 1, mipLevels, 1, format, Type::Texture3D, bindFlags));\n  104      pTexture->apiInit(pData, (mipLevels == kMaxPossible));\n  105      return pTexture;\n  106  }\n  107  \n  108: Texture::SharedPtr Texture::createCube(std::shared_ptr<Device> device, uint32_t width, uint32_t height, ResourceFormat format, uint32_t arraySize, uint32_t mipLevels, const void* pData, BindFlags bindFlags) {\n  109:     bindFlags = updateBindFlags(device, bindFlags, pData != nullptr, mipLevels, format, \"TextureCube\");\n  110:     Texture::SharedPtr pTexture = SharedPtr(new Texture(device, width, height, 1, arraySize, mipLevels, 1, format, Type::TextureCube, bindFlags));\n  111      pTexture->apiInit(pData, (mipLevels == kMaxPossible));\n  112      return pTexture;\n  113  }\n  114  \n  115: Texture::SharedPtr Texture::create2DMS(std::shared_ptr<Device> device, uint32_t width, uint32_t height, ResourceFormat format, uint32_t sampleCount, uint32_t arraySize, BindFlags bindFlags) {\n  116:     bindFlags = updateBindFlags(device, bindFlags, false, 1, format, \"Texture2DMultisample\");\n  117:     Texture::SharedPtr pTexture = SharedPtr(new Texture(device, width, height, 1, arraySize, 1, sampleCount, format, Type::Texture2DMultisample, bindFlags));\n  118      pTexture->apiInit(nullptr, false);\n  119      return pTexture;\n  120  }\n  121  \n  122: Texture::Texture(std::shared_ptr<Device> device, uint32_t width, uint32_t height, uint32_t depth, uint32_t arraySize, uint32_t mipLevels, uint32_t sampleCount, ResourceFormat format, Type type, BindFlags bindFlags)\n  123:     : Resource(device, type, bindFlags, 0), mWidth(width), mHeight(height), mDepth(depth), mMipLevels(mipLevels), mSampleCount(sampleCount), mArraySize(arraySize), mFormat(format) {\n  124      assert(width > 0 && height > 0 && depth > 0);\n  125      assert(arraySize > 0 && mipLevels > 0 && sampleCount > 0);\n  ...\n  323  \n  324      auto data = [](Texture* pTexture, uint32_t subresource) {\n  325:         return pTexture->device()->getRenderContext()->readTextureSubresource(pTexture, subresource);\n  326      };\n  327      c.func_(\"data\", data, \"subresource\"_a);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Texture.h:\n  111          \\return A pointer to a new texture, or throws an exception if creation failed.\n  112      */\n  113:     static SharedPtr createFromApiHandle(std::shared_ptr<Device> device, ApiHandle handle, Type type, uint32_t width, uint32_t height, uint32_t depth, ResourceFormat format, uint32_t sampleCount, uint32_t arraySize, uint32_t mipLevels, State initState, BindFlags bindFlags);\n  114  \n  115      /** Create a 1D texture.\n  ...\n  122          \\return A pointer to a new texture, or throws an exception if creation failed.\n  123      */\n  124:     static SharedPtr create1D(std::shared_ptr<Device> device, uint32_t width, ResourceFormat format, uint32_t arraySize = 1, uint32_t mipLevels = kMaxPossible, const void* pInitData = nullptr, BindFlags bindFlags = BindFlags::ShaderResource);\n  125  \n  126      /** Create a 2D texture.\n  ...\n  134          \\return A pointer to a new texture, or throws an exception if creation failed.\n  135      */\n  136:     static SharedPtr create2D(std::shared_ptr<Device> device, uint32_t width, uint32_t height, ResourceFormat format, uint32_t arraySize = 1, uint32_t mipLevels = kMaxPossible, const void* pInitData = nullptr, BindFlags bindFlags = BindFlags::ShaderResource);\n  137  \n  138      /** Create a 3D texture.\n  ...\n  147          \\return A pointer to a new texture, or throws an exception if creation failed.\n  148      */\n  149:     static SharedPtr create3D(std::shared_ptr<Device> device, uint32_t width, uint32_t height, uint32_t depth, ResourceFormat format, uint32_t mipLevels = kMaxPossible, const void* pInitData = nullptr, BindFlags bindFlags = BindFlags::ShaderResource, bool isSparse = false);\n  150  \n  151      /** Create a cube texture.\n  ...\n  159          \\return A pointer to a new texture, or throws an exception if creation failed.\n  160      */\n  161:     static SharedPtr createCube(std::shared_ptr<Device> device, uint32_t width, uint32_t height, ResourceFormat format, uint32_t arraySize = 1, uint32_t mipLevels = kMaxPossible, const void* pInitData = nullptr, BindFlags bindFlags = BindFlags::ShaderResource);\n  162  \n  163      /** Create a multi-sampled 2D texture.\n  ...\n  170          \\return A pointer to a new texture, or throws an exception if creation failed.\n  171      */\n  172:     static SharedPtr create2DMS(std::shared_ptr<Device> device, uint32_t width, uint32_t height, ResourceFormat format, uint32_t sampleCount, uint32_t arraySize = 1, BindFlags bindFlags = BindFlags::ShaderResource);\n  173  \n  174      /** Create a new texture object from a file.\n  ...\n  179          \\return A new texture, or nullptr if the texture failed to load.\n  180      */\n  181:     static SharedPtr createFromFile(std::shared_ptr<Device> device, const std::string& filename, bool generateMipLevels, bool loadAsSrgb, BindFlags bindFlags = BindFlags::ShaderResource);\n  182  \n  183      /** Get a shader-resource view for the entire resource\n  ...\n  244  \n  245   protected:\n  246:     Texture(std::shared_ptr<Device> device, uint32_t width, uint32_t height, uint32_t depth, uint32_t arraySize, uint32_t mipLevels, uint32_t sampleCount, ResourceFormat format, Type Type, BindFlags bindFlags);\n  247      void apiInit(const void* pData, bool autoGenMips);\n  248      void uploadInitData(const void* pData, bool autoGenMips);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/TextureLoader.cpp:\n  529  }\n  530  \n  531: Texture::SharedPtr createTextureFromDx10Dds(std::shared_ptr<Device> device, DdsData& ddsData, const std::string& filename, ResourceFormat format, uint32_t mipLevels, Texture::BindFlags bindFlags) {\n  532      format = convertBgrxFormatToBgra(ddsData, format);\n  533  \n  ...\n  537      switch(ddsData.dx10Header.resourceDimension) {\n  538          case DXResourceDimension::RESOURCE_DIMENSION_TEXTURE1D:\n  539:             return Texture::create1D(device, ddsData.header.width, format, arraySize, mipLevels, ddsData.data.data(), bindFlags);\n  540          case DXResourceDimension::RESOURCE_DIMENSION_TEXTURE2D:\n  541              if(ddsData.dx10Header.miscFlag & DdsHeaderDX10::kCubeMapMask) {\n  542                  flipData(ddsData, format, ddsData.header.width, ddsData.header.height, 6 * arraySize, mipLevels == Texture::kMaxPossible ? 1 : mipLevels, true);\n  543:                 return Texture::createCube(device, ddsData.header.width, ddsData.header.height, format, arraySize, mipLevels, ddsData.data.data(), bindFlags);\n  544              } else {\n  545                  flipData(ddsData, format, ddsData.header.width, ddsData.header.height, arraySize, mipLevels == Texture::kMaxPossible ? 1 : mipLevels);\n  546:                 return Texture::create2D(device, ddsData.header.width, ddsData.header.height, format, arraySize, mipLevels, ddsData.data.data(), bindFlags);\n  547              }\n  548          case DXResourceDimension::RESOURCE_DIMENSION_TEXTURE3D:\n  549              flipData(ddsData, format, ddsData.header.width, ddsData.header.height, ddsData.header.depth, mipLevels == Texture::kMaxPossible ? 1 : mipLevels);\n  550:             return Texture::create3D(device, ddsData.header.width, ddsData.header.height, ddsData.header.depth, format, mipLevels, ddsData.data.data(), bindFlags);\n  551          case DXResourceDimension::RESOURCE_DIMENSION_BUFFER:\n  552          case DXResourceDimension::RESOURCE_DIMENSION_UNKNOWN:\n  ...\n  559  }\n  560  \n  561: Texture::SharedPtr createTextureFromLegacyDds(std::shared_ptr<Device> device, DdsData& ddsData, const std::string& filename, ResourceFormat format, uint32_t mipLevels, Texture::BindFlags bindFlags) {\n  562      format = convertBgrxFormatToBgra(ddsData, format);\n  563  \n  ...\n  565      if (ddsData.header.flags & DdsHeader::kDepthMask) {\n  566          flipData(ddsData, format, ddsData.header.width, ddsData.header.height, ddsData.header.depth, mipLevels == Texture::kMaxPossible ? 1 : mipLevels);\n  567:         return Texture::create3D(device, ddsData.header.width, ddsData.header.height, ddsData.header.depth, format, mipLevels, ddsData.data.data(), bindFlags);\n  568      } else if (ddsData.header.caps[1] & DdsHeader::kCaps2CubeMapMask) {\n  569          // Load the cubemap texture\n  570:         return Texture::createCube(device, ddsData.header.width, ddsData.header.height, format, 1, mipLevels, ddsData.data.data(), bindFlags);\n  571      } else {\n  572          // This is a 2D Texture\n  573          flipData(ddsData, format, ddsData.header.width, ddsData.header.height, 1, mipLevels == Texture::kMaxPossible ? 1 : mipLevels);\n  574:         return Texture::create2D(device, ddsData.header.width, ddsData.header.height, format, 1, mipLevels, ddsData.data.data(), bindFlags);\n  575      }\n  576  \n  ...\n  579  }\n  580  \n  581: Texture::SharedPtr createTextureFromDDSFile(std::shared_ptr<Device> device, const std::string filename, bool generateMips, bool loadAsSrgb, Texture::BindFlags bindFlags) {\n  582      DdsData ddsData;\n  583      if (!loadDDSDataFromFile(filename, ddsData)) return nullptr;\n  ...\n  601  \n  602      if (ddsData.hasDX10Header) {\n  603:         return createTextureFromDx10Dds(device, ddsData, filename, format, mipLevels, bindFlags);\n  604      } else {\n  605:         return createTextureFromLegacyDds(device, ddsData, filename, format, mipLevels, bindFlags);\n  606      }\n  607  }\n  608  \n  609: Texture::SharedPtr Texture::createFromFile(std::shared_ptr<Device> device, const std::string& filename, bool generateMipLevels, bool loadAsSrgb, Texture::BindFlags bindFlags) {\n  610      std::string fullpath;\n  611      if (findFileInDataDirectories(filename, fullpath) == false) {\n  ...\n  616      Texture::SharedPtr pTex;\n  617      if (hasSuffix(filename, \".dds\")) {\n  618:         pTex = createTextureFromDDSFile(device, fullpath, generateMipLevels, loadAsSrgb, bindFlags);\n  619      } else {\n  620:         Bitmap::UniqueConstPtr pBitmap = Bitmap::createFromFile(device, fullpath, kTopDown);\n  621          if (pBitmap) {\n  622              ResourceFormat texFormat = pBitmap->getFormat();\n  ...\n  625              }\n  626  \n  627:             pTex = Texture::create2D(device, pBitmap->getWidth(), pBitmap->getHeight(), texFormat, 1, generateMipLevels ? Texture::kMaxPossible : 1, pBitmap->getData(), bindFlags);\n  628          }\n  629      }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/FalcorVK.h:\n  128  class Device;\n  129  \n  130: uint32_t getMaxViewportCount(std::shared_ptr<Device> device);\n  131  \n  132  }  // namespace Falcor\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKBuffer.cpp:\n   36  namespace Falcor {\n   37      \n   38: VkDeviceMemory allocateDeviceMemory(Device::SharedPtr device, GpuMemoryHeap::Type memType, uint32_t memoryTypeBits, size_t size) {\n   39      VkMemoryAllocateInfo allocInfo = {};\n   40      allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;\n   41      allocInfo.allocationSize = size;\n   42:     allocInfo.memoryTypeIndex = device->getVkMemoryType(memType, memoryTypeBits);\n   43  \n   44:     VkDeviceMemory deviceMem;\n   45:     vk_call(vkAllocateMemory(device->getApiHandle(), &allocInfo, nullptr, &deviceMem));\n   46:     return deviceMem;\n   47  }\n   48  \n   49: void* mapBufferApi(Device::SharedPtr device, const Buffer::ApiHandle& apiHandle, size_t size) {\n   50      void* pData;\n   51:     vk_call(vkMapMemory(apiHandle.device()->getApiHandle(), apiHandle, 0, size, 0, &pData));\n   52      return pData;\n   53  }\n   ..\n   82  size_t getBufferDataAlignment(const Buffer* pBuffer) {\n   83      VkMemoryRequirements reqs;\n   84:     vkGetBufferMemoryRequirements(pBuffer->device()->getApiHandle(), pBuffer->getApiHandle(), &reqs);\n   85      return reqs.alignment;\n   86  }\n   87  \n   88: Buffer::ApiHandle createBuffer(Device::SharedPtr device, size_t size, Buffer::BindFlags bindFlags, GpuMemoryHeap::Type memType) {\n   89      VkBufferCreateInfo bufferInfo = {};\n   90      bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;\n   ..\n   97      \n   98      VkBuffer buffer;\n   99:     vk_call(vkCreateBuffer(device->getApiHandle(), &bufferInfo, nullptr, &buffer));\n  100  \n  101      // Get the required buffer size\n  102      VkMemoryRequirements reqs;\n  103:     vkGetBufferMemoryRequirements(device->getApiHandle(), buffer, &reqs);\n  104  \n  105:     VkDeviceMemory mem = allocateDeviceMemory(device, memType, reqs.memoryTypeBits, reqs.size);\n  106:     vk_call(vkBindBufferMemory(device->getApiHandle(), buffer, mem, 0));\n  107:     Buffer::ApiHandle apiHandle = Buffer::ApiHandle::create(device, buffer, mem);\n  108  \n  109      return apiHandle;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKComputeContext.cpp:\n   39  namespace Falcor {\n   40  \n   41:     ComputeContext::ComputeContext(std::shared_ptr<Device> device, LowLevelContextData::CommandQueueType type, CommandQueueHandle queue) : CopyContext(device, type, queue) {\n   42          assert(queue);\n   43      }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKCopyContext.cpp:\n  166      }\n  167  \n  168:     static void initTexAccessParams(std::shared_ptr<Device> device, const Texture* pTexture, uint32_t subresourceIndex, VkBufferImageCopy& vkCopy, Buffer::SharedPtr& pStaging, const void* pSrcData, const uint3& offset, const uint3& size, size_t& dataSize)\n  169      {\n  170          assert(isDepthStencilFormat(pTexture->getFormat()) == false); // #VKTODO Nothing complicated here, just that Vulkan doesn't support writing to both depth and stencil, which may be confusing to the user\n  ...\n  186  \n  187          // Upload the data to a staging buffer\n  188:         pStaging = Buffer::create(device, dataSize, Buffer::BindFlags::None, pSrcData ? Buffer::CpuAccess::Write : Buffer::CpuAccess::Read, pSrcData);\n  189          vkCopy.bufferOffset = pStaging->getGpuAddressOffset();\n  190      }\n  ...\n  195          Buffer::SharedPtr pStaging;\n  196          size_t dataSize;\n  197:         initTexAccessParams(pCtx->device(), pTexture, subresourceIndex, vkCopy, pStaging, pData, offset, size, dataSize);\n  198  \n  199          // Execute the copy\n  ...\n  226  \n  227          VkBufferImageCopy vkCopy;\n  228:         initTexAccessParams(pCtx->device(), pTexture, subresourceIndex, vkCopy, pThis->mpBuffer, nullptr, {}, uint3(-1, -1, -1), pThis->mDataSize);\n  229  \n  230          // Execute the copy\n  ...\n  234  \n  235          // Create a fence and signal\n  236:         pThis->mpFence = GpuFence::create(pCtx->device());\n  237          pCtx->flush(false);\n  238          pThis->mpFence->gpuSignal(pCtx->getLowLevelData()->getCommandQueue());\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKDescriptorData.h:\n   38  \n   39  struct DescriptorSetApiData {\n   40:     DescriptorSetApiData(Device::SharedPtr device, VkDescriptorSetLayout l, VkDescriptorPool p, VkDescriptorSet s) : layout(l), set(s), pool(p), mpDevice(device) {}\n   41      \n   42      VkDescriptorSetLayout layout;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKDescriptorSet.cpp:\n   47          allocInfo.descriptorSetCount = 1;\n   48          allocInfo.pSetLayouts = &layout;\n   49:         vk_call(vkAllocateDescriptorSets(mpPool->device()->getApiHandle(), &allocInfo, &mApiHandle));\n   50:         mpApiData = std::make_shared<DescriptorSetApiData>(mpPool->device(), layout, mpPool->getApiHandle(0), mApiHandle);\n   51      }\n   52  \n   ..\n   62  \n   63      template<bool isUav, typename ViewType>\n   64:     static void setSrvUavCommon(Device::SharedPtr device, VkDescriptorSet set, uint32_t bindIndex, uint32_t arrayIndex, const ViewType* pView, DescriptorPool::Type type) {\n   65          VkWriteDescriptorSet write = {};\n   66          VkDescriptorImageInfo image;\n   ..\n   95          write.descriptorCount = 1;\n   96  \n   97:         vkUpdateDescriptorSets(device->getApiHandle(), 1, &write, 0, nullptr);\n   98      }\n   99  \n  100      void DescriptorSet::setSrv(uint32_t rangeIndex, uint32_t descIndex, const ShaderResourceView* pSrv) {\n  101:         setSrvUavCommon<false>(mpPool->device(), mApiHandle, mLayout.getRange(rangeIndex).baseRegIndex, descIndex, pSrv, mLayout.getRange(rangeIndex).type);\n  102      }\n  103  \n  104      void DescriptorSet::setUav(uint32_t rangeIndex, uint32_t descIndex, const UnorderedAccessView* pUav) {\n  105:         setSrvUavCommon<true>(mpPool->device(), mApiHandle, mLayout.getRange(rangeIndex).baseRegIndex, descIndex, pUav, mLayout.getRange(rangeIndex).type);\n  106      }\n  107  \n  ...\n  121          write.pImageInfo = &info;\n  122  \n  123:         vkUpdateDescriptorSets(mpPool->device()->getApiHandle(), 1, &write, 0, nullptr);\n  124      }\n  125  \n  ...\n  141          write.descriptorCount = 1;\n  142          write.pBufferInfo = &info;\n  143:         vkUpdateDescriptorSets(mpPool->device()->getApiHandle(), 1, &write, 0, nullptr);\n  144      }\n  145  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKDevice.cpp:\n   61  #endif\n   62  \n   63: uint32_t getMaxViewportCount(std::shared_ptr<Device> device) {\n   64:     assert(device);\n   65:     return device->getPhysicalDeviceLimits().maxViewports;\n   66  }\n   67  \n   ..\n   71      uint32_t falcorToVulkanQueueType[Device::kQueueTypeCount];\n   72      uint32_t vkMemoryTypeBits[(uint32_t)Device::MemoryType::Count];\n   73:     VkPhysicalDeviceLimits deviceLimits;\n   74:     std::vector<VkExtensionProperties> deviceExtensions;\n   75  \n   76      struct {\n   ..\n   96  }\n   97  \n   98: static uint32_t getCurrentBackBufferIndex(VkDevice device, uint32_t backBufferCount, DeviceApiData* pApiData) {\n   99      VkFence fence = pApiData->presentFences.f[pApiData->presentFences.cur];\n  100:     vk_call(vkWaitForFences(device, 1, &fence, false, -1));\n  101  \n  102      pApiData->presentFences.cur = (pApiData->presentFences.cur + 1) % backBufferCount;\n  103      fence = pApiData->presentFences.f[pApiData->presentFences.cur];\n  104:     vkResetFences(device, 1, &fence);\n  105      uint32_t newIndex;\n  106:     vk_call(vkAcquireNextImageKHR(device, pApiData->swapchain, std::numeric_limits<uint64_t>::max(), nullptr, fence, &newIndex));\n  107      return newIndex;\n  108  }\n  ...\n  280  void Device::toggleFullScreen(bool fullscreen){}\n  281  \n  282: /** Select best physical device based on memory\n  283  */\n  284: VkPhysicalDevice selectPhysicalDevice(const std::vector<VkPhysicalDevice>& devices) {\n  285:     LOG_DBG(\"Selecting physical Vulkan device...\");\n  286      VkPhysicalDevice bestDevice = VK_NULL_HANDLE;\n  287      uint64_t bestMemory = 0;\n  288  \n  289:     for (const VkPhysicalDevice& device : devices) {\n  290          VkPhysicalDeviceMemoryProperties properties;\n  291:         vkGetPhysicalDeviceMemoryProperties(device, &properties);\n  292  \n  293:         // Get local memory size from device\n  294:         uint64_t deviceMemory = 0;\n  295          for (uint32_t i = 0; i < properties.memoryHeapCount; i++) {\n  296              if ((properties.memoryHeaps[i].flags & VK_MEMORY_HEAP_DEVICE_LOCAL_BIT) > 0) {\n  297:                 deviceMemory = properties.memoryHeaps[i].size;\n  298                  break;\n  299              }\n  ...\n  301  \n  302          // Save if best found so far\n  303:         if (bestDevice == VK_NULL_HANDLE || deviceMemory > bestMemory) {\n  304:             bestDevice = device;\n  305:             bestMemory = deviceMemory;\n  306          }\n  307      }\n  ...\n  310      vkGetPhysicalDeviceProperties(bestDevice, &pProperties);\n  311  \n  312:     LOG_DBG(\"Selected Vulkan physical device: %s\", pProperties.deviceName);\n  313      return bestDevice;\n  314  }\n  315  \n  316  VkPhysicalDevice initPhysicalDevice(VkInstance instance, DeviceApiData* pData, const Device::Desc& desc) {\n  317:     // Enumerate devices\n  318      uint32_t count = 0;\n  319      vkEnumeratePhysicalDevices(instance, &count, nullptr);\n  320      assert(count > 0);\n  321  \n  322:     std::vector<VkPhysicalDevice> devices(count);\n  323:     vkEnumeratePhysicalDevices(instance, &count, devices.data());\n  324  \n  325:     // Pick a device\n  326:     VkPhysicalDevice physicalDevice = selectPhysicalDevice(devices);\n  327      vkGetPhysicalDeviceProperties(physicalDevice, &pData->properties);\n  328:     pData->deviceLimits = pData->properties.limits;\n  329  \n  330:     // Check that the device/driver supports the requested API version\n  331      uint32_t vkApiVersion = VK_MAKE_VERSION(desc.apiMajorVersion, desc.apiMinorVersion, 0);\n  332      if (vkApiVersion != 0 && pData->properties.apiVersion < vkApiVersion) {\n  333          std::string reqVerStr = std::to_string(desc.apiMajorVersion) + \".\" + std::to_string(desc.apiMinorVersion);\n  334          std::string supportedStr = std::to_string(VK_VERSION_MAJOR(pData->properties.apiVersion)) + \".\" + std::to_string(VK_VERSION_MINOR(pData->properties.apiVersion));\n  335:         logError(\"Vulkan device does not support requested API version. Requested version: \" + reqVerStr + \", Highest supported: \" + supportedStr);\n  336          return nullptr;\n  337      }\n  ...\n  376          const uint32_t queueCount = desc.cmdQueues[type];\n  377          queuePriorities[type].resize(queueCount, 1.0f); // Setting all priority at max for now\n  378:         cmdQueues[type].resize(queueCount); // Save how many queues of each type there will be so we can retrieve them easier after device creation\n  379  \n  380          VkDeviceQueueCreateInfo info = {};\n  ...\n  403      uint32_t extensionCount = 0;\n  404      vkEnumerateDeviceExtensionProperties(physicalDevice, nullptr, &extensionCount, nullptr);\n  405:     pData->deviceExtensions.resize(extensionCount);\n  406:     vkEnumerateDeviceExtensionProperties(physicalDevice, nullptr, &extensionCount, pData->deviceExtensions.data());\n  407  \n  408:     for (const VkExtensionProperties& extension : pData->deviceExtensions) {\n  409          logInfo(\"Available Device Extension: \" + std::string(extension.extensionName) + \" - VK Spec Version: \" + std::to_string(extension.specVersion));\n  410      }\n  411  \n  412      std::vector<const char*> extensionNames = { \"VK_KHR_swapchain\" };\n  413:     assert(isExtensionSupported(extensionNames[0], pData->deviceExtensions));\n  414  \n  415      for (const auto& a : desc.requiredExtensions) {\n  416:         if (isExtensionSupported(a, pData->deviceExtensions)) {\n  417              extensionNames.push_back(a.c_str());\n  418          } else {\n  419:             logWarning(\"The device doesn't support the requested '\" + a + \"` extension\");\n  420          }\n  421      }\n  422  \n  423      // Logical Device\n  424:     VkDeviceCreateInfo deviceInfo = {};\n  425:     deviceInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;\n  426:     deviceInfo.queueCreateInfoCount = (uint32_t)queueInfos.size();\n  427:     deviceInfo.pQueueCreateInfos = queueInfos.data();\n  428:     deviceInfo.enabledExtensionCount = (uint32_t)extensionNames.size();\n  429:     deviceInfo.ppEnabledExtensionNames = extensionNames.data();\n  430:     deviceInfo.pEnabledFeatures = &requiredFeatures;\n  431  \n  432:     VkDevice device;\n  433:     if (VK_FAILED(vkCreateDevice(physicalDevice, &deviceInfo, nullptr, &device))) {\n  434:         logError(\"Could not create Vulkan logical device.\");\n  435          return nullptr;\n  436      }\n  ...\n  439      for (uint32_t type = 0; type < arraysize(pData->falcorToVulkanQueueType); type++) {\n  440          for (uint32_t i = 0; i < (uint32_t)cmdQueues[type].size(); i++) {\n  441:             vkGetDeviceQueue(device, pData->falcorToVulkanQueueType[type], i, &cmdQueues[type][i]);\n  442          }\n  443      }\n  444  \n  445:     return device;\n  446  }\n  447  \n  ...\n  592  \n  593  /**\n  594:  * Initialize swapchain enabled vulkan device\n  595   */\n  596  bool Device::apiInit() {\n  ...\n  607      if (!surface) return false;\n  608      \n  609:     VkDevice device = createLogicalDevice(physicalDevice, mpApiData, desc, mCmdQueues);\n  610:     if (!device) return false;\n  611      \n  612      if (initMemoryTypes(physicalDevice, mpApiData) == false) return false;\n  613  \n  614:     mApiHandle = DeviceHandle::create(SharedPtr(this), instance, physicalDevice, device, surface);\n  615      mGpuTimestampFrequency = getPhysicalDeviceLimits().timestampPeriod / (1000 * 1000);\n  616:     mPhysicalDeviceName = std::string(mpApiData->properties.deviceName);\n  617  \n  618      if(!headless) {\n  ...\n  625              VkFenceCreateInfo info = { VK_STRUCTURE_TYPE_FENCE_CREATE_INFO };\n  626              info.flags = VK_FENCE_CREATE_SIGNALED_BIT;\n  627:             vk_call(vkCreateFence(device, &info, nullptr, &f));\n  628          }\n  629      } else {\n  ...\n  656  bool Device::isExtensionSupported(const std::string& name) const\n  657  {\n  658:     //return Falcor::isExtensionSupported(name, mpApiData->deviceExtensions);\n  659      return true;\n  660  }\n  ...\n  672  \n  673  const VkPhysicalDeviceLimits& Device::getPhysicalDeviceLimits() const {\n  674:     return mpApiData->deviceLimits;\n  675  }\n  676  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKFbo.cpp:\n   36  namespace Falcor {\n   37  \n   38: Fbo::Fbo(std::shared_ptr<Device> device): mpDevice(device), mTempDesc(device) {\n   39:     mColorAttachments.resize(getMaxColorTargetCount(device));\n   40  }\n   41  \n   ..\n   49  }\n   50  \n   51: uint32_t Fbo::getMaxColorTargetCount(std::shared_ptr<Device> device) {\n   52:     int count =device->getPhysicalDeviceLimits().maxFragmentOutputAttachments;\n   53      return count;\n   54  }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKFormats.cpp:\n  112      };\n  113  \n  114:     ResourceBindFlags getFormatBindFlags(Device::SharedPtr device, ResourceFormat format) {\n  115          VkFormatProperties p;\n  116:         vkGetPhysicalDeviceFormatProperties(device->getApiHandle(), getVkFormat(format), &p);\n  117  \n  118          auto convertFlags = [](VkFormatFeatureFlags vk) -> ResourceBindFlags\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKGpuFence.cpp:\n   36  \n   37      // #VKTODO This entire class seems overly complicated. Need to make sure that there are no performance issues\n   38:     VkFence createFence(std::shared_ptr<Device> device) {\n   39          VkFenceCreateInfo info = {};\n   40          info.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;\n   41          VkFence fence;\n   42:         vkCreateFence(device->getApiHandle(), &info, nullptr, &fence);\n   43          return fence;\n   44      }\n   45  \n   46:     void destroyFence(std::shared_ptr<Device> device, VkFence fence) {\n   47:         vkDestroyFence(device->getApiHandle(), fence, nullptr);\n   48      }\n   49  \n   50:     void resetFence(std::shared_ptr<Device> device, VkFence fence) {\n   51:         vkResetFences(device->getApiHandle(), 1, &fence);\n   52      }\n   53  \n   54:     VkSemaphore createSemaphore(std::shared_ptr<Device> device) {\n   55          VkSemaphoreCreateInfo semaphoreInfo = {};\n   56          semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;\n   57          VkSemaphore sem;\n   58:         vkCreateSemaphore(device->getApiHandle(), &semaphoreInfo, nullptr, &sem);\n   59          return sem;\n   60      };\n   61  \n   62:     void destroySemaphore(std::shared_ptr<Device> device, VkSemaphore semaphore) {\n   63:         vkDestroySemaphore(device->getApiHandle(), semaphore, nullptr);\n   64      }\n   65  \n   66      struct FenceApiData {\n   67:         FenceApiData(std::shared_ptr<Device> device) { \n   68:             fenceQueue =  std::make_unique<SmartQueue<VkFence, createFence, destroyFence, resetFence>>(device);\n   69:             semaphoreQueue = std::make_unique<SmartQueue<VkSemaphore, createSemaphore, destroySemaphore, nullptr>>(device);\n   70          }\n   71  \n   ..\n   73          class SmartQueue {\n   74           public:\n   75:             SmartQueue(std::shared_ptr<Device> device) { mpDevice = device; }\n   76              ~SmartQueue() {\n   77                  popAllObjects();\n   ..\n  133      }\n  134  \n  135:     GpuFence::SharedPtr GpuFence::create(std::shared_ptr<Device> device) {\n  136:         SharedPtr pFence = SharedPtr(new GpuFence(device));\n  137:         pFence->mpApiData = new FenceApiData(device);\n  138          pFence->mCpuValue = 1;\n  139          return pFence;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VkGpuMemoryHeap.cpp:\n   33  namespace Falcor {\n   34  \n   35: Buffer::ApiHandle createBuffer(std::shared_ptr<Device> device, size_t size, Buffer::BindFlags bindFlags, GpuMemoryHeap::Type memType);\n   36  \n   37  void GpuMemoryHeap::initBasePageData(BaseData& data, size_t size) {\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKLowLevelContextData.cpp:\n   39      };\n   40  \n   41:     VkCommandBuffer createCommandBuffer(std::shared_ptr<Device> device, void* pUserData)\n   42      {\n   43          LowLevelContextData* pThis = (LowLevelContextData*)pUserData;\n   ..\n   48          cmdBufAllocateInfo.commandBufferCount = 1;\n   49          VkCommandBuffer cmdBuf;\n   50:         vk_call(vkAllocateCommandBuffers(device->getApiHandle(), &cmdBufAllocateInfo, &cmdBuf));\n   51          return cmdBuf;\n   52      }\n   ..\n   63      }\n   64  \n   65:     LowLevelContextData::LowLevelContextData(std::shared_ptr<Device> device, CommandQueueType type, CommandQueueHandle queue): mType(type), mpQueue(queue), mpDevice(device)\n   66      {\n   67  \n   68      }\n   69  \n   70:     LowLevelContextData::SharedPtr LowLevelContextData::create(std::shared_ptr<Device> device, LowLevelContextData::CommandQueueType type, CommandQueueHandle queue) {\n   71:         SharedPtr pThis = SharedPtr(new LowLevelContextData(device, type, queue));\n   72          pThis->mType = type;\n   73:         pThis->mpFence = GpuFence::create(device);\n   74          pThis->mpQueue = queue;\n   75  \n   ..\n   77          commandPoolCreateInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;\n   78          commandPoolCreateInfo.flags = VK_COMMAND_POOL_CREATE_TRANSIENT_BIT | VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;\n   79:         commandPoolCreateInfo.queueFamilyIndex = device->getApiCommandQueueType(type);\n   80          VkCommandPool pool;\n   81:         if (VK_FAILED(vkCreateCommandPool(device->getApiHandle(), &commandPoolCreateInfo, nullptr, &pool)))\n   82          {\n   83              logError(\"Could not create command pool\");\n   84              return nullptr;\n   85          }\n   86:         pThis->mpAllocator = CommandAllocatorHandle::create(device, pool);\n   87          pThis->mpApiData = new LowLevelContextApiData;\n   88:         pThis->mpApiData->pCmdBufferAllocator = FencedPool<VkCommandBuffer>::create(device, pThis->mpFence, createCommandBuffer, pThis.get());\n   89          pThis->mpList = pThis->mpApiData->pCmdBufferAllocator->newObject();\n   90          initCommandList(pThis->mpApiData, pThis->mpList);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VkQueryHeap.cpp:\n   46  }\n   47  \n   48: QueryHeap::QueryHeap(std::shared_ptr<Device> device, Type type, uint32_t count) : mType(type), mCount(count) {\n   49      VkQueryPoolCreateInfo info = {};\n   50      info.sType = VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO;\n   ..\n   53      info.pipelineStatistics = VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM;\n   54      VkQueryPool pool;\n   55:     vk_call(vkCreateQueryPool(device->getApiHandle(), &info, nullptr, &pool));\n   56:     mApiHandle = ApiHandle::create(device, pool);\n   57  }\n   58  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKRenderContext.cpp:\n   39      VkImageLayout getImageLayout(Resource::State state);\n   40  \n   41:     RenderContext::RenderContext(std::shared_ptr<Device> device, CommandQueueHandle queue)\n   42:         : ComputeContext(device, LowLevelContextData::CommandQueueType::Direct, queue)\n   43      {\n   44      }\n   ..\n  152      static void transitionFboResources(RenderContext* pCtx, const Fbo* pFbo) {\n  153          // We are setting the entire RTV array to make sure everything that was previously bound is detached\n  154:         uint32_t colorTargets = Fbo::getMaxColorTargetCount(pCtx->device());\n  155  \n  156          if (pFbo) {\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKResourceViews.cpp:\n   44  template<typename ApiHandleType>\n   45  ResourceView<ApiHandleType>::~ResourceView() {\n   46:     getResource()->device()->releaseResource(mApiHandle);\n   47  }\n   48  \n   49: Texture::SharedPtr createBlackTexture(Device::SharedPtr device) {\n   50      uint8_t blackPixel[4] = { 0 };\n   51:     return Texture::create2D(device, 1, 1, ResourceFormat::RGBA8Unorm, 1, 1, blackPixel, Resource::BindFlags::ShaderResource | Resource::BindFlags::RenderTarget | Resource::BindFlags::UnorderedAccess);\n   52  }\n   53  \n   54: Buffer::SharedPtr createZeroBuffer(Device::SharedPtr device) {\n   55      static const uint32_t zero = 0;\n   56:     return Buffer::create(device, sizeof(uint32_t), Resource::BindFlags::UnorderedAccess, Buffer::CpuAccess::None, &zero);\n   57  }\n   58  \n   59: Buffer::SharedPtr createZeroTypedBuffer(Device::SharedPtr device) {\n   60      static const uint32_t zero = 0;\n   61:     return Buffer::createTyped<uint32_t>(device, 1, Resource::BindFlags::UnorderedAccess, Buffer::CpuAccess::None, &zero);\n   62  }\n   63  \n   64: Texture::SharedPtr getEmptyTexture(Device::SharedPtr device) {\n   65:     static Texture::SharedPtr sBlackTexture = createBlackTexture(device);\n   66      return sBlackTexture;\n   67  }\n   68  \n   69: Buffer::SharedPtr getEmptyBuffer(Device::SharedPtr device) {\n   70:     static Buffer::SharedPtr sZeroBuffer = createZeroBuffer(device);\n   71      return sZeroBuffer;\n   72  }\n   73  \n   74: Buffer::SharedPtr getEmptyTypedBuffer(Device::SharedPtr device) {\n   75:     static Buffer::SharedPtr sZeroTypedBuffer = createZeroTypedBuffer(device);\n   76      return sZeroTypedBuffer;\n   77  }\n   ..\n  141              VkImageViewCreateInfo info = initializeImageViewInfo((const Texture*)pResource, mostDetailedMip, mipCount, firstArraySlice, arraySize);\n  142              VkImageView imageView;\n  143:             vk_call(vkCreateImageView(pResource->device()->getApiHandle(), &info, nullptr, &imageView));\n  144:             return VkResource<VkImageView, VkBufferView>::SharedPtr::create(pResource->device(), imageView, nullptr);\n  145          }\n  146  \n  ...\n  152              if (pBuffer->isTyped()) {\n  153                  VkBufferViewCreateInfo info = initializeBufferViewInfo(pBuffer);\n  154:                 vk_call(vkCreateBufferView(pResource->device()->getApiHandle(), &info, nullptr, &bufferView));\n  155              }\n  156  \n  157:             return VkResource<VkImageView, VkBufferView>::SharedPtr::create(pResource->device(), bufferView, nullptr);\n  158          }\n  159  \n  ...\n  181      if (!pBuffer) {\n  182          VkBufferView bufferView = {};\n  183:         auto view = VkResource<VkImageView, VkBufferView>::SharedPtr::create(pBuffer.get()->device(), bufferView, nullptr);\n  184          return SharedPtr(new ShaderResourceView(pBuffer, view, firstElement, elementCount));\n  185      }\n  ...\n  199      if (buffer->isTyped()) {\n  200          VkBufferViewCreateInfo info = initializeBufferViewInfo(buffer);\n  201:         vk_call(vkCreateBufferView(pBuffer->device()->getApiHandle(), &info, nullptr, &bufferView));\n  202      }\n  203  \n  204:     auto view = VkResource<VkImageView, VkBufferView>::SharedPtr::create(pBuffer.get()->device(), bufferView, nullptr);\n  205  \n  206      return SharedPtr(new ShaderResourceView(pBuffer, view, firstElement, elementCount));\n  ...\n  243      if (!pBuffer) {\n  244          VkBufferView bufferView = {};\n  245:         auto view = VkResource<VkImageView, VkBufferView>::SharedPtr::create(pBuffer.get()->device(), bufferView, nullptr);\n  246          return SharedPtr(new UnorderedAccessView(pBuffer, view, firstElement, elementCount));\n  247      }\n  ...\n  261      if (buffer->isTyped()) {\n  262          VkBufferViewCreateInfo info = initializeBufferViewInfo(buffer);\n  263:         vk_call(vkCreateBufferView(pBuffer->device()->getApiHandle(), &info, nullptr, &bufferView));\n  264      }\n  265  \n  266:     auto view = VkResource<VkImageView, VkBufferView>::SharedPtr::create(pBuffer.get()->device(), bufferView, nullptr);\n  267      return SharedPtr(new UnorderedAccessView(pBuffer, view, firstElement, elementCount));\n  268  }\n  ...\n  291  \n  292      VkBufferView bufferView = {};\n  293:     auto handle = VkResource<VkImageView, VkBufferView>::SharedPtr::create(pBuffer.get()->device(), bufferView, nullptr);\n  294  \n  295  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKSampler.cpp:\n   33  namespace Falcor {\n   34  \n   35: uint32_t Sampler::getApiMaxAnisotropy(std::shared_ptr<Device> device) {\n   36:     return (uint32_t)device->getPhysicalDeviceLimits().maxSamplerAnisotropy;\n   37  }\n   38  \n   39: Sampler::SharedPtr Sampler::create(std::shared_ptr<Device> device, const Desc& desc) {\n   40:     SharedPtr pSampler = SharedPtr(new Sampler(device, desc));\n   41  \n   42      VkSamplerCreateInfo info;\n   43      initVkSamplerInfo(pSampler.get(), info);\n   44      VkSampler handle;\n   45:     vk_call(vkCreateSampler(device->getApiHandle(), &info, nullptr, &handle));\n   46:     pSampler->mApiHandle = ApiHandle::create(device, handle);\n   47      return pSampler;\n   48  }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKShader.cpp:\n   32  namespace Falcor {\n   33  \n   34:     Shader::Shader(std::shared_ptr<Device> device, ShaderType type) : mType(type), mpDevice(device) {}\n   35  \n   36      Shader::~Shader() = default;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKSmartHandle.h:\n   44      virtual ~VkBaseApiHandle() = default;\n   45  \n   46:     Device::SharedPtr device() { return mpDevice; }\n   47  \n   48   protected:\n   49:     VkBaseApiHandle(std::shared_ptr<Device> device) { mpDevice = device; }\n   50  \n   51   protected:\n   ..\n   60          SharedPtr() = default;\n   61          explicit SharedPtr(VkHandle<ApiHandle>* pHandle) : std::shared_ptr<VkHandle<ApiHandle>>(pHandle) {}\n   62:         static SharedPtr create(std::shared_ptr<Device> device, ApiHandle handle) { return SharedPtr(new VkHandle(device, handle)); }\n   63          operator ApiHandle() const { return get()->mApiHandle; }\n   64       private:\n   ..\n   73   private:\n   74      friend class SharedPtr;\n   75:     explicit VkHandle(std::shared_ptr<Device> device, const ApiHandle& apiHandle) : VkBaseApiHandle(device), mApiHandle(apiHandle) {}\n   76      ApiHandle mApiHandle;\n   77  };\n   ..\n   83          SharedPtr() = default;\n   84          explicit SharedPtr(VkRootSignature* pHandle) : std::shared_ptr<VkRootSignature>(pHandle) {}\n   85:         static SharedPtr create(std::shared_ptr<Device> device, VkPipelineLayout layout, const std::vector<VkDescriptorSetLayout>& sets) { return SharedPtr(new VkRootSignature(device ,layout, sets)); }\n   86          operator VkPipelineLayout() const { return get()->mApiHandle; }\n   87  \n   ..\n   94   private:\n   95      friend class SharedPtr;\n   96:     VkRootSignature(std::shared_ptr<Device> device, VkPipelineLayout layout, const std::vector<VkDescriptorSetLayout>& sets) : VkBaseApiHandle(device), mApiHandle(layout), mSets(sets) {}\n   97      VkPipelineLayout mApiHandle;\n   98      std::vector<VkDescriptorSetLayout> mSets;\n   ..\n  105          SharedPtr() = default;\n  106          explicit SharedPtr(VkDeviceData* pData) : std::shared_ptr<VkDeviceData>(pData) {}\n  107:         static SharedPtr create(std::shared_ptr<Device> device, VkInstance instance, VkPhysicalDevice physicalDevice, VkDevice vkdevice, VkSurfaceKHR surface) {\n  108:             return SharedPtr(new VkDeviceData(device, instance, physicalDevice, vkdevice, surface));\n  109          }\n  110  \n  ...\n  122   private:\n  123      friend SharedPtr;\n  124:     VkDeviceData(std::shared_ptr<Device> device, VkInstance instance, VkPhysicalDevice physicalDevice, VkDevice vkdevice, VkSurfaceKHR surface) :\n  125:         VkBaseApiHandle(device), mInstance(instance), mPhysicalDevice(physicalDevice), mLogicalDevice(vkdevice), mSurface(surface) {}\n  126      VkInstance          mInstance;\n  127      VkPhysicalDevice    mPhysicalDevice;\n  ...\n  144          explicit SharedPtr(VkResource<ImageType, BufferType>* pRes) : std::shared_ptr<VkResource<ImageType, BufferType>>(pRes) {}\n  145  \n  146:         static SharedPtr create(std::shared_ptr<Device> device, ImageType image, VkDeviceMemory mem) {\n  147:             return SharedPtr(new VkResource<ImageType, BufferType>(device, image, mem));\n  148          }\n  149  \n  150:         static SharedPtr create(std::shared_ptr<Device> device, BufferType buffer, VkDeviceMemory mem) {\n  151:             return SharedPtr(new VkResource<ImageType, BufferType>(device, buffer, mem));\n  152          }\n  153  \n  ...\n  172   private:\n  173      friend SharedPtr;\n  174:     VkResource(std::shared_ptr<Device> device, ImageType image, VkDeviceMemory mem) : VkBaseApiHandle(device), mType(VkResourceType::Image), mImage(image), mDeviceMem(mem) { }\n  175      \n  176:     VkResource(std::shared_ptr<Device> device, BufferType buffer, VkDeviceMemory mem) : VkBaseApiHandle(device), mType(VkResourceType::Buffer), mBuffer(buffer), mDeviceMem(mem) { }\n  177  \n  178      VkResourceType mType = VkResourceType::None;\n  ...\n  188          SharedPtr() = default;\n  189          explicit SharedPtr(VkFbo* pFbo) : std::shared_ptr<VkFbo>(pFbo) {}\n  190:         static SharedPtr create(std::shared_ptr<Device> device, VkRenderPass renderPass, VkFramebuffer fbo) { return SharedPtr(new VkFbo(device, renderPass, fbo)); }\n  191  \n  192          operator VkFramebuffer() const { return get()->mVkFbo; }\n  ...\n  203   private:\n  204      friend SharedPtr;\n  205:     VkFbo(std::shared_ptr<Device> device, VkRenderPass renderPass, VkFramebuffer fbo) : VkBaseApiHandle(device), mVkRenderPass(renderPass), mVkFbo(fbo) {}\n  206      VkRenderPass mVkRenderPass = VK_NULL_HANDLE;\n  207      VkFramebuffer mVkFbo = VK_NULL_HANDLE;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKState.cpp:\n  161  \n  162      static bool hasColorAttachments(const Fbo::Desc& fboDesc) {\n  163:         for (uint32_t i = 0; i < Fbo::getMaxColorTargetCount(fboDesc.device()); i++) {\n  164              if (fboDesc.getColorTargetFormat(i) != ResourceFormat::Unknown) return true;\n  165          }\n  ...\n  498      void initVkRenderPassInfo(const Fbo::Desc& fboDesc, RenderPassCreateInfo& infoOut) {\n  499          // Init Color and Depth Attachment Info\n  500:         infoOut.attachmentDescs.resize(Fbo::getMaxColorTargetCount(fboDesc.device()) + 1); // Color + Depth\n  501          std::vector<uint32_t> regToAttachmentIndex(infoOut.attachmentDescs.size(), VK_ATTACHMENT_UNUSED);\n  502          uint32_t rtCount = 0;\n  503  \n  504          // Color attachments. We're only attaching textures which are actually bound (non-null)\n  505:         for (uint32_t i = 0; i < Fbo::getMaxColorTargetCount(fboDesc.device()); i++) {\n  506              ResourceFormat format = fboDesc.getColorTargetFormat(i);\n  507              if(format != ResourceFormat::Unknown) {\n  ...\n  560          if(hasColor) {\n  561              // Color attachments. This is where we create the indirection between the attachment in the RenderPass and the shader output-register index\n  562:             for (size_t i = 0; i < Fbo::getMaxColorTargetCount(fboDesc.device()); i++) {\n  563                  VkAttachmentReference& ref = infoOut.attachmentRefs[i];\n  564                  ref.attachment = regToAttachmentIndex[i];\n  ...\n  566              }\n  567  \n  568:             subpassDesc.colorAttachmentCount = Fbo::getMaxColorTargetCount(fboDesc.device());\n  569              subpassDesc.pColorAttachments = infoOut.attachmentRefs.data();\n  570          }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKTexture.cpp:\n  105      }\n  106  \n  107:     static VkImageTiling getFormatImageTiling(std::shared_ptr<Device> device, VkFormat format, VkImageUsageFlags usage) {\n  108          VkFormatProperties p;\n  109:         vkGetPhysicalDeviceFormatProperties(device->getApiHandle(), format, &p);\n  110          auto featureBits = getFormatFeatureBitsFromUsage(usage);\n  111          if ((p.optimalTilingFeatures & featureBits) == featureBits) return VK_IMAGE_TILING_OPTIMAL;\n  ...\n  152          VkMemoryRequirements memRequirements;\n  153          vkGetImageMemoryRequirements(mpDevice->getApiHandle(), image, &memRequirements);\n  154:         VkDeviceMemory deviceMem = allocateDeviceMemory(Device::MemoryType::Default, memRequirements.memoryTypeBits, memRequirements.size);\n  155:         vkBindImageMemory(mpDevice->getApiHandle(), image, deviceMem, 0);\n  156:         mApiHandle = ApiHandle::create(mpDevice, image, deviceMem);\n  157    \n  158          if (pData != nullptr) {\n\n/home/max/dev/Falcor/src/Falcor/Core/BufferTypes/ParameterBlock.cpp:\n  230  ParameterBlock::~ParameterBlock() = default;\n  231  \n  232: ParameterBlock::SharedPtr ParameterBlock::create(std::shared_ptr<Device> device, const std::shared_ptr<const ProgramVersion>& pProgramVersion, const ReflectionType::SharedConstPtr& pElementType) {\n  233      if (!pElementType) {\n  234          throw std::runtime_error(\"Can't create a parameter block without type information\");\n  235      }\n  236      auto pReflection = ParameterBlockReflection::create(pProgramVersion.get(), pElementType);\n  237:     return create(device, pReflection);\n  238  }\n  239  \n  240: ParameterBlock::SharedPtr ParameterBlock::create(std::shared_ptr<Device> device, const ParameterBlockReflection::SharedConstPtr& pReflection) {\n  241      assert(pReflection);\n  242:     return SharedPtr(new ParameterBlock(device, pReflection->getProgramVersion(), pReflection));\n  243  }\n  244  \n  245: ParameterBlock::SharedPtr ParameterBlock::create(std::shared_ptr<Device> device, const std::shared_ptr<const ProgramVersion>& pProgramVersion, const std::string& typeName) {\n  246      assert(pProgramVersion);\n  247:     return ParameterBlock::create(device, pProgramVersion, pProgramVersion->getReflector()->findType(typeName));\n  248  }\n  249  \n  250: ParameterBlock::ParameterBlock(std::shared_ptr<Device> device, const std::shared_ptr<const ProgramVersion>& pProgramVersion, const ParameterBlockReflection::SharedConstPtr& pReflection)\n  251      : mpReflector(pReflection)\n  252      , mpProgramVersion(pProgramVersion)\n  253      , mData(pReflection->getElementType()->getByteSize(), 0) \n  254:     , mpDevice(device) {\n  255  \n  256      ReflectionStructType::BuildState state;\n\n/home/max/dev/Falcor/src/Falcor/Core/BufferTypes/ParameterBlock.h:\n  106      /** Create a new object that holds a value of the given type.\n  107      */\n  108:     static SharedPtr create(std::shared_ptr<Device> device, const std::shared_ptr<const ProgramVersion>& pProgramVersion, const ReflectionType::SharedConstPtr& pType);\n  109  \n  110      /** Create a new object that holds a value described by the given reflector.\n  111      */\n  112:     static SharedPtr create(std::shared_ptr<Device> device, const ParameterBlockReflection::SharedConstPtr& pReflection);\n  113  \n  114      /** Create a new object that holds a value of the type with the given name in the given program.\n  ...\n  116          \\param[in] typeName Name of the type. If the type does not exist an exception is thrown.\n  117      */\n  118:     static SharedPtr create(std::shared_ptr<Device> device, const std::shared_ptr<const ProgramVersion>& pProgramVersion, const std::string& typeName);\n  119  \n  120      /** Set a variable into the block.\n  ...\n  343      std::shared_ptr<Device>  mpDevice;\n  344  \n  345:     ParameterBlock(std::shared_ptr<Device> device, const std::shared_ptr<const ProgramVersion>& pProgramVersion, const ParameterBlockReflection::SharedConstPtr& pReflection);\n  346  \n  347      std::shared_ptr<const ProgramVersion> mpProgramVersion;\n\n/home/max/dev/Falcor/src/Falcor/Core/Platform/MonitorInfo.cpp:\n   84              NULL, //HWND\n   85              DIGCF_PRESENT, // Flags //DIGCF_ALLCLASSES|\n   86:             NULL, // device info, create a new one.\n   87              NULL, // machine name, local machine\n   88              NULL);// reserved\n   ..\n  133          DISPLAY_DEVICE dd;\n  134          dd.cb = sizeof(dd);\n  135:         DWORD devIdx = 0; // device index\n  136  \n  137          bool bFoundDevice = false;\n\n/home/max/dev/Falcor/src/Falcor/Core/Platform/Windows/ProgressBarWin.cpp:\n   36      {\n   37          HWND hwnd;\n   38:         std::random_device rd;\n   39          std::mt19937 rng;\n   40          std::uniform_int_distribution<int> dist;\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ComputeProgram.cpp:\n   31  namespace Falcor {\n   32  \n   33:     ComputeProgram::SharedPtr ComputeProgram::createFromFile(std::shared_ptr<Device> device, const std::string& filename, const std::string& csEntry, const DefineList& programDefines, Shader::CompilerFlags flags, const std::string& shaderModel) {\n   34          Desc d(filename);\n   35          if (!shaderModel.empty()) d.setShaderModel(shaderModel);\n   36          d.setCompilerFlags(flags);\n   37          d.csEntry(csEntry);\n   38:         return create(device, d, programDefines);\n   39      }\n   40  \n   41:     ComputeProgram::SharedPtr ComputeProgram::create(std::shared_ptr<Device> device, const Program::Desc& desc, const DefineList& programDefines) {\n   42          SharedPtr pProg = SharedPtr(new ComputeProgram);\n   43:         pProg->init(device, desc, programDefines);\n   44          return pProg;\n   45      }\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ComputeProgram.h:\n   55          \\return A new object, or an exception is thrown if creation failed.\n   56      */\n   57:     static SharedPtr createFromFile(std::shared_ptr<Device> device, const std::string& filename, const std::string& csEntry, const DefineList& programDefines = DefineList(), Shader::CompilerFlags flags = Shader::CompilerFlags::None, const std::string& shaderModel = \"\");\n   58  \n   59      /** Create a new compute program.\n   ..\n   63          \\return A new object, or an exception is thrown if creation failed.\n   64      */\n   65:     static SharedPtr create(std::shared_ptr<Device> device, const Program::Desc& desc, const DefineList& programDefines = DefineList());\n   66  \n   67   private:\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/GraphicsProgram.cpp:\n   31  namespace Falcor {\n   32  \n   33:     GraphicsProgram::SharedPtr GraphicsProgram::create(std::shared_ptr<Device> device, const Desc& desc, const Program::DefineList& programDefines) {\n   34          SharedPtr pProg = SharedPtr(new GraphicsProgram);\n   35          Desc d = desc;\n   36          d.addDefaultVertexShaderIfNeeded();\n   37:         pProg->init(device, d, programDefines);\n   38          return pProg;\n   39      }\n   40  \n   41:     GraphicsProgram::SharedPtr GraphicsProgram::createFromFile(std::shared_ptr<Device> device, const std::string& filename, const std::string& vsEntry, const std::string& psEntry, const DefineList& programDefines) {\n   42          Desc d(filename);\n   43          d.vsEntry(vsEntry).psEntry(psEntry).addDefaultVertexShaderIfNeeded();\n   44:         return create(device, d, programDefines);\n   45      }\n   46  \n\n/home/max/dev/Falcor/src/Falcor/Core/Program/GraphicsProgram.h:\n   52          \\return A new object, or an exception is thrown if creation failed.\n   53      */\n   54:     static SharedPtr create(std::shared_ptr<Device> device, const Desc& desc, const Program::DefineList& programDefines = DefineList());\n   55  \n   56      /** Create a new graphics program from file.\n   ..\n   61          \\return A new object, or an exception is thrown if creation failed.\n   62      */\n   63:     static SharedPtr createFromFile(std::shared_ptr<Device> device, const std::string& filename, const std::string& vsEntry, const std::string& psEntry, const DefineList& programDefines = DefineList());\n   64  \n   65   private:\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/Program.cpp:\n   41  static Program::DefineList sGlobalDefineList;\n   42  \n   43: static Shader::SharedPtr createShaderFromBlob(std::shared_ptr<Device> device, const Shader::Blob& shaderBlob, ShaderType shaderType, const std::string& entryPointName, Shader::CompilerFlags flags, std::string& log) {\n   44      std::string errorMsg;\n   45:     auto pShader = Shader::create(device, shaderBlob, shaderType, entryPointName, flags, log);\n   46      return pShader;\n   47  }\n   ..\n  151  std::vector<std::weak_ptr<Program>> Program::sPrograms;\n  152  \n  153: void Program::init(std::shared_ptr<Device> device, Desc const& desc, DefineList const& defineList) {\n  154      mDesc = desc;\n  155      mDefineList = defineList;\n  156:     mpDevice = device;\n  157  \n  158      sPrograms.push_back(shared_from_this());\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/Program.h:\n  245      Program() = default;\n  246  \n  247:     void init(std::shared_ptr<Device> device, Desc const& desc, DefineList const& programDefines);\n  248  \n  249      bool link() const;\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramVars.cpp:\n   55      }\n   56  \n   57:     ProgramVars::ProgramVars(std::shared_ptr<Device> device, const ProgramReflection::SharedConstPtr& pReflector)\n   58:         : ParameterBlock(device, pReflector->getProgramVersion(), pReflector->getDefaultParameterBlock())\n   59          , mpReflector(pReflector)\n   60      {\n   ..\n   73      }\n   74  \n   75:     GraphicsVars::GraphicsVars(std::shared_ptr<Device> device, const ProgramReflection::SharedConstPtr& pReflector)\n   76:         : ProgramVars(device, pReflector)\n   77      {\n   78          addSimpleEntryPointGroups();\n   79      }\n   80  \n   81:     GraphicsVars::SharedPtr GraphicsVars::create(std::shared_ptr<Device> device, const ProgramReflection::SharedConstPtr& pReflector) {\n   82          if (pReflector == nullptr) {\n   83              throw std::runtime_error(\"Can't create a GraphicsVars object without a program reflector\");\n   84          }\n   85:         return SharedPtr(new GraphicsVars(device, pReflector));\n   86      }\n   87  \n   88:     GraphicsVars::SharedPtr GraphicsVars::create(std::shared_ptr<Device> device, const GraphicsProgram* pProg) {\n   89          if (pProg == nullptr) {\n   90              throw std::runtime_error(\"Can't create a GraphicsVars object without a program\");\n   91          }\n   92:         return create(device, pProg->getReflector());\n   93      }\n   94  \n   95:     ComputeVars::SharedPtr ComputeVars::create(std::shared_ptr<Device> device, const ProgramReflection::SharedConstPtr& pReflector) {\n   96          if (pReflector == nullptr) {\n   97              throw std::runtime_error(\"Can't create a ComputeVars object without a program reflector\");\n   98          }\n   99:         return SharedPtr(new ComputeVars(device, pReflector));\n  100      }\n  101  \n  102:     ComputeVars::SharedPtr ComputeVars::create(std::shared_ptr<Device> device, const ComputeProgram* pProg) {\n  103          if (pProg == nullptr) {\n  104              throw std::runtime_error(\"Can't create a ComputeVars object without a program\");\n  105          }\n  106:         return create(device, pProg->getReflector());\n  107      }\n  108  \n  109:     ComputeVars::ComputeVars(std::shared_ptr<Device> device, const ProgramReflection::SharedConstPtr& pReflector)\n  110:         : ProgramVars(device, pReflector)\n  111      {\n  112          addSimpleEntryPointGroups();\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramVars.h:\n   50          \\return New object, or throws an exception if creation failed.\n   51      */\n   52:     static SharedPtr create(std::shared_ptr<Device> device, const EntryPointGroupReflection::SharedConstPtr& pReflector, uint32_t groupIndexInProgram) {\n   53          assert(pReflector);\n   54:         return SharedPtr(new EntryPointGroupVars(device, pReflector, groupIndexInProgram));\n   55      }\n   56  \n   ..\n   58  \n   59   protected:\n   60:     EntryPointGroupVars(std::shared_ptr<Device> device, const EntryPointGroupReflection::SharedConstPtr& pReflector, uint32_t groupIndexInProgram)\n   61:         : ParameterBlock(device, pReflector->getProgramVersion(), pReflector)\n   62          , mGroupIndexInProgram(groupIndexInProgram)\n   63      {\n   ..\n   91  \n   92   protected:\n   93:     ProgramVars(std::shared_ptr<Device> device, const ProgramReflection::SharedConstPtr& pReflector);\n   94  \n   95      ProgramReflection::SharedConstPtr mpReflector;\n   ..\n  110          \\return A new object, or an exception is thrown if creation failed.\n  111      */\n  112:     static SharedPtr create(std::shared_ptr<Device> device, const ProgramReflection::SharedConstPtr& pReflector);\n  113  \n  114      /** Create a new graphics vars object.\n  ...\n  116          \\return A new object, or an exception is thrown if creation failed.\n  117      */\n  118:     static SharedPtr create(std::shared_ptr<Device> device, const GraphicsProgram* pProg);\n  119  \n  120      virtual bool apply(RenderContext* pContext, bool bindRootSig, RootSignature* pRootSignature);\n  121  \n  122   protected:\n  123:     GraphicsVars(std::shared_ptr<Device> device, const ProgramReflection::SharedConstPtr& pReflector);\n  124  };\n  125  \n  ...\n  137          \\return A new object, or an exception is thrown if creation failed.\n  138      */\n  139:     static SharedPtr create(std::shared_ptr<Device> device, const ProgramReflection::SharedConstPtr& pReflector);\n  140  \n  141      /** Create a new compute vars object.\n  ...\n  143          \\return A new object, or an exception is thrown if creation failed.\n  144      */\n  145:     static SharedPtr create(std::shared_ptr<Device> device, const ComputeProgram* pProg);\n  146  \n  147      virtual bool apply(ComputeContext* pContext, bool bindRootSig, RootSignature* pRootSignature);\n  148  \n  149   protected:\n  150:     ComputeVars(std::shared_ptr<Device> device, const ProgramReflection::SharedConstPtr& pReflector);\n  151  };\n  152  \n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramVersion.cpp:\n   89  \n   90      ProgramKernels::ProgramKernels(\n   91:         std::shared_ptr<Device> device, \n   92          const ProgramVersion* pVersion,\n   93          const ProgramReflection::SharedPtr& pReflector,\n   ..\n   98          , mpVersion(pVersion)\n   99          , mUniqueEntryPointGroups(uniqueEntryPointGroups)\n  100:         , mpDevice(device)\n  101      {\n  102:         mpRootSignature = RootSignature::create(device, pReflector.get());\n  103      }\n  104  \n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramVersion.h:\n  187      protected:\n  188          ProgramKernels(\n  189:             std::shared_ptr<Device> device, \n  190              const ProgramVersion* pVersion,\n  191              const ProgramReflection::SharedPtr& pReflector,\n\n/home/max/dev/Falcor/src/Falcor/Core/Renderer.h:\n   44  struct SampleConfig : ScriptBindings::enable_to_string {\n   45      Window::Desc windowDesc;                 ///< Controls window creation\n   46:     Device::Desc deviceDesc;                 ///< Controls device creation\n   47      bool suppressInput = false;              ///< Suppress all keyboard and mouse input (other than escape to terminate)\n   48      bool showMessageBoxOnError = true;       ///< Show message box on framework/API errors.\n\n/home/max/dev/Falcor/src/Falcor/Core/Sample.cpp:\n   58              return;\n   59          }\n   60:         // Tell the device to resize the swap chain\n   61          auto winSize = mpWindow->getClientAreaSize();\n   62          auto pBackBufferFBO = mpDevice->resizeSwapChain(winSize.x, winSize.y);\n   ..\n  237          mShowUI = config.showUI;\n  238          \n  239:         mVsyncOn = config.deviceDesc.enableVsync;\n  240  \n  241          // Create the window\n  242          mpWindow = Window::create(config.windowDesc, this);\n  243          if (mpWindow == nullptr) {\n  244:             logError(\"Failed to create device and window\");\n  245              return;\n  246          }\n  247          \n  248:         // Create device \n  249:         mpDevice = Device::create(mpWindow, config.deviceDesc);\n  250  \n  251          mClock = new Clock(mpDevice);\n  ...\n  258          ProgressBar::SharedPtr pBar;\n  259          if (config.windowDesc.mode != Window::WindowMode::Minimized) pBar = ProgressBar::show(\"Initializing Falcor\");\n  260:         Device::Desc d = config.deviceDesc;\n  261          \n  262          if (mpDevice == nullptr) {\n  263:             logError(\"Failed to create device\");\n  264              return;\n  265          }\n  ...\n  579      SampleConfig Sample::getConfig() {\n  580          SampleConfig c;\n  581:         c.deviceDesc = mpDevice->getDesc();\n  582          c.windowDesc = mpWindow->getDesc();\n  583          c.showMessageBoxOnError = Logger::isBoxShownOnError();\n  ...\n  606          auto sampleDesc = m.regClass(SampleConfig);\n  607  #define field(f_) rwField(#f_, &SampleConfig::f_)\n  608:         sampleDesc.field(windowDesc).field(deviceDesc).field(showMessageBoxOnError).field(timeScale);\n  609          sampleDesc.field(pauseTime).field(showUI);\n  610  #undef field\n\n/home/max/dev/Falcor/src/Falcor/Core/State/ComputeState.cpp:\n   33  namespace Falcor {\n   34  \n   35: ComputeState::ComputeState(std::shared_ptr<Device> device): mpDevice(device) {\n   36      mpCsoGraph = _StateGraph::create();\n   37  }\n\n/home/max/dev/Falcor/src/Falcor/Core/State/ComputeState.h:\n   51          \\return A new object, or an exception is thrown if creation failed.\n   52      */\n   53:     static SharedPtr create(std::shared_ptr<Device> device) { return SharedPtr(new ComputeState(device)); }\n   54  \n   55      /** Copy constructor. Useful if you need to make minor changes to an already existing object\n   ..\n   70      \n   71   private:\n   72:     ComputeState(std::shared_ptr<Device> device);\n   73  \n   74      std::shared_ptr<Device> mpDevice;\n\n/home/max/dev/Falcor/src/Falcor/Core/State/GraphicsState.cpp:\n   47  }\n   48  \n   49: GraphicsState::GraphicsState(std::shared_ptr<Device> device): mpDevice(device), mDesc(device) {\n   50:     uint32_t vpCount = getMaxViewportCount(device);\n   51  \n   52      // Create the viewports\n\n/home/max/dev/Falcor/src/Falcor/Core/State/GraphicsState.h:\n   84          \\return A new object, or an exception is thrown if creation failed.\n   85      */\n   86:     static SharedPtr create(std::shared_ptr<Device> device) { return SharedPtr(new GraphicsState(device)); }\n   87  \n   88      /** Copy constructor. Useful if you need to make minor changes to an already existing object\n   ..\n  232  \n  233  private:\n  234:     GraphicsState(std::shared_ptr<Device> device);\n  235  \n  236      Vao::SharedConstPtr mpVao;\n\n/home/max/dev/Falcor/src/Falcor/Data/Framework/Fonts/consolab.ttf:\n    <binary>\n\n/home/max/dev/Falcor/src/Falcor/Data/Framework/Fonts/trebucbd.ttf:\n    <binary>\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/EmissiveIntegrator.ps.slang:\n  102          // We need to detect that and handle it with a fallback mechanism (print error for now).\n  103  \n  104:         // Convert to 2DH normalized device coordinates.\n  105          float2 ndcPos = texelPos * (2.f / _VIEWPORT_DIM) - 1.f;\n  106  \n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/EnvProbe.cpp:\n   72      bool EnvProbe::init(RenderContext* pRenderContext, const std::string& filename) {\n   73          // Create compute program for the setup phase.\n   74:         mpSetupPass = ComputePass::create(pRenderContext->device(), kShaderFilenameSetup, \"main\");\n   75  \n   76          // Create sampler.\n   ..\n   79          samplerDesc.setFilterMode(Sampler::Filter::Linear, Sampler::Filter::Linear, Sampler::Filter::Linear);\n   80          samplerDesc.setAddressingMode(Sampler::AddressMode::Wrap, Sampler::AddressMode::Clamp, Sampler::AddressMode::Clamp);\n   81:         mpEnvSampler = Sampler::create(pRenderContext->device(), samplerDesc);\n   82          samplerDesc.setFilterMode(Sampler::Filter::Point, Sampler::Filter::Point, Sampler::Filter::Point);\n   83          samplerDesc.setAddressingMode(Sampler::AddressMode::Clamp, Sampler::AddressMode::Clamp, Sampler::AddressMode::Clamp);\n   84:         mpImportanceSampler = Sampler::create(pRenderContext->device(), samplerDesc);\n   85  \n   86          // Load environment map from file. Set it to generate mips and use linear color.\n   87:         mpEnvMap = Texture::createFromFile(pRenderContext->device(), filename, true, false);\n   88          if (!mpEnvMap) {\n   89              logError(\"EnvProbe::init() - Failed to load texture \" + filename);\n   ..\n  110  \n  111          // Create importance map. We have to set the RTV flag to be able to use generateMips().\n  112:         mpImportanceMap = Texture::create2D(pRenderContext->device(), dimension, dimension, ResourceFormat::R32Float, 1, mips, nullptr, Resource::BindFlags::ShaderResource | Resource::BindFlags::RenderTarget | Resource::BindFlags::UnorderedAccess);\n  113          assert(mpImportanceMap);\n  114  \n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVH.cpp:\n   35  namespace Falcor {\n   36  \n   37:     LightBVH::SharedPtr LightBVH::create(std::shared_ptr<Device> device, const LightCollection::SharedConstPtr& pLightCollection) {\n   38:         return SharedPtr(new LightBVH(device, pLightCollection));\n   39      }\n   40  \n   ..\n  178      }\n  179  \n  180:     LightBVH::LightBVH(std::shared_ptr<Device> device, const LightCollection::SharedConstPtr& pLightCollection) : mpDevice(device), mpLightCollection(pLightCollection) {\n  181          verifyStaticParams();\n  182          mAlignedAllocator.setMinimumAlignment(16);\n  183          mAlignedAllocator.setCacheLineSize(0);  // Don't worry about allocations that straddle two cache lines.\n  184  \n  185:         mLeafUpdater = ComputePass::create(device, kShaderFile, \"updateLeafNodes\");\n  186:         mInternalUpdater = ComputePass::create(device, kShaderFile, \"updateInternalNodes\");\n  187      }\n  188  \n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVH.h:\n  118          };\n  119  \n  120:         std::shared_ptr<Device> device() { return mpDevice; }\n  121  \n  122          /** Function called on each node.\n  ...\n  131              \\param[in] pLightCollection The light collection around which the BVH will be built.\n  132          */\n  133:         static SharedPtr create(std::shared_ptr<Device> device, const LightCollection::SharedConstPtr& pLightCollection);\n  134  \n  135          /** Refit all the BVH nodes to the underlying geometry, without changing the hierarchy.\n  ...\n  197  \n  198       protected:\n  199:         LightBVH(std::shared_ptr<Device> device, const LightCollection::SharedConstPtr& pLightCollection);\n  200  \n  201          void computeStats();\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVHBuilder.cpp:\n  196  \n  197      void LightBVHBuilder::build(LightBVH& bvh) {\n  198:         PROFILE(bvh.device(), \"LightBVHBuilder::build()\");\n  199  \n  200          bvh.clear();\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightBVHSampler.cpp:\n   50  \n   51      bool LightBVHSampler::update(RenderContext* pRenderContext) {\n   52:         PROFILE(pRenderContext->device(), \"LightBVHSampler::update\");\n   53  \n   54          bool samplerChanged = false;\n   ..\n  156              throw std::runtime_error(\"Failed to create BVH builder\");\n  157          }\n  158:         mpBVH = LightBVH::create(pRenderContext->device(), pScene->getLightCollection(pRenderContext));\n  159          if (!mpBVH) {\n  160              throw std::runtime_error(\"Failed to create BVH\");\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightCollection.cpp:\n   52  \n   53      bool LightCollection::update(RenderContext* pRenderContext, UpdateStatus* pUpdateStatus) {\n   54:         PROFILE(pRenderContext->device(), \"LightCollection::update()\");\n   55  \n   56          if (pUpdateStatus) {\n   ..\n  116          assert(pScene);\n  117          mpScene = pScene;\n  118:         mpDevice = pRenderContext->device();\n  119  \n  120          // Setup the lights.\n  ...\n  299  \n  300          // Create the GPU buffer.\n  301:         mpPerMeshInstanceOffset = Buffer::createStructured(pRenderContext->device(), sizeof(uint32_t), instanceCount, Resource::BindFlags::ShaderResource);\n  302          mpPerMeshInstanceOffset->setName(\"LightCollection_PerMeshInstanceOffset\");\n  303  \n  ...\n  317  \n  318              if (!mIntegrator.pResultBuffer || mIntegrator.pResultBuffer->getSize() < bufSize) {\n  319:                 mIntegrator.pResultBuffer = Buffer::create(pRenderContext->device(), bufSize, Resource::BindFlags::ShaderResource | Resource::BindFlags::UnorderedAccess, Buffer::CpuAccess::None);\n  320                  mIntegrator.pResultBuffer->setName(\"LightCollection_IntegratorResults\");\n  321                  assert(mIntegrator.pResultBuffer);\n  ...\n  493          const size_t stagingSize = mpMeshLightsVertexPos->getSize() + mpMeshLightsTexCoords->getSize() + mpTriangleData->getSize();\n  494          if (!mpStagingBuffer || mpStagingBuffer->getSize() < stagingSize) {\n  495:             mpStagingBuffer = Buffer::create(pRenderContext->device(), stagingSize, Resource::BindFlags::None, Buffer::CpuAccess::Read);\n  496              mpStagingBuffer->setName(\"LightCollection_StagingBuffer\");\n  497              mCPUInvalidData = CPUOutOfDateFlags::All;\n\n/home/max/dev/Falcor/src/Falcor/Experimental/Scene/Lights/LightCollection.h:\n  108      ~LightCollection() = default;\n  109  \n  110:     std::shared_ptr<Device> const device() { return mpDevice; }\n  111  \n  112      /** Creates a light collection for the given scene.\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/BasePasses/BaseGraphicsPass.cpp:\n   31  namespace Falcor {\n   32  \n   33: BaseGraphicsPass::BaseGraphicsPass(std::shared_ptr<Device> device, const Program::Desc& progDesc, const Program::DefineList& programDefines): mpDevice(device) {\n   34:     auto pProg = GraphicsProgram::create(device, progDesc, programDefines);\n   35  \n   36:     mpState = GraphicsState::create(device);\n   37      mpState->setProgram(pProg);\n   38  \n   39:     mpVars = GraphicsVars::create(device, pProg.get());\n   40  }\n   41  \n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/BasePasses/BaseGraphicsPass.h:\n   75          \\return A new object, or an exception is thrown if creation failed.\n   76      */\n   77:     BaseGraphicsPass(std::shared_ptr<Device> device, const Program::Desc& progDesc, const Program::DefineList& programDefines);\n   78  \n   79      GraphicsVars::SharedPtr mpVars;\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/BasePasses/ComputePass.cpp:\n   31  namespace Falcor {\n   32  \n   33: ComputePass::ComputePass(std::shared_ptr<Device> device, const Program::Desc& desc, const Program::DefineList& defines, bool createVars): mpDevice(device) {\n   34:     auto pProg = ComputeProgram::create(device, desc, defines);\n   35:     mpState = ComputeState::create(device);\n   36      mpState->setProgram(pProg);\n   37:     if (createVars) mpVars = ComputeVars::create(device, pProg.get());\n   38      assert(pProg && mpState && (!createVars || mpVars));\n   39  }\n   40  \n   41: ComputePass::SharedPtr ComputePass::create(std::shared_ptr<Device> device, const std::string& filename, const std::string& csEntry, const Program::DefineList& defines, bool createVars) {\n   42      Program::Desc d;\n   43      d.addShaderLibrary(filename).csEntry(csEntry);\n   44:     return create(device, d, defines, createVars);\n   45  }\n   46  \n   47: ComputePass::SharedPtr ComputePass::create(std::shared_ptr<Device> device, const Program::Desc& desc, const Program::DefineList& defines, bool createVars) {\n   48:     return SharedPtr(new ComputePass(device, desc, defines, createVars));\n   49  }\n   50  \n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/BasePasses/ComputePass.h:\n   48              \\return A new object, or throws an exception if creation failed.\n   49          */\n   50:         static SharedPtr create(std::shared_ptr<Device> device, const std::string& filename, const std::string& csEntry = \"main\", const Program::DefineList& defines = Program::DefineList(), bool createVars = true);\n   51  \n   52          /** Create a new compute pass.\n   ..\n   56              \\return A new object, or throws an exception if creation failed.\n   57          */\n   58:         static SharedPtr create(std::shared_ptr<Device> device, const Program::Desc& desc, const Program::DefineList& defines = Program::DefineList(), bool createVars = true);\n   59  \n   60          /** Execute the pass using the given compute-context\n   ..\n  108  \n  109      protected:\n  110:         ComputePass(std::shared_ptr<Device> device, const Program::Desc& desc, const Program::DefineList& defines, bool createVars);\n  111          ComputeVars::SharedPtr mpVars;\n  112          ComputeState::SharedPtr mpState;\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/BasePasses/FullScreenPass.cpp:\n   70  #undef ADJUST_Y\n   71  \n   72: void initFullScreenData(std::shared_ptr<Device> device, Buffer::SharedPtr& pVB, Vao::SharedPtr& pVao) {\n   73      // First time we got here. create VB and VAO\n   74      const uint32_t vbSize = (uint32_t)(sizeof(Vertex)*arraysize(kVertices));\n   75:     pVB = Buffer::create(device, vbSize, Buffer::BindFlags::Vertex, Buffer::CpuAccess::Write, (void*)kVertices);\n   76      assert(pVB);\n   77  \n   ..\n   90  }  // namespace\n   91  \n   92: FullScreenPass::FullScreenPass(std::shared_ptr<Device> device, const Program::Desc& progDesc, const Program::DefineList& programDefines): BaseGraphicsPass(device, progDesc, programDefines) {\n   93      gFullScreenData.objectCount++;\n   94  \n   ..\n   99  \n  100      if (gFullScreenData.pVertexBuffer == nullptr) {\n  101:         initFullScreenData(device, gFullScreenData.pVertexBuffer, gFullScreenData.pVao);\n  102      }\n  103      assert(gFullScreenData.pVao);\n  ...\n  116  }\n  117  \n  118: FullScreenPass::SharedPtr FullScreenPass::create(std::shared_ptr<Device> device, const Program::Desc& desc, const Program::DefineList& defines, uint32_t viewportMask) {\n  119      Program::Desc d = desc;\n  120      Program::DefineList defs = defines;\n  ...\n  132      if (!d.hasEntryPoint(ShaderType::Vertex)) d.addShaderLibrary(\"RenderGraph/BasePasses/FullScreenPass.vs.slang\").vsEntry(\"main\");\n  133  \n  134:     return SharedPtr(new FullScreenPass(device, d, defs));\n  135  }\n  136  \n  137: FullScreenPass::SharedPtr FullScreenPass::create(std::shared_ptr<Device> device, const std::string& filename, const Program::DefineList& defines, uint32_t viewportMask) {\n  138      Program::Desc d;\n  139      d.addShaderLibrary(filename).psEntry(\"main\");\n  140:     return create(device, d, defines, viewportMask);\n  141  }\n  142  \n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/BasePasses/FullScreenPass.h:\n   46          \\return A new object, or throws an exception if creation failed.\n   47      */\n   48:     static SharedPtr create(std::shared_ptr<Device> device, const std::string& filename, const Program::DefineList& defines = Program::DefineList(), uint32_t viewportMask = 0);\n   49  \n   50      /** Create a new fullscreen pass.\n   ..\n   54          \\return A new object, or throws an exception if creation failed.\n   55      */\n   56:     static SharedPtr create(std::shared_ptr<Device> device, const Program::Desc& desc, const Program::DefineList& defines = Program::DefineList(), uint32_t viewportMask = 0);\n   57  \n   58      /** Execute the pass using an FBO\n   ..\n   64  \n   65   protected:\n   66:     FullScreenPass(std::shared_ptr<Device> device, const Program::Desc& progDesc, const Program::DefineList& programDefines);\n   67  };\n   68  \n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/BasePasses/RasterPass.cpp:\n   32  namespace Falcor {\n   33  \n   34: RasterPass::SharedPtr RasterPass::create(std::shared_ptr<Device> device, const Program::Desc& desc, const Program::DefineList& defines) {\n   35:     return SharedPtr(new RasterPass(device, desc, defines));\n   36  }\n   37  \n   38: RasterPass::SharedPtr RasterPass::create(std::shared_ptr<Device> device, const std::string& filename, const std::string& vsEntry, const std::string& psEntry, const Program::DefineList& defines) {\n   39      Program::Desc d;\n   40      d.addShaderLibrary(filename).vsEntry(vsEntry).psEntry(psEntry);\n   41:     return create(device, d, defines);\n   42  }\n   43  \n   44: RasterPass::RasterPass(std::shared_ptr<Device> device, const Program::Desc& progDesc, const Program::DefineList& programDefines) : BaseGraphicsPass(device, progDesc, programDefines) {\n   45  }\n   46  \n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/BasePasses/RasterPass.h:\n   44              \\return A new object, or throws an exception if creation failed.\n   45          */\n   46:         static SharedPtr create(std::shared_ptr<Device> device, const std::string& filename, const std::string& vsEntry, const std::string& psEntry, const Program::DefineList& defines = Program::DefineList());\n   47  \n   48          /** Create a new object.\n   ..\n   51              \\return A new object, or throws an exception if creation failed.\n   52          */\n   53:         static SharedPtr create(std::shared_ptr<Device> device, const Program::Desc& desc, const Program::DefineList& defines = Program::DefineList());\n   54  \n   55          /** Ordered draw call.\n   ..\n   67  \n   68       protected:\n   69:         RasterPass(std::shared_ptr<Device> device, const Program::Desc& progDesc, const Program::DefineList& programDefines);\n   70      };\n   71  \n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/BasePasses/RasterScenePass.cpp:\n   31  namespace Falcor {\n   32  \n   33: RasterScenePass::RasterScenePass(std::shared_ptr<Device> device, const Scene::SharedPtr& pScene, const Program::Desc& progDesc, const Program::DefineList& programDefines) : BaseGraphicsPass(device, progDesc, programDefines), mpScene(pScene) {\n   34      assert(pScene);\n   35  }\n   36  \n   37: RasterScenePass::SharedPtr RasterScenePass::create(std::shared_ptr<Device> device, const Scene::SharedPtr& pScene, const Program::Desc& progDesc, const Program::DefineList& programDefines) {\n   38      if (pScene == nullptr) {\n   39          throw std::runtime_error(\"Can't create a RasterScenePass object without a scene\");            \n   ..\n   42      dl.add(pScene->getSceneDefines());\n   43  \n   44:     return SharedPtr(new RasterScenePass(device, pScene, progDesc, dl));\n   45  }\n   46  \n   47: RasterScenePass::SharedPtr RasterScenePass::create(std::shared_ptr<Device> device, const Scene::SharedPtr& pScene, const std::string& filename, const std::string& vsEntry, const std::string& psEntry, const Program::DefineList& programDefines) {\n   48      Program::Desc d;\n   49      d.addShaderLibrary(filename).vsEntry(vsEntry).psEntry(psEntry);\n   50:     return create(device, pScene, d, programDefines);\n   51  }\n   52  \n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/BasePasses/RasterScenePass.h:\n   45              \\return A new object, or throws an exception if creation failed.\n   46          */\n   47:         static SharedPtr create(std::shared_ptr<Device> device, const Scene::SharedPtr& pScene, const Program::Desc& progDesc, const Program::DefineList& programDefines = Program::DefineList());\n   48  \n   49          /** Create a new object.\n   ..\n   55              \\return A new object, or throws an exception if creation failed.\n   56          */\n   57:         static SharedPtr create(std::shared_ptr<Device> device, const Scene::SharedPtr& pScene, const std::string& filename, const std::string& vsEntry, const std::string& psEntry, const Program::DefineList& programDefines = Program::DefineList());\n   58  \n   59          /** Render the scene into the dst FBO\n   ..\n   73          const Scene::SharedPtr& getScene() const { return mpScene; }\n   74       private:\n   75:         RasterScenePass(std::shared_ptr<Device> device, const Scene::SharedPtr& pScene, const Program::Desc& progDesc, const Program::DefineList& programDefines);\n   76          Scene::SharedPtr mpScene;\n   77      };\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraph.cpp:\n   37  const FileDialogFilterVec RenderGraph::kFileExtensionFilters = { { \"py\", \"Render Graph Files\"} };\n   38  \n   39: RenderGraph::SharedPtr RenderGraph::create(std::shared_ptr<Device> device, const std::string& name) {\n   40:     return SharedPtr(new RenderGraph(device, name));\n   41  }\n   42  \n   43: RenderGraph::RenderGraph(std::shared_ptr<Device> device, const std::string& name): mName(name), mpDevice(device) {\n   44      if (gpFramework == nullptr) {\n   45          throw std::runtime_error(\"Can't construct RenderGraph - framework is not initialized\");\n   ..\n  673          return pPass;\n  674      };\n  675:     passClass.ctor(createRenderPass, \"device\"_a, \"name\"_a, \"dict\"_a = pybind11::dict());\n  676  \n  677      const auto& loadPassLibrary = [](std::shared_ptr<Device> pDevice, const std::string& library) {\n  ...\n  679      };\n  680  \n  681:     m.func_(RenderGraphIR::kLoadPassLibrary, loadPassLibrary, \"device\"_a, \"name\"_a);\n  682  \n  683      const auto& updateRenderPass = [](std::shared_ptr<Device> pDevice, const RenderGraph::SharedPtr& pGraph, const std::string& passName, pybind11::dict d) {\n  ...\n  685      };\n  686  \n  687:     graphClass.func_(RenderGraphIR::kUpdatePass, updateRenderPass, \"device\"_a, \"name\"_a, \"dict\"_a);\n  688  }\n  689  \n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraph.h:\n   50          ~RenderGraph();\n   51  \n   52:         std::shared_ptr<Device> device() { return mpDevice; }\n   53  \n   54          /** Create a new render graph.\n   ..\n   56              \\return New object, or throws an exception if creation failed.\n   57          */\n   58:         static SharedPtr create(std::shared_ptr<Device> device, const std::string& name = \"\");\n   59  \n   60          /** Set a scene\n   ..\n  213          friend class RenderGraphCompiler;\n  214  \n  215:         RenderGraph(std::shared_ptr<Device> device, const std::string& name);\n  216          std::string mName;\n  217  \n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraphCompiler.cpp:\n   45  \n   46      // Register the external resources\n   47:     auto pResourcesCache = ResourceCache::create(graph.device());\n   48      for (const auto&[name, pRes] : dependencies.externalResources) pResourcesCache->registerExternalResource(name, pRes);\n   49  \n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraphExe.cpp:\n   32  \n   33      void RenderGraphExe::execute(const Context& ctx) {\n   34:         PROFILE(ctx.pRenderContext->device(), \"RenderGraphExe::execute()\");\n   35  \n   36          for (const auto& pass : mExecutionList) {\n   37:             PROFILE(ctx.pRenderContext->device(), pass.name);\n   38  \n   39              RenderData renderData(pass.name, mpResourceCache, ctx.pGraphDictionary, ctx.defaultTexDims, ctx.defaultTexFormat);\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderPassLibrary.cpp:\n   80          auto it = spInstances.find(pDevice.get());\n   81          if(it != spInstances.end()) {\n   82:             // found device bound pass library\n   83              return *it->second;\n   84          } else {\n   85:             // create pass library for a new device\n   86              auto ret = spInstances.insert(std::pair<Device*, RenderPassLibrary*>(pDevice.get(), new RenderPassLibrary(pDevice)));\n   87              if (ret.second == false) {\n   88:                 logError(\"RenderPassLibrary for device \" + pDevice->getPhysicalDeviceName() + \" already created !!!\");\n   89              } else {\n   90:                 // add built-in passes for provided device\n   91                  addBuiltinPasses(pDevice);\n   92              }\n\n/home/max/dev/Falcor/src/Falcor/RenderPasses/ResolvePass.cpp:\n   46  \n   47  ResolvePass::SharedPtr ResolvePass::create(RenderContext* pRenderContext, const Dictionary& dictionary) {\n   48:     return SharedPtr(new ResolvePass(pRenderContext->device()));\n   49  }\n   50  \n\n/home/max/dev/Falcor/src/Falcor/RenderPasses/Shared/PathTracer/PathData.slang:\n   38  };\n   39  \n   40: // TODO: Move enum to host/device shared header so that we can add validation.\n   41  /** The path flags are currently stored in 11 bits. See `kMaxPathFlagsBits`.\n   42      If all ray bits are zero the path is inactive/terminated.\n\n/home/max/dev/Falcor/src/Falcor/RenderPasses/Shared/PathTracer/PathTracer.h:\n   87  \n   88          // Configuration\n   89:         PathTracerParams                    mSharedParams;                  ///< Host/device shared rendering parameters.\n   90          uint32_t                            mSelectedSampleGenerator = SAMPLE_GENERATOR_DEFAULT;            ///< Which pseudorandom sample generator to use.\n   91          EmissiveLightSamplerType            mSelectedEmissiveSampler = EmissiveLightSamplerType::LightBVH;  ///< Which emissive light sampler to use.\n\n/home/max/dev/Falcor/src/Falcor/RenderPasses/Shared/PathTracer/PathTracerParams.slang:\n   51  };\n   52  \n   53: /** Path tracer parameters. Shared between host and device.\n   54  \n   55      Note that if you add configuration parameters, do not forget to register\n\n/home/max/dev/Falcor/src/Falcor/Scene/Animation/AnimationController.cpp:\n   44          uint32_t float4Count = (uint32_t)mLocalMatrices.size() * 4;\n   45  \n   46:         mpWorldMatricesBuffer = Buffer::createStructured(pScene->device(), sizeof(float4), float4Count, Resource::BindFlags::ShaderResource, Buffer::CpuAccess::None, nullptr, false);\n   47          mpPrevWorldMatricesBuffer = mpWorldMatricesBuffer;\n   48:         mpInvTransposeWorldMatricesBuffer = Buffer::createStructured(pScene->device(), sizeof(float4), float4Count, Resource::BindFlags::ShaderResource, Buffer::CpuAccess::None, nullptr, false);\n   49          createSkinningPass(staticVertexData, dynamicVertexData);\n   50      }\n   ..\n   70  \n   71      bool AnimationController::animate(RenderContext* pContext, double currentTime) {\n   72:         PROFILE(pContext->device(), \"animate\");\n   73  \n   74          mMatricesChanged.assign(mMatricesChanged.size(), false);\n   ..\n  189          if (mActiveAnimationCount) {\n  190              if (mpWorldMatricesBuffer == mpPrevWorldMatricesBuffer) {\n  191:                 mpPrevWorldMatricesBuffer = Buffer::createStructured(mpScene->device(), sizeof(float4), mpWorldMatricesBuffer->getElementCount(), Resource::BindFlags::ShaderResource, Buffer::CpuAccess::None, nullptr, false);\n  192              }\n  193          }\n  ...\n  214              mInvTransposeSkinningMatrices.resize(mSkinningMatrices.size());\n  215  \n  216:             mpSkinningPass = ComputePass::create(mpScene->device(), \"Scene/Animation/Skinning.slang\");\n  217              auto block = mpSkinningPass->getVars()[\"gData\"];\n  218              block[\"skinnedVertices\"] = pVB;\n  ...\n  220  \n  221              auto createBuffer = [&](const std::string& name, const auto& initData) {\n  222:                 auto pBuffer = Buffer::createStructured(mpScene->device(), block[name], (uint32_t)initData.size(), ResourceBindFlags::ShaderResource, Buffer::CpuAccess::None, nullptr, false);\n  223                  pBuffer->setBlob(initData.data(), 0, pBuffer->getSize());\n  224                  block[name] = pBuffer;\n  ...\n  230              assert(mSkinningMatrices.size() * 4 < UINT32_MAX);\n  231              uint32_t float4Count = (uint32_t)mSkinningMatrices.size() * 4;\n  232:             mpSkinningMatricesBuffer = Buffer::createStructured(mpScene->device(), sizeof(float4), float4Count, ResourceBindFlags::ShaderResource, Buffer::CpuAccess::None, nullptr, false);\n  233:             mpInvTransposeSkinningMatricesBuffer = Buffer::createStructured(mpScene->device(), sizeof(float4), float4Count, ResourceBindFlags::ShaderResource, Buffer::CpuAccess::None, nullptr, false);\n  234              block[\"boneMatrices\"].setBuffer(mpSkinningMatricesBuffer);\n  235              block[\"inverseTransposeBoneMatrices\"].setBuffer(mpInvTransposeSkinningMatricesBuffer);\n\n/home/max/dev/Falcor/src/Falcor/Scene/Camera/CameraData.slang:\n   31  BEGIN_NAMESPACE_FALCOR\n   32  \n   33: /** This is a host/device structure that describes a camera.\n   34  */\n   35  struct CameraData\n\n/home/max/dev/Falcor/src/Falcor/Scene/Lights/LightData.slang:\n   43  };\n   44  \n   45: /** This is a host/device structure that describes analytic light sources.\n   46  */\n   47  struct LightData\n\n/home/max/dev/Falcor/src/Falcor/Scene/Lights/LightProbe.cpp:\n   76  \n   77          Texture::SharedPtr integrateSpecularLD(RenderContext* pContext, const Texture::SharedPtr& pTexture, uint32_t size, ResourceFormat format, uint32_t sampleCount) {\n   78:             std::shared_ptr<Device> device = pContext->device();\n   79  \n   80              mpSpecularLDPass[\"gInputTex\"] = pTexture;\n   81              mpSpecularLDPass[\"DataCB\"][\"gSampleCount\"] = sampleCount;\n   82  \n   83:             Texture::SharedPtr pOutput = Texture::create2D(device, size, size, format, 1, Texture::kMaxPossible, nullptr, Resource::BindFlags::ShaderResource | Resource::BindFlags::RenderTarget);\n   84  \n   85              // Execute on each mip level\n   86              uint32_t mipCount = pOutput->getMipCount();\n   87              for (uint32_t i = 0; i < mipCount; i++) {\n   88:                 Fbo::SharedPtr pFbo = Fbo::create(device);\n   89                  pFbo->attachColorTarget(pOutput, 0, i);\n   90  \n   ..\n  100  \n  101          Texture::SharedPtr executeSingleMip(RenderContext* pContext, const FullScreenPass::SharedPtr& pPass, const Texture::SharedPtr& pTexture, uint32_t size, ResourceFormat format, uint32_t sampleCount) {\n  102:             std::shared_ptr<Device> device = pContext->device();\n  103  \n  104              pPass[\"gInputTex\"] = pTexture;\n  ...\n  106  \n  107              // Output texture\n  108:             Fbo::SharedPtr pFbo = Fbo::create2D(device, size, size, Fbo::Desc(device).setColorTarget(0, format));\n  109  \n  110              // Execute\n  ...\n  129          if (sIntegration.isInitialized() == false) {\n  130              assert(sLightProbeCount == 0);\n  131:             sIntegration.init(pContext->device());\n  132              sSharedResources.dfgTexture = sIntegration.integrateDFG(pContext, pTexture, 128, ResourceFormat::RGBA16Float, 128);\n  133:             sSharedResources.dfgSampler = Sampler::create(pContext->device(), Sampler::Desc().setFilterMode(Sampler::Filter::Point, Sampler::Filter::Point, Sampler::Filter::Point).setAddressingMode(Sampler::AddressMode::Clamp, Sampler::AddressMode::Clamp, Sampler::AddressMode::Clamp));\n  134          }\n  135  \n  ...\n  151  \n  152      LightProbe::SharedPtr LightProbe::create(RenderContext* pContext, const std::string& filename, bool loadAsSrgb, ResourceFormat overrideFormat, uint32_t diffSampleCount, uint32_t specSampleCount, uint32_t diffSize, uint32_t specSize, ResourceFormat preFilteredFormat) {\n  153:         std::shared_ptr<Device> device = pContext->device();\n  154          \n  155:         assert(device);\n  156          \n  157          Texture::SharedPtr pTexture;\n  158          if (overrideFormat != ResourceFormat::Unknown) {\n  159:             Texture::SharedPtr pOrigTex = Texture::createFromFile(device, filename, false, loadAsSrgb);\n  160              if (pOrigTex) {\n  161:                 pTexture = Texture::create2D(device, pOrigTex->getWidth(), pOrigTex->getHeight(), overrideFormat, 1, Texture::kMaxPossible, nullptr, Resource::BindFlags::RenderTarget | Resource::BindFlags::ShaderResource);\n  162                  pTexture->setSourceFilename(pOrigTex->getSourceFilename());\n  163:                 device->getRenderContext()->blit(pOrigTex->getSRV(0, 1, 0, 1), pTexture->getRTV(0, 0, 1));\n  164:                 pTexture->generateMips(device->getRenderContext());\n  165              }\n  166          } else {\n  167:             pTexture = Texture::createFromFile(device, filename, true, loadAsSrgb);\n  168          }\n  169  \n\n/home/max/dev/Falcor/src/Falcor/Scene/Lights/LightProbeData.slang:\n   36  #endif\n   37  \n   38: /** This is a host/device structure that describes light probe resources.\n   39  */\n   40  struct LightProbeResources\n   ..\n   46  };\n   47  \n   48: /** This is a host/device structure that describes shared light probe resources.\n   49  */\n   50  struct LightProbeSharedResources\n   ..\n   54  };\n   55  \n   56: /** This is a host/device structure that describes light probe data.\n   57  */\n   58  struct LightProbeData\n\n/home/max/dev/Falcor/src/Falcor/Scene/Material/MaterialData.slang:\n   37  #endif\n   38  \n   39: /** This is a host/device structure that describes material resources.\n   40  */\n   41  struct MaterialResources\n   ..\n   53  };\n   54  \n   55: /** This is a host/device structure that describes a material.\n   56  */\n   57  struct MaterialData\n\n/home/max/dev/Falcor/src/Falcor/Scene/ParticleSystem/ParticleSystem.cpp:\n   51      {\n   52  \n   53:         std::shared_ptr<Device> device = pCtx->device();\n   54  \n   55          mShouldSort = sorted;\n   ..\n   60          if (mShouldSort) {\n   61              mMaxParticles = (uint32_t)pow(2, (std::ceil(log2((float)maxParticles))));\n   62:             initSortResources(device);\n   63              defineList.add(\"_SORT\");\n   64          } else {\n   ..\n   66          }\n   67          //compute cs\n   68:         ComputeProgram::SharedPtr pSimulateCs = ComputeProgram::createFromFile(device, simulateComputeShader, \"main\", defineList);\n   69  \n   70          //get num sim threads, required as a define for emit cs\n   ..\n   77          Program::DefineList emitDefines;\n   78          emitDefines.add(\"_SIMULATE_THREADS\", std::to_string(mSimulateThreads));\n   79:         ComputeProgram::SharedPtr pEmitCs = ComputeProgram::createFromFile(device, kEmitShader, \"main\", emitDefines);\n   80  \n   81          //draw shader\n   82          GraphicsProgram::Desc d(kVertexShader);\n   83          d.vsEntry(\"main\").addShaderLibrary(drawPixelShader).psEntry(\"main\");\n   84:         GraphicsProgram::SharedPtr pDrawProgram = GraphicsProgram::create(device, d, defineList);\n   85  \n   86          //ParticlePool\n   87:         mpParticlePool = Buffer::createStructured(device, pEmitCs.get(), \"particlePool\", mMaxParticles);\n   88  \n   89          //emitList\n   90:         mpEmitList = Buffer::createStructured(device, pEmitCs.get(), \"emitList\", mMaxEmitPerFrame);\n   91  \n   92          //Dead List\n   93:         mpDeadList = Buffer::createStructured(device, pEmitCs.get(), \"deadList\", mMaxParticles);\n   94  \n   95          // Init data in dead list buffer\n   ..\n  102  \n  103          // Alive list\n  104:         mpAliveList = Buffer::createStructured(device, pSimulateCs.get(), \"aliveList\", mMaxParticles);\n  105  \n  106          // Indirect args\n  107          Resource::BindFlags indirectBindFlags = Resource::BindFlags::IndirectArg | Resource::BindFlags::UnorderedAccess;\n  108:         mpIndirectArgs = Buffer::createStructured(device, pSimulateCs.get(), \"drawArgs\", 1, indirectBindFlags);\n  109  \n  110          //initialize the first member of the args, vert count per instance, to be 4 for particle billboards\n  ...\n  114          //Vars\n  115          //emit\n  116:         mEmitResources.pVars = ComputeVars::create(device, pEmitCs->getReflector());\n  117          mEmitResources.pVars->setBuffer(\"deadList\", mpDeadList);\n  118          mEmitResources.pVars->setBuffer(\"particlePool\", mpParticlePool);\n  ...\n  120          mEmitResources.pVars->setBuffer(\"numAlive\", mpAliveList->getUAVCounter());\n  121          //simulate\n  122:         mSimulateResources.pVars = ComputeVars::create(device, pSimulateCs->getReflector());\n  123          mSimulateResources.pVars->setBuffer(\"deadList\", mpDeadList);\n  124          mSimulateResources.pVars->setBuffer(\"particlePool\", mpParticlePool);\n  ...\n  135  \n  136          //draw\n  137:         mDrawResources.pVars = GraphicsVars::create(device, pDrawProgram->getReflector());\n  138          mDrawResources.pVars->setBuffer(\"aliveList\", mpAliveList);\n  139          mDrawResources.pVars->setBuffer(\"particlePool\", mpParticlePool);\n  140  \n  141          //State\n  142:         mEmitResources.pState = ComputeState::create(device);\n  143          mEmitResources.pState->setProgram(pEmitCs);\n  144:         mSimulateResources.pState = ComputeState::create(device);\n  145          mSimulateResources.pState->setProgram(pSimulateCs);\n  146:         mDrawResources.pState = GraphicsState::create(device);\n  147          mDrawResources.pState->setProgram(pDrawProgram);\n  148  \n\n/home/max/dev/Falcor/src/Falcor/Scene/Scene.cpp:\n  146  \n  147  void Scene::render(RenderContext* pContext, GraphicsState* pState, GraphicsVars* pVars, RenderFlags flags) {\n  148:     PROFILE(pContext->device(), \"renderScene\");\n  149  \n  150      pState->setVao(mpVao);\n\n/home/max/dev/Falcor/src/Falcor/Scene/Scene.h:\n  126          };\n  127  \n  128:         std::shared_ptr<Device> device() { return mpDevice; }\n  129  \n  130          /** Access the scene's camera to change properties, or use elsewhere.\n\n/home/max/dev/Falcor/src/Falcor/Testing/UnitTest.h:\n   99      class dlldecl GPUUnitTestContext : public UnitTestContext {\n  100       public:\n  101:         GPUUnitTestContext(RenderContext* pContext) : mpContext(pContext) { mpDevice = pContext->device(); }\n  102  \n  103          /** createProgram creates a compute program from the source code at the\n\n/home/max/dev/Falcor/src/Falcor/Utils/Algorithm/BitonicSort.cpp:\n   53  \n   54      bool BitonicSort::execute(RenderContext* pRenderContext, Buffer::SharedPtr pData, uint32_t totalSize, uint32_t chunkSize, uint32_t groupSize) {\n   55:         PROFILE(pRenderContext->device(), \"BitonicSort::execute\");\n   56  \n   57          // Validate inputs.\n\n/home/max/dev/Falcor/src/Falcor/Utils/Algorithm/ComputeParallelReduction.cpp:\n   67      template<typename T>\n   68      bool ComputeParallelReduction::execute(RenderContext* pRenderContext, const Texture::SharedPtr& pInput, Type operation, T* pResult, Buffer::SharedPtr pResultBuffer, uint64_t resultOffset) {\n   69:         PROFILE(pRenderContext->device(), \"ComputeParallelReduction::execute\");\n   70  \n   71          // Check texture array/mip/sample count.\n\n/home/max/dev/Falcor/src/Falcor/Utils/Algorithm/ParallelReductionType.slangh:\n   28  #pragma once\n   29  \n   30: // Type defines shared between host and device.\n   31  #define FORMAT_TYPE_UNKNOWN 0\n   32  #define FORMAT_TYPE_FLOAT   1\n\n/home/max/dev/Falcor/src/Falcor/Utils/Algorithm/PrefixSum.cpp:\n   62  \n   63  bool PrefixSum::execute(RenderContext* pRenderContext, Buffer::SharedPtr pData, uint32_t elementCount, uint32_t* pTotalSum, Buffer::SharedPtr pTotalSumBuffer, uint64_t pTotalSumOffset) {\n   64:     PROFILE(pRenderContext->device(), \"PrefixSum::execute\");\n   65  \n   66      assert(pRenderContext);\n\n/home/max/dev/Falcor/src/Falcor/Utils/Color/ColorHelpers.slang:\n   31  BEGIN_NAMESPACE_FALCOR\n   32  \n   33: /** This file contains host/device shared color utility functions.\n   34  */\n   35  \n\n/home/max/dev/Falcor/src/Falcor/Utils/Math/BitTricks.slang:\n   34      So, deinterleave_16bit(interleave_16bit(x)) == x should hold true.\n   35  \n   36:     TODO: Make this a host/device shared header, ensure code compiles on the host.\n   37      TODO: Add optimized 8-bit and 2x8-bit interleaving functions.\n   38      TODO: Use NvApi intrinsics to optimize the code on NV.\n\n/home/max/dev/Falcor/src/Falcor/Utils/Timing/Profiler.cpp:\n   45      using DeviceProfilerEvents = std::unordered_map<std::string, Profiler::EventData*>;\n   46  \n   47:     std::unordered_map<Profiler::DeviceEventKey, Profiler::EventData*, Profiler::device_event_key_hash> Profiler::sProfilerEvents;\n   48      std::vector<Profiler::EventData*> Profiler::sRegisteredEvents;\n   49      std::string curEventName = \"\";\n\n/home/max/dev/Falcor/src/Falcor/Utils/Timing/Profiler.h:\n   57      typedef std::pair<uint8_t, std::string> DeviceEventKey;\n   58  \n   59:     struct device_event_key_hash    {\n   60          template <class T1, class T2>\n   61          std::size_t operator() (const std::pair<T1, T2> &pair) const {\n   ..\n  161      static double getCpuTime(const EventData* pData);\n  162  \n  163:     static std::unordered_map<DeviceEventKey, EventData*, device_event_key_hash> sProfilerEvents;\n  164      static std::vector<EventData*> sRegisteredEvents;\n  165      static uint32_t sCurrentLevel;\n  ...\n  188  #if _PROFILING_ENABLED\n  189  // Profiling enabled\n  190: #define PROFILE_ALL_FLAGS(_device, _name) Falcor::ProfilerEvent _profileEvent##__LINE__(_device, _name)\n  191: #define PROFILE_SOME_FLAGS(_device, _name, _flags) Falcor::ProfilerEvent _profileEvent##__LINE__(_device, _name, _flags)\n  192  \n  193  #define GET_PROFILE(_1, _2, _3, NAME, ...) NAME\n  ...\n  195  #else\n  196  // Profiling disabled\n  197: #define PROFILE(_device, _name)\n  198  #endif\n  199  \n\n/home/max/dev/Falcor/src/Falcor/Utils/UI/Gui.cpp:\n  147  \n  148      void GuiImpl::init(Gui* pGui, float scaleFactor) {\n  149:         mpDevice = pGui->device();\n  150  \n  151          mScaleFactor = scaleFactor;\n\n/home/max/dev/Falcor/src/Falcor/Utils/UI/Gui.h:\n  478          };\n  479  \n  480:         std::shared_ptr<Device> device() { return mpDevice; }\n  481  \n  482          /** Create a new GUI object. Each object is essentially a container for a GUI window\n\n/home/max/dev/Falcor/src/Mogwai/Extensions/Capture/FrameCapture.cpp:\n  147          if (!pGraph) return;\n  148          uint64_t frameID = gpFramework->getClock().getFrame();\n  149:         triggerFrame(mpRenderer->device()->getRenderContext(), pGraph, frameID);\n  150      }\n  151  \n\n/home/max/dev/Falcor/src/Mogwai/Extensions/Capture/VideoCapture.cpp:\n   90                  auto res = msgBox(\"Trying to record graph output \" + outputName + \" but the resource format is not supported by the video encoder.\\nWould you like to capture the output as an RGBA8Srgb resource?\\n\\nFor HDR textures, this operation will clamp the results\", MsgBoxType::YesNo);\n   91                  if(res == MsgBoxButton::No) continue;\n   92:                 encoder.pBlitTex = createTextureForBlit(mpRenderer->device(), pTex.get());\n   93                  pTex = encoder.pBlitTex;\n   94              }\n\n/home/max/dev/Falcor/src/Mogwai/Mogwai.cpp:\n  589          // offscreen renderer\n  590          auto pNullWindow = Falcor::Window::SharedPtr(nullptr);\n  591:         IRenderer::UniquePtr pRenderer = std::make_unique<Mogwai::Renderer>(Device::create(pNullWindow, config.deviceDesc));\n  592  \n  593          ArgList args;\n\n/home/max/dev/Falcor/src/Mogwai/Mogwai.h:\n   96      Renderer(Falcor::Device::SharedPtr pDevice);\n   97  \n   98:     Falcor::Device::SharedPtr device() { return mpDevice; }\n   99:     Falcor::Device::SharedPtr device() const { return mpDevice; }\n  100  \n  101      void onLoad(RenderContext* pRenderContext) override;\n\n/home/max/dev/Falcor/src/Mogwai/MogwaiSettings.cpp:\n  194          file.separator();\n  195          if (file.item(\"Reload Render-Passes\", \"F5\")) {\n  196:             RenderPassLibrary::instance(mpRenderer->device()).reloadLibraries(gpFramework->getRenderContext());\n  197          }\n  198  \n\n/home/max/dev/Falcor/src/RenderPasses/AccumulatePass/AccumulatePass.cpp:\n   65  \n   66  AccumulatePass::SharedPtr AccumulatePass::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   67:     return SharedPtr(new AccumulatePass(pRenderContext->device(), dict));\n   68  }\n   69  \n\n/home/max/dev/Falcor/src/RenderPasses/Antialiasing/FXAA/FXAA.cpp:\n   53  \n   54  FXAA::SharedPtr FXAA::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   55:     SharedPtr pFXAA = SharedPtr(new FXAA(pRenderContext->device()));\n   56      for (const auto& v : dict) {\n   57          if (v.key() == kQualitySubPix) pFXAA->mQualitySubPix = v.val();\n\n/home/max/dev/Falcor/src/RenderPasses/Antialiasing/TAA/TAA.cpp:\n   51  \n   52  TAA::SharedPtr TAA::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   53:     SharedPtr pTAA = SharedPtr(new TAA(pRenderContext->device()));\n   54      for (const auto& v : dict) {\n   55          if (v.key() == kAlpha) pTAA->mControls.alpha = v.val();\n\n/home/max/dev/Falcor/src/RenderPasses/BlitPass/BlitPass.cpp:\n   64  \n   65  BlitPass::SharedPtr BlitPass::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   66:     return SharedPtr(new BlitPass(pRenderContext->device(), dict));\n   67  }\n   68  \n\n/home/max/dev/Falcor/src/RenderPasses/BSDFViewer/BSDFViewer.cpp:\n   48  \n   49  BSDFViewer::SharedPtr BSDFViewer::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   50:     return SharedPtr(new BSDFViewer(pRenderContext->device(), dict));\n   51  }\n   52  \n\n/home/max/dev/Falcor/src/RenderPasses/BSDFViewer/BSDFViewerParams.slang:\n   31  BEGIN_NAMESPACE_FALCOR\n   32  \n   33: /** BSDFViewer parameters shared between host and device.\n   34      Make sure struct layout follows the HLSL packing rules as it is uploaded as a memory blob.\n   35      Do not use bool's as they are 1 byte in Visual Studio, 4 bytes in HLSL.\n\n/home/max/dev/Falcor/src/RenderPasses/CSM/CSM.cpp:\n  238  \n  239  CSM::SharedPtr CSM::create(RenderContext* pRenderContext, const Dictionary& dict) {\n  240:     auto pCSM = SharedPtr(new CSM(pRenderContext->device()));\n  241      for (const auto& v : dict) {\n  242          if (v.key() == kMapSize) pCSM->mMapSize = (uint2)v.val();\n\n/home/max/dev/Falcor/src/RenderPasses/DebugPasses/InvalidPixelDetectionPass/InvalidPixelDetectionPass.cpp:\n   41  \n   42  InvalidPixelDetectionPass::SharedPtr InvalidPixelDetectionPass::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   43:     SharedPtr pPass = SharedPtr(new InvalidPixelDetectionPass(pRenderContext->device()));\n   44      return pPass;\n   45  }\n\n/home/max/dev/Falcor/src/RenderPasses/DebugPasses/SideBySidePass/SideBySidePass.cpp:\n   42  \n   43  SideBySidePass::SharedPtr SideBySidePass::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   44:     SharedPtr pPass = SharedPtr(new SideBySidePass(pRenderContext->device()));\n   45      for (const auto& v : dict) {\n   46          if (v.key() == kImageLeftBound) pPass->mImageLeftBound = v.val();\n\n/home/max/dev/Falcor/src/RenderPasses/DebugPasses/SplitScreenPass/SplitScreenPass.cpp:\n   64  \n   65  SplitScreenPass::SharedPtr SplitScreenPass::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   66:     SharedPtr pPass = SharedPtr(new SplitScreenPass(pRenderContext->device()));\n   67      for (const auto& v : dict) {\n   68          if (!pPass->parseKeyValuePair(v.key(), v.val())) {\n\n/home/max/dev/Falcor/src/RenderPasses/DepthPass/DepthPass.cpp:\n   64  \n   65  DepthPass::SharedPtr DepthPass::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   66:     return SharedPtr(new DepthPass(pRenderContext->device(), dict));\n   67  }\n   68  \n\n/home/max/dev/Falcor/src/RenderPasses/ErrorMeasurePass/ErrorMeasurePass.cpp:\n   74  \n   75  ErrorMeasurePass::SharedPtr ErrorMeasurePass::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   76:     return SharedPtr(new ErrorMeasurePass(pRenderContext->device(), dict));\n   77  }\n   78  \n\n/home/max/dev/Falcor/src/RenderPasses/ForwardLightingPass/ForwardLightingPass.cpp:\n   54  \n   55  ForwardLightingPass::SharedPtr ForwardLightingPass::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   56:     auto pThis = SharedPtr(new ForwardLightingPass(pRenderContext->device()));\n   57      pThis->setColorFormat(ResourceFormat::RGBA32Float).setMotionVecFormat(ResourceFormat::RG16Float).setNormalMapFormat(ResourceFormat::RGBA8Unorm).setSampleCount(1).usePreGeneratedDepthBuffer(true);\n   58  \n   ..\n  111      if (mpScene) mpState->getProgram()->addDefines(mpScene->getSceneDefines());\n  112  \n  113:     mpVars = GraphicsVars::create(pRenderContext->device(), mpState->getProgram()->getReflector());\n  114  \n  115      Sampler::Desc samplerDesc;\n  116      samplerDesc.setFilterMode(Sampler::Filter::Linear, Sampler::Filter::Linear, Sampler::Filter::Linear);\n  117:     setSampler(Sampler::create(pRenderContext->device(), samplerDesc));\n  118  }\n  119  \n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/GBuffer/GBufferParams.slang:\n   31  BEGIN_NAMESPACE_FALCOR\n   32  \n   33: /** Constants shared between host and device.\n   34      Make sure struct layout follows the HLSL packing rules as it is uploaded as a memory blob.\n   35      Do not use bool's as they are 1 byte in Visual Studio, 4 bytes in HLSL.\n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/GBuffer/GBufferRaster.cpp:\n   76  \n   77  GBufferRaster::SharedPtr GBufferRaster::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   78:     return SharedPtr(new GBufferRaster(pRenderContext->device(), dict));\n   79  }\n   80  \n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/VBuffer/VBufferRaster.cpp:\n   51  \n   52  VBufferRaster::SharedPtr VBufferRaster::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   53:     return SharedPtr(new VBufferRaster(pRenderContext->device(), dict));\n   54  }\n   55  \n\n/home/max/dev/Falcor/src/RenderPasses/ImageLoader/ImageLoader.cpp:\n   55  \n   56  ImageLoader::SharedPtr ImageLoader::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   57:     SharedPtr pPass = SharedPtr(new ImageLoader(pRenderContext->device()));\n   58  \n   59      for (const auto& v : dict) {\n   ..\n   67  \n   68      if (pPass->mImageName.size()) {\n   69:         pPass->mpTex = Texture::createFromFile(pRenderContext->device(), pPass->mImageName, pPass->mGenerateMips, pPass->mLoadSRGB);\n   70      }\n   71  \n   ..\n  115      if (reloadImage && mImageName.size()) {\n  116          mImageName = stripDataDirectories(mImageName);\n  117:         mpTex = Texture::createFromFile(widget.gui()->device(), mImageName, mGenerateMips, mLoadSRGB);\n  118      }\n  119  }\n\n/home/max/dev/Falcor/src/RenderPasses/PixelInspectorPass/PixelInspectorPass.cpp:\n   62  \n   63  PixelInspectorPass::SharedPtr PixelInspectorPass::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   64:     return SharedPtr(new PixelInspectorPass(pRenderContext->device()));\n   65  }\n   66  \n\n/home/max/dev/Falcor/src/RenderPasses/SkyBox/SkyBox.cpp:\n   93  \n   94  SkyBox::SharedPtr SkyBox::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   95:     SharedPtr pSkyBox = SharedPtr(new SkyBox(pRenderContext->device()));\n   96      for (const auto& v : dict) {\n   97          if (v.key() == kTexName) {\n   ..\n  106      std::shared_ptr<Texture> pTexture;\n  107      if (pSkyBox->mTexName.size() != 0) {\n  108:         pTexture = Texture::createFromFile(pRenderContext->device(), pSkyBox->mTexName, false, pSkyBox->mLoadSrgb);\n  109          if (pTexture == nullptr) throw std::runtime_error(\"SkyBox::create - Error creating texture from file\");\n  110          pSkyBox->setTexture(pTexture);\n\n/home/max/dev/Falcor/src/RenderPasses/SSAO/SSAO.cpp:\n   97  \n   98  SSAO::SharedPtr SSAO::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   99:     SharedPtr pSSAO = SharedPtr(new SSAO(pRenderContext->device()));\n  100      Dictionary blurDict;\n  101      for (const auto& v : dict) {\n\n/home/max/dev/Falcor/src/RenderPasses/SVGFPass/SVGFPass.cpp:\n   84  \n   85  SVGFPass::SharedPtr SVGFPass::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   86:     return SharedPtr(new SVGFPass(pRenderContext->device(), dict));\n   87  }\n   88  \n\n/home/max/dev/Falcor/src/RenderPasses/TemporalDelayPass/TemporalDelayPass.cpp:\n   55  \n   56  TemporalDelayPass::SharedPtr TemporalDelayPass::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   57:     SharedPtr pPass = SharedPtr(new TemporalDelayPass(pRenderContext->device()));\n   58      for (const auto& v : dict) {\n   59          if (v.key() == kDelay) pPass->mDelay = (uint32_t) v.val();\n\n/home/max/dev/Falcor/src/RenderPasses/ToneMapper/ToneMapper.cpp:\n  127      if (dict.keyExists(kOutputFormat)) outputFormat = dict[kOutputFormat];\n  128  \n  129:     ToneMapper* pTM = new ToneMapper(pRenderContext->device(), Operator::Aces, outputFormat);\n  130  \n  131      try {\n\n/home/max/dev/Falcor/src/RenderPasses/ToneMapper/ToneMapperParams.slang:\n   66  #endif\n   67  \n   68: /** Tone mapper parameters shared between host and device.\n   69      Make sure struct layout follows the HLSL packing rules as it is uploaded as a memory blob.\n   70      Do not use bool's as they are 1 byte in Visual Studio, 4 bytes in HLSL.\n\n/home/max/dev/Falcor/src/RenderPasses/Utils/Composite/Composite.cpp:\n   43  \n   44  Composite::SharedPtr Composite::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   45:     return SharedPtr(new Composite(pRenderContext->device(), dict));\n   46  }\n   47  \n\n/home/max/dev/Falcor/src/RenderPasses/Utils/GaussianBlur/GaussianBlur.cpp:\n   56  \n   57  GaussianBlur::SharedPtr GaussianBlur::create(RenderContext* pRenderContext, const Dictionary& dict) {\n   58:     SharedPtr pBlur = SharedPtr(new GaussianBlur(pRenderContext->device()));\n   59      for (const auto& v : dict) {\n   60          if (v.key() == kKernelWidth) pBlur->mKernelWidth = v.val();\n\n/home/max/dev/Falcor/src/Samples/CudaInterop/FalcorCUDA.cpp:\n  110  \n  111      uint32_t gNodeMask;\n  112:     CUdevice  gCudaDevice;\n  113      CUcontext gCudaContext;\n  114      CUstream  gCudaStream;\n\n/home/max/dev/Falcor/src/Samples/ShaderToy/ShaderToy.cpp:\n   99      config.windowDesc.width = 1280;\n  100      config.windowDesc.height = 720;\n  101:     config.deviceDesc.enableVsync = true;\n  102      config.windowDesc.resizableWindow = true;\n  103      config.windowDesc.title = \"Falcor Shader Toy\";\n\n/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Utils/MathHelpersTests.cpp:\n  116              // Generate test data.\n  117              std::vector<BBoxTestCase> testCases;\n  118:             std::random_device rd;\n  119              std::mt19937 gen(rd());\n  120              std::uniform_real_distribution<> posAndNegDist(-100.f, 100.f);\n\n/home/max/dev/Falcor/src/USD/hgiVk/blitEncoder.cpp:\n    2  #include \"USD/hgiVk/commandBuffer.h\"\n    3  #include \"USD/hgiVk/conversions.h\"\n    4: #include \"USD/hgiVk/device.h\"\n    5  #include \"USD/hgiVk/diagnostic.h\"\n    6  #include \"USD/hgiVk/renderPass.h\"\n    .\n   13  \n   14  HgiVkBlitEncoder::HgiVkBlitEncoder(\n   15:     HgiVkDevice* device,\n   16      HgiVkCommandBuffer* cmdBuf)\n   17      : HgiBlitEncoder()\n   18:     , _device(device)\n   19      , _commandBuffer(cmdBuf)\n   20      , _isRecording(true)\n   ..\n   65      // need to submit it immediately and wait for it to complete so that the\n   66      // CPU can read the pixels data.\n   67:     HgiVkCommandPool cp(_device);\n   68:     HgiVkCommandBuffer cb(_device, &cp, HgiVkCommandBufferUsagePrimary);\n   69      VkCommandBuffer vkCmdBuf = cb.GetCommandBufferForRecoding();\n   70  \n   ..\n   76      dstDesc.data = nullptr;\n   77  \n   78:     HgiVkBuffer dstBuffer(_device, dstDesc);\n   79  \n   80      // Setup info to copy data form gpu texture to gpu buffer\n   ..\n  142      TF_VERIFY(\n  143          vkCreateFence(\n  144:             _device->GetVulkanDevice(),\n  145              &fenceInfo,\n  146              HgiVkAllocator(),\n  ...\n  154      submitInfo.pCommandBuffers = &vkCmdBuf;\n  155      submitInfos.emplace_back(std::move(submitInfo));\n  156:     _device->SubmitToQueue(submitInfos, vkFence);\n  157  \n  158      // Wait for the copy from GPU to CPU to complete.\n  ...\n  160      TF_VERIFY(\n  161          vkWaitForFences(\n  162:             _device->GetVulkanDevice(),\n  163              1,\n  164              &vkFence,\n  ...\n  167      );\n  168  \n  169:     vkDestroyFence(_device->GetVulkanDevice(), vkFence, HgiVkAllocator());\n  170  \n  171      // Copy the data from gpu buffer to cpu destination buffer\n\n/home/max/dev/Falcor/src/USD/hgiVk/blitEncoder.h:\n   20      HGIVK_API\n   21      HgiVkBlitEncoder(\n   22:         HgiVkDevice* device,\n   23          HgiVkCommandBuffer* cmdBuf);\n   24  \n   ..\n   50  \n   51  private:\n   52:     HgiVkDevice* _device;\n   53      HgiVkCommandBuffer* _commandBuffer;\n   54      bool _isRecording;\n\n/home/max/dev/Falcor/src/USD/hgiVk/buffer.cpp:\n    4  #include \"USD/hgiVk/commandBuffer.h\"\n    5  #include \"USD/hgiVk/conversions.h\"\n    6: #include \"USD/hgiVk/device.h\"\n    7  #include \"USD/hgiVk/diagnostic.h\"\n    8  \n    .\n   11  \n   12  HgiVkBuffer::HgiVkBuffer(\n   13:     HgiVkDevice* device,\n   14      HgiBufferDesc const& desc)\n   15      : HgiBuffer(desc)\n   16:     , _device(device)\n   17      , _descriptor(desc)\n   18      , _vkBuffer(nullptr)\n   ..\n   44      }\n   45  \n   46: // todo check with device if supported.\n   47      bufCreateInfo.usage |=\n   48          VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR;\n   ..\n   85      TF_VERIFY(\n   86          vmaCreateBuffer(\n   87:             _device->GetVulkanMemoryAllocator(),\n   88              &bufCreateInfo,\n   89              &allocInfo,\n   ..\n   97          TF_VERIFY(\n   98              vmaMapMemory(\n   99:                 _device->GetVulkanMemoryAllocator(),\n  100                  _vmaBufferAllocation,\n  101                  &_dataMapped) == VK_SUCCESS\n  ...\n  112          if (allocInfo.usage != VMA_MEMORY_USAGE_CPU_ONLY) {\n  113              vmaFlushAllocation(\n  114:                 _device->GetVulkanMemoryAllocator(),\n  115                  _vmaBufferAllocation,\n  116                  0, // offset\n  ...\n  128          std::string debugLabel = \"Buffer \" + _descriptor.debugName;\n  129          HgiVkSetDebugName(\n  130:             _device,\n  131              (uint64_t)_vkBuffer,\n  132              VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT,\n  ...\n  139      if (_dataMapped) {\n  140          vmaUnmapMemory(\n  141:             _device->GetVulkanMemoryAllocator(),\n  142              _vmaBufferAllocation);\n  143      }\n  144  \n  145      vmaDestroyBuffer(\n  146:         _device->GetVulkanMemoryAllocator(),\n  147          _vkBuffer,\n  148          _vmaBufferAllocation);\n  ...\n  178      // See also vkFlushMappedMemoryRanges (we don't need another barrier).\n  179      vmaFlushAllocation(\n  180:         _device->GetVulkanMemoryAllocator(),\n  181          _vmaBufferAllocation,\n  182          byteOffset,\n  ...\n  200  HgiVkBuffer::GetBufferAddress() const\n  201  {\n  202:     if (!_device->vkGetBufferDeviceAddressEXT) return 0;\n  203  \n  204      VkBufferDeviceAddressInfoKHR info =\n  ...\n  206      info.buffer = _vkBuffer;\n  207  \n  208:     VkDeviceAddress address = _device->vkGetBufferDeviceAddressEXT(\n  209:         _device->GetVulkanDevice(),\n  210          &info);\n  211  \n\n/home/max/dev/Falcor/src/USD/hgiVk/buffer.h:\n   22      HGIVK_API\n   23      HgiVkBuffer(\n   24:         HgiVkDevice* device,\n   25          HgiBufferDesc const& desc);\n   26  \n   ..\n   69  \n   70  private:\n   71:     HgiVkDevice* _device;\n   72      HgiBufferDesc _descriptor;\n   73      VkBuffer _vkBuffer;\n\n/home/max/dev/Falcor/src/USD/hgiVk/commandBuffer.cpp:\n    7  #include \"USD/hgiVk/commandPool.h\"\n    8  #include \"USD/hgiVk/blitEncoder.h\"\n    9: #include \"USD/hgiVk/device.h\"\n   10  #include \"USD/hgiVk/diagnostic.h\"\n   11  #include \"USD/hgiVk/graphicsEncoder.h\"\n   ..\n   20  \n   21  HgiVkCommandBuffer::HgiVkCommandBuffer(\n   22:     HgiVkDevice* device,\n   23      HgiVkCommandPool* commandPool,\n   24      HgiVkCommandBufferUsage usage)\n   25:     : _device(device)\n   26      , _commandPool(commandPool)\n   27      , _usage(usage)\n   ..\n   45      TF_VERIFY(\n   46          vkAllocateCommandBuffers(\n   47:             device->GetVulkanDevice(),\n   48              &allocateInfo,\n   49              &_vkCommandBuffer) == VK_SUCCESS\n   ..\n   53      // TimeStamp query pool\n   54      //\n   55:     if (_device->GetDeviceSupportTimeStamps()) {\n   56          _timeQueries.reserve(HGIVK_MAX_TIMESTAMPS/2);\n   57  \n   ..\n   63          TF_VERIFY(\n   64              vkCreateQueryPool(\n   65:                 _device->GetVulkanDevice(),\n   66                  &queryPoolInfo,\n   67                  HgiVkAllocator(),\n   ..\n   79      if (_vkTimeStampQueryPool) {\n   80         vkDestroyQueryPool(\n   81:             _device->GetVulkanDevice(),\n   82              _vkTimeStampQueryPool,\n   83              HgiVkAllocator());\n   ..\n   85  \n   86      vkFreeCommandBuffers(\n   87:         _device->GetVulkanDevice(),\n   88          _commandPool->GetVulkanCommandPool(),\n   89          1, // command buffer cnt\n   ..\n  142      std::string debugLabel = \"Command Buffer \" + std::string(name);\n  143      HgiVkSetDebugName(\n  144:         _device,\n  145          (uint64_t)_vkCommandBuffer,\n  146          VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT,\n  ...\n  150          debugLabel = \"Query Pool \" + std::string(name);\n  151          HgiVkSetDebugName(\n  152:             _device,\n  153              (uint64_t)_vkTimeStampQueryPool,\n  154              VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT,\n  ...\n  224  \n  225      VkPhysicalDeviceProperties const& p =\n  226:         _device->GetVulkanPhysicalDeviceProperties();\n  227      float toNanoSec = p.limits.timestampPeriod;\n  228  \n  ...\n  236      for (HgiTimeQuery& query : _timeQueries) {\n  237          vkGetQueryPoolResults(\n  238:             _device->GetVulkanDevice(),\n  239              _vkTimeStampQueryPool,\n  240              query.beginStamp,\n  ...\n  263      // by a thread. So we record all resets into one single command buffer.\n  264  \n  265:     // XXX VK_KHR_performance_query can do it on a device level, which would fit\n  266      // our design much better. But, for now, it is not that well supported.\n  267  \n\n/home/max/dev/Falcor/src/USD/hgiVk/commandBuffer.h:\n   54      HGIVK_API\n   55      HgiVkCommandBuffer(\n   56:         HgiVkDevice* device,\n   57          HgiVkCommandPool* commandPool,\n   58          HgiVkCommandBufferUsage usage);\n   ..\n  118  \n  119  private:\n  120:     HgiVkDevice* _device;\n  121      HgiVkCommandPool* _commandPool;\n  122      HgiVkCommandBufferUsage _usage;\n\n/home/max/dev/Falcor/src/USD/hgiVk/commandBufferManager.cpp:\n    1  #include \"pxr/base/tf/diagnostic.h\"\n    2  #include \"USD/hgiVk/commandBufferManager.h\"\n    3: #include \"USD/hgiVk/device.h\"\n    4  #include \"USD/hgiVk/diagnostic.h\"\n    5  #include \"USD/hgiVk/hgi.h\"\n    .\n   13  \n   14  \n   15: HgiVkCommandBufferManager::HgiVkCommandBufferManager(HgiVkDevice* device)\n   16:     : _device(device)\n   17      , _frame(~0ull)\n   18      , _nextAvailableIndex(0)\n   ..\n   28      TF_VERIFY(\n   29          vkCreateSemaphore(\n   30:             _device->GetVulkanDevice(),\n   31              &semaCreateInfo,\n   32              HgiVkAllocator(),\n   ..\n   53  \n   54      vkDestroySemaphore(\n   55:         _device->GetVulkanDevice(),\n   56          _vkSemaphore, HgiVkAllocator());\n   57  }\n   ..\n  166  \n  167      // Commit all recorded resource and draw commands from all threads.\n  168:     _device->SubmitToQueue(submitInfos, fence);\n  169  \n  170      // Next frame's threads must re-acquire a command buffer, so reset index.\n  ...\n  262  \n  263          HgiVkCommandBuffer* cb = new HgiVkCommandBuffer(\n  264:             _device,\n  265              cp,\n  266              HgiVkCommandBufferUsageSecondaryRenderPass);\n  ...\n  318      std::string debugLabel = \"Semaphore \" + name;\n  319      HgiVkSetDebugName(\n  320:         _device,\n  321          (uint64_t)_vkSemaphore,\n  322          VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT,\n  ...\n  355  \n  356      for (size_t i=currentSize; i<numThreads; i++) {\n  357:         HgiVkCommandPool* cp = new HgiVkCommandPool(_device);\n  358          _commandPools.push_back(cp);\n  359  \n  360          _resourceCommandBuffers.push_back(\n  361              new HgiVkCommandBuffer(\n  362:                 _device,\n  363                  cp,\n  364                  HgiVkCommandBufferUsagePrimary)\n  ...\n  367          _drawCommandBuffers.push_back(\n  368              new HgiVkCommandBuffer(\n  369:                 _device,\n  370                  cp,\n  371                  HgiVkCommandBufferUsagePrimary)\n\n/home/max/dev/Falcor/src/USD/hgiVk/commandBufferManager.h:\n   34      HGIVK_API\n   35      HgiVkCommandBufferManager(\n   36:         HgiVkDevice* device);\n   37  \n   38      HGIVK_API\n   ..\n  116  \n  117  private:\n  118:     HgiVkDevice* _device;\n  119  \n  120      uint64_t _frame;\n\n/home/max/dev/Falcor/src/USD/hgiVk/commandPool.cpp:\n    1  #include \"pxr/base/tf/diagnostic.h\"\n    2  #include \"USD/hgiVk/commandPool.h\"\n    3: #include \"USD/hgiVk/device.h\"\n    4  #include \"USD/hgiVk/diagnostic.h\"\n    5  \n    .\n    8  \n    9  \n   10: HgiVkCommandPool::HgiVkCommandPool(HgiVkDevice* device)\n   11:     : _device(device)\n   12      , _vkCommandPool(nullptr)\n   13  {\n   ..\n   18      // XXX If Graphics and Compute were to come from different queue families we\n   19      // would need to use a different commandpool/buffer for gfx and compute.\n   20:     poolCreateInfo.queueFamilyIndex = device->GetVulkanDeviceQueueFamilyIndex();\n   21  \n   22      TF_VERIFY(\n   23          vkCreateCommandPool(\n   24:             device->GetVulkanDevice(),\n   25              &poolCreateInfo,\n   26              HgiVkAllocator(),\n   ..\n   32  {\n   33      vkDestroyCommandPool(\n   34:         _device->GetVulkanDevice(),\n   35          _vkCommandPool,\n   36          HgiVkAllocator());\n   ..\n   42      TF_VERIFY(\n   43          vkResetCommandPool(\n   44:             _device->GetVulkanDevice(),\n   45              _vkCommandPool,\n   46              0 /*flags*/) == VK_SUCCESS\n   ..\n   59      std::string debugLabel = \"Command Pool \" + name;\n   60      HgiVkSetDebugName(\n   61:         _device,\n   62          (uint64_t)_vkCommandPool,\n   63          VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT,\n\n/home/max/dev/Falcor/src/USD/hgiVk/commandPool.h:\n   23  public:\n   24      HGIVK_API\n   25:     HgiVkCommandPool(HgiVkDevice* device);\n   26  \n   27      HGIVK_API\n   ..\n   46  \n   47  private:\n   48:     HgiVkDevice* _device;\n   49      VkCommandPool _vkCommandPool;\n   50  };\n\n/home/max/dev/Falcor/src/USD/hgiVk/computeEncoder.cpp:\n    1  #include \"USD/hgiVk/computeEncoder.h\"\n    2  \n    3: #include \"USD/hgiVk/device.h\"\n    4  #include \"USD/hgiVk/diagnostic.h\"\n    5  #include \"USD/hgiVk/pipeline.h\"\n    .\n   11  \n   12  HgiVkComputeEncoder::HgiVkComputeEncoder(\n   13:     HgiVkDevice* device,\n   14      HgiVkCommandBuffer* cb)\n   15      : HgiComputeEncoder()\n   16:     , _device(device)\n   17      , _commandBuffer(_commandBuffer)\n   18      , _isRecording(true)\n\n/home/max/dev/Falcor/src/USD/hgiVk/computeEncoder.h:\n   25      HGIVK_API\n   26      HgiVkComputeEncoder(\n   27:         HgiVkDevice* device,\n   28          HgiVkCommandBuffer* cb);\n   29  \n   ..\n   60  \n   61  private:\n   62:     HgiVkDevice* _device;\n   63      HgiVkCommandBuffer* _commandBuffer;\n   64      bool _isRecording;\n\n/home/max/dev/Falcor/src/USD/hgiVk/device.cpp:\n    2  #include \"pxr/base/tf/envSetting.h\"\n    3  \n    4: #include \"USD/hgiVk/device.h\"\n    5  #include \"USD/hgiVk/diagnostic.h\"\n    6  #include \"USD/hgiVk/hgi.h\"\n    .\n   64  HgiVkDevice::HgiVkDevice(\n   65      HgiVkInstance* instance,\n   66:     HgiVkDeviceSettings deviceType)\n   67      : _vmaAllocator(nullptr)\n   68      , _vkPhysicalDevice(nullptr)\n   ..\n   79  {\n   80      //\n   81:     // Determine physical device\n   82      //\n   83  \n   ..\n  106          if (familyIndex == VK_QUEUE_FAMILY_IGNORED) continue;\n  107  \n  108:         if (deviceType == HgiVkPresentationType) {\n  109              if (!_SupportsPresentation(physicalDevices[i], familyIndex)) {\n  110                  continue;\n  111              }\n  112          } else {\n  113:             TF_CODING_ERROR(\"VULKAN_ERROR: Unknown device type requested\");\n  114          }\n  115  \n  116          if (props.apiVersion < VK_API_VERSION_1_0) continue;\n  117  \n  118:         if (!discrete && props.deviceType==VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU){\n  119              discrete = physicalDevices[i];\n  120              discreteTimeStamps = timeStamps;\n  ...\n  142  \n  143          #if defined(_DEBUG)\n  144:             TF_WARN(\"Selected GPU %s\", _vkDeviceProperties.deviceName);\n  145          #endif\n  146      } else {\n  147:         TF_CODING_ERROR(\"VULKAN_ERROR: Unable to determine physical device\");\n  148          return;\n  149      }\n  150  \n  151      //\n  152:     // Query supported extensions for device\n  153      //\n  154  \n  ...\n  238      } else {\n  239          #if !defined(__APPLE__)\n  240:             TF_WARN(\"Unsupported VK_EXT_buffer_device_address (update drivers?)\");\n  241          #endif\n  242      }\n  ...\n  256      extensions.push_back(VK_KHR_MAINTENANCE1_EXTENSION_NAME);\n  257  \n  258:     // Query device features2.\n  259      // We want to query for descriptor indexing features, but this is unstable\n  260      // on MoltenVk 1. So we skip it (we already know they are not supported).\n  ...\n  272      vkGetPhysicalDeviceFeatures2(_vkPhysicalDevice, &features);\n  273  \n  274:     // XXX Force override indexing features on some devices since they turned\n  275      // out to work or not work even though feature query claimed otherwise.\n  276      #if defined(__linux__)\n  277          // Unbuntu 18.10 Intel UHD 620 does not render with partiallyBound true.\n  278:         if (strstr(_vkDeviceProperties.deviceName, \"UHD Graphics 620\")) {\n  279              _indexingFeatures.descriptorBindingVariableDescriptorCount=VK_TRUE;\n  280              _indexingFeatures.descriptorBindingPartiallyBound=VK_FALSE;\n  ...\n  315      allocatorInfo.instance = instance->GetVulkanInstance();\n  316      allocatorInfo.physicalDevice = _vkPhysicalDevice;\n  317:     allocatorInfo.device = _vkDevice;\n  318      if (dedicatedAllocations) {\n  319          allocatorInfo.flags |=VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT;\n  ...\n  349  \n  350      //\n  351:     // Hgi device features\n  352      //\n  353      _hgiDeviceFeatures.maxSamplers =\n  ...\n  362  HgiVkDevice::~HgiVkDevice()\n  363  {\n  364:     // Make sure device is done consuming all frames before destroying objects.\n  365      TF_VERIFY(vkDeviceWaitIdle(_vkDevice) == VK_SUCCESS);\n  366  \n  ...\n  370      _renderPassPipelineCache.Clear();\n  371  \n  372:     // Destroy vulkan objects in the frames before destroying this device.\n  373      for (HgiVkRenderFrame* frame : _frames) {\n  374          delete frame;\n\n/home/max/dev/Falcor/src/USD/hgiVk/device.h:\n    6  \n    7  #include \"pxr/pxr.h\"\n    8: #include \"pxr/imaging/hgi/deviceFeatures.h\"\n    9  \n   10  #include \"USD/hgiVk/api.h\"\n   ..\n   34  /// \\class HgiVkDevice\n   35  ///\n   36: /// Vulkan implementation of GPU device.\n   37  ///\n   38  class HgiVkDevice final {\n   ..\n   41      HgiVkDevice(\n   42          HgiVkInstance* instance,\n   43:         HgiVkDeviceSettings deviceType);\n   44  \n   45      HGIVK_API\n   ..\n   69          VkFence fence);\n   70  \n   71:     /// Returns the vulkan device\n   72      HGIVK_API\n   73      VkDevice GetVulkanDevice() const;\n   74  \n   75:     /// Returns the vulkan physical device\n   76      HGIVK_API\n   77      VkPhysicalDevice GetVulkanPhysicalDevice() const;\n   78  \n   79:     /// Returns the vulkan physical device properties\n   80      HGIVK_API\n   81      VkPhysicalDeviceProperties const& GetVulkanPhysicalDeviceProperties() const;\n   82  \n   83:     /// Returns the vulkan physical device features\n   84      HGIVK_API\n   85      VkPhysicalDeviceFeatures const& GetVulkanPhysicalDeviceFeatures() const;\n   86  \n   87:     /// Returns the indexing features of the physical device\n   88      HGIVK_API\n   89      VkPhysicalDeviceDescriptorIndexingFeaturesEXT const&\n   ..\n  105      void ReleaseRenderPass(HgiVkRenderPass* rp);\n  106  \n  107:     /// Returns the vulkan device queue.\n  108      HGIVK_API\n  109      VkQueue GetVulkanDeviceQueue() const;\n  110  \n  111:     /// Returns the family index of the vulkan device queue.\n  112      HGIVK_API\n  113      uint32_t GetVulkanDeviceQueueFamilyIndex() const;\n  ...\n  130      void DestroyObject(HgiVkObject const& object);\n  131  \n  132:     /// Wait for all queued up commands to have been processed on device.\n  133      /// This should ideally never be used as it creates very big stalls.\n  134      HGIVK_API\n  ...\n  139      uint64_t GetCurrentFrame() const;\n  140  \n  141:     /// Returns device used and unused memmory.\n  142      HGIVK_API\n  143      void GetDeviceMemoryInfo(size_t* used, size_t* unused) const;\n  144  \n  145:     /// Returns true if the device support debug marker extension\n  146      HGIVK_API\n  147      bool GetDeviceSupportDebugMarkers() const;\n  148  \n  149:     /// Returns true if the device support time stamps\n  150      HGIVK_API\n  151      bool GetDeviceSupportTimeStamps() const;\n  ...\n  155      HgiTimeQueryVector const & GetTimeQueries() const;\n  156  \n  157:     /// Returns the feature and limits of the device\n  158      HGIVK_API\n  159      HgiDeviceFeatures const& GetDeviceFeatures() const;\n  160  \n  161  public:\n  162:     /// device extension functions\n  163  \n  164      // Not supported on MoltenVk 1\n  ...\n  171      HgiVkDevice(const HgiVkDevice&) = delete;\n  172  \n  173:     // Returns true if the provided extension is supported by the device\n  174      bool _IsSupportedExtension(const char* extensionName) const;\n  175  \n  176  private:\n  177:     // Vulkan device objects\n  178      VmaAllocator _vmaAllocator;\n  179      VkPhysicalDevice _vkPhysicalDevice;\n\n/home/max/dev/Falcor/src/USD/hgiVk/diagnostic.cpp:\n    5  \n    6  #include \"USD/hgiVk/commandBuffer.h\"\n    7: #include \"USD/hgiVk/device.h\"\n    8  #include \"USD/hgiVk/diagnostic.h\"\n    9  #include \"USD/hgiVk/instance.h\"\n   ..\n   20  \n   21  // XXX Make HgiVkDebug class and move all function, including below in there.\n   22: // We may have multiple devices where one supports the marker extension and\n   23  // one does not.\n   24  static PFN_vkCmdDebugMarkerBeginEXT _vkCmdDebugMarkerBeginEXT = 0;\n   ..\n   48      // https://github.com/KhronosGroup/Vulkan-ValidationLayers/issues/73\n   49      if (strstr(pMessage, \"Shader requires vertexPipelineStoresAndAtomics but is\"\n   50:                          \" not enabled on the device\")) {\n   51          return VK_FALSE;\n   52      }\n   ..\n   59      if(strstr(pMessage, \"Mapping an image with layout\") != nullptr &&\n   60         strstr(pMessage, \"can result in undefined behavior if this memory is \"\n   61:                         \"used by the device\") != nullptr) {\n   62          return VK_FALSE;\n   63      }\n   ..\n  138  \n  139  void\n  140: HgiVkInitializeDeviceDebug(HgiVkDevice* device)\n  141  {\n  142      if (!HgiVkIsDebugEnabled()) return;\n  143:     if (!device->GetDeviceSupportDebugMarkers()) return;\n  144  \n  145      _vkCmdDebugMarkerBeginEXT = (PFN_vkCmdDebugMarkerBeginEXT)\n  146          vkGetDeviceProcAddr(\n  147:             device->GetVulkanDevice(),\n  148              \"vkCmdDebugMarkerBeginEXT\");\n  149  \n  150      _vkCmdDebugMarkerEndEXT = (PFN_vkCmdDebugMarkerEndEXT)\n  151          vkGetDeviceProcAddr(\n  152:             device->GetVulkanDevice(),\n  153              \"vkCmdDebugMarkerEndEXT\");\n  154  \n  155      _vkDebugMarkerSetObjectNameEXT = (PFN_vkDebugMarkerSetObjectNameEXT)\n  156          vkGetDeviceProcAddr(\n  157:             device->GetVulkanDevice(),\n  158              \"vkDebugMarkerSetObjectNameEXT\");\n  159  }\n  ...\n  189  void\n  190  HgiVkSetDebugName(\n  191:     HgiVkDevice* device,\n  192      uint64_t vulkanObject,\n  193      uint32_t objectType,\n  ...\n  201      debugInfo.objectType = VkDebugReportObjectTypeEXT(objectType);\n  202      debugInfo.pObjectName = name;\n  203:     _vkDebugMarkerSetObjectNameEXT(device->GetVulkanDevice(), &debugInfo);\n  204  }\n  205  \n\n/home/max/dev/Falcor/src/USD/hgiVk/diagnostic.h:\n   27  void HgiVkDestroyDebug(HgiVkInstance* instance);\n   28  \n   29: /// Setup vulkan device debug function ptrs\n   30  HGIVK_API\n   31: void HgiVkInitializeDeviceDebug(HgiVkDevice* device);\n   32  \n   33  /// Push a debug marker\n   ..\n   45  HGIVK_API\n   46  void HgiVkSetDebugName(\n   47:     HgiVkDevice* device,\n   48      uint64_t vulkanObject,\n   49      uint32_t /*VkDebugReportObjectTypeEXT*/ objectType,\n\n/home/max/dev/Falcor/src/USD/hgiVk/frame.cpp:\n    1  #include \"pxr/base/tf/diagnostic.h\"\n    2: #include \"USD/hgiVk/device.h\"\n    3  #include \"USD/hgiVk/diagnostic.h\"\n    4  #include \"USD/hgiVk/frame.h\"\n    .\n    8  \n    9  \n   10: HgiVkRenderFrame::HgiVkRenderFrame(HgiVkDevice* device)\n   11:     : _device(device)\n   12:     , _commandBufferManager(device)\n   13      , _vkFence(nullptr)\n   14  {\n   ..\n   19      TF_VERIFY(\n   20          vkCreateFence(\n   21:             _device->GetVulkanDevice(),\n   22              &fenceInfo,\n   23              HgiVkAllocator(),\n   ..\n   28  HgiVkRenderFrame::~HgiVkRenderFrame()\n   29  {\n   30:     vkDestroyFence(_device->GetVulkanDevice(), _vkFence, HgiVkAllocator());\n   31  }\n   32  \n   ..\n   39      TF_VERIFY(\n   40          vkWaitForFences(\n   41:             _device->GetVulkanDevice(),\n   42              1,\n   43              &_vkFence,\n   ..\n   48      TF_VERIFY(\n   49          vkResetFences(\n   50:             _device->GetVulkanDevice(),\n   51              1,\n   52              &_vkFence)  == VK_SUCCESS\n   ..\n   85      std::string debugLabel = \"Fence \" + name;\n   86      HgiVkSetDebugName(\n   87:         _device,\n   88          (uint64_t)_vkFence,\n   89          VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT,\n\n/home/max/dev/Falcor/src/USD/hgiVk/frame.h:\n   30  class HgiVkRenderFrame final {\n   31  public:\n   32:     HgiVkRenderFrame(HgiVkDevice* device);\n   33      ~HgiVkRenderFrame();\n   34  \n   ..\n   61  \n   62  private:\n   63:     HgiVkDevice* _device;\n   64  \n   65      // Thread-safe managing of one frame's command buffers.\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/Include/Types.h:\n  476      {\n  477          coherent     = false;\n  478:         devicecoherent = false;\n  479          queuefamilycoherent = false;\n  480          workgroupcoherent = false;\n  ...\n  524      bool sample       : 1;\n  525      bool coherent     : 1;\n  526:     bool devicecoherent : 1;\n  527      bool queuefamilycoherent : 1;\n  528      bool workgroupcoherent : 1;\n  ...\n  538      bool isMemory() const\n  539      {\n  540:         return subgroupcoherent || workgroupcoherent || queuefamilycoherent || devicecoherent || coherent || volatil || restrict || readonly || writeonly || nonprivate;\n  541      }\n  542      bool isMemoryQualifierImageAndSSBOOnly() const\n  543      {\n  544:         return subgroupcoherent || workgroupcoherent || queuefamilycoherent || devicecoherent || coherent || volatil || restrict || readonly || writeonly;\n  545      }\n  546      bool bufferReferenceNeedsVulkanMemoryModel() const\n  547      {\n  548          // include qualifiers that map to load/store availability/visibility/nonprivate memory access operands\n  549:         return subgroupcoherent || workgroupcoherent || queuefamilycoherent || devicecoherent || coherent || nonprivate;\n  550      }\n  551  \n  ...\n 1941          if (qualifier.coherent)\n 1942              appendStr(\" coherent\");\n 1943:         if (qualifier.devicecoherent)\n 1944:             appendStr(\" devicecoherent\");\n 1945          if (qualifier.queuefamilycoherent)\n 1946              appendStr(\" queuefamilycoherent\");\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/glslang.y:\n 1424      | DEVICECOHERENT {\n 1425          $$.init($1.loc);\n 1426:         parseContext.requireExtensions($1.loc, 1, &E_GL_KHR_memory_scope_semantics, \"devicecoherent\");\n 1427:         $$.qualifier.devicecoherent = true;\n 1428      }\n 1429      | QUEUEFAMILYCOHERENT {\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/glslang_tab.cpp:\n 5977      {\n 5978          (yyval.interm.type).init((yyvsp[0].lex).loc);\n 5979:         parseContext.requireExtensions((yyvsp[0].lex).loc, 1, &E_GL_KHR_memory_scope_semantics, \"devicecoherent\");\n 5980:         (yyval.interm.type).qualifier.devicecoherent = true;\n 5981      }\n 5982  #line 5983 \"MachineIndependent/glslang_tab.cpp\" /* yacc.c:1646  */\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/Initialize.cpp:\n 5322          (profile == EEsProfile && version >= 310)) {\n 5323          stageBuiltins[EShLangCompute].append(\n 5324:             \"in highp int gl_DeviceIndex;\"     // GL_EXT_device_group\n 5325              \"\\n\");\n 5326      }\n ....\n 5395      if (profile != EEsProfile && version >= 450) {\n 5396          stageBuiltins[EShLangMeshNV].append(\n 5397:             \"in highp int gl_DeviceIndex;\"     // GL_EXT_device_group\n 5398              \"in int gl_DrawIDARB;\"             // GL_ARB_shader_draw_parameters\n 5399              \"\\n\");\n 5400  \n 5401          stageBuiltins[EShLangTaskNV].append(\n 5402:             \"in highp int gl_DeviceIndex;\"     // GL_EXT_device_group\n 5403              \"in int gl_DrawIDARB;\"             // GL_ARB_shader_draw_parameters\n 5404              \"\\n\");\n ....\n 5595          (profile == EEsProfile && version >= 310)) {\n 5596          stageBuiltins[EShLangVertex].append(\n 5597:             \"in highp int gl_DeviceIndex;\"     // GL_EXT_device_group\n 5598              \"in highp int gl_ViewIndex;\"       // GL_EXT_multiview\n 5599              \"\\n\");\n ....\n 5718          (profile == EEsProfile && version >= 310)) {\n 5719          stageBuiltins[EShLangGeometry].append(\n 5720:             \"in highp int gl_DeviceIndex;\"     // GL_EXT_device_group\n 5721              \"in highp int gl_ViewIndex;\"       // GL_EXT_multiview\n 5722              \"\\n\");\n ....\n 5809          (profile == EEsProfile && version >= 310)) {\n 5810          stageBuiltins[EShLangTessControl].append(\n 5811:             \"in highp int gl_DeviceIndex;\"     // GL_EXT_device_group\n 5812              \"in highp int gl_ViewIndex;\"       // GL_EXT_multiview\n 5813              \"\\n\");\n ....\n 5896          (profile == EEsProfile && version >= 310)) {\n 5897          stageBuiltins[EShLangTessEvaluation].append(\n 5898:             \"in highp int gl_DeviceIndex;\"     // GL_EXT_device_group\n 5899              \"in highp int gl_ViewIndex;\"       // GL_EXT_multiview\n 5900              \"\\n\");\n ....\n 6122          (profile == EEsProfile && version >= 310)) {\n 6123          stageBuiltins[EShLangFragment].append(\n 6124:             \"flat in highp int gl_DeviceIndex;\"     // GL_EXT_device_group\n 6125              \"flat in highp int gl_ViewIndex;\"       // GL_EXT_multiview\n 6126              \"\\n\");\n ....\n 6265      }\n 6266      if ((profile != EEsProfile && version >= 140)) {\n 6267:         const char *deviceIndex =\n 6268:             \"in highp int gl_DeviceIndex;\"     // GL_EXT_device_group\n 6269              \"\\n\";\n 6270  \n 6271:         stageBuiltins[EShLangRayGenNV].append(deviceIndex);\n 6272:         stageBuiltins[EShLangIntersectNV].append(deviceIndex);\n 6273:         stageBuiltins[EShLangAnyHitNV].append(deviceIndex);\n 6274:         stageBuiltins[EShLangClosestHitNV].append(deviceIndex);\n 6275:         stageBuiltins[EShLangMissNV].append(deviceIndex);\n 6276      }\n 6277  #endif\n ....\n 8155          if ((profile != EEsProfile && version >= 140) ||\n 8156              (profile == EEsProfile && version >= 310)) {\n 8157:             symbolTable.setVariableExtensions(\"gl_DeviceIndex\",  1, &E_GL_EXT_device_group);\n 8158              BuiltInVariable(\"gl_DeviceIndex\", EbvDeviceIndex, symbolTable);\n 8159              symbolTable.setVariableExtensions(\"gl_ViewIndex\", 1, &E_GL_EXT_multiview);\n ....\n 8448          }\n 8449  \n 8450:         symbolTable.setVariableExtensions(\"gl_DeviceIndex\",  1, &E_GL_EXT_device_group);\n 8451          BuiltInVariable(\"gl_DeviceIndex\", EbvDeviceIndex, symbolTable);\n 8452          symbolTable.setVariableExtensions(\"gl_ViewIndex\", 1, &E_GL_EXT_multiview);\n ....\n 8688          if ((profile != EEsProfile && version >= 140) ||\n 8689              (profile == EEsProfile && version >= 310)) {\n 8690:             symbolTable.setVariableExtensions(\"gl_DeviceIndex\",  1, &E_GL_EXT_device_group);\n 8691              BuiltInVariable(\"gl_DeviceIndex\", EbvDeviceIndex, symbolTable);\n 8692              symbolTable.setVariableExtensions(\"gl_ViewIndex\", 1, &E_GL_EXT_multiview);\n ....\n 8736              symbolTable.setVariableExtensions(\"gl_IncomingRayFlagsNV\", 1, &E_GL_NV_ray_tracing);\n 8737  \n 8738:             symbolTable.setVariableExtensions(\"gl_DeviceIndex\", 1, &E_GL_EXT_device_group);\n 8739  \n 8740              BuiltInVariable(\"gl_LaunchIDNV\",            EbvLaunchIdNV,           symbolTable);\n ....\n 8830  \n 8831          if (profile != EEsProfile && version >= 450) {\n 8832:             // GL_EXT_device_group\n 8833:             symbolTable.setVariableExtensions(\"gl_DeviceIndex\", 1, &E_GL_EXT_device_group);\n 8834              BuiltInVariable(\"gl_DeviceIndex\", EbvDeviceIndex, symbolTable);\n 8835  \n ....\n 8920  \n 8921          if (profile != EEsProfile && version >= 450) {\n 8922:             // GL_EXT_device_group\n 8923:             symbolTable.setVariableExtensions(\"gl_DeviceIndex\", 1, &E_GL_EXT_device_group);\n 8924              BuiltInVariable(\"gl_DeviceIndex\", EbvDeviceIndex, symbolTable);\n 8925  \n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/Intermediate.cpp:\n 1363  \n 1364              // HLSL semantics: the scalar (or vec1) is replicated to every component of the matrix.  Left to its\n 1365:             // own devices, the constructor from a scalar would populate the diagonal.  This forces replication\n 1366              // to every matrix element.\n 1367  \n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/linkValidate.cpp:\n  555      // Memory...\n  556      if (symbol.getQualifier().coherent          != unitSymbol.getQualifier().coherent ||\n  557:         symbol.getQualifier().devicecoherent    != unitSymbol.getQualifier().devicecoherent ||\n  558          symbol.getQualifier().queuefamilycoherent  != unitSymbol.getQualifier().queuefamilycoherent ||\n  559          symbol.getQualifier().workgroupcoherent != unitSymbol.getQualifier().workgroupcoherent ||\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/ParseHelper.cpp:\n 1152                          if (argQualifier.volatil && ! formalQualifier.volatil)\n 1153                              error(arguments->getLoc(), message, \"volatile\", \"\");\n 1154:                         if (argQualifier.coherent && ! (formalQualifier.devicecoherent || formalQualifier.coherent))\n 1155                              error(arguments->getLoc(), message, \"coherent\", \"\");\n 1156:                         if (argQualifier.devicecoherent && ! (formalQualifier.devicecoherent || formalQualifier.coherent))\n 1157:                             error(arguments->getLoc(), message, \"devicecoherent\", \"\");\n 1158:                         if (argQualifier.queuefamilycoherent && ! (formalQualifier.queuefamilycoherent || formalQualifier.devicecoherent || formalQualifier.coherent))\n 1159                              error(arguments->getLoc(), message, \"queuefamilycoherent\", \"\");\n 1160:                         if (argQualifier.workgroupcoherent && ! (formalQualifier.workgroupcoherent || formalQualifier.queuefamilycoherent || formalQualifier.devicecoherent || formalQualifier.coherent))\n 1161                              error(arguments->getLoc(), message, \"workgroupcoherent\", \"\");\n 1162:                         if (argQualifier.subgroupcoherent && ! (formalQualifier.subgroupcoherent || formalQualifier.workgroupcoherent || formalQualifier.queuefamilycoherent || formalQualifier.devicecoherent || formalQualifier.coherent))\n 1163                              error(arguments->getLoc(), message, \"subgroupcoherent\", \"\");\n 1164                          if (argQualifier.readonly && ! formalQualifier.readonly)\n ....\n 3432          dst.precision = src.precision;\n 3433  \n 3434:     if (!force && ((src.coherent && (dst.devicecoherent || dst.queuefamilycoherent || dst.workgroupcoherent || dst.subgroupcoherent)) ||\n 3435:                    (src.devicecoherent && (dst.coherent || dst.queuefamilycoherent || dst.workgroupcoherent || dst.subgroupcoherent)) ||\n 3436:                    (src.queuefamilycoherent && (dst.coherent || dst.devicecoherent || dst.workgroupcoherent || dst.subgroupcoherent)) ||\n 3437:                    (src.workgroupcoherent && (dst.coherent || dst.devicecoherent || dst.queuefamilycoherent || dst.subgroupcoherent)) ||\n 3438:                    (src.subgroupcoherent  && (dst.coherent || dst.devicecoherent || dst.queuefamilycoherent || dst.workgroupcoherent)))) {\n 3439:         error(loc, \"only one coherent/devicecoherent/queuefamilycoherent/workgroupcoherent/subgroupcoherent qualifier allowed\", GetPrecisionQualifierString(src.precision), \"\");\n 3440      }\n 3441      // Layout qualifiers\n ....\n 3462      MERGE_SINGLETON(sample);\n 3463      MERGE_SINGLETON(coherent);\n 3464:     MERGE_SINGLETON(devicecoherent);\n 3465      MERGE_SINGLETON(queuefamilycoherent);\n 3466      MERGE_SINGLETON(workgroupcoherent);\n ....\n 4396          type.getQualifier().volatil   = qualifier.volatil;\n 4397          type.getQualifier().coherent  = qualifier.coherent;\n 4398:         type.getQualifier().devicecoherent  = qualifier.devicecoherent ;\n 4399          type.getQualifier().queuefamilycoherent  = qualifier.queuefamilycoherent;\n 4400          type.getQualifier().workgroupcoherent  = qualifier.workgroupcoherent;\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/Scan.cpp:\n  381      (*KeywordMap)[\"buffer\"] =                  BUFFER;\n  382      (*KeywordMap)[\"coherent\"] =                COHERENT;\n  383:     (*KeywordMap)[\"devicecoherent\"] =          DEVICECOHERENT;\n  384      (*KeywordMap)[\"queuefamilycoherent\"] =     QUEUEFAMILYCOHERENT;\n  385      (*KeywordMap)[\"workgroupcoherent\"] =       WORKGROUPCOHERENT;\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/Versions.cpp:\n  281  \n  282      // EXT extensions\n  283:     extensionBehavior[E_GL_EXT_device_group]             = EBhDisable;\n  284      extensionBehavior[E_GL_EXT_multiview]                = EBhDisable;\n  285  \n  ...\n  456          (profile == EEsProfile && version >= 310)) {\n  457          preamble +=\n  458:             \"#define GL_EXT_device_group 1\\n\"\n  459              \"#define GL_EXT_multiview 1\\n\"\n  460              ;\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/Versions.h:\n  163  \n  164  // EXT extensions\n  165: const char* const E_GL_EXT_device_group                     = \"GL_EXT_device_group\";\n  166  const char* const E_GL_EXT_multiview                        = \"GL_EXT_multiview\";\n  167  const char* const E_GL_EXT_post_depth_coverage              = \"GL_EXT_post_depth_coverage\";\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/SPIRV/GLSL.ext.KHR.h:\n   33  static const char* const E_SPV_KHR_shader_ballot                = \"SPV_KHR_shader_ballot\";\n   34  static const char* const E_SPV_KHR_subgroup_vote                = \"SPV_KHR_subgroup_vote\";\n   35: static const char* const E_SPV_KHR_device_group                 = \"SPV_KHR_device_group\";\n   36  static const char* const E_SPV_KHR_multiview                    = \"SPV_KHR_multiview\";\n   37  static const char* const E_SPV_KHR_shader_draw_parameters       = \"SPV_KHR_shader_draw_parameters\";\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/SPIRV/GlslangToSpv.cpp:\n  501      if (coherentFlags.volatil ||\n  502          coherentFlags.coherent ||\n  503:         coherentFlags.devicecoherent ||\n  504          coherentFlags.queuefamilycoherent ||\n  505          coherentFlags.workgroupcoherent ||\n  ...\n  528      if (coherentFlags.volatil ||\n  529          coherentFlags.coherent ||\n  530:         coherentFlags.devicecoherent ||\n  531          coherentFlags.queuefamilycoherent ||\n  532          coherentFlags.workgroupcoherent ||\n  ...\n  551      spv::Builder::AccessChain::CoherentFlags flags;\n  552      flags.coherent = type.getQualifier().coherent;\n  553:     flags.devicecoherent = type.getQualifier().devicecoherent;\n  554      flags.queuefamilycoherent = type.getQualifier().queuefamilycoherent;\n  555      // shared variables are implicitly workgroupcoherent in GLSL.\n  ...\n  563                         flags.workgroupcoherent ||\n  564                         flags.queuefamilycoherent ||\n  565:                        flags.devicecoherent ||\n  566                         flags.coherent ||\n  567                         flags.volatil;\n  ...\n  576          // coherent defaults to Device scope in the old model, QueueFamilyKHR scope in the new model\n  577          scope = glslangIntermediate->usingVulkanMemoryModel() ? spv::ScopeQueueFamilyKHR : spv::ScopeDevice;\n  578:     } else if (coherentFlags.devicecoherent) {\n  579          scope = spv::ScopeDevice;\n  580      } else if (coherentFlags.queuefamilycoherent) {\n  ...\n  826  \n  827      case glslang::EbvDeviceIndex:\n  828:         addPre13Extension(spv::E_SPV_KHR_device_group);\n  829          builder.addCapability(spv::CapabilityDeviceGroup);\n  830          return spv::BuiltInDeviceIndex;\n  ...\n 1239      if (parent.coherent)\n 1240          child.coherent = true;\n 1241:     if (parent.devicecoherent)\n 1242:         child.devicecoherent = true;\n 1243      if (parent.queuefamilycoherent)\n 1244          child.queuefamilycoherent = true;\n ....\n 7312  spv::Id TGlslangToSpvTraverser::createNoArgOperation(glslang::TOperator op, spv::Decoration precision, spv::Id typeId)\n 7313  {\n 7314:     // GLSL memory barriers use queuefamily scope in new model, device scope in old model\n 7315      spv::Scope memoryBarrierScope = glslangIntermediate->usingVulkanMemoryModel() ? spv::ScopeQueueFamilyKHR : spv::ScopeDevice;\n 7316  \n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/SPIRV/SpvBuilder.h:\n  559          struct CoherentFlags {\n  560              unsigned coherent : 1;\n  561:             unsigned devicecoherent : 1;\n  562              unsigned queuefamilycoherent : 1;\n  563              unsigned workgroupcoherent : 1;\n  ...\n  569              void clear() {\n  570                  coherent = 0;\n  571:                 devicecoherent = 0;\n  572                  queuefamilycoherent = 0;\n  573                  workgroupcoherent = 0;\n  ...\n  581              CoherentFlags operator |=(const CoherentFlags &other) {\n  582                  coherent |= other.coherent;\n  583:                 devicecoherent |= other.devicecoherent;\n  584                  queuefamilycoherent |= other.queuefamilycoherent;\n  585                  workgroupcoherent |= other.workgroupcoherent;\n\n/home/max/dev/Falcor/src/USD/hgiVk/graphicsEncoder.cpp:\n    4  #include \"USD/hgiVk/commandBuffer.h\"\n    5  #include \"USD/hgiVk/conversions.h\"\n    6: #include \"USD/hgiVk/device.h\"\n    7  #include \"USD/hgiVk/diagnostic.h\"\n    8  #include \"USD/hgiVk/graphicsEncoder.h\"\n    .\n   16  \n   17  HgiVkGraphicsEncoder::HgiVkGraphicsEncoder(\n   18:     HgiVkDevice* device,\n   19      HgiVkCommandBuffer* cb,\n   20      HgiGraphicsEncoderDesc const& desc)\n   21      : HgiGraphicsEncoder()\n   22:     , _device(device)\n   23      , _commandBuffer(cb)\n   24      , _renderPass(nullptr)\n   ..\n   26      , _isRecording(true)\n   27  {\n   28:     _renderPass = device->AcquireRenderPass(desc);\n   29      _renderPass->BeginRenderPass(_commandBuffer, _isParallelEncoder);\n   30  }\n   31  \n   32  HgiVkGraphicsEncoder::HgiVkGraphicsEncoder(\n   33:     HgiVkDevice* device,\n   34      HgiVkCommandBuffer* cb,\n   35      HgiVkRenderPass* renderPass)\n   36      : HgiGraphicsEncoder()\n   37:     , _device(device)\n   38      , _commandBuffer(cb)\n   39      , _renderPass(renderPass)\n   ..\n   58      if (!_isParallelEncoder) {\n   59          _renderPass->EndRenderPass(_commandBuffer);\n   60:         _device->ReleaseRenderPass(_renderPass);\n   61      }\n   62  \n\n/home/max/dev/Falcor/src/USD/hgiVk/graphicsEncoder.h:\n   31      HGIVK_API\n   32      HgiVkGraphicsEncoder(\n   33:         HgiVkDevice* device,\n   34          HgiVkCommandBuffer* cb,\n   35          HgiGraphicsEncoderDesc const& desc);\n   ..\n   38      HGIVK_API\n   39      HgiVkGraphicsEncoder(\n   40:         HgiVkDevice* device,\n   41          HgiVkCommandBuffer* cb,\n   42          HgiVkRenderPass* renderPass);\n   ..\n   99  \n  100  private:\n  101:     HgiVkDevice* _device;\n  102      HgiVkCommandBuffer* _commandBuffer;\n  103      HgiVkRenderPass* _renderPass;\n\n/home/max/dev/Falcor/src/USD/hgiVk/hgi.cpp:\n   20  #include \"USD/hgiVk/commandBuffer.h\"\n   21  #include \"USD/hgiVk/commandBufferManager.h\"\n   22: #include \"USD/hgiVk/device.h\"\n   23  #include \"USD/hgiVk/hgi.h\"\n   24  #include \"USD/hgiVk/instance.h\"\n   ..\n   75      _instance = new HgiVkInstance();\n   76  \n   77:     // Create \"primary device\" at front of vector.\n   78      HgiVkDevice* dev = new HgiVkDevice(_instance, HgiVkPresentationType);\n   79      TF_VERIFY(dev);\n   80:     _devices.push_back(dev);\n   81  \n   82      // Make sure HgiVk is ready to modify resources or record commands.\n   ..\n   95      _frameStarted = true;\n   96  \n   97:     for (HgiVkDevice* d : _devices) {\n   98          d->BeginFrame();\n   99      }\n  ...\n  104  {\n  105      // Submit the command buffer to GPU.\n  106:     for (HgiVkDevice* d : _devices) {\n  107          d->EndFrame();\n  108      }\n  ...\n  110      _frameStarted = false;\n  111  \n  112:     // todo Defrag the AMD VulkanMemoryAllocator device->vmaAllocator\n  113      //      You need to destroy/recreate vk buffers and update descriptorSets.\n  114      //      See VMA header: defragmentation\n  ...\n  118      // Additional notes:\n  119      //      https://developer.nvidia.com/vulkan-memory-management\n  120:     //      https://ourmachinery.com/post/device-memory-management/\n  121  \n  122      // Hydra currently does not call BeginFrame() and even if it did during\n  ...\n  139      if (!_ValidateGraphicsEncoderDescriptor(desc)) return nullptr;\n  140  \n  141:     HgiVkDevice* device = GetPrimaryDevice();\n  142:     HgiVkCommandBufferManager* cbm = device->GetCommandBufferManager();\n  143      HgiVkCommandBuffer* cb = cbm->GetDrawCommandBuffer();\n  144:     HgiVkGraphicsEncoder* enc = new HgiVkGraphicsEncoder(device, cb, desc);\n  145  \n  146      return HgiGraphicsEncoderUniquePtr(enc);\n  ...\n  155      if (!_ValidateGraphicsEncoderDescriptor(desc)) return nullptr;\n  156  \n  157:     HgiVkDevice* device = GetPrimaryDevice();\n  158:     HgiVkCommandBufferManager* cbm = device->GetCommandBufferManager();\n  159      HgiVkCommandBuffer* cb = cbm->GetDrawCommandBuffer();\n  160      HgiVkParallelGraphicsEncoder* enc =\n  161:         new HgiVkParallelGraphicsEncoder(debugName, device, cb, desc, pipeline);\n  162  \n  163      return HgiParallelGraphicsEncoderUniquePtr(enc);\n  ...\n  167  HgiVk::CreateBlitEncoder()\n  168  {\n  169:     HgiVkDevice* device = GetPrimaryDevice();\n  170:     HgiVkCommandBufferManager* cbm = device->GetCommandBufferManager();\n  171      HgiVkCommandBuffer* cb = cbm->GetResourceCommandBuffer();\n  172:     return HgiBlitEncoderUniquePtr(new HgiVkBlitEncoder(device, cb));\n  173  }\n  174  \n  ...\n  176  HgiVk::CreateTexture(HgiTextureDesc const& desc)\n  177  {\n  178:     HgiVkDevice* device = GetPrimaryDevice();\n  179:     HgiVkCommandBufferManager* cbm = device->GetCommandBufferManager();\n  180      HgiVkCommandBuffer* cb = cbm->GetResourceCommandBuffer();\n  181:     HgiVkTexture* tex = new HgiVkTexture(device, cb, desc);\n  182  \n  183      // If caller provided data to copy into this texture we create a staging\n  ...\n  192          stagingDesc.data = desc.pixelData;\n  193  \n  194:         HgiVkBuffer* stagingBuffer = new HgiVkBuffer(device, stagingDesc);\n  195  \n  196          // Record the copy\n  ...\n  201          stagingObject.buffer = stagingBuffer;\n  202          stagingObject.type = HgiVkObjectTypeBuffer;\n  203:         device->DestroyObject(stagingObject);\n  204      }\n  205  \n  ...\n  211  {\n  212      if (TF_VERIFY(texHandle, \"Invalid texture\")) {\n  213:         HgiVkDevice* device = GetPrimaryDevice();\n  214          HgiVkObject object;\n  215          object.type = HgiVkObjectTypeTexture;\n  216          if (object.texture = static_cast<HgiVkTexture*>(*texHandle)) {\n  217:             device->DestroyObject(object);\n  218              *texHandle = nullptr;\n  219          }\n  ...\n  224  HgiVk::CreateBuffer(HgiBufferDesc const& desc)\n  225  {\n  226:     HgiVkDevice* device = GetPrimaryDevice();\n  227:     HgiVkCommandBufferManager* cbm = device->GetCommandBufferManager();\n  228:     HgiVkBuffer* buffer = new HgiVkBuffer(device, desc);\n  229  \n  230      // If caller provided data to copy into this buffer we create a staging\n  ...\n  239          stagingDesc.data = desc.data;\n  240  \n  241:         HgiVkBuffer* stagingBuffer = new HgiVkBuffer(device, stagingDesc);\n  242  \n  243          // Record the copy\n  ...\n  249          stagingObject.buffer = stagingBuffer;\n  250          stagingObject.type = HgiVkObjectTypeBuffer;\n  251:         device->DestroyObject(stagingObject);\n  252      }\n  253  \n  ...\n  259  {\n  260      if (TF_VERIFY(bufferHandle, \"Invalid buffer\")) {\n  261:         HgiVkDevice* device = GetPrimaryDevice();\n  262          HgiVkObject object;\n  263          object.type = HgiVkObjectTypeBuffer;\n  264          if (object.buffer = static_cast<HgiVkBuffer*>(*bufferHandle)) {\n  265:             device->DestroyObject(object);\n  266              *bufferHandle = nullptr;\n  267          }\n  ...\n  272  HgiVk::CreatePipeline(HgiPipelineDesc const& desc)\n  273  {\n  274:     HgiVkDevice* device = GetPrimaryDevice();\n  275:     return new HgiVkPipeline(device, desc);\n  276  }\n  277  \n  ...\n  280  {\n  281      if (TF_VERIFY(pipeHandle, \"Invalid pipeline\")) {\n  282:         HgiVkDevice* device = GetPrimaryDevice();\n  283          HgiVkObject object;\n  284          object.type = HgiVkObjectTypePipeline;\n  285          if (object.pipeline = static_cast<HgiVkPipeline*>(*pipeHandle)) {\n  286:             device->DestroyObject(object);\n  287              *pipeHandle = nullptr;\n  288          }\n  ...\n  293  HgiVk::CreateResourceBindings(HgiResourceBindingsDesc const& desc)\n  294  {\n  295:     HgiVkDevice* device = GetPrimaryDevice();\n  296:     return new HgiVkResourceBindings(device, desc);\n  297  }\n  298  \n  ...\n  301  {\n  302      if (TF_VERIFY(resHandle, \"Invalid resource bindings\")) {\n  303:         HgiVkDevice* device = GetPrimaryDevice();\n  304          HgiVkObject object;\n  305          object.type = HgiVkObjectTypeResourceBindings;\n  306          if (object.resourceBindings =\n  307                  static_cast<HgiVkResourceBindings*>(*resHandle)) {\n  308:             device->DestroyObject(object);\n  309              *resHandle = nullptr;\n  310          }\n  ...\n  315  HgiVk::CreateShaderFunction(HgiShaderFunctionDesc const& desc)\n  316  {\n  317:     HgiVkDevice* device = GetPrimaryDevice();\n  318:     return new HgiVkShaderFunction(device, desc);\n  319  }\n  320  \n  ...\n  323  {\n  324      if (TF_VERIFY(shaderFunctionHandle, \"Invalid shader function\")) {\n  325:         HgiVkDevice* device = GetPrimaryDevice();\n  326          HgiVkObject object;\n  327          object.type = HgiVkObjectTypeShaderFunction;\n  328          if (object.shaderFunction =\n  329                  static_cast<HgiVkShaderFunction*>(*shaderFunctionHandle)) {\n  330:             device->DestroyObject(object);\n  331              *shaderFunctionHandle = nullptr;\n  332          }\n  ...\n  344  {\n  345      if (TF_VERIFY(shaderProgramHandle, \"Invalid shader program\")) {\n  346:         HgiVkDevice* device = GetPrimaryDevice();\n  347          HgiVkObject object;\n  348          object.type = HgiVkObjectTypeShaderProgram;\n  349          if (object.shaderProgram =\n  350                  static_cast<HgiVkShaderProgram*>(*shaderProgramHandle)) {\n  351:             device->DestroyObject(object);\n  352              *shaderProgramHandle = nullptr;\n  353          }\n  ...\n  358  HgiVk::GetMemoryInfo(size_t* used, size_t* unused)\n  359  {\n  360:     // XXX for now assume they want the primary device.\n  361:     // But note we can have multiple _devices.\n  362:     HgiVkDevice* device = GetPrimaryDevice();\n  363:     device->GetDeviceMemoryInfo(used, unused);\n  364  }\n  365  \n  ...\n  367  HgiVk::GetTimeQueries()\n  368  {\n  369:     // XXX for now assume they want the primary device.\n  370:     // But note we can have multiple _devices.\n  371:     HgiVkDevice* device = GetPrimaryDevice();\n  372:     return device->GetTimeQueries();\n  373  }\n  374  \n  ...\n  376  HgiVk::GetDeviceFeatures()\n  377  {\n  378:     // XXX for now assume they want the primary device.\n  379:     // But note we can have multiple _devices.\n  380:     HgiVkDevice* device = GetPrimaryDevice();\n  381:     return device->GetDeviceFeatures();\n  382  }\n  383  \n  ...\n  397  HgiVk::GetPrimaryDevice() const\n  398  {\n  399:     if (_devices.empty()) return nullptr;\n  400:     return _devices.front();\n  401  }\n  402  \n  ...\n  404  HgiVk::CreateSurface(HgiVkSurfaceDesc const& desc)\n  405  {\n  406:     HgiVkDevice* device = GetPrimaryDevice();\n  407:     return new HgiVkSurface(_instance, device, desc);\n  408  }\n  409  \n  ...\n  412  {\n  413      if (TF_VERIFY(surfaceHandle, \"Invalid surface\")) {\n  414:         HgiVkDevice* device = GetPrimaryDevice();\n  415          HgiVkObject object;\n  416          object.type = HgiVkObjectTypeSurface;\n  417          if (object.surface = *surfaceHandle) {\n  418:             device->DestroyObject(object);\n  419              *surfaceHandle = nullptr;\n  420          }\n  ...\n  425  HgiVk::CreateSwapchain(HgiVkSurfaceHandle surfaceHandle)\n  426  {\n  427:     HgiVkDevice* device = GetPrimaryDevice();\n  428:     return new HgiVkSwapchain(device, surfaceHandle);\n  429  }\n  430  \n  ...\n  433  {\n  434      if (TF_VERIFY(swapchainHandle, \"Invalid swapchain\")) {\n  435:         HgiVkDevice* device = GetPrimaryDevice();\n  436          HgiVkObject object;\n  437          object.type = HgiVkObjectTypeSwapchain;\n  438          if (object.swapchain = *swapchainHandle) {\n  439:             device->DestroyObject(object);\n  440              *swapchainHandle = nullptr;\n  441          }\n  ...\n  446  HgiVk::DestroyHgiVk()\n  447  {\n  448:     for (HgiVkDevice* device : _devices) {\n  449:         delete device;\n  450      }\n  451:     _devices.clear();\n  452  \n  453      delete _instance;\n\n/home/max/dev/Falcor/src/USD/hgiVk/hgi.h:\n  119      void* GetVkInstance();\n  120  \n  121:     // Returns the primary device. This device must support presentation and\n  122      // resource creation.\n  123      HGIVK_API\n  ...\n  140      void DestroySwapchain(HgiVkSwapchainHandle* swapchainHandle);\n  141  \n  142:     /// Destroys all devices and vulkan instance.\n  143      /// Should be called once during application shutdown.\n  144      HGIVK_API\n  ...\n  159  private:\n  160      HgiVkInstance* _instance;\n  161:     HgiVkDeviceVector _devices;\n  162      bool _frameStarted;\n  163  };\n\n/home/max/dev/Falcor/src/USD/hgiVk/parallelGraphicsEncoder.cpp:\n    3  #include \"USD/hgiVk/commandBuffer.h\"\n    4  #include \"USD/hgiVk/commandBufferManager.h\"\n    5: #include \"USD/hgiVk/device.h\"\n    6  #include \"USD/hgiVk/diagnostic.h\"\n    7  #include \"USD/hgiVk/graphicsEncoder.h\"\n    .\n   17  HgiVkParallelGraphicsEncoder::HgiVkParallelGraphicsEncoder(\n   18      const char* debugName,\n   19:     HgiVkDevice* device,\n   20      HgiVkCommandBuffer* primaryCB,\n   21      HgiGraphicsEncoderDesc const& desc,\n   22      HgiPipelineHandle pipeline)\n   23      : HgiParallelGraphicsEncoder(debugName)\n   24:     , _device(device)\n   25      , _primaryCommandBuffer(primaryCB)\n   26      , _renderPass(nullptr)\n   ..\n   36      // Make sure there are enough secondary commmand buffer for this parallel\n   37      // encoder to use during CreateGraphicsEncoder().\n   38:     HgiVkCommandBufferManager* cbm = _device->GetCommandBufferManager();\n   39      _cmdBufBlockId = cbm->ReserveSecondaryDrawBuffersForParallelEncoder();\n   40  \n   ..\n   43      // individual graphics encoders that are used in the threads.\n   44      // This will ensure the load op for each attachment happens once.\n   45:     _renderPass = device->AcquireRenderPass(desc);\n   46      _renderPass->BeginRenderPass(_primaryCommandBuffer, /*use secondary*/ true);\n   47  \n   ..\n   69  {\n   70      // Record secondary cmd bufs into primary cmd buf\n   71:     HgiVkCommandBufferManager* cbm = _device->GetCommandBufferManager();\n   72      cbm->ExecuteSecondaryCommandBuffers(_cmdBufBlockId, _primaryCommandBuffer);\n   73  \n   74      // End the render pass (perform store ops)\n   75      _renderPass->EndRenderPass(_primaryCommandBuffer);\n   76:     _device->ReleaseRenderPass(_renderPass);\n   77  \n   78      if (_isDebugging) {\n   ..\n   96  \n   97      // Get thread_local secondary command buffer\n   98:     HgiVkCommandBufferManager* cbm = _device->GetCommandBufferManager();\n   99      HgiVkCommandBuffer* cb = cbm->GetSecondaryDrawCommandBuffer(_cmdBufBlockId);\n  100  \n  ...\n  104      // Create the graphics encoder passing it our already started render pass.\n  105      HgiVkGraphicsEncoder* enc = new HgiVkGraphicsEncoder(\n  106:         _device, cb, _renderPass);\n  107  \n  108      return HgiGraphicsEncoderUniquePtr(enc);\n\n/home/max/dev/Falcor/src/USD/hgiVk/parallelGraphicsEncoder.h:\n   29      HgiVkParallelGraphicsEncoder(\n   30          const char* debugName,\n   31:         HgiVkDevice* device,\n   32          HgiVkCommandBuffer* primaryCB,\n   33          HgiGraphicsEncoderDesc const& desc,\n   ..\n   51  \n   52  private:\n   53:     HgiVkDevice* _device;\n   54      HgiVkCommandBuffer* _primaryCommandBuffer;\n   55      HgiVkRenderPass* _renderPass;\n\n/home/max/dev/Falcor/src/USD/hgiVk/pipeline.cpp:\n    5  #include \"USD/hgiVk/commandBuffer.h\"\n    6  #include \"USD/hgiVk/conversions.h\"\n    7: #include \"USD/hgiVk/device.h\"\n    8  #include \"USD/hgiVk/diagnostic.h\"\n    9  #include \"USD/hgiVk/pipeline.h\"\n   ..\n   14  \n   15  HgiVkPipeline::HgiVkPipeline(\n   16:     HgiVkDevice* device,\n   17      HgiPipelineDesc const& desc)\n   18      : HgiPipeline(desc)\n   19:     , _device(device)\n   20      , _descriptor(desc)\n   21      , _vkTopology(VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST)\n   ..\n   31      for (_Pipeline p : _pipelines) {\n   32          vkDestroyPipeline(\n   33:             _device->GetVulkanDevice(),\n   34              p.vkPipeline,\n   35              HgiVkAllocator());\n   ..\n  313      // Render pass\n  314      //\n  315:     HgiVkRenderPass* renderPass = _device->AcquireRenderPass(rpDesc);\n  316      pipeCreateInfo.renderPass = renderPass->GetVulkanRenderPass();\n  317  \n  ...\n  324      // xxx we need to add a pipeline cache to avoid app having to keep compiling\n  325      // shader micro-code for every pipeline combination. We except that the\n  326:     // spir-V shader code is not compiled for the target device until this point\n  327      // where we create the pipeline. So a pipeline cache can be helpful.\n  328      // https://zeux.io/2019/07/17/serializing-pipeline-cache/\n  329      TF_VERIFY(\n  330          vkCreateGraphicsPipelines(\n  331:             _device->GetVulkanDevice(),\n  332:             _device->GetVulkanPipelineCache(),\n  333              1,\n  334              &pipeCreateInfo,\n  ...\n  343          std::string debugLabel = \"Graphics Pipeline \" + _descriptor.debugName;\n  344          HgiVkSetDebugName(\n  345:             _device,\n  346              (uint64_t)pipeline.vkPipeline,\n  347              VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT,\n  ...\n  399      TF_VERIFY(\n  400          vkCreateComputePipelines(\n  401:             _device->GetVulkanDevice(),\n  402:             _device->GetVulkanPipelineCache(),\n  403              1,\n  404              &pipeCreateInfo,\n  ...\n  411          std::string debugLabel = \"Compute Pipeline \" + _descriptor.debugName;\n  412          HgiVkSetDebugName(\n  413:             _device,\n  414              (uint64_t)pipeline.vkPipeline,\n  415              VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT,\n\n/home/max/dev/Falcor/src/USD/hgiVk/pipeline.h:\n   27      HGIVK_API\n   28      HgiVkPipeline(\n   29:         HgiVkDevice* device,\n   30          HgiPipelineDesc const& desc);\n   31  \n   ..\n   65  \n   66  private:\n   67:     HgiVkDevice* _device;\n   68      HgiPipelineDesc _descriptor;\n   69      std::vector<_Pipeline> _pipelines;\n\n/home/max/dev/Falcor/src/USD/hgiVk/renderPass.cpp:\n    3  #include \"USD/hgiVk/commandBuffer.h\"\n    4  #include \"USD/hgiVk/conversions.h\"\n    5: #include \"USD/hgiVk/device.h\"\n    6  #include \"USD/hgiVk/diagnostic.h\"\n    7  #include \"USD/hgiVk/renderPass.h\"\n    .\n   10  \n   11  HgiVkRenderPass::HgiVkRenderPass(\n   12:     HgiVkDevice* device,\n   13      HgiGraphicsEncoderDesc const& desc)\n   14:     : _device(device)\n   15      , _descriptor(desc)\n   16      , _vkRenderPass(nullptr)\n   ..\n   28  \n   29      // Prevent the render pass cache from deleting this render pass.\n   30:     _lastUsedFrame = _device->GetCurrentFrame();\n   31  \n   32      //\n   ..\n  174      TF_VERIFY(\n  175          VK_CREATE_RENDERPASS(\n  176:             _device->GetVulkanDevice(),\n  177              &renderPassInfo,\n  178              HgiVkAllocator(),\n  ...\n  184          std::string debugLabel = \"Render Pass \" + _descriptor.debugName;\n  185          HgiVkSetDebugName(\n  186:             _device,\n  187              (uint64_t)_vkRenderPass,\n  188              VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT,\n  ...\n  201      TF_VERIFY(\n  202          vkCreateFramebuffer(\n  203:             _device->GetVulkanDevice(),\n  204              &fbufCreateInfo,\n  205              HgiVkAllocator(),\n  ...\n  211          std::string debugLabel = \"Framebuffer \" + _descriptor.debugName;\n  212          HgiVkSetDebugName(\n  213:             _device,\n  214              (uint64_t)_vkFramebuffer,\n  215              VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT,\n  ...\n  221  {\n  222      vkDestroyFramebuffer(\n  223:         _device->GetVulkanDevice(),\n  224          _vkFramebuffer,\n  225          HgiVkAllocator());\n  226  \n  227      vkDestroyRenderPass(\n  228:         _device->GetVulkanDevice(),\n  229          _vkRenderPass,\n  230          HgiVkAllocator());\n  ...\n  250  {\n  251      // Prevent the render pass cache from deleting this render pass\n  252:     _lastUsedFrame = _device->GetCurrentFrame();\n  253  \n  254      // Begin render pass in primary command buffer\n\n/home/max/dev/Falcor/src/USD/hgiVk/renderPass.h:\n   44      #define VK_SUBPASS_DEPENDENCY VkSubpassDependency2KHR\n   45      #define VK_SUBPASS_DEPENDENCY_TYPE VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR\n   46:     #define VK_CREATE_RENDERPASS device->vkCreateRenderPass2KHR\n   47  #endif\n   48  \n   ..\n   55      HGIVK_API\n   56      HgiVkRenderPass(\n   57:         HgiVkDevice* device,\n   58          HgiGraphicsEncoderDesc const& desc);\n   59  \n   ..\n  132  \n  133  private:\n  134:     HgiVkDevice* _device;\n  135      HgiGraphicsEncoderDesc _descriptor;\n  136  \n\n/home/max/dev/Falcor/src/USD/hgiVk/renderPassPipelineCache.cpp:\n    5  #include \"pxr/imaging/hgi/graphicsEncoderDesc.h\"\n    6  \n    7: #include \"USD/hgiVk/device.h\"\n    8  #include \"USD/hgiVk/hgi.h\"\n    9  #include \"USD/hgiVk/object.h\"\n   ..\n   25          object.type = HgiVkObjectTypeRenderPass;\n   26          object.renderPass = renderPass;\n   27:         device->DestroyObject(object);\n   28      }\n   29  \n   30:     HgiVkDevice* device = nullptr;\n   31      HgiGraphicsEncoderDesc descriptor;\n   32      HgiVkRenderPass* renderPass = nullptr;\n   ..\n   46  static HgiVkRenderPassCacheItem*\n   47  _CreateRenderPassCacheItem(\n   48:     HgiVkDevice* device,\n   49      const HgiGraphicsEncoderDesc& desc)\n   50  {\n   51      HgiVkRenderPassCacheItem* rci = new HgiVkRenderPassCacheItem();\n   52:     rci->device = device;\n   53      rci->descriptor = desc;\n   54:     rci->renderPass = new HgiVkRenderPass(device, desc);\n   55      return rci;\n   56  }\n   ..\n  113  HgiVkRenderPass*\n  114  HgiVkRenderPassPipelineCache::AcquireRenderPass(\n  115:     HgiVkDevice* device,\n  116      HgiGraphicsEncoderDesc const& desc)\n  117  {\n  ...\n  163      // This new render pass will get merged into the renderPassCache at the\n  164      // end of the frame.\n  165:     HgiVkRenderPassCacheItem* pci = _CreateRenderPassCacheItem(device, desc);\n  166      pv.push_back(pci);\n  167      return pci->renderPass;\n\n/home/max/dev/Falcor/src/USD/hgiVk/renderPassPipelineCache.h:\n   51      HGIVK_API\n   52      HgiVkRenderPass* AcquireRenderPass(\n   53:         HgiVkDevice* device,\n   54          HgiGraphicsEncoderDesc const& desc);\n   55  \n   ..\n   65      /// Clears all render pass from cache.\n   66      /// This initiates destruction of all render passes and should generally\n   67:     /// only be called when the device is being destroyed.\n   68      HGIVK_API\n   69      void Clear();\n\n/home/max/dev/Falcor/src/USD/hgiVk/resourceBindings.cpp:\n    4  #include \"USD/hgiVk/commandBuffer.h\"\n    5  #include \"USD/hgiVk/conversions.h\"\n    6: #include \"USD/hgiVk/device.h\"\n    7  #include \"USD/hgiVk/diagnostic.h\"\n    8  #include \"USD/hgiVk/resourceBindings.h\"\n    .\n   13  \n   14  HgiVkResourceBindings::HgiVkResourceBindings(\n   15:     HgiVkDevice* device,\n   16      HgiResourceBindingsDesc const& desc)\n   17      : HgiResourceBindings(desc)\n   18:     , _device(device)\n   19      , _descriptor(desc)\n   20      , _vkDescriptorSetLayout(nullptr)\n   ..\n   78      // Check descriptor indexing support.\n   79      VkPhysicalDeviceDescriptorIndexingFeaturesEXT indexingFeatures =\n   80:         _device->GetVulkanPhysicalDeviceIndexingFeatures();\n   81      VkDescriptorBindingFlagsEXT bindFlags = 0;\n   82  \n   ..\n  114      TF_VERIFY(\n  115          vkCreateDescriptorSetLayout(\n  116:             _device->GetVulkanDevice(),\n  117              &setCreateInfo,\n  118              HgiVkAllocator(),\n  ...\n  124          std::string debugLabel = \"Descriptor Set Layout \" + _descriptor.debugName;\n  125          HgiVkSetDebugName(\n  126:             _device,\n  127              (uint64_t)_vkDescriptorSetLayout,\n  128              VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT,\n  ...\n  163      TF_VERIFY(\n  164          vkCreateDescriptorPool(\n  165:             _device->GetVulkanDevice(),\n  166              &pool_info,\n  167              HgiVkAllocator(),\n  ...\n  173          std::string debugLabel = \"Descriptor Pool \" + _descriptor.debugName;\n  174          HgiVkSetDebugName(\n  175:             _device,\n  176              (uint64_t)_vkDescriptorPool,\n  177              VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT,\n  ...\n  191      TF_VERIFY(\n  192          vkAllocateDescriptorSets(\n  193:             _device->GetVulkanDevice(),\n  194              &allocateInfo,\n  195              &_vkDescriptorSet) == VK_SUCCESS\n  ...\n  200          std::string debugLabel = \"Descriptor Set \" + _descriptor.debugName;\n  201          HgiVkSetDebugName(\n  202:             _device,\n  203              (uint64_t)_vkDescriptorSet,\n  204              VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT,\n  ...\n  210      //\n  211      VkPhysicalDeviceProperties const& devProps =\n  212:         _device->GetVulkanPhysicalDeviceProperties();\n  213      VkPhysicalDeviceLimits const& limits = devProps.limits;\n  214  \n  ...\n  318      // command buffer recording.\n  319      vkUpdateDescriptorSets(\n  320:         _device->GetVulkanDevice(),\n  321          (uint32_t) writeSets.size(),\n  322          writeSets.data(),\n  ...\n  349      TF_VERIFY(\n  350          vkCreatePipelineLayout(\n  351:             _device->GetVulkanDevice(),\n  352              &pipeLayCreateInfo,\n  353              HgiVkAllocator(),\n  ...\n  359          std::string debugLabel = \"Pipeline Layout \" + _descriptor.debugName;\n  360          HgiVkSetDebugName(\n  361:             _device,\n  362              (uint64_t)_vkPipelineLayout,\n  363              VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT,\n  ...\n  369  {\n  370      vkDestroyDescriptorSetLayout(\n  371:         _device->GetVulkanDevice(),\n  372          _vkDescriptorSetLayout,\n  373          HgiVkAllocator());\n  374  \n  375      vkDestroyPipelineLayout(\n  376:         _device->GetVulkanDevice(),\n  377          _vkPipelineLayout,\n  378          HgiVkAllocator());\n  ...\n  383      // if (_vkDescriptorSet) {\n  384      //     vkFreeDescriptorSets(\n  385:     //         _device->GetVulkanDevice(),\n  386      //         _vkDescriptorPool,\n  387      //         1,\n  ...\n  390      //\n  391      vkDestroyDescriptorPool(\n  392:         _device->GetVulkanDevice(),\n  393          _vkDescriptorPool,\n  394          HgiVkAllocator());\n\n/home/max/dev/Falcor/src/USD/hgiVk/resourceBindings.h:\n   27  /// There is a limit to how many descriptor sets that can be bound at one time.\n   28  /// Aiming for 4 seems like a safe minimum:\n   29: /// http://vulkan.gpuinfo.org/displaydevicelimit.php?name=maxBoundDescriptorSets\n   30  ///\n   31  /// This does not affect how many sets you can make, but you likely want to\n   ..\n   39      HGIVK_API\n   40      HgiVkResourceBindings(\n   41:         HgiVkDevice* device,\n   42          HgiResourceBindingsDesc const& desc);\n   43  \n   ..\n   83  \n   84  private:\n   85:     HgiVkDevice* _device;\n   86      HgiResourceBindingsDesc _descriptor;\n   87  \n\n/home/max/dev/Falcor/src/USD/hgiVk/shaderFunction.cpp:\n    2  \n    3  #include \"USD/hgiVk/conversions.h\"\n    4: #include \"USD/hgiVk/device.h\"\n    5  #include \"USD/hgiVk/diagnostic.h\"\n    6  #include \"USD/hgiVk/shaderFunction.h\"\n    .\n   10  \n   11  HgiVkShaderFunction::HgiVkShaderFunction(\n   12:     HgiVkDevice* device,\n   13      HgiShaderFunctionDesc const& desc)\n   14      : HgiShaderFunction(desc)\n   15:     , _device(device)\n   16      , _descriptor(desc)\n   17      , _vkShaderModule(nullptr)\n   ..\n   20          {VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO};\n   21  \n   22:     HgiVkShaderCompiler* shaderCompiler = device->GetShaderCompiler();\n   23  \n   24      std::vector<unsigned int> spirv;\n   ..\n   42          TF_VERIFY(\n   43              vkCreateShaderModule(\n   44:                 _device->GetVulkanDevice(),\n   45                  &shaderCreateInfo,\n   46                  HgiVkAllocator(),\n   ..\n   52              std::string debugLabel = \"ShaderModule \" + _descriptor.debugName;\n   53              HgiVkSetDebugName(\n   54:                 _device,\n   55                  (uint64_t)_vkShaderModule,\n   56                  VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT,\n   ..\n   64      if (_vkShaderModule) {\n   65          vkDestroyShaderModule(\n   66:             _device->GetVulkanDevice(),\n   67              _vkShaderModule,\n   68              HgiVkAllocator());\n\n/home/max/dev/Falcor/src/USD/hgiVk/shaderFunction.h:\n   21      HGIVK_API\n   22      HgiVkShaderFunction(\n   23:         HgiVkDevice* device,\n   24          HgiShaderFunctionDesc const& desc);\n   25  \n   ..\n   53  \n   54  private:\n   55:     HgiVkDevice* _device;\n   56      HgiShaderFunctionDesc _descriptor;\n   57      std::string _errors;\n\n/home/max/dev/Falcor/src/USD/hgiVk/surface.cpp:\n    1  #include \"pxr/base/tf/diagnostic.h\"\n    2  \n    3: #include \"USD/hgiVk/device.h\"\n    4  #include \"USD/hgiVk/instance.h\"\n    5  #include \"USD/hgiVk/surface.h\"\n    .\n   83  HgiVkSurface::HgiVkSurface(\n   84      HgiVkInstance* instance,\n   85:     HgiVkDevice* device,\n   86      HgiVkSurfaceDesc const& desc)\n   87      : _instance(instance)\n   ..\n   98      TF_VERIFY(\n   99          vkGetPhysicalDeviceSurfaceSupportKHR(\n  100:             device->GetVulkanPhysicalDevice(),\n  101:             device->GetVulkanDeviceQueueFamilyIndex(),\n  102              _vkSurface,\n  103              &presentSupported) == VK_SUCCESS\n  104      );\n  105  \n  106:     TF_VERIFY(presentSupported, \"Presenting not supported on Vulkan device\");\n  107  }\n  108  \n\n/home/max/dev/Falcor/src/USD/hgiVk/surface.h:\n   42      HgiVkSurface(\n   43          HgiVkInstance* instance,\n   44:         HgiVkDevice* device,\n   45          HgiVkSurfaceDesc const& desc);\n   46  \n\n/home/max/dev/Falcor/src/USD/hgiVk/swapchain.cpp:\n    3  #include \"USD/hgiVk/commandBuffer.h\"\n    4  #include \"USD/hgiVk/conversions.h\"\n    5: #include \"USD/hgiVk/device.h\"\n    6  #include \"USD/hgiVk/diagnostic.h\"\n    7  #include \"USD/hgiVk/renderPass.h\"\n    .\n   36  static VkFormat\n   37  _GetSurfaceFormat(\n   38:     HgiVkDevice* device,\n   39      HgiVkSurface* surface)\n   40  {\n   ..\n   42      TF_VERIFY(\n   43          vkGetPhysicalDeviceSurfaceFormatsKHR(\n   44:             device->GetVulkanPhysicalDevice(),\n   45              surface->GetVulkanSurface(),\n   46              &formatCount,\n   ..\n   53      TF_VERIFY(\n   54          vkGetPhysicalDeviceSurfaceFormatsKHR(\n   55:             device->GetVulkanPhysicalDevice(),\n   56              surface->GetVulkanSurface(),\n   57              &formatCount,\n   ..\n   76  static void\n   77  _DestroyVulkanSwapchain(\n   78:     HgiVkDevice* device,\n   79      VkSwapchainKHR vkSwapchain,\n   80      VkSemaphore vkAcquireSemaphore,\n   ..\n   83  {\n   84      TF_VERIFY(\n   85:         vkDeviceWaitIdle(device->GetVulkanDevice()) == VK_SUCCESS\n   86      );\n   87  \n   88      for (uint32_t i = 0; i < vkImageViews.size(); i++) {\n   89          vkDestroyImageView(\n   90:             device->GetVulkanDevice(),\n   91              vkImageViews[i],\n   92              HgiVkAllocator());\n   ..\n   94  \n   95      vkDestroySwapchainKHR(\n   96:         device->GetVulkanDevice(),\n   97          vkSwapchain,\n   98          HgiVkAllocator());\n   99  \n  100      vkDestroySemaphore(\n  101:         device->GetVulkanDevice(),\n  102          vkReleaseSemaphore,\n  103          HgiVkAllocator());\n  104  \n  105      vkDestroySemaphore(\n  106:         device->GetVulkanDevice(),\n  107          vkAcquireSemaphore,\n  108          HgiVkAllocator());\n  ...\n  110  \n  111  HgiVkSwapchain::HgiVkSwapchain(\n  112:     HgiVkDevice* device,\n  113      HgiVkSurfaceHandle surface)\n  114:     : _device(device)\n  115      , _surface(surface)\n  116      , _width(0)\n  ...\n  130      _PreDestroyVulkanSwapchain();\n  131      _DestroyVulkanSwapchain(\n  132:         _device,\n  133          _vkSwapchain,\n  134          _vkAcquireSemaphore,\n  ...\n  213      TF_VERIFY(\n  214          vkQueueSubmit(\n  215:             _device->GetVulkanDeviceQueue(),\n  216              1,\n  217              &submitInfo,\n  ...\n  229  \n  230      VkResult res = vkQueuePresentKHR(\n  231:         _device->GetVulkanDeviceQueue(),\n  232          &vkPresentInfo);\n  233  \n  ...\n  269      TF_VERIFY(\n  270          vkGetPhysicalDeviceSurfaceCapabilitiesKHR(\n  271:             _device->GetVulkanPhysicalDevice(),\n  272              _surface->GetVulkanSurface(),\n  273              &surfaceCaps) == VK_SUCCESS\n  ...\n  276      _width = surfaceCaps.currentExtent.width;\n  277      _height = surfaceCaps.currentExtent.height;\n  278:     _vkSwapchainFormat = _GetSurfaceFormat(_device, _surface);\n  279  \n  280      //\n  ...\n  310          VK_IMAGE_USAGE_TRANSFER_DST_BIT;      // for blitting\n  311      swapCreateInfo.queueFamilyIndexCount = 1;\n  312:     uint32_t queueFamilyIndex = _device->GetVulkanDeviceQueueFamilyIndex();\n  313      swapCreateInfo.pQueueFamilyIndices = &queueFamilyIndex;\n  314      swapCreateInfo.preTransform = VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR;\n  ...\n  319      TF_VERIFY(\n  320          vkCreateSwapchainKHR(\n  321:             _device->GetVulkanDevice(),\n  322              &swapCreateInfo,\n  323              HgiVkAllocator(),\n  ...\n  330          std::string debugLabel = \"Swapchain HgiVk\";\n  331          HgiVkSetDebugName(\n  332:             _device,\n  333              (uint64_t)_vkSwapchain,\n  334              VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT,\n  ...\n  342      TF_VERIFY(\n  343          vkGetSwapchainImagesKHR(\n  344:             _device->GetVulkanDevice(),\n  345              _vkSwapchain,\n  346              &imageCount,\n  ...\n  355      TF_VERIFY(\n  356          vkGetSwapchainImagesKHR(\n  357:             _device->GetVulkanDevice(),\n  358              _vkSwapchain,\n  359              &imageCount,\n  ...\n  368      TF_VERIFY(\n  369          vkCreateSemaphore(\n  370:             _device->GetVulkanDevice(),\n  371              &semaCreateInfo,\n  372              HgiVkAllocator(),\n  ...\n  378          std::string debugLabel = \"Semaphore Acquire HgiVk Swapchain\";\n  379          HgiVkSetDebugName(\n  380:             _device,\n  381              (uint64_t)_vkAcquireSemaphore,\n  382              VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT,\n  ...\n  386      TF_VERIFY(\n  387          vkCreateSemaphore(\n  388:             _device->GetVulkanDevice(),\n  389              &semaCreateInfo,\n  390              HgiVkAllocator(),\n  ...\n  396          std::string debugLabel = \"Semaphore Release HgiVk Swapchain\";\n  397          HgiVkSetDebugName(\n  398:             _device,\n  399              (uint64_t)_vkReleaseSemaphore,\n  400              VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT,\n  ...\n  417          TF_VERIFY(\n  418              vkCreateImageView(\n  419:                 _device->GetVulkanDevice(),\n  420                  &createInfo,\n  421                  HgiVkAllocator(),\n  ...\n  429                                       \" HgiVk Swapchain\";\n  430              HgiVkSetDebugName(\n  431:                 _device,\n  432                  (uint64_t)_vkImageViews[i],\n  433                  VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT,\n  ...\n  460          texVkDesc.sampler = nullptr;\n  461  \n  462:         HgiVkTexture* tex = new HgiVkTexture(_device, texDesc, texVkDesc);\n  463          _textures[i] = tex;\n  464      }\n  ...\n  479          renderPassDesc.colorAttachments.emplace_back(std::move(attachment));\n  480  \n  481:         HgiVkRenderPass* rp = _device->AcquireRenderPass(renderPassDesc);\n  482          _renderPasses.push_back(rp);\n  483      }\n  ...\n  519      _CreateVulkanSwapchain();\n  520      _DestroyVulkanSwapchain(\n  521:         _device,\n  522          vkSwapchain,\n  523          vkAcquireSemaphore,\n  ...\n  532      TF_VERIFY(\n  533          vkGetPhysicalDeviceSurfaceCapabilitiesKHR(\n  534:             _device->GetVulkanPhysicalDevice(),\n  535              _surface->GetVulkanSurface(),\n  536              &surfaceCaps) == VK_SUCCESS\n  ...\n  551  {\n  552      return vkAcquireNextImageKHR(\n  553:         _device->GetVulkanDevice(),\n  554          _vkSwapchain,\n  555          ~0ull,\n\n/home/max/dev/Falcor/src/USD/hgiVk/swapchain.h:\n   27      HGIVK_API\n   28      HgiVkSwapchain(\n   29:         HgiVkDevice* device,\n   30          HgiVkSurfaceHandle surface);\n   31  \n   ..\n   78  \n   79  private:\n   80:     HgiVkDevice* _device;\n   81      HgiVkSurface* _surface;\n   82  \n\n/home/max/dev/Falcor/src/USD/hgiVk/texture.cpp:\n    1: #include \"USD/hgiVk/device.h\"\n    2  #include \"USD/hgiVk/diagnostic.h\"\n    3  #include \"USD/hgiVk/commandBuffer.h\"\n    .\n   20  \n   21  HgiVkTexture::HgiVkTexture(\n   22:     HgiVkDevice* device,\n   23      HgiVkCommandBuffer* cb,\n   24      HgiTextureDesc const & desc)\n   25      : HgiTexture(desc)\n   26:     , _device(device)\n   27      , _descriptor(desc)\n   28      , _vkImage(nullptr)\n   29      , _vmaImageAllocation(nullptr)\n   30  {\n   31:     TF_VERIFY(device && cb);\n   32  \n   33      VkPhysicalDeviceProperties const& vkDeviceProps =\n   34:         device->GetVulkanPhysicalDeviceProperties();\n   35  \n   36      VkPhysicalDeviceFeatures const& vkDeviceFeatures =\n   37:         device->GetVulkanPhysicalDeviceFeatures();\n   38  \n   39      GfVec3i const& dimensions = desc.dimensions;\n   ..\n   71  \n   72      if (!_CheckFormatSupport(\n   73:             device->GetVulkanPhysicalDevice(),\n   74              imageCreateInfo.format,\n   75              formatValidationFlags)) {\n   76:         TF_CODING_ERROR(\"Image format not supported on device\");\n   77      };\n   78  \n   ..\n   86      TF_VERIFY(\n   87          vmaCreateImage(\n   88:             device->GetVulkanMemoryAllocator(),\n   89              &imageCreateInfo,\n   90              &allocInfo,\n   ..\n   98          std::string debugLabel = \"Image \" + _descriptor.debugName;\n   99          HgiVkSetDebugName(\n  100:             _device,\n  101              (uint64_t)_vkImage,\n  102              VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT,\n  ...\n  133      TF_VERIFY(\n  134          vkCreateSampler(\n  135:             device->GetVulkanDevice(),\n  136              &sampler,\n  137              HgiVkAllocator(),\n  ...\n  143          std::string debugLabel = \"Sampler \" + _descriptor.debugName;\n  144          HgiVkSetDebugName(\n  145:             _device,\n  146              (uint64_t)_vkDescriptor.sampler,\n  147              VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT,\n  ...\n  192      TF_VERIFY(\n  193          vkCreateImageView(\n  194:             device->GetVulkanDevice(),\n  195              &view,\n  196              HgiVkAllocator(),\n  ...\n  202          std::string debugLabel = \"Image View \" + _descriptor.debugName;\n  203          HgiVkSetDebugName(\n  204:             _device,\n  205              (uint64_t)_vkDescriptor.imageView,\n  206              VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT,\n  ...\n  247  \n  248  HgiVkTexture::HgiVkTexture(\n  249:     HgiVkDevice* device,\n  250      HgiTextureDesc const & desc,\n  251      VkDescriptorImageInfo const& vkDesc)\n  252      : HgiTexture(desc)\n  253:     , _device(device)\n  254      , _descriptor(desc)\n  255      , _vkDescriptor(vkDesc)\n  ...\n  274  \n  275      vkDestroyImageView(\n  276:         _device->GetVulkanDevice(),\n  277          _vkDescriptor.imageView,\n  278          HgiVkAllocator());\n  279  \n  280      vkDestroySampler(\n  281:         _device->GetVulkanDevice(),\n  282          _vkDescriptor.sampler,\n  283          HgiVkAllocator());\n  284  \n  285      vmaDestroyImage(\n  286:         _device->GetVulkanMemoryAllocator(),\n  287          _vkImage,\n  288          _vmaImageAllocation);\n\n/home/max/dev/Falcor/src/USD/hgiVk/texture.h:\n   26      HGIVK_API\n   27      HgiVkTexture(\n   28:         HgiVkDevice* device,\n   29          HgiVkCommandBuffer* cb,\n   30          HgiTextureDesc const & desc);\n   ..\n   33      HGIVK_API\n   34      HgiVkTexture(\n   35:         HgiVkDevice* device,\n   36          HgiTextureDesc const & desc,\n   37          VkDescriptorImageInfo const& vkDesc);\n   ..\n   85  \n   86  private:\n   87:     HgiVkDevice* _device;\n   88  \n   89      HgiTextureDesc _descriptor;\n\n/home/max/dev/Falcor/src/USD/hgiVk/vulkanMemoryAllocator/vk_mem_alloc.h:\n  156  VmaAllocatorCreateInfo allocatorInfo = {};\n  157  allocatorInfo.physicalDevice = physicalDevice;\n  158: allocatorInfo.device = device;\n  159  \n  160  VmaAllocator allocator;\n  ...\n  194  \\page choosing_memory_type Choosing memory type\n  195  \n  196: Physical devices in Vulkan support various combinations of memory heaps and\n  197  types. Help with choosing correct and optimal memory type for your specific\n  198  resource is one of the key features of this library. You can use it by filling\n  ...\n  203     can use function: vmaFindMemoryTypeIndex(), vmaFindMemoryTypeIndexForBufferInfo(),\n  204     vmaFindMemoryTypeIndexForImageInfo().\n  205: -# If you want to allocate a region of device memory without association with any\n  206     specific image or buffer, you can use function vmaAllocateMemory(). Usage of\n  207     this function is not recommended and usually not needed.\n  ...\n  280  \\section choosing_memory_type_explicit_memory_types Explicit memory types\n  281  \n  282: If you inspected memory types available on the physical device and you have\n  283  a preference for memory types that you want to use, you can fill member\n  284  VmaAllocationCreateInfo::memoryTypeBits. It is a bit mask, where each bit set\n  ...\n  325  - When [VK_KHR_dedicated_allocation](@ref vk_khr_dedicated_allocation) extension is enabled\n  326    and it reports that dedicated allocation is required or recommended for the resource.\n  327: - When allocation of next big memory block fails due to not enough device memory,\n  328    but allocation with the exact requested size succeeds.\n  329  \n  ...\n  375  When mapping, you may see a warning from Vulkan validation layer similar to this one:\n  376  \n  377: <i>Mapping an image with layout VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL can result in undefined behavior if this memory is used by the device. Only GENERAL or PREINITIALIZED should be used.</i>\n  378  \n  379  It happens because the library maps entire `VkDeviceMemory` block, where different\n  ...\n  415  \n  416  - When operating system is Windows 7 or 8.x (Windows 10 is not affected because it uses WDDM2),\n  417:   device is discrete AMD GPU,\n  418    and memory type is the special 256 MiB pool of `DEVICE_LOCAL + HOST_VISIBLE` memory\n  419    (selected when you use #VMA_MEMORY_USAGE_CPU_TO_GPU),\n  ...\n  554  only to obtain statistical information, e.g. for debugging purposes.\n  555  \n  556: It is recommended to use <b>VK_EXT_memory_budget</b> device extension to obtain information\n  557: about the budget from Vulkan device. VMA is able to use this extension automatically.\n  558  When not enabled, the allocator behaves same way, but then it estimates current usage\n  559  and available budget based on its internal information and Vulkan memory heap sizes,\n  560  which may be less precise. In order to use this extension:\n  561  \n  562: 1. Make sure extensions VK_EXT_memory_budget and VK_KHR_get_physical_device_properties2\n  563:    required by it are available and enable them. Please note that the first is a device\n  564     extension and the second is instance extension!\n  565  2. Use flag #VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT when creating #VmaAllocator object.\n  ...\n  603  \n  604  A memory pool contains a number of `VkDeviceMemory` blocks.\n  605: The library automatically creates and manages default pool for each memory type available on the device.\n  606  Default memory pool automatically grows in size.\n  607  Size of allocated blocks is also variable and managed automatically.\n  ...\n  830  \n  831  - Updates #VmaAllocation objects to point to new `VkDeviceMemory` and offset.\n  832:   After allocation has been moved, its VmaAllocationInfo::deviceMemory and/or\n  833    VmaAllocationInfo::offset changes. You must query them again using\n  834    vmaGetAllocationInfo() if you need them.\n  ...\n  859  \\code\n  860  // Given following variables already initialized:\n  861: VkDevice device;\n  862  VmaAllocator allocator;\n  863  std::vector<VkBuffer> buffers;\n  ...\n  884      {\n  885          // Destroy buffer that is immutably bound to memory region which is no longer valid.\n  886:         vkDestroyBuffer(device, buffers[i], nullptr);\n  887  \n  888          // Create new buffer with same parameters.\n  889          VkBufferCreateInfo bufferInfo = ...;\n  890:         vkCreateBuffer(device, &bufferInfo, nullptr, &buffers[i]);\n  891              \n  892          // You can make dummy call to vkGetBufferMemoryRequirements here to silence validation layer warning.\n  ...\n  926  \\code\n  927  // Given following variables already initialized:\n  928: VkDevice device;\n  929  VmaAllocator allocator;\n  930  VkCommandBuffer commandBuffer;\n  ...\n  962      {\n  963          // Destroy buffer that is immutably bound to memory region which is no longer valid.\n  964:         vkDestroyBuffer(device, buffers[i], nullptr);\n  965  \n  966          // Create new buffer with same parameters.\n  967          VkBufferCreateInfo bufferInfo = ...;\n  968:         vkCreateBuffer(device, &bufferInfo, nullptr, &buffers[i]);\n  969              \n  970          // You can make dummy call to vkGetBufferMemoryRequirements here to silence validation layer warning.\n  ...\n 1020     class `VmaDefragmentationAlgorithm` and implement your version of its pure virtual methods.\n 1021     See definition and comments of this class for details.\n 1022: -# Your code needs to interact with device memory block metadata.\n 1023     If you need more access to its data than it's provided by its public interface,\n 1024     declare your new class as a friend class e.g. in class `VmaBlockMetadata_Generic`.\n ....\n 1049  You mustn't forget to destroy this allocation and this buffer/image.\n 1050  vmaGetAllocationInfo() can also be used for checking status of the allocation.\n 1051: Allocation is lost when returned VmaAllocationInfo::deviceMemory == `VK_NULL_HANDLE`.\n 1052  \n 1053  To create an allocation that can make some other allocations lost to make room\n ....\n 1522  by detecting it in Vulkan.\n 1523  To do it, call `vkGetPhysicalDeviceProperties()`, inspect\n 1524: `VkPhysicalDeviceProperties::deviceType` and look for `VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU`.\n 1525  When you find it, you can assume that memory is unified and all memory types are comparably fast\n 1526  to access from GPU, regardless of `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`.\n ....\n 1613  \\section heap_memory_limit Device heap memory limit\n 1614  \n 1615: When device memory of certain heap runs out of free space, new allocations may\n 1616  fail (returning error code) or they may succeed, silently pushing some existing\n 1617  memory blocks from GPU VRAM to system RAM (which degrades performance). This\n ....\n 1619  driver.\n 1620  \n 1621: On AMD cards it can be controlled while creating Vulkan device object by using\n 1622  VK_AMD_memory_overallocation_behavior extension, if available.\n 1623  \n 1624: Alternatively, if you want to test how your program behaves with limited amount of Vulkan device\n 1625  memory available without switching your graphics card to one that really has\n 1626  smaller VRAM, you can use a feature of this library intended for this purpose.\n ....\n 1640  enabled. To enable it:\n 1641  \n 1642: 1 . When creating Vulkan device, check if following 2 device extensions are\n 1643  supported (call `vkEnumerateDeviceExtensionProperties()`).\n 1644  If yes, enable them (fill `VkDeviceCreateInfo::ppEnabledExtensionNames`).\n ....\n 1706    - It happens when VK_KHR_dedicated_allocation extension is enabled.\n 1707      `vkGetBufferMemoryRequirements2KHR` function is used instead, while validation layer seems to be unaware of it.\n 1708: - *Mapping an image with layout VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL can result in undefined behavior if this memory is used by the device. Only GENERAL or PREINITIALIZED should be used.*\n 1709    - It happens when you map a buffer or image, because the library maps entire\n 1710      `VkDeviceMemory` block, where different types of images and buffers may end\n ....\n 1810  \n 1811  #if !defined(VMA_MEMORY_BUDGET)\n 1812:     #if VK_EXT_memory_budget && (VK_KHR_get_physical_device_properties2 || VMA_VULKAN_VERSION >= 1001000)\n 1813          #define VMA_MEMORY_BUDGET 1\n 1814      #else\n ....\n 1836  \n 1837  It is recommended to create just one object of this type per `VkDevice` object,\n 1838: right after Vulkan is initialized and keep it alive until before Vulkan device is destroyed.\n 1839  */\n 1840  VK_DEFINE_HANDLE(VmaAllocator)\n ....\n 1885      GPUs.\n 1886  \n 1887:     You may set this flag only if you found out that following device extensions are\n 1888:     supported, you enabled them while creating Vulkan device passed as\n 1889:     VmaAllocatorCreateInfo::device, and you want them to be used internally by this\n 1890      library:\n 1891  \n 1892:     - VK_KHR_get_memory_requirements2 (device extension)\n 1893:     - VK_KHR_dedicated_allocation (device extension)\n 1894  \n 1895      When this flag is set, you can experience following warnings reported by Vulkan\n ....\n 1905      When it's `VK_API_VERSION_1_1`, the flag is ignored because the extension has been promoted to Vulkan 1.1.\n 1906  \n 1907:     You may set this flag only if you found out that this device extension is supported,\n 1908:     you enabled it while creating Vulkan device passed as VmaAllocatorCreateInfo::device,\n 1909      and you want it to be used internally by this library.\n 1910  \n ....\n 1917      Enables usage of VK_EXT_memory_budget extension.\n 1918  \n 1919:     You may set this flag only if you found out that this device extension is supported,\n 1920:     you enabled it while creating Vulkan device passed as VmaAllocatorCreateInfo::device,\n 1921      and you want it to be used internally by this library, along with another instance extension\n 1922:     VK_KHR_get_physical_device_properties2, which is required by it (or Vulkan 1.1, where this extension is promoted).\n 1923  \n 1924      The extension provides query for current memory usage and budget, which will probably\n ....\n 1999      /// Flags for created allocator. Use #VmaAllocatorCreateFlagBits enum.\n 2000      VmaAllocatorCreateFlags flags;\n 2001:     /// Vulkan physical device.\n 2002      /** It must be valid throughout whole lifetime of created allocator. */\n 2003      VkPhysicalDevice physicalDevice;\n 2004:     /// Vulkan device.\n 2005      /** It must be valid throughout whole lifetime of created allocator. */\n 2006:     VkDevice device;\n 2007      /// Preferred size of a single `VkDeviceMemory` block to be allocated from large heaps > 1 GiB. Optional.\n 2008      /** Set to 0 to use default, which is currently 256 MiB. */\n ....\n 2048      smaller amount of memory, because graphics driver doesn't necessary fail new\n 2049      allocations with `VK_ERROR_OUT_OF_DEVICE_MEMORY` result when memory capacity is\n 2050:     exceeded. It may return success and just silently migrate some device memory\n 2051      blocks to system RAM. This driver behavior can also be controlled using\n 2052      VK_AMD_memory_overallocation_behavior extension.\n ....\n 2219  /** \\brief Retrieves information about current memory budget for all memory heaps.\n 2220  \n 2221: \\param[out] pBudget Must point to array with number of elements at least equal to number of memory heaps in physical device used.\n 2222  \n 2223  This function is called \"get\" not \"calculate\" because it is very fast, suitable to be called\n ....\n 2267      */\n 2268      VMA_MEMORY_USAGE_UNKNOWN = 0,\n 2269:     /** Memory will be used on device only, so fast access from the device is preferred.\n 2270:     It usually means device-local GPU (video) memory.\n 2271      No need to be mappable on host.\n 2272      It is roughly equivalent of `D3D12_HEAP_TYPE_DEFAULT`.\n ....\n 2274      Usage:\n 2275      \n 2276:     - Resources written and read by device, e.g. images used as attachments.\n 2277      - Resources transferred from host once (immutable) or infrequently and read by\n 2278:       device multiple times, e.g. textures to be sampled, vertex buffers, uniform\n 2279        (constant) buffers, and majority of other types of resources used on GPU.\n 2280  \n ....\n 2288      Guarantees to be `HOST_VISIBLE` and `HOST_COHERENT`.\n 2289      CPU access is typically uncached. Writes may be write-combined.\n 2290:     Resources created in this pool may still be accessible to the device, but access to them can be slow.\n 2291      It is roughly equivalent of `D3D12_HEAP_TYPE_UPLOAD`.\n 2292  \n ....\n 2298      CPU access is typically uncached. Writes may be write-combined.\n 2299  \n 2300:     Usage: Resources written frequently by host (dynamic), read by device. E.g. textures, vertex buffers, uniform buffers updated every frame or every draw call.\n 2301      */\n 2302      VMA_MEMORY_USAGE_CPU_TO_GPU = 3,\n ....\n 2306      Usage:\n 2307  \n 2308:     - Resources written by device, read by host - results of some computations, e.g. screen capture, average scene luminance for HDR tone mapping.\n 2309      - Any resources read or accessed randomly on host, e.g. CPU-side copy of vertex buffer used as source of transfer, but also used for collision detection.\n 2310      */\n ....\n 2366  \n 2367      To check if allocation is not lost, call vmaGetAllocationInfo() and check if\n 2368:     VmaAllocationInfo::deviceMemory is not `VK_NULL_HANDLE`.\n 2369  \n 2370      For details about supporting lost allocations, see Lost Allocations\n ....\n 2398      */\n 2399      VMA_ALLOCATION_CREATE_DONT_BIND_BIT = 0x00000080,\n 2400:     /** Create allocation only if additional device memory required for it, if any, won't exceed\n 2401      memory budget. Otherwise return `VK_ERROR_OUT_OF_DEVICE_MEMORY`.\n 2402      */\n ....\n 2495  \\return Returns VK_ERROR_FEATURE_NOT_PRESENT if not found. Receiving such result\n 2496  from this function or any other allocating function probably means that your\n 2497: device doesn't support any memory type with requested features for the specific\n 2498  type of resource you want to use it for. Please check parameters of your\n 2499  resource, like image layout (OPTIMAL versus LINEAR) or mip level count.\n ....\n 2674  } VmaPoolStats;\n 2675  \n 2676: /** \\brief Allocates Vulkan device memory and creates #VmaPool object.\n 2677  \n 2678  @param allocator Allocator object.\n ....\n 2685  \tVmaPool* pPool);\n 2686  \n 2687: /** \\brief Destroys #VmaPool object and frees Vulkan device memory.\n 2688  */\n 2689  VMA_CALL_PRE void VMA_CALL_POST vmaDestroyPool(\n ....\n 2792      If the allocation is lost, it is equal to `VK_NULL_HANDLE`.\n 2793      */\n 2794:     VkDeviceMemory deviceMemory;\n 2795:     /** \\brief Offset into deviceMemory object to the beginning of this allocation, in bytes. (deviceMemory, offset) pair is unique to this allocation.\n 2796  \n 2797      It can change after call to vmaDefragment() if this allocation is passed to the function, or if allocation is lost.\n ....\n 2924  This function also atomically \"touches\" allocation - marks it as used in current frame,\n 2925  just like vmaTouchAllocation().\n 2926: If the allocation is in lost state, `pAllocationInfo->deviceMemory == VK_NULL_HANDLE`.\n 2927  \n 2928  Although this function uses atomics and doesn't lock any mutex, so it should be quite efficient,\n ....\n 3234      uint32_t allocationsMoved;\n 3235      /// Number of empty `VkDeviceMemory` objects that have been released to the system.\n 3236:     uint32_t deviceMemoryBlocksFreed;\n 3237  } VmaDefragmentationStats;\n 3238  \n ....\n 3446  \n 3447  \\code\n 3448: vkDestroyBuffer(device, buffer, allocationCallbacks);\n 3449  vmaFreeMemory(allocator, allocation);\n 3450  \\endcode\n ....\n 3471  \n 3472  \\code\n 3473: vkDestroyImage(device, image, allocationCallbacks);\n 3474  vmaFreeMemory(allocator, allocation);\n 3475  \\endcode\n ....\n 6182  \n 6183  /*\n 6184: Represents a single block of device memory (`VkDeviceMemory`) with all the\n 6185  data about its regions (aka suballocations, #VmaAllocation), assigned and free.\n 6186  \n ....\n 7192      bool IsIntegratedGpu() const\n 7193      {\n 7194:         return m_PhysicalDeviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU;\n 7195      }\n 7196  \n ....\n 12772                  if(pDefragmentationStats != VMA_NULL)\n 12773                  {\n 12774:                     ++pDefragmentationStats->deviceMemoryBlocksFreed;\n 12775                      pDefragmentationStats->bytesFreed += pBlock->m_pMetadata->GetSize();\n 12776                  }\n .....\n 14759      fprintf(m_File, \"PhysicalDevice,driverVersion,%u\\n\", devProps.driverVersion);\n 14760      fprintf(m_File, \"PhysicalDevice,vendorID,%u\\n\", devProps.vendorID);\n 14761:     fprintf(m_File, \"PhysicalDevice,deviceID,%u\\n\", devProps.deviceID);\n 14762:     fprintf(m_File, \"PhysicalDevice,deviceType,%u\\n\", devProps.deviceType);\n 14763:     fprintf(m_File, \"PhysicalDevice,deviceName,%s\\n\", devProps.deviceName);\n 14764  \n 14765      fprintf(m_File, \"PhysicalDeviceLimits,maxMemoryAllocationCount,%u\\n\", devProps.limits.maxMemoryAllocationCount);\n .....\n 14857      m_UseKhrBindMemory2((pCreateInfo->flags & VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT) != 0),\n 14858      m_UseExtMemoryBudget((pCreateInfo->flags & VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT) != 0),\n 14859:     m_hDevice(pCreateInfo->device),\n 14860      m_hInstance(pCreateInfo->instance),\n 14861      m_AllocationCallbacksSpecified(pCreateInfo->pAllocationCallbacks != VMA_NULL),\n .....\n 14886      }\n 14887  \n 14888:     VMA_ASSERT(pCreateInfo->physicalDevice && pCreateInfo->device);\n 14889  \n 14890      if(m_VulkanApiVersion < VK_MAKE_VERSION(1, 1, 0))\n .....\n 15928              {\n 15929                  pAllocationInfo->memoryType = UINT32_MAX;\n 15930:                 pAllocationInfo->deviceMemory = VK_NULL_HANDLE;\n 15931                  pAllocationInfo->offset = 0;\n 15932                  pAllocationInfo->size = hAllocation->GetSize();\n .....\n 15938              {\n 15939                  pAllocationInfo->memoryType = hAllocation->GetMemoryTypeIndex();\n 15940:                 pAllocationInfo->deviceMemory = hAllocation->GetMemory();\n 15941                  pAllocationInfo->offset = hAllocation->GetOffset();\n 15942                  pAllocationInfo->size = hAllocation->GetSize();\n .....\n 15977  \n 15978          pAllocationInfo->memoryType = hAllocation->GetMemoryTypeIndex();\n 15979:         pAllocationInfo->deviceMemory = hAllocation->GetMemory();\n 15980          pAllocationInfo->offset = hAllocation->GetOffset();\n 15981          pAllocationInfo->size = hAllocation->GetSize();\n\n1320 matches across 220 files\n\n\nSearching 1282 files for \"mapBufferApi\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Buffer.cpp:\n   58  \n   59  size_t getBufferDataAlignment(const Buffer* pBuffer);\n   60: void* mapBufferApi(const Buffer::ApiHandle& apiHandle, size_t size);\n   61  \n   62  Buffer::Buffer(std::shared_ptr<Device> pDevice, size_t size, BindFlags bindFlags, CpuAccess cpuAccess): Resource(pDevice, Type::Buffer, bindFlags, size), mCpuAccess(cpuAccess) {}\n   ..\n  263          } else if (mCpuAccess == CpuAccess::Read) {\n  264              assert(mBindFlags == BindFlags::None);\n  265:             return mapBufferApi(mApiHandle, mSize);\n  266          } else {\n  267              // For buffers without CPU access we must copy the contents to a staging buffer.\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Buffer.cpp:\n   71      }\n   72  \n   73:     void* mapBufferApi(const Buffer::ApiHandle& apiHandle, size_t size)\n   74      {\n   75          D3D12_RANGE r{ 0, size };\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKBuffer.cpp:\n   47  }\n   48  \n   49: void* mapBufferApi(Device::SharedPtr device, const Buffer::ApiHandle& apiHandle, size_t size) {\n   50      void* pData;\n   51      vk_call(vkMapMemory(apiHandle.device()->getApiHandle(), apiHandle, 0, size, 0, &pData));\n\n4 matches across 3 files\n\n\nSearching 1282 files for \"mapBufferApi\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Buffer.cpp:\n   58  \n   59  size_t getBufferDataAlignment(const Buffer* pBuffer);\n   60: void* mapBufferApi(const Buffer::ApiHandle& apiHandle, size_t size);\n   61  \n   62  Buffer::Buffer(std::shared_ptr<Device> pDevice, size_t size, BindFlags bindFlags, CpuAccess cpuAccess): Resource(pDevice, Type::Buffer, bindFlags, size), mCpuAccess(cpuAccess) {}\n   ..\n  263          } else if (mCpuAccess == CpuAccess::Read) {\n  264              assert(mBindFlags == BindFlags::None);\n  265:             return mapBufferApi(mApiHandle, mSize);\n  266          } else {\n  267              // For buffers without CPU access we must copy the contents to a staging buffer.\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Buffer.cpp:\n   71      }\n   72  \n   73:     void* mapBufferApi(const Buffer::ApiHandle& apiHandle, size_t size)\n   74      {\n   75          D3D12_RANGE r{ 0, size };\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKBuffer.cpp:\n   47  }\n   48  \n   49: void* mapBufferApi(Device::SharedPtr device, const Buffer::ApiHandle& apiHandle, size_t size) {\n   50      void* pData;\n   51      //vk_call(vkMapMemory(apiHandle.device()->getApiHandle(), apiHandle, 0, size, 0, &pData));\n\n4 matches across 3 files\n\n\nSearching 1282 files for \"mapBufferApi\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Buffer.cpp:\n   58  \n   59  size_t getBufferDataAlignment(const Buffer* pBuffer);\n   60: void* mapBufferApi(const Buffer::ApiHandle& apiHandle, size_t size);\n   61  \n   62  Buffer::Buffer(std::shared_ptr<Device> pDevice, size_t size, BindFlags bindFlags, CpuAccess cpuAccess): Resource(pDevice, Type::Buffer, bindFlags, size), mCpuAccess(cpuAccess) {}\n   ..\n  263          } else if (mCpuAccess == CpuAccess::Read) {\n  264              assert(mBindFlags == BindFlags::None);\n  265:             return mapBufferApi(mApiHandle, mSize);\n  266          } else {\n  267              // For buffers without CPU access we must copy the contents to a staging buffer.\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Buffer.cpp:\n   71      }\n   72  \n   73:     void* mapBufferApi(const Buffer::ApiHandle& apiHandle, size_t size)\n   74      {\n   75          D3D12_RANGE r{ 0, size };\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKBuffer.cpp:\n   47  }\n   48  \n   49: void* mapBufferApi(Device::SharedPtr device, const Buffer::ApiHandle& apiHandle, size_t size) {\n   50      void* pData;\n   51      vk_call(vkMapMemory(apiHandle.device()->getApiHandle(), apiHandle, 0, size, 0, &pData));\n\n4 matches across 3 files\n\n\nSearching 1282 files for \"mapBufferApi\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Buffer.cpp:\n   58  \n   59  size_t getBufferDataAlignment(const Buffer* pBuffer);\n   60: void* mapBufferApi(const Buffer::ApiHandle& apiHandle, size_t size);\n   61  \n   62  Buffer::Buffer(std::shared_ptr<Device> pDevice, size_t size, BindFlags bindFlags, CpuAccess cpuAccess): Resource(pDevice, Type::Buffer, bindFlags, size), mCpuAccess(cpuAccess) {}\n   ..\n  263          } else if (mCpuAccess == CpuAccess::Read) {\n  264              assert(mBindFlags == BindFlags::None);\n  265:             return mapBufferApi(mApiHandle, mSize);\n  266          } else {\n  267              // For buffers without CPU access we must copy the contents to a staging buffer.\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Buffer.cpp:\n   71      }\n   72  \n   73:     void* mapBufferApi(const Buffer::ApiHandle& apiHandle, size_t size)\n   74      {\n   75          D3D12_RANGE r{ 0, size };\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKBuffer.cpp:\n   47  }\n   48  \n   49: void* mapBufferApi(Device::SharedPtr pDevice, const Buffer::ApiHandle& apiHandle, size_t size) {\n   50      void* pData;\n   51      vk_call(vkMapMemory(pDevice->getApiHandle(), apiHandle, 0, size, 0, &pData));\n\n4 matches across 3 files\n\n\nSearching 1282 files for \"mapBufferApi\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Buffer.cpp:\n   58  \n   59  size_t getBufferDataAlignment(const Buffer* pBuffer);\n   60: void* mapBufferApi(std::shared_ptr<Device> pDevice, const Buffer::ApiHandle& apiHandle, size_t size);\n   61  \n   62  Buffer::Buffer(std::shared_ptr<Device> pDevice, size_t size, BindFlags bindFlags, CpuAccess cpuAccess): Resource(pDevice, Type::Buffer, bindFlags, size), mCpuAccess(cpuAccess) {}\n   ..\n  263          } else if (mCpuAccess == CpuAccess::Read) {\n  264              assert(mBindFlags == BindFlags::None);\n  265:             return mapBufferApi(mpDevice, mApiHandle, mSize);\n  266          } else {\n  267              // For buffers without CPU access we must copy the contents to a staging buffer.\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Buffer.cpp:\n   71      }\n   72  \n   73:     void* mapBufferApi(const Buffer::ApiHandle& apiHandle, size_t size)\n   74      {\n   75          D3D12_RANGE r{ 0, size };\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKBuffer.cpp:\n   47  }\n   48  \n   49: void* mapBufferApi(Device::SharedPtr pDevice, const Buffer::ApiHandle& apiHandle, size_t size) {\n   50      void* pData;\n   51      vk_call(vkMapMemory(pDevice->getApiHandle(), apiHandle, 0, size, 0, &pData));\n\n4 matches across 3 files\n\n\nSearching 1282 files for \"allocateDeviceMemory\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKBuffer.cpp:\n   36  namespace Falcor {\n   37      \n   38: VkDeviceMemory allocateDeviceMemory(std::shared_ptr<Device> pDevice, GpuMemoryHeap::Type memType, uint32_t memoryTypeBits, size_t size) {\n   39      VkMemoryAllocateInfo allocInfo = {};\n   40      allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;\n   ..\n  103      vkGetBufferMemoryRequirements(device->getApiHandle(), buffer, &reqs);\n  104  \n  105:     VkDeviceMemory mem = allocateDeviceMemory(device, memType, reqs.memoryTypeBits, reqs.size);\n  106      vk_call(vkBindBufferMemory(device->getApiHandle(), buffer, mem, 0));\n  107      Buffer::ApiHandle apiHandle = Buffer::ApiHandle::create(device, buffer, mem);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKTexture.cpp:\n   32  \n   33  namespace Falcor {\n   34:     VkDeviceMemory allocateDeviceMemory(Device::MemoryType memType, uint32_t memoryTypeBits, size_t size);\n   35  \n   36      struct TextureApiData {\n   ..\n  152          VkMemoryRequirements memRequirements;\n  153          vkGetImageMemoryRequirements(mpDevice->getApiHandle(), image, &memRequirements);\n  154:         VkDeviceMemory deviceMem = allocateDeviceMemory(Device::MemoryType::Default, memRequirements.memoryTypeBits, memRequirements.size);\n  155          vkBindImageMemory(mpDevice->getApiHandle(), image, deviceMem, 0);\n  156          mApiHandle = ApiHandle::create(mpDevice, image, deviceMem);\n\n4 matches across 2 files\n\n\nSearching 1282 files for \"allocateDeviceMemory\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKBuffer.cpp:\n   36  namespace Falcor {\n   37      \n   38: VkDeviceMemory allocateDeviceMemory(std::shared_ptr<Device> pDevice, GpuMemoryHeap::Type memType, uint32_t memoryTypeBits, size_t size) {\n   39      VkMemoryAllocateInfo allocInfo = {};\n   40      allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;\n   ..\n  103      vkGetBufferMemoryRequirements(device->getApiHandle(), buffer, &reqs);\n  104  \n  105:     VkDeviceMemory mem = allocateDeviceMemory(device, memType, reqs.memoryTypeBits, reqs.size);\n  106      vk_call(vkBindBufferMemory(device->getApiHandle(), buffer, mem, 0));\n  107      Buffer::ApiHandle apiHandle = Buffer::ApiHandle::create(device, buffer, mem);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKTexture.cpp:\n   32  \n   33  namespace Falcor {\n   34:     VkDeviceMemory allocateDeviceMemory(std::shared_ptr<Device> pDevice, Device::MemoryType memType, uint32_t memoryTypeBits, size_t size);\n   35  \n   36      struct TextureApiData {\n   ..\n  152          VkMemoryRequirements memRequirements;\n  153          vkGetImageMemoryRequirements(mpDevice->getApiHandle(), image, &memRequirements);\n  154:         VkDeviceMemory deviceMem = allocateDeviceMemory(mpDevice, Device::MemoryType::Default, memRequirements.memoryTypeBits, memRequirements.size);\n  155          vkBindImageMemory(mpDevice->getApiHandle(), image, deviceMem, 0);\n  156          mApiHandle = ApiHandle::create(mpDevice, image, deviceMem);\n\n4 matches across 2 files\n\n\nSearching 1282 files for \"allocateDeviceMemory\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKBuffer.cpp:\n   36  namespace Falcor {\n   37      \n   38: VkDeviceMemory allocateDeviceMemory(std::shared_ptr<Device> pDevice, GpuMemoryHeap::Type memType, uint32_t memoryTypeBits, size_t size) {\n   39      VkMemoryAllocateInfo allocInfo = {};\n   40      allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;\n   ..\n  103      vkGetBufferMemoryRequirements(pDevice->getApiHandle(), buffer, &reqs);\n  104  \n  105:     VkDeviceMemory mem = allocateDeviceMemory(pDevice, memType, reqs.memoryTypeBits, reqs.size);\n  106      vk_call(vkBindBufferMemory(pDevice->getApiHandle(), buffer, mem, 0));\n  107      Buffer::ApiHandle apiHandle = Buffer::ApiHandle::create(pDevice, buffer, mem);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKTexture.cpp:\n   32  \n   33  namespace Falcor {\n   34:     VkDeviceMemory allocateDeviceMemory(std::shared_ptr<Device> pDevice, Device::MemoryType memType, uint32_t memoryTypeBits, size_t size);\n   35  \n   36      struct TextureApiData {\n   ..\n  152          VkMemoryRequirements memRequirements;\n  153          vkGetImageMemoryRequirements(mpDevice->getApiHandle(), image, &memRequirements);\n  154:         VkDeviceMemory deviceMem = allocateDeviceMemory(mpDevice, Device::MemoryType::Default, memRequirements.memoryTypeBits, memRequirements.size);\n  155          vkBindImageMemory(mpDevice->getApiHandle(), image, deviceMem, 0);\n  156          mApiHandle = ApiHandle::create(mpDevice, image, deviceMem);\n\n4 matches across 2 files\n\n\nSearching 1282 files for \"allocateDeviceMemory\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKBuffer.cpp:\n   36  namespace Falcor {\n   37      \n   38: VkDeviceMemory allocateDeviceMemory(std::shared_ptr<Device> pDevice, GpuMemoryHeap::Type memType, uint32_t memoryTypeBits, size_t size) {\n   39      VkMemoryAllocateInfo allocInfo = {};\n   40      allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;\n   ..\n  103      vkGetBufferMemoryRequirements(pDevice->getApiHandle(), buffer, &reqs);\n  104  \n  105:     VkDeviceMemory mem = allocateDeviceMemory(pDevice, memType, reqs.memoryTypeBits, reqs.size);\n  106      vk_call(vkBindBufferMemory(pDevice->getApiHandle(), buffer, mem, 0));\n  107      Buffer::ApiHandle apiHandle = Buffer::ApiHandle::create(pDevice, buffer, mem);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKTexture.cpp:\n   32  \n   33  namespace Falcor {\n   34:     VkDeviceMemory allocateDeviceMemory(std::shared_ptr<Device> pDevice, Device::MemoryType memType, uint32_t memoryTypeBits, size_t size);\n   35  \n   36      struct TextureApiData {\n   ..\n  152          VkMemoryRequirements memRequirements;\n  153          vkGetImageMemoryRequirements(mpDevice->getApiHandle(), image, &memRequirements);\n  154:         VkDeviceMemory deviceMem = allocateDeviceMemory(mpDevice, Device::MemoryType::Default, memRequirements.memoryTypeBits, memRequirements.size);\n  155          vkBindImageMemory(mpDevice->getApiHandle(), image, deviceMem, 0);\n  156          mApiHandle = ApiHandle::create(mpDevice, image, deviceMem);\n\n4 matches across 2 files\n\n\nSearching 1282 files for \"allocateDeviceMemory\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKBuffer.cpp:\n   36  namespace Falcor {\n   37      \n   38: VkDeviceMemory allocateDeviceMemory(std::shared_ptr<Device> pDevice, GpuMemoryHeap::Type memType, uint32_t memoryTypeBits, size_t size) {\n   39      VkMemoryAllocateInfo allocInfo = {};\n   40      allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;\n   ..\n  103      vkGetBufferMemoryRequirements(pDevice->getApiHandle(), buffer, &reqs);\n  104  \n  105:     VkDeviceMemory mem = allocateDeviceMemory(pDevice, memType, reqs.memoryTypeBits, reqs.size);\n  106      vk_call(vkBindBufferMemory(pDevice->getApiHandle(), buffer, mem, 0));\n  107      Buffer::ApiHandle apiHandle = Buffer::ApiHandle::create(pDevice, buffer, mem);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKTexture.cpp:\n   32  \n   33  namespace Falcor {\n   34:     VkDeviceMemory allocateDeviceMemory(std::shared_ptr<Device> pDevice, Device::MemoryType memType, uint32_t memoryTypeBits, size_t size);\n   35  \n   36      struct TextureApiData {\n   ..\n  152          VkMemoryRequirements memRequirements;\n  153          vkGetImageMemoryRequirements(mpDevice->getApiHandle(), image, &memRequirements);\n  154:         VkDeviceMemory deviceMem = allocateDeviceMemory(mpDevice, Device::MemoryType::Default, memRequirements.memoryTypeBits, memRequirements.size);\n  155          vkBindImageMemory(mpDevice->getApiHandle(), image, deviceMem, 0);\n  156          mApiHandle = ApiHandle::create(mpDevice, image, deviceMem);\n\n4 matches across 2 files\n\n\nSearching 1282 files for \"createSurface\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKDevice.cpp:\n  446  }\n  447  \n  448: VkSurfaceKHR createSurface(VkInstance instance, VkPhysicalDevice physicalDevice, DeviceApiData *pData, const Window* pWindow) {\n  449      VkSurfaceKHR surface;\n  450  \n  ...\n  604      if (!physicalDevice) return false;\n  605      \n  606:     VkSurfaceKHR surface = createSurface(instance, physicalDevice, mpApiData, mpWindow.get());\n  607      if (!surface) return false;\n  608      \n\n2 matches in 1 file\n\n\nSearching 1282 files for \"DeviceHandle\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12DescriptorHeap.cpp:\n   34      D3D12DescriptorHeap::D3D12DescriptorHeap(D3D12_DESCRIPTOR_HEAP_TYPE type, uint32_t chunkCount) : mMaxChunkCount(chunkCount), mType(type)\n   35      {\n   36:         DeviceHandle pDevice = gpDevice->getApiHandle();\n   37          mDescriptorSize = pDevice->GetDescriptorHandleIncrementSize(type);\n   38      }\n   ..\n   43      {\n   44          assert(gpDevice);\n   45:         DeviceHandle pDevice = gpDevice->getApiHandle();\n   46  \n   47          uint32_t chunkCount = (descCount + kDescPerChunk - 1) / kDescPerChunk;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Device.cpp:\n  123      }\n  124  \n  125:     DeviceHandle createDevice(IDXGIFactory4* pFactory, D3D_FEATURE_LEVEL requestedFeatureLevel, const std::vector<UUID>& experimentalFeatures)\n  126      {\n  127          // Feature levels to try creating devices. Listed in descending order so the highest supported level is used.\n  ...\n  141          // Find the HW adapter\n  142          IDXGIAdapter1Ptr pAdapter;\n  143:         DeviceHandle pDevice;\n  144          D3D_FEATURE_LEVEL deviceFeatureLevel;\n  145  \n  ...\n  202      }\n  203  \n  204:     Device::SupportedFeatures getSupportedFeatures(DeviceHandle pDevice)\n  205      {\n  206          Device::SupportedFeatures supported = Device::SupportedFeatures::None;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/FalcorD3D12.h:\n  203  \n  204      using WindowHandle = HWND;\n  205:     using DeviceHandle = ID3D12DevicePtr;\n  206      using CommandListHandle = ID3D12GraphicsCommandListPtr;\n  207      using CommandQueueHandle = ID3D12CommandQueuePtr;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Device.h:\n   61      using SharedPtr = std::shared_ptr<Device>;\n   62      using SharedConstPtr = std::shared_ptr<const Device>;\n   63:     using ApiHandle = DeviceHandle;\n   64      static const uint32_t kQueueTypeCount = (uint32_t)LowLevelContextData::CommandQueueType::Count;\n   65  \n   ..\n  156      /** Get the native API handle\n  157      */\n  158:     const DeviceHandle& getApiHandle() { return mApiHandle; }\n  159  \n  160      /** Present the back-buffer to the window\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/FalcorVK.h:\n   84  #endif\n   85  \n   86: using DeviceHandle = VkDeviceData::SharedPtr;\n   87  using CommandListHandle = VkCommandBuffer;\n   88  using CommandQueueHandle = VkQueue;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKDevice.cpp:\n  616  \n  617      if(!headless) {\n  618:         mApiHandle = DeviceHandle::create(SharedPtr(this), instance, physicalDevice, device, surface);\n  619      } else {\n  620:         mApiHandle = DeviceHandle::create(SharedPtr(this), instance, physicalDevice, device);\n  621      }\n  622  \n\n11 matches across 6 files\n\n\nSearching 1282 files for \"VkDeviceData\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/FalcorVK.h:\n   84  #endif\n   85  \n   86: using DeviceHandle = VkDeviceData::SharedPtr;\n   87  using CommandListHandle = VkCommandBuffer;\n   88  using CommandQueueHandle = VkQueue;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VkSmartHandle.cpp:\n   47      template<> VkHandle<VkQueryPool>::~VkHandle() { if (mApiHandle != VK_NULL_HANDLE && mpDevice) vkDestroyQueryPool(mpDevice->getApiHandle(), mApiHandle, nullptr); }\n   48  \n   49:     VkDeviceData::~VkDeviceData() {\n   50          if (mInstance != VK_NULL_HANDLE && mLogicalDevice != VK_NULL_HANDLE && mInstance != VK_NULL_HANDLE) {\n   51              vkDestroySurfaceKHR(mInstance, mSurface, nullptr);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKSmartHandle.h:\n   98  };\n   99  \n  100: class VkDeviceData : public VkBaseApiHandle, public inherit_shared_from_this<VkBaseApiHandle, VkDeviceData> {\n  101   public:\n  102:     class SharedPtr : public std::shared_ptr<VkDeviceData> {\n  103       public:\n  104          SharedPtr() = default;\n  105:         explicit SharedPtr(VkDeviceData* pData) : std::shared_ptr<VkDeviceData>(pData) {}\n  106          static SharedPtr create(std::shared_ptr<Device> device, VkInstance instance, VkPhysicalDevice physicalDevice, VkDevice vkdevice, VkSurfaceKHR surface) {\n  107:             return SharedPtr(new VkDeviceData(device, instance, physicalDevice, vkdevice, surface));\n  108          }\n  109  \n  ...\n  114  \n  115       private:\n  116:         VkDeviceData* get() const { return std::shared_ptr<VkDeviceData>::get(); }\n  117      };\n  118  \n  119:     ~VkDeviceData();\n  120  \n  121   private:\n  122      friend SharedPtr;\n  123:     VkDeviceData(std::shared_ptr<Device> device, VkInstance instance, VkPhysicalDevice physicalDevice, VkDevice vkdevice, VkSurfaceKHR surface) :\n  124          VkBaseApiHandle(device), mInstance(instance), mPhysicalDevice(physicalDevice), mLogicalDevice(vkdevice), mSurface(surface) {}\n  125      VkInstance          mInstance;\n\n13 matches across 3 files\n\n\nSearching 1282 files for \"ConstTextureSharedPtrRef\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12ResourceViews.cpp:\n  281      }\n  282  \n  283:     ShaderResourceView::SharedPtr ShaderResourceView::create(ConstTextureSharedPtrRef pTexture, uint32_t mostDetailedMip, uint32_t mipCount, uint32_t firstArraySlice, uint32_t arraySize)\n  284      {\n  285          if (!pTexture && getNullView()) return getNullView();\n  ...\n  327      }\n  328  \n  329:     DepthStencilView::SharedPtr DepthStencilView::create(ConstTextureSharedPtrRef pTexture, uint32_t mipLevel, uint32_t firstArraySlice, uint32_t arraySize)\n  330      {\n  331          if (!pTexture && getNullView()) return getNullView();\n  ...\n  362      }\n  363  \n  364:     UnorderedAccessView::SharedPtr UnorderedAccessView::create(ConstTextureSharedPtrRef pTexture, uint32_t mipLevel, uint32_t firstArraySlice, uint32_t arraySize)\n  365      {\n  366          if (!pTexture && getNullView()) return getNullView();\n  ...\n  414      RenderTargetView::~RenderTargetView() = default;\n  415  \n  416:     RenderTargetView::SharedPtr RenderTargetView::create(ConstTextureSharedPtrRef pTexture, uint32_t mipLevel, uint32_t firstArraySlice, uint32_t arraySize)\n  417      {\n  418          if (!pTexture && getNullView()) return getNullView();\n\n/home/max/dev/Falcor/src/Falcor/Core/API/ResourceViews.h:\n   42  \n   43  using ResourceWeakPtr = std::weak_ptr<Resource>;\n   44: using ConstTextureSharedPtrRef = const std::shared_ptr<Texture>&;\n   45  using ConstBufferSharedPtrRef = const std::shared_ptr<Buffer>&;\n   46  \n   ..\n  114      using SharedConstPtr = std::shared_ptr<const ShaderResourceView>;\n  115  \n  116:     static SharedPtr create(std::shared_ptr<Device> pDevice, ConstTextureSharedPtrRef pTexture, uint32_t mostDetailedMip, uint32_t mipCount, uint32_t firstArraySlice, uint32_t arraySize);\n  117      static SharedPtr create(std::shared_ptr<Device> pDevice, ConstBufferSharedPtrRef pBuffer, uint32_t firstElement, uint32_t elementCount);\n  118      static SharedPtr getNullView(std::shared_ptr<Device> pDevice);\n  ...\n  134      using SharedConstPtr = std::shared_ptr<const DepthStencilView>;\n  135  \n  136:     static SharedPtr create(std::shared_ptr<Device> pDevice, ConstTextureSharedPtrRef pTexture, uint32_t mipLevel, uint32_t firstArraySlice, uint32_t arraySize);\n  137      static SharedPtr getNullView(std::shared_ptr<Device> pDevice);\n  138  \n  ...\n  147      using SharedConstPtr = std::shared_ptr<const UnorderedAccessView>;\n  148  \n  149:     static SharedPtr create(std::shared_ptr<Device> pDevice, ConstTextureSharedPtrRef pTexture, uint32_t mipLevel, uint32_t firstArraySlice, uint32_t arraySize);\n  150      static SharedPtr create(std::shared_ptr<Device> pDevice, ConstBufferSharedPtrRef pBuffer, uint32_t firstElement, uint32_t elementCount);\n  151      static SharedPtr getNullView(std::shared_ptr<Device> pDevice);\n  ...\n  165      using SharedPtr = std::shared_ptr<RenderTargetView>;\n  166      using SharedConstPtr = std::shared_ptr<const RenderTargetView>;\n  167:     static SharedPtr create(std::shared_ptr<Device> pDevice, ConstTextureSharedPtrRef pTexture, uint32_t mipLevel, uint32_t firstArraySlice, uint32_t arraySize);\n  168      static SharedPtr getNullView(std::shared_ptr<Device> pDevice);\n  169      ~RenderTargetView();\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKResourceViews.cpp:\n  164  }\n  165  \n  166: ShaderResourceView::SharedPtr ShaderResourceView::create(std::shared_ptr<Device> pDevice, ConstTextureSharedPtrRef pTexture, uint32_t mostDetailedMip, uint32_t mipCount, uint32_t firstArraySlice, uint32_t arraySize) {\n  167      if (!pTexture) {\n  168          return getNullView(pDevice);\n  ...\n  207  }\n  208  \n  209: DepthStencilView::SharedPtr DepthStencilView::create(std::shared_ptr<Device> pDevice, ConstTextureSharedPtrRef pTexture, uint32_t mipLevel, uint32_t firstArraySlice, uint32_t arraySize) {\n  210      if (!pTexture) {\n  211          return getNullView(pDevice);\n  ...\n  221  }\n  222  \n  223: UnorderedAccessView::SharedPtr UnorderedAccessView::create(std::shared_ptr<Device> pDevice, ConstTextureSharedPtrRef pTexture, uint32_t mipLevel, uint32_t firstArraySlice, uint32_t arraySize) {\n  224      if (!pTexture) {\n  225          return getNullView(pDevice);\n  ...\n  272  }\n  273  \n  274: RenderTargetView::SharedPtr RenderTargetView::create(std::shared_ptr<Device> pDevice, ConstTextureSharedPtrRef pTexture, uint32_t mipLevel, uint32_t firstArraySlice, uint32_t arraySize) {\n  275      if (!pTexture) return getNullView(pDevice);\n  276  \n\n13 matches across 3 files\n\n\nSearching 1282 files for \"getClientAreaSize\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Device.cpp:\n   98          DXGI_SWAP_CHAIN_DESC1 swapChainDesc = {};\n   99          swapChainDesc.BufferCount = bufferCount;\n  100:         swapChainDesc.Width = pWindow->getClientAreaSize().x;\n  101:         swapChainDesc.Height = pWindow->getClientAreaSize().y;\n  102          // Flip mode doesn't support SRGB formats, so we strip them down when creating the resource. We will create the RTV as SRGB instead.\n  103          // More details at the end of https://msdn.microsoft.com/en-us/library/windows/desktop/bb173064.aspx\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Device.cpp:\n  125  \n  126      // Update the FBOs\n  127:     if (updateDefaultFBO(mpWindow->getClientAreaSize().x, mpWindow->getClientAreaSize().y, mDesc.colorFormat, mDesc.depthFormat) == false) {\n  128          return false;\n  129      }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Engine.cpp:\n   83      // Update the FBOs\n   84      if(!headless) {\n   85:         if (updateDefaultFBO(mpDevice->getWindow()->getClientAreaSize().x, mpDevice->getWindow()->getClientAreaSize().y, mpDevice->getDesc().colorFormat, mpDevice->getDesc().depthFormat) == false) {\n   86              return false;\n   87          }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKDevice.cpp:\n  490      VkExtent2D swapchainExtent = {};\n  491      if (surfaceCapabilities.currentExtent.width == (uint32_t)-1) {\n  492:         const uint2 windowSize = mpWindow->getClientAreaSize();\n  493          swapchainExtent.width = windowSize.x;\n  494          swapchainExtent.height = windowSize.y;\n\n/home/max/dev/Falcor/src/Falcor/Core/Sample.cpp:\n   59          }\n   60          // Tell the device to resize the swap chain\n   61:         auto winSize = mpWindow->getClientAreaSize();\n   62          auto pBackBufferFBO = mpDevice->resizeSwapChain(winSize.x, winSize.y);\n   63          auto width = pBackBufferFBO->getWidth();\n   ..\n  388  \n  389              controlsGroup.separator();\n  390:             screenSizeUI(controlsGroup, mpWindow->getClientAreaSize());\n  391              controlsGroup.separator();\n  392  \n\n/home/max/dev/Falcor/src/Falcor/Core/Window.h:\n  118      /** Get the width of the window's client area\n  119      */\n  120:     uint2 getClientAreaSize() const { return { mDesc.width, mDesc.height }; }\n  121  \n  122      /** Get the descriptor\n\n/home/max/dev/Falcor/src/Mogwai/MogwaiSettings.cpp:\n   88      };\n   89  \n   90:     uint2 currentRes = gpFramework->getWindow()->getClientAreaSize();\n   91      static const Gui::DropdownList dropdownList = initDropDown(resolutions, arraysize(resolutions));\n   92      uint32_t currentVal = initDropDownVal(resolutions, arraysize(resolutions), currentRes);\n\n11 matches across 7 files\n\n\nSearching 1282 files for \"resizeSwapChain\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Device.cpp:\n  295  }\n  296  \n  297: Fbo::SharedPtr Device::resizeSwapChain(uint32_t width, uint32_t height) {\n  298      assert(width > 0 && height > 0);\n  299  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Device.h:\n  173          \\return A new FBO object\n  174      */\n  175:     Fbo::SharedPtr resizeSwapChain(uint32_t width, uint32_t height);\n  176  \n  177      /** Get the desc\n\n/home/max/dev/Falcor/src/Falcor/Core/Renderer.h:\n   72  \n   73      /** Resize the swap-chain buffers*/\n   74:     virtual void resizeSwapChain(uint32_t width, uint32_t height) = 0;\n   75  \n   76      /** Check if a key is pressed*/\n\n/home/max/dev/Falcor/src/Falcor/Core/Sample.cpp:\n   60          // Tell the device to resize the swap chain\n   61          auto winSize = mpWindow->getClientAreaSize();\n   62:         auto pBackBufferFBO = mpDevice->resizeSwapChain(winSize.x, winSize.y);\n   63          auto width = pBackBufferFBO->getWidth();\n   64          auto height = pBackBufferFBO->getHeight();\n   ..\n  335  \n  336          widget.var(\"Screen Resolution\", screenDims);\n  337:         if (widget.dropdown(\"Change Resolution\", dropdownList, currentVal) && (currentVal != 0)) gpFramework->resizeSwapChain(resolutions[currentVal].x, resolutions[currentVal].y);\n  338      }\n  339  \n  ...\n  508      }\n  509  \n  510:     void Sample::resizeSwapChain(uint32_t width, uint32_t height) {\n  511          mpWindow->resize(width, height);\n  512      }\n  ...\n  618          m.func_(\"setWindowPos\", setWindowPos, \"x\"_a, \"y\"_a);\n  619  \n  620:         auto resize = [this](uint32_t width, uint32_t height) {resizeSwapChain(width, height); };\n  621:         m.func_(\"resizeSwapChain\", resize, \"width\"_a, \"height\"_a);\n  622      }\n  623  \n\n/home/max/dev/Falcor/src/Falcor/Core/Sample.h:\n   87      FrameRate& getFrameRate() override { return *mFrameRate; }\n   88  \n   89:     void resizeSwapChain(uint32_t width, uint32_t height) override;\n   90      bool isKeyPressed(const KeyboardEvent::Key& key) override;\n   91      void toggleUI(bool showUI) override { mShowUI = showUI; }\n\n/home/max/dev/Falcor/src/Mogwai/Data/Config.py:\n    6  \n    7  # Window Configuration\n    8: m.resizeSwapChain(1920, 1080)\n    9  m.ui = True\n   10  \n\n/home/max/dev/Falcor/src/Mogwai/MogwaiScripting.cpp:\n   42  const std::string kGetGraph = \"getGraph\";\n   43  const std::string kUI = \"ui\";\n   44: const std::string kResizeSwapChain = \"resizeSwapChain\";\n   45  const std::string kActiveGraph = \"activeGraph\";\n   46  const std::string kScene = \"scene\";\n   ..\n  154  \n  155      // PYTHONDEPRECATED Use the global function defined in the script bindings in Sample.cpp when resizing from a Python script.\n  156:     auto resize = [](Renderer* pRenderer, uint32_t width, uint32_t height) {gpFramework->resizeSwapChain(width, height); };\n  157      c.func_(kResizeSwapChain.c_str(), resize);\n  158  }\n\n/home/max/dev/Falcor/src/Mogwai/MogwaiSettings.cpp:\n  103          } else {\n  104              customSize = {};\n  105:             gpFramework->resizeSwapChain(resolutions[currentVal].x, resolutions[currentVal].y);\n  106          }\n  107      }\n  ...\n  112          w.var(\"##custres\", customSize);\n  113          if (w.button(\"Apply##custres\", true)) {\n  114:             gpFramework->resizeSwapChain(customSize.x, customSize.y);\n  115              forceCustom = false;\n  116          }\n\n14 matches across 8 files\n\n\nSearching 1282 files for \"std::unordered_map<Falcor::ResourceViewInfo\" (case sensitive)\n\n0 matches\n\nSearching 1282 files for \"std::unordered_map\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/GpuMemoryHeap.h:\n   98  \n   99      std::priority_queue<Allocation> mDeferredReleases;\n  100:     std::unordered_map<size_t, PageData::UniquePtr> mUsedPages;\n  101      std::queue<PageData::UniquePtr> mAvailablePages;\n  102  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Resource.h:\n  199      std::shared_ptr<Device> mpDevice;\n  200  \n  201:     mutable std::unordered_map<ResourceViewInfo, ShaderResourceView::SharedPtr, ViewInfoHashFunc> mSrvs;\n  202:     mutable std::unordered_map<ResourceViewInfo, RenderTargetView::SharedPtr, ViewInfoHashFunc> mRtvs;\n  203:     mutable std::unordered_map<ResourceViewInfo, DepthStencilView::SharedPtr, ViewInfoHashFunc> mDsvs;\n  204:     mutable std::unordered_map<ResourceViewInfo, UnorderedAccessView::SharedPtr, ViewInfoHashFunc> mUavs;\n  205  };\n  206  \n\n/home/max/dev/Falcor/src/Falcor/Core/BufferTypes/VariablesBufferUI.cpp:\n   32  namespace Falcor\n   33  {\n   34:     std::unordered_map<std::string, int32_t> VariablesBufferUI::mGuiArrayIndices;\n   35  \n   36      bool renderGuiWidgetFromType(Gui::Widgets& widget, ReflectionBasicType::Type type, uint8_t* data, const std::string& name)\n\n/home/max/dev/Falcor/src/Falcor/Core/BufferTypes/VariablesBufferUI.h:\n   43      private:\n   44          ParameterBlock& mVariablesBufferRef;\n   45:         static std::unordered_map<std::string, int32_t> mGuiArrayIndices;\n   46  \n   47          /** Recursive function for displaying shader reflection member\n\n/home/max/dev/Falcor/src/Falcor/Core/Platform/Windows/Windows.cpp:\n  488      }\n  489  \n  490:     static std::unordered_map<std::string, std::pair<std::thread, bool> > fileThreads;\n  491  \n  492      static void checkFileModifiedStatus(const std::string& filePath, const std::function<void()>& callback)\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/Program.h:\n  284      static std::vector<std::weak_ptr<Program>> sPrograms;\n  285  \n  286:     using string_time_map = std::unordered_map<std::string, time_t>;\n  287      mutable string_time_map mFileTimeMap;\n  288  \n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramReflection.h:\n  880          slang::TypeLayoutReflection*    pSlangTypeLayout);\n  881      std::vector<std::shared_ptr<const ReflectionVar>> mMembers;   // Struct members\n  882:     std::unordered_map<std::string, int32_t> mNameToIndex; // Translates from a name to an index in mMembers\n  883      std::string mName;\n  884  };\n  ...\n 1428          ReflectionBasicType::Type type = ReflectionBasicType::Type::Unknown; ///> The type of the variable\n 1429      };\n 1430:     using VariableMap = std::unordered_map<std::string, ShaderVariable>;\n 1431  \n 1432      using BindLocation = ParameterBlockReflection::BindLocation;\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramVersion.h:\n  260  \n  261          // Cached version of compiled kernels for this program version\n  262:         mutable std::unordered_map<std::string, ProgramKernels::SharedPtr> mpKernels;\n  263      };\n  264  }\n\n/home/max/dev/Falcor/src/Falcor/Core/State/StateGraph.h:\n   99  \n  100   private:\n  101:     using edge_map = std::unordered_map<EdgeType, uint32_t, EdgeHashType>;\n  102      \n  103      const auto getEdgeIt(const EdgeType& e) const {\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraph.cpp:\n  592      // Gather list of passes by order they were added\n  593      std::vector<NodeData*> nodeVec;\n  594:     std::unordered_map<RenderPass*, RenderPassReflection> passReflectionMap;\n  595  \n  596      if (executionOrder.size() > 0) {\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraph.h:\n  232  \n  233          Scene::SharedPtr mpScene;\n  234:         std::unordered_map<std::string, uint32_t> mNameToIndex;\n  235          DirectedGraph::SharedPtr mpGraph;\n  236:         std::unordered_map<uint32_t, EdgeData> mEdgeData;\n  237:         std::unordered_map<uint32_t, NodeData> mNodeData;\n  238  \n  239          struct GraphOut {\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraphCompiler.cpp:\n  216  void RenderGraphCompiler::allocateResources(ResourceCache* pResourceCache) {\n  217      // Build list to look up execution order index from the pass\n  218:     std::unordered_map<RenderPass*, uint32_t> passToIndex;\n  219      for (size_t i = 0; i < mExecutionList.size(); i++) {\n  220          passToIndex.emplace(mExecutionList[i].pPass.get(), uint32_t(i));\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraphUI.cpp:\n  155          uint32_t mPinIndexToDisplay = uint32_t(-1);\n  156          bool mPopupPinIsInput = false;\n  157:         std::unordered_map<uint32_t, ImGui::Node*> mpIDtoNode;\n  158      };\n  159  \n  ...\n 1286          std::unordered_set<std::string> nodeConnectedInput;\n 1287          std::unordered_set<std::string> nodeConnectedOutput;\n 1288:         std::unordered_map<std::string, uint32_t> previousGuiNodeIDs;\n 1289          std::unordered_set<uint32_t> existingIDs;\n 1290  \n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraphUI.h:\n   63  \n   64          std::vector<PinUI> mInputPins;\n   65:         std::unordered_map<std::string, uint32_t> mNameToIndexInput;\n   66  \n   67          std::vector<PinUI> mOutputPins;\n   68:         std::unordered_map<std::string, uint32_t> mNameToIndexOutput;\n   69  \n   70          uint32_t mGuiNodeID;\n   ..\n  190          std::vector<const char*> mAllNodeTypes;\n  191  \n  192:         std::unordered_map <std::string, RenderPassUI> mRenderPassUI;\n  193  \n  194:         std::unordered_map <std::string, uint32_t> mInputPinStringToLinkID;\n  195  \n  196          // maps output pin name to input pin ids. Pair first is pin id, second is node id\n  197:         std::unordered_map <std::string, std::vector< std::pair<uint32_t, uint32_t > > > mOutputToInputPins;\n  198  \n  199          // if in external editing mode, building list of commands for changes to send to the other process\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderPassLibrary.h:\n  120              time_t lastModified;\n  121          };\n  122:         std::unordered_map<std::string, LibDesc> mLibs;\n  123:         std::unordered_map<std::string, ExtendedDesc> mPasses;\n  124  \n  125          std::shared_ptr<Device> mpDevice;\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/ResourceCache.h:\n   40   public:\n   41      using SharedPtr = std::shared_ptr<ResourceCache>;\n   42:     using ResourcesMap = std::unordered_map<std::string, Resource::SharedPtr>;\n   43  \n   44      /** Create a new object\n   ..\n   97  \n   98      // Resources and properties for fields within (and therefore owned by) a render graph\n   99:     std::unordered_map<std::string, uint32_t> mNameToIndex;\n  100      std::vector<ResourceData> mResourceData;\n  101  \n\n/home/max/dev/Falcor/src/Falcor/Scene/Scene.cpp:\n  657  \n  658      // The non-instanced meshes are grouped based on what global matrix ID their transform is.\n  659:     std::unordered_map<uint32_t, std::vector<uint32_t>> nodeToMeshList;\n  660      for (uint32_t meshId = 0; meshId < (uint32_t)instanceLists.size(); meshId++) {\n  661          const auto& instanceList = instanceLists[meshId];\n\n/home/max/dev/Falcor/src/Falcor/Scene/Scene.h:\n  526          };\n  527  \n  528:         std::unordered_map<uint32_t, TlasData> mTlasCache;  ///< Top Level Acceleration Structure for scene data cached per shader ray count\n  529                                                              ///< Number of ray types in program affects Shader Table indexing\n  530          Buffer::SharedPtr mpTlasScratch;                    ///< Scratch buffer used for TLAS builds. Can be shared as long as instance desc count is the same, which for now it is.\n\n/home/max/dev/Falcor/src/Falcor/Scene/SceneBuilder.h:\n  216      MeshList mMeshes;\n  217      std::vector<Material::SharedPtr> mMaterials;\n  218:     std::unordered_map<const Material*, uint32_t> mMaterialToId;\n  219  \n  220      Scene::AnimatedObject<Camera> mCamera;\n\n/home/max/dev/Falcor/src/Falcor/Utils/Algorithm/DirectedGraph.h:\n  187          DirectedGraph() = default;\n  188  \n  189:         std::unordered_map<uint32_t, Node> mNodes;\n  190:         std::unordered_map<uint32_t, Edge> mEdges;\n  191          uint32_t mCurrentNodeId = 0;\n  192          uint32_t mCurrentEdgeId = 0;\n\n/home/max/dev/Falcor/src/Falcor/Utils/ArgList.h:\n  104  \n  105   private:\n  106:     std::unordered_map<std::string, std::vector<Arg>> mMap;\n  107  };\n  108  \n\n/home/max/dev/Falcor/src/Falcor/Utils/Scripting/ScriptBindings.cpp:\n   36  {\n   37      ClassesMap sClasses;\n   38:     std::unordered_map<std::type_index, std::string> sEnumNames;\n   39  \n   40      namespace\n\n/home/max/dev/Falcor/src/Falcor/Utils/Scripting/ScriptBindings.h:\n   58          std::function<std::string(const void*)> printF;\n   59      };\n   60:     std::unordered_map<std::string, Funcs> funcs;\n   61      std::string name;\n   62  };\n   63  \n   64: using ClassesMap = std::unordered_map<std::type_index, ClassDesc>;\n   65  dlldecl extern ClassesMap sClasses;\n   66: dlldecl extern std::unordered_map<std::type_index, std::string> sEnumNames;\n   67  \n   68  using BindComponentFunc = std::function<void(ScriptBindings::Module& m)>;\n\n/home/max/dev/Falcor/src/Falcor/Utils/TermColor.cpp:\n   67  #endif\n   68  \n   69: static const std::unordered_map<TermColor, std::string> kBeginTag = {\n   70      { TermColor::Gray,    \"\\33[90m\" },\n   71      { TermColor::Red,     \"\\33[91m\" },\n\n/home/max/dev/Falcor/src/Falcor/Utils/Timing/Profiler.cpp:\n   43      bool gProfileEnabled = false;  // TODO: make configurable\n   44  \n   45:     using DeviceProfilerEvents = std::unordered_map<std::string, Profiler::EventData*>;\n   46  \n   47:     std::unordered_map<Profiler::DeviceEventKey, Profiler::EventData*, Profiler::device_event_key_hash> Profiler::sProfilerEvents;\n   48      std::vector<Profiler::EventData*> Profiler::sRegisteredEvents;\n   49      std::string curEventName = \"\";\n\n/home/max/dev/Falcor/src/Falcor/Utils/Timing/Profiler.h:\n  161      static double getCpuTime(const EventData* pData);\n  162  \n  163:     static std::unordered_map<DeviceEventKey, EventData*, device_event_key_hash> sProfilerEvents;\n  164      static std::vector<EventData*> sRegisteredEvents;\n  165      static uint32_t sCurrentLevel;\n\n/home/max/dev/Falcor/src/Falcor/Utils/UI/Gui.cpp:\n   56              int32_t currentItem = -1;\n   57          };\n   58:         std::unordered_map<std::string, ComboData> mDropDownValues;\n   59  \n   60          // This struct is used to cache the mouse events\n   ..\n   78          ParameterBlockReflection::BindLocation mGuiImageLoc;\n   79          float mScaleFactor = 1.0f;\n   80:         std::unordered_map<std::string, ImFont*> mFontMap;\n   81          ImFont* mpActiveFont = nullptr;\n   82  \n\n/home/max/dev/Falcor/src/Mogwai/Extensions/Capture/CaptureTrigger.h:\n   65  \n   66          using range_vec = std::vector<Range>;\n   67:         std::unordered_map<const RenderGraph*, range_vec> mGraphRanges;\n   68  \n   69          std::string mBaseFilename = \"Mogwai\";\n\n/home/max/dev/Falcor/src/Mogwai/Mogwai.h:\n   68          Bindings(ScriptBindings::Module& m, ScriptBindings::Class<Renderer>& c) : mModule(m), mMogwai(c) {}\n   69          friend class Renderer;\n   70:         std::unordered_map<std::string, std::string> mGlobalObjects;\n   71          ScriptBindings::Module& mModule;\n   72          ScriptBindings::Class<Renderer>& mMogwai;\n   ..\n  139          std::vector<std::string> originalOutputs;\n  140          std::vector<DebugWindow> debugWindows;\n  141:         std::unordered_map<std::string, uint32_t> graphOutputRefs;\n  142      };\n  143  \n\n/home/max/dev/Falcor/src/RenderPasses/PixelInspectorPass/PixelInspectorPass.h:\n   63      float2                                mCursorPosition = float2(0.0f);\n   64      float2                                mSelectedCursorPosition = float2(0.0f);\n   65:     std::unordered_map<std::string, bool> mAvailableInputs;\n   66:     std::unordered_map<std::string, bool> mIsInputInBounds;\n   67  \n   68      // UI variables\n\n/home/max/dev/Falcor/src/Tools/ImageCompare/args.h:\n 3665       * \\tparam T the type to store the result as\n 3666       * \\tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with operator(), and returning a bool (if ARGS_NOEXCEPT is defined)\n 3667:      * \\tparam Map The Map type.  Should operate like std::map or std::unordered_map\n 3668       */\n 3669      template <\n ....\n 3671          typename T,\n 3672          typename Reader = ValueReader,\n 3673:         template <typename...> class Map = std::unordered_map>\n 3674      class MapFlag : public ValueFlagBase\n 3675      {\n ....\n 3753       * \\tparam List the list type that houses the values\n 3754       * \\tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with operator(), and returning a bool (if ARGS_NOEXCEPT is defined)\n 3755:      * \\tparam Map The Map type.  Should operate like std::map or std::unordered_map\n 3756       */\n 3757      template <\n ....\n 3760          template <typename...> class List = std::vector,\n 3761          typename Reader = ValueReader,\n 3762:         template <typename...> class Map = std::unordered_map>\n 3763      class MapFlagList : public ValueFlagBase\n 3764      {\n ....\n 4064       * \\tparam T the type to store the result as\n 4065       * \\tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with operator(), and returning a bool (if ARGS_NOEXCEPT is defined)\n 4066:      * \\tparam Map The Map type.  Should operate like std::map or std::unordered_map\n 4067       */\n 4068      template <\n ....\n 4070          typename T,\n 4071          typename Reader = ValueReader,\n 4072:         template <typename...> class Map = std::unordered_map>\n 4073      class MapPositional : public PositionalBase\n 4074      {\n ....\n 4145       * \\tparam List the list type that houses the values\n 4146       * \\tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with operator(), and returning a bool (if ARGS_NOEXCEPT is defined)\n 4147:      * \\tparam Map The Map type.  Should operate like std::map or std::unordered_map\n 4148       */\n 4149      template <\n ....\n 4152          template <typename...> class List = std::vector,\n 4153          typename Reader = ValueReader,\n 4154:         template <typename...> class Map = std::unordered_map>\n 4155      class MapPositionalList : public PositionalBase\n 4156      {\n\n/home/max/dev/Falcor/src/Tools/RenderGraphEditor/RenderGraphEditor.h:\n   57      std::vector<RenderGraph::SharedPtr> mpGraphs;\n   58      std::vector<RenderGraphUI> mRenderGraphUIs;\n   59:     std::unordered_map<std::string, uint32_t> mGraphNamesToIndex;\n   60      size_t mCurrentGraphIndex;\n   61      uint2 mWindowSize;\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/Include/Common.h:\n  193  \n  194  template <class K, class D, class HASH = std::hash<K>, class PRED = std::equal_to<K> >\n  195: class TUnorderedMap : public std::unordered_map<K, D, HASH, PRED, pool_allocator<std::pair<K const, D> > > {\n  196  };\n  197  \n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/iomapper.cpp:\n  376  \n  377      typedef std::vector<int> TSlotSet;\n  378:     typedef std::unordered_map<int, TSlotSet> TSlotSetMap;\n  379      TSlotSetMap slots;\n  380  \n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/localintermediate.h:\n  889      bool usePhysicalStorageBuffer;\n  890  \n  891:     std::unordered_map<std::string, int> uniformLocationOverrides;\n  892      int uniformLocationBase;\n  893  \n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/propagateNoContraction.cpp:\n   69  typedef std::unordered_multimap<ObjectAccessChain, glslang::TIntermOperator*> NodeMapping;\n   70  // Mapping from object nodes to their access chain info string.\n   71: typedef std::unordered_map<glslang::TIntermTyped*, ObjectAccessChain> AccessChainMapping;\n   72  \n   73  // Set of object IDs.\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/reflection.h:\n  163      void buildAttributeReflection(EShLanguage, const TIntermediate&);\n  164  \n  165:     // Need a TString hash: typedef std::unordered_map<TString, int> TNameToIndex;\n  166      typedef std::map<std::string, int> TNameToIndex;\n  167      typedef std::vector<TObjectReflection> TMapIndexToReflection;\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/MachineIndependent/Scan.cpp:\n  324  // A single global usable by all threads, by all versions, by all languages.\n  325  // After a single process-level initialization, this is read only and thread safe\n  326: std::unordered_map<const char*, int, str_hash, str_eq>* KeywordMap = nullptr;\n  327  std::unordered_set<const char*, str_hash, str_eq>* ReservedSet = nullptr;\n  328  \n  ...\n  338          return;\n  339      }\n  340:     KeywordMap = new std::unordered_map<const char*, int, str_hash, str_eq>;\n  341  \n  342      (*KeywordMap)[\"const\"] =                   CONST;\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/SPIRV/GlslangToSpv.cpp:\n  226      const glslang::TIntermediate* glslangIntermediate;\n  227      spv::Id stdBuiltins;\n  228:     std::unordered_map<const char*, spv::Id> extBuiltinMap;\n  229  \n  230:     std::unordered_map<int, spv::Id> symbolValues;\n  231      std::unordered_set<int> rValueParameters;  // set of formal function parameters passed as rValues, rather than a pointer\n  232:     std::unordered_map<std::string, spv::Function*> functionMap;\n  233:     std::unordered_map<const glslang::TTypeList*, spv::Id> structMap[glslang::ElpCount][glslang::ElmCount];\n  234      // for mapping glslang block indices to spv indices (e.g., due to hidden members):\n  235:     std::unordered_map<const glslang::TTypeList*, std::vector<int> > memberRemapper;\n  236      std::stack<bool> breakForLoop;  // false means break for switch\n  237:     std::unordered_map<std::string, const glslang::TIntermSymbol*> counterOriginator;\n  238      // Map pointee types for EbtReference to their forward pointers\n  239      std::map<const glslang::TType *, spv::Id> forwardPointers;\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/SPIRV/SpvBuilder.h:\n  734  \n  735       // not output, internally used for quick & dirty canonical (unique) creation\n  736:     std::unordered_map<unsigned int, std::vector<Instruction*>> groupedConstants;       // map type opcodes to constant inst.\n  737:     std::unordered_map<unsigned int, std::vector<Instruction*>> groupedStructConstants; // map struct-id to constant instructions\n  738:     std::unordered_map<unsigned int, std::vector<Instruction*>> groupedTypes;           // map type opcodes to type instructions\n  739  \n  740      // stack of switches\n  ...\n  745  \n  746      // map from strings to their string ids\n  747:     std::unordered_map<std::string, spv::Id> stringIds;\n  748  \n  749      // map from include file name ids to their contents\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/SPIRV/SPVRemapper.cpp:\n  780  \n  781          spv::Op          thisOpCode(spv::OpNop);\n  782:         std::unordered_map<int, int> opCounter;\n  783          int              idCounter(0);\n  784          fnId = spv::NoResult;\n  ...\n 1107          msg(3, 2, std::string(\"DCE Vars: \"));\n 1108  \n 1109:         std::unordered_map<spv::Id, int> varUseCount;\n 1110  \n 1111          // Count function variable use\n ....\n 1157              isType[asTypeConstId(typeStart)] = true;\n 1158  \n 1159:         std::unordered_map<spv::Id, int> typeUseCount;\n 1160  \n 1161          // This is not the most efficient algorithm, but this is an offline tool, and\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/SPIRV/SPVRemapper.h:\n  135  private:\n  136     // Local to global, or global to local ID map\n  137:    typedef std::unordered_map<spv::Id, spv::Id> idmap_t;\n  138     typedef std::unordered_set<spv::Id>          idset_t;\n  139:    typedef std::unordered_map<spv::Id, int>     blockmap_t;\n  140  \n  141     void remap(std::uint32_t opts = DO_EVERYTHING);\n  142  \n  143     // Map of names to IDs\n  144:    typedef std::unordered_map<std::string, spv::Id> namemap_t;\n  145  \n  146     typedef std::uint32_t spirword_t;\n  ...\n  163     // A set that preserves position order, and a reverse map\n  164     typedef std::set<int>                    posmap_t;\n  165:    typedef std::unordered_map<spv::Id, int> posmap_rev_t;\n  166  \n  167     // Maps and ID to the size of its base type, if known.\n  168:    typedef std::unordered_map<spv::Id, unsigned> typesize_map_t;\n  169  \n  170     // handle error\n  ...\n  269     // Function start and end.  use unordered_map because we'll have\n  270     // many fewer functions than IDs.\n  271:    std::unordered_map<spv::Id, range_t> fnPos;\n  272  \n  273     // Which functions are called, anywhere in the module, with a call count\n  274:    std::unordered_map<spv::Id, int> fnCalls;\n  275  \n  276     posmap_t       typeConstPos;  // word positions that define types & consts (ordered)\n\n/home/max/dev/Falcor/src/USD/hgiVk/vulkanMemoryAllocator/vk_mem_alloc.h:\n 3524  \n 3525  /* Set this macro to 1 to make the library including and using STL containers:\n 3526: std::pair, std::vector, std::list, std::unordered_map.\n 3527  \n 3528  Set it to 0 or undefined to make the library using its own implementation of\n ....\n 5256  \n 5257  #define VMA_MAP_TYPE(KeyT, ValueT) \\\n 5258:     std::unordered_map< KeyT, ValueT, std::hash<KeyT>, std::equal_to<KeyT>, VmaStlAllocator< std::pair<KeyT, ValueT> > >\n 5259  \n 5260  #else // #if VMA_USE_STL_UNORDERED_MAP\n ....\n 5270  };\n 5271  \n 5272: /* Class compatible with subset of interface of std::unordered_map.\n 5273  KeyT, ValueT must be POD because they will be stored in VmaVector.\n 5274  */\n\n89 matches across 43 files\n\n\nSearching 1282 files for \"ResourceViewInfo\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Buffer.cpp:\n  181  template<typename ViewClass, typename ViewMapType>\n  182  typename ViewClass::SharedPtr findViewCommon(Buffer* pBuffer, uint32_t firstElement, uint32_t elementCount, ViewMapType& viewMap, CreateFuncType<ViewClass> createFunc) {\n  183:     ResourceViewInfo view = ResourceViewInfo(firstElement, elementCount);\n  184  \n  185      if (viewMap.find(view) == viewMap.end()) {\n\n/home/max/dev/Falcor/src/Falcor/Core/API/CopyContext.cpp:\n   73  }\n   74  \n   75: bool CopyContext::resourceBarrier(const Resource* pResource, Resource::State newState, const ResourceViewInfo* pViewInfo) {\n   76      const Texture* pTexture = dynamic_cast<const Texture*>(pResource);\n   77      if (pTexture) {\n   ..\n   95  }\n   96  \n   97: bool CopyContext::subresourceBarriers(const Texture* pTexture, Resource::State newState, const ResourceViewInfo* pViewInfo) {\n   98:     ResourceViewInfo fullResource;\n   99      bool setGlobal = false;\n  100  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/CopyContext.h:\n   94          \\return true if a barrier commands were recorded for the entire resource-view, otherwise false (for example, when the current resource state is the same as the new state or when only some subresources were transitioned)\n   95      */\n   96:     virtual bool resourceBarrier(const Resource* pResource, Resource::State newState, const ResourceViewInfo* pViewInfo = nullptr);\n   97  \n   98      /** Insert a UAV barrier\n   ..\n  156      bool textureBarrier(const Texture* pTexture, Resource::State newState);\n  157      bool bufferBarrier(const Buffer* pBuffer, Resource::State newState);\n  158:     bool subresourceBarriers(const Texture* pTexture, Resource::State newState, const ResourceViewInfo* pViewInfo);\n  159      void apiSubresourceBarrier(const Texture* pTexture, Resource::State newState, Resource::State oldState, uint32_t arraySlice, uint32_t mipLevel);\n  160      void updateTextureSubresources(const Texture* pTexture, uint32_t firstSubresource, uint32_t subresourceCount, const void* pData, const uint3& offset = uint3(0), const uint3& size = uint3(-1));\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Resource.h:\n  131  \n  132      struct ViewInfoHashFunc {\n  133:         std::size_t operator()(const ResourceViewInfo& v) const {\n  134              return ((std::hash<uint32_t>()(v.firstArraySlice) ^ (std::hash<uint32_t>()(v.arraySize) << 1)) >> 1)\n  135                  ^ (std::hash<uint32_t>()(v.mipCount) << 1)\n  ...\n  199      std::shared_ptr<Device> mpDevice;\n  200  \n  201:     mutable std::unordered_map<ResourceViewInfo, ShaderResourceView::SharedPtr, ViewInfoHashFunc> mSrvs;\n  202:     mutable std::unordered_map<ResourceViewInfo, RenderTargetView::SharedPtr, ViewInfoHashFunc> mRtvs;\n  203:     mutable std::unordered_map<ResourceViewInfo, DepthStencilView::SharedPtr, ViewInfoHashFunc> mDsvs;\n  204:     mutable std::unordered_map<ResourceViewInfo, UnorderedAccessView::SharedPtr, ViewInfoHashFunc> mUavs;\n  205  };\n  206  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/ResourceViews.h:\n   45  using ConstBufferSharedPtrRef = const std::shared_ptr<Buffer>&;\n   46  \n   47: struct dlldecl ResourceViewInfo {\n   48:     ResourceViewInfo() = default;\n   49:     ResourceViewInfo(uint32_t mostDetailedMip, uint32_t mipCount, uint32_t firstArraySlice, uint32_t arraySize)\n   50          : mostDetailedMip(mostDetailedMip), mipCount(mipCount), firstArraySlice(firstArraySlice), arraySize(arraySize) {}\n   51  \n   52:     ResourceViewInfo(uint32_t firstElement, uint32_t elementCount)\n   53          : firstElement(firstElement), elementCount(elementCount) {}\n   54  \n   ..\n   65      uint32_t elementCount = kMaxPossible;\n   66  \n   67:     bool operator==(const ResourceViewInfo& other) const {\n   68          return (firstArraySlice == other.firstArraySlice)\n   69              && (arraySize == other.arraySize)\n   ..\n   96      /** Get information about the view.\n   97      */\n   98:     const ResourceViewInfo& getViewInfo() const { return mViewInfo; }\n   99  \n  100      /** Get the resource referenced by the view.\n  ...\n  104   protected:\n  105      ApiHandle mApiHandle;\n  106:     ResourceViewInfo mViewInfo;\n  107      ResourceWeakPtr mpResource;\n  108      std::shared_ptr<Device> mpDevice;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Texture.cpp:\n  168      }\n  169  \n  170:     ResourceViewInfo view = ResourceViewInfo(mostDetailedMip, mipCount, firstArraySlice, arraySize);\n  171  \n  172      if (viewMap.find(view) == viewMap.end()) {\n\n/home/max/dev/Falcor/src/Falcor/Raytracing/RtProgramVarsHelper.cpp:\n   53      }\n   54  \n   55:     bool RtVarsContext::resourceBarrier(const Resource* pResource, Resource::State newState, const ResourceViewInfo* pViewInfo)\n   56      {\n   57          return gpDevice->getRenderContext()->resourceBarrier(pResource, newState, pViewInfo);\n\n/home/max/dev/Falcor/src/Falcor/Raytracing/RtProgramVarsHelper.h:\n  151  \n  152          const LowLevelContextData::SharedPtr& getLowLevelData() const override { return mpLowLevelData; }\n  153:         bool resourceBarrier(const Resource* pResource, Resource::State newState, const ResourceViewInfo* pViewInfo = nullptr) override;\n  154          RtVarsCmdList::SharedPtr getRtVarsCmdList() const { return mpList; }\n  155  \n\n23 matches across 8 files\n\n\nSearching 1282 files for \"Resource(\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Buffer.cpp:\n   60  void* mapBufferApi(std::shared_ptr<Device> pDevice, const Buffer::ApiHandle& apiHandle, size_t size);\n   61  \n   62: Buffer::Buffer(std::shared_ptr<Device> pDevice, size_t size, BindFlags bindFlags, CpuAccess cpuAccess): Resource(pDevice, Type::Buffer, bindFlags, size), mCpuAccess(cpuAccess) {}\n   63  \n   64  Buffer::SharedPtr Buffer::create(std::shared_ptr<Device> pDevice, size_t size, BindFlags bindFlags, CpuAccess cpuAccess, const void* pInitData) {\n   ..\n  125  {\n  126      const auto& pDefaultBlock = pProgram->getReflector()->getDefaultParameterBlock();\n  127:     const ReflectionVar* pVar = pDefaultBlock ? pDefaultBlock->getResource(name).get() : nullptr;\n  128      if (pVar == nullptr) {\n  129          throw std::runtime_error(\"Can't find a structured buffer named `\" + name + \"` in the program\");\n  ...\n  132  }\n  133  \n  134: Buffer::SharedPtr Buffer::aliasResource(std::shared_ptr<Device> pDevice, Resource::SharedPtr pBaseResource, GpuAddress offset, size_t size, Resource::BindFlags bindFlags) {\n  135      assert(pBaseResource->asBuffer()); // Only aliasing buffers for now\n  136      CpuAccess cpuAccess = pBaseResource->asBuffer() ? pBaseResource->asBuffer()->getCpuAccess() : CpuAccess::None;\n  137      if (cpuAccess != CpuAccess::None) {\n  138:         logError(\"Buffer::aliasResource() - trying to alias a buffer with CpuAccess::\" + to_string(cpuAccess) + \" which is illegal. Aliased resource must have CpuAccess::None\");\n  139          return nullptr;\n  140      }\n  141  \n  142      if ((pBaseResource->getBindFlags() & bindFlags) != bindFlags) {\n  143:         logError(\"Buffer::aliasResource() - requested buffer bind-flags don't match the aliased resource bind flags.\\nRequested = \" + to_string(bindFlags) + \"\\nAliased = \" + to_string(pBaseResource->getBindFlags()));\n  144          return nullptr;\n  145      }\n  146  \n  147      if (offset >= pBaseResource->getSize() || (offset + size) >= pBaseResource->getSize()) {\n  148:         logError(\"Buffer::aliasResource() - requested offset and size don't fit inside the alias resource dimensions. Requesed size = \" +\n  149              to_string(size) + \", offset = \" + to_string(offset) + \". Aliased resource size = \" + to_string(pBaseResource->getSize()));\n  150          return nullptr;\n  ...\n  172          mpDevice->getUploadHeap()->release(mDynamicData);\n  173      } else {\n  174:         mpDevice->releaseResource(mApiHandle);\n  175      }\n  176  }\n  ...\n  288              RenderContext* pContext = mpDevice->getRenderContext();\n  289              assert(mGpuVaOffset == 0);\n  290:             pContext->copyResource(mpStagingResource.get(), this);\n  291              pContext->flush(true);\n  292  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Buffer.h:\n  180          bool createCounter = true);\n  181  \n  182:     static SharedPtr aliasResource(std::shared_ptr<Device> pDevice, Resource::SharedPtr pBaseResource, GpuAddress offset, size_t size, Resource::BindFlags bindFlags);\n  183  \n  184      /** Create a new buffer from an existing API handle.\n\n/home/max/dev/Falcor/src/Falcor/Core/API/ComputeStateObject.cpp:\n   40  \n   41  ComputeStateObject::~ComputeStateObject() {\n   42:     mpDevice->releaseResource(mApiHandle);\n   43  }\n   44  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/CopyContext.h:\n  102      /** Copy an entire resource\n  103      */\n  104:     void copyResource(const Resource* pDst, const Resource* pSrc);\n  105  \n  106      /** Copy a subresource\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Buffer.cpp:\n   55          ID3D12ResourcePtr pApiHandle;\n   56          D3D12_HEAP_FLAGS heapFlags = is_set(bindFlags, ResourceBindFlags::Shared) ? D3D12_HEAP_FLAG_SHARED : D3D12_HEAP_FLAG_NONE;\n   57:         d3d_call(pDevice->CreateCommittedResource(&heapProps, heapFlags, &bufDesc, d3dState, nullptr, IID_PPV_ARGS(&pApiHandle)));\n   58          \n   59          // Map and upload data if needed\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12ComputeContext.cpp:\n  118      void clearUavCommon(ComputeContext* pContext, const UnorderedAccessView* pUav, const ClearType& clear, ID3D12GraphicsCommandList* pList)\n  119      {\n  120:         pContext->resourceBarrier(pUav->getResource(), Resource::State::UnorderedAccess);\n  121          UavHandle uav = pUav->getApiHandle();\n  122          if (typeid(ClearType) == typeid(float4))\n  123          {\n  124:             pList->ClearUnorderedAccessViewFloat(uav->getGpuHandle(0), uav->getCpuHandle(0), pUav->getResource()->getApiHandle(), (float*)value_ptr(clear), 0, nullptr);\n  125          }\n  126          else if (typeid(ClearType) == typeid(uint4))\n  127          {\n  128:             pList->ClearUnorderedAccessViewUint(uav->getGpuHandle(0), uav->getCpuHandle(0), pUav->getResource()->getApiHandle(), (uint32_t*)value_ptr(clear), 0, nullptr);\n  129          }\n  130          else\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12CopyContext.cpp:\n  277      }\n  278  \n  279:     void CopyContext::copyResource(const Resource* pDst, const Resource* pSrc)\n  280      {\n  281          resourceBarrier(pDst, Resource::State::CopyDest);\n  282          resourceBarrier(pSrc, Resource::State::CopySource);\n  283:         mpLowLevelData->getCommandList()->CopyResource(pDst->getApiHandle(), pSrc->getApiHandle());\n  284          mCommandsPending = true;\n  285      }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12NvApiExDesc.h:\n   86      {\n   87          auto pBlock = pKernels->getReflector()->getDefaultParameterBlock();\n   88:         auto pVar = pBlock->getResource(\"g_NvidiaExt\");\n   89          if (!pVar) return std::optional<uint32_t>();\n   90  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12RenderContext.cpp:\n  140      void RenderContext::clearRtv(const RenderTargetView* pRtv, const float4& color)\n  141      {\n  142:         resourceBarrier(pRtv->getResource(), Resource::State::RenderTarget);\n  143          mpLowLevelData->getCommandList()->ClearRenderTargetView(pRtv->getApiHandle()->getCpuHandle(0), glm::value_ptr(color), 0, nullptr);\n  144          mCommandsPending = true;\n  ...\n  150          flags |= clearStencil ? D3D12_CLEAR_FLAG_STENCIL : 0;\n  151  \n  152:         resourceBarrier(pDsv->getResource(), Resource::State::DepthStencil);\n  153          mpLowLevelData->getCommandList()->ClearDepthStencilView(pDsv->getApiHandle()->getCpuHandle(0), D3D12_CLEAR_FLAGS(flags), depth, stencil, 0, nullptr);\n  154          mCommandsPending = true;\n  ...\n  424          assert(pDst->getViewInfo().arraySize == 1 && pDst->getViewInfo().mipCount == 1);\n  425  \n  426:         const Texture* pSrcTexture = dynamic_cast<const Texture*>(pSrc->getResource());\n  427:         const Texture* pDstTexture = dynamic_cast<const Texture*>(pDst->getResource());\n  428          assert(pSrcTexture != nullptr && pDstTexture != nullptr);\n  429  \n  ...\n  487      }\n  488  \n  489:     void RenderContext::resolveResource(const Texture::SharedPtr& pSrc, const Texture::SharedPtr& pDst)\n  490      {\n  491          bool match = true;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/D3D12/D3D12Texture.cpp:\n  143  \n  144          D3D12_HEAP_FLAGS heapFlags = is_set(mBindFlags, ResourceBindFlags::Shared) ? D3D12_HEAP_FLAG_SHARED : D3D12_HEAP_FLAG_NONE;\n  145:         d3d_call(gpDevice->getApiHandle()->CreateCommittedResource(&kDefaultHeapProps, heapFlags, &desc, D3D12_RESOURCE_STATE_COMMON, pClearVal, IID_PPV_ARGS(&mApiHandle)));\n  146  \n  147          if (pData)\n  ...\n  153      Texture::~Texture()\n  154      {\n  155:         gpDevice->releaseResource(mApiHandle);\n  156      }\n  157  }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Device.cpp:\n  227  }\n  228  \n  229: void Device::releaseResource(ApiObjectHandle pResource) {\n  230      if (pResource) {\n  231          // Some static objects get here when the application exits\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Device.h:\n  193      const DescriptorPool::SharedPtr& getGpuDescriptorPool() const { return mpGpuDescPool; }\n  194      const GpuMemoryHeap::SharedPtr& getUploadHeap() const { return mpUploadHeap; }\n  195:     void releaseResource(ApiObjectHandle pResource);\n  196      double getGpuTimestampFrequency() const { return mGpuTimestampFrequency; }  // ms/tick\n  197  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/GraphicsStateObject.cpp:\n   67  \n   68  GraphicsStateObject::~GraphicsStateObject() {\n   69:     mpDevice->releaseResource(mApiHandle);\n   70  }\n   71  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/RenderContext.h:\n  181          If any of these properties don't match, you'll have to use `resolveSubresource`\n  182      */\n  183:     void resolveResource(const Texture::SharedPtr& pSrc, const Texture::SharedPtr& pDst);\n  184  \n  185      /** Resolve a multi-sampled sub-resource\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Resource.cpp:\n   32  namespace Falcor {\n   33  \n   34: Resource::~Resource() = default;\n   35  \n   36  const std::string to_string(Resource::Type type) {\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Resource.h:\n   97      static const uint32_t kMaxPossible = RenderTargetView::kMaxPossible;\n   98  \n   99:     virtual ~Resource() = 0;\n  100  \n  101      std::shared_ptr<Device> device() { return mpDevice; }\n  ...\n  177      friend class CopyContext;\n  178  \n  179:     Resource(std::shared_ptr<Device> pDevice, Type type, BindFlags bindFlags, uint64_t size) : mpDevice(pDevice), mType(type), mBindFlags(bindFlags), mSize(size) {}\n  180  \n  181      Type mType;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/ResourceViews.h:\n   85  \n   86      ResourceView(std::shared_ptr<Device> pDevice, ResourceWeakPtr& pResource, ApiHandle handle, uint32_t mostDetailedMip, uint32_t mipCount, uint32_t firstArraySlice, uint32_t arraySize)\n   87:         : mApiHandle(handle), mpDevice(pDevice), mpResource(pResource), mViewInfo(mostDetailedMip, mipCount, firstArraySlice, arraySize) {}\n   88  \n   89      ResourceView(std::shared_ptr<Device> pDevice, ResourceWeakPtr& pResource, ApiHandle handle, uint32_t firstElement, uint32_t elementCount)\n   90:         : mApiHandle(handle), mpDevice(pDevice), mpResource(pResource), mViewInfo(firstElement, elementCount) {}\n   91  \n   92      /** Get the raw API handle.\n   ..\n  100      /** Get the resource referenced by the view.\n  101      */\n  102:     Resource* getResource() const { return mpResource.lock().get(); }\n  103  \n  104   protected:\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Texture.cpp:\n  121  \n  122  Texture::Texture(std::shared_ptr<Device> device, uint32_t width, uint32_t height, uint32_t depth, uint32_t arraySize, uint32_t mipLevels, uint32_t sampleCount, ResourceFormat format, Type type, BindFlags bindFlags)\n  123:     : Resource(device, type, bindFlags, 0), mWidth(width), mHeight(height), mDepth(depth), mMipLevels(mipLevels), mSampleCount(sampleCount), mArraySize(arraySize), mFormat(format) {\n  124      assert(width > 0 && height > 0 && depth > 0);\n  125      assert(arraySize > 0 && mipLevels > 0 && sampleCount > 0);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKComputeContext.cpp:\n  102              return;\n  103          }\n  104:         pCtx->resourceBarrier(pView->getResource(), Resource::State::CopyDest);\n  105          VkClearColorValue colVal;\n  106          assert(sizeof(ClearType) <= sizeof(colVal.float32));\n  ...\n  114          range.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;\n  115  \n  116:         vkCmdClearColorImage(pCtx->getLowLevelData()->getCommandList(), pView->getResource()->getApiHandle(), VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, &colVal, 1, &range);\n  117      }\n  118  \n  ...\n  133                  logWarning(\"Vulkan buffer clears only support a single element. A vector was supplied which has different elements per channel. only `x` will be used'\");\n  134              }\n  135:             const Buffer* pBuffer = dynamic_cast<const Buffer*>(pUav->getResource());\n  136              vkCmdFillBuffer(getLowLevelData()->getCommandList(), pBuffer->getApiHandle(), pBuffer->getGpuAddressOffset(), pBuffer->getSize(), value.x);\n  137          }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKCopyContext.cpp:\n  334      }\n  335  \n  336:     void CopyContext::copyResource(const Resource* pDst, const Resource* pSrc)\n  337      {\n  338          const Buffer* pDstBuffer = dynamic_cast<const Buffer*>(pDst);\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKDescriptorSet.cpp:\n   70  \n   71          if (handle.getType() == VkResourceType::Buffer) {\n   72:             Buffer* pBuffer = dynamic_cast<Buffer*>(pView->getResource());\n   73              if (pBuffer->isTyped()) {\n   74                  texelBufferView = pBuffer->getUAV()->getApiHandle();\n   ..\n  127          VkDescriptorBufferInfo info;\n  128  \n  129:         const auto& pBuffer = dynamic_cast<const Buffer*>(pView->getResource());\n  130          assert(pBuffer);\n  131          info.buffer = pBuffer->getApiHandle();\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKFbo.cpp:\n   41  \n   42  Fbo::~Fbo() {\n   43:     mpDevice->releaseResource(std::static_pointer_cast<VkBaseApiHandle>(mApiHandle));\n   44  }\n   45  \n   ..\n  106      vkCreateFramebuffer(mpDevice->getApiHandle(), &frameBufferInfo, nullptr, &frameBuffer);\n  107  \n  108:     if (mApiHandle) mpDevice->releaseResource(std::static_pointer_cast<VkBaseApiHandle>(mApiHandle));\n  109      mApiHandle = ApiHandle::create(mpDevice, pass, frameBuffer);\n  110  }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKRenderContext.cpp:\n   57      void RenderContext::clearDsv(const DepthStencilView* pDsv, float depth, uint8_t stencil, bool clearDepth, bool clearStencil) {\n   58          // LOG_DBG(\"clear dsv\");\n   59:         resourceBarrier(pDsv->getResource(), Resource::State::CopyDest);\n   60  \n   61          VkClearDepthStencilValue val;\n   ..\n   72          range.aspectMask |= clearStencil ? VK_IMAGE_ASPECT_STENCIL_BIT : 0;\n   73  \n   74:         vkCmdClearDepthStencilImage(mpLowLevelData->getCommandList(), pDsv->getResource()->getApiHandle(), VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, &val, 1, &range);\n   75          mCommandsPending = true;\n   76      }\n   ..\n  263      template<uint32_t offsetCount, typename ViewType>\n  264      void initBlitData(const ViewType* pView, const uint4& rect, VkImageSubresourceLayers& layer, VkOffset3D offset[offsetCount]) {\n  265:         const Texture* pTex = dynamic_cast<const Texture*>(pView->getResource());\n  266  \n  267          layer.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT; // Can't blit depth texture\n  ...\n  285  \n  286      void RenderContext::blit(ShaderResourceView::SharedPtr pSrc, RenderTargetView::SharedPtr pDst, const uint4& srcRect, const uint4& dstRect, Sampler::Filter filter) {\n  287:         const Texture* pTexture = dynamic_cast<const Texture*>(pSrc->getResource());\n  288:         resourceBarrier(pSrc->getResource(), Resource::State::CopySource, &pSrc->getViewInfo());\n  289:         resourceBarrier(pDst->getResource(), Resource::State::CopyDest, &pDst->getViewInfo());\n  290  \n  291          if (pTexture && pTexture->getSampleCount() > 1) {\n  ...\n  299              resolve.extent.depth = 1;\n  300  \n  301:             vkCmdResolveImage(mpLowLevelData->getCommandList(), pSrc->getResource()->getApiHandle(), VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, pDst->getResource()->getApiHandle(), VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &resolve);\n  302          } else {\n  303              VkImageBlit blt;\n  ...\n  307              // Vulkan spec requires VK_FILTER_NEAREST if blit source is a depth and/or stencil format\n  308              VkFilter vkFilter = isDepthStencilFormat(pTexture->getFormat()) ? VK_FILTER_NEAREST : getVkFilter(filter);\n  309:             vkCmdBlitImage(mpLowLevelData->getCommandList(), pSrc->getResource()->getApiHandle(), VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, pDst->getResource()->getApiHandle(), VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &blt, vkFilter);\n  310          }\n  311          mCommandsPending = true;\n  312      }\n  313  \n  314:     void RenderContext::resolveResource(const Texture::SharedPtr& pSrc, const Texture::SharedPtr& pDst) {\n  315          // Just blit. It will work\n  316          blit(pSrc->getSRV(), pDst->getRTV());\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKResourceViews.cpp:\n   47  template<typename ApiHandleType>\n   48  ResourceView<ApiHandleType>::~ResourceView() {\n   49:     getResource()->device()->releaseResource(mApiHandle);\n   50  }\n   51  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VkSmartHandle.cpp:\n   56  \n   57      template<>\n   58:     VkResource<VkImage, VkBuffer>::~VkResource() {\n   59:         LOG_DBG(\"~VkResource() <VkImage, VkBuffer>\");\n   60          if (!mpDevice) {\n   61              // #VKTODO This is here because of the black texture in VkResourceViews.cpp\n   ..\n   83  \n   84      template<>\n   85:     VkResource<VkImageView, VkBufferView>::~VkResource() {\n   86:         LOG_DBG(\"~VkResource() <VkImageView, VkBufferView>\");\n   87          if (!mpDevice) {\n   88              // #VKTODO This is here because of the black texture in VkResourceViews.cpp\n   ..\n  129      template VkHandle<VkQueryPool>::~VkHandle();\n  130  \n  131:     template VkResource<VkImage, VkBuffer>::~VkResource();\n  132:     template VkResource<VkImageView, VkBufferView>::~VkResource();\n  133  }  // namespace Falcor\n  134  \n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKSmartHandle.h:\n  163      };\n  164  \n  165:     ~VkResource() {\n  166  #ifdef _WIN32\n  167          static_assert(false, \"VkResource missing destructor specialization\");\n  ...\n  171   private:\n  172      friend SharedPtr;\n  173:     VkResource(std::shared_ptr<Device> device, ImageType image, VkDeviceMemory mem) : VkBaseApiHandle(device), mType(VkResourceType::Image), mImage(image), mDeviceMem(mem) { }\n  174      \n  175:     VkResource(std::shared_ptr<Device> device, BufferType buffer, VkDeviceMemory mem) : VkBaseApiHandle(device), mType(VkResourceType::Buffer), mBuffer(buffer), mDeviceMem(mem) { }\n  176  \n  177      VkResourceType mType = VkResourceType::None;\n  ...\n  219  template<> VkHandle<VkQueryPool>::~VkHandle();\n  220  \n  221: template<> VkResource<VkImage, VkBuffer>::~VkResource();\n  222: template<> VkResource<VkImageView, VkBufferView>::~VkResource();\n  223  \n  224  }  // namespace Falcor\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKTexture.cpp:\n   39      Texture::~Texture() {\n   40          // #VKTODO the `if` is here because of the black texture in VkResourceView.cpp\n   41:         if (mpDevice ) mpDevice->releaseResource(std::static_pointer_cast<VkBaseApiHandle>(mApiHandle));\n   42      }\n   43  \n\n/home/max/dev/Falcor/src/Falcor/Core/BufferTypes/ParameterBlock.cpp:\n  144  Resource::SharedPtr getResourceFromView(const ViewType* pView) {\n  145      if (!pView) return nullptr;\n  146:     auto pResource = pView->getResource();\n  147      if (!pResource) return nullptr;\n  148      return pResource->shared_from_this();\n  ...\n 1149  }\n 1150  \n 1151: static void prepareResource(CopyContext* pContext, Resource* pResource, bool isUav) {\n 1152      if (!pResource) return;\n 1153  \n ....\n 1460          // Prepare all bound resources by inserting appropriate barriers/transitions as needed.\n 1461          for (auto& srv : mSRVs) {\n 1462:             prepareResource(pContext, srv.pResource.get(), false);\n 1463          }\n 1464  \n 1465          for (auto& uav : mUAVs) {\n 1466:             prepareResource(pContext, uav.pResource.get(), true);\n 1467          }\n 1468  \n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramReflection.cpp:\n 1556      }\n 1557  \n 1558:     const ReflectionVar::SharedConstPtr ParameterBlockReflection::getResource(const std::string& name) const\n 1559      {\n 1560          return getElementType()->findMember(name);\n ....\n 2020      }\n 2021  \n 2022:     const ReflectionVar::SharedConstPtr ProgramReflection::getResource(const std::string& name) const\n 2023      {\n 2024:         return mpDefaultBlock->getResource(name);\n 2025      }\n 2026  \n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ProgramReflection.h:\n  355          ResourceShaderVarOffset resource)\n  356          : mUniform(uniform)\n  357:         , mResource(resource)\n  358      {}\n  359  \n  ...\n  376      ShaderVarOffset(Invalid _ = kInvalid)\n  377          : mUniform(UniformShaderVarOffset::kInvalid)\n  378:         , mResource(ResourceShaderVarOffset::kInvalid)\n  379      {}\n  380  \n  ...\n  391      ShaderVarOffset(Zero)\n  392          : mUniform(UniformShaderVarOffset::kZero)\n  393:         , mResource(ResourceShaderVarOffset::kZero)\n  394      {}\n  395  \n  ...\n  420      /** Get the underlying resource offset.\n  421      */\n  422:     ResourceShaderVarOffset getResource() const\n  423      {\n  424          return mResource;\n  ...\n 1200      /** Get the variable for a resource in the block\n 1201      */\n 1202:     const ReflectionVar::SharedConstPtr getResource(const std::string& name) const;\n 1203  \n 1204      /** Get the bind-location for a resource in the block\n ....\n 1463      /** Get a resource from the default parameter block\n 1464      */\n 1465:     const ReflectionVar::SharedConstPtr getResource(const std::string& name) const;\n 1466  \n 1467      /** Search for a vertex attribute by its semantic name\n\n/home/max/dev/Falcor/src/Falcor/Core/Program/ShaderVar.cpp:\n  169              {\n  170                  UniformShaderVarOffset elementUniformLocation = mOffset.getUniform() + index * pArrayType->getElementByteStride();\n  171:                 ResourceShaderVarOffset elementResourceLocation(mOffset.getResource().getRangeIndex(), mOffset.getResource().getArrayIndex() * elementCount + ResourceShaderVarOffset::ArrayIndex(index));\n  172                  TypedShaderVarOffset newOffset = TypedShaderVarOffset(pArrayType->getElementType().get(), ShaderVarOffset(elementUniformLocation, elementResourceLocation));\n  173                  return ShaderVar(mpBlock, newOffset);\n  ...\n  247              auto offsetIntoElement = byteOffset % elementStride;\n  248  \n  249:             TypedShaderVarOffset elementOffset = TypedShaderVarOffset(pElementType.get(), ShaderVarOffset(mOffset.getUniform() + elementIndex * elementStride, mOffset.getResource()));\n  250              ShaderVar elementCursor(mpBlock, elementOffset);\n  251              return elementCursor[UniformShaderVarOffset(offsetIntoElement)];\n\n/home/max/dev/Falcor/src/Falcor/Core/Sample.cpp:\n  455              auto pSwapChainFbo = mpDevice->getSwapChainFbo();\n  456              RenderContext* pRenderContext = getRenderContext();\n  457:             pRenderContext->copyResource(pSwapChainFbo->getColorTexture(0).get(), mpTargetFBO->getColorTexture(0).get());\n  458  \n  459              // Capture video frame before UI is rendered\n\n/home/max/dev/Falcor/src/Falcor/Raytracing/RtProgramVarsHelper.h:\n   71          void CopyBufferRegion(ID3D12Resource *pDstBuffer, UINT64 DstOffset, ID3D12Resource *pSrcBuffer, UINT64 SrcOffset, UINT64 NumBytes) { should_not_get_here(); }\n   72          void CopyTextureRegion(const D3D12_TEXTURE_COPY_LOCATION *pDst, UINT DstX, UINT DstY, UINT DstZ, const D3D12_TEXTURE_COPY_LOCATION *pSrc, const D3D12_BOX *pSrcBox) { should_not_get_here(); }\n   73:         void CopyResource(ID3D12Resource *pDstResource, ID3D12Resource *pSrcResource) { should_not_get_here(); }\n   74          void CopyTiles(ID3D12Resource *pTiledResource, const D3D12_TILED_RESOURCE_COORDINATE *pTileRegionStartCoordinate, const D3D12_TILE_REGION_SIZE *pTileRegionSize, ID3D12Resource *pBuffer, UINT64 BufferStartOffsetInBytes, D3D12_TILE_COPY_FLAGS Flags) { should_not_get_here(); }\n   75          void ResolveSubresource(ID3D12Resource *pDstResource, UINT DstSubresource, ID3D12Resource *pSrcResource, UINT SrcSubresource, DXGI_FORMAT Format) { should_not_get_here(); }\n   ..\n   98          void ClearUnorderedAccessViewFloat(D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap, D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle, ID3D12Resource *pResource, const FLOAT Values[4], UINT NumRects, const D3D12_RECT *pRects) { should_not_get_here(); }\n   99          void ClearUnorderedAccessViewUint(D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap, D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle, ID3D12Resource *pResource, const UINT Values[4], UINT NumRects, const D3D12_RECT *pRects) { should_not_get_here(); }\n  100:         void DiscardResource(ID3D12Resource *pResource, const D3D12_DISCARD_REGION *pRegion) { should_not_get_here(); }\n  101          void BeginQuery(ID3D12QueryHeap *pQueryHeap, D3D12_QUERY_TYPE Type, UINT Index) { should_not_get_here(); }\n  102          void EndQuery(ID3D12QueryHeap *pQueryHeap, D3D12_QUERY_TYPE Type, UINT Index) { should_not_get_here(); }\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraph.cpp:\n  488      }\n  489  \n  490:     return mpExe->getResource(name);\n  491  }\n  492  \n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraphCompiler.cpp:\n   46      // Register the external resources\n   47      auto pResourcesCache = ResourceCache::create(graph.device());\n   48:     for (const auto&[name, pRes] : dependencies.externalResources) pResourcesCache->registerExternalResource(name, pRes);\n   49  \n   50      c.resolveExecutionOrder();\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraphExe.cpp:\n   87      }\n   88  \n   89:     Resource::SharedPtr RenderGraphExe::getResource(const std::string& name) const {\n   90          assert(mpResourceCache);\n   91:         return mpResourceCache->getResource(name);\n   92      }\n   93  \n   94      void RenderGraphExe::setInput(const std::string& name, const Resource::SharedPtr& pResource) {\n   95:         mpResourceCache->registerExternalResource(name, pResource);\n   96      }\n   97  }\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraphExe.h:\n   70          /** Get a resource from the cache\n   71          */\n   72:         Resource::SharedPtr getResource(const std::string& name) const;\n   73  \n   74          /** Set an external input resource\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderPass.cpp:\n   41  }\n   42  \n   43: const Resource::SharedPtr& RenderData::getResource(const std::string& name) const {\n   44:     return mpResources->getResource(mName + '.' + name);\n   45  }\n   46  \n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderPass.h:\n   46              \\return If the name exists, a pointer to the resource. Otherwise, nullptr\n   47          */\n   48:         const Resource::SharedPtr& operator[](const std::string& name) const { return getResource(name); }\n   49  \n   50          /** Get a resource\n   ..\n   52              \\return If the name exists, a pointer to the resource. Otherwise, nullptr\n   53          */\n   54:         const Resource::SharedPtr& getResource(const std::string& name) const;\n   55  \n   56          /** Get the global dictionary. You can use it to pass data between different passes\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/ResourceCache.cpp:\n   43      }\n   44  \n   45:     const Resource::SharedPtr& ResourceCache::getResource(const std::string& name) const {\n   46          static const Resource::SharedPtr pNull;\n   47          auto extIt = mExternalResources.find(name);\n   ..\n   63      }\n   64  \n   65:     void ResourceCache::registerExternalResource(const std::string& name, const Resource::SharedPtr& pResource) {\n   66          if(pResource) mExternalResources[name] = pResource;\n   67          else\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/ResourceCache.h:\n   57          \\param[in] pResource The resource to register. If this is null, will unregister the resource\n   58      */\n   59:     void registerExternalResource(const std::string& name, const Resource::SharedPtr& pResource);\n   60  \n   61      /** Register a field that requires resources to be allocated.\n   ..\n   70      /** Get a resource by name. Includes external resources known by the cache.\n   71      */\n   72:     const Resource::SharedPtr& getResource(const std::string& name) const;\n   73  \n   74      /** Get the field-reflection of a resource\n\n/home/max/dev/Falcor/src/Falcor/RenderPasses/ResolvePass.cpp:\n   59          }\n   60  \n   61:         pContext->resolveResource(pSrcTex, pDstTex);\n   62      } else {\n   63          logWarning(\"ResolvePass::execute() - missing an input or output resource\");\n\n/home/max/dev/Falcor/src/Falcor/RenderPasses/Shared/PathTracer/PathTracer.cpp:\n  559                  assert(pDstRayCount->getFormat() == pSrcRayCount->getFormat());\n  560                  assert(pDstRayCount->getWidth() == pSrcRayCount->getWidth() && pDstRayCount->getHeight() == pSrcRayCount->getHeight());\n  561:                 pRenderContext->copyResource(pDstRayCount, pSrcRayCount);\n  562              }\n  563          }\n\n/home/max/dev/Falcor/src/Falcor/Scene/Animation/AnimationController.cpp:\n   78              if (mLastAnimationTime == currentTime) {\n   79                  // Copy the current matrices to the previous matrices. We can do that only once, but not sure if it we'll help perf (it only occures when the animation is paused)\n   80:                 pContext->copyResource(mpPrevWorldMatricesBuffer.get(), mpWorldMatricesBuffer.get());\n   81                  return false;\n   82              }\n\n/home/max/dev/Falcor/src/Falcor/Utils/UI/PixelZoom.cpp:\n   73      if (mShouldZoom) {\n   74          //copy backbuffer into src blit fbo\n   75:         pCtx->copyResource(mpSrcBlitFbo->getColorTexture(0).get(), backBuffer->getColorTexture(0).get());\n   76  \n   77          //blit src blit fbo into dst blit fbo\n\n/home/max/dev/Falcor/src/RenderPasses/ForwardLightingPass/ForwardLightingPass.cpp:\n  140      for (uint32_t i = 1; i < 3; i++) {\n  141          const auto& pRtv = mpFbo->getRenderTargetView(i).get();\n  142:         if (pRtv->getResource() != nullptr) pContext->clearRtv(pRtv, float4(0));\n  143      }\n  144  \n\n/home/max/dev/Falcor/src/RenderPasses/GBuffer/GBuffer/GBufferRaster.cpp:\n  188      mpDepthPrePassGraph->execute(pRenderContext);\n  189      mpFbo->attachDepthStencilTarget(mpDepthPrePassGraph->getOutput(\"DepthPrePass.depth\")->asTexture());\n  190:     pRenderContext->copyResource(renderData[kDepthName].get(), mpDepthPrePassGraph->getOutput(\"DepthPrePass.depth\").get());\n  191  \n  192      // Bind extra channels as UAV buffers.\n\n/home/max/dev/Falcor/src/RenderPasses/TemporalDelayPass/TemporalDelayPass.cpp:\n  107  void TemporalDelayPass::execute(RenderContext* pRenderContext, const RenderData& renderData) {\n  108      if (mDelay == 0) {\n  109:         pRenderContext->copyResource(renderData[kMaxDelay].get(), renderData[kSrc].get());\n  110          return;\n  111      }\n  112      for (uint32_t copyDst = 0; copyDst <= mDelay; ++copyDst) {\n  113          uint32_t copySrc = copyDst + 1;\n  114:         if (copyDst == 0) pRenderContext->copyResource(renderData[kMaxDelay].get(), renderData[kMaxDelay + \"-\" + to_string(copySrc)].get());\n  115:         else if (copyDst == mDelay) pRenderContext->copyResource(renderData[kMaxDelay + \"-\" + to_string(copyDst)].get(), renderData[kSrc].get());\n  116:         else pRenderContext->copyResource(renderData[kMaxDelay + \"-\" + to_string(copyDst)].get(), renderData[kMaxDelay + \"-\" + to_string(copySrc)].get());\n  117      }\n  118  }\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/SPIRV/GlslangToSpv.cpp:\n 1195  // Return whether or not the given type is something that should be tied to a\n 1196  // descriptor set.\n 1197: bool IsDescriptorResource(const glslang::TType& type)\n 1198  {\n 1199      // uniform and buffer blocks are included, unless it is a push_constant\n ....\n 7472      if (symbol->getQualifier().hasSet())\n 7473          builder.addDecoration(id, spv::DecorationDescriptorSet, symbol->getQualifier().layoutSet);\n 7474:     else if (IsDescriptorResource(symbol->getType())) {\n 7475          // default to 0\n 7476          builder.addDecoration(id, spv::DecorationDescriptorSet, 0);\n ....\n 7478      if (symbol->getQualifier().hasBinding())\n 7479          builder.addDecoration(id, spv::DecorationBinding, symbol->getQualifier().layoutBinding);\n 7480:     else if (IsDescriptorResource(symbol->getType())) {\n 7481          // default to 0\n 7482          builder.addDecoration(id, spv::DecorationBinding, 0);\n\n115 matches across 49 files\n\n\nSearching 1282 files for \"setResourceSrvUavCommon\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/BufferTypes/ParameterBlock.cpp:\n  546  }\n  547  \n  548: bool ParameterBlock::setResourceSrvUavCommon(const BindLocation& bindLoc, const Resource::SharedPtr& pResource, const char* funcName) {\n  549      size_t flatIndex = getFlatIndex(bindLoc);\n  550  \n  ...\n  636      if (!bindLocation.isValid()) return false;\n  637  \n  638:     return setResourceSrvUavCommon(bindLocation, pBuf, \"setBuffer()\");\n  639  }\n  640  \n  ...\n  715  \n  716  bool ParameterBlock::setTexture(const BindLocation& bindLocation, const Texture::SharedPtr& pTexture) {\n  717:     return setResourceSrvUavCommon(bindLocation, pTexture, \"setTexture()\");\n  718  }\n  719  \n\n/home/max/dev/Falcor/src/Falcor/Core/BufferTypes/ParameterBlock.h:\n  422      bool checkRootDescriptorResourceCompatibility(const Resource::SharedPtr& pResource, const std::string& funcName) const;\n  423  \n  424:     bool setResourceSrvUavCommon(const BindLocation& bindLoc, const Resource::SharedPtr& pResource, const char* funcName);\n  425      Resource::SharedPtr getResourceSrvUavCommon(const BindLocation& bindLoc, const char* funcName) const;\n  426  \n\n4 matches across 2 files\n\n\nSearching 1282 files for \"mDeferredReleases\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Device.cpp:\n  168  void Device::release() {\n  169      LOG_DBG(\"Start deffered releses.\");\n  170:     decltype(mDeferredReleases)().swap(mDeferredReleases);  \n  171      LOG_DBG(\"Deffered releases done.\");\n  172  }\n  ...\n  237          // Some static objects get here when the application exits\n  238          if(this) {\n  239:             mDeferredReleases.push({ mpFrameFence->getCpuValue(), pResource });\n  240          }\n  241      }\n  ...\n  250      uint64_t gpuVal = mpFrameFence->getGpuValue();\n  251  \n  252:     while (mDeferredReleases.size() && mDeferredReleases.front().frameID <= gpuVal) {\n  253:         mDeferredReleases.pop();\n  254      }\n  255      \n  ...\n  268      for (uint32_t i = 0; i < arraysize(mCmdQueues); i++) mCmdQueues[i].clear();\n  269      for (uint32_t i = 0; i < kSwapChainBuffersCount; i++) mpSwapChainFbos[i].reset();\n  270:     mDeferredReleases = decltype(mDeferredReleases)();\n  271      releaseNullViews();\n  272      releaseNullBufferViews();\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Device.h:\n  215      };\n  216  \n  217:     std::queue<ResourceRelease> mDeferredReleases;\n  218  \n  219      uint32_t mCurrentBackBufferIndex;\n\n/home/max/dev/Falcor/src/Falcor/Core/API/GpuMemoryHeap.cpp:\n   33  \n   34      GpuMemoryHeap::~GpuMemoryHeap() {\n   35:         mDeferredReleases = decltype(mDeferredReleases)();\n   36      }\n   37  \n   ..\n   95      void GpuMemoryHeap::release(Allocation& data) {\n   96          assert(data.pResourceHandle);\n   97:         mDeferredReleases.push(data);\n   98      }\n   99  \n  100      void GpuMemoryHeap::executeDeferredReleases() {\n  101          uint64_t gpuVal = mpFence->getGpuValue();\n  102:         while (mDeferredReleases.size() && mDeferredReleases.top().fenceValue <= gpuVal) {\n  103:             const Allocation& data = mDeferredReleases.top();\n  104              \n  105              if (data.pageID == mCurrentPageId) {\n  ...\n  119                  // else it's a mega-page. Popping it will release the resource\n  120              }\n  121:             mDeferredReleases.pop();\n  122          }\n  123      }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/GpuMemoryHeap.h:\n   97      PageData::UniquePtr mpActivePage;\n   98  \n   99:     std::priority_queue<Allocation> mDeferredReleases;\n  100      std::unordered_map<size_t, PageData::UniquePtr> mUsedPages;\n  101      std::queue<PageData::UniquePtr> mAvailablePages;\n\n17 matches across 4 files\n\n\nSearching 1282 files for \"SharedPtr(this)\" (case sensitive)\n\n0 matches\n\nSearching 1282 files for \"smartDevicePtr\" (case sensitive)\n\n0 matches\n\nSearching 1282 files for \"Device uid\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Device.cpp:\n   52      if (!pWindow){\n   53          headless = true;\n   54:         LOG_DBG(\"Device uid: %u type headless\", _uid);\n   55      } else {\n   56          headless = false;\n   57:         LOG_DBG(\"Device uid: %u\", _uid);\n   58      }\n   59  }\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKResourceViews.cpp:\n  302      VkBufferView bufferView = {};\n  303  \n  304:     std::cout << \"Device uid \" << pDevice->uid() << std::endl;\n  305      \n  306      auto handle = VkResource<VkImageView, VkBufferView>::SharedPtr::create(pDevice, bufferView, nullptr);\n\n3 matches across 2 files\n\n\nSearching 1282 files for \"Device uid\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/Device.cpp:\n   52      if (!pWindow){\n   53          headless = true;\n   54:         LOG_DBG(\"Device uid: %u type headless\", _uid);\n   55      } else {\n   56          headless = false;\n   57:         LOG_DBG(\"Device uid: %u\", _uid);\n   58      }\n   59  }\n\n2 matches in 1 file\n\n\nSearching 1282 files for \"loadRenderPassLibrary\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderGraphIR.cpp:\n   41      const char* RenderGraphIR::kAutoGenEdges = \"autoGenEdges\";\n   42      const char* RenderGraphIR::kUpdatePass = \"updatePass\";\n   43:     const char* RenderGraphIR::kLoadPassLibrary = \"loadRenderPassLibrary\";\n   44      const char* RenderGraphIR::kRenderPass = \"RenderPass\";\n   45      const char* RenderGraphIR::kRenderGraph = \"RenderGraph\";\n\n/home/max/dev/Falcor/src/Mogwai/Data/BSDFViewer.py:\n    1  def render_graph_BSDFViewerGraph():\n    2      g = RenderGraph(\"BSDFViewerGraph\")\n    3:     loadRenderPassLibrary(\"AccumulatePass\")\n    4:     loadRenderPassLibrary(\"BSDFViewer\")\n    5      BSDFViewer = RenderPass(\"BSDFViewer\")\n    6      g.addPass(BSDFViewer, \"BSDFViewer\")\n\n/home/max/dev/Falcor/src/Mogwai/Data/ForwardRenderer.py:\n    1  def render_graph_forward_renderer():\n    2:     loadRenderPassLibrary(\"Antialiasing\")\n    3:     loadRenderPassLibrary(\"BlitPass\")\n    4:     loadRenderPassLibrary(\"CSM\")\n    5:     loadRenderPassLibrary(\"DepthPass\")\n    6:     loadRenderPassLibrary(\"ForwardLightingPass\")\n    7:     loadRenderPassLibrary(\"SSAO\")\n    8:     loadRenderPassLibrary(\"ToneMapper\")\n    9  \n   10      skyBox = RenderPass(\"SkyBox\")\n\n/home/max/dev/Falcor/src/Mogwai/Data/ForwardRendererAA.py:\n    3  def render_graph_forward_renderer():\n    4      g = RenderGraph(\"forward_renderer\")\n    5:     loadRenderPassLibrary(\"AccumulatePass.rpl\")\n    6:     loadRenderPassLibrary(\"SSAO.rpl\")\n    7:     loadRenderPassLibrary(\"ForwardLightingPass.rpl\")\n    8:     loadRenderPassLibrary(\"SkyBox.rpl\")\n    9:     loadRenderPassLibrary(\"GBuffer.rpl\")\n   10:     loadRenderPassLibrary(\"ToneMapper.rpl\")\n   11:     loadRenderPassLibrary(\"DepthPass.rpl\")\n   12:     loadRenderPassLibrary(\"CSM.rpl\")\n   13:     loadRenderPassLibrary(\"BlitPass.rpl\")\n   14:     loadRenderPassLibrary(\"Antialiasing.rpl\")\n   15      AccumulatePass = RenderPass(\"AccumulatePass\", {'enableAccumulation': True, 'precisionMode': AccumulatePrecision.Single})\n   16      g.addPass(AccumulatePass, \"AccumulatePass\")\n\n/home/max/dev/Falcor/src/Mogwai/Data/PathTracer.py:\n    1  def render_graph_PathTracerGraph():\n    2      g = RenderGraph(\"PathTracerGraph\")\n    3:     loadRenderPassLibrary(\"AccumulatePass.dll\")\n    4:     loadRenderPassLibrary(\"GBuffer.dll\")\n    5:     loadRenderPassLibrary(\"ToneMapper.dll\")\n    6:     loadRenderPassLibrary(\"MegakernelPathTracer.dll\")\n    7      AccumulatePass = RenderPass(\"AccumulatePass\", {'enableAccumulation': True})\n    8      g.addPass(AccumulatePass, \"AccumulatePass\")\n\n/home/max/dev/Falcor/src/Mogwai/Data/VBufferPathTracer.py:\n    1  def render_graph_VBufferPathTracerGraph():\n    2      g = RenderGraph(\"VBufferPathTracerGraph\")\n    3:     loadRenderPassLibrary(\"AccumulatePass.dll\")\n    4:     loadRenderPassLibrary(\"GBuffer.dll\")\n    5:     loadRenderPassLibrary(\"ToneMapper.dll\")\n    6:     loadRenderPassLibrary(\"MegakernelPathTracer.dll\")\n    7      AccumulatePass = RenderPass(\"AccumulatePass\", {'enableAccumulation': True})\n    8      g.addPass(AccumulatePass, \"AccumulatePass\")\n\n/home/max/dev/Falcor/src/RenderPasses/MinimalPathTracer/Data/MinimalPathTracer.py:\n    3  def render_graph_MinimalPathTracer():\n    4      g = RenderGraph(\"MinimalPathTracer\")\n    5:     loadRenderPassLibrary(\"AccumulatePass.dll\")\n    6:     loadRenderPassLibrary(\"GBuffer.dll\")\n    7:     loadRenderPassLibrary(\"MinimalPathTracer.dll\")\n    8:     loadRenderPassLibrary(\"ToneMapper.dll\")\n    9      AccumulatePass = RenderPass(\"AccumulatePass\", {'enableAccumulation': True, 'precisionMode': AccumulatePrecision.Single})\n   10      g.addPass(AccumulatePass, \"AccumulatePass\")\n\n/home/max/dev/Falcor/src/RenderPasses/WhittedRayTracer/Data/WhittedRayTracer_GB_rast.py:\n    3  def render_graph_WhittedRayTracer():\n    4      g = RenderGraph(\"DefaultRenderGraph\")\n    5:     loadRenderPassLibrary(\"GBuffer.dll\")\n    6:     loadRenderPassLibrary(\"WhittedRatTracer.dll\")\n    7:     loadRenderPassLibrary(\"ToneMapper.dll\")\n    8      WhittedRayTracer = RenderPass(\"WhittedRayTracer\", {'mUsingRasterizedGBuffer': True, 'mMaxBounces': 1, 'mComputeDirect': True, 'mUseAnalyticLights': 1, 'mUseEmissiveLights': 1, 'mUseEnvLight': 0, 'mUseEnvBackground': 1})\n    9      g.addPass(WhittedRayTracer, \"WhittedRayTracer\")\n\n/home/max/dev/Falcor/src/RenderPasses/WhittedRayTracer/Data/WhittedRayTracer_GB_ray.py:\n    3  def render_graph_WhittedRayTracer():\n    4      g = RenderGraph(\"DefaultRenderGraph\")\n    5:     loadRenderPassLibrary(\"GBuffer.dll\")\n    6:     loadRenderPassLibrary(\"WhittedRatTracer.dll\")\n    7:     loadRenderPassLibrary(\"ToneMapper.dll\")\n    8      WhittedRayTracer = RenderPass(\"WhittedRayTracer\", {'mUsingRasterizedGBuffer': False, 'mMaxBounces': 2, 'mComputeDirect': True, 'mUseAnalyticLights': 1, 'mUseEmissiveLights': 1, 'mUseEnvLight': 0, 'mUseEnvBackground': 1})\n    9      g.addPass(WhittedRayTracer, \"WhittedRayTracer\")\n\n38 matches across 9 files\n\n\nSearching 1282 files for \"PYBIND11_MODULE\" (case sensitive)\n\n0 matches\n\nSearching 1282 files for \"staticFunc_\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/Core/API/DeviceManager.cpp:\n   42      auto deviceManagerClass = m.regClass(DeviceManager);\n   43      deviceManagerClass.ctor(&DeviceManager::instance);\n   44:     deviceManagerClass.staticFunc_(\"__new__\", &DeviceManager::instance)\n   45  }\n   46  \n\n/home/max/dev/Falcor/src/Falcor/Utils/Scripting/ScriptBindings.h:\n  133  \n  134      template <typename Func, typename... Extra>\n  135:     Class& staticFunc_(const char* name, Func&& f, const Extra&... extra) {\n  136          pyclass.def_static(name, std::forward<Func>(f), extra...);\n  137          return *this;\n\n2 matches across 2 files\n\n\nSearching 1282 files for \"singleton\" (case sensitive)\n\n/home/max/dev/Falcor/src/Falcor/RenderGraph/RenderPassLibrary.h:\n   53          using DescVec = std::vector<RenderPassDesc>;\n   54  \n   55:         /** Get an instance of the library. It's a singleton, you'll always get the same object\n   56          */\n   57          static RenderPassLibrary& instance(std::shared_ptr<Device> pDevice);\n\n/home/max/dev/Falcor/src/USD/hgiVk/glslang/glslang/Public/ShaderLang.h:\n  832      std::list<TShader*> stages[EShLangCount];\n  833      TIntermediate* intermediate[EShLangCount];\n  834:     bool newedIntermediate[EShLangCount];      // track which intermediate were \"new\" versus reusing a singleton unit in a stage\n  835      TInfoSink* infoSink;\n  836      TReflection* reflection;\n\n2 matches across 2 files\n",
			"settings":
			{
				"buffer_size": 500872,
				"line_ending": "Unix",
				"name": "Find Results",
				"scratch": true
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VkResource.cpp",
			"settings":
			{
				"buffer_size": 1884,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/Data/ForwardRenderer.py",
			"settings":
			{
				"buffer_size": 1872,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/Data/BSDFViewer.py",
			"settings":
			{
				"buffer_size": 634,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/glslang/glslang/Include/BaseTypes.h",
			"settings":
			{
				"buffer_size": 18643,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/glslang/glslang/MachineIndependent/Initialize.cpp",
			"settings":
			{
				"buffer_size": 477356,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Raster.slang",
			"settings":
			{
				"buffer_size": 4526,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/GBuffer/GBufferRaster.3d.slang",
			"settings":
			{
				"buffer_size": 7187,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/ShadingData.slang",
			"settings":
			{
				"buffer_size": 15181,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/Antialiasing/TAA/TAA.ps.slang",
			"settings":
			{
				"buffer_size": 5743,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Experimental/Scene/Lights/LightBVH.cpp",
			"settings":
			{
				"buffer_size": 18635,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Experimental/Scene/Lights/LightBVHBuilder.h",
			"settings":
			{
				"buffer_size": 11295,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Experimental/Scene/Lights/LightBVHBuilder.cpp",
			"settings":
			{
				"buffer_size": 41661,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Experimental/Scene/Lights/LightBVH.h",
			"settings":
			{
				"buffer_size": 12420,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Algorithm/ParallelReduction.ps.slang",
			"settings":
			{
				"buffer_size": 4191,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/BSDFViewer/BSDFViewerParams.slang",
			"settings":
			{
				"buffer_size": 6511,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/glslang/glslang/MachineIndependent/ParseHelper.cpp",
			"settings":
			{
				"buffer_size": 364782,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/glslang/SPIRV/SpvBuilder.cpp",
			"settings":
			{
				"buffer_size": 105150,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/source/slang/slang-ir.cpp",
			"settings":
			{
				"buffer_size": 150177,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/glslang/SPIRV/SpvBuilder.h",
			"settings":
			{
				"buffer_size": 35460,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/source/slang-glslang/slang-glslang.cpp",
			"settings":
			{
				"buffer_size": 18679,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/spirv-tools/source/spirv_target_env.cpp",
			"settings":
			{
				"buffer_size": 10524,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/spirv-tools/CHANGES",
			"settings":
			{
				"buffer_size": 47890,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/SceneBuilder.cpp",
			"settings":
			{
				"buffer_size": 23587,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/SceneTypes.slang",
			"settings":
			{
				"buffer_size": 5249,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/source/slang/slang-type-layout.cpp",
			"settings":
			{
				"buffer_size": 149248,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/source/slang/slang-type-layout.h",
			"settings":
			{
				"buffer_size": 34158,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/slang.h",
			"settings":
			{
				"buffer_size": 132132,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/glm/test/core/core_type_aligned.cpp",
			"settings":
			{
				"buffer_size": 5440,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Formats.cpp",
			"settings":
			{
				"buffer_size": 19719,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/glm/glm/gtx/compatibility.hpp",
			"settings":
			{
				"buffer_size": 14979,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKFormats.cpp",
			"settings":
			{
				"buffer_size": 10446,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/glslang/glslang/Include/intermediate.h",
			"settings":
			{
				"buffer_size": 54763,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/docs/language-reference/04-types.md",
			"settings":
			{
				"buffer_size": 14365,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/glslang/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 4705,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/glslang/SPIRV/GlslangToSpv.cpp",
			"settings":
			{
				"buffer_size": 339007,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/glslang/Test/100.frag",
			"settings":
			{
				"buffer_size": 4744,
				"line_ending": "Windows"
			}
		},
		{
			"file": "third_party/slang/external/glext.h",
			"settings":
			{
				"buffer_size": 811328,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/docs/wave-intrinsics.md",
			"settings":
			{
				"buffer_size": 13145,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/DebugPasses/InvalidPixelDetectionPass/InvalidPixelDetectionPass.cpp",
			"settings":
			{
				"buffer_size": 4278,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Core/RootBufferParamBlockTests.cpp",
			"settings":
			{
				"buffer_size": 8904,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Core/RootBufferParamBlockTests.cs.slang",
			"settings":
			{
				"buffer_size": 3086,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Core/ParamBlockDefinition.slang",
			"settings":
			{
				"buffer_size": 2225,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/ProgramVersion.cpp",
			"settings":
			{
				"buffer_size": 8252,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderGraphIR.cpp",
			"settings":
			{
				"buffer_size": 5845,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderGraphIR.h",
			"settings":
			{
				"buffer_size": 3409,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Importers/AssimpImporter.cpp",
			"settings":
			{
				"buffer_size": 44987,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Importers/AssimpImporter.h",
			"settings":
			{
				"buffer_size": 2484,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Importers/PythonImporter.h",
			"settings":
			{
				"buffer_size": 2145,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Camera/Camera.h",
			"settings":
			{
				"buffer_size": 11607,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Sampling/SampleGenerator.h",
			"settings":
			{
				"buffer_size": 4312,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/SampleGenerators/StratifiedSamplePattern.h",
			"settings":
			{
				"buffer_size": 3466,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/SampleGenerators/HaltonSamplePattern.h",
			"settings":
			{
				"buffer_size": 3159,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/SampleGenerators/CPUSampleGenerator.h",
			"settings":
			{
				"buffer_size": 2791,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/GraphicsStateObject.h",
			"settings":
			{
				"buffer_size": 6433,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/GraphicsStateObject.cpp",
			"settings":
			{
				"buffer_size": 4274,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKFbo.cpp",
			"settings":
			{
				"buffer_size": 5380,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/ComputeStateObject.h",
			"settings":
			{
				"buffer_size": 3496,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Experimental/Scene/Lights/EnvProbe.cpp",
			"settings":
			{
				"buffer_size": 6616,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/ComputeContext.h",
			"settings":
			{
				"buffer_size": 3967,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/GpuTimer.h",
			"settings":
			{
				"buffer_size": 3787,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/LowLevelContextData.h",
			"settings":
			{
				"buffer_size": 3656,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Timing/Profiler.h",
			"settings":
			{
				"buffer_size": 8484,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Platform/Windows/Windows.cpp",
			"settings":
			{
				"buffer_size": 26025,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/tools/gfx/d3d12/render-d3d12.cpp",
			"settings":
			{
				"buffer_size": 139342,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/tools/gfx/vulkan/render-vk.cpp",
			"settings":
			{
				"buffer_size": 99401,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Raytracing/RtProgramVarsHelper.cpp",
			"settings":
			{
				"buffer_size": 6214,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/D3D12/FalcorD3D12.h",
			"settings":
			{
				"buffer_size": 9709,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Platform/OS.cpp",
			"settings":
			{
				"buffer_size": 8771,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/SkyBox/SkyBox.slang",
			"settings":
			{
				"buffer_size": 2520,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/CSM/VisibilityPass.ps.slang",
			"settings":
			{
				"buffer_size": 2953,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/ToneMapper/ToneMapping.ps.slang",
			"settings":
			{
				"buffer_size": 5616,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/ToneMapper/Luminance.ps.slang",
			"settings":
			{
				"buffer_size": 2106,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Importers/PythonImporter.cpp",
			"settings":
			{
				"buffer_size": 3931,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Importers/SceneImporter.cpp",
			"settings":
			{
				"buffer_size": 36435,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Importers/SceneImporter.h",
			"settings":
			{
				"buffer_size": 2157,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/Program.h",
			"settings":
			{
				"buffer_size": 12423,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/GraphicsProgram.h",
			"settings":
			{
				"buffer_size": 3809,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/ComputeProgram.h",
			"settings":
			{
				"buffer_size": 3818,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/GraphicsProgram.cpp",
			"settings":
			{
				"buffer_size": 2616,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Camera/Camera.slang",
			"settings":
			{
				"buffer_size": 5388,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/ArgList.h",
			"settings":
			{
				"buffer_size": 4051,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/Mogwai.cpp",
			"settings":
			{
				"buffer_size": 23378,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/stdafx.h",
			"settings":
			{
				"buffer_size": 1851,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Renderer.h",
			"settings":
			{
				"buffer_size": 6779,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderPassLibrary.cpp",
			"settings":
			{
				"buffer_size": 11235,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderPassLibrary.h",
			"settings":
			{
				"buffer_size": 5360,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/UserInput.h",
			"settings":
			{
				"buffer_size": 7116,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Externals/GLM/glm/gtx/compatibility.hpp",
			"settings":
			{
				"buffer_size": 14969,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Sample.h",
			"settings":
			{
				"buffer_size": 7395,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/Gui.h",
			"settings":
			{
				"buffer_size": 26357,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Window.cpp",
			"settings":
			{
				"buffer_size": 17937,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Window.h",
			"settings":
			{
				"buffer_size": 5627,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/ArgList.cpp",
			"settings":
			{
				"buffer_size": 6269,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/AlignedAllocator.h",
			"settings":
			{
				"buffer_size": 6544,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Resource.h",
			"settings":
			{
				"buffer_size": 7622,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Core/BufferTests.cpp",
			"settings":
			{
				"buffer_size": 6996,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/DebugPasses/InvalidPixelDetectionTests.cpp",
			"settings":
			{
				"buffer_size": 3746,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/ShadingUtils/ShadingUtilsTests.cpp",
			"settings":
			{
				"buffer_size": 12331,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Testing/UnitTest.h",
			"settings":
			{
				"buffer_size": 18208,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Testing/UnitTest.cpp",
			"settings":
			{
				"buffer_size": 11972,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/ComputeProgram.cpp",
			"settings":
			{
				"buffer_size": 2634,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Core/BufferAccessTests.cpp",
			"settings":
			{
				"buffer_size": 6233,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Core/BufferAccessTests.cs.slang",
			"settings":
			{
				"buffer_size": 1913,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Resource.cpp",
			"settings":
			{
				"buffer_size": 5154,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/RenderContext.h",
			"settings":
			{
				"buffer_size": 11439,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/RenderContext.cpp",
			"settings":
			{
				"buffer_size": 5599,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/RasterizerState.h",
			"settings":
			{
				"buffer_size": 7490,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/RasterizerState.cpp",
			"settings":
			{
				"buffer_size": 2247,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKRasterizerState.cpp",
			"settings":
			{
				"buffer_size": 2034,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/QueryHeap.h",
			"settings":
			{
				"buffer_size": 3579,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Formats.h",
			"settings":
			{
				"buffer_size": 13822,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Buffer.h",
			"settings":
			{
				"buffer_size": 19243,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Experimental/Scene/Lights/EnvProbe.h",
			"settings":
			{
				"buffer_size": 3717,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 1908,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/Extensions/Capture/CaptureTrigger.cpp",
			"settings":
			{
				"buffer_size": 7579,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/Extensions/Capture/VideoCapture.cpp",
			"settings":
			{
				"buffer_size": 9655,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/Extensions/Capture/FrameCapture.cpp",
			"settings":
			{
				"buffer_size": 6569,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/Extensions/Capture/FrameCapture.h",
			"settings":
			{
				"buffer_size": 2710,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/RenderGraphEditor/RenderGraphEditor.cpp",
			"settings":
			{
				"buffer_size": 20776,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Externals/dear_imgui_addons/imguinodegrapheditor/imguinodegrapheditor.h",
			"settings":
			{
				"buffer_size": 47853,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/ImageCompare/ImageCompare.cpp",
			"settings":
			{
				"buffer_size": 14050,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/Mogwai.h",
			"settings":
			{
				"buffer_size": 8268,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderGraphImportExport.cpp",
			"settings":
			{
				"buffer_size": 6264,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/ResourceCache.cpp",
			"settings":
			{
				"buffer_size": 8382,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Animation/AnimationController.cpp",
			"settings":
			{
				"buffer_size": 13034,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderPassReflection.cpp",
			"settings":
			{
				"buffer_size": 12090,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderPass.cpp",
			"settings":
			{
				"buffer_size": 2449,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderPasses/ResolvePass.h",
			"settings":
			{
				"buffer_size": 2584,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderPasses/ResolvePass.cpp",
			"settings":
			{
				"buffer_size": 3100,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 5056,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "file( GLOB SOURCES"
			}
		},
		{
			"file": "src/Falcor/Scene/ParticleSystem/ParticleSystem.h",
			"settings":
			{
				"buffer_size": 10438,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/ParticleSystem/ParticleSystem.cpp",
			"settings":
			{
				"buffer_size": 16405,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/HitInfo.h",
			"settings":
			{
				"buffer_size": 3622,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Samples/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 1201,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/RenderGraphEditor/RenderGraphEditor.h",
			"settings":
			{
				"buffer_size": 3325,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/DebugPasses/DebugPasses.cpp",
			"settings":
			{
				"buffer_size": 2436,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/DebugPasses/SplitScreenPass/SplitScreenPass.h",
			"settings":
			{
				"buffer_size": 3041,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/DebugPasses/SplitScreenPass/SplitScreenPass.cpp",
			"settings":
			{
				"buffer_size": 6309,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/DebugPasses/SideBySidePass/SideBySidePass.h",
			"settings":
			{
				"buffer_size": 2482,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/DebugPasses/SideBySidePass/SideBySidePass.cpp",
			"settings":
			{
				"buffer_size": 3134,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/DebugPasses/InvalidPixelDetectionPass/InvalidPixelDetectionPass.h",
			"settings":
			{
				"buffer_size": 2619,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/CSM/CSM.h",
			"settings":
			{
				"buffer_size": 8949,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/CSM/CSM.cpp",
			"settings":
			{
				"buffer_size": 35619,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/Gui.slang",
			"settings":
			{
				"buffer_size": 2501,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/TextRenderer.slang",
			"settings":
			{
				"buffer_size": 2282,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/ErrorMeasurePass/ErrorMeasurePass.cpp",
			"settings":
			{
				"buffer_size": 16567,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/VBuffer/VBufferRaster.h",
			"settings":
			{
				"buffer_size": 2960,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/ErrorMeasurePass/ErrorMeasurePass.h",
			"settings":
			{
				"buffer_size": 4795,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/PixelInspectorPass/PixelInspectorPass.h",
			"settings":
			{
				"buffer_size": 3479,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderPass.h",
			"settings":
			{
				"buffer_size": 7147,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/PixelInspectorPass/PixelInspectorPass.cpp",
			"settings":
			{
				"buffer_size": 15137,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/SSAO/SSAO.h",
			"settings":
			{
				"buffer_size": 4465,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/SkyBox/SkyBox.h",
			"settings":
			{
				"buffer_size": 3377,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/SkyBox/SkyBox.cpp",
			"settings":
			{
				"buffer_size": 8099,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/Antialiasing/FXAA/FXAA.h",
			"settings":
			{
				"buffer_size": 3316,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/Antialiasing/TAA/TAA.h",
			"settings":
			{
				"buffer_size": 3086,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/Antialiasing/TAA/TAA.cpp",
			"settings":
			{
				"buffer_size": 5446,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/Antialiasing/FXAA/FXAA.cpp",
			"settings":
			{
				"buffer_size": 4663,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/SkyBox/Data/cube.obj",
			"settings":
			{
				"buffer_size": 401,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/ForwardLightingPass/ForwardLightingPass.h",
			"settings":
			{
				"buffer_size": 4522,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/ForwardLightingPass/ForwardLightingPass.cpp",
			"settings":
			{
				"buffer_size": 9750,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/ImageLoader/ImageLoader.h",
			"settings":
			{
				"buffer_size": 2888,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/ImageLoader/ImageLoader.cpp",
			"settings":
			{
				"buffer_size": 5146,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/ToneMapper/ToneMapper.h",
			"settings":
			{
				"buffer_size": 5483,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/ToneMapper/ToneMapper.cpp",
			"settings":
			{
				"buffer_size": 16177,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/AccumulatePass/AccumulatePass.cpp",
			"settings":
			{
				"buffer_size": 10804,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/GBufferBase.h",
			"settings":
			{
				"buffer_size": 3675,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/GBufferBase.cpp",
			"settings":
			{
				"buffer_size": 6613,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/SampleGenerators/HaltonSamplePattern.cpp",
			"settings":
			{
				"buffer_size": 2647,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/VBuffer/VBufferRT.h",
			"settings":
			{
				"buffer_size": 2997,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/GBuffer/GBufferRaster.cpp",
			"settings":
			{
				"buffer_size": 9973,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/GBuffer/GBufferRaster.h",
			"settings":
			{
				"buffer_size": 3089,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/GBuffer/GBuffer.h",
			"settings":
			{
				"buffer_size": 3189,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/GBuffer/GBuffer.cpp",
			"settings":
			{
				"buffer_size": 5817,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/DepthPass/DepthPass.cpp",
			"settings":
			{
				"buffer_size": 5263,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/Utils/GaussianBlur/GaussianBlur.cpp",
			"settings":
			{
				"buffer_size": 8197,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/SSAO/SSAO.cpp",
			"settings":
			{
				"buffer_size": 11771,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/Utils/GaussianBlur/GaussianBlur.h",
			"settings":
			{
				"buffer_size": 3547,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/Utils/Composite/Composite.cpp",
			"settings":
			{
				"buffer_size": 4310,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/TemporalDelayPass/TemporalDelayPass.h",
			"settings":
			{
				"buffer_size": 2703,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/Utils/Composite/Composite.h",
			"settings":
			{
				"buffer_size": 2924,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/DepthPass/DepthPass.h",
			"settings":
			{
				"buffer_size": 3357,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/GBuffer/GBufferRT.h",
			"settings":
			{
				"buffer_size": 3771,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/VBuffer/VBufferRT.cpp",
			"settings":
			{
				"buffer_size": 5767,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/VBuffer/VBufferRaster.cpp",
			"settings":
			{
				"buffer_size": 5657,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/GBuffer/GBufferRT.cpp",
			"settings":
			{
				"buffer_size": 9623,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/Antialiasing/Antialiasing.cpp",
			"settings":
			{
				"buffer_size": 2797,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/BlitPass/BlitPass.cpp",
			"settings":
			{
				"buffer_size": 3995,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/BSDFViewer/BSDFViewer.h",
			"settings":
			{
				"buffer_size": 4307,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/SVGFPass/SVGFPass.cpp",
			"settings":
			{
				"buffer_size": 18970,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/TemporalDelayPass/TemporalDelayPass.cpp",
			"settings":
			{
				"buffer_size": 6201,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/SVGFPass/SVGFPass.h",
			"settings":
			{
				"buffer_size": 4511,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/BSDFViewer/BSDFViewer.cpp",
			"settings":
			{
				"buffer_size": 18949,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/DebugPasses/ComparisonPass.h",
			"settings":
			{
				"buffer_size": 3108,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/DebugPasses/ComparisonPass.cpp",
			"settings":
			{
				"buffer_size": 5202,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/BlitPass/BlitPass.h",
			"settings":
			{
				"buffer_size": 2803,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/AccumulatePass/AccumulatePass.h",
			"settings":
			{
				"buffer_size": 5448,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "CMakeLists.txt",
			"settings":
			{
				"buffer_size": 3602,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 289,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/StringUtils.h",
			"settings":
			{
				"buffer_size": 12635,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Samples/ModelViewer/ModelViewer.cpp",
			"settings":
			{
				"buffer_size": 9979,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Samples/ModelViewer/ModelViewer.ps.slang.bak",
			"settings":
			{
				"buffer_size": 2408,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Samples/ModelViewer/ModelViewer.ps.slang",
			"settings":
			{
				"buffer_size": 2391,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Lights/LightProbeIntegration.ps.slang",
			"settings":
			{
				"buffer_size": 7921,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 1429,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Samples/ShaderToy/ShaderToy.cpp",
			"settings":
			{
				"buffer_size": 4229,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/BasePasses/FullScreenPass.cpp",
			"settings":
			{
				"buffer_size": 5668,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/BasePasses/ComputePass.h",
			"settings":
			{
				"buffer_size": 6372,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/BasePasses/FullScreenPass.h",
			"settings":
			{
				"buffer_size": 4025,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/BasePasses/ComputePass.cpp",
			"settings":
			{
				"buffer_size": 4013,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/BasePasses/BaseGraphicsPass.cpp",
			"settings":
			{
				"buffer_size": 2819,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Timing/FrameRate.h",
			"settings":
			{
				"buffer_size": 3811,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Timing/FrameRate.cpp",
			"settings":
			{
				"buffer_size": 2265,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Experimental/Scene/Lights/LightBVHSampler.h",
			"settings":
			{
				"buffer_size": 6356,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Experimental/Scene/Lights/LightBVHSampler.cpp",
			"settings":
			{
				"buffer_size": 7714,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Experimental/Scene/Lights/LightCollection.cpp",
			"settings":
			{
				"buffer_size": 29489,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/BasePasses/BaseGraphicsPass.h",
			"settings":
			{
				"buffer_size": 3738,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Experimental/Scene/Lights/LightCollection.h",
			"settings":
			{
				"buffer_size": 12783,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/BufferTypes/ParameterBlock.cpp",
			"settings":
			{
				"buffer_size": 67205,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/BSDFViewer/BSDFViewer.cs.slang",
			"settings":
			{
				"buffer_size": 15202,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Core/BufferTests.cs.slang",
			"settings":
			{
				"buffer_size": 2850,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/ShaderVar.cpp",
			"settings":
			{
				"buffer_size": 15515,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Lights/LightProbe.cpp",
			"settings":
			{
				"buffer_size": 11503,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "/***************************************************************************\n # Copyright (c) 2020, NVIDIA CORPORATION. All rights reserved.\n #\n # Redistribution and use in source and binary forms, with or without\n # modification, are permitted provided that the following conditions\n # are met:\n #  * Redistributions of source code must retain the above copyright\n #    notice, this list of conditions and the following disclaimer.\n #  * Redistributions in binary form must reproduce the above copyright\n #    notice, this list of conditions and the following disclaimer in the\n #    documentation and/or other materials provided with the distribution.\n #  * Neither the name of NVIDIA CORPORATION nor the names of its\n #    contributors may be used to endorse or promote products derived\n #    from this software without specific prior written permission.\n #\n # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY\n # EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n # IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n # PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n # CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n # EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n # PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n # PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n **************************************************************************/\n#ifndef SRC_FALCOR_SCENE_LIGHTS_LIGHTPROBE_H_\n#define SRC_FALCOR_SCENE_LIGHTS_LIGHTPROBE_H_\n\n#include \"LightProbeData.slang\"\n#include \"Falcor/Core/API/Texture.h\"\n#include \"Falcor/Core/API/Sampler.h\"\n\nnamespace Falcor {\n\nclass Device;\nclass RenderContext;\nclass Gui;\nclass ProgramVars;\nclass ParameterBlock;\n\nclass dlldecl LightProbe {\n public:\n    using SharedPtr = std::shared_ptr<LightProbe>;\n    using SharedConstPtr = std::shared_ptr<const LightProbe>;\n    using ConstSharedPtrRef = const SharedPtr&;\n\n    static const uint32_t kDataSize = sizeof(LightProbeData) - sizeof(LightProbeResources);\n    static const uint32_t kDefaultDiffSamples = 4096;\n    static const uint32_t kDefaultSpecSamples = 1024;\n    static const uint32_t kDefaultDiffSize = 128;\n    static const uint32_t kDefaultSpecSize = 1024;\n\n    /** Create a light-probe from a file\n        \\param[in] pContext The current render context to be used for pre-integration.\n        \\param[in] filename Texture filename\n        \\param[in] loadAsSrgb Indicates whether the source texture is in sRGB or linear color space\n        \\param[in] overrideFormat Override the format of the original texture. ResourceFormat::Unknown means keep the original format. Useful in cases where generateMips is true, but the original format doesn't support automatic mip generation\n        \\param[in] diffSampleCount How many times to sample when generating diffuse texture.\n        \\param[in] specSampleCount How many times to sample when generating specular texture.\n        \\param[in] diffSize The width and height of the pre-filtered diffuse texture. We always create a square texture.\n        \\param[in] specSize The width and height of the pre-filtered specular texture. We always create a square texture.\n        \\param[in] preFilteredFormat The format of the pre-filtered texture\n    */\n    static SharedPtr create(RenderContext* pContext, const std::string& filename, bool loadAsSrgb, ResourceFormat overrideFormat = ResourceFormat::Unknown, uint32_t diffSampleCount = kDefaultDiffSamples, uint32_t specSampleCount = kDefaultSpecSamples, uint32_t diffSize = kDefaultDiffSize, uint32_t specSize = kDefaultSpecSize, ResourceFormat preFilteredFormat = ResourceFormat::RGBA16Float);\n\n    /** Create a light-probe from a texture\n        \\param[in] pContext The current render context to be used for pre-integration.\n        \\param[in] pTexture The source texture\n        \\param[in] diffSampleCount How many times to sample when generating diffuse texture.\n        \\param[in] specSampleCount How many times to sample when generating specular texture.\n        \\param[in] diffSize The width and height of the pre-filtered diffuse texture. We always create a square texture.\n        \\param[in] specSize The width and height of the pre-filtered specular texture. We always create a square texture.\n        \\param[in] preFilteredFormat The format of the pre-filtered texture\n    */\n    static SharedPtr create(RenderContext* pContext, const Texture::SharedPtr& pTexture, uint32_t diffSampleCount = kDefaultDiffSamples, uint32_t specSampleCount = kDefaultSpecSamples, uint32_t diffSize = kDefaultDiffSize, uint32_t specSize = kDefaultSpecSize, ResourceFormat preFilteredFormat = ResourceFormat::RGBA16Float);\n\n    ~LightProbe();\n\n    /** Render UI elements for this light.\n        \\param[in] pGui The GUI to create the elements with\n        \\param[in] group Optional. If specified, creates a UI group to display elements within\n    */\n    void renderUI(Gui* pGui, const char* group = nullptr);\n\n    /** Set the light probe's world-space position\n    */\n    void setPosW(const float3& posW) { mData.posW = posW; }\n\n    /** Get the light probe's world-space position\n    */\n    const float3& getPosW() const { return mData.posW; }\n\n    /** Set the spherical radius the light probe encompasses. Set radius to negative to sample as an infinite-distance global light probe.\n    */\n    void setRadius(float radius) { mData.radius = radius; }\n\n    /** Get the light probe's radius.\n    */\n    float getRadius() const { return mData.radius; }\n\n    /** Get the sample count used to generate the diffuse texture.\n    */\n    uint32_t getDiffSampleCount() const { return mDiffSampleCount; }\n\n    /** Get the sample count used to generate the specular texture.\n    */\n    uint32_t getSpecSampleCount() const { return mSpecSampleCount; }\n\n    /** Set the light probe's light intensity\n    */\n    void setIntensity(const float3& intensity) { mData.intensity = intensity; }\n\n    /** Get the light probe's light intensity\n    */\n    const float3& getIntensity() const { return mData.intensity; }\n\n    /** Attach a sampler to the light probe\n    */\n    void setSampler(const Sampler::SharedPtr& pSampler) { mData.resources.sampler = pSampler; }\n\n    /** Get the sampler state\n    */\n    const Sampler::SharedPtr& getSampler() const { return mData.resources.sampler; }\n\n    /** Get the light probe's source texture.\n    */\n    const Texture::SharedPtr& getOrigTexture() const { return mData.resources.origTexture; }\n\n    /** Get the light probe's diffuse texture.\n    */\n    const Texture::SharedPtr& getDiffuseTexture() const { return mData.resources.diffuseTexture; }\n\n    /** Get the light probe's specular texture.\n    */\n    const Texture::SharedPtr& getSpecularTexture() const { return mData.resources.specularTexture; }\n\n    /** Get the texture storing the pre-integrated DFG term shared by all light probes.\n    */\n    static const Texture::SharedPtr& getDfgTexture() { return sSharedResources.dfgTexture; }\n\n    /** Bind the light data into a shader var\n    */\n    void setShaderData(const ShaderVar& var);\n\n private:\n    static uint32_t sLightProbeCount;\n    static LightProbeSharedResources sSharedResources;\n\n    LightProbeData mData;\n    uint32_t mDiffSampleCount;\n    uint32_t mSpecSampleCount;\n\n    LightProbe(RenderContext* pContext, const Texture::SharedPtr& pTexture, uint32_t diffSamples, uint32_t specSamples, uint32_t diffSize, uint32_t specSize, ResourceFormat preFilteredFormat);\n};\n\n}  // namespace Falcor\n\n#endif  // SRC_FALCOR_SCENE_LIGHTS_LIGHTPROBE_H_\n",
			"file": "src/Falcor/Scene/Lights/LightProbe.h",
			"file_size": 7852,
			"file_write_time": 132406993613157651,
			"settings":
			{
				"buffer_size": 7813,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/BasePasses/RasterScenePass.cpp",
			"settings":
			{
				"buffer_size": 3371,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderGraphCompiler.cpp",
			"settings":
			{
				"buffer_size": 18153,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderGraph.cpp",
			"settings":
			{
				"buffer_size": 30040,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderGraphExe.cpp",
			"settings":
			{
				"buffer_size": 4177,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderGraphExe.h",
			"settings":
			{
				"buffer_size": 4072,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Scripting/Dictionary.h",
			"settings":
			{
				"buffer_size": 4523,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderGraphUI.cpp",
			"settings":
			{
				"buffer_size": 64727,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Debug/PixelDebug.cpp",
			"settings":
			{
				"buffer_size": 9625,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Algorithm/ParallelReduction.cpp",
			"settings":
			{
				"buffer_size": 6148,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Utils/ParallelReductionTests.cpp",
			"settings":
			{
				"buffer_size": 11656,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Utils/PrefixSumTests.cpp",
			"settings":
			{
				"buffer_size": 4850,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Algorithm/PrefixSum.cpp",
			"settings":
			{
				"buffer_size": 7112,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Algorithm/BitonicSort.cpp",
			"settings":
			{
				"buffer_size": 4470,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Algorithm/ComputeParallelReduction.h",
			"settings":
			{
				"buffer_size": 4901,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Algorithm/ParallelReduction.h",
			"settings":
			{
				"buffer_size": 3575,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Algorithm/BitonicSort.h",
			"settings":
			{
				"buffer_size": 4169,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Algorithm/PrefixSum.h",
			"settings":
			{
				"buffer_size": 4191,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Algorithm/ComputeParallelReduction.cpp",
			"settings":
			{
				"buffer_size": 9541,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Scripting/Console.cpp",
			"settings":
			{
				"buffer_size": 4108,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Scripting/ScriptBindings.cpp",
			"settings":
			{
				"buffer_size": 4848,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Sampling/SampleGenerator.cpp",
			"settings":
			{
				"buffer_size": 3452,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Timing/Clock.cpp",
			"settings":
			{
				"buffer_size": 9831,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Timing/Clock.h",
			"settings":
			{
				"buffer_size": 8564,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/TextureLoader.cpp",
			"settings":
			{
				"buffer_size": 24304,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/assimp/include/assimp/Bitmap.h",
			"settings":
			{
				"buffer_size": 4295,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/VAO.h",
			"settings":
			{
				"buffer_size": 5144,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Logger.h",
			"settings":
			{
				"buffer_size": 5549,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Logger.cpp",
			"settings":
			{
				"buffer_size": 5968,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/BinaryFileStream.h",
			"settings":
			{
				"buffer_size": 5898,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Scripting/Scripting.cpp",
			"settings":
			{
				"buffer_size": 5721,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Timing/Profiler.cpp",
			"settings":
			{
				"buffer_size": 10754,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/Gui.cpp",
			"settings":
			{
				"buffer_size": 56184,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/PixelZoom.cpp",
			"settings":
			{
				"buffer_size": 5190,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/TextRenderer.cpp",
			"settings":
			{
				"buffer_size": 7231,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/TextRenderer.h",
			"settings":
			{
				"buffer_size": 3353,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/PixelZoom.h",
			"settings":
			{
				"buffer_size": 3368,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/DebugDrawer.h",
			"settings":
			{
				"buffer_size": 4027,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/DebugDrawer.cpp",
			"settings":
			{
				"buffer_size": 8927,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/Font.h",
			"settings":
			{
				"buffer_size": 4060,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/tools/render-test/bind-location.h",
			"settings":
			{
				"buffer_size": 19257,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/UI/Font.cpp",
			"settings":
			{
				"buffer_size": 5156,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/ProgramReflection.cpp",
			"settings":
			{
				"buffer_size": 85503,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKGraphicsStateObject.cpp",
			"settings":
			{
				"buffer_size": 5776,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/source/slang/slang-reflection.cpp",
			"settings":
			{
				"buffer_size": 50216,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/source/slang/slang-compiler.h",
			"settings":
			{
				"buffer_size": 90183,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/source/slang/slang-name.cpp",
			"settings":
			{
				"buffer_size": 800,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/source/core/slang-dictionary.h",
			"settings":
			{
				"buffer_size": 13988,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/ProgramVars.cpp",
			"settings":
			{
				"buffer_size": 14700,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Raytracing/RtProgramVarsHelper.h",
			"settings":
			{
				"buffer_size": 14339,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/ProgramVars.h",
			"settings":
			{
				"buffer_size": 6787,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/ShaderVar.h",
			"settings":
			{
				"buffer_size": 17036,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/ProgramReflection.h",
			"settings":
			{
				"buffer_size": 54819,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/Program.cpp",
			"settings":
			{
				"buffer_size": 34062,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Buffer.cpp",
			"settings":
			{
				"buffer_size": 13450,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/FBO.cpp",
			"settings":
			{
				"buffer_size": 18040,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/BlendState.h",
			"settings":
			{
				"buffer_size": 9346,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/BlendState.cpp",
			"settings":
			{
				"buffer_size": 3664,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/FBO.h",
			"settings":
			{
				"buffer_size": 13423,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Texture.h",
			"settings":
			{
				"buffer_size": 15073,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/ShadingUtils/RaytracingTests.cpp",
			"settings":
			{
				"buffer_size": 4882,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Slang/SlangTests.cpp",
			"settings":
			{
				"buffer_size": 8055,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Slang/SlangTests.cs.slang",
			"settings":
			{
				"buffer_size": 6527,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Slang/SlangShared.slang",
			"settings":
			{
				"buffer_size": 2435,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Slang/ShaderModel.cpp",
			"settings":
			{
				"buffer_size": 3182,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Slang/Int64Tests.cpp",
			"settings":
			{
				"buffer_size": 3694,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Slang/TraceRayFlags.cpp",
			"settings":
			{
				"buffer_size": 3163,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Slang/TraceRayInline.cpp",
			"settings":
			{
				"buffer_size": 2113,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Slang/WaveOps.cpp",
			"settings":
			{
				"buffer_size": 6067,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Utils/AABBTests.cpp",
			"settings":
			{
				"buffer_size": 7752,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/prelude/slang-cpp-types.h",
			"settings":
			{
				"buffer_size": 28997,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/FalcorTest.h",
			"settings":
			{
				"buffer_size": 2143,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/FalcorTest.cpp",
			"settings":
			{
				"buffer_size": 3605,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Sampling/SampleGeneratorTests.cpp",
			"settings":
			{
				"buffer_size": 7287,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Core/RootBufferTests.cpp",
			"settings":
			{
				"buffer_size": 8005,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Core/RootBufferStructTests.cpp",
			"settings":
			{
				"buffer_size": 5631,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VkGpuMemoryHeap.cpp",
			"settings":
			{
				"buffer_size": 2413,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Platform/Linux/Linux.cpp",
			"settings":
			{
				"buffer_size": 15074,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Platform/Windows/ProgressBarWin.cpp",
			"settings":
			{
				"buffer_size": 4513,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Platform/OS.h",
			"settings":
			{
				"buffer_size": 15995,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKState.h",
			"settings":
			{
				"buffer_size": 3960,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Texture.cpp",
			"settings":
			{
				"buffer_size": 16155,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 47,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 2011,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/commandBuffer.cpp",
			"settings":
			{
				"buffer_size": 8461,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/commandBufferManager.cpp",
			"settings":
			{
				"buffer_size": 13416,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/commandPool.cpp",
			"settings":
			{
				"buffer_size": 1629,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/computeEncoder.cpp",
			"settings":
			{
				"buffer_size": 1791,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/conversions.cpp",
			"settings":
			{
				"buffer_size": 9785,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/device.cpp",
			"settings":
			{
				"buffer_size": 17769,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/diagnostic.cpp",
			"settings":
			{
				"buffer_size": 6577,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/frame.cpp",
			"settings":
			{
				"buffer_size": 2455,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/garbageCollector.cpp",
			"settings":
			{
				"buffer_size": 3957,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/graphicsEncoder.cpp",
			"settings":
			{
				"buffer_size": 6479,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/hgi.cpp",
			"settings":
			{
				"buffer_size": 14444,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/instance.cpp",
			"settings":
			{
				"buffer_size": 1940,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/parallelGraphicsEncoder.cpp",
			"settings":
			{
				"buffer_size": 3913,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/pipeline.cpp",
			"settings":
			{
				"buffer_size": 15055,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/renderPass.cpp",
			"settings":
			{
				"buffer_size": 15805,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/pipeline.h",
			"settings":
			{
				"buffer_size": 1831,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/renderPassPipelineCache.cpp",
			"settings":
			{
				"buffer_size": 8095,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/resourceBindings.cpp",
			"settings":
			{
				"buffer_size": 16563,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/shaderCompiler.cpp",
			"settings":
			{
				"buffer_size": 10186,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/shaderFunction.cpp",
			"settings":
			{
				"buffer_size": 2509,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/shaderProgram.cpp",
			"settings":
			{
				"buffer_size": 437,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/surface.cpp",
			"settings":
			{
				"buffer_size": 3812,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/swapchain.cpp",
			"settings":
			{
				"buffer_size": 17443,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/texture.cpp",
			"settings":
			{
				"buffer_size": 15437,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/buffer.cpp",
			"settings":
			{
				"buffer_size": 9825,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/blitEncoder.cpp",
			"settings":
			{
				"buffer_size": 6180,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/blitEncoder.h",
			"settings":
			{
				"buffer_size": 1319,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/buffer.h",
			"settings":
			{
				"buffer_size": 1965,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/commandBuffer.h",
			"settings":
			{
				"buffer_size": 3844,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/commandBufferManager.h",
			"settings":
			{
				"buffer_size": 5853,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/commandPool.h",
			"settings":
			{
				"buffer_size": 1102,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/computeEncoder.h",
			"settings":
			{
				"buffer_size": 1631,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/conversions.h",
			"settings":
			{
				"buffer_size": 1688,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/device.h",
			"settings":
			{
				"buffer_size": 6599,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/diagnostic.h",
			"settings":
			{
				"buffer_size": 1085,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/frame.h",
			"settings":
			{
				"buffer_size": 2289,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/garbageCollector.h",
			"settings":
			{
				"buffer_size": 1637,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/graphicsEncoder.h",
			"settings":
			{
				"buffer_size": 2732,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/hgi.h",
			"settings":
			{
				"buffer_size": 4470,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/instance.h",
			"settings":
			{
				"buffer_size": 693,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/USD/hgiVk/parallelGraphicsEncoder.h",
			"settings":
			{
				"buffer_size": 1608,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/MogwaiSettings.h",
			"settings":
			{
				"buffer_size": 2575,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/MogwaiSettings.cpp",
			"settings":
			{
				"buffer_size": 10806,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/MogwaiScripting.cpp",
			"settings":
			{
				"buffer_size": 6767,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Shader.h",
			"settings":
			{
				"buffer_size": 8437,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Sampler.h",
			"settings":
			{
				"buffer_size": 7871,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Sampler.cpp",
			"settings":
			{
				"buffer_size": 3887,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKShader.cpp",
			"settings":
			{
				"buffer_size": 2775,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/stdafx.h",
			"settings":
			{
				"buffer_size": 1831,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/CopyContext.cpp",
			"settings":
			{
				"buffer_size": 6896,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/VAO.cpp",
			"settings":
			{
				"buffer_size": 3603,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKBuffer.cpp",
			"settings":
			{
				"buffer_size": 6579,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/ComputeContext.cpp",
			"settings":
			{
				"buffer_size": 2998,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/D3D12/D3D12ComputeContext.cpp",
			"settings":
			{
				"buffer_size": 6740,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/D3D12/D3D12LowLevelContextData.cpp",
			"settings":
			{
				"buffer_size": 4664,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKLowLevelContextData.cpp",
			"settings":
			{
				"buffer_size": 5608,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/FencedPool.h",
			"settings":
			{
				"buffer_size": 4321,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKComputeContext.cpp",
			"settings":
			{
				"buffer_size": 8062,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Tools/FalcorTest/Tests/Utils/MathHelpersTests.cpp",
			"settings":
			{
				"buffer_size": 12262,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKRenderContext.cpp",
			"settings":
			{
				"buffer_size": 16737,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/BasePasses/RasterPass.cpp",
			"settings":
			{
				"buffer_size": 2998,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/BasePasses/RasterPass.h",
			"settings":
			{
				"buffer_size": 4407,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKResourceViews.cpp",
			"settings":
			{
				"buffer_size": 13407,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 3482,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/max/Desktop/gbuffer.py",
			"settings":
			{
				"buffer_size": 574,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/GBuffer/GBuffer/GBufferParams.slang",
			"settings":
			{
				"buffer_size": 2388,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Threading.cpp",
			"settings":
			{
				"buffer_size": 2799,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/TermColor.cpp",
			"settings":
			{
				"buffer_size": 3484,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/TermColor.h",
			"settings":
			{
				"buffer_size": 2499,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Threading.h",
			"settings":
			{
				"buffer_size": 3003,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "/***************************************************************************\n # Copyright (c) 2020, NVIDIA CORPORATION. All rights reserved.\n #\n # Redistribution and use in source and binary forms, with or without\n # modification, are permitted provided that the following conditions\n # are met:\n #  * Redistributions of source code must retain the above copyright\n #    notice, this list of conditions and the following disclaimer.\n #  * Redistributions in binary form must reproduce the above copyright\n #    notice, this list of conditions and the following disclaimer in the\n #    documentation and/or other materials provided with the distribution.\n #  * Neither the name of NVIDIA CORPORATION nor the names of its\n #    contributors may be used to endorse or promote products derived\n #    from this software without specific prior written permission.\n #\n # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY\n # EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n # IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n # PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n # CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n # EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n # PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n # PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n **************************************************************************/\n#include \"Utils/Math/MathConstants.slangh\"\n#include \"Scene/Material/MaterialDefines.slangh\"\n\nimport Scene.Scene;\nimport Scene.TextureSampler;\nimport Experimental.Scene.Material.MaterialShading;\nimport Experimental.Scene.Lights.EnvProbe;\nimport Utils.Sampling.SampleGenerator;\nimport Utils.Debug.PixelDebug;\nimport Utils.Math.BitTricks;\nimport Utils.Math.MathHelpers;\nimport BSDFViewerParams;\n\ncbuffer PerFrameCB\n{\n    BSDFViewerParams gParams;\n    EnvProbe gEnvProbe;\n}\n\nRWTexture2D<float4> gOutput;\nRWStructuredBuffer<PixelData> gPixelData;\n\nstatic const float3 kGroundPlaneColor = float3(0.05f);\n\nstruct SurfaceData\n{\n    ShadingData sd;\n\n    // Additional fields we want to inspect that are not part of Falcor's ShadingData.\n    float3 baseColor;\n    float3 wi;\n};\n\n\n/** Get normalized viewport coordinate.\n    The viewport is centered on the image with square aspect and height 1.0. The y-axis points down.\n    TODO: Change to a more standard definition.\n    \\return Viewport coordinate.\n*/\nfloat2 getViewportCoord(uint2 pixel)\n{\n    float2 p = pixel + float2(0.5f);\n    return (p - gParams.viewportOffset) * gParams.viewportScale;\n}\n\n/** Setup geometric frame of reference for BRDF slice.\n    \\param[in] uv Viewport coordinate in [0,1].\n    \\param[out] v Interpolated attributes for the point on the sphere.\n    \\param[out] viewDir View direction.\n    \\return Normalized incident direction (light vector).\n*/\nfloat3 calculateSliceGeometry(float2 uv, out VertexData v, out float3 viewDir)\n{\n    // Setup local surface frame as T,B,N (right-handed).\n    v.posW = float3(0, 0, 0);\n    v.normalW = float3(0, 0, 1);\n    v.bitangentW = float3(0, 1, 0);\n    v.texC = gParams.texCoords;\n    v.faceNormalW = v.normalW;\n\n    // Compute dot products.\n    // These are based on the axes in the 2D slice (theta_h, theta_d) with origin in lower-left corner.\n    // This is the same format as the slices in Burley et al. 2012, 2015.\n    float theta_h = uv.x * (M_PI / 2);\n    float theta_d = (1.f - uv.y) * (M_PI / 2);\n\n    float NdotH = cos(theta_h);\n    float HdotL = cos(theta_d);     // Note: HdotL = HdotV\n\n    // Place the H vector at (0,0,1) to start.\n    // Compute L, V that are mirrored about the yz-plane.\n    float3 L = float3(sqrt(1.f - HdotL * HdotL), 0, HdotL);\n    float3 V = float3(-L.x, 0.f, L.z);\n\n    // Rotate L, V about the x-axis by an angle theta_h.\n    float cos_h = NdotH;\n    float sin_h = sqrt(1 - NdotH * NdotH);\n    L = float3(L.x, cos_h * L.y - sin_h * L.z, sin_h * L.y + cos_h * L.z);\n    V = float3(V.x, cos_h * V.y - sin_h * V.z, sin_h * V.y + cos_h * V.z);\n\n    // Return vectors.\n    viewDir = V;\n    return normalize(L);\n}\n\n/** Ray-sphere intersection.\n    This function implements the standard analytic test and returns the closest hit.\n    \\param[in] rayOrigin Ray origin.\n    \\param[in] rayDir Ray direction (does not have to be normalized).\n    \\param[in] center Sphere center.\n    \\param[in] radius Sphere radius.\n    \\param[in] intersectionPos Position on the sphere for the closest intersection (if any).\n    \\return True if the ray intersects the sphere.\n*/\nbool raySphereIntersection(float3 rayOrigin, float3 rayDir, float3 center, float radius, out float3 intersectionPos)\n{\n    // The sphere equation is ||P-C||^2 = r^2 and the ray P = A+tB.\n    // Solve for minimum positive t to find the closest intersection.\n    float3 oc = rayOrigin - center;\n    float a = dot(rayDir, rayDir); // = 1.0 if direction is normalized\n    float b = 2.f * dot(rayDir, oc);\n    float c = dot(oc, oc) - radius * radius;\n    float discriminant = b * b - 4.f * a * c;\n\n    // Negative discriminant means ray missed sphere.\n    if (discriminant < 0.f) return false;\n\n    // There are two solutions t0 and t1, but one or both may be negative.\n    float t0 = -b - sqrt(discriminant);\n    float t1 = -b + sqrt(discriminant);\n    float tc = t0 < 0.f ? t1 : t0; // tc is the closest hit we care about\n    if (tc < 0.f) return false;\n\n    float t = tc / (2.f * a);\n    intersectionPos = rayOrigin + t * rayDir;\n    return true;\n}\n\n/** Calculate sphere geometry for the given viewport coordinate.\n    \\param[in] uv Viewport coordinate in [0,1].\n    \\param[out] v Interpolated attributes for the point on the sphere (if hit).\n    \\param[out] rayDir Ray direction for the camera ray (normalized).\n    \\return True if we're on the sphere.\n*/\nbool calculateSphereGeometry(float2 uv, out VertexData v, out float3 rayDir)\n{\n    const float2 ndc = float2(2.f * uv.x - 1.f, -2.f * uv.y + 1.f);\n\n    if (gParams.orthographicCamera)\n    {\n        // Calculate intersection with the unit sphere.\n        // The orthographic camera's viewport is +-1 units vertically so the sphere fits exactly.\n        float3 p = float3(ndc, 0);\n        float d = 1.f - p.x * p.x - p.y * p.y;\n        rayDir = float3(0, 0, -1);\n\n        if (d < 0.f) return false;\n        p.z = sqrt(d);\n        v.posW = p;\n    }\n    else // Projective camera\n    {\n        // Setup camera ray and calculate ray-sphere intersection.\n        float3 origin = { 0, 0, gParams.cameraDistance };\n        float3 target = float3(ndc * gParams.cameraViewportScale, 0);\n        rayDir = normalize(target - origin);\n\n        float3 p;\n        if (!raySphereIntersection(origin, rayDir, float3(0), 1.f, p)) return false;\n        v.posW = p;\n    }\n\n    // Setup surface attributes for the unit sphere.\n    v.normalW = v.posW;\n    v.bitangentW = perp_stark(v.normalW); // Make up a bitangent\n    v.faceNormalW = v.normalW;\n\n    if (gParams.useFixedTexCoords)\n    {\n        v.texC = gParams.texCoords;\n    }\n    else\n    {\n        // Compute texture coords using cylindrical mapping of the visible hemisphere.\n        // We place u=0 on the left side and and u=1 on the right, and v=0 at the bottom and v=1 at the top.\n        float3 p = v.posW;\n        float texU = atan2(p.z, -p.x) / M_PI;\n        float texV = acos(-p.y) / M_PI;\n        v.texC = float2(texU, texV);\n    }\n\n    return true;\n}\n\n/** Prepare SurfaceData struct with material parameters.\n    All unused fields are initialized to their default values.\n*/\nSurfaceData prepareMaterial(VertexData v, float3 viewDir)\n{\n    SurfaceData data = {};\n\n    if (gParams.useSceneMaterial)\n    {\n        // Setup Falcor's ShadingData based on scene material.\n        ExplicitLodTextureSampler lod = { 0.f };\n        data.sd = _prepareShadingData(v, gParams.materialID, gScene.materials[gParams.materialID], gScene.materialResources[gParams.materialID], viewDir, lod, gParams.useNormalMapping);\n\n        // Setup additional fields not currently available in ShadingData.\n        MaterialData md = gScene.getMaterial(gParams.materialID);\n        MaterialResources mr = gScene.materialResources[gParams.materialID];\n        data.baseColor = sampleTexture(mr.baseColor, mr.samplerState, v.texC, md.baseColor, EXTRACT_DIFFUSE_TYPE(md.flags), lod).rgb;\n    }\n    else\n    {\n        ShadingData sd = {};\n\n        // Set geometric parameters.\n        sd.posW = v.posW;\n        sd.uv = v.texC;\n        sd.V = normalize(viewDir);\n        sd.N = normalize(v.normalW);\n        sd.B = normalize(v.bitangentW - sd.N * (dot(v.bitangentW, sd.N)));\n        sd.T = normalize(cross(sd.B, sd.N));\n        sd.NdotV = dot(sd.N, sd.V);\n        sd.faceN = v.faceNormalW;\n        sd.frontFacing = dot(sd.V, sd.faceN) >= 0.f;\n        sd.doubleSided = false;\n\n        // Set material parameters.\n        // Calculate the specular reflectance for dielectrics from the IoR.\n        sd.IoR = gParams.IoR;\n        float f = (sd.IoR - 1.f) / (sd.IoR + 1.f);\n        float F0 = f * f;\n        sd.diffuse = lerp(gParams.baseColor.rgb, float3(0), gParams.metallic);\n        sd.specular = lerp(float3(F0), gParams.baseColor.rgb, gParams.metallic);\n        sd.linearRoughness = gParams.linearRoughness;\n        sd.ggxAlpha = sd.linearRoughness * sd.linearRoughness;\n        sd.metallic = gParams.metallic;\n\n        // Unused\n        sd.opacity = 1;\n        sd.occlusion = 1;\n\n        // Store outputs\n        data.sd = sd;\n        data.baseColor = gParams.baseColor;\n    }\n\n    return data;\n}\n\n/** Returns the color to use for background pixels.\n    \\param[in] uv Viewport coordinates.\n    \\param[in] dir Normalized ray direction.\n*/\nfloat3 evalBackground(float2 uv, float3 dir)\n{\n    if (gParams.useGroundPlane)\n    {\n        bool hitGround = gParams.orthographicCamera ? (uv.y >= 0.5f) : (dir.y < 0.f);\n        if (hitGround) return kGroundPlaneColor;\n    }\n    if (gParams.useDirectionalLight) return float3(0);\n\n    float3 L = gParams.useEnvMap ? evalEnvProbe(gEnvProbe, dir) : gParams.lightColor;\n    return L * gParams.lightIntensity;\n}\n\n/** Evaluates the incident lighting from a given direction.\n    If directional lighting is enabled, it can be assumed 'dir' is light's direction.\n*/\nfloat3 evalLighting(float3 dir)\n{\n    if (gParams.useGroundPlane && dir.y < 0.f)\n    {\n        return float3(0.f);\n    }\n\n    float3 L = gParams.useEnvMap ? evalEnvProbe(gEnvProbe, dir) : gParams.lightColor;\n    return L * gParams.lightIntensity;\n}\n\n/** Returns the BSDF lobe mask for the currently enabled lobes.\n*/\nuint getActiveLobes()\n{\n    uint lobes = 0;\n    if (gParams.enableDiffuse) lobes |= (uint)LobeType::DiffuseReflection;\n    if (gParams.enableSpecular) lobes |= (uint)LobeType::SpecularReflection;\n    // TODO: Viewer doesn't support transmission lobes yet\n    return lobes;\n}\n\n/** Evaluates the BSDF slice for a given viewport coordinate.\n    \\return Evaluated BSDF value.\n*/\nfloat3 evalBSDFSlice(float2 uv, inout SurfaceData data)\n{\n    // Calculate geometry and incident/outgoing directions.\n    VertexData v;\n    float3 viewDir;\n    float3 lightDir = calculateSliceGeometry(uv, v, viewDir);\n\n    // Setup shading data based on the current material.\n    data = prepareMaterial(v, viewDir);\n    data.wi = lightDir;\n\n    // Evaluate BRDF at this point.\n    float3 f = evalBSDFCosine(data.sd, data.wi, getActiveLobes());\n\n    // Remove cosine term if it's disabled in the viewer.\n    if (!gParams.applyNdotL)\n    {\n        float NdotL = dot(data.sd.N, data.wi);\n        f = NdotL > 0.f ? f / NdotL : float3(0);\n    }\n\n    return f;\n}\n\n/** Samples the BSDF to evaluate incident illumination.\n    This is done differently depending on the configuration.\n    \\param[in] sd Shading point data.\n    \\param[in] sg Sample generator.\n    \\param[out] s Generated sample. Only valid if true is returned.\n    \\return True if a sample was generated, false otherwise.\n*/\nbool generateBSDFSample(const ShadingData sd, inout SampleGenerator sg, out BSDFSample s)\n{\n    if (gParams.useDirectionalLight)\n    {\n        // With directional light, disable BSDF sampling and just return a sample in the light's direction.\n        s.wi = -normalize(gParams.lightDir);\n        s.weight = evalBSDFCosine(sd, s.wi);\n        s.pdf = 1.f;\n        return dot(sd.N, s.wi) > 0.f;\n    }\n    else\n    {\n        if (gParams.useBrdfSampling) return sampleBSDF(sd, sg, s);\n        else return sampleBSDF_Reference(sd, sg, s);\n    }\n}\n\n/** Evaluates the lit sphere for a given viewport coordinate.\n    The viewport shows an analytic sphere of the specified material at infinite distance.\n    When each pixel is evaluated using a random light direction and omnidirectional white light,\n    the result converges to the total reflectance (integral of BSDF times the dot(N,L) factor.\n    \\return Outgoing radiance value.\n*/\nfloat3 evalSphere(float2 uv, inout SurfaceData data, inout SampleGenerator sg)\n{\n    // Calculate the local surface frame.\n    VertexData v;\n    float3 rayDir;\n    if (!calculateSphereGeometry(uv, v, rayDir)) return evalBackground(uv, rayDir);\n\n    // Setup shading data based on the current material.\n    data = prepareMaterial(v, -rayDir);\n\n    float3 output = 0;\n    \n    BSDFSample s = {};\n    \n    if (generateBSDFSample(data.sd, sg, s)) {\n        data.wi = s.wi;\n        float3 L = evalLighting(s.wi);\n\n        // Use computed pdf explicitly (for debugging).\n        if (gParams.usePdf) {\n            output = L * evalBSDFCosine(data.sd, s.wi) / s.pdf;\n        } else {\n            output = L * s.weight;\n        }\n    }\n\n    return output;\n}\n\n/** BSDF viewer pass entry point.\n*/\n[numthreads(16, 16, 1)]\nvoid main(uint3 dispatchThreadID : SV_DispatchThreadID)\n{\n    const uint2 pixel = dispatchThreadID.xy;\n    if (any(pixel >= gParams.frameDim)) return;\n\n    printSetPixel(pixel);\n\n    SurfaceData data = {};\n    float3 output = 0;\n    float2 uv = getViewportCoord(pixel);\n\n    if (gParams.sliceViewer)\n    {\n        if (all(uv >= 0.f && uv < 1.f))\n        {\n            output = evalBSDFSlice(uv, data);\n        }\n    }\n    else\n    {\n        // Create pseudorandom number generator.\n        SampleGenerator sg = SampleGenerator.create(pixel, gParams.frameCount);\n        output = evalSphere(uv, data, sg);\n    }\n\n    // DEBUG\n    //if (gParams.debugSwitch0)\n    //{\n    //    if (sd.N.z < 0.f) output = float3(1, 0, 0);\n    //}\n\n    // Write output data.\n    gOutput[pixel] = float4(output, 1);\n\n    if (gParams.readback && all(pixel == gParams.selectedPixel))\n    {\n        PixelData px;\n        px.texC = data.sd.uv;\n        px.baseColor = data.baseColor;\n        px.diffuse = data.sd.diffuse;\n        px.specular = data.sd.specular;\n        px.linearRoughness = data.sd.linearRoughness;\n        px.metallic = data.sd.metallic;\n        px.N = data.sd.N;\n        px.T = data.sd.T;\n        px.B = data.sd.B;\n        px.wo = data.sd.V;\n        px.wi = data.wi;\n        px.output = output;\n        gPixelData[0] = px;\n    }\n}\n",
			"file": "build/bin/Shaders/RenderPasses/BSDFViewer/BSDFViewer.cs.slang",
			"file_size": 15202,
			"file_write_time": 132389801358286917,
			"settings":
			{
				"buffer_size": 15202,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/RenderPasses/Utils/Utils.cpp",
			"settings":
			{
				"buffer_size": 2234,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/tools/render-test/cuda/cuda-compute-util.cpp",
			"settings":
			{
				"buffer_size": 53192,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VkSmartHandle.cpp",
			"settings":
			{
				"buffer_size": 6726,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKRootSignature.cpp",
			"settings":
			{
				"buffer_size": 8750,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Program/ProgramVersion.h",
			"settings":
			{
				"buffer_size": 10447,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/examples/model-viewer/main.cpp",
			"settings":
			{
				"buffer_size": 86920,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/ResourceViews.h",
			"settings":
			{
				"buffer_size": 9621,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/RootSignature.h",
			"settings":
			{
				"buffer_size": 6716,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/RootSignature.cpp",
			"settings":
			{
				"buffer_size": 8993,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKSampler.cpp",
			"settings":
			{
				"buffer_size": 2442,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/tools/gfx/render.h",
			"settings":
			{
				"buffer_size": 28476,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/FalcorVK.h",
			"settings":
			{
				"buffer_size": 5196,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Device.h",
			"settings":
			{
				"buffer_size": 11455,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Device.cpp",
			"settings":
			{
				"buffer_size": 17286,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/GpuMemoryHeap.h",
			"settings":
			{
				"buffer_size": 4090,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/GpuMemoryHeap.cpp",
			"settings":
			{
				"buffer_size": 5126,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKComputeStateObject.cpp",
			"settings":
			{
				"buffer_size": 2823,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKCopyContext.cpp",
			"settings":
			{
				"buffer_size": 22189,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKDescriptorPool.cpp",
			"settings":
			{
				"buffer_size": 5083,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKDescriptorSet.cpp",
			"settings":
			{
				"buffer_size": 7835,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKDescriptorData.h",
			"settings":
			{
				"buffer_size": 2550,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "/***************************************************************************\n # Copyright (c) 2020, NVIDIA CORPORATION. All rights reserved.\n #\n # Redistribution and use in source and binary forms, with or without\n # modification, are permitted provided that the following conditions\n # are met:\n #  * Redistributions of source code must retain the above copyright\n #    notice, this list of conditions and the following disclaimer.\n #  * Redistributions in binary form must reproduce the above copyright\n #    notice, this list of conditions and the following disclaimer in the\n #    documentation and/or other materials provided with the distribution.\n #  * Neither the name of NVIDIA CORPORATION nor the names of its\n #    contributors may be used to endorse or promote products derived\n #    from this software without specific prior written permission.\n #\n # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY\n # EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n # IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n # PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n # CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n # EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n # PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n # PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n **************************************************************************/\n#include <set>\n\n#include \"Falcor/stdafx.h\"\n#include \"Falcor/Core/API/Device.h\"\n#include \"Falcor/Core/API/DeviceManager.h\"\n#include \"Falcor/Core/API/Vulkan/FalcorVK.h\"\n#include \"Falcor.h\"\n\n\nnamespace Falcor {\n\nVkInstance gVulkanInstance = VK_NULL_HANDLE;\n\nnamespace {\n\nstatic std::vector<VkLayerProperties> enumarateInstanceLayersProperties() {\n    uint32_t layerCount = 0;\n    vkEnumerateInstanceLayerProperties(&layerCount, nullptr);\n    std::vector<VkLayerProperties> layerProperties(layerCount);\n    vkEnumerateInstanceLayerProperties(&layerCount, layerProperties.data());\n\n    for (const VkLayerProperties& layer : layerProperties) {\n        logInfo(\"Available Vulkan Layer: \" + std::string(layer.layerName) + \" - VK Spec Version: \" + std::to_string(layer.specVersion) + \" - Implementation Version: \" + std::to_string(layer.implementationVersion));\n    }\n\n    return layerProperties;\n}\n\nstatic bool isLayerSupported(const std::string& layer, const std::vector<VkLayerProperties>& supportedLayers) {\n    for (const auto& l : supportedLayers) {\n        if (l.layerName == layer) return true;\n    }\n    return false;\n}\n\nvoid enableLayerIfPresent(const char* layerName, const std::vector<VkLayerProperties>& supportedLayers, std::vector<const char*>& requiredLayers) {\n    if (isLayerSupported(layerName, supportedLayers)) {\n        requiredLayers.push_back(layerName);\n    } else {\n        logWarning(\"Can't enable requested Vulkan layer \" + std::string(layerName) + \". Something bad might happen. Or not, depends on the layer.\");\n    }\n}\n\nstatic std::vector<VkExtensionProperties> enumarateInstanceExtensions() {\n    // Enumerate implicitly available extensions. The debug layers above just have VK_EXT_debug_report\n    uint32_t extensionCount = 0;\n    vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, nullptr);\n    std::vector<VkExtensionProperties> supportedExtensions(extensionCount);\n    vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, supportedExtensions.data());\n\n    for (const VkExtensionProperties& extension : supportedExtensions) {\n        logInfo(\"Available Instance Extension: \" + std::string(extension.extensionName) + \" - VK Spec Version: \" + std::to_string(extension.specVersion));\n    }\n\n    return supportedExtensions;\n}\n\nVkInstance createInstance(DeviceApiData* pData, bool enableDebugLayer) {\n    // Initialize the layers\n    const auto layerProperties = enumarateInstanceLayersProperties();\n    std::vector<const char*> requiredLayers;\n\n    if (enableDebugLayer) {\n        enableLayerIfPresent(\"VK_LAYER_LUNARG_standard_validation\", layerProperties, requiredLayers);\n    }\n\n    // Initialize the extensions\n    std::vector<VkExtensionProperties> supportedExtensions = enumarateInstanceExtensions();\n\n    // Extensions to use when creating instance\n    std::vector<const char*> requiredExtensions = {\n        \"VK_KHR_surface\",\n#ifdef _WIN32\n        \"VK_KHR_win32_surface\"\n#else\n        \"VK_KHR_xlib_surface\"\n#endif\n    };\n\n    if (enableDebugLayer) { requiredExtensions.push_back(\"VK_EXT_debug_report\"); }\n\n    VkInstanceCreateInfo instanceCreateInfo = {};\n    instanceCreateInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;\n    instanceCreateInfo.enabledLayerCount = (uint32_t)requiredLayers.size();\n    instanceCreateInfo.ppEnabledLayerNames = requiredLayers.data();\n    instanceCreateInfo.enabledExtensionCount = (uint32_t)requiredExtensions.size();\n    instanceCreateInfo.ppEnabledExtensionNames = requiredExtensions.data();\n\n    VkInstance instance;\n    if (VK_FAILED(vkCreateInstance(&instanceCreateInfo, nullptr, &instance))) {\n        logError(\"Failed to create Vulkan instance\");\n        return nullptr;\n    }\n\n    // Hook up callbacks for VK_EXT_debug_report\n    //if (enableDebugLayer) {\n    //    initDebugCallback(instance, &pData->debugReportCallbackHandle);\n    //}\n\n    return instance;\n}\n\n}  // namespace\n\nbool DeviceManager::init() {\n    //gVulkanInstance = createInstance();\n    \n    if (!gVulkanInstance)\n        return false;\n}\n\nvoid DeviceManager::enumerateDevices() {\n    \n}\n\n}  // namespace Falcor\n",
			"file": "src/Falcor/Core/API/Vulkan/VKDeviceManager.cpp",
			"file_size": 5743,
			"file_write_time": 132415500588549916,
			"settings":
			{
				"buffer_size": 5792,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/DeviceManager.h",
			"settings":
			{
				"buffer_size": 3515,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKDevice.cpp",
			"settings":
			{
				"buffer_size": 28956,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKGpuFence.cpp",
			"settings":
			{
				"buffer_size": 10228,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKGpuTimer.cpp",
			"settings":
			{
				"buffer_size": 2646,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/D3D12/D3D12GpuFence.cpp",
			"settings":
			{
				"buffer_size": 3766,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/GpuFence.h",
			"settings":
			{
				"buffer_size": 3526,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKSmartHandle.h",
			"settings":
			{
				"buffer_size": 9756,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKState.cpp",
			"settings":
			{
				"buffer_size": 27538,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VKTexture.cpp",
			"settings":
			{
				"buffer_size": 7857,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "falcor.sublime-project",
			"settings":
			{
				"buffer_size": 2302,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/vulkan/include/vulkan/vulkan.hpp",
			"settings":
			{
				"buffer_size": 2369181,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/usr/include/vulkan/vulkan.hpp",
			"settings":
			{
				"buffer_size": 4010350,
				"line_ending": "Unix"
			}
		},
		{
			"file": "third_party/slang/external/vulkan/include/vulkan/vulkan_core.h",
			"settings":
			{
				"buffer_size": 451013,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Math/FalcorMath.h",
			"settings":
			{
				"buffer_size": 8456,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Framework.h",
			"settings":
			{
				"buffer_size": 13038,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/type.h",
			"settings":
			{
				"buffer_size": 6550,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Framework.cpp",
			"settings":
			{
				"buffer_size": 2253,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/CopyContext.h",
			"settings":
			{
				"buffer_size": 7675,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/VertexLayout.cpp",
			"settings":
			{
				"buffer_size": 1862,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/FalcorConfig.h",
			"settings":
			{
				"buffer_size": 2544,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderPassStandardFlags.h",
			"settings":
			{
				"buffer_size": 2479,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Falcor.h",
			"settings":
			{
				"buffer_size": 6959,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Debug/PixelDebug.h",
			"settings":
			{
				"buffer_size": 5769,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Image/Bitmap.h",
			"settings":
			{
				"buffer_size": 6060,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Image/Bitmap.cpp",
			"settings":
			{
				"buffer_size": 21119,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Scripting/ScriptBindings.h",
			"settings":
			{
				"buffer_size": 10241,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/max/Desktop/compos.py",
			"settings":
			{
				"buffer_size": 1267,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Scripting/Console.h",
			"settings":
			{
				"buffer_size": 2101,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Scripting/Scripting.h",
			"settings":
			{
				"buffer_size": 5726,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/DescriptorPool.h",
			"settings":
			{
				"buffer_size": 5596,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/DescriptorPool.cpp",
			"settings":
			{
				"buffer_size": 2683,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/State/GraphicsState.h",
			"settings":
			{
				"buffer_size": 10063,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/State/GraphicsState.cpp",
			"settings":
			{
				"buffer_size": 8458,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/State/ComputeState.cpp",
			"settings":
			{
				"buffer_size": 3405,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/ComputeStateObject.cpp",
			"settings":
			{
				"buffer_size": 2465,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/GpuTimer.cpp",
			"settings":
			{
				"buffer_size": 4479,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/State/ComputeState.h",
			"settings":
			{
				"buffer_size": 3782,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/State/StateGraph.h",
			"settings":
			{
				"buffer_size": 4323,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Raytracing/RtProgram/RtProgram.cpp",
			"settings":
			{
				"buffer_size": 7986,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Raytracing/RtProgram/RtProgram.h",
			"settings":
			{
				"buffer_size": 6561,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/AppData.h",
			"settings":
			{
				"buffer_size": 2896,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Platform/Linux/ProgressBarLinux.cpp",
			"settings":
			{
				"buffer_size": 5059,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/AppData.cpp",
			"settings":
			{
				"buffer_size": 5386,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Mogwai/Extensions/Capture/CaptureTrigger.h",
			"settings":
			{
				"buffer_size": 3849,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/Sample.cpp",
			"settings":
			{
				"buffer_size": 24618,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/VertexLayout.h",
			"settings":
			{
				"buffer_size": 7327,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/DeviceManager.cpp",
			"settings":
			{
				"buffer_size": 4871,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/Vulkan/VkQueryHeap.cpp",
			"settings":
			{
				"buffer_size": 2779,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/D3D12/D3D12Device.cpp",
			"settings":
			{
				"buffer_size": 15156,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/DescriptorSet.h",
			"settings":
			{
				"buffer_size": 5856,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/DescriptorSet.cpp",
			"settings":
			{
				"buffer_size": 2618,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/ResourceViews.cpp",
			"settings":
			{
				"buffer_size": 5611,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "Falcor.sln",
			"settings":
			{
				"buffer_size": 19418,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Scene.h",
			"settings":
			{
				"buffer_size": 25118,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderGraphUI.h",
			"settings":
			{
				"buffer_size": 8554,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/RenderGraph.h",
			"settings":
			{
				"buffer_size": 11413,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/ResourceCache.h",
			"settings":
			{
				"buffer_size": 5357,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/RenderGraph/BasePasses/RasterScenePass.h",
			"settings":
			{
				"buffer_size": 4422,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Debug/DebugConsole.h",
			"settings":
			{
				"buffer_size": 4292,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/SceneBuilder.h",
			"settings":
			{
				"buffer_size": 11802,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Utils/Debug/debug.h",
			"settings":
			{
				"buffer_size": 2463,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "#ifndef __FALCOR_DEBUG_H__"
			}
		},
		{
			"file": "src/Falcor/Core/BufferTypes/ParameterBlock.h",
			"settings":
			{
				"buffer_size": 20399,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Scene.cpp",
			"settings":
			{
				"buffer_size": 49068,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Camera/CameraController.cpp",
			"settings":
			{
				"buffer_size": 9863,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Scene/Camera/Camera.cpp",
			"settings":
			{
				"buffer_size": 13365,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Falcor/Core/API/D3D12/D3D12Resource.cpp",
			"settings":
			{
				"buffer_size": 6227,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"Package Control: ",
				"Package Control: Install Package"
			]
		],
		"width": 0.0
	},
	"console":
	{
		"height": 320.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/max/dev/Falcor",
		"/home/max/dev/Falcor/src",
		"/home/max/dev/Falcor/src/Falcor",
		"/home/max/dev/Falcor/src/Falcor/Core",
		"/home/max/dev/Falcor/src/Falcor/Core/API",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan",
		"/home/max/dev/Falcor/src/Falcor/Core/BufferTypes",
		"/home/max/dev/Falcor/src/Falcor/Core/Program",
		"/home/max/dev/Falcor/src/Falcor/RenderGraph",
		"/home/max/dev/Falcor/src/Falcor/Utils",
		"/home/max/dev/Falcor/src/Falcor/Utils/Scripting",
		"/home/max/dev/Falcor/src/Falcor/Utils/UI",
		"/home/max/dev/Falcor/src/Mogwai",
		"/home/max/dev/Falcor/src/Mogwai/Extensions",
		"/home/max/dev/Falcor/src/Mogwai/Extensions/Capture",
		"/home/max/dev/Falcor/src/RenderPasses",
		"/home/max/dev/Falcor/src/RenderPasses/AccumulatePass",
		"/home/max/dev/Falcor/src/RenderPasses/Antialiasing",
		"/home/max/dev/Falcor/src/RenderPasses/Antialiasing/FXAA",
		"/home/max/dev/Falcor/src/RenderPasses/Antialiasing/TAA",
		"/home/max/dev/Falcor/src/RenderPasses/BlitPass",
		"/home/max/dev/Falcor/src/RenderPasses/BSDFViewer",
		"/home/max/dev/Falcor/src/RenderPasses/CSM",
		"/home/max/dev/Falcor/src/RenderPasses/DebugPasses",
		"/home/max/dev/Falcor/src/RenderPasses/DebugPasses/InvalidPixelDetectionPass",
		"/home/max/dev/Falcor/src/RenderPasses/DebugPasses/SideBySidePass",
		"/home/max/dev/Falcor/src/RenderPasses/DebugPasses/SplitScreenPass",
		"/home/max/dev/Falcor/src/RenderPasses/DepthPass",
		"/home/max/dev/Falcor/src/RenderPasses/ErrorMeasurePass",
		"/home/max/dev/Falcor/src/RenderPasses/ForwardLightingPass",
		"/home/max/dev/Falcor/src/RenderPasses/GBuffer",
		"/home/max/dev/Falcor/src/RenderPasses/GBuffer/GBuffer",
		"/home/max/dev/Falcor/src/RenderPasses/GBuffer/VBuffer",
		"/home/max/dev/Falcor/src/RenderPasses/ImageLoader",
		"/home/max/dev/Falcor/src/RenderPasses/MinimalPathTracer",
		"/home/max/dev/Falcor/src/RenderPasses/PixelInspectorPass",
		"/home/max/dev/Falcor/src/RenderPasses/SkyBox",
		"/home/max/dev/Falcor/src/RenderPasses/SSAO",
		"/home/max/dev/Falcor/src/RenderPasses/SVGFPass",
		"/home/max/dev/Falcor/src/RenderPasses/TemporalDelayPass",
		"/home/max/dev/Falcor/src/RenderPasses/ToneMapper",
		"/home/max/dev/Falcor/src/RenderPasses/Utils",
		"/home/max/dev/Falcor/src/RenderPasses/Utils/Composite",
		"/home/max/dev/Falcor/src/RenderPasses/Utils/GaussianBlur",
		"/home/max/dev/Falcor/src/Tools",
		"/home/max/dev/Falcor/src/Tools/RenderGraphEditor",
		"/home/max/dev/Falcor/src/Tools/RenderGraphEditor/Data",
		"/home/max/dev/Falcor/Tools"
	],
	"file_history":
	[
		"/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKDeviceManager.h",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Engine.h",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Engine.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKGpuFence.cpp",
		"/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Utils/AABB_VKTests.cs.slang",
		"/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Utils/AABB_VKTests.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKFbo.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKTexture.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKState.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKGraphicsStateObject.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan/VKGpuTimer.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/API/GpuTimer.cpp",
		"/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Utils/HalfUtilsTests.cpp",
		"/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Slang/SlangMutatingTests.cpp",
		"/home/max/dev/Falcor/src/Tools/FalcorTest/Tests/Slang/WaveOps.cs.slang",
		"/home/max/dev/Falcor/src/Falcor/Scene/SceneBuilder.cpp",
		"/home/max/dev/Falcor/src/Falcor/Core/BufferTypes/ParameterBlock.cpp",
		"/home/max/dev/Falcor/src/Falcor/Data/LightProbes/20050806-03_hd.hdr",
		"/home/max/dev/Falcor/build/bin/Data/cube.obj",
		"/home/max/.config/sublime-text-3/Packages/SublimeLinter-gcc/miscellaneous/demo.cpp",
		"/home/max/.config/sublime-text-3/Packages/Package Control/Package Control.sublime-settings",
		"/home/max/Downloads/Telegram Desktop/scene.v001.usda",
		"/home/max/dev/blender/source/blender/draw/engines/eevee/eevee_occlusion_trace.c",
		"/home/max/dev/blender/release/scripts/startup/bl_ui/__init__.py",
		"/home/max/dev/blender/source/blender/draw/engines/eevee/shaders/common_fullscreen_embree_vert.glsl",
		"/home/max/dev/blender/source/blender/draw/engines/eevee/shaders/common_uniforms_embree_lib.glsl",
		"/home/max/dev/blender/source/blender/draw/engines/eevee/eevee_objects_map.h",
		"/home/max/dev/blender/source/blender/blenlib/intern/winstuff_dir.c",
		"/home/max/dev/blender/source/blender/draw/intern/draw_cache_extract.h",
		"/home/max/dev/blender/source/blender/draw/engines/workbench/workbench_engine.c",
		"/home/max/dev/blender/source/blender/draw/DRW_engine_types.h",
		"/home/max/dev/blender/source/blender/blenlib/BLI_hash.h",
		"/home/max/dev/blender/source/blender/blenlib/BLI_index_range.h",
		"/home/max/dev/blender/source/blender/bmesh/intern/bmesh_operators_private.h",
		"/home/max/dev/blender/source/blender/bmesh/intern/bmesh_operators.h",
		"/home/max/dev/blender/source/blender/python/intern/CMakeLists.txt",
		"/home/max/dev/blender/source/blender/blenlib/intern/BLI_ghash_utils.c",
		"/home/max/dev/blender/source/blender/blenlib/intern/BLI_ghash.c",
		"/home/max/dev/blender/source/blender/blenloader/intern/versioning_280.c",
		"/home/max/dev/blender/source/blender/draw/engines/eevee/shaders/ambient_occlusion_trace_lib.glsl",
		"/home/max/dev/bivis/src/blender/addon/ui.py",
		"/home/max/dev/bivis/src/blender/addon/presets.py",
		"/home/max/dev/bivis/src/blender/addon/properties.py",
		"/home/max/dev/bivis/src/blender/addon/osl.py",
		"/home/max/dev/bivis/src/blender/addon/operators.py",
		"/home/max/dev/bivis/src/blender/blender_python.cpp",
		"/home/max/dev/bivis/src/blender/addon/engine.py",
		"/home/max/dev/bivis/src/blender/addon/__init__.py",
		"/home/max/dev/bivis/src/blender/CMakeLists.txt",
		"/home/max/dev/blender/intern/CMakeLists.txt",
		"/home/max/dev/unity/scripts/mesh_smoother.cs",
		"/home/max/dev/unity/scripts/mesh_helper.cs",
		"/home/max/dev/fasta/src/fasta_lib/renderer.h",
		"/home/max/dev/fasta/CMakeLists.txt",
		"/home/max/dev/fasta/third_party/glad/include/KHR/khrplatform.h",
		"/home/max/dev/fasta/third_party/glad/include/glad/glad.h",
		"/home/max/dev/fasta/src/locomotive_lib/logging.h",
		"/home/max/dev/fasta/src/locomotive_lib/CMakeLists.txt",
		"/home/max/dev/fasta/src/locomotive_lib/logging.cpp",
		"/home/max/dev/fasta/src/xenon_lib/XN_RendererIPR.h",
		"/home/max/dev/fasta/src/xenon_py/CMakeLists.txt",
		"/home/max/dev/fasta/src/xenon_lib/XN_Shader.h",
		"/home/max/dev/fasta/src/xenon_lib/CMakeLists.txt",
		"/home/max/dev/fasta/src/xenon_cmd/CMakeLists.txt",
		"/home/max/dev/fasta/src/xenon_lib/XN_Mesh.h",
		"/home/max/dev/fasta/src/xenon_lib/XN_Shader.cpp",
		"/home/max/dev/fasta/src/xenon_lib/XN_GBuffer.cpp",
		"/home/max/dev/fasta/src/xenon_lib/XN_GBuffer.h",
		"/home/max/dev/fasta/src/xenon_lib/XN_Renderer.h",
		"/home/max/dev/fasta/src/xenon_lib/XN_Renderer.cpp",
		"/home/max/dev/fasta/src/xenon_cmd/fsquad.h",
		"/home/max/dev/fasta/src/xenon_cmd/xenon.cpp",
		"/home/max/dev/fasta/src/xenon_lib/XN_RendererIPR.cpp",
		"/home/max/projects/Xenon/xenon.sublime-project",
		"/home/max/projects/Xenon/src/ROP_Xenon.h",
		"/home/max/projects/Xenon/src/ROP_Xenon.cpp",
		"/home/max/projects/Xenon/makefile"
	],
	"find":
	{
		"height": 39.0
	},
	"find_in_files":
	{
		"height": 125.0,
		"where_history":
		[
			"/home/max/dev/Falcor/src",
			"/home/max/dev/Falcor/src,/home/max/dev/Falcor/third_party/slang",
			"/home/max/dev/Falcor/src",
			"/home/max/dev/Falcor/src/Falcor",
			"/home/max/dev/Falcor/src/Falcor,/home/max/dev/Falcor/third_party/slang",
			"/home/max/dev/Falcor/src/Falcor",
			"/home/max/dev/Falcor/third_party/slang/source",
			"/home/max/dev/Falcor/src",
			"/home/max/dev/Falcor/third_party/slang",
			"/home/max/dev/Falcor/src",
			"/home/max/dev/Falcor/third_party/slang",
			"/home/max/dev/Falcor/src",
			"/home/max/dev/Falcor/Build",
			"/home/max/dev/Falcor/",
			"/home/max/dev/Falcor/src/",
			"/home/max/dev/Falcor/src/Mogwai",
			"/home/max/dev/Falcor/src/Falcor",
			"/home/max/dev/Falcor/",
			"/home/max/dev/Falcor/src/Falcor",
			"/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan",
			"/home/max/dev/Falcor/src",
			"/home/max/dev/Falcor/src/Falcor",
			"/home/max/dev/Falcor/src/Falcor/Core/API/Vulkan",
			"/home/max/dev/Falcor"
		]
	},
	"find_state":
	{
		"case_sensitive": true,
		"find_history":
		[
			"singleton",
			"staticFunc_",
			"PYBIND11_MODULE",
			"loadRenderPassLibrary",
			"Device uid",
			"smartDevicePtr",
			"SharedPtr(this)",
			"mDeferredReleases",
			"setResourceSrvUavCommon",
			"Resource(",
			"ResourceViewInfo",
			"std::unordered_map",
			"std::unordered_map<Falcor::ResourceViewInfo",
			"resizeSwapChain",
			"getClientAreaSize",
			"ConstTextureSharedPtrRef",
			"VkDeviceData",
			"DeviceHandle",
			"createSurface",
			"allocateDeviceMemory",
			"mapBufferApi",
			"device",
			"mapBufferApi",
			"VkResource",
			"ResourceHandle",
			"mapBufferApi",
			"getBufferDataAlignment",
			"createDescriptorSetLayout",
			"_profileEvent",
			"getGlobalClock",
			"FrameRate",
			"UnitTestContext",
			"Scene* pScene",
			"LightCollection",
			"= delete",
			"GraphicsState",
			"gpDevice",
			"ResourceHandle",
			"gpDevice",
			"mpDevice",
			"kSwapChainBuffersCount",
			"gpDevice",
			"mpSwapChainFbos",
			"gpDevice",
			"IFramework",
			"IRenderer",
			"_pass",
			"dso",
			"D3D12_DRAW_INDEXED_ARGUMENTS",
			"createDrawList",
			"uavBarrier",
			"initGeomDesc",
			"PixelData",
			"ShadingData",
			"getCurrentBackBufferIndex",
			"vkAcquireNextImageKHR",
			"AMD_EXTENSIONS",
			"gl_BaryCoordSmoothAMD",
			"setDefines",
			"gl_BaryCoordSmoothAMD",
			"vulkan",
			"availableFor",
			"SV_Barycentrics",
			"GL_AMD_shader_explicit_vertex_parameter",
			"SV_Barycentrics",
			"SV_PrimitiveID",
			"SV_Barycentrics",
			"register(",
			"asTexture",
			"DebugConsole",
			"unordered_set",
			"gProfileEnabled",
			"FrameRate",
			"gProfileEnabled",
			"enableDebugLayer",
			"generateBSDFSample",
			"[[vk::binding",
			"uavBarrier",
			"spvVersion",
			"requires SPIR-V 1.3",
			"SPV_ENV_VULKAN_1_1_SPIRV_1_4",
			"SPIR-V 1.3",
			"SLANG_SPIRV",
			"SPIR",
			"<float3>",
			"ReflectionResourceType",
			"float3",
			"kFormatDesc",
			"RGB32Float",
			"GLM_ENABLE_EXPERIMENTAL",
			"float3",
			"RGB16Float",
			"float3",
			"RGB32Float",
			"WaveGetLaneCount",
			"FormatForElementType",
			"falcorToVkDescType",
			"VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER",
			"WaveGetLaneCount",
			"int16_t",
			"int16_T",
			"AMD_EXTENSIONS",
			"extension",
			"420.430",
			"Test failed",
			"printToDebugWindow",
			"mapBuffer",
			"Dispatch dimension exceeds maximum",
			"InvalidPixel",
			"vkCreateImage",
			"asTexture",
			"flush",
			"getRootDescriptorRangeCount",
			"mRootDescriptorRangeIndices",
			"VkDescriptorSet",
			"createDescriptorSetLayout",
			"RootSignature",
			"mRootConstants",
			"mRootDescriptors",
			"VkPipeline",
			"bindForCompute",
			"applyComputeVars",
			"applyProgramVarsCommon",
			"bindForCompute",
			"mRootDescriptors",
			"mpRootSignature",
			"mpRootSignature->apiInit",
			"RootSignature"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"mpDevice",
			"kPassTempLibSuffix",
			"PROJECT_DIR",
			"spData"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 403,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "src/Falcor/Core/API/D3D12/D3D12ResourceViews.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 18914,
						"regions":
						{
						},
						"selection":
						[
							[
								11151,
								11151
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4150.0,
						"zoom_level": 1.0
					},
					"stack_index": 236,
					"type": "text"
				},
				{
					"buffer": 1,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 500872,
						"regions":
						{
							"match":
							{
								"flags": 112,
								"regions":
								[
									[
										323,
										331
									],
									[
										397,
										405
									],
									[
										677,
										685
									],
									[
										753,
										761
									],
									[
										998,
										1006
									],
									[
										1088,
										1096
									],
									[
										1290,
										1298
									],
									[
										1351,
										1359
									],
									[
										1557,
										1565
									],
									[
										1611,
										1619
									],
									[
										1911,
										1919
									],
									[
										1978,
										1986
									],
									[
										2152,
										2160
									],
									[
										2216,
										2224
									],
									[
										2601,
										2609
									],
									[
										2938,
										2946
									],
									[
										3001,
										3009
									],
									[
										3166,
										3174
									],
									[
										3555,
										3563
									],
									[
										3713,
										3721
									],
									[
										3767,
										3775
									],
									[
										3989,
										3997
									],
									[
										4041,
										4049
									],
									[
										4111,
										4119
									],
									[
										4176,
										4184
									],
									[
										4346,
										4354
									],
									[
										4421,
										4429
									],
									[
										4484,
										4492
									],
									[
										4613,
										4621
									],
									[
										4678,
										4686
									],
									[
										4731,
										4739
									],
									[
										4874,
										4882
									],
									[
										4954,
										4962
									],
									[
										5021,
										5029
									],
									[
										5230,
										5238
									],
									[
										5340,
										5348
									],
									[
										5437,
										5445
									],
									[
										5631,
										5639
									],
									[
										5707,
										5715
									],
									[
										5770,
										5778
									],
									[
										5915,
										5923
									],
									[
										5996,
										6004
									],
									[
										6065,
										6073
									],
									[
										6194,
										6202
									],
									[
										6259,
										6267
									],
									[
										6312,
										6320
									],
									[
										6509,
										6517
									],
									[
										6584,
										6592
									],
									[
										6647,
										6655
									],
									[
										6836,
										6844
									],
									[
										6909,
										6917
									],
									[
										7295,
										7303
									],
									[
										7383,
										7391
									],
									[
										7596,
										7604
									],
									[
										7679,
										7687
									],
									[
										7750,
										7758
									],
									[
										7894,
										7902
									],
									[
										7935,
										7943
									],
									[
										8128,
										8136
									],
									[
										8243,
										8251
									],
									[
										8346,
										8354
									],
									[
										8479,
										8487
									],
									[
										8548,
										8556
									],
									[
										8605,
										8613
									],
									[
										8802,
										8810
									],
									[
										8875,
										8883
									],
									[
										8936,
										8944
									],
									[
										9207,
										9215
									],
									[
										9294,
										9302
									],
									[
										9443,
										9451
									],
									[
										9528,
										9536
									],
									[
										9601,
										9609
									],
									[
										9784,
										9792
									],
									[
										9853,
										9861
									],
									[
										9998,
										10006
									],
									[
										10079,
										10087
									],
									[
										10148,
										10156
									],
									[
										10291,
										10299
									],
									[
										10370,
										10378
									],
									[
										10437,
										10445
									],
									[
										10568,
										10576
									],
									[
										10635,
										10643
									],
									[
										10690,
										10698
									],
									[
										10825,
										10833
									],
									[
										10896,
										10904
									],
									[
										10955,
										10963
									],
									[
										11128,
										11136
									],
									[
										11195,
										11203
									],
									[
										11250,
										11258
									],
									[
										11481,
										11489
									],
									[
										11551,
										11559
									],
									[
										11674,
										11682
									],
									[
										11986,
										12001
									],
									[
										12194,
										12209
									],
									[
										12323,
										12338
									],
									[
										12341,
										12356
									],
									[
										12644,
										12659
									],
									[
										12814,
										12829
									],
									[
										13057,
										13072
									],
									[
										13300,
										13315
									],
									[
										13535,
										13550
									],
									[
										13879,
										13894
									],
									[
										14315,
										14330
									],
									[
										14554,
										14569
									],
									[
										14838,
										14853
									],
									[
										15055,
										15070
									],
									[
										15230,
										15245
									],
									[
										15664,
										15679
									],
									[
										16016,
										16031
									],
									[
										16252,
										16267
									],
									[
										16286,
										16301
									],
									[
										16359,
										16374
									],
									[
										16519,
										16534
									],
									[
										16859,
										16874
									],
									[
										17184,
										17199
									],
									[
										17218,
										17233
									],
									[
										17257,
										17272
									],
									[
										17274,
										17289
									],
									[
										17529,
										17544
									],
									[
										17737,
										17752
									],
									[
										17905,
										17920
									],
									[
										17939,
										17954
									],
									[
										18167,
										18182
									],
									[
										18201,
										18216
									],
									[
										18331,
										18346
									],
									[
										18365,
										18380
									],
									[
										18690,
										18705
									],
									[
										18753,
										18768
									],
									[
										19030,
										19045
									],
									[
										19093,
										19108
									],
									[
										19568,
										19583
									],
									[
										19885,
										19900
									],
									[
										20177,
										20192
									],
									[
										20366,
										20381
									],
									[
										20764,
										20779
									],
									[
										21036,
										21051
									],
									[
										21466,
										21481
									],
									[
										21502,
										21517
									],
									[
										21627,
										21642
									],
									[
										21654,
										21669
									],
									[
										21794,
										21809
									],
									[
										21924,
										21939
									],
									[
										22034,
										22049
									],
									[
										22150,
										22165
									],
									[
										22363,
										22378
									],
									[
										22563,
										22578
									],
									[
										22963,
										22978
									],
									[
										23201,
										23216
									],
									[
										23358,
										23373
									],
									[
										23611,
										23626
									],
									[
										24014,
										24029
									],
									[
										24293,
										24308
									],
									[
										24532,
										24547
									],
									[
										24715,
										24730
									],
									[
										25095,
										25110
									],
									[
										25282,
										25297
									],
									[
										25811,
										25826
									],
									[
										26039,
										26054
									],
									[
										26152,
										26167
									],
									[
										26283,
										26298
									],
									[
										26449,
										26464
									],
									[
										26858,
										26873
									],
									[
										27008,
										27023
									],
									[
										27422,
										27437
									],
									[
										27576,
										27591
									],
									[
										27856,
										27871
									],
									[
										27914,
										27929
									],
									[
										28261,
										28276
									],
									[
										28410,
										28425
									],
									[
										28464,
										28479
									],
									[
										28544,
										28559
									],
									[
										28621,
										28636
									],
									[
										28696,
										28711
									],
									[
										28803,
										28818
									],
									[
										28947,
										28962
									],
									[
										29127,
										29142
									],
									[
										29192,
										29207
									],
									[
										29435,
										29450
									],
									[
										29645,
										29660
									],
									[
										29807,
										29822
									],
									[
										30243,
										30258
									],
									[
										30682,
										30697
									],
									[
										31006,
										31021
									],
									[
										31375,
										31390
									],
									[
										31762,
										31777
									],
									[
										32159,
										32174
									],
									[
										32550,
										32565
									],
									[
										32793,
										32808
									],
									[
										33044,
										33059
									],
									[
										33300,
										33315
									],
									[
										33650,
										33665
									],
									[
										33817,
										33832
									],
									[
										33862,
										33877
									],
									[
										33923,
										33938
									],
									[
										33959,
										33974
									],
									[
										33977,
										33992
									],
									[
										34049,
										34064
									],
									[
										34147,
										34162
									],
									[
										34250,
										34265
									],
									[
										34271,
										34286
									],
									[
										34331,
										34346
									],
									[
										34469,
										34484
									],
									[
										34630,
										34645
									],
									[
										34939,
										34954
									],
									[
										35262,
										35277
									],
									[
										35524,
										35539
									],
									[
										35562,
										35577
									],
									[
										35898,
										35913
									],
									[
										35927,
										35942
									],
									[
										36385,
										36400
									],
									[
										36563,
										36578
									],
									[
										36938,
										36951
									],
									[
										37163,
										37176
									],
									[
										37558,
										37571
									],
									[
										37949,
										37962
									],
									[
										38221,
										38234
									],
									[
										38580,
										38593
									],
									[
										39037,
										39050
									],
									[
										39205,
										39218
									],
									[
										39429,
										39442
									],
									[
										39616,
										39629
									],
									[
										39778,
										39791
									],
									[
										39954,
										39967
									],
									[
										40137,
										40150
									],
									[
										40282,
										40295
									],
									[
										40521,
										40534
									],
									[
										40688,
										40701
									],
									[
										40851,
										40864
									],
									[
										41010,
										41023
									],
									[
										41328,
										41341
									],
									[
										41387,
										41400
									],
									[
										41446,
										41459
									],
									[
										41504,
										41517
									],
									[
										41800,
										41815
									],
									[
										41842,
										41857
									],
									[
										42051,
										42066
									],
									[
										42325,
										42340
									],
									[
										42536,
										42551
									],
									[
										42856,
										42871
									],
									[
										43051,
										43066
									],
									[
										43263,
										43278
									],
									[
										43549,
										43564
									],
									[
										43586,
										43601
									],
									[
										43767,
										43782
									],
									[
										43844,
										43859
									],
									[
										44187,
										44202
									],
									[
										44366,
										44381
									],
									[
										44391,
										44406
									],
									[
										44448,
										44463
									],
									[
										44473,
										44488
									],
									[
										44529,
										44544
									],
									[
										44897,
										44912
									],
									[
										45095,
										45110
									],
									[
										45333,
										45348
									],
									[
										45489,
										45504
									],
									[
										45734,
										45749
									],
									[
										46044,
										46059
									],
									[
										46354,
										46369
									],
									[
										46664,
										46679
									],
									[
										46973,
										46988
									],
									[
										47283,
										47298
									],
									[
										47514,
										47529
									],
									[
										47809,
										47824
									],
									[
										48260,
										48275
									],
									[
										48552,
										48567
									],
									[
										49003,
										49018
									],
									[
										49357,
										49372
									],
									[
										49619,
										49634
									],
									[
										50020,
										50035
									],
									[
										50390,
										50405
									],
									[
										50699,
										50714
									],
									[
										51021,
										51036
									],
									[
										51308,
										51323
									],
									[
										51633,
										51648
									],
									[
										51988,
										52003
									],
									[
										52334,
										52349
									],
									[
										52771,
										52786
									],
									[
										53103,
										53118
									],
									[
										53337,
										53352
									],
									[
										53603,
										53618
									],
									[
										53781,
										53796
									],
									[
										54075,
										54090
									],
									[
										54340,
										54355
									],
									[
										54693,
										54708
									],
									[
										55040,
										55049
									],
									[
										55183,
										55192
									],
									[
										55233,
										55242
									],
									[
										55247,
										55256
									],
									[
										55548,
										55557
									],
									[
										55741,
										55750
									],
									[
										55909,
										55918
									],
									[
										56098,
										56107
									],
									[
										56219,
										56228
									],
									[
										56500,
										56509
									],
									[
										56749,
										56758
									],
									[
										56763,
										56772
									],
									[
										56794,
										56803
									],
									[
										57021,
										57030
									],
									[
										57033,
										57042
									],
									[
										57253,
										57262
									],
									[
										57564,
										57573
									],
									[
										57860,
										57869
									],
									[
										58167,
										58176
									],
									[
										58358,
										58367
									],
									[
										58650,
										58659
									],
									[
										58750,
										58759
									],
									[
										58961,
										58970
									],
									[
										59113,
										59122
									],
									[
										59151,
										59160
									],
									[
										59328,
										59337
									],
									[
										59451,
										59460
									],
									[
										59713,
										59722
									],
									[
										59873,
										59882
									],
									[
										60299,
										60308
									],
									[
										60525,
										60534
									],
									[
										60842,
										60851
									],
									[
										61132,
										61146
									],
									[
										61647,
										61661
									],
									[
										62019,
										62033
									],
									[
										62296,
										62310
									],
									[
										62695,
										62709
									],
									[
										63003,
										63017
									],
									[
										63262,
										63276
									],
									[
										63451,
										63465
									],
									[
										63633,
										63647
									],
									[
										63892,
										63906
									],
									[
										64362,
										64376
									],
									[
										64682,
										64696
									],
									[
										64890,
										64904
									],
									[
										65224,
										65238
									],
									[
										65552,
										65566
									],
									[
										65853,
										65867
									],
									[
										66186,
										66200
									],
									[
										66463,
										66477
									],
									[
										66862,
										66876
									],
									[
										67170,
										67184
									],
									[
										67429,
										67443
									],
									[
										67618,
										67632
									],
									[
										67800,
										67814
									],
									[
										68059,
										68073
									],
									[
										68529,
										68543
									],
									[
										68849,
										68863
									],
									[
										69057,
										69071
									],
									[
										69391,
										69405
									],
									[
										69719,
										69733
									],
									[
										70020,
										70034
									],
									[
										70423,
										70437
									],
									[
										70731,
										70745
									],
									[
										70990,
										71004
									],
									[
										71179,
										71193
									],
									[
										71361,
										71375
									],
									[
										71620,
										71634
									],
									[
										72090,
										72104
									],
									[
										72410,
										72424
									],
									[
										72618,
										72632
									],
									[
										72952,
										72966
									],
									[
										73280,
										73294
									],
									[
										73580,
										73594
									],
									[
										73903,
										73917
									],
									[
										74162,
										74176
									],
									[
										74351,
										74365
									],
									[
										74533,
										74547
									],
									[
										74792,
										74806
									],
									[
										75262,
										75276
									],
									[
										75582,
										75596
									],
									[
										75790,
										75804
									],
									[
										76124,
										76138
									],
									[
										76452,
										76466
									],
									[
										76762,
										76775
									],
									[
										76864,
										76877
									],
									[
										77192,
										77217
									],
									[
										77411,
										77436
									],
									[
										77711,
										77736
									],
									[
										77996,
										78021
									],
									[
										78303,
										78328
									],
									[
										78347,
										78372
									],
									[
										78688,
										78713
									],
									[
										78940,
										78965
									],
									[
										79250,
										79275
									],
									[
										79535,
										79560
									],
									[
										79842,
										79867
									],
									[
										79886,
										79911
									],
									[
										80227,
										80252
									],
									[
										80479,
										80504
									],
									[
										80789,
										80814
									],
									[
										81075,
										81100
									],
									[
										81382,
										81407
									],
									[
										81426,
										81451
									],
									[
										81726,
										81748
									],
									[
										81976,
										81998
									],
									[
										82220,
										82242
									],
									[
										82482,
										82504
									],
									[
										82732,
										82754
									],
									[
										83136,
										83158
									],
									[
										83413,
										83435
									],
									[
										83667,
										83689
									],
									[
										83929,
										83951
									],
									[
										84179,
										84201
									],
									[
										84583,
										84605
									],
									[
										84833,
										84855
									],
									[
										85077,
										85099
									],
									[
										85339,
										85361
									],
									[
										85589,
										85611
									],
									[
										85995,
										86017
									],
									[
										86245,
										86267
									],
									[
										86489,
										86511
									],
									[
										86751,
										86773
									],
									[
										87001,
										87023
									],
									[
										87417,
										87429
									],
									[
										87823,
										87835
									],
									[
										88083,
										88095
									],
									[
										88292,
										88304
									],
									[
										88714,
										88728
									],
									[
										88904,
										88918
									],
									[
										89192,
										89206
									],
									[
										89482,
										89496
									],
									[
										89860,
										89874
									],
									[
										90169,
										90183
									],
									[
										90609,
										90623
									],
									[
										90818,
										90832
									],
									[
										91094,
										91108
									],
									[
										91453,
										91467
									],
									[
										91837,
										91851
									],
									[
										91984,
										91998
									],
									[
										92338,
										92352
									],
									[
										92709,
										92723
									],
									[
										92741,
										92755
									],
									[
										92982,
										92996
									],
									[
										93168,
										93182
									],
									[
										93184,
										93198
									],
									[
										93458,
										93472
									],
									[
										93689,
										93703
									],
									[
										94126,
										94140
									],
									[
										94450,
										94464
									],
									[
										94540,
										94554
									],
									[
										94761,
										94775
									],
									[
										95185,
										95199
									],
									[
										95468,
										95482
									],
									[
										95697,
										95711
									],
									[
										96035,
										96045
									],
									[
										96102,
										96112
									],
									[
										96177,
										96187
									],
									[
										96252,
										96262
									],
									[
										96327,
										96337
									],
									[
										96402,
										96412
									],
									[
										96800,
										96810
									],
									[
										97207,
										97217
									],
									[
										97579,
										97589
									],
									[
										97806,
										97816
									],
									[
										98110,
										98120
									],
									[
										98360,
										98370
									],
									[
										98689,
										98699
									],
									[
										99065,
										99075
									],
									[
										99425,
										99435
									],
									[
										99569,
										99579
									],
									[
										99766,
										99776
									],
									[
										99983,
										99993
									],
									[
										100162,
										100172
									],
									[
										100439,
										100449
									],
									[
										100634,
										100644
									],
									[
										100922,
										100932
									],
									[
										101141,
										101151
									],
									[
										101389,
										101399
									],
									[
										101667,
										101677
									],
									[
										101865,
										101875
									],
									[
										102167,
										102177
									],
									[
										102386,
										102396
									],
									[
										102615,
										102625
									],
									[
										102647,
										102657
									],
									[
										102769,
										102779
									],
									[
										102878,
										102888
									],
									[
										103115,
										103125
									],
									[
										103360,
										103370
									],
									[
										103565,
										103575
									],
									[
										103605,
										103615
									],
									[
										103727,
										103737
									],
									[
										103847,
										103857
									],
									[
										104076,
										104086
									],
									[
										104320,
										104330
									],
									[
										104352,
										104362
									],
									[
										104386,
										104396
									],
									[
										104426,
										104436
									],
									[
										104580,
										104590
									],
									[
										104716,
										104726
									],
									[
										104802,
										104812
									],
									[
										104907,
										104917
									],
									[
										105036,
										105046
									],
									[
										105095,
										105105
									],
									[
										105297,
										105307
									],
									[
										105530,
										105540
									],
									[
										105627,
										105637
									],
									[
										105851,
										105861
									],
									[
										105967,
										105977
									],
									[
										106138,
										106148
									],
									[
										106210,
										106220
									],
									[
										106289,
										106299
									],
									[
										106362,
										106372
									],
									[
										106500,
										106510
									],
									[
										106613,
										106623
									],
									[
										106695,
										106705
									],
									[
										106810,
										106820
									],
									[
										106891,
										106901
									],
									[
										106914,
										106924
									],
									[
										107116,
										107126
									],
									[
										107148,
										107158
									],
									[
										107180,
										107190
									],
									[
										107220,
										107230
									],
									[
										107452,
										107462
									],
									[
										107836,
										107846
									],
									[
										108265,
										108275
									],
									[
										108508,
										108518
									],
									[
										108547,
										108557
									],
									[
										108814,
										108824
									],
									[
										109089,
										109099
									],
									[
										109128,
										109138
									],
									[
										109277,
										109287
									],
									[
										109316,
										109326
									],
									[
										109521,
										109531
									],
									[
										109723,
										109733
									],
									[
										110016,
										110026
									],
									[
										110254,
										110264
									],
									[
										110316,
										110326
									],
									[
										110565,
										110575
									],
									[
										110627,
										110637
									],
									[
										110862,
										110872
									],
									[
										110885,
										110895
									],
									[
										111018,
										111028
									],
									[
										111042,
										111052
									],
									[
										111175,
										111185
									],
									[
										111332,
										111342
									],
									[
										111492,
										111502
									],
									[
										111627,
										111637
									],
									[
										111785,
										111795
									],
									[
										111924,
										111934
									],
									[
										112080,
										112090
									],
									[
										112229,
										112239
									],
									[
										112409,
										112419
									],
									[
										112600,
										112610
									],
									[
										112706,
										112716
									],
									[
										112867,
										112877
									],
									[
										113008,
										113018
									],
									[
										113053,
										113063
									],
									[
										113093,
										113103
									],
									[
										113138,
										113148
									],
									[
										113166,
										113176
									],
									[
										113483,
										113493
									],
									[
										113550,
										113560
									],
									[
										113625,
										113635
									],
									[
										113700,
										113710
									],
									[
										113775,
										113785
									],
									[
										113850,
										113860
									],
									[
										114248,
										114258
									],
									[
										114655,
										114665
									],
									[
										115027,
										115037
									],
									[
										115254,
										115264
									],
									[
										115558,
										115568
									],
									[
										115808,
										115818
									],
									[
										116137,
										116147
									],
									[
										116513,
										116523
									],
									[
										116873,
										116883
									],
									[
										117017,
										117027
									],
									[
										117214,
										117224
									],
									[
										117431,
										117441
									],
									[
										117610,
										117620
									],
									[
										117887,
										117897
									],
									[
										118082,
										118092
									],
									[
										118370,
										118380
									],
									[
										118589,
										118599
									],
									[
										118837,
										118847
									],
									[
										119115,
										119125
									],
									[
										119313,
										119323
									],
									[
										119615,
										119625
									],
									[
										119834,
										119844
									],
									[
										120063,
										120073
									],
									[
										120095,
										120105
									],
									[
										120217,
										120227
									],
									[
										120326,
										120336
									],
									[
										120563,
										120573
									],
									[
										120808,
										120818
									],
									[
										121013,
										121023
									],
									[
										121053,
										121063
									],
									[
										121175,
										121185
									],
									[
										121295,
										121305
									],
									[
										121524,
										121534
									],
									[
										121768,
										121778
									],
									[
										121800,
										121810
									],
									[
										121834,
										121844
									],
									[
										121874,
										121884
									],
									[
										122028,
										122038
									],
									[
										122164,
										122174
									],
									[
										122250,
										122260
									],
									[
										122355,
										122365
									],
									[
										122484,
										122494
									],
									[
										122543,
										122553
									],
									[
										122745,
										122755
									],
									[
										122978,
										122988
									],
									[
										123075,
										123085
									],
									[
										123299,
										123309
									],
									[
										123415,
										123425
									],
									[
										123586,
										123596
									],
									[
										123658,
										123668
									],
									[
										123737,
										123747
									],
									[
										123810,
										123820
									],
									[
										123948,
										123958
									],
									[
										124061,
										124071
									],
									[
										124143,
										124153
									],
									[
										124258,
										124268
									],
									[
										124339,
										124349
									],
									[
										124362,
										124372
									],
									[
										124564,
										124574
									],
									[
										124596,
										124606
									],
									[
										124628,
										124638
									],
									[
										124668,
										124678
									],
									[
										124900,
										124910
									],
									[
										125284,
										125294
									],
									[
										125713,
										125723
									],
									[
										125956,
										125966
									],
									[
										125995,
										126005
									],
									[
										126262,
										126272
									],
									[
										126537,
										126547
									],
									[
										126576,
										126586
									],
									[
										126725,
										126735
									],
									[
										126764,
										126774
									],
									[
										126969,
										126979
									],
									[
										127171,
										127181
									],
									[
										127464,
										127474
									],
									[
										127702,
										127712
									],
									[
										127764,
										127774
									],
									[
										128013,
										128023
									],
									[
										128075,
										128085
									],
									[
										128310,
										128320
									],
									[
										128333,
										128343
									],
									[
										128466,
										128476
									],
									[
										128490,
										128500
									],
									[
										128623,
										128633
									],
									[
										128780,
										128790
									],
									[
										128940,
										128950
									],
									[
										129075,
										129085
									],
									[
										129233,
										129243
									],
									[
										129372,
										129382
									],
									[
										129528,
										129538
									],
									[
										129677,
										129687
									],
									[
										129857,
										129867
									],
									[
										130048,
										130058
									],
									[
										130154,
										130164
									],
									[
										130315,
										130325
									],
									[
										130456,
										130466
									],
									[
										130501,
										130511
									],
									[
										130541,
										130551
									],
									[
										130586,
										130596
									],
									[
										130614,
										130624
									],
									[
										130893,
										130905
									],
									[
										131299,
										131311
									],
									[
										131559,
										131571
									],
									[
										131768,
										131780
									],
									[
										132199,
										132205
									],
									[
										132254,
										132260
									],
									[
										132571,
										132577
									],
									[
										132900,
										132906
									],
									[
										133228,
										133234
									],
									[
										133558,
										133564
									],
									[
										133886,
										133892
									],
									[
										134289,
										134295
									],
									[
										134660,
										134666
									],
									[
										134818,
										134824
									],
									[
										135190,
										135196
									],
									[
										135348,
										135354
									],
									[
										135621,
										135627
									],
									[
										135895,
										135901
									],
									[
										136169,
										136175
									],
									[
										136444,
										136450
									],
									[
										136809,
										136815
									],
									[
										137175,
										137181
									],
									[
										137491,
										137497
									],
									[
										137649,
										137655
									],
									[
										137966,
										137972
									],
									[
										138124,
										138130
									],
									[
										138431,
										138437
									],
									[
										138801,
										138807
									],
									[
										139169,
										139175
									],
									[
										139538,
										139544
									],
									[
										139997,
										140003
									],
									[
										140457,
										140463
									],
									[
										140869,
										140875
									],
									[
										141027,
										141033
									],
									[
										141438,
										141444
									],
									[
										141596,
										141602
									],
									[
										141989,
										141995
									],
									[
										142315,
										142321
									],
									[
										142639,
										142645
									],
									[
										142964,
										142970
									],
									[
										143362,
										143368
									],
									[
										143761,
										143767
									],
									[
										144111,
										144117
									],
									[
										144269,
										144275
									],
									[
										144618,
										144624
									],
									[
										144776,
										144782
									],
									[
										145154,
										145160
									],
									[
										145478,
										145484
									],
									[
										145801,
										145807
									],
									[
										146138,
										146144
									],
									[
										146433,
										146439
									],
									[
										146451,
										146457
									],
									[
										146519,
										146525
									],
									[
										146702,
										146708
									],
									[
										146935,
										146941
									],
									[
										147023,
										147029
									],
									[
										147400,
										147406
									],
									[
										147565,
										147571
									],
									[
										147960,
										147966
									],
									[
										147997,
										148003
									],
									[
										148147,
										148153
									],
									[
										148226,
										148232
									],
									[
										148474,
										148480
									],
									[
										148660,
										148666
									],
									[
										148891,
										148897
									],
									[
										149027,
										149033
									],
									[
										149106,
										149112
									],
									[
										149205,
										149211
									],
									[
										149311,
										149317
									],
									[
										149525,
										149531
									],
									[
										149761,
										149767
									],
									[
										150096,
										150102
									],
									[
										150253,
										150259
									],
									[
										150700,
										150706
									],
									[
										150976,
										150982
									],
									[
										151089,
										151095
									],
									[
										151340,
										151346
									],
									[
										151597,
										151603
									],
									[
										151808,
										151814
									],
									[
										151849,
										151855
									],
									[
										152022,
										152028
									],
									[
										152316,
										152322
									],
									[
										152549,
										152555
									],
									[
										152736,
										152742
									],
									[
										153136,
										153142
									],
									[
										153246,
										153252
									],
									[
										153349,
										153355
									],
									[
										153686,
										153692
									],
									[
										153791,
										153797
									],
									[
										154030,
										154036
									],
									[
										154338,
										154344
									],
									[
										154431,
										154437
									],
									[
										154535,
										154541
									],
									[
										154758,
										154764
									],
									[
										154856,
										154862
									],
									[
										155004,
										155010
									],
									[
										155119,
										155125
									],
									[
										155275,
										155281
									],
									[
										155456,
										155462
									],
									[
										155565,
										155571
									],
									[
										155689,
										155695
									],
									[
										155816,
										155822
									],
									[
										155952,
										155958
									],
									[
										155997,
										156003
									],
									[
										156164,
										156170
									],
									[
										156295,
										156301
									],
									[
										156635,
										156641
									],
									[
										156931,
										156937
									],
									[
										157060,
										157066
									],
									[
										157211,
										157217
									],
									[
										157657,
										157663
									],
									[
										157901,
										157907
									],
									[
										158393,
										158399
									],
									[
										158605,
										158611
									],
									[
										158808,
										158814
									],
									[
										159015,
										159021
									],
									[
										159072,
										159078
									],
									[
										159405,
										159411
									],
									[
										159642,
										159648
									],
									[
										159661,
										159667
									],
									[
										159982,
										159988
									],
									[
										160194,
										160200
									],
									[
										160286,
										160292
									],
									[
										160487,
										160493
									],
									[
										160925,
										160931
									],
									[
										161055,
										161061
									],
									[
										161298,
										161304
									],
									[
										161501,
										161507
									],
									[
										161519,
										161525
									],
									[
										161593,
										161599
									],
									[
										161686,
										161692
									],
									[
										161736,
										161742
									],
									[
										161829,
										161835
									],
									[
										161954,
										161960
									],
									[
										162178,
										162184
									],
									[
										162330,
										162336
									],
									[
										162480,
										162486
									],
									[
										162841,
										162847
									],
									[
										162977,
										162983
									],
									[
										163243,
										163249
									],
									[
										163694,
										163700
									],
									[
										163994,
										164000
									],
									[
										164337,
										164343
									],
									[
										164460,
										164466
									],
									[
										164623,
										164629
									],
									[
										165049,
										165055
									],
									[
										165337,
										165343
									],
									[
										165446,
										165452
									],
									[
										165558,
										165564
									],
									[
										165751,
										165757
									],
									[
										165807,
										165813
									],
									[
										166072,
										166078
									],
									[
										166281,
										166287
									],
									[
										166646,
										166652
									],
									[
										167005,
										167011
									],
									[
										167385,
										167391
									],
									[
										167827,
										167833
									],
									[
										168143,
										168149
									],
									[
										168340,
										168346
									],
									[
										168669,
										168675
									],
									[
										168813,
										168819
									],
									[
										168948,
										168954
									],
									[
										169169,
										169175
									],
									[
										169212,
										169218
									],
									[
										169515,
										169521
									],
									[
										169834,
										169840
									],
									[
										170018,
										170024
									],
									[
										170051,
										170057
									],
									[
										170247,
										170253
									],
									[
										170443,
										170449
									],
									[
										170601,
										170607
									],
									[
										170724,
										170730
									],
									[
										170991,
										170997
									],
									[
										171217,
										171223
									],
									[
										171526,
										171532
									],
									[
										171577,
										171583
									],
									[
										171654,
										171660
									],
									[
										171672,
										171678
									],
									[
										171700,
										171706
									],
									[
										171780,
										171786
									],
									[
										172106,
										172112
									],
									[
										172310,
										172316
									],
									[
										172581,
										172587
									],
									[
										172709,
										172715
									],
									[
										172907,
										172913
									],
									[
										172944,
										172950
									],
									[
										173130,
										173136
									],
									[
										173443,
										173449
									],
									[
										173523,
										173529
									],
									[
										173620,
										173626
									],
									[
										173638,
										173644
									],
									[
										173825,
										173831
									],
									[
										174034,
										174040
									],
									[
										174221,
										174227
									],
									[
										174502,
										174508
									],
									[
										174681,
										174687
									],
									[
										175009,
										175015
									],
									[
										175077,
										175083
									],
									[
										175258,
										175264
									],
									[
										175536,
										175542
									],
									[
										175622,
										175628
									],
									[
										175872,
										175878
									],
									[
										176023,
										176029
									],
									[
										176354,
										176360
									],
									[
										176419,
										176425
									],
									[
										176592,
										176598
									],
									[
										176658,
										176664
									],
									[
										176931,
										176937
									],
									[
										177003,
										177009
									],
									[
										177072,
										177078
									],
									[
										177146,
										177152
									],
									[
										177223,
										177229
									],
									[
										177295,
										177301
									],
									[
										177358,
										177364
									],
									[
										177439,
										177445
									],
									[
										177530,
										177536
									],
									[
										177621,
										177627
									],
									[
										177709,
										177715
									],
									[
										177874,
										177880
									],
									[
										177960,
										177966
									],
									[
										178053,
										178059
									],
									[
										178143,
										178149
									],
									[
										178239,
										178245
									],
									[
										178342,
										178348
									],
									[
										178513,
										178519
									],
									[
										178562,
										178568
									],
									[
										178721,
										178727
									],
									[
										178802,
										178808
									],
									[
										178914,
										178920
									],
									[
										179171,
										179177
									],
									[
										179337,
										179343
									],
									[
										179648,
										179654
									],
									[
										179760,
										179766
									],
									[
										179947,
										179953
									],
									[
										180188,
										180194
									],
									[
										180402,
										180408
									],
									[
										180658,
										180664
									],
									[
										180938,
										180944
									],
									[
										181154,
										181160
									],
									[
										181360,
										181366
									],
									[
										181410,
										181416
									],
									[
										181561,
										181567
									],
									[
										181682,
										181688
									],
									[
										181966,
										181972
									],
									[
										182190,
										182196
									],
									[
										182266,
										182272
									],
									[
										182425,
										182431
									],
									[
										182687,
										182693
									],
									[
										182869,
										182875
									],
									[
										183313,
										183319
									],
									[
										183553,
										183559
									],
									[
										183888,
										183894
									],
									[
										184108,
										184114
									],
									[
										184463,
										184469
									],
									[
										184736,
										184742
									],
									[
										184904,
										184910
									],
									[
										185037,
										185043
									],
									[
										185300,
										185306
									],
									[
										185485,
										185491
									],
									[
										185618,
										185624
									],
									[
										185886,
										185892
									],
									[
										186082,
										186088
									],
									[
										186215,
										186221
									],
									[
										186481,
										186487
									],
									[
										186666,
										186672
									],
									[
										186801,
										186807
									],
									[
										187073,
										187079
									],
									[
										187241,
										187247
									],
									[
										187366,
										187372
									],
									[
										187607,
										187613
									],
									[
										187803,
										187809
									],
									[
										188212,
										188218
									],
									[
										188587,
										188593
									],
									[
										189016,
										189022
									],
									[
										189424,
										189430
									],
									[
										189849,
										189855
									],
									[
										190293,
										190299
									],
									[
										190734,
										190740
									],
									[
										191125,
										191131
									],
									[
										191403,
										191409
									],
									[
										191862,
										191868
									],
									[
										192241,
										192247
									],
									[
										192706,
										192712
									],
									[
										193056,
										193062
									],
									[
										193473,
										193479
									],
									[
										193837,
										193843
									],
									[
										194307,
										194313
									],
									[
										194598,
										194604
									],
									[
										194947,
										194953
									],
									[
										195174,
										195180
									],
									[
										195479,
										195485
									],
									[
										195606,
										195612
									],
									[
										195768,
										195774
									],
									[
										196119,
										196125
									],
									[
										196271,
										196277
									],
									[
										196477,
										196483
									],
									[
										196801,
										196807
									],
									[
										197010,
										197016
									],
									[
										197287,
										197293
									],
									[
										197371,
										197377
									],
									[
										197418,
										197424
									],
									[
										197464,
										197470
									],
									[
										197495,
										197501
									],
									[
										197567,
										197573
									],
									[
										197691,
										197697
									],
									[
										197940,
										197946
									],
									[
										198106,
										198112
									],
									[
										198382,
										198388
									],
									[
										198569,
										198575
									],
									[
										198670,
										198676
									],
									[
										198758,
										198764
									],
									[
										198867,
										198873
									],
									[
										199097,
										199103
									],
									[
										199189,
										199195
									],
									[
										199411,
										199417
									],
									[
										199946,
										199952
									],
									[
										200268,
										200274
									],
									[
										200495,
										200501
									],
									[
										200765,
										200771
									],
									[
										201061,
										201067
									],
									[
										201172,
										201178
									],
									[
										201459,
										201465
									],
									[
										201586,
										201592
									],
									[
										201785,
										201791
									],
									[
										202093,
										202099
									],
									[
										202321,
										202327
									],
									[
										202619,
										202625
									],
									[
										202859,
										202865
									],
									[
										203066,
										203072
									],
									[
										203282,
										203288
									],
									[
										203310,
										203316
									],
									[
										203337,
										203343
									],
									[
										203587,
										203593
									],
									[
										203647,
										203653
									],
									[
										203774,
										203780
									],
									[
										203953,
										203959
									],
									[
										204187,
										204193
									],
									[
										204278,
										204284
									],
									[
										204513,
										204519
									],
									[
										204628,
										204634
									],
									[
										204685,
										204691
									],
									[
										204839,
										204845
									],
									[
										204848,
										204854
									],
									[
										204970,
										204976
									],
									[
										205045,
										205051
									],
									[
										205076,
										205082
									],
									[
										205290,
										205296
									],
									[
										205497,
										205503
									],
									[
										205558,
										205564
									],
									[
										205598,
										205604
									],
									[
										205769,
										205775
									],
									[
										205794,
										205800
									],
									[
										205992,
										205998
									],
									[
										206176,
										206182
									],
									[
										206248,
										206254
									],
									[
										206294,
										206300
									],
									[
										206367,
										206373
									],
									[
										206473,
										206479
									],
									[
										206551,
										206557
									],
									[
										207113,
										207119
									],
									[
										207592,
										207598
									],
									[
										207830,
										207836
									],
									[
										207968,
										207974
									],
									[
										208066,
										208072
									],
									[
										208409,
										208415
									],
									[
										208546,
										208552
									],
									[
										208682,
										208688
									],
									[
										208841,
										208847
									],
									[
										208869,
										208875
									],
									[
										208937,
										208943
									],
									[
										209011,
										209017
									],
									[
										209072,
										209078
									],
									[
										209151,
										209157
									],
									[
										209222,
										209228
									],
									[
										209299,
										209305
									],
									[
										209364,
										209370
									],
									[
										209386,
										209392
									],
									[
										209455,
										209461
									],
									[
										209728,
										209734
									],
									[
										209855,
										209861
									],
									[
										209951,
										209957
									],
									[
										210078,
										210084
									],
									[
										210169,
										210175
									],
									[
										210381,
										210387
									],
									[
										210561,
										210567
									],
									[
										210803,
										210809
									],
									[
										211023,
										211029
									],
									[
										211197,
										211203
									],
									[
										211362,
										211368
									],
									[
										211380,
										211386
									],
									[
										211399,
										211405
									],
									[
										211468,
										211474
									],
									[
										211586,
										211592
									],
									[
										211618,
										211624
									],
									[
										211868,
										211874
									],
									[
										211989,
										211995
									],
									[
										212380,
										212386
									],
									[
										212558,
										212564
									],
									[
										212710,
										212716
									],
									[
										212765,
										212771
									],
									[
										212878,
										212884
									],
									[
										212932,
										212938
									],
									[
										213052,
										213058
									],
									[
										213262,
										213268
									],
									[
										213424,
										213430
									],
									[
										213491,
										213497
									],
									[
										213642,
										213648
									],
									[
										213763,
										213769
									],
									[
										213894,
										213900
									],
									[
										214046,
										214052
									],
									[
										214067,
										214073
									],
									[
										214251,
										214257
									],
									[
										214318,
										214324
									],
									[
										214380,
										214386
									],
									[
										214623,
										214629
									],
									[
										214955,
										214961
									],
									[
										215221,
										215227
									],
									[
										215423,
										215429
									],
									[
										215519,
										215525
									],
									[
										215663,
										215669
									],
									[
										215810,
										215816
									],
									[
										215918,
										215924
									],
									[
										216258,
										216264
									],
									[
										216380,
										216386
									],
									[
										216644,
										216650
									],
									[
										216812,
										216818
									],
									[
										217154,
										217160
									],
									[
										217487,
										217493
									],
									[
										217578,
										217584
									],
									[
										217816,
										217822
									],
									[
										217882,
										217888
									],
									[
										218251,
										218257
									],
									[
										218487,
										218493
									],
									[
										218606,
										218612
									],
									[
										218694,
										218700
									],
									[
										218944,
										218950
									],
									[
										219030,
										219036
									],
									[
										219209,
										219215
									],
									[
										219310,
										219316
									],
									[
										219469,
										219475
									],
									[
										219551,
										219557
									],
									[
										219668,
										219674
									],
									[
										219745,
										219751
									],
									[
										219865,
										219871
									],
									[
										219952,
										219958
									],
									[
										220265,
										220271
									],
									[
										220415,
										220421
									],
									[
										220671,
										220677
									],
									[
										220851,
										220857
									],
									[
										221085,
										221091
									],
									[
										221402,
										221408
									],
									[
										221575,
										221581
									],
									[
										221888,
										221894
									],
									[
										222206,
										222212
									],
									[
										222379,
										222385
									],
									[
										222669,
										222675
									],
									[
										222884,
										222890
									],
									[
										222922,
										222928
									],
									[
										223061,
										223067
									],
									[
										223143,
										223149
									],
									[
										223320,
										223326
									],
									[
										223423,
										223429
									],
									[
										223624,
										223630
									],
									[
										223673,
										223679
									],
									[
										223884,
										223890
									],
									[
										223992,
										223998
									],
									[
										224013,
										224019
									],
									[
										224272,
										224278
									],
									[
										224330,
										224336
									],
									[
										224554,
										224560
									],
									[
										224608,
										224614
									],
									[
										224899,
										224905
									],
									[
										225019,
										225025
									],
									[
										225241,
										225247
									],
									[
										225340,
										225346
									],
									[
										225681,
										225687
									],
									[
										225754,
										225760
									],
									[
										225839,
										225845
									],
									[
										225875,
										225881
									],
									[
										226019,
										226025
									],
									[
										226092,
										226098
									],
									[
										226155,
										226161
									],
									[
										226235,
										226241
									],
									[
										226569,
										226575
									],
									[
										226690,
										226696
									],
									[
										226800,
										226806
									],
									[
										226923,
										226929
									],
									[
										227069,
										227075
									],
									[
										227132,
										227138
									],
									[
										227264,
										227270
									],
									[
										227329,
										227335
									],
									[
										227658,
										227664
									],
									[
										227739,
										227745
									],
									[
										227941,
										227947
									],
									[
										228011,
										228017
									],
									[
										228385,
										228391
									],
									[
										228755,
										228761
									],
									[
										229125,
										229131
									],
									[
										229551,
										229557
									],
									[
										229838,
										229844
									],
									[
										230110,
										230116
									],
									[
										230250,
										230256
									],
									[
										230651,
										230657
									],
									[
										230834,
										230840
									],
									[
										230912,
										230918
									],
									[
										231183,
										231189
									],
									[
										231578,
										231584
									],
									[
										231697,
										231703
									],
									[
										231847,
										231853
									],
									[
										232001,
										232007
									],
									[
										232179,
										232185
									],
									[
										232337,
										232343
									],
									[
										232644,
										232650
									],
									[
										232927,
										232933
									],
									[
										233212,
										233218
									],
									[
										233581,
										233587
									],
									[
										233845,
										233851
									],
									[
										234239,
										234245
									],
									[
										234474,
										234480
									],
									[
										234678,
										234684
									],
									[
										234970,
										234976
									],
									[
										235343,
										235349
									],
									[
										235476,
										235482
									],
									[
										235638,
										235644
									],
									[
										235939,
										235945
									],
									[
										236365,
										236371
									],
									[
										236662,
										236668
									],
									[
										236906,
										236912
									],
									[
										237078,
										237084
									],
									[
										237354,
										237360
									],
									[
										237624,
										237630
									],
									[
										237943,
										237949
									],
									[
										238308,
										238314
									],
									[
										238529,
										238535
									],
									[
										238753,
										238759
									],
									[
										238895,
										238901
									],
									[
										239105,
										239111
									],
									[
										239348,
										239354
									],
									[
										239441,
										239447
									],
									[
										239665,
										239671
									],
									[
										239755,
										239761
									],
									[
										239933,
										239939
									],
									[
										240217,
										240223
									],
									[
										240340,
										240346
									],
									[
										240566,
										240572
									],
									[
										240697,
										240703
									],
									[
										240979,
										240985
									],
									[
										241100,
										241106
									],
									[
										241324,
										241330
									],
									[
										241437,
										241443
									],
									[
										241527,
										241533
									],
									[
										241816,
										241822
									],
									[
										242008,
										242014
									],
									[
										242160,
										242166
									],
									[
										242291,
										242297
									],
									[
										242496,
										242502
									],
									[
										242786,
										242792
									],
									[
										243068,
										243074
									],
									[
										243295,
										243301
									],
									[
										243537,
										243543
									],
									[
										243818,
										243824
									],
									[
										244044,
										244050
									],
									[
										244280,
										244286
									],
									[
										244533,
										244539
									],
									[
										244609,
										244615
									],
									[
										244817,
										244823
									],
									[
										245164,
										245170
									],
									[
										245206,
										245212
									],
									[
										245570,
										245576
									],
									[
										245844,
										245850
									],
									[
										246067,
										246073
									],
									[
										246173,
										246179
									],
									[
										246239,
										246245
									],
									[
										246519,
										246525
									],
									[
										246635,
										246641
									],
									[
										246789,
										246795
									],
									[
										247116,
										247122
									],
									[
										247407,
										247413
									],
									[
										247425,
										247431
									],
									[
										247707,
										247713
									],
									[
										247751,
										247757
									],
									[
										247958,
										247964
									],
									[
										248160,
										248166
									],
									[
										248178,
										248184
									],
									[
										248193,
										248199
									],
									[
										248253,
										248259
									],
									[
										248522,
										248528
									],
									[
										248567,
										248573
									],
									[
										248770,
										248776
									],
									[
										249231,
										249237
									],
									[
										249623,
										249629
									],
									[
										250023,
										250029
									],
									[
										250363,
										250369
									],
									[
										250557,
										250563
									],
									[
										250893,
										250899
									],
									[
										251309,
										251315
									],
									[
										251421,
										251427
									],
									[
										251551,
										251557
									],
									[
										251627,
										251633
									],
									[
										251946,
										251952
									],
									[
										252041,
										252047
									],
									[
										252243,
										252249
									],
									[
										252521,
										252527
									],
									[
										252783,
										252789
									],
									[
										253064,
										253070
									],
									[
										253339,
										253345
									],
									[
										253585,
										253591
									],
									[
										253967,
										253973
									],
									[
										254163,
										254169
									],
									[
										254354,
										254360
									],
									[
										254732,
										254738
									],
									[
										255303,
										255309
									],
									[
										255686,
										255692
									],
									[
										255965,
										255971
									],
									[
										256057,
										256063
									],
									[
										256115,
										256121
									],
									[
										256201,
										256207
									],
									[
										256298,
										256304
									],
									[
										256562,
										256568
									],
									[
										256859,
										256865
									],
									[
										256957,
										256963
									],
									[
										257014,
										257020
									],
									[
										257080,
										257086
									],
									[
										257184,
										257190
									],
									[
										257361,
										257367
									],
									[
										257592,
										257598
									],
									[
										257716,
										257722
									],
									[
										257850,
										257856
									],
									[
										258140,
										258146
									],
									[
										258524,
										258530
									],
									[
										258807,
										258813
									],
									[
										259152,
										259158
									],
									[
										259380,
										259386
									],
									[
										259599,
										259605
									],
									[
										259699,
										259705
									],
									[
										259892,
										259898
									],
									[
										260111,
										260117
									],
									[
										260489,
										260495
									],
									[
										260605,
										260611
									],
									[
										260813,
										260819
									],
									[
										261092,
										261098
									],
									[
										261429,
										261435
									],
									[
										261688,
										261694
									],
									[
										261967,
										261973
									],
									[
										262083,
										262089
									],
									[
										262197,
										262203
									],
									[
										262456,
										262462
									],
									[
										262548,
										262554
									],
									[
										262649,
										262655
									],
									[
										262937,
										262943
									],
									[
										263310,
										263316
									],
									[
										263539,
										263545
									],
									[
										263819,
										263825
									],
									[
										263952,
										263958
									],
									[
										264131,
										264137
									],
									[
										264501,
										264507
									],
									[
										264632,
										264638
									],
									[
										264930,
										264936
									],
									[
										265223,
										265229
									],
									[
										265581,
										265587
									],
									[
										265993,
										265999
									],
									[
										266412,
										266418
									],
									[
										266491,
										266497
									],
									[
										266580,
										266586
									],
									[
										266636,
										266642
									],
									[
										266884,
										266890
									],
									[
										267148,
										267154
									],
									[
										267446,
										267452
									],
									[
										267633,
										267639
									],
									[
										267886,
										267892
									],
									[
										268078,
										268084
									],
									[
										268340,
										268346
									],
									[
										268666,
										268672
									],
									[
										268818,
										268824
									],
									[
										269181,
										269187
									],
									[
										269322,
										269328
									],
									[
										269567,
										269573
									],
									[
										269725,
										269731
									],
									[
										270047,
										270053
									],
									[
										270208,
										270214
									],
									[
										270624,
										270630
									],
									[
										271146,
										271152
									],
									[
										271475,
										271481
									],
									[
										271743,
										271749
									],
									[
										272085,
										272091
									],
									[
										272399,
										272405
									],
									[
										272746,
										272752
									],
									[
										273088,
										273094
									],
									[
										273580,
										273586
									],
									[
										273788,
										273794
									],
									[
										274216,
										274222
									],
									[
										274400,
										274406
									],
									[
										274780,
										274786
									],
									[
										274799,
										274805
									],
									[
										275029,
										275035
									],
									[
										275403,
										275409
									],
									[
										275754,
										275760
									],
									[
										275773,
										275779
									],
									[
										275947,
										275953
									],
									[
										275977,
										275983
									],
									[
										276214,
										276220
									],
									[
										276435,
										276441
									],
									[
										277012,
										277018
									],
									[
										277031,
										277037
									],
									[
										277079,
										277085
									],
									[
										277285,
										277291
									],
									[
										277410,
										277416
									],
									[
										277694,
										277700
									],
									[
										277831,
										277837
									],
									[
										277959,
										277965
									],
									[
										278137,
										278143
									],
									[
										278286,
										278292
									],
									[
										278448,
										278454
									],
									[
										278653,
										278659
									],
									[
										278797,
										278803
									],
									[
										279012,
										279018
									],
									[
										279027,
										279033
									],
									[
										279252,
										279258
									],
									[
										279466,
										279472
									],
									[
										279820,
										279826
									],
									[
										280120,
										280126
									],
									[
										280239,
										280245
									],
									[
										280381,
										280387
									],
									[
										280523,
										280529
									],
									[
										280727,
										280733
									],
									[
										281008,
										281014
									],
									[
										281301,
										281307
									],
									[
										281671,
										281677
									],
									[
										281964,
										281970
									],
									[
										282248,
										282254
									],
									[
										282380,
										282386
									],
									[
										282517,
										282523
									],
									[
										282801,
										282807
									],
									[
										282982,
										282988
									],
									[
										283353,
										283359
									],
									[
										283728,
										283734
									],
									[
										284157,
										284163
									],
									[
										284423,
										284429
									],
									[
										284806,
										284812
									],
									[
										285020,
										285026
									],
									[
										285258,
										285264
									],
									[
										285704,
										285710
									],
									[
										286021,
										286027
									],
									[
										286311,
										286317
									],
									[
										286552,
										286558
									],
									[
										286614,
										286620
									],
									[
										286664,
										286670
									],
									[
										286734,
										286740
									],
									[
										286892,
										286898
									],
									[
										287082,
										287088
									],
									[
										287257,
										287263
									],
									[
										287611,
										287617
									],
									[
										288185,
										288191
									],
									[
										288547,
										288553
									],
									[
										288742,
										288748
									],
									[
										288809,
										288815
									],
									[
										289124,
										289130
									],
									[
										289467,
										289473
									],
									[
										289734,
										289740
									],
									[
										290091,
										290097
									],
									[
										290442,
										290448
									],
									[
										290715,
										290721
									],
									[
										290919,
										290925
									],
									[
										291320,
										291326
									],
									[
										291781,
										291787
									],
									[
										292108,
										292114
									],
									[
										292527,
										292533
									],
									[
										292878,
										292884
									],
									[
										293181,
										293187
									],
									[
										293505,
										293511
									],
									[
										293890,
										293896
									],
									[
										294153,
										294159
									],
									[
										294354,
										294360
									],
									[
										294802,
										294808
									],
									[
										295092,
										295098
									],
									[
										295381,
										295387
									],
									[
										295568,
										295574
									],
									[
										295839,
										295845
									],
									[
										296188,
										296194
									],
									[
										296448,
										296454
									],
									[
										296708,
										296714
									],
									[
										297149,
										297155
									],
									[
										297461,
										297467
									],
									[
										297780,
										297786
									],
									[
										298122,
										298128
									],
									[
										298342,
										298348
									],
									[
										298774,
										298780
									],
									[
										299074,
										299080
									],
									[
										299315,
										299321
									],
									[
										299568,
										299574
									],
									[
										299916,
										299922
									],
									[
										300218,
										300224
									],
									[
										300391,
										300397
									],
									[
										300482,
										300488
									],
									[
										300489,
										300495
									],
									[
										300731,
										300737
									],
									[
										300774,
										300780
									],
									[
										300983,
										300989
									],
									[
										301156,
										301162
									],
									[
										301380,
										301386
									],
									[
										301574,
										301580
									],
									[
										301707,
										301713
									],
									[
										301969,
										301975
									],
									[
										302084,
										302090
									],
									[
										302330,
										302336
									],
									[
										302460,
										302466
									],
									[
										302549,
										302555
									],
									[
										302556,
										302562
									],
									[
										302680,
										302686
									],
									[
										302886,
										302892
									],
									[
										303077,
										303083
									],
									[
										303345,
										303351
									],
									[
										303597,
										303603
									],
									[
										303791,
										303797
									],
									[
										303935,
										303941
									],
									[
										304170,
										304176
									],
									[
										304347,
										304353
									],
									[
										304537,
										304543
									],
									[
										304590,
										304596
									],
									[
										304767,
										304773
									],
									[
										304881,
										304887
									],
									[
										305124,
										305130
									],
									[
										305306,
										305312
									],
									[
										305412,
										305418
									],
									[
										305419,
										305425
									],
									[
										305581,
										305587
									],
									[
										305765,
										305771
									],
									[
										305968,
										305974
									],
									[
										306175,
										306181
									],
									[
										306345,
										306351
									],
									[
										306592,
										306598
									],
									[
										306829,
										306835
									],
									[
										307031,
										307037
									],
									[
										307257,
										307263
									],
									[
										307518,
										307524
									],
									[
										307772,
										307778
									],
									[
										307928,
										307934
									],
									[
										308205,
										308211
									],
									[
										308385,
										308391
									],
									[
										308407,
										308413
									],
									[
										308414,
										308420
									],
									[
										308567,
										308573
									],
									[
										308728,
										308734
									],
									[
										308917,
										308923
									],
									[
										309151,
										309157
									],
									[
										309355,
										309361
									],
									[
										309593,
										309599
									],
									[
										309771,
										309777
									],
									[
										309980,
										309986
									],
									[
										310217,
										310223
									],
									[
										310310,
										310316
									],
									[
										310519,
										310525
									],
									[
										310655,
										310661
									],
									[
										310677,
										310683
									],
									[
										310684,
										310690
									],
									[
										310961,
										310967
									],
									[
										311089,
										311095
									],
									[
										311253,
										311259
									],
									[
										311428,
										311434
									],
									[
										311648,
										311654
									],
									[
										311886,
										311892
									],
									[
										311979,
										311985
									],
									[
										312174,
										312180
									],
									[
										312351,
										312357
									],
									[
										312441,
										312447
									],
									[
										312448,
										312454
									],
									[
										312667,
										312673
									],
									[
										312778,
										312784
									],
									[
										312989,
										312995
									],
									[
										313180,
										313186
									],
									[
										313330,
										313336
									],
									[
										313461,
										313467
									],
									[
										313718,
										313724
									],
									[
										313882,
										313888
									],
									[
										314150,
										314156
									],
									[
										314280,
										314286
									],
									[
										314393,
										314399
									],
									[
										314541,
										314547
									],
									[
										314715,
										314721
									],
									[
										315048,
										315054
									],
									[
										315325,
										315331
									],
									[
										315685,
										315691
									],
									[
										315878,
										315884
									],
									[
										316026,
										316032
									],
									[
										316295,
										316301
									],
									[
										316500,
										316506
									],
									[
										316647,
										316653
									],
									[
										316804,
										316810
									],
									[
										316925,
										316931
									],
									[
										317049,
										317055
									],
									[
										317189,
										317195
									],
									[
										317367,
										317373
									],
									[
										317557,
										317563
									],
									[
										317753,
										317759
									],
									[
										317899,
										317905
									],
									[
										318140,
										318146
									],
									[
										318331,
										318337
									],
									[
										318500,
										318506
									],
									[
										318656,
										318662
									],
									[
										318885,
										318891
									],
									[
										319014,
										319020
									],
									[
										319231,
										319237
									],
									[
										319355,
										319361
									],
									[
										319587,
										319593
									],
									[
										319807,
										319813
									],
									[
										320184,
										320190
									],
									[
										320453,
										320459
									],
									[
										320594,
										320600
									],
									[
										320674,
										320680
									],
									[
										320855,
										320861
									],
									[
										321059,
										321065
									],
									[
										321275,
										321281
									],
									[
										321432,
										321438
									],
									[
										321669,
										321675
									],
									[
										321864,
										321870
									],
									[
										321960,
										321966
									],
									[
										322086,
										322092
									],
									[
										322308,
										322314
									],
									[
										322472,
										322478
									],
									[
										322494,
										322500
									],
									[
										322501,
										322507
									],
									[
										322544,
										322550
									],
									[
										322670,
										322676
									],
									[
										322852,
										322858
									],
									[
										323005,
										323011
									],
									[
										323162,
										323168
									],
									[
										323361,
										323367
									],
									[
										323597,
										323603
									],
									[
										323701,
										323707
									],
									[
										323918,
										323924
									],
									[
										324118,
										324124
									],
									[
										324356,
										324362
									],
									[
										324616,
										324622
									],
									[
										324984,
										324990
									],
									[
										325164,
										325170
									],
									[
										325211,
										325217
									],
									[
										325569,
										325575
									],
									[
										325615,
										325621
									],
									[
										325952,
										325958
									],
									[
										326015,
										326021
									],
									[
										326389,
										326395
									],
									[
										326621,
										326627
									],
									[
										326871,
										326877
									],
									[
										327179,
										327185
									],
									[
										327476,
										327482
									],
									[
										327776,
										327782
									],
									[
										328079,
										328085
									],
									[
										328381,
										328387
									],
									[
										328605,
										328611
									],
									[
										328683,
										328689
									],
									[
										328782,
										328788
									],
									[
										328852,
										328858
									],
									[
										328919,
										328925
									],
									[
										328990,
										328996
									],
									[
										329055,
										329061
									],
									[
										329315,
										329321
									],
									[
										329619,
										329625
									],
									[
										330022,
										330028
									],
									[
										330416,
										330422
									],
									[
										330646,
										330652
									],
									[
										330743,
										330749
									],
									[
										330954,
										330960
									],
									[
										331051,
										331057
									],
									[
										331400,
										331406
									],
									[
										331794,
										331800
									],
									[
										331841,
										331847
									],
									[
										332415,
										332421
									],
									[
										332596,
										332602
									],
									[
										332633,
										332639
									],
									[
										332750,
										332756
									],
									[
										332901,
										332907
									],
									[
										333209,
										333215
									],
									[
										333550,
										333556
									],
									[
										333887,
										333893
									],
									[
										334014,
										334020
									],
									[
										334202,
										334208
									],
									[
										334344,
										334350
									],
									[
										334488,
										334494
									],
									[
										334606,
										334612
									],
									[
										334897,
										334903
									],
									[
										335184,
										335190
									],
									[
										335212,
										335218
									],
									[
										335636,
										335642
									],
									[
										335988,
										335994
									],
									[
										336242,
										336248
									],
									[
										336481,
										336487
									],
									[
										336524,
										336530
									],
									[
										337031,
										337037
									],
									[
										337071,
										337077
									],
									[
										337465,
										337471
									],
									[
										337701,
										337707
									],
									[
										337961,
										337967
									],
									[
										337998,
										338004
									],
									[
										338325,
										338331
									],
									[
										338702,
										338708
									],
									[
										338923,
										338929
									],
									[
										339149,
										339155
									],
									[
										339186,
										339192
									],
									[
										339513,
										339519
									],
									[
										339855,
										339861
									],
									[
										340079,
										340085
									],
									[
										340348,
										340354
									],
									[
										340372,
										340378
									],
									[
										340700,
										340706
									],
									[
										340886,
										340892
									],
									[
										341024,
										341030
									],
									[
										341031,
										341037
									],
									[
										341177,
										341183
									],
									[
										341379,
										341385
									],
									[
										341510,
										341516
									],
									[
										341517,
										341523
									],
									[
										341713,
										341719
									],
									[
										341911,
										341917
									],
									[
										342098,
										342104
									],
									[
										342245,
										342251
									],
									[
										342508,
										342514
									],
									[
										342679,
										342685
									],
									[
										342827,
										342833
									],
									[
										343019,
										343025
									],
									[
										343172,
										343178
									],
									[
										343330,
										343336
									],
									[
										343648,
										343654
									],
									[
										343877,
										343883
									],
									[
										343950,
										343956
									],
									[
										344114,
										344120
									],
									[
										344305,
										344311
									],
									[
										344378,
										344384
									],
									[
										344584,
										344590
									],
									[
										344754,
										344760
									],
									[
										344827,
										344833
									],
									[
										344994,
										345000
									],
									[
										345120,
										345126
									],
									[
										345193,
										345199
									],
									[
										345345,
										345351
									],
									[
										345580,
										345586
									],
									[
										345777,
										345783
									],
									[
										345937,
										345943
									],
									[
										346151,
										346157
									],
									[
										346333,
										346339
									],
									[
										346406,
										346412
									],
									[
										346490,
										346496
									],
									[
										346715,
										346721
									],
									[
										346912,
										346918
									],
									[
										347074,
										347080
									],
									[
										347288,
										347294
									],
									[
										347477,
										347483
									],
									[
										347542,
										347548
									],
									[
										347677,
										347683
									],
									[
										347895,
										347901
									],
									[
										348098,
										348104
									],
									[
										348171,
										348177
									],
									[
										348314,
										348320
									],
									[
										348578,
										348584
									],
									[
										348776,
										348782
									],
									[
										348847,
										348853
									],
									[
										348999,
										349005
									],
									[
										349268,
										349274
									],
									[
										349486,
										349492
									],
									[
										349751,
										349757
									],
									[
										349978,
										349984
									],
									[
										350031,
										350037
									],
									[
										350064,
										350070
									],
									[
										350104,
										350110
									],
									[
										350265,
										350271
									],
									[
										350318,
										350324
									],
									[
										350351,
										350357
									],
									[
										350398,
										350404
									],
									[
										350545,
										350551
									],
									[
										350598,
										350604
									],
									[
										350631,
										350637
									],
									[
										350678,
										350684
									],
									[
										350794,
										350800
									],
									[
										350846,
										350852
									],
									[
										350977,
										350983
									],
									[
										351052,
										351058
									],
									[
										351189,
										351195
									],
									[
										351379,
										351385
									],
									[
										351575,
										351581
									],
									[
										351641,
										351647
									],
									[
										351791,
										351797
									],
									[
										351987,
										351993
									],
									[
										352155,
										352161
									],
									[
										352165,
										352171
									],
									[
										352198,
										352204
									],
									[
										352231,
										352237
									],
									[
										352404,
										352410
									],
									[
										352417,
										352423
									],
									[
										352623,
										352629
									],
									[
										352828,
										352834
									],
									[
										353065,
										353071
									],
									[
										353293,
										353299
									],
									[
										353494,
										353500
									],
									[
										353501,
										353507
									],
									[
										353786,
										353792
									],
									[
										354092,
										354098
									],
									[
										354342,
										354348
									],
									[
										354600,
										354606
									],
									[
										354794,
										354800
									],
									[
										355098,
										355104
									],
									[
										355354,
										355360
									],
									[
										355514,
										355520
									],
									[
										355780,
										355786
									],
									[
										355945,
										355951
									],
									[
										356038,
										356044
									],
									[
										356045,
										356051
									],
									[
										356250,
										356256
									],
									[
										356436,
										356442
									],
									[
										356794,
										356800
									],
									[
										357051,
										357057
									],
									[
										357098,
										357104
									],
									[
										357336,
										357342
									],
									[
										357544,
										357550
									],
									[
										357591,
										357597
									],
									[
										357828,
										357834
									],
									[
										358070,
										358076
									],
									[
										358186,
										358192
									],
									[
										358445,
										358451
									],
									[
										358616,
										358622
									],
									[
										358685,
										358691
									],
									[
										358692,
										358698
									],
									[
										358886,
										358892
									],
									[
										359020,
										359026
									],
									[
										359260,
										359266
									],
									[
										359460,
										359466
									],
									[
										359700,
										359706
									],
									[
										359881,
										359887
									],
									[
										360029,
										360035
									],
									[
										360239,
										360245
									],
									[
										360576,
										360582
									],
									[
										360712,
										360718
									],
									[
										360835,
										360841
									],
									[
										361054,
										361060
									],
									[
										361259,
										361265
									],
									[
										361335,
										361341
									],
									[
										361554,
										361560
									],
									[
										361709,
										361715
									],
									[
										361718,
										361724
									],
									[
										361810,
										361816
									],
									[
										361967,
										361973
									],
									[
										362222,
										362228
									],
									[
										362461,
										362467
									],
									[
										362708,
										362714
									],
									[
										362952,
										362958
									],
									[
										363141,
										363147
									],
									[
										363250,
										363256
									],
									[
										363257,
										363263
									],
									[
										363488,
										363494
									],
									[
										363693,
										363699
									],
									[
										363942,
										363948
									],
									[
										364164,
										364170
									],
									[
										364403,
										364409
									],
									[
										364616,
										364622
									],
									[
										364872,
										364878
									],
									[
										365086,
										365092
									],
									[
										365303,
										365309
									],
									[
										365494,
										365500
									],
									[
										365741,
										365747
									],
									[
										365937,
										365943
									],
									[
										366097,
										366103
									],
									[
										366299,
										366305
									],
									[
										366464,
										366470
									],
									[
										366797,
										366803
									],
									[
										367024,
										367030
									],
									[
										367148,
										367154
									],
									[
										367345,
										367351
									],
									[
										367528,
										367534
									],
									[
										367633,
										367639
									],
									[
										367640,
										367646
									],
									[
										367842,
										367848
									],
									[
										368020,
										368026
									],
									[
										368283,
										368289
									],
									[
										368509,
										368515
									],
									[
										368745,
										368751
									],
									[
										368867,
										368873
									],
									[
										369080,
										369086
									],
									[
										369268,
										369274
									],
									[
										369450,
										369456
									],
									[
										369504,
										369510
									],
									[
										369727,
										369733
									],
									[
										369894,
										369900
									],
									[
										370120,
										370126
									],
									[
										370291,
										370297
									],
									[
										370442,
										370448
									],
									[
										370658,
										370664
									],
									[
										370855,
										370861
									],
									[
										371014,
										371020
									],
									[
										371195,
										371201
									],
									[
										371359,
										371365
									],
									[
										371502,
										371508
									],
									[
										371652,
										371658
									],
									[
										371825,
										371831
									],
									[
										371886,
										371892
									],
									[
										371893,
										371899
									],
									[
										372054,
										372060
									],
									[
										372205,
										372211
									],
									[
										372366,
										372372
									],
									[
										372544,
										372550
									],
									[
										372840,
										372846
									],
									[
										373049,
										373055
									],
									[
										373324,
										373330
									],
									[
										373543,
										373549
									],
									[
										373748,
										373754
									],
									[
										373928,
										373934
									],
									[
										374102,
										374108
									],
									[
										374339,
										374345
									],
									[
										374541,
										374547
									],
									[
										374778,
										374784
									],
									[
										374992,
										374998
									],
									[
										375228,
										375234
									],
									[
										375465,
										375471
									],
									[
										375678,
										375684
									],
									[
										375873,
										375879
									],
									[
										376050,
										376056
									],
									[
										376253,
										376259
									],
									[
										376456,
										376462
									],
									[
										376571,
										376577
									],
									[
										376698,
										376704
									],
									[
										376866,
										376872
									],
									[
										376993,
										376999
									],
									[
										377000,
										377006
									],
									[
										377142,
										377148
									],
									[
										377241,
										377247
									],
									[
										377371,
										377377
									],
									[
										377548,
										377554
									],
									[
										377733,
										377739
									],
									[
										377843,
										377849
									],
									[
										378081,
										378087
									],
									[
										378265,
										378271
									],
									[
										378494,
										378500
									],
									[
										378695,
										378701
									],
									[
										378924,
										378930
									],
									[
										379122,
										379128
									],
									[
										379262,
										379268
									],
									[
										379269,
										379275
									],
									[
										379404,
										379410
									],
									[
										379558,
										379564
									],
									[
										379709,
										379715
									],
									[
										379928,
										379934
									],
									[
										380100,
										380106
									],
									[
										380260,
										380266
									],
									[
										380514,
										380520
									],
									[
										380523,
										380529
									],
									[
										380655,
										380661
									],
									[
										381084,
										381090
									],
									[
										381439,
										381445
									],
									[
										381897,
										381903
									],
									[
										382242,
										382248
									],
									[
										382525,
										382531
									],
									[
										382859,
										382865
									],
									[
										382934,
										382940
									],
									[
										383326,
										383332
									],
									[
										383433,
										383439
									],
									[
										383782,
										383788
									],
									[
										384086,
										384092
									],
									[
										384324,
										384330
									],
									[
										384551,
										384557
									],
									[
										384729,
										384735
									],
									[
										385002,
										385008
									],
									[
										385229,
										385235
									],
									[
										385407,
										385413
									],
									[
										385804,
										385810
									],
									[
										386244,
										386250
									],
									[
										386513,
										386519
									],
									[
										386849,
										386855
									],
									[
										387186,
										387192
									],
									[
										387384,
										387390
									],
									[
										387637,
										387643
									],
									[
										387666,
										387672
									],
									[
										388192,
										388198
									],
									[
										388534,
										388540
									],
									[
										388827,
										388833
									],
									[
										388997,
										389003
									],
									[
										389080,
										389086
									],
									[
										389132,
										389138
									],
									[
										389262,
										389268
									],
									[
										389322,
										389328
									],
									[
										389636,
										389642
									],
									[
										389715,
										389721
									],
									[
										389756,
										389762
									],
									[
										389977,
										389983
									],
									[
										390056,
										390062
									],
									[
										390097,
										390103
									],
									[
										390240,
										390246
									],
									[
										390601,
										390607
									],
									[
										390758,
										390764
									],
									[
										390869,
										390875
									],
									[
										391324,
										391330
									],
									[
										391709,
										391715
									],
									[
										391929,
										391935
									],
									[
										391966,
										391972
									],
									[
										392015,
										392021
									],
									[
										392236,
										392242
									],
									[
										392380,
										392386
									],
									[
										392769,
										392775
									],
									[
										393045,
										393051
									],
									[
										393264,
										393270
									],
									[
										393695,
										393701
									],
									[
										393953,
										393959
									],
									[
										394280,
										394286
									],
									[
										394591,
										394597
									],
									[
										394783,
										394789
									],
									[
										394980,
										394986
									],
									[
										395028,
										395034
									],
									[
										395096,
										395102
									],
									[
										395489,
										395495
									],
									[
										395793,
										395799
									],
									[
										395910,
										395916
									],
									[
										396058,
										396064
									],
									[
										396216,
										396222
									],
									[
										396465,
										396471
									],
									[
										396687,
										396693
									],
									[
										397056,
										397062
									],
									[
										397081,
										397087
									],
									[
										397136,
										397142
									],
									[
										397163,
										397169
									],
									[
										397220,
										397226
									],
									[
										397247,
										397253
									],
									[
										397646,
										397652
									],
									[
										397891,
										397897
									],
									[
										398107,
										398113
									],
									[
										398422,
										398428
									],
									[
										398741,
										398747
									],
									[
										399140,
										399152
									],
									[
										399546,
										399558
									],
									[
										399806,
										399818
									],
									[
										400015,
										400027
									],
									[
										400450,
										400462
									],
									[
										400856,
										400868
									],
									[
										401116,
										401128
									],
									[
										401325,
										401337
									],
									[
										401762,
										401774
									],
									[
										402168,
										402180
									],
									[
										402428,
										402440
									],
									[
										402637,
										402649
									],
									[
										403072,
										403084
									],
									[
										403478,
										403490
									],
									[
										403738,
										403750
									],
									[
										403947,
										403959
									],
									[
										404372,
										404384
									],
									[
										404811,
										404823
									],
									[
										405081,
										405093
									],
									[
										405290,
										405302
									],
									[
										405710,
										405730
									],
									[
										406077,
										406097
									],
									[
										406441,
										406461
									],
									[
										406769,
										406789
									],
									[
										407246,
										407266
									],
									[
										407613,
										407633
									],
									[
										407977,
										407997
									],
									[
										408338,
										408358
									],
									[
										408825,
										408845
									],
									[
										409193,
										409213
									],
									[
										409560,
										409580
									],
									[
										409921,
										409941
									],
									[
										410408,
										410428
									],
									[
										410776,
										410796
									],
									[
										411143,
										411163
									],
									[
										411504,
										411524
									],
									[
										411991,
										412011
									],
									[
										412359,
										412379
									],
									[
										412726,
										412746
									],
									[
										413087,
										413107
									],
									[
										413544,
										413557
									],
									[
										413798,
										413811
									],
									[
										414246,
										414258
									],
									[
										414457,
										414469
									],
									[
										414697,
										414709
									],
									[
										415075,
										415087
									],
									[
										415243,
										415255
									],
									[
										415490,
										415502
									],
									[
										415850,
										415862
									],
									[
										416057,
										416069
									],
									[
										416266,
										416278
									],
									[
										416525,
										416537
									],
									[
										416655,
										416667
									],
									[
										416946,
										416958
									],
									[
										417325,
										417337
									],
									[
										417340,
										417352
									],
									[
										417641,
										417653
									],
									[
										417729,
										417741
									],
									[
										417813,
										417825
									],
									[
										417921,
										417933
									],
									[
										417960,
										417972
									],
									[
										418192,
										418204
									],
									[
										418335,
										418347
									],
									[
										418386,
										418398
									],
									[
										418444,
										418456
									],
									[
										418525,
										418537
									],
									[
										419109,
										419133
									],
									[
										419408,
										419432
									],
									[
										419687,
										419711
									],
									[
										420007,
										420031
									],
									[
										420325,
										420349
									],
									[
										420623,
										420647
									],
									[
										421129,
										421153
									],
									[
										421472,
										421496
									],
									[
										422008,
										422032
									],
									[
										422399,
										422423
									],
									[
										422715,
										422739
									],
									[
										423011,
										423035
									],
									[
										423301,
										423325
									],
									[
										423781,
										423798
									],
									[
										423851,
										423868
									],
									[
										424272,
										424289
									],
									[
										424305,
										424322
									],
									[
										424590,
										424607
									],
									[
										424636,
										424653
									],
									[
										425018,
										425035
									],
									[
										425312,
										425329
									],
									[
										425592,
										425609
									],
									[
										425804,
										425821
									],
									[
										426045,
										426062
									],
									[
										426463,
										426478
									],
									[
										426698,
										426713
									],
									[
										426913,
										426928
									],
									[
										427235,
										427250
									],
									[
										427579,
										427594
									],
									[
										427722,
										427737
									],
									[
										427986,
										428001
									],
									[
										428045,
										428060
									],
									[
										428258,
										428273
									],
									[
										428552,
										428567
									],
									[
										428792,
										428807
									],
									[
										429154,
										429169
									],
									[
										429397,
										429412
									],
									[
										429638,
										429653
									],
									[
										430072,
										430090
									],
									[
										430326,
										430344
									],
									[
										430438,
										430456
									],
									[
										430548,
										430566
									],
									[
										430658,
										430676
									],
									[
										430887,
										430905
									],
									[
										431272,
										431290
									],
									[
										431524,
										431542
									],
									[
										431888,
										431906
									],
									[
										432221,
										432239
									],
									[
										432531,
										432549
									],
									[
										432833,
										432851
									],
									[
										433037,
										433055
									],
									[
										433339,
										433357
									],
									[
										433588,
										433606
									],
									[
										433708,
										433726
									],
									[
										433773,
										433791
									],
									[
										434101,
										434119
									],
									[
										434484,
										434502
									],
									[
										434717,
										434735
									],
									[
										434975,
										434993
									],
									[
										435106,
										435124
									],
									[
										435296,
										435314
									],
									[
										435381,
										435399
									],
									[
										435569,
										435587
									],
									[
										435931,
										435949
									],
									[
										435994,
										436012
									],
									[
										436277,
										436295
									],
									[
										436496,
										436514
									],
									[
										436783,
										436801
									],
									[
										437095,
										437113
									],
									[
										437700,
										437718
									],
									[
										437950,
										437968
									],
									[
										438008,
										438026
									],
									[
										438225,
										438243
									],
									[
										438420,
										438438
									],
									[
										438665,
										438683
									],
									[
										438784,
										438802
									],
									[
										438897,
										438915
									],
									[
										439143,
										439161
									],
									[
										439469,
										439487
									],
									[
										439543,
										439561
									],
									[
										439931,
										439949
									],
									[
										440250,
										440268
									],
									[
										440513,
										440531
									],
									[
										440765,
										440783
									],
									[
										441101,
										441119
									],
									[
										441399,
										441417
									],
									[
										441741,
										441759
									],
									[
										441808,
										441826
									],
									[
										442272,
										442290
									],
									[
										442457,
										442475
									],
									[
										442872,
										442890
									],
									[
										443094,
										443112
									],
									[
										443505,
										443523
									],
									[
										443690,
										443708
									],
									[
										444112,
										444130
									],
									[
										444334,
										444352
									],
									[
										444620,
										444638
									],
									[
										444958,
										444976
									],
									[
										445214,
										445232
									],
									[
										445452,
										445470
									],
									[
										445842,
										445860
									],
									[
										446174,
										446192
									],
									[
										446615,
										446633
									],
									[
										446852,
										446870
									],
									[
										447150,
										447168
									],
									[
										447225,
										447243
									],
									[
										447415,
										447433
									],
									[
										447487,
										447505
									],
									[
										447696,
										447714
									],
									[
										447863,
										447881
									],
									[
										448262,
										448280
									],
									[
										448395,
										448413
									],
									[
										448532,
										448550
									],
									[
										448773,
										448791
									],
									[
										449042,
										449060
									],
									[
										449247,
										449265
									],
									[
										449436,
										449454
									],
									[
										449739,
										449757
									],
									[
										449867,
										449885
									],
									[
										450041,
										450059
									],
									[
										450298,
										450316
									],
									[
										450436,
										450454
									],
									[
										450659,
										450677
									],
									[
										450804,
										450822
									],
									[
										451159,
										451177
									],
									[
										451340,
										451358
									],
									[
										451590,
										451608
									],
									[
										452085,
										452101
									],
									[
										452109,
										452125
									],
									[
										452393,
										452409
									],
									[
										452654,
										452670
									],
									[
										452696,
										452712
									],
									[
										453175,
										453191
									],
									[
										453521,
										453537
									],
									[
										454054,
										454070
									],
									[
										454366,
										454382
									],
									[
										454478,
										454494
									],
									[
										454588,
										454604
									],
									[
										454698,
										454714
									],
									[
										454951,
										454967
									],
									[
										454981,
										454997
									],
									[
										455022,
										455038
									],
									[
										455278,
										455294
									],
									[
										455520,
										455536
									],
									[
										455755,
										455771
									],
									[
										455948,
										455964
									],
									[
										456147,
										456163
									],
									[
										456171,
										456187
									],
									[
										456502,
										456518
									],
									[
										456928,
										456944
									],
									[
										457434,
										457443
									],
									[
										457851,
										457860
									],
									[
										458089,
										458098
									],
									[
										458517,
										458526
									],
									[
										458829,
										458838
									],
									[
										459205,
										459214
									],
									[
										459608,
										459617
									],
									[
										459812,
										459821
									],
									[
										460039,
										460048
									],
									[
										460405,
										460414
									],
									[
										460574,
										460583
									],
									[
										460966,
										460975
									],
									[
										461404,
										461413
									],
									[
										461686,
										461695
									],
									[
										461955,
										461964
									],
									[
										462186,
										462195
									],
									[
										462437,
										462446
									],
									[
										462746,
										462755
									],
									[
										463055,
										463064
									],
									[
										463408,
										463417
									],
									[
										463849,
										463858
									],
									[
										463944,
										463953
									],
									[
										464103,
										464112
									],
									[
										464501,
										464510
									],
									[
										464733,
										464742
									],
									[
										464875,
										464884
									],
									[
										465279,
										465288
									],
									[
										465578,
										465587
									],
									[
										465808,
										465817
									],
									[
										466050,
										466059
									],
									[
										466300,
										466309
									],
									[
										466451,
										466460
									],
									[
										466962,
										466971
									],
									[
										467266,
										467275
									],
									[
										467475,
										467484
									],
									[
										467853,
										467862
									],
									[
										468318,
										468327
									],
									[
										468631,
										468640
									],
									[
										469023,
										469032
									],
									[
										469334,
										469343
									],
									[
										469689,
										469698
									],
									[
										469956,
										469965
									],
									[
										470172,
										470181
									],
									[
										470411,
										470420
									],
									[
										470845,
										470854
									],
									[
										471121,
										471130
									],
									[
										471539,
										471548
									],
									[
										471918,
										471927
									],
									[
										471971,
										471980
									],
									[
										472075,
										472084
									],
									[
										472349,
										472358
									],
									[
										472424,
										472433
									],
									[
										472882,
										472891
									],
									[
										472957,
										472966
									],
									[
										473159,
										473168
									],
									[
										473507,
										473516
									],
									[
										473536,
										473545
									],
									[
										473718,
										473727
									],
									[
										473758,
										473767
									],
									[
										474008,
										474017
									],
									[
										474048,
										474057
									],
									[
										474341,
										474350
									],
									[
										474415,
										474424
									],
									[
										474567,
										474576
									],
									[
										474751,
										474760
									],
									[
										474946,
										474955
									],
									[
										475305,
										475314
									],
									[
										475377,
										475386
									],
									[
										475665,
										475674
									],
									[
										475970,
										475979
									],
									[
										476123,
										476132
									],
									[
										476409,
										476418
									],
									[
										476549,
										476558
									],
									[
										476787,
										476796
									],
									[
										476994,
										477003
									],
									[
										477088,
										477097
									],
									[
										477294,
										477303
									],
									[
										477468,
										477477
									],
									[
										477648,
										477657
									],
									[
										477820,
										477829
									],
									[
										478013,
										478022
									],
									[
										478260,
										478269
									],
									[
										478677,
										478686
									],
									[
										478716,
										478725
									],
									[
										479309,
										479318
									],
									[
										479704,
										479713
									],
									[
										480336,
										480345
									],
									[
										481475,
										481484
									],
									[
										481928,
										481937
									],
									[
										482257,
										482266
									],
									[
										482461,
										482470
									],
									[
										482585,
										482594
									],
									[
										482776,
										482785
									],
									[
										482993,
										483002
									],
									[
										483219,
										483228
									],
									[
										483295,
										483304
									],
									[
										483608,
										483617
									],
									[
										483830,
										483839
									],
									[
										484119,
										484128
									],
									[
										484349,
										484358
									],
									[
										484726,
										484735
									],
									[
										485028,
										485037
									],
									[
										485251,
										485260
									],
									[
										485743,
										485752
									],
									[
										486176,
										486185
									],
									[
										486469,
										486478
									],
									[
										486847,
										486856
									],
									[
										487201,
										487210
									],
									[
										487606,
										487615
									],
									[
										487875,
										487884
									],
									[
										488033,
										488042
									],
									[
										488163,
										488172
									],
									[
										488510,
										488519
									],
									[
										488831,
										488840
									],
									[
										489162,
										489171
									],
									[
										489507,
										489530
									],
									[
										489769,
										489792
									],
									[
										489989,
										490012
									],
									[
										490294,
										490317
									],
									[
										490772,
										490789
									],
									[
										490798,
										490815
									],
									[
										491001,
										491018
									],
									[
										491189,
										491206
									],
									[
										491217,
										491234
									],
									[
										491279,
										491296
									],
									[
										491526,
										491543
									],
									[
										491555,
										491572
									],
									[
										491758,
										491775
									],
									[
										491959,
										491976
									],
									[
										491988,
										492005
									],
									[
										492156,
										492173
									],
									[
										492345,
										492362
									],
									[
										492373,
										492390
									],
									[
										492465,
										492482
									],
									[
										492698,
										492715
									],
									[
										492908,
										492925
									],
									[
										493421,
										493431
									],
									[
										493536,
										493546
									],
									[
										493726,
										493736
									],
									[
										494115,
										494125
									],
									[
										494230,
										494240
									],
									[
										494623,
										494644
									],
									[
										494934,
										494955
									],
									[
										494985,
										495006
									],
									[
										495230,
										495251
									],
									[
										495279,
										495300
									],
									[
										495324,
										495345
									],
									[
										495364,
										495385
									],
									[
										495410,
										495431
									],
									[
										495466,
										495487
									],
									[
										495507,
										495528
									],
									[
										495754,
										495775
									],
									[
										495809,
										495830
									],
									[
										495854,
										495875
									],
									[
										495914,
										495935
									],
									[
										495961,
										495982
									],
									[
										496009,
										496030
									],
									[
										496060,
										496081
									],
									[
										496110,
										496131
									],
									[
										496154,
										496175
									],
									[
										496203,
										496224
									],
									[
										496585,
										496606
									],
									[
										496640,
										496661
									],
									[
										496688,
										496709
									],
									[
										496739,
										496760
									],
									[
										497105,
										497126
									],
									[
										497160,
										497181
									],
									[
										497208,
										497229
									],
									[
										497259,
										497280
									],
									[
										497639,
										497660
									],
									[
										497694,
										497715
									],
									[
										497742,
										497763
									],
									[
										497800,
										497821
									],
									[
										498221,
										498242
									],
									[
										498269,
										498290
									],
									[
										498326,
										498347
									],
									[
										498849,
										498870
									],
									[
										498897,
										498918
									],
									[
										498954,
										498975
									],
									[
										499659,
										499670
									],
									[
										499873,
										499884
									],
									[
										500315,
										500324
									],
									[
										500752,
										500761
									]
								],
								"scope": ""
							}
						},
						"selection":
						[
							[
								500321,
								500321
							]
						],
						"settings":
						{
							"detect_indentation": false,
							"line_numbers": false,
							"output_tag": 53,
							"result_base_dir": "",
							"result_file_regex": "^([^ \t].*):$",
							"result_line_regex": "^ +([0-9]+):",
							"scroll_past_end": true,
							"syntax": "Packages/Default/Find Results.hidden-tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 191675.0,
						"zoom_level": 1.0
					},
					"stack_index": 23,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "src/Falcor/Core/API/Vulkan/VkResource.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1884,
						"regions":
						{
						},
						"selection":
						[
							[
								1754,
								1754
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 41,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "src/Mogwai/Data/ForwardRenderer.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1872,
						"regions":
						{
						},
						"selection":
						[
							[
								1872,
								1872
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 333,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "src/Mogwai/Data/BSDFViewer.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 634,
						"regions":
						{
						},
						"selection":
						[
							[
								156,
								156
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 334,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "third_party/slang/external/glslang/glslang/Include/BaseTypes.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 18643,
						"regions":
						{
						},
						"selection":
						[
							[
								18403,
								18403
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 8214.0,
						"zoom_level": 1.0
					},
					"stack_index": 347,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "third_party/slang/external/glslang/glslang/MachineIndependent/Initialize.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 477356,
						"regions":
						{
						},
						"selection":
						[
							[
								383248,
								383248
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 141562.0,
						"zoom_level": 1.0
					},
					"stack_index": 348,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "src/Falcor/Scene/Raster.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4526,
						"regions":
						{
						},
						"selection":
						[
							[
								2674,
								2674
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1173.0,
						"zoom_level": 1.0
					},
					"stack_index": 337,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "src/RenderPasses/GBuffer/GBuffer/GBufferRaster.3d.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7187,
						"regions":
						{
						},
						"selection":
						[
							[
								5949,
								5949
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 328,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "src/Falcor/Scene/ShadingData.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15181,
						"regions":
						{
						},
						"selection":
						[
							[
								2978,
								2978
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 510.0,
						"zoom_level": 1.0
					},
					"stack_index": 338,
					"type": "text"
				},
				{
					"buffer": 10,
					"file": "src/RenderPasses/Antialiasing/TAA/TAA.ps.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5743,
						"regions":
						{
						},
						"selection":
						[
							[
								1764,
								1764
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 346,
					"type": "text"
				},
				{
					"buffer": 11,
					"file": "src/Falcor/Experimental/Scene/Lights/LightBVH.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 18635,
						"regions":
						{
						},
						"selection":
						[
							[
								2197,
								2197
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 160,
					"type": "text"
				},
				{
					"buffer": 12,
					"file": "src/Falcor/Experimental/Scene/Lights/LightBVHBuilder.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11295,
						"regions":
						{
						},
						"selection":
						[
							[
								11255,
								11255
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 393.0,
						"zoom_level": 1.0
					},
					"stack_index": 162,
					"type": "text"
				},
				{
					"buffer": 13,
					"file": "src/Falcor/Experimental/Scene/Lights/LightBVHBuilder.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 41661,
						"regions":
						{
						},
						"selection":
						[
							[
								9495,
								9495
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2703.0,
						"zoom_level": 1.0
					},
					"stack_index": 159,
					"type": "text"
				},
				{
					"buffer": 14,
					"file": "src/Falcor/Experimental/Scene/Lights/LightBVH.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 12420,
						"regions":
						{
						},
						"selection":
						[
							[
								5412,
								5412
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1530.0,
						"zoom_level": 1.0
					},
					"stack_index": 161,
					"type": "text"
				},
				{
					"buffer": 15,
					"file": "src/Falcor/Utils/Algorithm/ParallelReduction.ps.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4191,
						"regions":
						{
						},
						"selection":
						[
							[
								1791,
								1791
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 367,
					"type": "text"
				},
				{
					"buffer": 16,
					"file": "src/RenderPasses/BSDFViewer/BSDFViewerParams.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6511,
						"regions":
						{
						},
						"selection":
						[
							[
								6078,
								6078
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1400.0,
						"zoom_level": 1.0
					},
					"stack_index": 343,
					"type": "text"
				},
				{
					"buffer": 17,
					"file": "third_party/slang/external/glslang/glslang/MachineIndependent/ParseHelper.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 364782,
						"regions":
						{
						},
						"selection":
						[
							[
								97986,
								97986
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 35727.0,
						"zoom_level": 1.0
					},
					"stack_index": 372,
					"type": "text"
				},
				{
					"buffer": 18,
					"file": "third_party/slang/external/glslang/SPIRV/SpvBuilder.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 105150,
						"regions":
						{
						},
						"selection":
						[
							[
								1975,
								1975
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 734.0,
						"zoom_level": 1.0
					},
					"stack_index": 369,
					"type": "text"
				},
				{
					"buffer": 19,
					"file": "third_party/slang/source/slang/slang-ir.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 150177,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 14249.0,
						"zoom_level": 1.0
					},
					"stack_index": 371,
					"type": "text"
				},
				{
					"buffer": 20,
					"file": "third_party/slang/external/glslang/SPIRV/SpvBuilder.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 35460,
						"regions":
						{
						},
						"selection":
						[
							[
								2248,
								2248
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 547.0,
						"zoom_level": 1.0
					},
					"stack_index": 370,
					"type": "text"
				},
				{
					"buffer": 21,
					"file": "third_party/slang/source/slang-glslang/slang-glslang.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 18679,
						"regions":
						{
						},
						"selection":
						[
							[
								9729,
								9729
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3760.0,
						"zoom_level": 1.0
					},
					"stack_index": 374,
					"type": "text"
				},
				{
					"buffer": 22,
					"file": "third_party/slang/external/spirv-tools/source/spirv_target_env.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10524,
						"regions":
						{
						},
						"selection":
						[
							[
								6159,
								6159
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2145.0,
						"zoom_level": 1.0
					},
					"stack_index": 375,
					"type": "text"
				},
				{
					"buffer": 23,
					"file": "third_party/slang/external/spirv-tools/CHANGES",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 47890,
						"regions":
						{
						},
						"selection":
						[
							[
								26053,
								26053
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 3,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 969.0,
						"zoom_level": 1.0
					},
					"stack_index": 376,
					"type": "text"
				},
				{
					"buffer": 24,
					"file": "src/Falcor/Scene/SceneBuilder.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 23587,
						"regions":
						{
						},
						"selection":
						[
							[
								20564,
								20564
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 6175.0,
						"zoom_level": 1.0
					},
					"stack_index": 204,
					"type": "text"
				},
				{
					"buffer": 25,
					"file": "src/Falcor/Scene/SceneTypes.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5249,
						"regions":
						{
						},
						"selection":
						[
							[
								5227,
								5227
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1842.0,
						"zoom_level": 1.0
					},
					"stack_index": 336,
					"type": "text"
				},
				{
					"buffer": 26,
					"file": "third_party/slang/source/slang/slang-type-layout.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 149248,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3250.0,
						"zoom_level": 1.0
					},
					"stack_index": 382,
					"type": "text"
				},
				{
					"buffer": 27,
					"file": "third_party/slang/source/slang/slang-type-layout.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 34158,
						"regions":
						{
						},
						"selection":
						[
							[
								4752,
								4752
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 7568.0,
						"zoom_level": 1.0
					},
					"stack_index": 381,
					"type": "text"
				},
				{
					"buffer": 28,
					"file": "third_party/slang/slang.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 132132,
						"regions":
						{
						},
						"selection":
						[
							[
								14421,
								14421
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1367.0,
						"zoom_level": 1.0
					},
					"stack_index": 377,
					"type": "text"
				},
				{
					"buffer": 29,
					"file": "third_party/slang/external/glm/test/core/core_type_aligned.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5440,
						"regions":
						{
						},
						"selection":
						[
							[
								1764,
								1764
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 612.0,
						"zoom_level": 1.0
					},
					"stack_index": 383,
					"type": "text"
				},
				{
					"buffer": 30,
					"file": "src/Falcor/Core/API/Formats.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 19719,
						"regions":
						{
						},
						"selection":
						[
							[
								1805,
								1805
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 180.0,
						"zoom_level": 1.0
					},
					"stack_index": 364,
					"type": "text"
				},
				{
					"buffer": 31,
					"file": "third_party/slang/external/glm/glm/gtx/compatibility.hpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14979,
						"regions":
						{
						},
						"selection":
						[
							[
								452,
								452
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 395,
					"type": "text"
				},
				{
					"buffer": 32,
					"file": "src/Falcor/Core/API/Vulkan/VKFormats.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10446,
						"regions":
						{
						},
						"selection":
						[
							[
								8644,
								8644
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1346.0,
						"zoom_level": 1.0
					},
					"stack_index": 270,
					"type": "text"
				},
				{
					"buffer": 33,
					"file": "third_party/slang/external/glslang/glslang/Include/intermediate.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 54763,
						"regions":
						{
						},
						"selection":
						[
							[
								25731,
								25731
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 16441.0,
						"zoom_level": 1.0
					},
					"stack_index": 399,
					"type": "text"
				},
				{
					"buffer": 34,
					"file": "third_party/slang/docs/language-reference/04-types.md",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14365,
						"regions":
						{
						},
						"selection":
						[
							[
								1184,
								1184
							]
						],
						"settings":
						{
							"syntax": "Packages/Markdown/Markdown.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 402,
					"type": "text"
				},
				{
					"buffer": 35,
					"file": "third_party/slang/external/glslang/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4705,
						"regions":
						{
						},
						"selection":
						[
							[
								2012,
								2012
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 403,
					"type": "text"
				},
				{
					"buffer": 36,
					"file": "third_party/slang/external/glslang/SPIRV/GlslangToSpv.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 339007,
						"regions":
						{
						},
						"selection":
						[
							[
								1976,
								1976
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 255.0,
						"zoom_level": 1.0
					},
					"stack_index": 404,
					"type": "text"
				},
				{
					"buffer": 37,
					"file": "third_party/slang/external/glslang/Test/100.frag",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4744,
						"regions":
						{
						},
						"selection":
						[
							[
								1633,
								1633
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1683.0,
						"zoom_level": 1.0
					},
					"stack_index": 405,
					"type": "text"
				},
				{
					"buffer": 38,
					"file": "third_party/slang/external/glext.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 811328,
						"regions":
						{
						},
						"selection":
						[
							[
								91506,
								91506
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 29021.0,
						"zoom_level": 1.0
					},
					"stack_index": 406,
					"type": "text"
				},
				{
					"buffer": 39,
					"file": "third_party/slang/docs/wave-intrinsics.md",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13145,
						"regions":
						{
						},
						"selection":
						[
							[
								370,
								370
							]
						],
						"settings":
						{
							"syntax": "Packages/Markdown/Markdown.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4675.0,
						"zoom_level": 1.0
					},
					"stack_index": 373,
					"type": "text"
				},
				{
					"buffer": 40,
					"file": "src/RenderPasses/DebugPasses/InvalidPixelDetectionPass/InvalidPixelDetectionPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4278,
						"regions":
						{
						},
						"selection":
						[
							[
								4017,
								4017
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 243.0,
						"zoom_level": 1.0
					},
					"stack_index": 121,
					"type": "text"
				},
				{
					"buffer": 41,
					"file": "src/Tools/FalcorTest/Tests/Core/RootBufferParamBlockTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8904,
						"regions":
						{
						},
						"selection":
						[
							[
								7978,
								7978
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 328.0,
						"zoom_level": 1.0
					},
					"stack_index": 387,
					"type": "text"
				},
				{
					"buffer": 42,
					"file": "src/Tools/FalcorTest/Tests/Core/RootBufferParamBlockTests.cs.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3086,
						"regions":
						{
						},
						"selection":
						[
							[
								1883,
								1883
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 390,
					"type": "text"
				},
				{
					"buffer": 43,
					"file": "src/Tools/FalcorTest/Tests/Core/ParamBlockDefinition.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2225,
						"regions":
						{
						},
						"selection":
						[
							[
								2107,
								2107
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 391,
					"type": "text"
				},
				{
					"buffer": 44,
					"file": "src/Falcor/Core/Program/ProgramVersion.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8252,
						"regions":
						{
						},
						"selection":
						[
							[
								4136,
								4136
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1125.0,
						"zoom_level": 1.0
					},
					"stack_index": 250,
					"type": "text"
				},
				{
					"buffer": 45,
					"file": "src/Falcor/RenderGraph/RenderGraphIR.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5845,
						"regions":
						{
						},
						"selection":
						[
							[
								2376,
								2376
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 47.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"type": "text"
				},
				{
					"buffer": 46,
					"file": "src/Falcor/RenderGraph/RenderGraphIR.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3409,
						"regions":
						{
						},
						"selection":
						[
							[
								1773,
								1773
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 432.0,
						"zoom_level": 1.0
					},
					"stack_index": 10,
					"type": "text"
				},
				{
					"buffer": 47,
					"file": "src/Falcor/Scene/Importers/AssimpImporter.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 44987,
						"regions":
						{
						},
						"selection":
						[
							[
								40724,
								40724
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 14260.0,
						"zoom_level": 1.0
					},
					"stack_index": 202,
					"type": "text"
				},
				{
					"buffer": 48,
					"file": "src/Falcor/Scene/Importers/AssimpImporter.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2484,
						"regions":
						{
						},
						"selection":
						[
							[
								1819,
								1819
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 178,
					"type": "text"
				},
				{
					"buffer": 49,
					"file": "src/Falcor/Scene/Importers/PythonImporter.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2145,
						"regions":
						{
						},
						"selection":
						[
							[
								1987,
								1987
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 176,
					"type": "text"
				},
				{
					"buffer": 50,
					"file": "src/Falcor/Scene/Camera/Camera.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11607,
						"regions":
						{
						},
						"selection":
						[
							[
								606,
								606
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 170.0,
						"zoom_level": 1.0
					},
					"stack_index": 166,
					"type": "text"
				},
				{
					"buffer": 51,
					"file": "src/Falcor/Utils/Sampling/SampleGenerator.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4312,
						"regions":
						{
						},
						"selection":
						[
							[
								4312,
								4312
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 277.0,
						"zoom_level": 1.0
					},
					"stack_index": 181,
					"type": "text"
				},
				{
					"buffer": 52,
					"file": "src/Falcor/Utils/SampleGenerators/StratifiedSamplePattern.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3466,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 357.0,
						"zoom_level": 1.0
					},
					"stack_index": 193,
					"type": "text"
				},
				{
					"buffer": 53,
					"file": "src/Falcor/Utils/SampleGenerators/HaltonSamplePattern.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3159,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 192,
					"type": "text"
				},
				{
					"buffer": 54,
					"file": "src/Falcor/Utils/SampleGenerators/CPUSampleGenerator.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2791,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 191,
					"type": "text"
				},
				{
					"buffer": 55,
					"file": "src/Falcor/Core/API/GraphicsStateObject.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6433,
						"regions":
						{
						},
						"selection":
						[
							[
								5115,
								5115
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 918.0,
						"zoom_level": 1.0
					},
					"stack_index": 232,
					"type": "text"
				},
				{
					"buffer": 56,
					"file": "src/Falcor/Core/API/GraphicsStateObject.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4274,
						"regions":
						{
						},
						"selection":
						[
							[
								4227,
								4227
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 734.0,
						"zoom_level": 1.0
					},
					"stack_index": 231,
					"type": "text"
				},
				{
					"buffer": 57,
					"file": "src/Falcor/Core/API/Vulkan/VKFbo.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5380,
						"regions":
						{
						},
						"selection":
						[
							[
								2311,
								2311
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1486.0,
						"zoom_level": 1.0
					},
					"stack_index": 47,
					"type": "text"
				},
				{
					"buffer": 58,
					"file": "src/Falcor/Core/API/ComputeStateObject.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3496,
						"regions":
						{
						},
						"selection":
						[
							[
								3496,
								3496
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 530.0,
						"zoom_level": 1.0
					},
					"stack_index": 235,
					"type": "text"
				},
				{
					"buffer": 59,
					"file": "src/Falcor/Experimental/Scene/Lights/EnvProbe.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6616,
						"regions":
						{
						},
						"selection":
						[
							[
								1791,
								1791
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 172,
					"type": "text"
				},
				{
					"buffer": 60,
					"file": "src/Falcor/Core/API/ComputeContext.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3967,
						"regions":
						{
						},
						"selection":
						[
							[
								3377,
								3377
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 459.0,
						"zoom_level": 1.0
					},
					"stack_index": 275,
					"type": "text"
				},
				{
					"buffer": 61,
					"file": "src/Falcor/Core/API/GpuTimer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3787,
						"regions":
						{
						},
						"selection":
						[
							[
								2467,
								2467
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 597.0,
						"zoom_level": 1.0
					},
					"stack_index": 274,
					"type": "text"
				},
				{
					"buffer": 62,
					"file": "src/Falcor/Core/API/LowLevelContextData.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3656,
						"regions":
						{
						},
						"selection":
						[
							[
								3566,
								3566
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 428.0,
						"zoom_level": 1.0
					},
					"stack_index": 256,
					"type": "text"
				},
				{
					"buffer": 63,
					"file": "src/Falcor/Utils/Timing/Profiler.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8484,
						"regions":
						{
						},
						"selection":
						[
							[
								6832,
								6832
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2244.0,
						"zoom_level": 1.0
					},
					"stack_index": 144,
					"type": "text"
				},
				{
					"buffer": 64,
					"file": "src/Falcor/Core/Platform/Windows/Windows.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 26025,
						"regions":
						{
						},
						"selection":
						[
							[
								25040,
								25040
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 11154.0,
						"zoom_level": 1.0
					},
					"stack_index": 441,
					"type": "text"
				},
				{
					"buffer": 65,
					"file": "third_party/slang/tools/gfx/d3d12/render-d3d12.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 139342,
						"regions":
						{
						},
						"selection":
						[
							[
								17858,
								17858
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 7779.0,
						"zoom_level": 1.0
					},
					"stack_index": 459,
					"type": "text"
				},
				{
					"buffer": 66,
					"file": "third_party/slang/tools/gfx/vulkan/render-vk.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 99401,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 7701.0,
						"zoom_level": 1.0
					},
					"stack_index": 458,
					"type": "text"
				},
				{
					"buffer": 67,
					"file": "src/Falcor/Raytracing/RtProgramVarsHelper.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6214,
						"regions":
						{
						},
						"selection":
						[
							[
								5889,
								5889
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1486.0,
						"zoom_level": 1.0
					},
					"stack_index": 358,
					"type": "text"
				},
				{
					"buffer": 68,
					"file": "src/Falcor/Core/API/D3D12/FalcorD3D12.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9709,
						"regions":
						{
						},
						"selection":
						[
							[
								1759,
								1759
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 460,
					"type": "text"
				},
				{
					"buffer": 69,
					"file": "src/Falcor/Core/Platform/OS.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8771,
						"regions":
						{
						},
						"selection":
						[
							[
								5508,
								5508
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 801.0,
						"zoom_level": 1.0
					},
					"stack_index": 416,
					"type": "text"
				},
				{
					"buffer": 70,
					"file": "src/RenderPasses/SkyBox/SkyBox.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2520,
						"regions":
						{
						},
						"selection":
						[
							[
								1900,
								1900
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 415,
					"type": "text"
				},
				{
					"buffer": 71,
					"file": "src/RenderPasses/CSM/VisibilityPass.ps.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2953,
						"regions":
						{
						},
						"selection":
						[
							[
								2130,
								2130
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 204.0,
						"zoom_level": 1.0
					},
					"stack_index": 329,
					"type": "text"
				},
				{
					"buffer": 72,
					"file": "src/RenderPasses/ToneMapper/ToneMapping.ps.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5616,
						"regions":
						{
						},
						"selection":
						[
							[
								2154,
								2154
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 153.0,
						"zoom_level": 1.0
					},
					"stack_index": 414,
					"type": "text"
				},
				{
					"buffer": 73,
					"file": "src/RenderPasses/ToneMapper/Luminance.ps.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2106,
						"regions":
						{
						},
						"selection":
						[
							[
								1729,
								1729
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 413,
					"type": "text"
				},
				{
					"buffer": 74,
					"file": "src/Falcor/Scene/Importers/PythonImporter.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3931,
						"regions":
						{
						},
						"selection":
						[
							[
								3536,
								3536
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 765.0,
						"zoom_level": 1.0
					},
					"stack_index": 203,
					"type": "text"
				},
				{
					"buffer": 75,
					"file": "src/Falcor/Scene/Importers/SceneImporter.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 36435,
						"regions":
						{
						},
						"selection":
						[
							[
								2727,
								2727
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1573.0,
						"zoom_level": 1.0
					},
					"stack_index": 211,
					"type": "text"
				},
				{
					"buffer": 76,
					"file": "src/Falcor/Scene/Importers/SceneImporter.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2157,
						"regions":
						{
						},
						"selection":
						[
							[
								1980,
								1980
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 177,
					"type": "text"
				},
				{
					"buffer": 77,
					"file": "src/Falcor/Core/Program/Program.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 12423,
						"regions":
						{
						},
						"selection":
						[
							[
								1815,
								1815
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3978.0,
						"zoom_level": 1.0
					},
					"stack_index": 248,
					"type": "text"
				},
				{
					"buffer": 78,
					"file": "src/Falcor/Core/Program/GraphicsProgram.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3809,
						"regions":
						{
						},
						"selection":
						[
							[
								3024,
								3024
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 275.0,
						"zoom_level": 1.0
					},
					"stack_index": 251,
					"type": "text"
				},
				{
					"buffer": 79,
					"file": "src/Falcor/Core/Program/ComputeProgram.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3818,
						"regions":
						{
						},
						"selection":
						[
							[
								2221,
								2221
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 171.0,
						"zoom_level": 1.0
					},
					"stack_index": 229,
					"type": "text"
				},
				{
					"buffer": 80,
					"file": "src/Falcor/Core/Program/GraphicsProgram.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2616,
						"regions":
						{
						},
						"selection":
						[
							[
								2229,
								2229
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 252,
					"type": "text"
				},
				{
					"buffer": 81,
					"file": "src/Falcor/Scene/Camera/Camera.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5388,
						"regions":
						{
						},
						"selection":
						[
							[
								4265,
								4265
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 345,
					"type": "text"
				},
				{
					"buffer": 82,
					"file": "src/Falcor/Utils/ArgList.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4051,
						"regions":
						{
						},
						"selection":
						[
							[
								1841,
								1841
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 350,
					"type": "text"
				},
				{
					"buffer": 83,
					"file": "src/Mogwai/Mogwai.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 23378,
						"regions":
						{
						},
						"selection":
						[
							[
								21932,
								21932
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 9809.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 84,
					"file": "src/Mogwai/stdafx.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1851,
						"regions":
						{
						},
						"selection":
						[
							[
								1850,
								1850
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 451,
					"type": "text"
				},
				{
					"buffer": 85,
					"file": "src/Falcor/Core/Renderer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6779,
						"regions":
						{
						},
						"selection":
						[
							[
								2065,
								2065
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 122.0,
						"zoom_level": 1.0
					},
					"stack_index": 61,
					"type": "text"
				},
				{
					"buffer": 86,
					"file": "src/Falcor/RenderGraph/RenderPassLibrary.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11235,
						"regions":
						{
						},
						"selection":
						[
							[
								3037,
								3037
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4034.0,
						"zoom_level": 1.0
					},
					"stack_index": 22,
					"type": "text"
				},
				{
					"buffer": 87,
					"file": "src/Falcor/RenderGraph/RenderPassLibrary.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5360,
						"regions":
						{
						},
						"selection":
						[
							[
								3684,
								3684
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 944.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				},
				{
					"buffer": 88,
					"file": "src/Falcor/Utils/UI/UserInput.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7116,
						"regions":
						{
						},
						"selection":
						[
							[
								1793,
								1793
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 396.0,
						"zoom_level": 1.0
					},
					"stack_index": 169,
					"type": "text"
				},
				{
					"buffer": 89,
					"file": "src/Externals/GLM/glm/gtx/compatibility.hpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14969,
						"regions":
						{
						},
						"selection":
						[
							[
								10757,
								10757
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 1029.0,
						"zoom_level": 1.0
					},
					"stack_index": 171,
					"type": "text"
				},
				{
					"buffer": 90,
					"file": "src/Falcor/Core/Sample.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7395,
						"regions":
						{
						},
						"selection":
						[
							[
								7184,
								7184
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1618.0,
						"zoom_level": 1.0
					},
					"stack_index": 75,
					"type": "text"
				},
				{
					"buffer": 91,
					"file": "src/Falcor/Utils/UI/Gui.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 26357,
						"regions":
						{
						},
						"selection":
						[
							[
								21882,
								21882
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 7905.0,
						"zoom_level": 1.0
					},
					"stack_index": 59,
					"type": "text"
				},
				{
					"buffer": 92,
					"file": "src/Falcor/Core/Window.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 17937,
						"regions":
						{
						},
						"selection":
						[
							[
								12930,
								12930
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4933.0,
						"zoom_level": 1.0
					},
					"stack_index": 73,
					"type": "text"
				},
				{
					"buffer": 93,
					"file": "src/Falcor/Core/Window.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5627,
						"regions":
						{
						},
						"selection":
						[
							[
								4740,
								4740
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1282.0,
						"zoom_level": 1.0
					},
					"stack_index": 60,
					"type": "text"
				},
				{
					"buffer": 94,
					"file": "src/Falcor/Utils/ArgList.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6269,
						"regions":
						{
						},
						"selection":
						[
							[
								6268,
								6268
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1893.0,
						"zoom_level": 1.0
					},
					"stack_index": 349,
					"type": "text"
				},
				{
					"buffer": 95,
					"file": "src/Falcor/Utils/AlignedAllocator.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6544,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1479.0,
						"zoom_level": 1.0
					},
					"stack_index": 325,
					"type": "text"
				},
				{
					"buffer": 96,
					"file": "src/Falcor/Core/API/Resource.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7622,
						"regions":
						{
						},
						"selection":
						[
							[
								7023,
								7023
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1720.0,
						"zoom_level": 1.0
					},
					"stack_index": 53,
					"type": "text"
				},
				{
					"buffer": 97,
					"file": "src/Tools/FalcorTest/Tests/Core/BufferTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6996,
						"regions":
						{
						},
						"selection":
						[
							[
								1742,
								1742
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1978.0,
						"zoom_level": 1.0
					},
					"stack_index": 388,
					"type": "text"
				},
				{
					"buffer": 98,
					"file": "src/Tools/FalcorTest/Tests/DebugPasses/InvalidPixelDetectionTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3746,
						"regions":
						{
						},
						"selection":
						[
							[
								2971,
								2971
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 88.0,
						"zoom_level": 1.0
					},
					"stack_index": 335,
					"type": "text"
				},
				{
					"buffer": 99,
					"file": "src/Tools/FalcorTest/Tests/ShadingUtils/ShadingUtilsTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 12331,
						"regions":
						{
						},
						"selection":
						[
							[
								12306,
								12306
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 409,
					"type": "text"
				},
				{
					"buffer": 100,
					"file": "src/Falcor/Testing/UnitTest.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 18208,
						"regions":
						{
						},
						"selection":
						[
							[
								4230,
								4230
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1303.0,
						"zoom_level": 1.0
					},
					"stack_index": 201,
					"type": "text"
				},
				{
					"buffer": 101,
					"file": "src/Falcor/Testing/UnitTest.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11972,
						"regions":
						{
						},
						"selection":
						[
							[
								11972,
								11972
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4227.0,
						"zoom_level": 1.0
					},
					"stack_index": 200,
					"type": "text"
				},
				{
					"buffer": 102,
					"file": "src/Falcor/Core/Program/ComputeProgram.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2634,
						"regions":
						{
						},
						"selection":
						[
							[
								2219,
								2219
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 25,
					"type": "text"
				},
				{
					"buffer": 103,
					"file": "src/Tools/FalcorTest/Tests/Core/BufferAccessTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6233,
						"regions":
						{
						},
						"selection":
						[
							[
								4566,
								4566
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 357.0,
						"zoom_level": 1.0
					},
					"stack_index": 389,
					"type": "text"
				},
				{
					"buffer": 104,
					"file": "src/Tools/FalcorTest/Tests/Core/BufferAccessTests.cs.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1913,
						"regions":
						{
						},
						"selection":
						[
							[
								1913,
								1913
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 393,
					"type": "text"
				},
				{
					"buffer": 105,
					"file": "src/Falcor/Core/API/Resource.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5154,
						"regions":
						{
						},
						"selection":
						[
							[
								4887,
								4887
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 42,
					"type": "text"
				},
				{
					"buffer": 106,
					"file": "src/Falcor/Core/API/RenderContext.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11439,
						"regions":
						{
						},
						"selection":
						[
							[
								11439,
								11439
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2499.0,
						"zoom_level": 1.0
					},
					"stack_index": 263,
					"type": "text"
				},
				{
					"buffer": 107,
					"file": "src/Falcor/Core/API/RenderContext.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5599,
						"regions":
						{
						},
						"selection":
						[
							[
								4126,
								4126
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 724.0,
						"zoom_level": 1.0
					},
					"stack_index": 64,
					"type": "text"
				},
				{
					"buffer": 108,
					"file": "src/Falcor/Core/API/RasterizerState.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7490,
						"regions":
						{
						},
						"selection":
						[
							[
								1841,
								1841
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2300.0,
						"zoom_level": 1.0
					},
					"stack_index": 356,
					"type": "text"
				},
				{
					"buffer": 109,
					"file": "src/Falcor/Core/API/RasterizerState.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2247,
						"regions":
						{
						},
						"selection":
						[
							[
								1768,
								1768
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 357,
					"type": "text"
				},
				{
					"buffer": 110,
					"file": "src/Falcor/Core/API/Vulkan/VKRasterizerState.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2034,
						"regions":
						{
						},
						"selection":
						[
							[
								1761,
								1761
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 365,
					"type": "text"
				},
				{
					"buffer": 111,
					"file": "src/Falcor/Core/API/QueryHeap.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3579,
						"regions":
						{
						},
						"selection":
						[
							[
								2529,
								2529
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 377.0,
						"zoom_level": 1.0
					},
					"stack_index": 45,
					"type": "text"
				},
				{
					"buffer": 112,
					"file": "src/Falcor/Core/API/Formats.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13822,
						"regions":
						{
						},
						"selection":
						[
							[
								12301,
								12301
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 5661.0,
						"zoom_level": 1.0
					},
					"stack_index": 269,
					"type": "text"
				},
				{
					"buffer": 113,
					"file": "src/Falcor/Core/API/Buffer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 19243,
						"regions":
						{
						},
						"selection":
						[
							[
								10640,
								10640
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2043.0,
						"zoom_level": 1.0
					},
					"stack_index": 52,
					"type": "text"
				},
				{
					"buffer": 114,
					"file": "src/Falcor/Experimental/Scene/Lights/EnvProbe.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3717,
						"regions":
						{
						},
						"selection":
						[
							[
								3676,
								3676
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 204.0,
						"zoom_level": 1.0
					},
					"stack_index": 217,
					"type": "text"
				},
				{
					"buffer": 115,
					"file": "src/Mogwai/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1908,
						"regions":
						{
						},
						"selection":
						[
							[
								1509,
								1509
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 168,
					"type": "text"
				},
				{
					"buffer": 116,
					"file": "src/Mogwai/Extensions/Capture/CaptureTrigger.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7579,
						"regions":
						{
						},
						"selection":
						[
							[
								7161,
								7161
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1993.0,
						"zoom_level": 1.0
					},
					"stack_index": 80,
					"type": "text"
				},
				{
					"buffer": 117,
					"file": "src/Mogwai/Extensions/Capture/VideoCapture.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9655,
						"regions":
						{
						},
						"selection":
						[
							[
								4887,
								4887
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 852.0,
						"zoom_level": 1.0
					},
					"stack_index": 79,
					"type": "text"
				},
				{
					"buffer": 118,
					"file": "src/Mogwai/Extensions/Capture/FrameCapture.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6569,
						"regions":
						{
						},
						"selection":
						[
							[
								6478,
								6478
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1841.0,
						"zoom_level": 1.0
					},
					"stack_index": 81,
					"type": "text"
				},
				{
					"buffer": 119,
					"file": "src/Mogwai/Extensions/Capture/FrameCapture.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2710,
						"regions":
						{
						},
						"selection":
						[
							[
								1765,
								1765
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 82,
					"type": "text"
				},
				{
					"buffer": 120,
					"file": "src/Tools/RenderGraphEditor/RenderGraphEditor.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 20776,
						"regions":
						{
						},
						"selection":
						[
							[
								20445,
								20445
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 26,
					"type": "text"
				},
				{
					"buffer": 121,
					"file": "src/Externals/dear_imgui_addons/imguinodegrapheditor/imguinodegrapheditor.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 47853,
						"regions":
						{
						},
						"selection":
						[
							[
								23852,
								23852
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 6018.0,
						"zoom_level": 1.0
					},
					"stack_index": 442,
					"type": "text"
				},
				{
					"buffer": 122,
					"file": "src/Tools/ImageCompare/ImageCompare.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14050,
						"regions":
						{
						},
						"selection":
						[
							[
								13223,
								13223
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 6069.0,
						"zoom_level": 1.0
					},
					"stack_index": 438,
					"type": "text"
				},
				{
					"buffer": 123,
					"file": "src/Mogwai/Mogwai.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8268,
						"regions":
						{
						},
						"selection":
						[
							[
								4109,
								4109
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1483.0,
						"zoom_level": 1.0
					},
					"stack_index": 74,
					"type": "text"
				},
				{
					"buffer": 124,
					"file": "src/Falcor/RenderGraph/RenderGraphImportExport.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6264,
						"regions":
						{
						},
						"selection":
						[
							[
								2379,
								2379
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2182.0,
						"zoom_level": 1.0
					},
					"stack_index": 440,
					"type": "text"
				},
				{
					"buffer": 125,
					"file": "src/Falcor/RenderGraph/ResourceCache.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8382,
						"regions":
						{
						},
						"selection":
						[
							[
								1783,
								1783
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 214,
					"type": "text"
				},
				{
					"buffer": 126,
					"file": "src/Falcor/Scene/Animation/AnimationController.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13034,
						"regions":
						{
						},
						"selection":
						[
							[
								11190,
								11190
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3009.0,
						"zoom_level": 1.0
					},
					"stack_index": 154,
					"type": "text"
				},
				{
					"buffer": 127,
					"file": "src/Falcor/RenderGraph/RenderPassReflection.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 12090,
						"regions":
						{
						},
						"selection":
						[
							[
								9644,
								9644
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2113.0,
						"zoom_level": 1.0
					},
					"stack_index": 21,
					"type": "text"
				},
				{
					"buffer": 128,
					"file": "src/Falcor/RenderGraph/RenderPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2449,
						"regions":
						{
						},
						"selection":
						[
							[
								2365,
								2365
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 20,
					"type": "text"
				},
				{
					"buffer": 129,
					"file": "src/Falcor/RenderPasses/ResolvePass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2584,
						"regions":
						{
						},
						"selection":
						[
							[
								2528,
								2528
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 131,
					"type": "text"
				},
				{
					"buffer": 130,
					"file": "src/Falcor/RenderPasses/ResolvePass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3100,
						"regions":
						{
						},
						"selection":
						[
							[
								2008,
								2008
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 130,
					"type": "text"
				},
				{
					"buffer": 131,
					"file": "src/Falcor/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5056,
						"regions":
						{
						},
						"selection":
						[
							[
								1443,
								1443
							]
						],
						"settings":
						{
							"auto_name": "file( GLOB SOURCES",
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 187.0,
						"zoom_level": 1.0
					},
					"stack_index": 283,
					"type": "text"
				},
				{
					"buffer": 132,
					"file": "src/Falcor/Scene/ParticleSystem/ParticleSystem.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10438,
						"regions":
						{
						},
						"selection":
						[
							[
								10145,
								10145
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3060.0,
						"zoom_level": 1.0
					},
					"stack_index": 207,
					"type": "text"
				},
				{
					"buffer": 133,
					"file": "src/Falcor/Scene/ParticleSystem/ParticleSystem.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 16405,
						"regions":
						{
						},
						"selection":
						[
							[
								6210,
								6210
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1436.0,
						"zoom_level": 1.0
					},
					"stack_index": 206,
					"type": "text"
				},
				{
					"buffer": 134,
					"file": "src/Falcor/Scene/HitInfo.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3622,
						"regions":
						{
						},
						"selection":
						[
							[
								3622,
								3622
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 179,
					"type": "text"
				},
				{
					"buffer": 135,
					"file": "src/Samples/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1201,
						"regions":
						{
						},
						"selection":
						[
							[
								1105,
								1105
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 437,
					"type": "text"
				},
				{
					"buffer": 136,
					"file": "src/Tools/RenderGraphEditor/RenderGraphEditor.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3325,
						"regions":
						{
						},
						"selection":
						[
							[
								1883,
								1883
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 357.0,
						"zoom_level": 1.0
					},
					"stack_index": 27,
					"type": "text"
				},
				{
					"buffer": 137,
					"file": "src/RenderPasses/DebugPasses/DebugPasses.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2436,
						"regions":
						{
						},
						"selection":
						[
							[
								1981,
								1981
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 445,
					"type": "text"
				},
				{
					"buffer": 138,
					"file": "src/RenderPasses/DebugPasses/SplitScreenPass/SplitScreenPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3041,
						"regions":
						{
						},
						"selection":
						[
							[
								2356,
								2356
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 99,
					"type": "text"
				},
				{
					"buffer": 139,
					"file": "src/RenderPasses/DebugPasses/SplitScreenPass/SplitScreenPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6309,
						"regions":
						{
						},
						"selection":
						[
							[
								4841,
								4841
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 599.0,
						"zoom_level": 1.0
					},
					"stack_index": 98,
					"type": "text"
				},
				{
					"buffer": 140,
					"file": "src/RenderPasses/DebugPasses/SideBySidePass/SideBySidePass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2482,
						"regions":
						{
						},
						"selection":
						[
							[
								2331,
								2331
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 124,
					"type": "text"
				},
				{
					"buffer": 141,
					"file": "src/RenderPasses/DebugPasses/SideBySidePass/SideBySidePass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3134,
						"regions":
						{
						},
						"selection":
						[
							[
								2697,
								2697
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 123,
					"type": "text"
				},
				{
					"buffer": 142,
					"file": "src/RenderPasses/DebugPasses/InvalidPixelDetectionPass/InvalidPixelDetectionPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2619,
						"regions":
						{
						},
						"selection":
						[
							[
								2442,
								2442
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 122,
					"type": "text"
				},
				{
					"buffer": 143,
					"file": "src/RenderPasses/CSM/CSM.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8949,
						"regions":
						{
						},
						"selection":
						[
							[
								5509,
								5509
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 561.0,
						"zoom_level": 1.0
					},
					"stack_index": 137,
					"type": "text"
				},
				{
					"buffer": 144,
					"file": "src/RenderPasses/CSM/CSM.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 35619,
						"regions":
						{
						},
						"selection":
						[
							[
								34358,
								34358
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 13124.0,
						"zoom_level": 1.0
					},
					"stack_index": 136,
					"type": "text"
				},
				{
					"buffer": 145,
					"file": "src/Falcor/Utils/UI/Gui.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2501,
						"regions":
						{
						},
						"selection":
						[
							[
								1773,
								1773
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 444,
					"type": "text"
				},
				{
					"buffer": 146,
					"file": "src/Falcor/Utils/UI/TextRenderer.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2282,
						"regions":
						{
						},
						"selection":
						[
							[
								1872,
								1872
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 326,
					"type": "text"
				},
				{
					"buffer": 147,
					"file": "src/RenderPasses/ErrorMeasurePass/ErrorMeasurePass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 16567,
						"regions":
						{
						},
						"selection":
						[
							[
								15730,
								15730
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4815.0,
						"zoom_level": 1.0
					},
					"stack_index": 88,
					"type": "text"
				},
				{
					"buffer": 148,
					"file": "src/RenderPasses/GBuffer/VBuffer/VBufferRaster.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2960,
						"regions":
						{
						},
						"selection":
						[
							[
								2618,
								2618
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 87,
					"type": "text"
				},
				{
					"buffer": 149,
					"file": "src/RenderPasses/ErrorMeasurePass/ErrorMeasurePass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4795,
						"regions":
						{
						},
						"selection":
						[
							[
								2642,
								2642
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 89,
					"type": "text"
				},
				{
					"buffer": 150,
					"file": "src/RenderPasses/PixelInspectorPass/PixelInspectorPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3479,
						"regions":
						{
						},
						"selection":
						[
							[
								2670,
								2670
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 120,
					"type": "text"
				},
				{
					"buffer": 151,
					"file": "src/Falcor/RenderGraph/RenderPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7147,
						"regions":
						{
						},
						"selection":
						[
							[
								6998,
								6998
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1501.0,
						"zoom_level": 1.0
					},
					"stack_index": 33,
					"type": "text"
				},
				{
					"buffer": 152,
					"file": "src/RenderPasses/PixelInspectorPass/PixelInspectorPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15137,
						"regions":
						{
						},
						"selection":
						[
							[
								15116,
								15116
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3999.0,
						"zoom_level": 1.0
					},
					"stack_index": 119,
					"type": "text"
				},
				{
					"buffer": 153,
					"file": "src/RenderPasses/SSAO/SSAO.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4465,
						"regions":
						{
						},
						"selection":
						[
							[
								3259,
								3259
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 118,
					"type": "text"
				},
				{
					"buffer": 154,
					"file": "src/RenderPasses/SkyBox/SkyBox.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3377,
						"regions":
						{
						},
						"selection":
						[
							[
								2854,
								2854
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 138,
					"type": "text"
				},
				{
					"buffer": 155,
					"file": "src/RenderPasses/SkyBox/SkyBox.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8099,
						"regions":
						{
						},
						"selection":
						[
							[
								2926,
								2926
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 153.0,
						"zoom_level": 1.0
					},
					"stack_index": 105,
					"type": "text"
				},
				{
					"buffer": 156,
					"file": "src/RenderPasses/Antialiasing/FXAA/FXAA.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3316,
						"regions":
						{
						},
						"selection":
						[
							[
								3095,
								3095
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 104,
					"type": "text"
				},
				{
					"buffer": 157,
					"file": "src/RenderPasses/Antialiasing/TAA/TAA.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3086,
						"regions":
						{
						},
						"selection":
						[
							[
								2743,
								2743
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 103,
					"type": "text"
				},
				{
					"buffer": 158,
					"file": "src/RenderPasses/Antialiasing/TAA/TAA.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5446,
						"regions":
						{
						},
						"selection":
						[
							[
								5089,
								5089
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 735.0,
						"zoom_level": 1.0
					},
					"stack_index": 96,
					"type": "text"
				},
				{
					"buffer": 159,
					"file": "src/RenderPasses/Antialiasing/FXAA/FXAA.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4663,
						"regions":
						{
						},
						"selection":
						[
							[
								2727,
								2727
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 95,
					"type": "text"
				},
				{
					"buffer": 160,
					"file": "src/RenderPasses/SkyBox/Data/cube.obj",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 401,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 417,
					"type": "text"
				},
				{
					"buffer": 161,
					"file": "src/RenderPasses/ForwardLightingPass/ForwardLightingPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4522,
						"regions":
						{
						},
						"selection":
						[
							[
								4518,
								4518
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 736.0,
						"zoom_level": 1.0
					},
					"stack_index": 134,
					"type": "text"
				},
				{
					"buffer": 162,
					"file": "src/RenderPasses/ForwardLightingPass/ForwardLightingPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9750,
						"regions":
						{
						},
						"selection":
						[
							[
								5658,
								5658
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 920.0,
						"zoom_level": 1.0
					},
					"stack_index": 107,
					"type": "text"
				},
				{
					"buffer": 163,
					"file": "src/RenderPasses/ImageLoader/ImageLoader.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2888,
						"regions":
						{
						},
						"selection":
						[
							[
								2706,
								2706
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 133,
					"type": "text"
				},
				{
					"buffer": 164,
					"file": "src/RenderPasses/ImageLoader/ImageLoader.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5146,
						"regions":
						{
						},
						"selection":
						[
							[
								3341,
								3341
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 667.0,
						"zoom_level": 1.0
					},
					"stack_index": 132,
					"type": "text"
				},
				{
					"buffer": 165,
					"file": "src/RenderPasses/ToneMapper/ToneMapper.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5483,
						"regions":
						{
						},
						"selection":
						[
							[
								3702,
								3702
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 566.0,
						"zoom_level": 1.0
					},
					"stack_index": 111,
					"type": "text"
				},
				{
					"buffer": 166,
					"file": "src/RenderPasses/ToneMapper/ToneMapper.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 16177,
						"regions":
						{
						},
						"selection":
						[
							[
								5942,
								5942
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1296.0,
						"zoom_level": 1.0
					},
					"stack_index": 110,
					"type": "text"
				},
				{
					"buffer": 167,
					"file": "src/RenderPasses/AccumulatePass/AccumulatePass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10804,
						"regions":
						{
						},
						"selection":
						[
							[
								10527,
								10527
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2739.0,
						"zoom_level": 1.0
					},
					"stack_index": 100,
					"type": "text"
				},
				{
					"buffer": 168,
					"file": "src/RenderPasses/GBuffer/GBufferBase.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3675,
						"regions":
						{
						},
						"selection":
						[
							[
								2523,
								2523
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 124.0,
						"zoom_level": 1.0
					},
					"stack_index": 91,
					"type": "text"
				},
				{
					"buffer": 169,
					"file": "src/RenderPasses/GBuffer/GBufferBase.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6613,
						"regions":
						{
						},
						"selection":
						[
							[
								3481,
								3481
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 328.0,
						"zoom_level": 1.0
					},
					"stack_index": 92,
					"type": "text"
				},
				{
					"buffer": 170,
					"file": "src/Falcor/Utils/SampleGenerators/HaltonSamplePattern.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2647,
						"regions":
						{
						},
						"selection":
						[
							[
								2237,
								2237
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 195,
					"type": "text"
				},
				{
					"buffer": 171,
					"file": "src/RenderPasses/GBuffer/VBuffer/VBufferRT.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2997,
						"regions":
						{
						},
						"selection":
						[
							[
								2997,
								2997
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 448,
					"type": "text"
				},
				{
					"buffer": 172,
					"file": "src/RenderPasses/GBuffer/GBuffer/GBufferRaster.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9973,
						"regions":
						{
						},
						"selection":
						[
							[
								9052,
								9052
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2299.0,
						"zoom_level": 1.0
					},
					"stack_index": 90,
					"type": "text"
				},
				{
					"buffer": 173,
					"file": "src/RenderPasses/GBuffer/GBuffer/GBufferRaster.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3089,
						"regions":
						{
						},
						"selection":
						[
							[
								2542,
								2542
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 94,
					"type": "text"
				},
				{
					"buffer": 174,
					"file": "src/RenderPasses/GBuffer/GBuffer/GBuffer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3189,
						"regions":
						{
						},
						"selection":
						[
							[
								3186,
								3186
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 93,
					"type": "text"
				},
				{
					"buffer": 175,
					"file": "src/RenderPasses/GBuffer/GBuffer/GBuffer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5817,
						"regions":
						{
						},
						"selection":
						[
							[
								3525,
								3525
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 293.0,
						"zoom_level": 1.0
					},
					"stack_index": 97,
					"type": "text"
				},
				{
					"buffer": 176,
					"file": "src/RenderPasses/DepthPass/DepthPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5263,
						"regions":
						{
						},
						"selection":
						[
							[
								3404,
								3404
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 380.0,
						"zoom_level": 1.0
					},
					"stack_index": 106,
					"type": "text"
				},
				{
					"buffer": 177,
					"file": "src/RenderPasses/Utils/GaussianBlur/GaussianBlur.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8197,
						"regions":
						{
						},
						"selection":
						[
							[
								2426,
								2426
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 157.0,
						"zoom_level": 1.0
					},
					"stack_index": 108,
					"type": "text"
				},
				{
					"buffer": 178,
					"file": "src/RenderPasses/SSAO/SSAO.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11771,
						"regions":
						{
						},
						"selection":
						[
							[
								5314,
								5314
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 769.0,
						"zoom_level": 1.0
					},
					"stack_index": 84,
					"type": "text"
				},
				{
					"buffer": 179,
					"file": "src/RenderPasses/Utils/GaussianBlur/GaussianBlur.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3547,
						"regions":
						{
						},
						"selection":
						[
							[
								3392,
								3392
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 306.0,
						"zoom_level": 1.0
					},
					"stack_index": 109,
					"type": "text"
				},
				{
					"buffer": 180,
					"file": "src/RenderPasses/Utils/Composite/Composite.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4310,
						"regions":
						{
						},
						"selection":
						[
							[
								2346,
								2346
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 361.0,
						"zoom_level": 1.0
					},
					"stack_index": 116,
					"type": "text"
				},
				{
					"buffer": 181,
					"file": "src/RenderPasses/TemporalDelayPass/TemporalDelayPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2703,
						"regions":
						{
						},
						"selection":
						[
							[
								2647,
								2647
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 115,
					"type": "text"
				},
				{
					"buffer": 182,
					"file": "src/RenderPasses/Utils/Composite/Composite.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2924,
						"regions":
						{
						},
						"selection":
						[
							[
								2671,
								2671
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 117,
					"type": "text"
				},
				{
					"buffer": 183,
					"file": "src/RenderPasses/DepthPass/DepthPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3357,
						"regions":
						{
						},
						"selection":
						[
							[
								3353,
								3353
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 102.0,
						"zoom_level": 1.0
					},
					"stack_index": 135,
					"type": "text"
				},
				{
					"buffer": 184,
					"file": "src/RenderPasses/GBuffer/GBuffer/GBufferRT.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3771,
						"regions":
						{
						},
						"selection":
						[
							[
								1726,
								1726
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 51.0,
						"zoom_level": 1.0
					},
					"stack_index": 447,
					"type": "text"
				},
				{
					"buffer": 185,
					"file": "src/RenderPasses/GBuffer/VBuffer/VBufferRT.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5767,
						"regions":
						{
						},
						"selection":
						[
							[
								1771,
								1771
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 153.0,
						"zoom_level": 1.0
					},
					"stack_index": 446,
					"type": "text"
				},
				{
					"buffer": 186,
					"file": "src/RenderPasses/GBuffer/VBuffer/VBufferRaster.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5657,
						"regions":
						{
						},
						"selection":
						[
							[
								5261,
								5261
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 975.0,
						"zoom_level": 1.0
					},
					"stack_index": 86,
					"type": "text"
				},
				{
					"buffer": 187,
					"file": "src/RenderPasses/GBuffer/GBuffer/GBufferRT.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9623,
						"regions":
						{
						},
						"selection":
						[
							[
								9623,
								9623
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2721.0,
						"zoom_level": 1.0
					},
					"stack_index": 355,
					"type": "text"
				},
				{
					"buffer": 188,
					"file": "src/RenderPasses/Antialiasing/Antialiasing.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2797,
						"regions":
						{
						},
						"selection":
						[
							[
								2797,
								2797
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 102,
					"type": "text"
				},
				{
					"buffer": 189,
					"file": "src/RenderPasses/BlitPass/BlitPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3995,
						"regions":
						{
						},
						"selection":
						[
							[
								3861,
								3861
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 561.0,
						"zoom_level": 1.0
					},
					"stack_index": 128,
					"type": "text"
				},
				{
					"buffer": 190,
					"file": "src/RenderPasses/BSDFViewer/BSDFViewer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4307,
						"regions":
						{
						},
						"selection":
						[
							[
								3025,
								3025
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 127,
					"type": "text"
				},
				{
					"buffer": 191,
					"file": "src/RenderPasses/SVGFPass/SVGFPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 18970,
						"regions":
						{
						},
						"selection":
						[
							[
								12854,
								12854
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 5598.0,
						"zoom_level": 1.0
					},
					"stack_index": 113,
					"type": "text"
				},
				{
					"buffer": 192,
					"file": "src/RenderPasses/TemporalDelayPass/TemporalDelayPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6201,
						"regions":
						{
						},
						"selection":
						[
							[
								6137,
								6137
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1041.0,
						"zoom_level": 1.0
					},
					"stack_index": 114,
					"type": "text"
				},
				{
					"buffer": 193,
					"file": "src/RenderPasses/SVGFPass/SVGFPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4511,
						"regions":
						{
						},
						"selection":
						[
							[
								2587,
								2587
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 51.0,
						"zoom_level": 1.0
					},
					"stack_index": 112,
					"type": "text"
				},
				{
					"buffer": 194,
					"file": "src/RenderPasses/BSDFViewer/BSDFViewer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 18949,
						"regions":
						{
						},
						"selection":
						[
							[
								4324,
								4324
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 548.0,
						"zoom_level": 1.0
					},
					"stack_index": 85,
					"type": "text"
				},
				{
					"buffer": 195,
					"file": "src/RenderPasses/DebugPasses/ComparisonPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3108,
						"regions":
						{
						},
						"selection":
						[
							[
								2227,
								2227
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 125,
					"type": "text"
				},
				{
					"buffer": 196,
					"file": "src/RenderPasses/DebugPasses/ComparisonPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5202,
						"regions":
						{
						},
						"selection":
						[
							[
								3784,
								3784
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 854.0,
						"zoom_level": 1.0
					},
					"stack_index": 126,
					"type": "text"
				},
				{
					"buffer": 197,
					"file": "src/RenderPasses/BlitPass/BlitPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2803,
						"regions":
						{
						},
						"selection":
						[
							[
								2669,
								2669
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 129,
					"type": "text"
				},
				{
					"buffer": 198,
					"file": "src/RenderPasses/AccumulatePass/AccumulatePass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5448,
						"regions":
						{
						},
						"selection":
						[
							[
								3628,
								3628
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 204.0,
						"zoom_level": 1.0
					},
					"stack_index": 101,
					"type": "text"
				},
				{
					"buffer": 199,
					"file": "CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3602,
						"regions":
						{
						},
						"selection":
						[
							[
								2097,
								2097
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 663.0,
						"zoom_level": 1.0
					},
					"stack_index": 339,
					"type": "text"
				},
				{
					"buffer": 200,
					"file": "src/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 289,
						"regions":
						{
						},
						"selection":
						[
							[
								289,
								289
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 278,
					"type": "text"
				},
				{
					"buffer": 201,
					"file": "src/Falcor/Utils/StringUtils.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 12635,
						"regions":
						{
						},
						"selection":
						[
							[
								12119,
								12119
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4699.0,
						"zoom_level": 1.0
					},
					"stack_index": 352,
					"type": "text"
				},
				{
					"buffer": 202,
					"file": "src/Samples/ModelViewer/ModelViewer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9979,
						"regions":
						{
						},
						"selection":
						[
							[
								3916,
								3916
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2397.0,
						"zoom_level": 1.0
					},
					"stack_index": 431,
					"type": "text"
				},
				{
					"buffer": 203,
					"file": "src/Samples/ModelViewer/ModelViewer.ps.slang.bak",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2408,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 420,
					"type": "text"
				},
				{
					"buffer": 204,
					"file": "src/Samples/ModelViewer/ModelViewer.ps.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2391,
						"regions":
						{
						},
						"selection":
						[
							[
								2383,
								2383
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 418,
					"type": "text"
				},
				{
					"buffer": 205,
					"file": "src/Falcor/Scene/Lights/LightProbeIntegration.ps.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7921,
						"regions":
						{
						},
						"selection":
						[
							[
								1944,
								1944
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 116.0,
						"zoom_level": 1.0
					},
					"stack_index": 428,
					"type": "text"
				},
				{
					"buffer": 206,
					"file": "src/Tools/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1429,
						"regions":
						{
						},
						"selection":
						[
							[
								1133,
								1133
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 426,
					"type": "text"
				},
				{
					"buffer": 207,
					"file": "src/Samples/ShaderToy/ShaderToy.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4229,
						"regions":
						{
						},
						"selection":
						[
							[
								4138,
								4138
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 482.0,
						"zoom_level": 1.0
					},
					"stack_index": 427,
					"type": "text"
				},
				{
					"buffer": 208,
					"file": "src/Falcor/RenderGraph/BasePasses/FullScreenPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5668,
						"regions":
						{
						},
						"selection":
						[
							[
								3852,
								3852
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 173,
					"type": "text"
				},
				{
					"buffer": 209,
					"file": "src/Falcor/RenderGraph/BasePasses/ComputePass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6372,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 714.0,
						"zoom_level": 1.0
					},
					"stack_index": 218,
					"type": "text"
				},
				{
					"buffer": 210,
					"file": "src/Falcor/RenderGraph/BasePasses/FullScreenPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4025,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 239.0,
						"zoom_level": 1.0
					},
					"stack_index": 219,
					"type": "text"
				},
				{
					"buffer": 211,
					"file": "src/Falcor/RenderGraph/BasePasses/ComputePass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4013,
						"regions":
						{
						},
						"selection":
						[
							[
								3937,
								3937
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 22.0,
						"zoom_level": 1.0
					},
					"stack_index": 174,
					"type": "text"
				},
				{
					"buffer": 212,
					"file": "src/Falcor/RenderGraph/BasePasses/BaseGraphicsPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2819,
						"regions":
						{
						},
						"selection":
						[
							[
								2000,
								2000
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 175,
					"type": "text"
				},
				{
					"buffer": 213,
					"file": "src/Falcor/Utils/Timing/FrameRate.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3811,
						"regions":
						{
						},
						"selection":
						[
							[
								2009,
								2009
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 87.0,
						"zoom_level": 1.0
					},
					"stack_index": 163,
					"type": "text"
				},
				{
					"buffer": 214,
					"file": "src/Falcor/Utils/Timing/FrameRate.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2265,
						"regions":
						{
						},
						"selection":
						[
							[
								1815,
								1815
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 185,
					"type": "text"
				},
				{
					"buffer": 215,
					"file": "src/Falcor/Experimental/Scene/Lights/LightBVHSampler.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6356,
						"regions":
						{
						},
						"selection":
						[
							[
								2964,
								2964
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 816.0,
						"zoom_level": 1.0
					},
					"stack_index": 456,
					"type": "text"
				},
				{
					"buffer": 216,
					"file": "src/Falcor/Experimental/Scene/Lights/LightBVHSampler.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7714,
						"regions":
						{
						},
						"selection":
						[
							[
								7713,
								7713
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1840.0,
						"zoom_level": 1.0
					},
					"stack_index": 158,
					"type": "text"
				},
				{
					"buffer": 217,
					"file": "src/Falcor/Experimental/Scene/Lights/LightCollection.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 29489,
						"regions":
						{
						},
						"selection":
						[
							[
								2921,
								2921
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 422.0,
						"zoom_level": 1.0
					},
					"stack_index": 157,
					"type": "text"
				},
				{
					"buffer": 218,
					"file": "src/Falcor/RenderGraph/BasePasses/BaseGraphicsPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3738,
						"regions":
						{
						},
						"selection":
						[
							[
								3598,
								3598
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 411.0,
						"zoom_level": 1.0
					},
					"stack_index": 221,
					"type": "text"
				},
				{
					"buffer": 219,
					"file": "src/Falcor/Experimental/Scene/Lights/LightCollection.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 12783,
						"regions":
						{
						},
						"selection":
						[
							[
								2005,
								2005
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 228,
					"type": "text"
				},
				{
					"buffer": 220,
					"file": "src/Falcor/Core/BufferTypes/ParameterBlock.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 67205,
						"regions":
						{
						},
						"selection":
						[
							[
								23467,
								23467
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 8969.0,
						"zoom_level": 1.0
					},
					"stack_index": 37,
					"type": "text"
				},
				{
					"buffer": 221,
					"file": "src/RenderPasses/BSDFViewer/BSDFViewer.cs.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15202,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 105.0,
						"zoom_level": 1.0
					},
					"stack_index": 344,
					"type": "text"
				},
				{
					"buffer": 222,
					"file": "src/Tools/FalcorTest/Tests/Core/BufferTests.cs.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2850,
						"regions":
						{
						},
						"selection":
						[
							[
								2587,
								2587
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 367.0,
						"zoom_level": 1.0
					},
					"stack_index": 392,
					"type": "text"
				},
				{
					"buffer": 223,
					"file": "src/Falcor/Core/Program/ShaderVar.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15515,
						"regions":
						{
						},
						"selection":
						[
							[
								12657,
								12657
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4745.0,
						"zoom_level": 1.0
					},
					"stack_index": 430,
					"type": "text"
				},
				{
					"buffer": 224,
					"file": "src/Falcor/Scene/Lights/LightProbe.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11503,
						"regions":
						{
						},
						"selection":
						[
							[
								6471,
								6471
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3264.0,
						"zoom_level": 1.0
					},
					"stack_index": 209,
					"type": "text"
				},
				{
					"buffer": 225,
					"file": "src/Falcor/Scene/Lights/LightProbe.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7813,
						"regions":
						{
						},
						"selection":
						[
							[
								3374,
								3374
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 765.0,
						"zoom_level": 1.0
					},
					"stack_index": 208,
					"type": "text"
				},
				{
					"buffer": 226,
					"file": "src/Falcor/RenderGraph/BasePasses/RasterScenePass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3371,
						"regions":
						{
						},
						"selection":
						[
							[
								2905,
								2905
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 222,
					"type": "text"
				},
				{
					"buffer": 227,
					"file": "src/Falcor/RenderGraph/RenderGraphCompiler.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 18153,
						"regions":
						{
						},
						"selection":
						[
							[
								1729,
								1729
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 366.0,
						"zoom_level": 1.0
					},
					"stack_index": 215,
					"type": "text"
				},
				{
					"buffer": 228,
					"file": "src/Falcor/RenderGraph/RenderGraph.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 30040,
						"regions":
						{
						},
						"selection":
						[
							[
								29968,
								29968
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 11628.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 229,
					"file": "src/Falcor/RenderGraph/RenderGraphExe.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4177,
						"regions":
						{
						},
						"selection":
						[
							[
								3590,
								3590
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 412.0,
						"zoom_level": 1.0
					},
					"stack_index": 155,
					"type": "text"
				},
				{
					"buffer": 230,
					"file": "src/Falcor/RenderGraph/RenderGraphExe.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4072,
						"regions":
						{
						},
						"selection":
						[
							[
								2042,
								2042
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 156,
					"type": "text"
				},
				{
					"buffer": 231,
					"file": "src/Falcor/Utils/Scripting/Dictionary.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4523,
						"regions":
						{
						},
						"selection":
						[
							[
								1943,
								1943
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 918.0,
						"zoom_level": 1.0
					},
					"stack_index": 31,
					"type": "text"
				},
				{
					"buffer": 232,
					"file": "src/Falcor/RenderGraph/RenderGraphUI.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 64727,
						"regions":
						{
						},
						"selection":
						[
							[
								39130,
								39130
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 14966.0,
						"zoom_level": 1.0
					},
					"stack_index": 432,
					"type": "text"
				},
				{
					"buffer": 233,
					"file": "src/Falcor/Utils/Debug/PixelDebug.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9625,
						"regions":
						{
						},
						"selection":
						[
							[
								1814,
								1814
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1683.0,
						"zoom_level": 1.0
					},
					"stack_index": 190,
					"type": "text"
				},
				{
					"buffer": 234,
					"file": "src/Falcor/Utils/Algorithm/ParallelReduction.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6148,
						"regions":
						{
						},
						"selection":
						[
							[
								1729,
								1729
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 536.0,
						"zoom_level": 1.0
					},
					"stack_index": 150,
					"type": "text"
				},
				{
					"buffer": 235,
					"file": "src/Tools/FalcorTest/Tests/Utils/ParallelReductionTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11656,
						"regions":
						{
						},
						"selection":
						[
							[
								9905,
								9905
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3213.0,
						"zoom_level": 1.0
					},
					"stack_index": 368,
					"type": "text"
				},
				{
					"buffer": 236,
					"file": "src/Tools/FalcorTest/Tests/Utils/PrefixSumTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4850,
						"regions":
						{
						},
						"selection":
						[
							[
								4793,
								4793
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1173.0,
						"zoom_level": 1.0
					},
					"stack_index": 363,
					"type": "text"
				},
				{
					"buffer": 237,
					"file": "src/Falcor/Utils/Algorithm/PrefixSum.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7112,
						"regions":
						{
						},
						"selection":
						[
							[
								3289,
								3289
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 379.0,
						"zoom_level": 1.0
					},
					"stack_index": 149,
					"type": "text"
				},
				{
					"buffer": 238,
					"file": "src/Falcor/Utils/Algorithm/BitonicSort.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4470,
						"regions":
						{
						},
						"selection":
						[
							[
								2970,
								2970
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 906.0,
						"zoom_level": 1.0
					},
					"stack_index": 152,
					"type": "text"
				},
				{
					"buffer": 239,
					"file": "src/Falcor/Utils/Algorithm/ComputeParallelReduction.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4901,
						"regions":
						{
						},
						"selection":
						[
							[
								1906,
								1906
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 612.0,
						"zoom_level": 1.0
					},
					"stack_index": 196,
					"type": "text"
				},
				{
					"buffer": 240,
					"file": "src/Falcor/Utils/Algorithm/ParallelReduction.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3575,
						"regions":
						{
						},
						"selection":
						[
							[
								3574,
								3574
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 357.0,
						"zoom_level": 1.0
					},
					"stack_index": 198,
					"type": "text"
				},
				{
					"buffer": 241,
					"file": "src/Falcor/Utils/Algorithm/BitonicSort.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4169,
						"regions":
						{
						},
						"selection":
						[
							[
								4169,
								4169
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 816.0,
						"zoom_level": 1.0
					},
					"stack_index": 199,
					"type": "text"
				},
				{
					"buffer": 242,
					"file": "src/Falcor/Utils/Algorithm/PrefixSum.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4191,
						"regions":
						{
						},
						"selection":
						[
							[
								4191,
								4191
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 878.0,
						"zoom_level": 1.0
					},
					"stack_index": 197,
					"type": "text"
				},
				{
					"buffer": 243,
					"file": "src/Falcor/Utils/Algorithm/ComputeParallelReduction.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9541,
						"regions":
						{
						},
						"selection":
						[
							[
								4105,
								4105
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 504.0,
						"zoom_level": 1.0
					},
					"stack_index": 151,
					"type": "text"
				},
				{
					"buffer": 244,
					"file": "src/Falcor/Utils/Scripting/Console.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4108,
						"regions":
						{
						},
						"selection":
						[
							[
								1760,
								1760
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 816.0,
						"zoom_level": 1.0
					},
					"stack_index": 28,
					"type": "text"
				},
				{
					"buffer": 245,
					"file": "src/Falcor/Utils/Scripting/ScriptBindings.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4848,
						"regions":
						{
						},
						"selection":
						[
							[
								1751,
								1751
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 449,
					"type": "text"
				},
				{
					"buffer": 246,
					"file": "src/Falcor/Utils/Sampling/SampleGenerator.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3452,
						"regions":
						{
						},
						"selection":
						[
							[
								3451,
								3451
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 306.0,
						"zoom_level": 1.0
					},
					"stack_index": 194,
					"type": "text"
				},
				{
					"buffer": 247,
					"file": "src/Falcor/Utils/Timing/Clock.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9831,
						"regions":
						{
						},
						"selection":
						[
							[
								8210,
								8210
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3482.0,
						"zoom_level": 1.0
					},
					"stack_index": 183,
					"type": "text"
				},
				{
					"buffer": 248,
					"file": "src/Falcor/Utils/Timing/Clock.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8564,
						"regions":
						{
						},
						"selection":
						[
							[
								2111,
								2111
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 51.0,
						"zoom_level": 1.0
					},
					"stack_index": 184,
					"type": "text"
				},
				{
					"buffer": 249,
					"file": "src/Falcor/Core/API/TextureLoader.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 24304,
						"regions":
						{
						},
						"selection":
						[
							[
								23777,
								23777
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4517.0,
						"zoom_level": 1.0
					},
					"stack_index": 186,
					"type": "text"
				},
				{
					"buffer": 250,
					"file": "third_party/assimp/include/assimp/Bitmap.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4295,
						"regions":
						{
						},
						"selection":
						[
							[
								2138,
								2138
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1162.0,
						"zoom_level": 1.0
					},
					"stack_index": 435,
					"type": "text"
				},
				{
					"buffer": 251,
					"file": "src/Falcor/Core/API/VAO.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5144,
						"regions":
						{
						},
						"selection":
						[
							[
								2540,
								2540
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1395.0,
						"zoom_level": 1.0
					},
					"stack_index": 227,
					"type": "text"
				},
				{
					"buffer": 252,
					"file": "src/Falcor/Utils/Logger.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5549,
						"regions":
						{
						},
						"selection":
						[
							[
								5217,
								5217
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1291.0,
						"zoom_level": 1.0
					},
					"stack_index": 12,
					"type": "text"
				},
				{
					"buffer": 253,
					"file": "src/Falcor/Utils/Logger.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5968,
						"regions":
						{
						},
						"selection":
						[
							[
								5674,
								5674
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2115.0,
						"zoom_level": 1.0
					},
					"stack_index": 340,
					"type": "text"
				},
				{
					"buffer": 254,
					"file": "src/Falcor/Utils/BinaryFileStream.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5898,
						"regions":
						{
						},
						"selection":
						[
							[
								1843,
								1843
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 170.0,
						"zoom_level": 1.0
					},
					"stack_index": 351,
					"type": "text"
				},
				{
					"buffer": 255,
					"file": "src/Falcor/Utils/Scripting/Scripting.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5721,
						"regions":
						{
						},
						"selection":
						[
							[
								1749,
								1749
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 74.0,
						"zoom_level": 1.0
					},
					"stack_index": 30,
					"type": "text"
				},
				{
					"buffer": 256,
					"file": "src/Falcor/Utils/Timing/Profiler.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10754,
						"regions":
						{
						},
						"selection":
						[
							[
								2524,
								2524
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 359.0,
						"zoom_level": 1.0
					},
					"stack_index": 143,
					"type": "text"
				},
				{
					"buffer": 257,
					"file": "src/Falcor/Utils/UI/Gui.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 56184,
						"regions":
						{
						},
						"selection":
						[
							[
								8303,
								8303
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2116.0,
						"zoom_level": 1.0
					},
					"stack_index": 58,
					"type": "text"
				},
				{
					"buffer": 258,
					"file": "src/Falcor/Utils/UI/PixelZoom.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5190,
						"regions":
						{
						},
						"selection":
						[
							[
								2488,
								2488
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 867.0,
						"zoom_level": 1.0
					},
					"stack_index": 139,
					"type": "text"
				},
				{
					"buffer": 259,
					"file": "src/Falcor/Utils/UI/TextRenderer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7231,
						"regions":
						{
						},
						"selection":
						[
							[
								5273,
								5273
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1212.0,
						"zoom_level": 1.0
					},
					"stack_index": 141,
					"type": "text"
				},
				{
					"buffer": 260,
					"file": "src/Falcor/Utils/UI/TextRenderer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3353,
						"regions":
						{
						},
						"selection":
						[
							[
								2192,
								2192
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 408.0,
						"zoom_level": 1.0
					},
					"stack_index": 142,
					"type": "text"
				},
				{
					"buffer": 261,
					"file": "src/Falcor/Utils/UI/PixelZoom.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3368,
						"regions":
						{
						},
						"selection":
						[
							[
								3286,
								3286
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 158.0,
						"zoom_level": 1.0
					},
					"stack_index": 140,
					"type": "text"
				},
				{
					"buffer": 262,
					"file": "src/Falcor/Utils/UI/DebugDrawer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4027,
						"regions":
						{
						},
						"selection":
						[
							[
								3944,
								3944
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 636.0,
						"zoom_level": 1.0
					},
					"stack_index": 148,
					"type": "text"
				},
				{
					"buffer": 263,
					"file": "src/Falcor/Utils/UI/DebugDrawer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8927,
						"regions":
						{
						},
						"selection":
						[
							[
								2050,
								2050
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 51.0,
						"zoom_level": 1.0
					},
					"stack_index": 147,
					"type": "text"
				},
				{
					"buffer": 264,
					"file": "src/Falcor/Utils/UI/Font.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4060,
						"regions":
						{
						},
						"selection":
						[
							[
								2244,
								2244
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 378.0,
						"zoom_level": 1.0
					},
					"stack_index": 146,
					"type": "text"
				},
				{
					"buffer": 265,
					"file": "third_party/slang/tools/render-test/bind-location.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 19257,
						"regions":
						{
						},
						"selection":
						[
							[
								10547,
								10547
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3980.0,
						"zoom_level": 1.0
					},
					"stack_index": 429,
					"type": "text"
				},
				{
					"buffer": 266,
					"file": "src/Falcor/Utils/UI/Font.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5156,
						"regions":
						{
						},
						"selection":
						[
							[
								2559,
								2559
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 255.0,
						"zoom_level": 1.0
					},
					"stack_index": 145,
					"type": "text"
				},
				{
					"buffer": 267,
					"file": "src/Falcor/Core/Program/ProgramReflection.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 85503,
						"regions":
						{
						},
						"selection":
						[
							[
								85503,
								85503
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 36385.0,
						"zoom_level": 1.0
					},
					"stack_index": 362,
					"type": "text"
				},
				{
					"buffer": 268,
					"file": "src/Falcor/Core/API/Vulkan/VKGraphicsStateObject.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5776,
						"regions":
						{
						},
						"selection":
						[
							[
								5776,
								5776
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 921.0,
						"zoom_level": 1.0
					},
					"stack_index": 241,
					"type": "text"
				},
				{
					"buffer": 269,
					"file": "third_party/slang/source/slang/slang-reflection.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 50216,
						"regions":
						{
						},
						"selection":
						[
							[
								2619,
								2619
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1382.0,
						"zoom_level": 1.0
					},
					"stack_index": 424,
					"type": "text"
				},
				{
					"buffer": 270,
					"file": "third_party/slang/source/slang/slang-compiler.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 90183,
						"regions":
						{
						},
						"selection":
						[
							[
								83549,
								83549
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 34736.0,
						"zoom_level": 1.0
					},
					"stack_index": 423,
					"type": "text"
				},
				{
					"buffer": 271,
					"file": "third_party/slang/source/slang/slang-name.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 800,
						"regions":
						{
						},
						"selection":
						[
							[
								630,
								630
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 56.0,
						"zoom_level": 1.0
					},
					"stack_index": 422,
					"type": "text"
				},
				{
					"buffer": 272,
					"file": "third_party/slang/source/core/slang-dictionary.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13988,
						"regions":
						{
						},
						"selection":
						[
							[
								8683,
								8683
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 421,
					"type": "text"
				},
				{
					"buffer": 273,
					"file": "src/Falcor/Core/Program/ProgramVars.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14700,
						"regions":
						{
						},
						"selection":
						[
							[
								5179,
								5179
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1056.0,
						"zoom_level": 1.0
					},
					"stack_index": 276,
					"type": "text"
				},
				{
					"buffer": 274,
					"file": "src/Falcor/Raytracing/RtProgramVarsHelper.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14339,
						"regions":
						{
						},
						"selection":
						[
							[
								2753,
								2753
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 299.0,
						"zoom_level": 1.0
					},
					"stack_index": 359,
					"type": "text"
				},
				{
					"buffer": 275,
					"file": "src/Falcor/Core/Program/ProgramVars.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6787,
						"regions":
						{
						},
						"selection":
						[
							[
								6787,
								6787
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 117.0,
						"zoom_level": 1.0
					},
					"stack_index": 246,
					"type": "text"
				},
				{
					"buffer": 276,
					"file": "src/Falcor/Core/Program/ShaderVar.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 17036,
						"regions":
						{
						},
						"selection":
						[
							[
								17036,
								17036
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 6056.0,
						"zoom_level": 1.0
					},
					"stack_index": 245,
					"type": "text"
				},
				{
					"buffer": 277,
					"file": "src/Falcor/Core/Program/ProgramReflection.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 54819,
						"regions":
						{
						},
						"selection":
						[
							[
								35151,
								35151
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 11673.0,
						"zoom_level": 1.0
					},
					"stack_index": 394,
					"type": "text"
				},
				{
					"buffer": 278,
					"file": "src/Falcor/Core/Program/Program.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 34062,
						"regions":
						{
						},
						"selection":
						[
							[
								27215,
								27215
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 11768.0,
						"zoom_level": 1.0
					},
					"stack_index": 247,
					"type": "text"
				},
				{
					"buffer": 279,
					"file": "src/Falcor/Core/API/Buffer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13450,
						"regions":
						{
						},
						"selection":
						[
							[
								11550,
								11550
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3287.0,
						"zoom_level": 1.0
					},
					"stack_index": 13,
					"type": "text"
				},
				{
					"buffer": 280,
					"file": "src/Falcor/Core/API/FBO.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 18040,
						"regions":
						{
						},
						"selection":
						[
							[
								6037,
								6037
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2397.0,
						"zoom_level": 1.0
					},
					"stack_index": 48,
					"type": "text"
				},
				{
					"buffer": 281,
					"file": "src/Falcor/Core/API/BlendState.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9346,
						"regions":
						{
						},
						"selection":
						[
							[
								9106,
								9106
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2535.0,
						"zoom_level": 1.0
					},
					"stack_index": 238,
					"type": "text"
				},
				{
					"buffer": 282,
					"file": "src/Falcor/Core/API/BlendState.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3664,
						"regions":
						{
						},
						"selection":
						[
							[
								1729,
								1729
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 306.0,
						"zoom_level": 1.0
					},
					"stack_index": 272,
					"type": "text"
				},
				{
					"buffer": 283,
					"file": "src/Falcor/Core/API/FBO.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13423,
						"regions":
						{
						},
						"selection":
						[
							[
								9893,
								9893
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2790.0,
						"zoom_level": 1.0
					},
					"stack_index": 49,
					"type": "text"
				},
				{
					"buffer": 284,
					"file": "src/Falcor/Core/API/Texture.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15073,
						"regions":
						{
						},
						"selection":
						[
							[
								11580,
								11580
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2594.0,
						"zoom_level": 1.0
					},
					"stack_index": 62,
					"type": "text"
				},
				{
					"buffer": 285,
					"file": "src/Tools/FalcorTest/Tests/ShadingUtils/RaytracingTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4882,
						"regions":
						{
						},
						"selection":
						[
							[
								4881,
								4881
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1315.0,
						"zoom_level": 1.0
					},
					"stack_index": 408,
					"type": "text"
				},
				{
					"buffer": 286,
					"file": "src/Tools/FalcorTest/Tests/Slang/SlangTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8055,
						"regions":
						{
						},
						"selection":
						[
							[
								6777,
								6777
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2518.0,
						"zoom_level": 1.0
					},
					"stack_index": 398,
					"type": "text"
				},
				{
					"buffer": 287,
					"file": "src/Tools/FalcorTest/Tests/Slang/SlangTests.cs.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6527,
						"regions":
						{
						},
						"selection":
						[
							[
								4191,
								4191
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1297.0,
						"zoom_level": 1.0
					},
					"stack_index": 400,
					"type": "text"
				},
				{
					"buffer": 288,
					"file": "src/Tools/FalcorTest/Tests/Slang/SlangShared.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2435,
						"regions":
						{
						},
						"selection":
						[
							[
								1765,
								1765
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 357.0,
						"zoom_level": 1.0
					},
					"stack_index": 401,
					"type": "text"
				},
				{
					"buffer": 289,
					"file": "src/Tools/FalcorTest/Tests/Slang/ShaderModel.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3182,
						"regions":
						{
						},
						"selection":
						[
							[
								2515,
								2515
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 75.0,
						"zoom_level": 1.0
					},
					"stack_index": 396,
					"type": "text"
				},
				{
					"buffer": 290,
					"file": "src/Tools/FalcorTest/Tests/Slang/Int64Tests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3694,
						"regions":
						{
						},
						"selection":
						[
							[
								1882,
								1882
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1060.0,
						"zoom_level": 1.0
					},
					"stack_index": 410,
					"type": "text"
				},
				{
					"buffer": 291,
					"file": "src/Tools/FalcorTest/Tests/Slang/TraceRayFlags.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3163,
						"regions":
						{
						},
						"selection":
						[
							[
								1762,
								1743
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 227.0,
						"zoom_level": 1.0
					},
					"stack_index": 407,
					"type": "text"
				},
				{
					"buffer": 292,
					"file": "src/Tools/FalcorTest/Tests/Slang/TraceRayInline.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2113,
						"regions":
						{
						},
						"selection":
						[
							[
								2113,
								2113
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 412,
					"type": "text"
				},
				{
					"buffer": 293,
					"file": "src/Tools/FalcorTest/Tests/Slang/WaveOps.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6067,
						"regions":
						{
						},
						"selection":
						[
							[
								3182,
								3182
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1122.0,
						"zoom_level": 1.0
					},
					"stack_index": 397,
					"type": "text"
				},
				{
					"buffer": 294,
					"file": "src/Tools/FalcorTest/Tests/Utils/AABBTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7752,
						"regions":
						{
						},
						"selection":
						[
							[
								2261,
								2261
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 262.0,
						"zoom_level": 1.0
					},
					"stack_index": 380,
					"type": "text"
				},
				{
					"buffer": 295,
					"file": "third_party/slang/prelude/slang-cpp-types.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 28997,
						"regions":
						{
						},
						"selection":
						[
							[
								1493,
								1493
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 614.0,
						"zoom_level": 1.0
					},
					"stack_index": 170,
					"type": "text"
				},
				{
					"buffer": 296,
					"file": "src/Tools/FalcorTest/FalcorTest.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2143,
						"regions":
						{
						},
						"selection":
						[
							[
								1866,
								1866
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 425,
					"type": "text"
				},
				{
					"buffer": 297,
					"file": "src/Tools/FalcorTest/FalcorTest.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3605,
						"regions":
						{
						},
						"selection":
						[
							[
								3312,
								3312
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 346.0,
						"zoom_level": 1.0
					},
					"stack_index": 411,
					"type": "text"
				},
				{
					"buffer": 298,
					"file": "src/Tools/FalcorTest/Tests/Sampling/SampleGeneratorTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7287,
						"regions":
						{
						},
						"selection":
						[
							[
								4059,
								4059
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 551.0,
						"zoom_level": 1.0
					},
					"stack_index": 384,
					"type": "text"
				},
				{
					"buffer": 299,
					"file": "src/Tools/FalcorTest/Tests/Core/RootBufferTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8005,
						"regions":
						{
						},
						"selection":
						[
							[
								7231,
								7231
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2098.0,
						"zoom_level": 1.0
					},
					"stack_index": 385,
					"type": "text"
				},
				{
					"buffer": 300,
					"file": "src/Tools/FalcorTest/Tests/Core/RootBufferStructTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5631,
						"regions":
						{
						},
						"selection":
						[
							[
								4710,
								4710
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 386,
					"type": "text"
				},
				{
					"buffer": 301,
					"file": "src/Falcor/Core/API/Vulkan/VkGpuMemoryHeap.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2413,
						"regions":
						{
						},
						"selection":
						[
							[
								2413,
								2413
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 257,
					"type": "text"
				},
				{
					"buffer": 302,
					"file": "src/Falcor/Core/Platform/Linux/Linux.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15074,
						"regions":
						{
						},
						"selection":
						[
							[
								14787,
								14787
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 7551.0,
						"zoom_level": 1.0
					},
					"stack_index": 361,
					"type": "text"
				},
				{
					"buffer": 303,
					"file": "src/Falcor/Core/Platform/Windows/ProgressBarWin.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4513,
						"regions":
						{
						},
						"selection":
						[
							[
								2360,
								2360
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 204.0,
						"zoom_level": 1.0
					},
					"stack_index": 455,
					"type": "text"
				},
				{
					"buffer": 304,
					"file": "src/Falcor/Core/Platform/OS.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15995,
						"regions":
						{
						},
						"selection":
						[
							[
								1983,
								1983
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2550.0,
						"zoom_level": 1.0
					},
					"stack_index": 433,
					"type": "text"
				},
				{
					"buffer": 305,
					"file": "src/Falcor/Core/API/Vulkan/VKState.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3960,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 377.0,
						"zoom_level": 1.0
					},
					"stack_index": 239,
					"type": "text"
				},
				{
					"buffer": 306,
					"file": "src/Falcor/Core/API/Texture.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 16155,
						"regions":
						{
						},
						"selection":
						[
							[
								14061,
								14061
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2520.0,
						"zoom_level": 1.0
					},
					"stack_index": 51,
					"type": "text"
				},
				{
					"buffer": 307,
					"file": "src/USD/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 47,
						"regions":
						{
						},
						"selection":
						[
							[
								47,
								47
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 284,
					"type": "text"
				},
				{
					"buffer": 308,
					"file": "src/USD/hgiVk/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2011,
						"regions":
						{
						},
						"selection":
						[
							[
								76,
								76
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 282,
					"type": "text"
				},
				{
					"buffer": 309,
					"file": "src/USD/hgiVk/commandBuffer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8461,
						"regions":
						{
						},
						"selection":
						[
							[
								1472,
								1472
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 285,
					"type": "text"
				},
				{
					"buffer": 310,
					"file": "src/USD/hgiVk/commandBufferManager.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13416,
						"regions":
						{
						},
						"selection":
						[
							[
								184,
								184
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 323,
					"type": "text"
				},
				{
					"buffer": 311,
					"file": "src/USD/hgiVk/commandPool.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1629,
						"regions":
						{
						},
						"selection":
						[
							[
								114,
								114
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 322,
					"type": "text"
				},
				{
					"buffer": 312,
					"file": "src/USD/hgiVk/computeEncoder.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1791,
						"regions":
						{
						},
						"selection":
						[
							[
								222,
								222
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 321,
					"type": "text"
				},
				{
					"buffer": 313,
					"file": "src/USD/hgiVk/conversions.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9785,
						"regions":
						{
						},
						"selection":
						[
							[
								150,
								150
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 320,
					"type": "text"
				},
				{
					"buffer": 314,
					"file": "src/USD/hgiVk/device.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 17769,
						"regions":
						{
						},
						"selection":
						[
							[
								209,
								209
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 319,
					"type": "text"
				},
				{
					"buffer": 315,
					"file": "src/USD/hgiVk/diagnostic.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6577,
						"regions":
						{
						},
						"selection":
						[
							[
								239,
								239
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 318,
					"type": "text"
				},
				{
					"buffer": 316,
					"file": "src/USD/hgiVk/frame.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2455,
						"regions":
						{
						},
						"selection":
						[
							[
								113,
								113
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 295,
					"type": "text"
				},
				{
					"buffer": 317,
					"file": "src/USD/hgiVk/garbageCollector.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3957,
						"regions":
						{
						},
						"selection":
						[
							[
								423,
								423
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 317,
					"type": "text"
				},
				{
					"buffer": 318,
					"file": "src/USD/hgiVk/graphicsEncoder.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6479,
						"regions":
						{
						},
						"selection":
						[
							[
								405,
								405
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 316,
					"type": "text"
				},
				{
					"buffer": 319,
					"file": "src/USD/hgiVk/hgi.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14444,
						"regions":
						{
						},
						"selection":
						[
							[
								961,
								961
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 315,
					"type": "text"
				},
				{
					"buffer": 320,
					"file": "src/USD/hgiVk/instance.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1940,
						"regions":
						{
						},
						"selection":
						[
							[
								103,
								103
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 314,
					"type": "text"
				},
				{
					"buffer": 321,
					"file": "src/USD/hgiVk/parallelGraphicsEncoder.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3913,
						"regions":
						{
						},
						"selection":
						[
							[
								387,
								387
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 313,
					"type": "text"
				},
				{
					"buffer": 322,
					"file": "src/USD/hgiVk/pipeline.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15055,
						"regions":
						{
						},
						"selection":
						[
							[
								348,
								348
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 312,
					"type": "text"
				},
				{
					"buffer": 323,
					"file": "src/USD/hgiVk/renderPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15805,
						"regions":
						{
						},
						"selection":
						[
							[
								264,
								264
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 288,
					"type": "text"
				},
				{
					"buffer": 324,
					"file": "src/USD/hgiVk/pipeline.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1831,
						"regions":
						{
						},
						"selection":
						[
							[
								1176,
								1176
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 287,
					"type": "text"
				},
				{
					"buffer": 325,
					"file": "src/USD/hgiVk/renderPassPipelineCache.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8095,
						"regions":
						{
						},
						"selection":
						[
							[
								322,
								322
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 311,
					"type": "text"
				},
				{
					"buffer": 326,
					"file": "src/USD/hgiVk/resourceBindings.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 16563,
						"regions":
						{
						},
						"selection":
						[
							[
								276,
								276
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 310,
					"type": "text"
				},
				{
					"buffer": 327,
					"file": "src/USD/hgiVk/shaderCompiler.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10186,
						"regions":
						{
						},
						"selection":
						[
							[
								285,
								285
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 309,
					"type": "text"
				},
				{
					"buffer": 328,
					"file": "src/USD/hgiVk/shaderFunction.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2509,
						"regions":
						{
						},
						"selection":
						[
							[
								149,
								149
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 308,
					"type": "text"
				},
				{
					"buffer": 329,
					"file": "src/USD/hgiVk/shaderProgram.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 437,
						"regions":
						{
						},
						"selection":
						[
							[
								50,
								50
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 307,
					"type": "text"
				},
				{
					"buffer": 330,
					"file": "src/USD/hgiVk/surface.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3812,
						"regions":
						{
						},
						"selection":
						[
							[
								112,
								112
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1530.0,
						"zoom_level": 1.0
					},
					"stack_index": 281,
					"type": "text"
				},
				{
					"buffer": 331,
					"file": "src/USD/hgiVk/swapchain.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 17443,
						"regions":
						{
						},
						"selection":
						[
							[
								253,
								253
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 306,
					"type": "text"
				},
				{
					"buffer": 332,
					"file": "src/USD/hgiVk/texture.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15437,
						"regions":
						{
						},
						"selection":
						[
							[
								1497,
								1497
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 305,
					"type": "text"
				},
				{
					"buffer": 333,
					"file": "src/USD/hgiVk/buffer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9825,
						"regions":
						{
						},
						"selection":
						[
							[
								182,
								182
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 304,
					"type": "text"
				},
				{
					"buffer": 334,
					"file": "src/USD/hgiVk/blitEncoder.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6180,
						"regions":
						{
						},
						"selection":
						[
							[
								1024,
								1024
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 303,
					"type": "text"
				},
				{
					"buffer": 335,
					"file": "src/USD/hgiVk/blitEncoder.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1319,
						"regions":
						{
						},
						"selection":
						[
							[
								378,
								378
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 280,
					"type": "text"
				},
				{
					"buffer": 336,
					"file": "src/USD/hgiVk/buffer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1965,
						"regions":
						{
						},
						"selection":
						[
							[
								148,
								148
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 302,
					"type": "text"
				},
				{
					"buffer": 337,
					"file": "src/USD/hgiVk/commandBuffer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3844,
						"regions":
						{
						},
						"selection":
						[
							[
								216,
								216
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 286,
					"type": "text"
				},
				{
					"buffer": 338,
					"file": "src/USD/hgiVk/commandBufferManager.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5853,
						"regions":
						{
						},
						"selection":
						[
							[
								292,
								292
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 301,
					"type": "text"
				},
				{
					"buffer": 339,
					"file": "src/USD/hgiVk/commandPool.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1102,
						"regions":
						{
						},
						"selection":
						[
							[
								213,
								213
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 300,
					"type": "text"
				},
				{
					"buffer": 340,
					"file": "src/USD/hgiVk/computeEncoder.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1631,
						"regions":
						{
						},
						"selection":
						[
							[
								252,
								252
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 299,
					"type": "text"
				},
				{
					"buffer": 341,
					"file": "src/USD/hgiVk/conversions.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1688,
						"regions":
						{
						},
						"selection":
						[
							[
								249,
								249
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 298,
					"type": "text"
				},
				{
					"buffer": 342,
					"file": "src/USD/hgiVk/device.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6599,
						"regions":
						{
						},
						"selection":
						[
							[
								357,
								357
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 297,
					"type": "text"
				},
				{
					"buffer": 343,
					"file": "src/USD/hgiVk/diagnostic.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1085,
						"regions":
						{
						},
						"selection":
						[
							[
								135,
								135
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 296,
					"type": "text"
				},
				{
					"buffer": 344,
					"file": "src/USD/hgiVk/frame.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2289,
						"regions":
						{
						},
						"selection":
						[
							[
								270,
								270
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 294,
					"type": "text"
				},
				{
					"buffer": 345,
					"file": "src/USD/hgiVk/garbageCollector.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1637,
						"regions":
						{
						},
						"selection":
						[
							[
								192,
								192
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 293,
					"type": "text"
				},
				{
					"buffer": 346,
					"file": "src/USD/hgiVk/graphicsEncoder.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2732,
						"regions":
						{
						},
						"selection":
						[
							[
								307,
								307
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 292,
					"type": "text"
				},
				{
					"buffer": 347,
					"file": "src/USD/hgiVk/hgi.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4470,
						"regions":
						{
						},
						"selection":
						[
							[
								195,
								195
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 291,
					"type": "text"
				},
				{
					"buffer": 348,
					"file": "src/USD/hgiVk/instance.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 693,
						"regions":
						{
						},
						"selection":
						[
							[
								137,
								137
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 290,
					"type": "text"
				},
				{
					"buffer": 349,
					"file": "src/USD/hgiVk/parallelGraphicsEncoder.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1608,
						"regions":
						{
						},
						"selection":
						[
							[
								280,
								280
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 289,
					"type": "text"
				},
				{
					"buffer": 350,
					"file": "src/Mogwai/MogwaiSettings.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2575,
						"regions":
						{
						},
						"selection":
						[
							[
								1742,
								1742
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 77,
					"type": "text"
				},
				{
					"buffer": 351,
					"file": "src/Mogwai/MogwaiSettings.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10806,
						"regions":
						{
						},
						"selection":
						[
							[
								7590,
								7590
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2368.0,
						"zoom_level": 1.0
					},
					"stack_index": 76,
					"type": "text"
				},
				{
					"buffer": 352,
					"file": "src/Mogwai/MogwaiScripting.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6767,
						"regions":
						{
						},
						"selection":
						[
							[
								5949,
								5949
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1496.0,
						"zoom_level": 1.0
					},
					"stack_index": 78,
					"type": "text"
				},
				{
					"buffer": 353,
					"file": "src/Falcor/Core/API/Shader.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8437,
						"regions":
						{
						},
						"selection":
						[
							[
								7321,
								7321
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2910.0,
						"zoom_level": 1.0
					},
					"stack_index": 260,
					"type": "text"
				},
				{
					"buffer": 354,
					"file": "src/Falcor/Core/API/Sampler.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7871,
						"regions":
						{
						},
						"selection":
						[
							[
								5224,
								5224
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1680.0,
						"zoom_level": 1.0
					},
					"stack_index": 210,
					"type": "text"
				},
				{
					"buffer": 355,
					"file": "src/Falcor/Core/API/Sampler.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3887,
						"regions":
						{
						},
						"selection":
						[
							[
								3190,
								3190
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 139.0,
						"zoom_level": 1.0
					},
					"stack_index": 261,
					"type": "text"
				},
				{
					"buffer": 356,
					"file": "src/Falcor/Core/API/Vulkan/VKShader.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2775,
						"regions":
						{
						},
						"selection":
						[
							[
								2709,
								2709
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 253,
					"type": "text"
				},
				{
					"buffer": 357,
					"file": "src/Falcor/stdafx.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1831,
						"regions":
						{
						},
						"selection":
						[
							[
								1788,
								1788
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 439,
					"type": "text"
				},
				{
					"buffer": 358,
					"file": "src/Falcor/Core/API/CopyContext.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6896,
						"regions":
						{
						},
						"selection":
						[
							[
								3581,
								3581
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 391.0,
						"zoom_level": 1.0
					},
					"stack_index": 264,
					"type": "text"
				},
				{
					"buffer": 359,
					"file": "src/Falcor/Core/API/VAO.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3603,
						"regions":
						{
						},
						"selection":
						[
							[
								3603,
								3603
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 530.0,
						"zoom_level": 1.0
					},
					"stack_index": 226,
					"type": "text"
				},
				{
					"buffer": 360,
					"file": "src/Falcor/Core/API/Vulkan/VKBuffer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6579,
						"regions":
						{
						},
						"selection":
						[
							[
								5086,
								5086
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 408.0,
						"zoom_level": 1.0
					},
					"stack_index": 50,
					"type": "text"
				},
				{
					"buffer": 361,
					"file": "src/Falcor/Core/API/ComputeContext.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2998,
						"regions":
						{
						},
						"selection":
						[
							[
								1989,
								1989
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 309.0,
						"zoom_level": 1.0
					},
					"stack_index": 277,
					"type": "text"
				},
				{
					"buffer": 362,
					"file": "src/Falcor/Core/API/D3D12/D3D12ComputeContext.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6740,
						"regions":
						{
						},
						"selection":
						[
							[
								3585,
								3585
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 852.0,
						"zoom_level": 1.0
					},
					"stack_index": 379,
					"type": "text"
				},
				{
					"buffer": 363,
					"file": "src/Falcor/Core/API/D3D12/D3D12LowLevelContextData.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4664,
						"regions":
						{
						},
						"selection":
						[
							[
								2929,
								2929
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 775.0,
						"zoom_level": 1.0
					},
					"stack_index": 454,
					"type": "text"
				},
				{
					"buffer": 364,
					"file": "src/Falcor/Core/API/Vulkan/VKLowLevelContextData.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5608,
						"regions":
						{
						},
						"selection":
						[
							[
								4399,
								4399
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 663.0,
						"zoom_level": 1.0
					},
					"stack_index": 255,
					"type": "text"
				},
				{
					"buffer": 365,
					"file": "src/Falcor/Core/API/FencedPool.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4321,
						"regions":
						{
						},
						"selection":
						[
							[
								3683,
								3683
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 995.0,
						"zoom_level": 1.0
					},
					"stack_index": 265,
					"type": "text"
				},
				{
					"buffer": 366,
					"file": "src/Falcor/Core/API/Vulkan/VKComputeContext.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8062,
						"regions":
						{
						},
						"selection":
						[
							[
								2892,
								2892
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 105.0,
						"zoom_level": 1.0
					},
					"stack_index": 56,
					"type": "text"
				},
				{
					"buffer": 367,
					"file": "src/Tools/FalcorTest/Tests/Utils/MathHelpersTests.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 12262,
						"regions":
						{
						},
						"selection":
						[
							[
								9216,
								9216
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2856.0,
						"zoom_level": 1.0
					},
					"stack_index": 378,
					"type": "text"
				},
				{
					"buffer": 368,
					"file": "src/Falcor/Core/API/Vulkan/VKRenderContext.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 16737,
						"regions":
						{
						},
						"selection":
						[
							[
								2378,
								2378
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 350.0,
						"zoom_level": 1.0
					},
					"stack_index": 262,
					"type": "text"
				},
				{
					"buffer": 369,
					"file": "src/Falcor/RenderGraph/BasePasses/RasterPass.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2998,
						"regions":
						{
						},
						"selection":
						[
							[
								1900,
								1900
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 224,
					"type": "text"
				},
				{
					"buffer": 370,
					"file": "src/Falcor/RenderGraph/BasePasses/RasterPass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4407,
						"regions":
						{
						},
						"selection":
						[
							[
								4406,
								4406
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 306.0,
						"zoom_level": 1.0
					},
					"stack_index": 220,
					"type": "text"
				},
				{
					"buffer": 371,
					"file": "src/Falcor/Core/API/Vulkan/VKResourceViews.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13407,
						"regions":
						{
						},
						"selection":
						[
							[
								13307,
								13307
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4549.0,
						"zoom_level": 1.0
					},
					"stack_index": 38,
					"type": "text"
				},
				{
					"buffer": 372,
					"file": "src/RenderPasses/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3482,
						"regions":
						{
						},
						"selection":
						[
							[
								3314,
								3314
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 932.0,
						"zoom_level": 1.0
					},
					"stack_index": 331,
					"type": "text"
				},
				{
					"buffer": 373,
					"file": "/home/max/Desktop/gbuffer.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 574,
						"regions":
						{
						},
						"selection":
						[
							[
								141,
								141
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 332,
					"type": "text"
				},
				{
					"buffer": 374,
					"file": "src/RenderPasses/GBuffer/GBuffer/GBufferParams.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2388,
						"regions":
						{
						},
						"selection":
						[
							[
								2363,
								2363
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 327,
					"type": "text"
				},
				{
					"buffer": 375,
					"file": "src/Falcor/Utils/Threading.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2799,
						"regions":
						{
						},
						"selection":
						[
							[
								1945,
								1945
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 388.0,
						"zoom_level": 1.0
					},
					"stack_index": 212,
					"type": "text"
				},
				{
					"buffer": 376,
					"file": "src/Falcor/Utils/TermColor.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3484,
						"regions":
						{
						},
						"selection":
						[
							[
								2669,
								2669
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 663.0,
						"zoom_level": 1.0
					},
					"stack_index": 353,
					"type": "text"
				},
				{
					"buffer": 377,
					"file": "src/Falcor/Utils/TermColor.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2499,
						"regions":
						{
						},
						"selection":
						[
							[
								1843,
								1843
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 354,
					"type": "text"
				},
				{
					"buffer": 378,
					"file": "src/Falcor/Utils/Threading.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3003,
						"regions":
						{
						},
						"selection":
						[
							[
								2415,
								2415
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 507.0,
						"zoom_level": 1.0
					},
					"stack_index": 213,
					"type": "text"
				},
				{
					"buffer": 379,
					"file": "build/bin/Shaders/RenderPasses/BSDFViewer/BSDFViewer.cs.slang",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15202,
						"regions":
						{
						},
						"selection":
						[
							[
								13788,
								13788
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 5865.0,
						"zoom_level": 1.0
					},
					"stack_index": 366,
					"type": "text"
				},
				{
					"buffer": 380,
					"file": "src/RenderPasses/Utils/Utils.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2234,
						"regions":
						{
						},
						"selection":
						[
							[
								2234,
								2234
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 330,
					"type": "text"
				},
				{
					"buffer": 381,
					"file": "third_party/slang/tools/render-test/cuda/cuda-compute-util.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 53192,
						"regions":
						{
						},
						"selection":
						[
							[
								1255,
								1255
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 357.0,
						"zoom_level": 1.0
					},
					"stack_index": 450,
					"type": "text"
				},
				{
					"buffer": 382,
					"file": "src/Falcor/Core/API/Vulkan/VkSmartHandle.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6726,
						"regions":
						{
						},
						"selection":
						[
							[
								3921,
								3921
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1278.0,
						"zoom_level": 1.0
					},
					"stack_index": 39,
					"type": "text"
				},
				{
					"buffer": 383,
					"file": "src/Falcor/Core/API/Vulkan/VKRootSignature.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8750,
						"regions":
						{
						},
						"selection":
						[
							[
								4765,
								4765
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1006.0,
						"zoom_level": 1.0
					},
					"stack_index": 71,
					"type": "text"
				},
				{
					"buffer": 384,
					"file": "src/Falcor/Core/Program/ProgramVersion.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10447,
						"regions":
						{
						},
						"selection":
						[
							[
								6330,
								6330
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2178.0,
						"zoom_level": 1.0
					},
					"stack_index": 249,
					"type": "text"
				},
				{
					"buffer": 385,
					"file": "third_party/slang/examples/model-viewer/main.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 86920,
						"regions":
						{
						},
						"selection":
						[
							[
								7215,
								7215
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3835.0,
						"zoom_level": 1.0
					},
					"stack_index": 461,
					"type": "text"
				},
				{
					"buffer": 386,
					"file": "src/Falcor/Core/API/ResourceViews.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9621,
						"regions":
						{
						},
						"selection":
						[
							[
								3488,
								3488
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2315.0,
						"zoom_level": 1.0
					},
					"stack_index": 43,
					"type": "text"
				},
				{
					"buffer": 387,
					"file": "src/Falcor/Core/API/RootSignature.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6716,
						"regions":
						{
						},
						"selection":
						[
							[
								4554,
								4554
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1386.0,
						"zoom_level": 1.0
					},
					"stack_index": 65,
					"type": "text"
				},
				{
					"buffer": 388,
					"file": "src/Falcor/Core/API/RootSignature.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8993,
						"regions":
						{
						},
						"selection":
						[
							[
								4764,
								4764
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1261.0,
						"zoom_level": 1.0
					},
					"stack_index": 66,
					"type": "text"
				},
				{
					"buffer": 389,
					"file": "src/Falcor/Core/API/Vulkan/VKSampler.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2442,
						"regions":
						{
						},
						"selection":
						[
							[
								2415,
								2415
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 254,
					"type": "text"
				},
				{
					"buffer": 390,
					"file": "third_party/slang/tools/gfx/render.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 28476,
						"regions":
						{
						},
						"selection":
						[
							[
								14530,
								14530
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 9715.0,
						"zoom_level": 1.0
					},
					"stack_index": 453,
					"type": "text"
				},
				{
					"buffer": 391,
					"file": "src/Falcor/Core/API/Vulkan/FalcorVK.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5196,
						"regions":
						{
						},
						"selection":
						[
							[
								2936,
								2936
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 898.0,
						"zoom_level": 1.0
					},
					"stack_index": 18,
					"type": "text"
				},
				{
					"buffer": 392,
					"file": "src/Falcor/Core/API/Device.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11455,
						"regions":
						{
						},
						"selection":
						[
							[
								5103,
								5103
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 612.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 393,
					"file": "src/Falcor/Core/API/Device.cpp",
					"semi_transient": true,
					"settings":
					{
						"buffer_size": 17286,
						"regions":
						{
						},
						"selection":
						[
							[
								2124,
								2124
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 14,
					"type": "text"
				},
				{
					"buffer": 394,
					"file": "src/Falcor/Core/API/GpuMemoryHeap.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4090,
						"regions":
						{
						},
						"selection":
						[
							[
								3927,
								3927
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 938.0,
						"zoom_level": 1.0
					},
					"stack_index": 259,
					"type": "text"
				},
				{
					"buffer": 395,
					"file": "src/Falcor/Core/API/GpuMemoryHeap.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5126,
						"regions":
						{
						},
						"selection":
						[
							[
								4817,
								4817
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1428.0,
						"zoom_level": 1.0
					},
					"stack_index": 258,
					"type": "text"
				},
				{
					"buffer": 396,
					"file": "src/Falcor/Core/API/Vulkan/VKComputeStateObject.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2823,
						"regions":
						{
						},
						"selection":
						[
							[
								2798,
								2798
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 34,
					"type": "text"
				},
				{
					"buffer": 397,
					"file": "src/Falcor/Core/API/Vulkan/VKCopyContext.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 22189,
						"regions":
						{
						},
						"selection":
						[
							[
								11857,
								11857
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3587.0,
						"zoom_level": 1.0
					},
					"stack_index": 267,
					"type": "text"
				},
				{
					"buffer": 398,
					"file": "src/Falcor/Core/API/Vulkan/VKDescriptorPool.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5083,
						"regions":
						{
						},
						"selection":
						[
							[
								5083,
								5083
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 16,
					"type": "text"
				},
				{
					"buffer": 399,
					"file": "src/Falcor/Core/API/Vulkan/VKDescriptorSet.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7835,
						"regions":
						{
						},
						"selection":
						[
							[
								3804,
								3804
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 632.0,
						"zoom_level": 1.0
					},
					"stack_index": 63,
					"type": "text"
				},
				{
					"buffer": 400,
					"file": "src/Falcor/Core/API/Vulkan/VKDescriptorData.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2550,
						"regions":
						{
						},
						"selection":
						[
							[
								1712,
								1712
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 17,
					"type": "text"
				},
				{
					"buffer": 401,
					"file": "src/Falcor/Core/API/Vulkan/VKDeviceManager.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5792,
						"regions":
						{
						},
						"selection":
						[
							[
								4033,
								4033
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 255.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 402,
					"file": "src/Falcor/Core/API/DeviceManager.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3515,
						"regions":
						{
						},
						"selection":
						[
							[
								3210,
								3210
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 918.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 403,
					"file": "src/Falcor/Core/API/Vulkan/VKDevice.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 28956,
						"regions":
						{
						},
						"selection":
						[
							[
								26518,
								26518
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 9939.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 404,
					"file": "src/Falcor/Core/API/Vulkan/VKGpuFence.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10228,
						"regions":
						{
						},
						"selection":
						[
							[
								10027,
								10027
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 124.0,
						"zoom_level": 1.0
					},
					"stack_index": 15,
					"type": "text"
				},
				{
					"buffer": 405,
					"file": "src/Falcor/Core/API/Vulkan/VKGpuTimer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2646,
						"regions":
						{
						},
						"selection":
						[
							[
								1791,
								1791
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 153.0,
						"zoom_level": 1.0
					},
					"stack_index": 266,
					"type": "text"
				},
				{
					"buffer": 406,
					"file": "src/Falcor/Core/API/D3D12/D3D12GpuFence.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3766,
						"regions":
						{
						},
						"selection":
						[
							[
								3204,
								3204
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 714.0,
						"zoom_level": 1.0
					},
					"stack_index": 463,
					"type": "text"
				},
				{
					"buffer": 407,
					"file": "src/Falcor/Core/API/GpuFence.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3526,
						"regions":
						{
						},
						"selection":
						[
							[
								2490,
								2490
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 598.0,
						"zoom_level": 1.0
					},
					"stack_index": 268,
					"type": "text"
				},
				{
					"buffer": 408,
					"file": "src/Falcor/Core/API/Vulkan/VKSmartHandle.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9756,
						"regions":
						{
						},
						"selection":
						[
							[
								3141,
								3141
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3335.0,
						"zoom_level": 1.0
					},
					"stack_index": 40,
					"type": "text"
				},
				{
					"buffer": 409,
					"file": "src/Falcor/Core/API/Vulkan/VKState.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 27538,
						"regions":
						{
						},
						"selection":
						[
							[
								2463,
								2463
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 9370.0,
						"zoom_level": 1.0
					},
					"stack_index": 240,
					"type": "text"
				},
				{
					"buffer": 410,
					"file": "src/Falcor/Core/API/Vulkan/VKTexture.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7857,
						"regions":
						{
						},
						"selection":
						[
							[
								7442,
								7442
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1799.0,
						"zoom_level": 1.0
					},
					"stack_index": 69,
					"type": "text"
				},
				{
					"buffer": 411,
					"file": "falcor.sublime-project",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2302,
						"regions":
						{
						},
						"selection":
						[
							[
								2299,
								2299
							]
						],
						"settings":
						{
							"syntax": "Packages/JavaScript/JSON.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 35,
					"type": "text"
				},
				{
					"buffer": 412,
					"file": "third_party/slang/external/vulkan/include/vulkan/vulkan.hpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2369181,
						"regions":
						{
						},
						"selection":
						[
							[
								509353,
								509353
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 193521.0,
						"zoom_level": 1.0
					},
					"stack_index": 419,
					"type": "text"
				},
				{
					"buffer": 413,
					"file": "/usr/include/vulkan/vulkan.hpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4010350,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 452,
					"type": "text"
				},
				{
					"buffer": 414,
					"file": "third_party/slang/external/vulkan/include/vulkan/vulkan_core.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 451013,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 436,
					"type": "text"
				},
				{
					"buffer": 415,
					"file": "src/Falcor/Utils/Math/FalcorMath.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8456,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 464,
					"type": "text"
				},
				{
					"buffer": 416,
					"file": "src/Falcor/Core/Framework.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13038,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 561.0,
						"zoom_level": 1.0
					},
					"stack_index": 55,
					"type": "text"
				},
				{
					"buffer": 417,
					"file": "src/Falcor/Core/type.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6550,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 360,
					"type": "text"
				},
				{
					"buffer": 418,
					"file": "src/Falcor/Core/Framework.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2253,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 244,
					"type": "text"
				},
				{
					"buffer": 419,
					"file": "src/Falcor/Core/API/CopyContext.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7675,
						"regions":
						{
						},
						"selection":
						[
							[
								7554,
								7554
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2193.0,
						"zoom_level": 1.0
					},
					"stack_index": 271,
					"type": "text"
				},
				{
					"buffer": 420,
					"file": "src/Falcor/Core/API/VertexLayout.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1862,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 225,
					"type": "text"
				},
				{
					"buffer": 421,
					"file": "src/Falcor/Core/FalcorConfig.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2544,
						"regions":
						{
						},
						"selection":
						[
							[
								2500,
								2500
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 54,
					"type": "text"
				},
				{
					"buffer": 422,
					"file": "src/Falcor/RenderGraph/RenderPassStandardFlags.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2479,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 443,
					"type": "text"
				},
				{
					"buffer": 423,
					"file": "src/Falcor/Falcor.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6959,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 324,
					"type": "text"
				},
				{
					"buffer": 424,
					"file": "src/Falcor/Utils/Debug/PixelDebug.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5769,
						"regions":
						{
						},
						"selection":
						[
							[
								5769,
								5769
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1326.0,
						"zoom_level": 1.0
					},
					"stack_index": 189,
					"type": "text"
				},
				{
					"buffer": 425,
					"file": "src/Falcor/Utils/Image/Bitmap.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6060,
						"regions":
						{
						},
						"selection":
						[
							[
								3538,
								3538
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1326.0,
						"zoom_level": 1.0
					},
					"stack_index": 188,
					"type": "text"
				},
				{
					"buffer": 426,
					"file": "src/Falcor/Utils/Image/Bitmap.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 21119,
						"regions":
						{
						},
						"selection":
						[
							[
								7400,
								7400
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2612.0,
						"zoom_level": 1.0
					},
					"stack_index": 187,
					"type": "text"
				},
				{
					"buffer": 427,
					"file": "src/Falcor/Utils/Scripting/ScriptBindings.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10241,
						"regions":
						{
						},
						"selection":
						[
							[
								5773,
								5773
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1634.0,
						"zoom_level": 1.0
					},
					"stack_index": 19,
					"type": "text"
				},
				{
					"buffer": 428,
					"file": "/home/max/Desktop/compos.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1267,
						"regions":
						{
						},
						"selection":
						[
							[
								1205,
								1205
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 36,
					"type": "text"
				},
				{
					"buffer": 429,
					"file": "src/Falcor/Utils/Scripting/Console.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2101,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 32,
					"type": "text"
				},
				{
					"buffer": 430,
					"file": "src/Falcor/Utils/Scripting/Scripting.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5726,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1377.0,
						"zoom_level": 1.0
					},
					"stack_index": 29,
					"type": "text"
				},
				{
					"buffer": 431,
					"file": "src/Falcor/Core/API/DescriptorPool.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5596,
						"regions":
						{
						},
						"selection":
						[
							[
								3627,
								3627
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1275.0,
						"zoom_level": 1.0
					},
					"stack_index": 68,
					"type": "text"
				},
				{
					"buffer": 432,
					"file": "src/Falcor/Core/API/DescriptorPool.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2683,
						"regions":
						{
						},
						"selection":
						[
							[
								2157,
								2157
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 67,
					"type": "text"
				},
				{
					"buffer": 433,
					"file": "src/Falcor/Core/State/GraphicsState.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10063,
						"regions":
						{
						},
						"selection":
						[
							[
								9145,
								9145
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3188.0,
						"zoom_level": 1.0
					},
					"stack_index": 233,
					"type": "text"
				},
				{
					"buffer": 434,
					"file": "src/Falcor/Core/State/GraphicsState.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8458,
						"regions":
						{
						},
						"selection":
						[
							[
								2784,
								2784
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 451.0,
						"zoom_level": 1.0
					},
					"stack_index": 230,
					"type": "text"
				},
				{
					"buffer": 435,
					"file": "src/Falcor/Core/State/ComputeState.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3405,
						"regions":
						{
						},
						"selection":
						[
							[
								2529,
								2529
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 153.0,
						"zoom_level": 1.0
					},
					"stack_index": 242,
					"type": "text"
				},
				{
					"buffer": 436,
					"file": "src/Falcor/Core/API/ComputeStateObject.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2465,
						"regions":
						{
						},
						"selection":
						[
							[
								2089,
								2089
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 234,
					"type": "text"
				},
				{
					"buffer": 437,
					"file": "src/Falcor/Core/API/GpuTimer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4479,
						"regions":
						{
						},
						"selection":
						[
							[
								3328,
								3328
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 459.0,
						"zoom_level": 1.0
					},
					"stack_index": 273,
					"type": "text"
				},
				{
					"buffer": 438,
					"file": "src/Falcor/Core/State/ComputeState.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3782,
						"regions":
						{
						},
						"selection":
						[
							[
								2662,
								2662
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 349.0,
						"zoom_level": 1.0
					},
					"stack_index": 243,
					"type": "text"
				},
				{
					"buffer": 439,
					"file": "src/Falcor/Core/State/StateGraph.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4323,
						"regions":
						{
						},
						"selection":
						[
							[
								4098,
								4098
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 102.0,
						"zoom_level": 1.0
					},
					"stack_index": 237,
					"type": "text"
				},
				{
					"buffer": 440,
					"file": "src/Falcor/Raytracing/RtProgram/RtProgram.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7986,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 467,
					"type": "text"
				},
				{
					"buffer": 441,
					"file": "src/Falcor/Raytracing/RtProgram/RtProgram.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6561,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 466,
					"type": "text"
				},
				{
					"buffer": 442,
					"file": "src/Mogwai/AppData.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2896,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 408.0,
						"zoom_level": 1.0
					},
					"stack_index": 182,
					"type": "text"
				},
				{
					"buffer": 443,
					"file": "src/Falcor/Core/Platform/Linux/ProgressBarLinux.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5059,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 457,
					"type": "text"
				},
				{
					"buffer": 444,
					"file": "src/Mogwai/AppData.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5386,
						"regions":
						{
						},
						"selection":
						[
							[
								2276,
								2276
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 714.0,
						"zoom_level": 1.0
					},
					"stack_index": 167,
					"type": "text"
				},
				{
					"buffer": 445,
					"file": "src/Mogwai/Extensions/Capture/CaptureTrigger.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3849,
						"regions":
						{
						},
						"selection":
						[
							[
								3848,
								3848
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 357.0,
						"zoom_level": 1.0
					},
					"stack_index": 83,
					"type": "text"
				},
				{
					"buffer": 446,
					"file": "src/Falcor/Core/Sample.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 24618,
						"regions":
						{
						},
						"selection":
						[
							[
								9993,
								9993
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4080.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 447,
					"file": "src/Falcor/Core/API/VertexLayout.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7327,
						"regions":
						{
						},
						"selection":
						[
							[
								7087,
								7087
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1977.0,
						"zoom_level": 1.0
					},
					"stack_index": 24,
					"type": "text"
				},
				{
					"buffer": 448,
					"file": "src/Falcor/Core/API/DeviceManager.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4871,
						"regions":
						{
						},
						"selection":
						[
							[
								2044,
								2044
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 349.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 449,
					"file": "src/Falcor/Core/API/Vulkan/VkQueryHeap.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2779,
						"regions":
						{
						},
						"selection":
						[
							[
								2659,
								2659
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 190.0,
						"zoom_level": 1.0
					},
					"stack_index": 46,
					"type": "text"
				},
				{
					"buffer": 450,
					"file": "src/Falcor/Core/API/D3D12/D3D12Device.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15156,
						"regions":
						{
						},
						"selection":
						[
							[
								11323,
								11323
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4233.0,
						"zoom_level": 1.0
					},
					"stack_index": 279,
					"type": "text"
				},
				{
					"buffer": 451,
					"file": "src/Falcor/Core/API/DescriptorSet.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5856,
						"regions":
						{
						},
						"selection":
						[
							[
								5033,
								5033
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1173.0,
						"zoom_level": 1.0
					},
					"stack_index": 72,
					"type": "text"
				},
				{
					"buffer": 452,
					"file": "src/Falcor/Core/API/DescriptorSet.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2618,
						"regions":
						{
						},
						"selection":
						[
							[
								2546,
								2546
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 70,
					"type": "text"
				},
				{
					"buffer": 453,
					"file": "src/Falcor/Core/API/ResourceViews.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5611,
						"regions":
						{
						},
						"selection":
						[
							[
								2562,
								2562
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 853.0,
						"zoom_level": 1.0
					},
					"stack_index": 44,
					"type": "text"
				},
				{
					"buffer": 454,
					"file": "Falcor.sln",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 19418,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 465,
					"type": "text"
				},
				{
					"buffer": 455,
					"file": "src/Falcor/Scene/Scene.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 25118,
						"regions":
						{
						},
						"selection":
						[
							[
								7107,
								7107
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 180,
					"type": "text"
				},
				{
					"buffer": 456,
					"file": "src/Falcor/RenderGraph/RenderGraphUI.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8554,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 434,
					"type": "text"
				},
				{
					"buffer": 457,
					"file": "src/Falcor/RenderGraph/RenderGraph.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11413,
						"regions":
						{
						},
						"selection":
						[
							[
								2635,
								2635
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1938.0,
						"zoom_level": 1.0
					},
					"stack_index": 11,
					"type": "text"
				},
				{
					"buffer": 458,
					"file": "src/Falcor/RenderGraph/ResourceCache.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5357,
						"regions":
						{
						},
						"selection":
						[
							[
								5357,
								5357
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 663.0,
						"zoom_level": 1.0
					},
					"stack_index": 216,
					"type": "text"
				},
				{
					"buffer": 459,
					"file": "src/Falcor/RenderGraph/BasePasses/RasterScenePass.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4422,
						"regions":
						{
						},
						"selection":
						[
							[
								4185,
								4185
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 306.0,
						"zoom_level": 1.0
					},
					"stack_index": 223,
					"type": "text"
				},
				{
					"buffer": 460,
					"file": "src/Falcor/Utils/Debug/DebugConsole.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4292,
						"regions":
						{
						},
						"selection":
						[
							[
								2156,
								2156
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 143.0,
						"zoom_level": 1.0
					},
					"stack_index": 341,
					"type": "text"
				},
				{
					"buffer": 461,
					"file": "src/Falcor/Scene/SceneBuilder.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11802,
						"regions":
						{
						},
						"selection":
						[
							[
								10308,
								10308
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3159.0,
						"zoom_level": 1.0
					},
					"stack_index": 205,
					"type": "text"
				},
				{
					"buffer": 462,
					"file": "src/Falcor/Utils/Debug/debug.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2463,
						"regions":
						{
						},
						"selection":
						[
							[
								2269,
								2269
							]
						],
						"settings":
						{
							"auto_name": "#ifndef __FALCOR_DEBUG_H__",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 41.0,
						"zoom_level": 1.0
					},
					"stack_index": 342,
					"type": "text"
				},
				{
					"buffer": 463,
					"file": "src/Falcor/Core/BufferTypes/ParameterBlock.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 20399,
						"regions":
						{
						},
						"selection":
						[
							[
								16343,
								16343
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 636.0,
						"zoom_level": 1.0
					},
					"stack_index": 57,
					"type": "text"
				},
				{
					"buffer": 464,
					"file": "src/Falcor/Scene/Scene.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 49068,
						"regions":
						{
						},
						"selection":
						[
							[
								5996,
								5996
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1862.0,
						"zoom_level": 1.0
					},
					"stack_index": 153,
					"type": "text"
				},
				{
					"buffer": 465,
					"file": "src/Falcor/Scene/Camera/CameraController.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9863,
						"regions":
						{
						},
						"selection":
						[
							[
								9668,
								9668
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3353.0,
						"zoom_level": 1.0
					},
					"stack_index": 165,
					"type": "text"
				},
				{
					"buffer": 466,
					"file": "src/Falcor/Scene/Camera/Camera.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13365,
						"regions":
						{
						},
						"selection":
						[
							[
								11054,
								11054
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3829.0,
						"zoom_level": 1.0
					},
					"stack_index": 164,
					"type": "text"
				},
				{
					"buffer": 467,
					"file": "src/Falcor/Core/API/D3D12/D3D12Resource.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6227,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 462,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 38.0
	},
	"input":
	{
		"height": 38.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.SublimeLinter":
	{
		"height": 0.0
	},
	"output.find_results":
	{
		"height": 120.0
	},
	"output.unsaved_changes":
	{
		"height": 120.0
	},
	"pinned_build_system": "Packages/Makefile/Make.sublime-build",
	"project": "falcor.sublime-project",
	"replace":
	{
		"height": 70.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 419.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
